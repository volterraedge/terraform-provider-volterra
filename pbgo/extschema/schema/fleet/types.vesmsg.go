//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package fleet

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_bgp "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/bgp"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *BGPConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BGPConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BGPConfiguration) DeepCopy() *BGPConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BGPConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BGPConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BGPConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BGPConfigurationValidator().Validate(ctx, m, opts...)
}

func (m *BGPConfiguration) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetPeersDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *BGPConfiguration) GetPeersDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetPeers() == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.GetPeers() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("peers[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateBGPConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBGPConfiguration) PeersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_bgp.Peer, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema_bgp.PeerValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for peers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_bgp.Peer)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_bgp.Peer, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated peers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items peers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBGPConfiguration) AsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for asn")
	}

	return validatorFn, nil
}

func (v *ValidateBGPConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BGPConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BGPConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn"]; exists {

		vOpts := append(opts, db.WithValidateField("asn"))
		if err := fv(ctx, m.GetAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["peers"]; exists {
		vOpts := append(opts, db.WithValidateField("peers"))
		if err := fv(ctx, m.GetPeers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBGPConfigurationValidator = func() *ValidateBGPConfiguration {
	v := &ValidateBGPConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPeers := v.PeersValidationRuleHandler
	rulesPeers := map[string]string{
		"ves.io.schema.rules.repeated.max_items":            "8",
		"ves.io.schema.rules.repeated.unique_metadata_name": "true",
	}
	vFn, err = vrhPeers(rulesPeers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BGPConfiguration.peers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["peers"] = vFn

	vrhAsn := v.AsnValidationRuleHandler
	rulesAsn := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
	}
	vFn, err = vrhAsn(rulesAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BGPConfiguration.asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn"] = vFn

	return v
}()

func BGPConfigurationValidator() db.Validator {
	return DefaultBGPConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *BondLacpType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BondLacpType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BondLacpType) DeepCopy() *BondLacpType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BondLacpType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BondLacpType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BondLacpType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BondLacpTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBondLacpType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBondLacpType) RateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for rate")
	}

	return validatorFn, nil
}

func (v *ValidateBondLacpType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BondLacpType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BondLacpType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["rate"]; exists {

		vOpts := append(opts, db.WithValidateField("rate"))
		if err := fv(ctx, m.GetRate(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBondLacpTypeValidator = func() *ValidateBondLacpType {
	v := &ValidateBondLacpType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRate := v.RateValidationRuleHandler
	rulesRate := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "30",
	}
	vFn, err = vrhRate(rulesRate)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BondLacpType.rate: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate"] = vFn

	return v
}()

func BondLacpTypeValidator() db.Validator {
	return DefaultBondLacpTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetStorageDeviceList().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.storage_device_list")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDcClusterGroupChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInsideVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkConnectorsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkFirewallDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOutsideVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStorageInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStorageStaticRoutesChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUsbPolicyChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *CreateSpecType) GetDcClusterGroupChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetDcClusterGroupChoice().(type) {
	case *CreateSpecType_NoDcClusterGroup:

	case *CreateSpecType_DcClusterGroup:

		vref := m.GetDcClusterGroup()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		odri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	case *CreateSpecType_DcClusterGroupInside:

		vref := m.GetDcClusterGroupInside()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		odri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_inside",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetDcClusterGroupChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetDcClusterGroupChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetDcClusterGroupChoice().(type) {
	case *CreateSpecType_NoDcClusterGroup:

	case *CreateSpecType_DcClusterGroup:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroup()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *CreateSpecType_DcClusterGroupInside:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupInside()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *CreateSpecType) GetInsideVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetInsideVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.inside_virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "inside_virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetInsideVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetInsideVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetInsideVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetInterfaceChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetInterfaceChoice().(type) {
	case *CreateSpecType_InterfaceList:
		odrInfos, err = m.GetInterfaceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "interface_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *CreateSpecType_DeviceList:
		odrInfos, err = m.GetDeviceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "device_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *CreateSpecType_DefaultConfig:

	}

	return drInfos, err
}

func (m *CreateSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetLogsReceiverChoice().(type) {
	case *CreateSpecType_LogsStreamingDisabled:

	case *CreateSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		odri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *CreateSpecType_LogsStreamingDisabled:

	case *CreateSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *CreateSpecType) GetNetworkConnectorsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetNetworkConnectors() {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.network_connectors[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_connector.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network_connectors",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetNetworkConnectorsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetNetworkConnectorsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_connector.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_connector")
	}
	for _, ref := range m.GetNetworkConnectors() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetNetworkFirewallDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetNetworkFirewall() {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.network_firewall[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_firewall.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network_firewall",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetNetworkFirewallDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetNetworkFirewallDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_firewall.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_firewall")
	}
	for _, ref := range m.GetNetworkFirewall() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetOutsideVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetOutsideVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.outside_virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "outside_virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetOutsideVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetOutsideVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetOutsideVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetStorageInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetStorageInterfaceChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetStorageInterfaceChoice().(type) {
	case *CreateSpecType_NoStorageInterfaces:

	case *CreateSpecType_StorageInterfaceList:
		odrInfos, err = m.GetStorageInterfaceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "storage_interface_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetStorageStaticRoutesChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetStorageStaticRoutesChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetStorageStaticRoutesChoice().(type) {
	case *CreateSpecType_NoStorageStaticRoutes:

	case *CreateSpecType_StorageStaticRoutes:
		odrInfos, err = m.GetStorageStaticRoutes().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "storage_static_routes." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

func (m *CreateSpecType) GetUsbPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetUsbPolicyChoice().(type) {
	case *CreateSpecType_DenyAllUsb:

	case *CreateSpecType_AllowAllUsb:

	case *CreateSpecType_UsbPolicy:

		vref := m.GetUsbPolicy()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("usb_policy.Object")
		odri := db.DRefInfo{
			RefdType:   "usb_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "usb_policy",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetUsbPolicyChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetUsbPolicyChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetUsbPolicyChoice().(type) {
	case *CreateSpecType_DenyAllUsb:

	case *CreateSpecType_AllowAllUsb:

	case *CreateSpecType_UsbPolicy:
		refdType, err := d.TypeForEntryKind("", "", "usb_policy.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: usb_policy")
		}

		vref := m.GetUsbPolicy()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "usb_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) BondChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bond_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) DcClusterGroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dc_cluster_group_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) GpuChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for gpu_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) StorageClassChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_class_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) StorageDeviceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_device_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) StorageInterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) StorageStaticRoutesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_static_routes_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) UsbPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for usb_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) FleetLabelValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fleet_label")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) NetworkConnectorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for network_connectors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated network_connectors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items network_connectors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) NetworkFirewallValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for network_firewall")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated network_firewall")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items network_firewall")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OutsideVirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for outside_virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated outside_virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items outside_virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) InsideVirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for inside_virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated inside_virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items inside_virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bond_choice"]; exists {
		val := m.GetBondChoice()
		vOpts := append(opts,
			db.WithValidateField("bond_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBondChoice().(type) {
	case *CreateSpecType_NoBondDevices:
		if fv, exists := v.FldValidators["bond_choice.no_bond_devices"]; exists {
			val := m.GetBondChoice().(*CreateSpecType_NoBondDevices).NoBondDevices
			vOpts := append(opts,
				db.WithValidateField("bond_choice"),
				db.WithValidateField("no_bond_devices"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_BondDeviceList:
		if fv, exists := v.FldValidators["bond_choice.bond_device_list"]; exists {
			val := m.GetBondChoice().(*CreateSpecType_BondDeviceList).BondDeviceList
			vOpts := append(opts,
				db.WithValidateField("bond_choice"),
				db.WithValidateField("bond_device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dc_cluster_group_choice"]; exists {
		val := m.GetDcClusterGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("dc_cluster_group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDcClusterGroupChoice().(type) {
	case *CreateSpecType_NoDcClusterGroup:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.no_dc_cluster_group"]; exists {
			val := m.GetDcClusterGroupChoice().(*CreateSpecType_NoDcClusterGroup).NoDcClusterGroup
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("no_dc_cluster_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DcClusterGroup:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group"]; exists {
			val := m.GetDcClusterGroupChoice().(*CreateSpecType_DcClusterGroup).DcClusterGroup
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DcClusterGroupInside:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside"]; exists {
			val := m.GetDcClusterGroupChoice().(*CreateSpecType_DcClusterGroupInside).DcClusterGroupInside
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group_inside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enable_default_fleet_config_download"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_default_fleet_config_download"))
		if err := fv(ctx, m.GetEnableDefaultFleetConfigDownload(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fleet_label"]; exists {

		vOpts := append(opts, db.WithValidateField("fleet_label"))
		if err := fv(ctx, m.GetFleetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gpu_choice"]; exists {
		val := m.GetGpuChoice()
		vOpts := append(opts,
			db.WithValidateField("gpu_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGpuChoice().(type) {
	case *CreateSpecType_DisableGpu:
		if fv, exists := v.FldValidators["gpu_choice.disable_gpu"]; exists {
			val := m.GetGpuChoice().(*CreateSpecType_DisableGpu).DisableGpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("disable_gpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_EnableGpu:
		if fv, exists := v.FldValidators["gpu_choice.enable_gpu"]; exists {
			val := m.GetGpuChoice().(*CreateSpecType_EnableGpu).EnableGpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("enable_gpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_EnableVgpu:
		if fv, exists := v.FldValidators["gpu_choice.enable_vgpu"]; exists {
			val := m.GetGpuChoice().(*CreateSpecType_EnableVgpu).EnableVgpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("enable_vgpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["inside_virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("inside_virtual_network"))
		if err := fv(ctx, m.GetInsideVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *CreateSpecType_InterfaceList:
		if fv, exists := v.FldValidators["interface_choice.interface_list"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_InterfaceList).InterfaceList
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("interface_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DeviceList:
		if fv, exists := v.FldValidators["interface_choice.device_list"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_DeviceList).DeviceList
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DefaultConfig:
		if fv, exists := v.FldValidators["interface_choice.default_config"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_DefaultConfig).DefaultConfig
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("default_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *CreateSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*CreateSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*CreateSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_connectors"]; exists {
		vOpts := append(opts, db.WithValidateField("network_connectors"))
		if err := fv(ctx, m.GetNetworkConnectors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_firewall"]; exists {
		vOpts := append(opts, db.WithValidateField("network_firewall"))
		if err := fv(ctx, m.GetNetworkFirewall(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("outside_virtual_network"))
		if err := fv(ctx, m.GetOutsideVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_class_choice"]; exists {
		val := m.GetStorageClassChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_class_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageClassChoice().(type) {
	case *CreateSpecType_DefaultStorageClass:
		if fv, exists := v.FldValidators["storage_class_choice.default_storage_class"]; exists {
			val := m.GetStorageClassChoice().(*CreateSpecType_DefaultStorageClass).DefaultStorageClass
			vOpts := append(opts,
				db.WithValidateField("storage_class_choice"),
				db.WithValidateField("default_storage_class"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_StorageClassList:
		if fv, exists := v.FldValidators["storage_class_choice.storage_class_list"]; exists {
			val := m.GetStorageClassChoice().(*CreateSpecType_StorageClassList).StorageClassList
			vOpts := append(opts,
				db.WithValidateField("storage_class_choice"),
				db.WithValidateField("storage_class_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_device_choice"]; exists {
		val := m.GetStorageDeviceChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_device_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageDeviceChoice().(type) {
	case *CreateSpecType_NoStorageDevice:
		if fv, exists := v.FldValidators["storage_device_choice.no_storage_device"]; exists {
			val := m.GetStorageDeviceChoice().(*CreateSpecType_NoStorageDevice).NoStorageDevice
			vOpts := append(opts,
				db.WithValidateField("storage_device_choice"),
				db.WithValidateField("no_storage_device"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_StorageDeviceList:
		if fv, exists := v.FldValidators["storage_device_choice.storage_device_list"]; exists {
			val := m.GetStorageDeviceChoice().(*CreateSpecType_StorageDeviceList).StorageDeviceList
			vOpts := append(opts,
				db.WithValidateField("storage_device_choice"),
				db.WithValidateField("storage_device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_interface_choice"]; exists {
		val := m.GetStorageInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageInterfaceChoice().(type) {
	case *CreateSpecType_NoStorageInterfaces:
		if fv, exists := v.FldValidators["storage_interface_choice.no_storage_interfaces"]; exists {
			val := m.GetStorageInterfaceChoice().(*CreateSpecType_NoStorageInterfaces).NoStorageInterfaces
			vOpts := append(opts,
				db.WithValidateField("storage_interface_choice"),
				db.WithValidateField("no_storage_interfaces"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_StorageInterfaceList:
		if fv, exists := v.FldValidators["storage_interface_choice.storage_interface_list"]; exists {
			val := m.GetStorageInterfaceChoice().(*CreateSpecType_StorageInterfaceList).StorageInterfaceList
			vOpts := append(opts,
				db.WithValidateField("storage_interface_choice"),
				db.WithValidateField("storage_interface_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_static_routes_choice"]; exists {
		val := m.GetStorageStaticRoutesChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_static_routes_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageStaticRoutesChoice().(type) {
	case *CreateSpecType_NoStorageStaticRoutes:
		if fv, exists := v.FldValidators["storage_static_routes_choice.no_storage_static_routes"]; exists {
			val := m.GetStorageStaticRoutesChoice().(*CreateSpecType_NoStorageStaticRoutes).NoStorageStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("storage_static_routes_choice"),
				db.WithValidateField("no_storage_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_StorageStaticRoutes:
		if fv, exists := v.FldValidators["storage_static_routes_choice.storage_static_routes"]; exists {
			val := m.GetStorageStaticRoutesChoice().(*CreateSpecType_StorageStaticRoutes).StorageStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("storage_static_routes_choice"),
				db.WithValidateField("storage_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["usb_policy_choice"]; exists {
		val := m.GetUsbPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("usb_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetUsbPolicyChoice().(type) {
	case *CreateSpecType_DenyAllUsb:
		if fv, exists := v.FldValidators["usb_policy_choice.deny_all_usb"]; exists {
			val := m.GetUsbPolicyChoice().(*CreateSpecType_DenyAllUsb).DenyAllUsb
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("deny_all_usb"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AllowAllUsb:
		if fv, exists := v.FldValidators["usb_policy_choice.allow_all_usb"]; exists {
			val := m.GetUsbPolicyChoice().(*CreateSpecType_AllowAllUsb).AllowAllUsb
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("allow_all_usb"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_UsbPolicy:
		if fv, exists := v.FldValidators["usb_policy_choice.usb_policy"]; exists {
			val := m.GetUsbPolicyChoice().(*CreateSpecType_UsbPolicy).UsbPolicy
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("usb_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBondChoice := v.BondChoiceValidationRuleHandler
	rulesBondChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBondChoice(rulesBondChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.bond_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bond_choice"] = vFn

	vrhDcClusterGroupChoice := v.DcClusterGroupChoiceValidationRuleHandler
	rulesDcClusterGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDcClusterGroupChoice(rulesDcClusterGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.dc_cluster_group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dc_cluster_group_choice"] = vFn

	vrhGpuChoice := v.GpuChoiceValidationRuleHandler
	rulesGpuChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhGpuChoice(rulesGpuChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.gpu_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["gpu_choice"] = vFn

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhStorageClassChoice := v.StorageClassChoiceValidationRuleHandler
	rulesStorageClassChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageClassChoice(rulesStorageClassChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.storage_class_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_class_choice"] = vFn

	vrhStorageDeviceChoice := v.StorageDeviceChoiceValidationRuleHandler
	rulesStorageDeviceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageDeviceChoice(rulesStorageDeviceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.storage_device_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_device_choice"] = vFn

	vrhStorageInterfaceChoice := v.StorageInterfaceChoiceValidationRuleHandler
	rulesStorageInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageInterfaceChoice(rulesStorageInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.storage_interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_interface_choice"] = vFn

	vrhStorageStaticRoutesChoice := v.StorageStaticRoutesChoiceValidationRuleHandler
	rulesStorageStaticRoutesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageStaticRoutesChoice(rulesStorageStaticRoutesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.storage_static_routes_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_static_routes_choice"] = vFn

	vrhUsbPolicyChoice := v.UsbPolicyChoiceValidationRuleHandler
	rulesUsbPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhUsbPolicyChoice(rulesUsbPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.usb_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["usb_policy_choice"] = vFn

	vrhFleetLabel := v.FleetLabelValidationRuleHandler
	rulesFleetLabel := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.k8s_label_value": "true",
	}
	vFn, err = vrhFleetLabel(rulesFleetLabel)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.fleet_label: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fleet_label"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhNetworkConnectors := v.NetworkConnectorsValidationRuleHandler
	rulesNetworkConnectors := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
	}
	vFn, err = vrhNetworkConnectors(rulesNetworkConnectors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.network_connectors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_connectors"] = vFn

	vrhNetworkFirewall := v.NetworkFirewallValidationRuleHandler
	rulesNetworkFirewall := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhNetworkFirewall(rulesNetworkFirewall)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.network_firewall: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_firewall"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhOutsideVirtualNetwork := v.OutsideVirtualNetworkValidationRuleHandler
	rulesOutsideVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhOutsideVirtualNetwork(rulesOutsideVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.outside_virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_virtual_network"] = vFn

	vrhInsideVirtualNetwork := v.InsideVirtualNetworkValidationRuleHandler
	rulesInsideVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhInsideVirtualNetwork(rulesInsideVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.inside_virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_virtual_network"] = vFn

	v.FldValidators["bond_choice.bond_device_list"] = FleetBondDevicesListTypeValidator().Validate

	v.FldValidators["dc_cluster_group_choice.dc_cluster_group"] = ves_io_schema_views.ObjectRefTypeValidator().Validate
	v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["gpu_choice.enable_vgpu"] = VGPUConfigurationValidator().Validate

	v.FldValidators["interface_choice.interface_list"] = FleetInterfaceListTypeValidator().Validate
	v.FldValidators["interface_choice.device_list"] = FleetDeviceListTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["storage_class_choice.storage_class_list"] = FleetStorageClassListTypeValidator().Validate

	v.FldValidators["storage_device_choice.storage_device_list"] = FleetStorageDeviceListTypeValidator().Validate

	v.FldValidators["storage_interface_choice.storage_interface_list"] = FleetInterfaceListTypeValidator().Validate

	v.FldValidators["storage_static_routes_choice.storage_static_routes"] = FleetStorageStaticRoutesListTypeValidator().Validate

	v.FldValidators["usb_policy_choice.usb_policy"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeviceInstanceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeviceInstanceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeviceInstanceType) DeepCopy() *DeviceInstanceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeviceInstanceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeviceInstanceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeviceInstanceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeviceInstanceTypeValidator().Validate(ctx, m, opts...)
}

func (m *DeviceInstanceType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDeviceInstanceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *DeviceInstanceType) GetDeviceInstanceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetDeviceInstance() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetDeviceInstance().(type) {
	case *DeviceInstanceType_NetworkDevice:
		odrInfos, err = m.GetNetworkDevice().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "network_device." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

type ValidateDeviceInstanceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeviceInstanceType) DeviceInstanceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device_instance")
	}
	return validatorFn, nil
}

func (v *ValidateDeviceInstanceType) OwnerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(DeviceOwnerType)
		return int32(i)
	}
	// DeviceOwnerType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, DeviceOwnerType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for owner")
	}

	return validatorFn, nil
}

func (v *ValidateDeviceInstanceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeviceInstanceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeviceInstanceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device_instance"]; exists {
		val := m.GetDeviceInstance()
		vOpts := append(opts,
			db.WithValidateField("device_instance"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDeviceInstance().(type) {
	case *DeviceInstanceType_NetworkDevice:
		if fv, exists := v.FldValidators["device_instance.network_device"]; exists {
			val := m.GetDeviceInstance().(*DeviceInstanceType_NetworkDevice).NetworkDevice
			vOpts := append(opts,
				db.WithValidateField("device_instance"),
				db.WithValidateField("network_device"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["owner"]; exists {

		vOpts := append(opts, db.WithValidateField("owner"))
		if err := fv(ctx, m.GetOwner(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeviceInstanceTypeValidator = func() *ValidateDeviceInstanceType {
	v := &ValidateDeviceInstanceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDeviceInstance := v.DeviceInstanceValidationRuleHandler
	rulesDeviceInstance := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDeviceInstance(rulesDeviceInstance)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeviceInstanceType.device_instance: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_instance"] = vFn

	vrhOwner := v.OwnerValidationRuleHandler
	rulesOwner := map[string]string{
		"ves.io.schema.rules.enum.in":          "[1]",
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOwner(rulesOwner)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeviceInstanceType.owner: %s", err)
		panic(errMsg)
	}
	v.FldValidators["owner"] = vFn

	v.FldValidators["device_instance.network_device"] = NetworkingDeviceInstanceTypeValidator().Validate

	return v
}()

func DeviceInstanceTypeValidator() db.Validator {
	return DefaultDeviceInstanceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeviceNetappBackendOntapSanChapType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeviceNetappBackendOntapSanChapType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *DeviceNetappBackendOntapSanChapType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetChapInitiatorSecret().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting DeviceNetappBackendOntapSanChapType.chap_initiator_secret")
	}

	if err := m.GetChapTargetInitiatorSecret().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting DeviceNetappBackendOntapSanChapType.chap_target_initiator_secret")
	}

	return nil
}

func (m *DeviceNetappBackendOntapSanChapType) DeepCopy() *DeviceNetappBackendOntapSanChapType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeviceNetappBackendOntapSanChapType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeviceNetappBackendOntapSanChapType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeviceNetappBackendOntapSanChapType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeviceNetappBackendOntapSanChapTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDeviceNetappBackendOntapSanChapType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeviceNetappBackendOntapSanChapType) ChapUsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for chap_username")
	}

	return validatorFn, nil
}

func (v *ValidateDeviceNetappBackendOntapSanChapType) ChapTargetUsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for chap_target_username")
	}

	return validatorFn, nil
}

func (v *ValidateDeviceNetappBackendOntapSanChapType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeviceNetappBackendOntapSanChapType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeviceNetappBackendOntapSanChapType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["chap_initiator_secret"]; exists {

		vOpts := append(opts, db.WithValidateField("chap_initiator_secret"))
		if err := fv(ctx, m.GetChapInitiatorSecret(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["chap_target_initiator_secret"]; exists {

		vOpts := append(opts, db.WithValidateField("chap_target_initiator_secret"))
		if err := fv(ctx, m.GetChapTargetInitiatorSecret(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["chap_target_username"]; exists {

		vOpts := append(opts, db.WithValidateField("chap_target_username"))
		if err := fv(ctx, m.GetChapTargetUsername(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["chap_username"]; exists {

		vOpts := append(opts, db.WithValidateField("chap_username"))
		if err := fv(ctx, m.GetChapUsername(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeviceNetappBackendOntapSanChapTypeValidator = func() *ValidateDeviceNetappBackendOntapSanChapType {
	v := &ValidateDeviceNetappBackendOntapSanChapType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChapUsername := v.ChapUsernameValidationRuleHandler
	rulesChapUsername := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhChapUsername(rulesChapUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeviceNetappBackendOntapSanChapType.chap_username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["chap_username"] = vFn

	vrhChapTargetUsername := v.ChapTargetUsernameValidationRuleHandler
	rulesChapTargetUsername := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhChapTargetUsername(rulesChapTargetUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeviceNetappBackendOntapSanChapType.chap_target_username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["chap_target_username"] = vFn

	v.FldValidators["chap_initiator_secret"] = ves_io_schema.SecretTypeValidator().Validate

	v.FldValidators["chap_target_initiator_secret"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func DeviceNetappBackendOntapSanChapTypeValidator() db.Validator {
	return DefaultDeviceNetappBackendOntapSanChapTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FlashArrayEndpoint) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FlashArrayEndpoint) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *FlashArrayEndpoint) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetApiToken().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting FlashArrayEndpoint.api_token")
	}

	return nil
}

func (m *FlashArrayEndpoint) DeepCopy() *FlashArrayEndpoint {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FlashArrayEndpoint{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FlashArrayEndpoint) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FlashArrayEndpoint) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FlashArrayEndpointValidator().Validate(ctx, m, opts...)
}

type ValidateFlashArrayEndpoint struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFlashArrayEndpoint) MgmtEndpointValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mgmt_endpoint")
	}
	return validatorFn, nil
}

func (v *ValidateFlashArrayEndpoint) MgmtEndpointMgmtIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MgmtIp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mgmt_ip")
	}
	return oValidatorFn_MgmtIp, nil
}
func (v *ValidateFlashArrayEndpoint) MgmtEndpointMgmtDnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MgmtDnsName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mgmt_dns_name")
	}
	return oValidatorFn_MgmtDnsName, nil
}

func (v *ValidateFlashArrayEndpoint) LabelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for labels")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for labels")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for labels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map labels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items labels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFlashArrayEndpoint) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FlashArrayEndpoint)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FlashArrayEndpoint got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_token"]; exists {

		vOpts := append(opts, db.WithValidateField("api_token"))
		if err := fv(ctx, m.GetApiToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {
		vOpts := append(opts, db.WithValidateField("labels"))
		if err := fv(ctx, m.GetLabels(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mgmt_endpoint"]; exists {
		val := m.GetMgmtEndpoint()
		vOpts := append(opts,
			db.WithValidateField("mgmt_endpoint"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMgmtEndpoint().(type) {
	case *FlashArrayEndpoint_MgmtIp:
		if fv, exists := v.FldValidators["mgmt_endpoint.mgmt_ip"]; exists {
			val := m.GetMgmtEndpoint().(*FlashArrayEndpoint_MgmtIp).MgmtIp
			vOpts := append(opts,
				db.WithValidateField("mgmt_endpoint"),
				db.WithValidateField("mgmt_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FlashArrayEndpoint_MgmtDnsName:
		if fv, exists := v.FldValidators["mgmt_endpoint.mgmt_dns_name"]; exists {
			val := m.GetMgmtEndpoint().(*FlashArrayEndpoint_MgmtDnsName).MgmtDnsName
			vOpts := append(opts,
				db.WithValidateField("mgmt_endpoint"),
				db.WithValidateField("mgmt_dns_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFlashArrayEndpointValidator = func() *ValidateFlashArrayEndpoint {
	v := &ValidateFlashArrayEndpoint{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMgmtEndpoint := v.MgmtEndpointValidationRuleHandler
	rulesMgmtEndpoint := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMgmtEndpoint(rulesMgmtEndpoint)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashArrayEndpoint.mgmt_endpoint: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mgmt_endpoint"] = vFn

	vrhMgmtEndpointMgmtIp := v.MgmtEndpointMgmtIpValidationRuleHandler
	rulesMgmtEndpointMgmtIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["mgmt_endpoint.mgmt_ip"], err = vrhMgmtEndpointMgmtIp(rulesMgmtEndpointMgmtIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field FlashArrayEndpoint.mgmt_endpoint_mgmt_ip: %s", err)
		panic(errMsg)
	}
	vrhMgmtEndpointMgmtDnsName := v.MgmtEndpointMgmtDnsNameValidationRuleHandler
	rulesMgmtEndpointMgmtDnsName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFnMap["mgmt_endpoint.mgmt_dns_name"], err = vrhMgmtEndpointMgmtDnsName(rulesMgmtEndpointMgmtDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field FlashArrayEndpoint.mgmt_endpoint_mgmt_dns_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["mgmt_endpoint.mgmt_ip"] = vFnMap["mgmt_endpoint.mgmt_ip"]
	v.FldValidators["mgmt_endpoint.mgmt_dns_name"] = vFnMap["mgmt_endpoint.mgmt_dns_name"]

	vrhLabels := v.LabelsValidationRuleHandler
	rulesLabels := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "128",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "20",
		"ves.io.schema.rules.map.values.string.max_len": "128",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhLabels(rulesLabels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashArrayEndpoint.labels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["labels"] = vFn

	v.FldValidators["api_token"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func FlashArrayEndpointValidator() db.Validator {
	return DefaultFlashArrayEndpointValidator
}

// augmented methods on protoc/std generated struct

func (m *FlashArrayType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FlashArrayType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *FlashArrayType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetFlashArrays() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting FlashArrayType.flash_arrays idx %v", idx)
		}
	}

	return nil
}

func (m *FlashArrayType) DeepCopy() *FlashArrayType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FlashArrayType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FlashArrayType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FlashArrayType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FlashArrayTypeValidator().Validate(ctx, m, opts...)
}

type ValidateFlashArrayType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFlashArrayType) SanTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for san_type")
	}

	return validatorFn, nil
}

func (v *ValidateFlashArrayType) DefaultFsTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_fs_type")
	}

	return validatorFn, nil
}

func (v *ValidateFlashArrayType) DefaultFsOptValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_fs_opt")
	}

	return validatorFn, nil
}

func (v *ValidateFlashArrayType) DefaultMountOptsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for default_mount_opts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for default_mount_opts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated default_mount_opts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items default_mount_opts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFlashArrayType) IscsiLoginTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for iscsi_login_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateFlashArrayType) FlashArraysValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*FlashArrayEndpoint, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := FlashArrayEndpointValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for flash_arrays")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*FlashArrayEndpoint)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*FlashArrayEndpoint, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated flash_arrays")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items flash_arrays")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFlashArrayType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FlashArrayType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FlashArrayType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_fs_opt"]; exists {

		vOpts := append(opts, db.WithValidateField("default_fs_opt"))
		if err := fv(ctx, m.GetDefaultFsOpt(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_fs_type"]; exists {

		vOpts := append(opts, db.WithValidateField("default_fs_type"))
		if err := fv(ctx, m.GetDefaultFsType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_mount_opts"]; exists {
		vOpts := append(opts, db.WithValidateField("default_mount_opts"))
		if err := fv(ctx, m.GetDefaultMountOpts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_preempt_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_preempt_attachments"))
		if err := fv(ctx, m.GetDisablePreemptAttachments(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flash_arrays"]; exists {
		vOpts := append(opts, db.WithValidateField("flash_arrays"))
		if err := fv(ctx, m.GetFlashArrays(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["iscsi_login_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("iscsi_login_timeout"))
		if err := fv(ctx, m.GetIscsiLoginTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["san_type"]; exists {

		vOpts := append(opts, db.WithValidateField("san_type"))
		if err := fv(ctx, m.GetSanType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFlashArrayTypeValidator = func() *ValidateFlashArrayType {
	v := &ValidateFlashArrayType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSanType := v.SanTypeValidationRuleHandler
	rulesSanType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"ISCSI\",\"FC\"]",
	}
	vFn, err = vrhSanType(rulesSanType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashArrayType.san_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["san_type"] = vFn

	vrhDefaultFsType := v.DefaultFsTypeValidationRuleHandler
	rulesDefaultFsType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"xfs\",\"ext4\"]",
	}
	vFn, err = vrhDefaultFsType(rulesDefaultFsType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashArrayType.default_fs_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_fs_type"] = vFn

	vrhDefaultFsOpt := v.DefaultFsOptValidationRuleHandler
	rulesDefaultFsOpt := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhDefaultFsOpt(rulesDefaultFsOpt)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashArrayType.default_fs_opt: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_fs_opt"] = vFn

	vrhDefaultMountOpts := v.DefaultMountOptsValidationRuleHandler
	rulesDefaultMountOpts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDefaultMountOpts(rulesDefaultMountOpts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashArrayType.default_mount_opts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_mount_opts"] = vFn

	vrhIscsiLoginTimeout := v.IscsiLoginTimeoutValidationRuleHandler
	rulesIscsiLoginTimeout := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "100",
	}
	vFn, err = vrhIscsiLoginTimeout(rulesIscsiLoginTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashArrayType.iscsi_login_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["iscsi_login_timeout"] = vFn

	vrhFlashArrays := v.FlashArraysValidationRuleHandler
	rulesFlashArrays := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhFlashArrays(rulesFlashArrays)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashArrayType.flash_arrays: %s", err)
		panic(errMsg)
	}
	v.FldValidators["flash_arrays"] = vFn

	return v
}()

func FlashArrayTypeValidator() db.Validator {
	return DefaultFlashArrayTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FlashBladeEndpoint) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FlashBladeEndpoint) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *FlashBladeEndpoint) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetApiToken().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting FlashBladeEndpoint.api_token")
	}

	return nil
}

func (m *FlashBladeEndpoint) DeepCopy() *FlashBladeEndpoint {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FlashBladeEndpoint{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FlashBladeEndpoint) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FlashBladeEndpoint) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FlashBladeEndpointValidator().Validate(ctx, m, opts...)
}

type ValidateFlashBladeEndpoint struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFlashBladeEndpoint) MgmtEndpointValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mgmt_endpoint")
	}
	return validatorFn, nil
}

func (v *ValidateFlashBladeEndpoint) MgmtEndpointMgmtIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MgmtIp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mgmt_ip")
	}
	return oValidatorFn_MgmtIp, nil
}
func (v *ValidateFlashBladeEndpoint) MgmtEndpointMgmtDnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MgmtDnsName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mgmt_dns_name")
	}
	return oValidatorFn_MgmtDnsName, nil
}

func (v *ValidateFlashBladeEndpoint) NfsEndpointValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nfs_endpoint")
	}
	return validatorFn, nil
}

func (v *ValidateFlashBladeEndpoint) NfsEndpointNfsEndpointIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NfsEndpointIp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nfs_endpoint_ip")
	}
	return oValidatorFn_NfsEndpointIp, nil
}
func (v *ValidateFlashBladeEndpoint) NfsEndpointNfsEndpointDnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NfsEndpointDnsName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nfs_endpoint_dns_name")
	}
	return oValidatorFn_NfsEndpointDnsName, nil
}

func (v *ValidateFlashBladeEndpoint) LablesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for lables")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for lables")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for lables")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map lables")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items lables")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFlashBladeEndpoint) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FlashBladeEndpoint)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FlashBladeEndpoint got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_token"]; exists {

		vOpts := append(opts, db.WithValidateField("api_token"))
		if err := fv(ctx, m.GetApiToken(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lables"]; exists {
		vOpts := append(opts, db.WithValidateField("lables"))
		if err := fv(ctx, m.GetLables(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mgmt_endpoint"]; exists {
		val := m.GetMgmtEndpoint()
		vOpts := append(opts,
			db.WithValidateField("mgmt_endpoint"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMgmtEndpoint().(type) {
	case *FlashBladeEndpoint_MgmtIp:
		if fv, exists := v.FldValidators["mgmt_endpoint.mgmt_ip"]; exists {
			val := m.GetMgmtEndpoint().(*FlashBladeEndpoint_MgmtIp).MgmtIp
			vOpts := append(opts,
				db.WithValidateField("mgmt_endpoint"),
				db.WithValidateField("mgmt_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FlashBladeEndpoint_MgmtDnsName:
		if fv, exists := v.FldValidators["mgmt_endpoint.mgmt_dns_name"]; exists {
			val := m.GetMgmtEndpoint().(*FlashBladeEndpoint_MgmtDnsName).MgmtDnsName
			vOpts := append(opts,
				db.WithValidateField("mgmt_endpoint"),
				db.WithValidateField("mgmt_dns_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["nfs_endpoint"]; exists {
		val := m.GetNfsEndpoint()
		vOpts := append(opts,
			db.WithValidateField("nfs_endpoint"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNfsEndpoint().(type) {
	case *FlashBladeEndpoint_NfsEndpointIp:
		if fv, exists := v.FldValidators["nfs_endpoint.nfs_endpoint_ip"]; exists {
			val := m.GetNfsEndpoint().(*FlashBladeEndpoint_NfsEndpointIp).NfsEndpointIp
			vOpts := append(opts,
				db.WithValidateField("nfs_endpoint"),
				db.WithValidateField("nfs_endpoint_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FlashBladeEndpoint_NfsEndpointDnsName:
		if fv, exists := v.FldValidators["nfs_endpoint.nfs_endpoint_dns_name"]; exists {
			val := m.GetNfsEndpoint().(*FlashBladeEndpoint_NfsEndpointDnsName).NfsEndpointDnsName
			vOpts := append(opts,
				db.WithValidateField("nfs_endpoint"),
				db.WithValidateField("nfs_endpoint_dns_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFlashBladeEndpointValidator = func() *ValidateFlashBladeEndpoint {
	v := &ValidateFlashBladeEndpoint{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMgmtEndpoint := v.MgmtEndpointValidationRuleHandler
	rulesMgmtEndpoint := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMgmtEndpoint(rulesMgmtEndpoint)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashBladeEndpoint.mgmt_endpoint: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mgmt_endpoint"] = vFn

	vrhMgmtEndpointMgmtIp := v.MgmtEndpointMgmtIpValidationRuleHandler
	rulesMgmtEndpointMgmtIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["mgmt_endpoint.mgmt_ip"], err = vrhMgmtEndpointMgmtIp(rulesMgmtEndpointMgmtIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field FlashBladeEndpoint.mgmt_endpoint_mgmt_ip: %s", err)
		panic(errMsg)
	}
	vrhMgmtEndpointMgmtDnsName := v.MgmtEndpointMgmtDnsNameValidationRuleHandler
	rulesMgmtEndpointMgmtDnsName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFnMap["mgmt_endpoint.mgmt_dns_name"], err = vrhMgmtEndpointMgmtDnsName(rulesMgmtEndpointMgmtDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field FlashBladeEndpoint.mgmt_endpoint_mgmt_dns_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["mgmt_endpoint.mgmt_ip"] = vFnMap["mgmt_endpoint.mgmt_ip"]
	v.FldValidators["mgmt_endpoint.mgmt_dns_name"] = vFnMap["mgmt_endpoint.mgmt_dns_name"]

	vrhNfsEndpoint := v.NfsEndpointValidationRuleHandler
	rulesNfsEndpoint := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNfsEndpoint(rulesNfsEndpoint)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashBladeEndpoint.nfs_endpoint: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nfs_endpoint"] = vFn

	vrhNfsEndpointNfsEndpointIp := v.NfsEndpointNfsEndpointIpValidationRuleHandler
	rulesNfsEndpointNfsEndpointIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["nfs_endpoint.nfs_endpoint_ip"], err = vrhNfsEndpointNfsEndpointIp(rulesNfsEndpointNfsEndpointIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field FlashBladeEndpoint.nfs_endpoint_nfs_endpoint_ip: %s", err)
		panic(errMsg)
	}
	vrhNfsEndpointNfsEndpointDnsName := v.NfsEndpointNfsEndpointDnsNameValidationRuleHandler
	rulesNfsEndpointNfsEndpointDnsName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFnMap["nfs_endpoint.nfs_endpoint_dns_name"], err = vrhNfsEndpointNfsEndpointDnsName(rulesNfsEndpointNfsEndpointDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field FlashBladeEndpoint.nfs_endpoint_nfs_endpoint_dns_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["nfs_endpoint.nfs_endpoint_ip"] = vFnMap["nfs_endpoint.nfs_endpoint_ip"]
	v.FldValidators["nfs_endpoint.nfs_endpoint_dns_name"] = vFnMap["nfs_endpoint.nfs_endpoint_dns_name"]

	vrhLables := v.LablesValidationRuleHandler
	rulesLables := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "128",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "20",
		"ves.io.schema.rules.map.values.string.max_len": "128",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhLables(rulesLables)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashBladeEndpoint.lables: %s", err)
		panic(errMsg)
	}
	v.FldValidators["lables"] = vFn

	v.FldValidators["api_token"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func FlashBladeEndpointValidator() db.Validator {
	return DefaultFlashBladeEndpointValidator
}

// augmented methods on protoc/std generated struct

func (m *FlashBladeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FlashBladeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *FlashBladeType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetFlashBlades() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting FlashBladeType.flash_blades idx %v", idx)
		}
	}

	return nil
}

func (m *FlashBladeType) DeepCopy() *FlashBladeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FlashBladeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FlashBladeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FlashBladeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FlashBladeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateFlashBladeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFlashBladeType) ExportRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for export_rules")
	}

	return validatorFn, nil
}

func (v *ValidateFlashBladeType) FlashBladesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*FlashBladeEndpoint, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := FlashBladeEndpointValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for flash_blades")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*FlashBladeEndpoint)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*FlashBladeEndpoint, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated flash_blades")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items flash_blades")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFlashBladeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FlashBladeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FlashBladeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["enable_snapshot_directory"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_snapshot_directory"))
		if err := fv(ctx, m.GetEnableSnapshotDirectory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["export_rules"]; exists {

		vOpts := append(opts, db.WithValidateField("export_rules"))
		if err := fv(ctx, m.GetExportRules(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flash_blades"]; exists {
		vOpts := append(opts, db.WithValidateField("flash_blades"))
		if err := fv(ctx, m.GetFlashBlades(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFlashBladeTypeValidator = func() *ValidateFlashBladeType {
	v := &ValidateFlashBladeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExportRules := v.ExportRulesValidationRuleHandler
	rulesExportRules := map[string]string{
		"ves.io.schema.rules.string.max_len": "50",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhExportRules(rulesExportRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashBladeType.export_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["export_rules"] = vFn

	vrhFlashBlades := v.FlashBladesValidationRuleHandler
	rulesFlashBlades := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhFlashBlades(rulesFlashBlades)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FlashBladeType.flash_blades: %s", err)
		panic(errMsg)
	}
	v.FldValidators["flash_blades"] = vFn

	return v
}()

func FlashBladeTypeValidator() db.Validator {
	return DefaultFlashBladeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetBondDeviceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetBondDeviceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetBondDeviceType) DeepCopy() *FleetBondDeviceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetBondDeviceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetBondDeviceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetBondDeviceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetBondDeviceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateFleetBondDeviceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetBondDeviceType) LacpChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for lacp_choice")
	}
	return validatorFn, nil
}

func (v *ValidateFleetBondDeviceType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateFleetBondDeviceType) DevicesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for devices")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for devices")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated devices")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items devices")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFleetBondDeviceType) LinkPollingIntervalValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for link_polling_interval")
	}

	return validatorFn, nil
}

func (v *ValidateFleetBondDeviceType) LinkUpDelayValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for link_up_delay")
	}

	return validatorFn, nil
}

func (v *ValidateFleetBondDeviceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetBondDeviceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetBondDeviceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["devices"]; exists {
		vOpts := append(opts, db.WithValidateField("devices"))
		if err := fv(ctx, m.GetDevices(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lacp_choice"]; exists {
		val := m.GetLacpChoice()
		vOpts := append(opts,
			db.WithValidateField("lacp_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLacpChoice().(type) {
	case *FleetBondDeviceType_Lacp:
		if fv, exists := v.FldValidators["lacp_choice.lacp"]; exists {
			val := m.GetLacpChoice().(*FleetBondDeviceType_Lacp).Lacp
			vOpts := append(opts,
				db.WithValidateField("lacp_choice"),
				db.WithValidateField("lacp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FleetBondDeviceType_ActiveBackup:
		if fv, exists := v.FldValidators["lacp_choice.active_backup"]; exists {
			val := m.GetLacpChoice().(*FleetBondDeviceType_ActiveBackup).ActiveBackup
			vOpts := append(opts,
				db.WithValidateField("lacp_choice"),
				db.WithValidateField("active_backup"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["link_polling_interval"]; exists {

		vOpts := append(opts, db.WithValidateField("link_polling_interval"))
		if err := fv(ctx, m.GetLinkPollingInterval(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_up_delay"]; exists {

		vOpts := append(opts, db.WithValidateField("link_up_delay"))
		if err := fv(ctx, m.GetLinkUpDelay(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetBondDeviceTypeValidator = func() *ValidateFleetBondDeviceType {
	v := &ValidateFleetBondDeviceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLacpChoice := v.LacpChoiceValidationRuleHandler
	rulesLacpChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLacpChoice(rulesLacpChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetBondDeviceType.lacp_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["lacp_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetBondDeviceType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhDevices := v.DevicesValidationRuleHandler
	rulesDevices := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "64",
		"ves.io.schema.rules.repeated.max_items":            "8",
		"ves.io.schema.rules.repeated.min_items":            "1",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhDevices(rulesDevices)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetBondDeviceType.devices: %s", err)
		panic(errMsg)
	}
	v.FldValidators["devices"] = vFn

	vrhLinkPollingInterval := v.LinkPollingIntervalValidationRuleHandler
	rulesLinkPollingInterval := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "500",
		"ves.io.schema.rules.uint32.lte":       "5000",
	}
	vFn, err = vrhLinkPollingInterval(rulesLinkPollingInterval)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetBondDeviceType.link_polling_interval: %s", err)
		panic(errMsg)
	}
	v.FldValidators["link_polling_interval"] = vFn

	vrhLinkUpDelay := v.LinkUpDelayValidationRuleHandler
	rulesLinkUpDelay := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "1000",
	}
	vFn, err = vrhLinkUpDelay(rulesLinkUpDelay)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetBondDeviceType.link_up_delay: %s", err)
		panic(errMsg)
	}
	v.FldValidators["link_up_delay"] = vFn

	v.FldValidators["lacp_choice.lacp"] = BondLacpTypeValidator().Validate

	return v
}()

func FleetBondDeviceTypeValidator() db.Validator {
	return DefaultFleetBondDeviceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetBondDevicesListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetBondDevicesListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetBondDevicesListType) DeepCopy() *FleetBondDevicesListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetBondDevicesListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetBondDevicesListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetBondDevicesListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetBondDevicesListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateFleetBondDevicesListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetBondDevicesListType) BondDevicesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*FleetBondDeviceType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := FleetBondDeviceTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for bond_devices")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*FleetBondDeviceType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*FleetBondDeviceType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated bond_devices")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items bond_devices")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFleetBondDevicesListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetBondDevicesListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetBondDevicesListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bond_devices"]; exists {
		vOpts := append(opts, db.WithValidateField("bond_devices"))
		if err := fv(ctx, m.GetBondDevices(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetBondDevicesListTypeValidator = func() *ValidateFleetBondDevicesListType {
	v := &ValidateFleetBondDevicesListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBondDevices := v.BondDevicesValidationRuleHandler
	rulesBondDevices := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhBondDevices(rulesBondDevices)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetBondDevicesListType.bond_devices: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bond_devices"] = vFn

	return v
}()

func FleetBondDevicesListTypeValidator() db.Validator {
	return DefaultFleetBondDevicesListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetDeviceListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetDeviceListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetDeviceListType) DeepCopy() *FleetDeviceListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetDeviceListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetDeviceListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetDeviceListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetDeviceListTypeValidator().Validate(ctx, m, opts...)
}

func (m *FleetDeviceListType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDevicesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *FleetDeviceListType) GetDevicesDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetDevices() == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.GetDevices() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("devices[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateFleetDeviceListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetDeviceListType) DevicesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*DeviceInstanceType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := DeviceInstanceTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for devices")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DeviceInstanceType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DeviceInstanceType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated devices")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items devices")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFleetDeviceListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetDeviceListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetDeviceListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["devices"]; exists {
		vOpts := append(opts, db.WithValidateField("devices"))
		if err := fv(ctx, m.GetDevices(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetDeviceListTypeValidator = func() *ValidateFleetDeviceListType {
	v := &ValidateFleetDeviceListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDevices := v.DevicesValidationRuleHandler
	rulesDevices := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDevices(rulesDevices)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetDeviceListType.devices: %s", err)
		panic(errMsg)
	}
	v.FldValidators["devices"] = vFn

	return v
}()

func FleetDeviceListTypeValidator() db.Validator {
	return DefaultFleetDeviceListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetInterfaceListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetInterfaceListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetInterfaceListType) DeepCopy() *FleetInterfaceListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetInterfaceListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetInterfaceListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetInterfaceListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetInterfaceListTypeValidator().Validate(ctx, m, opts...)
}

func (m *FleetInterfaceListType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetInterfacesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *FleetInterfaceListType) GetInterfacesDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, vref := range m.GetInterfaces() {
		if vref == nil {
			return nil, fmt.Errorf("FleetInterfaceListType.interfaces[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("network_interface.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_interface.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "interfaces",
			Ref:        vdRef,
		})
	}

	return drInfos, nil
}

// GetInterfacesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *FleetInterfaceListType) GetInterfacesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_interface.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_interface")
	}
	for i, vref := range m.GetInterfaces() {
		if vref == nil {
			return nil, fmt.Errorf("FleetInterfaceListType.interfaces[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "network_interface.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateFleetInterfaceListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetInterfaceListType) InterfacesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for interfaces")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated interfaces")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interfaces")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFleetInterfaceListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetInterfaceListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetInterfaceListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interfaces"]; exists {
		vOpts := append(opts, db.WithValidateField("interfaces"))
		if err := fv(ctx, m.GetInterfaces(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetInterfaceListTypeValidator = func() *ValidateFleetInterfaceListType {
	v := &ValidateFleetInterfaceListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaces := v.InterfacesValidationRuleHandler
	rulesInterfaces := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhInterfaces(rulesInterfaces)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetInterfaceListType.interfaces: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interfaces"] = vFn

	return v
}()

func FleetInterfaceListTypeValidator() db.Validator {
	return DefaultFleetInterfaceListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetStatus) DeepCopy() *FleetStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetStatusValidator().Validate(ctx, m, opts...)
}

type ValidateFleetStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["available_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("available_software_version"))
		if err := fv(ctx, m.GetAvailableSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetStatusValidator = func() *ValidateFleetStatus {
	v := &ValidateFleetStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FleetStatusValidator() db.Validator {
	return DefaultFleetStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetStorageClassListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetStorageClassListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetStorageClassListType) DeepCopy() *FleetStorageClassListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetStorageClassListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetStorageClassListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetStorageClassListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetStorageClassListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateFleetStorageClassListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetStorageClassListType) StorageClassesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*FleetStorageClassType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := FleetStorageClassTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for storage_classes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*FleetStorageClassType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*FleetStorageClassType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated storage_classes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items storage_classes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageClassListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetStorageClassListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetStorageClassListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["storage_classes"]; exists {
		vOpts := append(opts, db.WithValidateField("storage_classes"))
		if err := fv(ctx, m.GetStorageClasses(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetStorageClassListTypeValidator = func() *ValidateFleetStorageClassListType {
	v := &ValidateFleetStorageClassListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStorageClasses := v.StorageClassesValidationRuleHandler
	rulesStorageClasses := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStorageClasses(rulesStorageClasses)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageClassListType.storage_classes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_classes"] = vFn

	return v
}()

func FleetStorageClassListTypeValidator() db.Validator {
	return DefaultFleetStorageClassListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetStorageClassType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetStorageClassType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetStorageClassType) DeepCopy() *FleetStorageClassType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetStorageClassType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetStorageClassType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetStorageClassType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetStorageClassTypeValidator().Validate(ctx, m, opts...)
}

type ValidateFleetStorageClassType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetStorageClassType) DeviceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device_choice")
	}
	return validatorFn, nil
}

func (v *ValidateFleetStorageClassType) StorageDeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_device")
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageClassType) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageClassType) AdvancedStorageParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for advanced_storage_parameters")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for advanced_storage_parameters")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for advanced_storage_parameters")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map advanced_storage_parameters")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items advanced_storage_parameters")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageClassType) StorageClassNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_class_name")
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageClassType) ReclaimPolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for reclaim_policy")
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageClassType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetStorageClassType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetStorageClassType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advanced_storage_parameters"]; exists {
		vOpts := append(opts, db.WithValidateField("advanced_storage_parameters"))
		if err := fv(ctx, m.GetAdvancedStorageParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allow_volume_expansion"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_volume_expansion"))
		if err := fv(ctx, m.GetAllowVolumeExpansion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_storage_class"]; exists {

		vOpts := append(opts, db.WithValidateField("default_storage_class"))
		if err := fv(ctx, m.GetDefaultStorageClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["device_choice"]; exists {
		val := m.GetDeviceChoice()
		vOpts := append(opts,
			db.WithValidateField("device_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDeviceChoice().(type) {
	case *FleetStorageClassType_NetappTrident:
		if fv, exists := v.FldValidators["device_choice.netapp_trident"]; exists {
			val := m.GetDeviceChoice().(*FleetStorageClassType_NetappTrident).NetappTrident
			vOpts := append(opts,
				db.WithValidateField("device_choice"),
				db.WithValidateField("netapp_trident"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FleetStorageClassType_PureServiceOrchestrator:
		if fv, exists := v.FldValidators["device_choice.pure_service_orchestrator"]; exists {
			val := m.GetDeviceChoice().(*FleetStorageClassType_PureServiceOrchestrator).PureServiceOrchestrator
			vOpts := append(opts,
				db.WithValidateField("device_choice"),
				db.WithValidateField("pure_service_orchestrator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FleetStorageClassType_OpenebsEnterprise:
		if fv, exists := v.FldValidators["device_choice.openebs_enterprise"]; exists {
			val := m.GetDeviceChoice().(*FleetStorageClassType_OpenebsEnterprise).OpenebsEnterprise
			vOpts := append(opts,
				db.WithValidateField("device_choice"),
				db.WithValidateField("openebs_enterprise"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FleetStorageClassType_CustomStorage:
		if fv, exists := v.FldValidators["device_choice.custom_storage"]; exists {
			val := m.GetDeviceChoice().(*FleetStorageClassType_CustomStorage).CustomStorage
			vOpts := append(opts,
				db.WithValidateField("device_choice"),
				db.WithValidateField("custom_storage"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["reclaim_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("reclaim_policy"))
		if err := fv(ctx, m.GetReclaimPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_class_name"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_class_name"))
		if err := fv(ctx, m.GetStorageClassName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_device"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_device"))
		if err := fv(ctx, m.GetStorageDevice(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetStorageClassTypeValidator = func() *ValidateFleetStorageClassType {
	v := &ValidateFleetStorageClassType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDeviceChoice := v.DeviceChoiceValidationRuleHandler
	rulesDeviceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDeviceChoice(rulesDeviceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageClassType.device_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_choice"] = vFn

	vrhStorageDevice := v.StorageDeviceValidationRuleHandler
	rulesStorageDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhStorageDevice(rulesStorageDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageClassType.storage_device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_device"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageClassType.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	vrhAdvancedStorageParameters := v.AdvancedStorageParametersValidationRuleHandler
	rulesAdvancedStorageParameters := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "128",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "64",
		"ves.io.schema.rules.map.values.string.max_len": "128",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhAdvancedStorageParameters(rulesAdvancedStorageParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageClassType.advanced_storage_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advanced_storage_parameters"] = vFn

	vrhStorageClassName := v.StorageClassNameValidationRuleHandler
	rulesStorageClassName := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhStorageClassName(rulesStorageClassName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageClassType.storage_class_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_class_name"] = vFn

	vrhReclaimPolicy := v.ReclaimPolicyValidationRuleHandler
	rulesReclaimPolicy := map[string]string{
		"ves.io.schema.rules.string.max_len": "16",
	}
	vFn, err = vrhReclaimPolicy(rulesReclaimPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageClassType.reclaim_policy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["reclaim_policy"] = vFn

	v.FldValidators["device_choice.netapp_trident"] = StorageClassNetappTridentTypeValidator().Validate
	v.FldValidators["device_choice.pure_service_orchestrator"] = StorageClassPureServiceOrchestratorTypeValidator().Validate
	v.FldValidators["device_choice.openebs_enterprise"] = StorageClassOpenebsEnterpriseTypeValidator().Validate
	v.FldValidators["device_choice.custom_storage"] = StorageClassCustomTypeValidator().Validate

	return v
}()

func FleetStorageClassTypeValidator() db.Validator {
	return DefaultFleetStorageClassTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetStorageDeviceListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetStorageDeviceListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *FleetStorageDeviceListType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetStorageDevices() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting FleetStorageDeviceListType.storage_devices idx %v", idx)
		}
	}

	return nil
}

func (m *FleetStorageDeviceListType) DeepCopy() *FleetStorageDeviceListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetStorageDeviceListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetStorageDeviceListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetStorageDeviceListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetStorageDeviceListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateFleetStorageDeviceListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetStorageDeviceListType) StorageDevicesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*FleetStorageDeviceType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := FleetStorageDeviceTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for storage_devices")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*FleetStorageDeviceType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*FleetStorageDeviceType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated storage_devices")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items storage_devices")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageDeviceListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetStorageDeviceListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetStorageDeviceListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["storage_devices"]; exists {
		vOpts := append(opts, db.WithValidateField("storage_devices"))
		if err := fv(ctx, m.GetStorageDevices(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetStorageDeviceListTypeValidator = func() *ValidateFleetStorageDeviceListType {
	v := &ValidateFleetStorageDeviceListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStorageDevices := v.StorageDevicesValidationRuleHandler
	rulesStorageDevices := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStorageDevices(rulesStorageDevices)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageDeviceListType.storage_devices: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_devices"] = vFn

	return v
}()

func FleetStorageDeviceListTypeValidator() db.Validator {
	return DefaultFleetStorageDeviceListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetStorageDeviceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetStorageDeviceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *FleetStorageDeviceType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetNetappTrident().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting FleetStorageDeviceType.netapp_trident")
	}

	if err := m.GetPureServiceOrchestrator().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting FleetStorageDeviceType.pure_service_orchestrator")
	}

	return nil
}

func (m *FleetStorageDeviceType) DeepCopy() *FleetStorageDeviceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetStorageDeviceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetStorageDeviceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetStorageDeviceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetStorageDeviceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateFleetStorageDeviceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetStorageDeviceType) DeviceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device_choice")
	}
	return validatorFn, nil
}

func (v *ValidateFleetStorageDeviceType) StorageDeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_device")
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageDeviceType) AdvancedAdvancedParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for advanced_advanced_parameters")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for advanced_advanced_parameters")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for advanced_advanced_parameters")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map advanced_advanced_parameters")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items advanced_advanced_parameters")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageDeviceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetStorageDeviceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetStorageDeviceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advanced_advanced_parameters"]; exists {
		vOpts := append(opts, db.WithValidateField("advanced_advanced_parameters"))
		if err := fv(ctx, m.GetAdvancedAdvancedParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["device_choice"]; exists {
		val := m.GetDeviceChoice()
		vOpts := append(opts,
			db.WithValidateField("device_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDeviceChoice().(type) {
	case *FleetStorageDeviceType_NetappTrident:
		if fv, exists := v.FldValidators["device_choice.netapp_trident"]; exists {
			val := m.GetDeviceChoice().(*FleetStorageDeviceType_NetappTrident).NetappTrident
			vOpts := append(opts,
				db.WithValidateField("device_choice"),
				db.WithValidateField("netapp_trident"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FleetStorageDeviceType_PureServiceOrchestrator:
		if fv, exists := v.FldValidators["device_choice.pure_service_orchestrator"]; exists {
			val := m.GetDeviceChoice().(*FleetStorageDeviceType_PureServiceOrchestrator).PureServiceOrchestrator
			vOpts := append(opts,
				db.WithValidateField("device_choice"),
				db.WithValidateField("pure_service_orchestrator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FleetStorageDeviceType_OpenebsEnterprise:
		if fv, exists := v.FldValidators["device_choice.openebs_enterprise"]; exists {
			val := m.GetDeviceChoice().(*FleetStorageDeviceType_OpenebsEnterprise).OpenebsEnterprise
			vOpts := append(opts,
				db.WithValidateField("device_choice"),
				db.WithValidateField("openebs_enterprise"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FleetStorageDeviceType_CustomStorage:
		if fv, exists := v.FldValidators["device_choice.custom_storage"]; exists {
			val := m.GetDeviceChoice().(*FleetStorageDeviceType_CustomStorage).CustomStorage
			vOpts := append(opts,
				db.WithValidateField("device_choice"),
				db.WithValidateField("custom_storage"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_device"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_device"))
		if err := fv(ctx, m.GetStorageDevice(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetStorageDeviceTypeValidator = func() *ValidateFleetStorageDeviceType {
	v := &ValidateFleetStorageDeviceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDeviceChoice := v.DeviceChoiceValidationRuleHandler
	rulesDeviceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDeviceChoice(rulesDeviceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageDeviceType.device_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_choice"] = vFn

	vrhStorageDevice := v.StorageDeviceValidationRuleHandler
	rulesStorageDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhStorageDevice(rulesStorageDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageDeviceType.storage_device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_device"] = vFn

	vrhAdvancedAdvancedParameters := v.AdvancedAdvancedParametersValidationRuleHandler
	rulesAdvancedAdvancedParameters := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "128",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "64",
		"ves.io.schema.rules.map.values.string.max_len": "128",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhAdvancedAdvancedParameters(rulesAdvancedAdvancedParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageDeviceType.advanced_advanced_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advanced_advanced_parameters"] = vFn

	v.FldValidators["device_choice.netapp_trident"] = StorageDeviceNetappTridentTypeValidator().Validate
	v.FldValidators["device_choice.pure_service_orchestrator"] = StorageDevicePureStorageServiceOrchestratorTypeValidator().Validate
	v.FldValidators["device_choice.openebs_enterprise"] = StorageDeviceOpenebsEnterpriseTypeValidator().Validate

	return v
}()

func FleetStorageDeviceTypeValidator() db.Validator {
	return DefaultFleetStorageDeviceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetStorageStaticRoutesListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetStorageStaticRoutesListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetStorageStaticRoutesListType) DeepCopy() *FleetStorageStaticRoutesListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetStorageStaticRoutesListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetStorageStaticRoutesListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetStorageStaticRoutesListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetStorageStaticRoutesListTypeValidator().Validate(ctx, m, opts...)
}

func (m *FleetStorageStaticRoutesListType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetStorageRoutesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *FleetStorageStaticRoutesListType) GetStorageRoutesDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetStorageRoutes() == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.GetStorageRoutes() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("storage_routes[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateFleetStorageStaticRoutesListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetStorageStaticRoutesListType) StorageRoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.StaticRouteType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.StaticRouteTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for storage_routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.StaticRouteType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.StaticRouteType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated storage_routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items storage_routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFleetStorageStaticRoutesListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetStorageStaticRoutesListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetStorageStaticRoutesListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["storage_routes"]; exists {
		vOpts := append(opts, db.WithValidateField("storage_routes"))
		if err := fv(ctx, m.GetStorageRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetStorageStaticRoutesListTypeValidator = func() *ValidateFleetStorageStaticRoutesListType {
	v := &ValidateFleetStorageStaticRoutesListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStorageRoutes := v.StorageRoutesValidationRuleHandler
	rulesStorageRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStorageRoutes(rulesStorageRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FleetStorageStaticRoutesListType.storage_routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_routes"] = vFn

	return v
}()

func FleetStorageStaticRoutesListTypeValidator() db.Validator {
	return DefaultFleetStorageStaticRoutesListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GenericDeviceInstanceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GenericDeviceInstanceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GenericDeviceInstanceType) DeepCopy() *GenericDeviceInstanceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GenericDeviceInstanceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GenericDeviceInstanceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GenericDeviceInstanceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GenericDeviceInstanceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGenericDeviceInstanceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGenericDeviceInstanceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GenericDeviceInstanceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GenericDeviceInstanceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGenericDeviceInstanceTypeValidator = func() *ValidateGenericDeviceInstanceType {
	v := &ValidateGenericDeviceInstanceType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GenericDeviceInstanceTypeValidator() db.Validator {
	return DefaultGenericDeviceInstanceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetStorageDeviceList().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.storage_device_list")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDcClusterGroupChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInsideVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkConnectorsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkFirewallDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOutsideVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStorageInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStorageStaticRoutesChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUsbPolicyChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *GetSpecType) GetDcClusterGroupChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetDcClusterGroupChoice().(type) {
	case *GetSpecType_NoDcClusterGroup:

	case *GetSpecType_DcClusterGroup:

		vref := m.GetDcClusterGroup()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		odri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	case *GetSpecType_DcClusterGroupInside:

		vref := m.GetDcClusterGroupInside()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		odri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_inside",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetDcClusterGroupChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetDcClusterGroupChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetDcClusterGroupChoice().(type) {
	case *GetSpecType_NoDcClusterGroup:

	case *GetSpecType_DcClusterGroup:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroup()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *GetSpecType_DcClusterGroupInside:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupInside()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *GetSpecType) GetInsideVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetInsideVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.inside_virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "inside_virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetInsideVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetInsideVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetInsideVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetInterfaceChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetInterfaceChoice().(type) {
	case *GetSpecType_InterfaceList:
		odrInfos, err = m.GetInterfaceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "interface_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *GetSpecType_DeviceList:
		odrInfos, err = m.GetDeviceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "device_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *GetSpecType_DefaultConfig:

	}

	return drInfos, err
}

func (m *GetSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetLogsReceiverChoice().(type) {
	case *GetSpecType_LogsStreamingDisabled:

	case *GetSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		odri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *GetSpecType_LogsStreamingDisabled:

	case *GetSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *GetSpecType) GetNetworkConnectorsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetNetworkConnectors() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.network_connectors[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_connector.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network_connectors",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetNetworkConnectorsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetNetworkConnectorsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_connector.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_connector")
	}
	for _, ref := range m.GetNetworkConnectors() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetNetworkFirewallDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetNetworkFirewall() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.network_firewall[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_firewall.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network_firewall",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetNetworkFirewallDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetNetworkFirewallDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_firewall.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_firewall")
	}
	for _, ref := range m.GetNetworkFirewall() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetOutsideVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetOutsideVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.outside_virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "outside_virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetOutsideVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetOutsideVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetOutsideVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetStorageInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetStorageInterfaceChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetStorageInterfaceChoice().(type) {
	case *GetSpecType_NoStorageInterfaces:

	case *GetSpecType_StorageInterfaceList:
		odrInfos, err = m.GetStorageInterfaceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "storage_interface_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetStorageStaticRoutesChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetStorageStaticRoutesChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetStorageStaticRoutesChoice().(type) {
	case *GetSpecType_NoStorageStaticRoutes:

	case *GetSpecType_StorageStaticRoutes:
		odrInfos, err = m.GetStorageStaticRoutes().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "storage_static_routes." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

func (m *GetSpecType) GetUsbPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetUsbPolicyChoice().(type) {
	case *GetSpecType_DenyAllUsb:

	case *GetSpecType_AllowAllUsb:

	case *GetSpecType_UsbPolicy:

		vref := m.GetUsbPolicy()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("usb_policy.Object")
		odri := db.DRefInfo{
			RefdType:   "usb_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "usb_policy",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetUsbPolicyChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetUsbPolicyChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetUsbPolicyChoice().(type) {
	case *GetSpecType_DenyAllUsb:

	case *GetSpecType_AllowAllUsb:

	case *GetSpecType_UsbPolicy:
		refdType, err := d.TypeForEntryKind("", "", "usb_policy.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: usb_policy")
		}

		vref := m.GetUsbPolicy()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "usb_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) BondChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bond_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) DcClusterGroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dc_cluster_group_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) GpuChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for gpu_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) StorageClassChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_class_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) StorageDeviceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_device_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) StorageInterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) StorageStaticRoutesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_static_routes_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) UsbPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for usb_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) FleetLabelValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fleet_label")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) NetworkConnectorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for network_connectors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated network_connectors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items network_connectors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) NetworkFirewallValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for network_firewall")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated network_firewall")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items network_firewall")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OutsideVirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for outside_virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated outside_virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items outside_virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) InsideVirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for inside_virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated inside_virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items inside_virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bond_choice"]; exists {
		val := m.GetBondChoice()
		vOpts := append(opts,
			db.WithValidateField("bond_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBondChoice().(type) {
	case *GetSpecType_NoBondDevices:
		if fv, exists := v.FldValidators["bond_choice.no_bond_devices"]; exists {
			val := m.GetBondChoice().(*GetSpecType_NoBondDevices).NoBondDevices
			vOpts := append(opts,
				db.WithValidateField("bond_choice"),
				db.WithValidateField("no_bond_devices"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_BondDeviceList:
		if fv, exists := v.FldValidators["bond_choice.bond_device_list"]; exists {
			val := m.GetBondChoice().(*GetSpecType_BondDeviceList).BondDeviceList
			vOpts := append(opts,
				db.WithValidateField("bond_choice"),
				db.WithValidateField("bond_device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dc_cluster_group_choice"]; exists {
		val := m.GetDcClusterGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("dc_cluster_group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDcClusterGroupChoice().(type) {
	case *GetSpecType_NoDcClusterGroup:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.no_dc_cluster_group"]; exists {
			val := m.GetDcClusterGroupChoice().(*GetSpecType_NoDcClusterGroup).NoDcClusterGroup
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("no_dc_cluster_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DcClusterGroup:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group"]; exists {
			val := m.GetDcClusterGroupChoice().(*GetSpecType_DcClusterGroup).DcClusterGroup
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DcClusterGroupInside:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside"]; exists {
			val := m.GetDcClusterGroupChoice().(*GetSpecType_DcClusterGroupInside).DcClusterGroupInside
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group_inside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enable_default_fleet_config_download"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_default_fleet_config_download"))
		if err := fv(ctx, m.GetEnableDefaultFleetConfigDownload(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fleet_label"]; exists {

		vOpts := append(opts, db.WithValidateField("fleet_label"))
		if err := fv(ctx, m.GetFleetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gpu_choice"]; exists {
		val := m.GetGpuChoice()
		vOpts := append(opts,
			db.WithValidateField("gpu_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGpuChoice().(type) {
	case *GetSpecType_DisableGpu:
		if fv, exists := v.FldValidators["gpu_choice.disable_gpu"]; exists {
			val := m.GetGpuChoice().(*GetSpecType_DisableGpu).DisableGpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("disable_gpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_EnableGpu:
		if fv, exists := v.FldValidators["gpu_choice.enable_gpu"]; exists {
			val := m.GetGpuChoice().(*GetSpecType_EnableGpu).EnableGpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("enable_gpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_EnableVgpu:
		if fv, exists := v.FldValidators["gpu_choice.enable_vgpu"]; exists {
			val := m.GetGpuChoice().(*GetSpecType_EnableVgpu).EnableVgpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("enable_vgpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["inside_virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("inside_virtual_network"))
		if err := fv(ctx, m.GetInsideVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *GetSpecType_InterfaceList:
		if fv, exists := v.FldValidators["interface_choice.interface_list"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_InterfaceList).InterfaceList
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("interface_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DeviceList:
		if fv, exists := v.FldValidators["interface_choice.device_list"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_DeviceList).DeviceList
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DefaultConfig:
		if fv, exists := v.FldValidators["interface_choice.default_config"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_DefaultConfig).DefaultConfig
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("default_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *GetSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*GetSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*GetSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_connectors"]; exists {
		vOpts := append(opts, db.WithValidateField("network_connectors"))
		if err := fv(ctx, m.GetNetworkConnectors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_firewall"]; exists {
		vOpts := append(opts, db.WithValidateField("network_firewall"))
		if err := fv(ctx, m.GetNetworkFirewall(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("outside_virtual_network"))
		if err := fv(ctx, m.GetOutsideVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_class_choice"]; exists {
		val := m.GetStorageClassChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_class_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageClassChoice().(type) {
	case *GetSpecType_DefaultStorageClass:
		if fv, exists := v.FldValidators["storage_class_choice.default_storage_class"]; exists {
			val := m.GetStorageClassChoice().(*GetSpecType_DefaultStorageClass).DefaultStorageClass
			vOpts := append(opts,
				db.WithValidateField("storage_class_choice"),
				db.WithValidateField("default_storage_class"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_StorageClassList:
		if fv, exists := v.FldValidators["storage_class_choice.storage_class_list"]; exists {
			val := m.GetStorageClassChoice().(*GetSpecType_StorageClassList).StorageClassList
			vOpts := append(opts,
				db.WithValidateField("storage_class_choice"),
				db.WithValidateField("storage_class_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_device_choice"]; exists {
		val := m.GetStorageDeviceChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_device_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageDeviceChoice().(type) {
	case *GetSpecType_NoStorageDevice:
		if fv, exists := v.FldValidators["storage_device_choice.no_storage_device"]; exists {
			val := m.GetStorageDeviceChoice().(*GetSpecType_NoStorageDevice).NoStorageDevice
			vOpts := append(opts,
				db.WithValidateField("storage_device_choice"),
				db.WithValidateField("no_storage_device"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_StorageDeviceList:
		if fv, exists := v.FldValidators["storage_device_choice.storage_device_list"]; exists {
			val := m.GetStorageDeviceChoice().(*GetSpecType_StorageDeviceList).StorageDeviceList
			vOpts := append(opts,
				db.WithValidateField("storage_device_choice"),
				db.WithValidateField("storage_device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_interface_choice"]; exists {
		val := m.GetStorageInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageInterfaceChoice().(type) {
	case *GetSpecType_NoStorageInterfaces:
		if fv, exists := v.FldValidators["storage_interface_choice.no_storage_interfaces"]; exists {
			val := m.GetStorageInterfaceChoice().(*GetSpecType_NoStorageInterfaces).NoStorageInterfaces
			vOpts := append(opts,
				db.WithValidateField("storage_interface_choice"),
				db.WithValidateField("no_storage_interfaces"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_StorageInterfaceList:
		if fv, exists := v.FldValidators["storage_interface_choice.storage_interface_list"]; exists {
			val := m.GetStorageInterfaceChoice().(*GetSpecType_StorageInterfaceList).StorageInterfaceList
			vOpts := append(opts,
				db.WithValidateField("storage_interface_choice"),
				db.WithValidateField("storage_interface_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_static_routes_choice"]; exists {
		val := m.GetStorageStaticRoutesChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_static_routes_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageStaticRoutesChoice().(type) {
	case *GetSpecType_NoStorageStaticRoutes:
		if fv, exists := v.FldValidators["storage_static_routes_choice.no_storage_static_routes"]; exists {
			val := m.GetStorageStaticRoutesChoice().(*GetSpecType_NoStorageStaticRoutes).NoStorageStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("storage_static_routes_choice"),
				db.WithValidateField("no_storage_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_StorageStaticRoutes:
		if fv, exists := v.FldValidators["storage_static_routes_choice.storage_static_routes"]; exists {
			val := m.GetStorageStaticRoutesChoice().(*GetSpecType_StorageStaticRoutes).StorageStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("storage_static_routes_choice"),
				db.WithValidateField("storage_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["usb_policy_choice"]; exists {
		val := m.GetUsbPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("usb_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetUsbPolicyChoice().(type) {
	case *GetSpecType_DenyAllUsb:
		if fv, exists := v.FldValidators["usb_policy_choice.deny_all_usb"]; exists {
			val := m.GetUsbPolicyChoice().(*GetSpecType_DenyAllUsb).DenyAllUsb
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("deny_all_usb"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AllowAllUsb:
		if fv, exists := v.FldValidators["usb_policy_choice.allow_all_usb"]; exists {
			val := m.GetUsbPolicyChoice().(*GetSpecType_AllowAllUsb).AllowAllUsb
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("allow_all_usb"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_UsbPolicy:
		if fv, exists := v.FldValidators["usb_policy_choice.usb_policy"]; exists {
			val := m.GetUsbPolicyChoice().(*GetSpecType_UsbPolicy).UsbPolicy
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("usb_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBondChoice := v.BondChoiceValidationRuleHandler
	rulesBondChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBondChoice(rulesBondChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.bond_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bond_choice"] = vFn

	vrhDcClusterGroupChoice := v.DcClusterGroupChoiceValidationRuleHandler
	rulesDcClusterGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDcClusterGroupChoice(rulesDcClusterGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.dc_cluster_group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dc_cluster_group_choice"] = vFn

	vrhGpuChoice := v.GpuChoiceValidationRuleHandler
	rulesGpuChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhGpuChoice(rulesGpuChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.gpu_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["gpu_choice"] = vFn

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhStorageClassChoice := v.StorageClassChoiceValidationRuleHandler
	rulesStorageClassChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageClassChoice(rulesStorageClassChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.storage_class_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_class_choice"] = vFn

	vrhStorageDeviceChoice := v.StorageDeviceChoiceValidationRuleHandler
	rulesStorageDeviceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageDeviceChoice(rulesStorageDeviceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.storage_device_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_device_choice"] = vFn

	vrhStorageInterfaceChoice := v.StorageInterfaceChoiceValidationRuleHandler
	rulesStorageInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageInterfaceChoice(rulesStorageInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.storage_interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_interface_choice"] = vFn

	vrhStorageStaticRoutesChoice := v.StorageStaticRoutesChoiceValidationRuleHandler
	rulesStorageStaticRoutesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageStaticRoutesChoice(rulesStorageStaticRoutesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.storage_static_routes_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_static_routes_choice"] = vFn

	vrhUsbPolicyChoice := v.UsbPolicyChoiceValidationRuleHandler
	rulesUsbPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhUsbPolicyChoice(rulesUsbPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.usb_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["usb_policy_choice"] = vFn

	vrhFleetLabel := v.FleetLabelValidationRuleHandler
	rulesFleetLabel := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.k8s_label_value": "true",
	}
	vFn, err = vrhFleetLabel(rulesFleetLabel)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.fleet_label: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fleet_label"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhNetworkConnectors := v.NetworkConnectorsValidationRuleHandler
	rulesNetworkConnectors := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
	}
	vFn, err = vrhNetworkConnectors(rulesNetworkConnectors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.network_connectors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_connectors"] = vFn

	vrhNetworkFirewall := v.NetworkFirewallValidationRuleHandler
	rulesNetworkFirewall := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhNetworkFirewall(rulesNetworkFirewall)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.network_firewall: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_firewall"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhOutsideVirtualNetwork := v.OutsideVirtualNetworkValidationRuleHandler
	rulesOutsideVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhOutsideVirtualNetwork(rulesOutsideVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.outside_virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_virtual_network"] = vFn

	vrhInsideVirtualNetwork := v.InsideVirtualNetworkValidationRuleHandler
	rulesInsideVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhInsideVirtualNetwork(rulesInsideVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.inside_virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_virtual_network"] = vFn

	v.FldValidators["bond_choice.bond_device_list"] = FleetBondDevicesListTypeValidator().Validate

	v.FldValidators["dc_cluster_group_choice.dc_cluster_group"] = ves_io_schema_views.ObjectRefTypeValidator().Validate
	v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["gpu_choice.enable_vgpu"] = VGPUConfigurationValidator().Validate

	v.FldValidators["interface_choice.interface_list"] = FleetInterfaceListTypeValidator().Validate
	v.FldValidators["interface_choice.device_list"] = FleetDeviceListTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["storage_class_choice.storage_class_list"] = FleetStorageClassListTypeValidator().Validate

	v.FldValidators["storage_device_choice.storage_device_list"] = FleetStorageDeviceListTypeValidator().Validate

	v.FldValidators["storage_interface_choice.storage_interface_list"] = FleetInterfaceListTypeValidator().Validate

	v.FldValidators["storage_static_routes_choice.storage_static_routes"] = FleetStorageStaticRoutesListTypeValidator().Validate

	v.FldValidators["usb_policy_choice.usb_policy"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetStorageDeviceList().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.storage_device_list")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDcClusterGroupChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDevicesDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInsideVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetK8SClusterDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLocalControlPlaneDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkConnectorsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkFirewallDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOutsideVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSingleSiteDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStorageInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStorageStaticRoutesChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUsbPolicyChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetViewInternalDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *GlobalSpecType) GetDcClusterGroupChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetDcClusterGroupChoice().(type) {
	case *GlobalSpecType_NoDcClusterGroup:

	case *GlobalSpecType_DcClusterGroup:

		vref := m.GetDcClusterGroup()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		odri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	case *GlobalSpecType_DcClusterGroupInside:

		vref := m.GetDcClusterGroupInside()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		odri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_inside",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetDcClusterGroupChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetDcClusterGroupChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetDcClusterGroupChoice().(type) {
	case *GlobalSpecType_NoDcClusterGroup:

	case *GlobalSpecType_DcClusterGroup:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroup()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *GlobalSpecType_DcClusterGroupInside:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupInside()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetDevicesDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetDevices() == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.GetDevices() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("devices[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

func (m *GlobalSpecType) GetInsideVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetInsideVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.inside_virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "inside_virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetInsideVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetInsideVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetInsideVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetInterfaceChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetInterfaceChoice().(type) {
	case *GlobalSpecType_InterfaceList:
		odrInfos, err = m.GetInterfaceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "interface_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *GlobalSpecType_LegacyDevices:

	case *GlobalSpecType_DefaultInterfaces:

	}

	return drInfos, err
}

func (m *GlobalSpecType) GetK8SClusterDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}

	vref := m.GetK8SCluster()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("k8s_cluster.Object")
	drInfos = append(drInfos, db.DRefInfo{
		RefdType:   "k8s_cluster.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "k8s_cluster",
		Ref:        vdRef,
	})

	return drInfos, nil
}

// GetK8SClusterDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetK8SClusterDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "k8s_cluster.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: k8s_cluster")
	}

	vref := m.GetK8SCluster()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "k8s_cluster.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetLocalControlPlaneDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetLocalControlPlane() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetLocalControlPlane().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "local_control_plane." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *GlobalSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetLogsReceiverChoice().(type) {
	case *GlobalSpecType_LogsStreamingDisabled:

	case *GlobalSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		odri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *GlobalSpecType_LogsStreamingDisabled:

	case *GlobalSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *GlobalSpecType) GetNetworkConnectorsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetNetworkConnectors() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.network_connectors[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_connector.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network_connectors",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetNetworkConnectorsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetNetworkConnectorsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_connector.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_connector")
	}
	for _, ref := range m.GetNetworkConnectors() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetNetworkFirewallDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetNetworkFirewall() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.network_firewall[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_firewall.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network_firewall",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetNetworkFirewallDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetNetworkFirewallDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_firewall.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_firewall")
	}
	for _, ref := range m.GetNetworkFirewall() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetOutsideVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetOutsideVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.outside_virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "outside_virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetOutsideVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetOutsideVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetOutsideVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetSingleSiteDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetSingleSite() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.single_site[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "single_site",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetSingleSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetSingleSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetSingleSite() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetStorageInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetStorageInterfaceChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetStorageInterfaceChoice().(type) {
	case *GlobalSpecType_NoStorageInterfaces:

	case *GlobalSpecType_StorageInterfaceList:
		odrInfos, err = m.GetStorageInterfaceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "storage_interface_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetStorageStaticRoutesChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetStorageStaticRoutesChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetStorageStaticRoutesChoice().(type) {
	case *GlobalSpecType_NoStorageStaticRoutes:

	case *GlobalSpecType_StorageStaticRoutes:
		odrInfos, err = m.GetStorageStaticRoutes().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "storage_static_routes." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

func (m *GlobalSpecType) GetUsbPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetUsbPolicyChoice().(type) {
	case *GlobalSpecType_DenyAllUsb:

	case *GlobalSpecType_AllowAllUsb:

	case *GlobalSpecType_UsbPolicy:

		vref := m.GetUsbPolicy()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("usb_policy.Object")
		odri := db.DRefInfo{
			RefdType:   "usb_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "usb_policy",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetUsbPolicyChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetUsbPolicyChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetUsbPolicyChoice().(type) {
	case *GlobalSpecType_DenyAllUsb:

	case *GlobalSpecType_AllowAllUsb:

	case *GlobalSpecType_UsbPolicy:
		refdType, err := d.TypeForEntryKind("", "", "usb_policy.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: usb_policy")
		}

		vref := m.GetUsbPolicy()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "usb_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *GlobalSpecType) GetViewInternalDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("view_internal.Object")
	drInfos = append(drInfos, db.DRefInfo{
		RefdType:   "view_internal.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "view_internal",
		Ref:        vdRef,
	})

	return drInfos, nil
}

// GetViewInternalDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetViewInternalDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "view_internal.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: view_internal")
	}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "view_internal.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) BondChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bond_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DcClusterGroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dc_cluster_group_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) GpuChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for gpu_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StorageClassChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_class_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StorageDeviceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_device_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StorageInterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StorageStaticRoutesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_static_routes_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) UsbPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for usb_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) FleetLabelValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fleet_label")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DevicesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*DeviceInstanceType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := DeviceInstanceTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for devices")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DeviceInstanceType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DeviceInstanceType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated devices")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items devices")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) NetworkConnectorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for network_connectors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated network_connectors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items network_connectors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) NetworkFirewallValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for network_firewall")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated network_firewall")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items network_firewall")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OutsideVirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for outside_virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated outside_virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items outside_virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InsideVirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for inside_virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated inside_virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items inside_virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SingleSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for single_site")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated single_site")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items single_site")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) GeneratedYamlsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for generated_yamls")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for generated_yamls")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated generated_yamls")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items generated_yamls")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bond_choice"]; exists {
		val := m.GetBondChoice()
		vOpts := append(opts,
			db.WithValidateField("bond_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBondChoice().(type) {
	case *GlobalSpecType_NoBondDevices:
		if fv, exists := v.FldValidators["bond_choice.no_bond_devices"]; exists {
			val := m.GetBondChoice().(*GlobalSpecType_NoBondDevices).NoBondDevices
			vOpts := append(opts,
				db.WithValidateField("bond_choice"),
				db.WithValidateField("no_bond_devices"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_BondDeviceList:
		if fv, exists := v.FldValidators["bond_choice.bond_device_list"]; exists {
			val := m.GetBondChoice().(*GlobalSpecType_BondDeviceList).BondDeviceList
			vOpts := append(opts,
				db.WithValidateField("bond_choice"),
				db.WithValidateField("bond_device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dc_cluster_group_choice"]; exists {
		val := m.GetDcClusterGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("dc_cluster_group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDcClusterGroupChoice().(type) {
	case *GlobalSpecType_NoDcClusterGroup:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.no_dc_cluster_group"]; exists {
			val := m.GetDcClusterGroupChoice().(*GlobalSpecType_NoDcClusterGroup).NoDcClusterGroup
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("no_dc_cluster_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DcClusterGroup:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group"]; exists {
			val := m.GetDcClusterGroupChoice().(*GlobalSpecType_DcClusterGroup).DcClusterGroup
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DcClusterGroupInside:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside"]; exists {
			val := m.GetDcClusterGroupChoice().(*GlobalSpecType_DcClusterGroupInside).DcClusterGroupInside
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group_inside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["devices"]; exists {
		vOpts := append(opts, db.WithValidateField("devices"))
		if err := fv(ctx, m.GetDevices(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["enable_default_fleet_config_download"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_default_fleet_config_download"))
		if err := fv(ctx, m.GetEnableDefaultFleetConfigDownload(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["etcd_cluster_network"]; exists {

		vOpts := append(opts, db.WithValidateField("etcd_cluster_network"))
		if err := fv(ctx, m.GetEtcdClusterNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fleet_label"]; exists {

		vOpts := append(opts, db.WithValidateField("fleet_label"))
		if err := fv(ctx, m.GetFleetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fleet_type"]; exists {

		vOpts := append(opts, db.WithValidateField("fleet_type"))
		if err := fv(ctx, m.GetFleetType(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetFlowExporterChoice().(type) {
	case *GlobalSpecType_DisableFlowExport:
		if fv, exists := v.FldValidators["flow_exporter_choice.disable_flow_export"]; exists {
			val := m.GetFlowExporterChoice().(*GlobalSpecType_DisableFlowExport).DisableFlowExport
			vOpts := append(opts,
				db.WithValidateField("flow_exporter_choice"),
				db.WithValidateField("disable_flow_export"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_EnableFlowExport:
		if fv, exists := v.FldValidators["flow_exporter_choice.enable_flow_export"]; exists {
			val := m.GetFlowExporterChoice().(*GlobalSpecType_EnableFlowExport).EnableFlowExport
			vOpts := append(opts,
				db.WithValidateField("flow_exporter_choice"),
				db.WithValidateField("enable_flow_export"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["generated_yamls"]; exists {
		vOpts := append(opts, db.WithValidateField("generated_yamls"))
		if err := fv(ctx, m.GetGeneratedYamls(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gpu_choice"]; exists {
		val := m.GetGpuChoice()
		vOpts := append(opts,
			db.WithValidateField("gpu_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGpuChoice().(type) {
	case *GlobalSpecType_DisableGpu:
		if fv, exists := v.FldValidators["gpu_choice.disable_gpu"]; exists {
			val := m.GetGpuChoice().(*GlobalSpecType_DisableGpu).DisableGpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("disable_gpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_EnableGpu:
		if fv, exists := v.FldValidators["gpu_choice.enable_gpu"]; exists {
			val := m.GetGpuChoice().(*GlobalSpecType_EnableGpu).EnableGpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("enable_gpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_EnableVgpu:
		if fv, exists := v.FldValidators["gpu_choice.enable_vgpu"]; exists {
			val := m.GetGpuChoice().(*GlobalSpecType_EnableVgpu).EnableVgpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("enable_vgpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["inside_virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("inside_virtual_network"))
		if err := fv(ctx, m.GetInsideVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *GlobalSpecType_InterfaceList:
		if fv, exists := v.FldValidators["interface_choice.interface_list"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_InterfaceList).InterfaceList
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("interface_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_LegacyDevices:
		if fv, exists := v.FldValidators["interface_choice.legacy_devices"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_LegacyDevices).LegacyDevices
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("legacy_devices"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DefaultInterfaces:
		if fv, exists := v.FldValidators["interface_choice.default_interfaces"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_DefaultInterfaces).DefaultInterfaces
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("default_interfaces"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["k8s_cluster"]; exists {

		vOpts := append(opts, db.WithValidateField("k8s_cluster"))
		if err := fv(ctx, m.GetK8SCluster(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_control_plane"]; exists {

		vOpts := append(opts, db.WithValidateField("local_control_plane"))
		if err := fv(ctx, m.GetLocalControlPlane(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *GlobalSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*GlobalSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*GlobalSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_connectors"]; exists {
		vOpts := append(opts, db.WithValidateField("network_connectors"))
		if err := fv(ctx, m.GetNetworkConnectors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_firewall"]; exists {
		vOpts := append(opts, db.WithValidateField("network_firewall"))
		if err := fv(ctx, m.GetNetworkFirewall(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("outside_virtual_network"))
		if err := fv(ctx, m.GetOutsideVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["single_site"]; exists {
		vOpts := append(opts, db.WithValidateField("single_site"))
		if err := fv(ctx, m.GetSingleSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_class_choice"]; exists {
		val := m.GetStorageClassChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_class_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageClassChoice().(type) {
	case *GlobalSpecType_DefaultStorageClass:
		if fv, exists := v.FldValidators["storage_class_choice.default_storage_class"]; exists {
			val := m.GetStorageClassChoice().(*GlobalSpecType_DefaultStorageClass).DefaultStorageClass
			vOpts := append(opts,
				db.WithValidateField("storage_class_choice"),
				db.WithValidateField("default_storage_class"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_StorageClassList:
		if fv, exists := v.FldValidators["storage_class_choice.storage_class_list"]; exists {
			val := m.GetStorageClassChoice().(*GlobalSpecType_StorageClassList).StorageClassList
			vOpts := append(opts,
				db.WithValidateField("storage_class_choice"),
				db.WithValidateField("storage_class_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_device_choice"]; exists {
		val := m.GetStorageDeviceChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_device_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageDeviceChoice().(type) {
	case *GlobalSpecType_NoStorageDevice:
		if fv, exists := v.FldValidators["storage_device_choice.no_storage_device"]; exists {
			val := m.GetStorageDeviceChoice().(*GlobalSpecType_NoStorageDevice).NoStorageDevice
			vOpts := append(opts,
				db.WithValidateField("storage_device_choice"),
				db.WithValidateField("no_storage_device"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_StorageDeviceList:
		if fv, exists := v.FldValidators["storage_device_choice.storage_device_list"]; exists {
			val := m.GetStorageDeviceChoice().(*GlobalSpecType_StorageDeviceList).StorageDeviceList
			vOpts := append(opts,
				db.WithValidateField("storage_device_choice"),
				db.WithValidateField("storage_device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_interface_choice"]; exists {
		val := m.GetStorageInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageInterfaceChoice().(type) {
	case *GlobalSpecType_NoStorageInterfaces:
		if fv, exists := v.FldValidators["storage_interface_choice.no_storage_interfaces"]; exists {
			val := m.GetStorageInterfaceChoice().(*GlobalSpecType_NoStorageInterfaces).NoStorageInterfaces
			vOpts := append(opts,
				db.WithValidateField("storage_interface_choice"),
				db.WithValidateField("no_storage_interfaces"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_StorageInterfaceList:
		if fv, exists := v.FldValidators["storage_interface_choice.storage_interface_list"]; exists {
			val := m.GetStorageInterfaceChoice().(*GlobalSpecType_StorageInterfaceList).StorageInterfaceList
			vOpts := append(opts,
				db.WithValidateField("storage_interface_choice"),
				db.WithValidateField("storage_interface_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_static_routes_choice"]; exists {
		val := m.GetStorageStaticRoutesChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_static_routes_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageStaticRoutesChoice().(type) {
	case *GlobalSpecType_NoStorageStaticRoutes:
		if fv, exists := v.FldValidators["storage_static_routes_choice.no_storage_static_routes"]; exists {
			val := m.GetStorageStaticRoutesChoice().(*GlobalSpecType_NoStorageStaticRoutes).NoStorageStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("storage_static_routes_choice"),
				db.WithValidateField("no_storage_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_StorageStaticRoutes:
		if fv, exists := v.FldValidators["storage_static_routes_choice.storage_static_routes"]; exists {
			val := m.GetStorageStaticRoutesChoice().(*GlobalSpecType_StorageStaticRoutes).StorageStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("storage_static_routes_choice"),
				db.WithValidateField("storage_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["usb_policy_choice"]; exists {
		val := m.GetUsbPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("usb_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetUsbPolicyChoice().(type) {
	case *GlobalSpecType_DenyAllUsb:
		if fv, exists := v.FldValidators["usb_policy_choice.deny_all_usb"]; exists {
			val := m.GetUsbPolicyChoice().(*GlobalSpecType_DenyAllUsb).DenyAllUsb
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("deny_all_usb"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AllowAllUsb:
		if fv, exists := v.FldValidators["usb_policy_choice.allow_all_usb"]; exists {
			val := m.GetUsbPolicyChoice().(*GlobalSpecType_AllowAllUsb).AllowAllUsb
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("allow_all_usb"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_UsbPolicy:
		if fv, exists := v.FldValidators["usb_policy_choice.usb_policy"]; exists {
			val := m.GetUsbPolicyChoice().(*GlobalSpecType_UsbPolicy).UsbPolicy
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("usb_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["view_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("view_internal"))
		if err := fv(ctx, m.GetViewInternal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBondChoice := v.BondChoiceValidationRuleHandler
	rulesBondChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBondChoice(rulesBondChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.bond_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bond_choice"] = vFn

	vrhDcClusterGroupChoice := v.DcClusterGroupChoiceValidationRuleHandler
	rulesDcClusterGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDcClusterGroupChoice(rulesDcClusterGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.dc_cluster_group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dc_cluster_group_choice"] = vFn

	vrhGpuChoice := v.GpuChoiceValidationRuleHandler
	rulesGpuChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhGpuChoice(rulesGpuChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.gpu_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["gpu_choice"] = vFn

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhStorageClassChoice := v.StorageClassChoiceValidationRuleHandler
	rulesStorageClassChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageClassChoice(rulesStorageClassChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.storage_class_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_class_choice"] = vFn

	vrhStorageDeviceChoice := v.StorageDeviceChoiceValidationRuleHandler
	rulesStorageDeviceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageDeviceChoice(rulesStorageDeviceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.storage_device_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_device_choice"] = vFn

	vrhStorageInterfaceChoice := v.StorageInterfaceChoiceValidationRuleHandler
	rulesStorageInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageInterfaceChoice(rulesStorageInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.storage_interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_interface_choice"] = vFn

	vrhStorageStaticRoutesChoice := v.StorageStaticRoutesChoiceValidationRuleHandler
	rulesStorageStaticRoutesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageStaticRoutesChoice(rulesStorageStaticRoutesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.storage_static_routes_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_static_routes_choice"] = vFn

	vrhUsbPolicyChoice := v.UsbPolicyChoiceValidationRuleHandler
	rulesUsbPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhUsbPolicyChoice(rulesUsbPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.usb_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["usb_policy_choice"] = vFn

	vrhFleetLabel := v.FleetLabelValidationRuleHandler
	rulesFleetLabel := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.k8s_label_value": "true",
	}
	vFn, err = vrhFleetLabel(rulesFleetLabel)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.fleet_label: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fleet_label"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhDevices := v.DevicesValidationRuleHandler
	rulesDevices := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
	}
	vFn, err = vrhDevices(rulesDevices)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.devices: %s", err)
		panic(errMsg)
	}
	v.FldValidators["devices"] = vFn

	vrhNetworkConnectors := v.NetworkConnectorsValidationRuleHandler
	rulesNetworkConnectors := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
	}
	vFn, err = vrhNetworkConnectors(rulesNetworkConnectors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.network_connectors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_connectors"] = vFn

	vrhNetworkFirewall := v.NetworkFirewallValidationRuleHandler
	rulesNetworkFirewall := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhNetworkFirewall(rulesNetworkFirewall)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.network_firewall: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_firewall"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhOutsideVirtualNetwork := v.OutsideVirtualNetworkValidationRuleHandler
	rulesOutsideVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhOutsideVirtualNetwork(rulesOutsideVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.outside_virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_virtual_network"] = vFn

	vrhInsideVirtualNetwork := v.InsideVirtualNetworkValidationRuleHandler
	rulesInsideVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhInsideVirtualNetwork(rulesInsideVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.inside_virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_virtual_network"] = vFn

	vrhSingleSite := v.SingleSiteValidationRuleHandler
	rulesSingleSite := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhSingleSite(rulesSingleSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.single_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["single_site"] = vFn

	vrhGeneratedYamls := v.GeneratedYamlsValidationRuleHandler
	rulesGeneratedYamls := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhGeneratedYamls(rulesGeneratedYamls)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.generated_yamls: %s", err)
		panic(errMsg)
	}
	v.FldValidators["generated_yamls"] = vFn

	v.FldValidators["bond_choice.bond_device_list"] = FleetBondDevicesListTypeValidator().Validate

	v.FldValidators["dc_cluster_group_choice.dc_cluster_group"] = ves_io_schema_views.ObjectRefTypeValidator().Validate
	v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["gpu_choice.enable_vgpu"] = VGPUConfigurationValidator().Validate

	v.FldValidators["interface_choice.interface_list"] = FleetInterfaceListTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["storage_class_choice.storage_class_list"] = FleetStorageClassListTypeValidator().Validate

	v.FldValidators["storage_device_choice.storage_device_list"] = FleetStorageDeviceListTypeValidator().Validate

	v.FldValidators["storage_interface_choice.storage_interface_list"] = FleetInterfaceListTypeValidator().Validate

	v.FldValidators["storage_static_routes_choice.storage_static_routes"] = FleetStorageStaticRoutesListTypeValidator().Validate

	v.FldValidators["usb_policy_choice.usb_policy"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["k8s_cluster"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["local_control_plane"] = LocalControlPlaneTypeValidator().Validate

	v.FldValidators["view_internal"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LocalControlPlaneType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LocalControlPlaneType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LocalControlPlaneType) DeepCopy() *LocalControlPlaneType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LocalControlPlaneType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LocalControlPlaneType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LocalControlPlaneType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LocalControlPlaneTypeValidator().Validate(ctx, m, opts...)
}

func (m *LocalControlPlaneType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetBgpConfigDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *LocalControlPlaneType) GetBgpConfigDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetBgpConfig() == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.GetBgpConfig().GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "bgp_config." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

type ValidateLocalControlPlaneType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLocalControlPlaneType) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateLocalControlPlaneType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LocalControlPlaneType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LocalControlPlaneType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bgp_config"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_config"))
		if err := fv(ctx, m.GetBgpConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *LocalControlPlaneType_InsideVn:
		if fv, exists := v.FldValidators["network_choice.inside_vn"]; exists {
			val := m.GetNetworkChoice().(*LocalControlPlaneType_InsideVn).InsideVn
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("inside_vn"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LocalControlPlaneType_OutsideVn:
		if fv, exists := v.FldValidators["network_choice.outside_vn"]; exists {
			val := m.GetNetworkChoice().(*LocalControlPlaneType_OutsideVn).OutsideVn
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("outside_vn"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLocalControlPlaneTypeValidator = func() *ValidateLocalControlPlaneType {
	v := &ValidateLocalControlPlaneType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LocalControlPlaneType.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	v.FldValidators["bgp_config"] = BGPConfigurationValidator().Validate

	return v
}()

func LocalControlPlaneTypeValidator() db.Validator {
	return DefaultLocalControlPlaneTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkingDeviceInstanceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkingDeviceInstanceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkingDeviceInstanceType) DeepCopy() *NetworkingDeviceInstanceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkingDeviceInstanceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkingDeviceInstanceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkingDeviceInstanceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkingDeviceInstanceTypeValidator().Validate(ctx, m, opts...)
}

func (m *NetworkingDeviceInstanceType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetInterfaceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *NetworkingDeviceInstanceType) GetInterfaceDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetInterface() {
		if ref == nil {
			return nil, fmt.Errorf("NetworkingDeviceInstanceType.interface[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_interface.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "interface",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetInterfaceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *NetworkingDeviceInstanceType) GetInterfaceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_interface.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_interface")
	}
	for _, ref := range m.GetInterface() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateNetworkingDeviceInstanceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkingDeviceInstanceType) InterfaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for interface")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated interface")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateNetworkingDeviceInstanceType) UseValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkingDeviceInstanceUseType)
		return int32(i)
	}
	// NetworkingDeviceInstanceUseType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkingDeviceInstanceUseType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for use")
	}

	return validatorFn, nil
}

func (v *ValidateNetworkingDeviceInstanceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkingDeviceInstanceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkingDeviceInstanceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface"]; exists {
		vOpts := append(opts, db.WithValidateField("interface"))
		if err := fv(ctx, m.GetInterface(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["use"]; exists {

		vOpts := append(opts, db.WithValidateField("use"))
		if err := fv(ctx, m.GetUse(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkingDeviceInstanceTypeValidator = func() *ValidateNetworkingDeviceInstanceType {
	v := &ValidateNetworkingDeviceInstanceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterface := v.InterfaceValidationRuleHandler
	rulesInterface := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhInterface(rulesInterface)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkingDeviceInstanceType.interface: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface"] = vFn

	vrhUse := v.UseValidationRuleHandler
	rulesUse := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhUse(rulesUse)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkingDeviceInstanceType.use: %s", err)
		panic(errMsg)
	}
	v.FldValidators["use"] = vFn

	return v
}()

func NetworkingDeviceInstanceTypeValidator() db.Validator {
	return DefaultNetworkingDeviceInstanceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OntapVirtualStoragePoolType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OntapVirtualStoragePoolType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OntapVirtualStoragePoolType) DeepCopy() *OntapVirtualStoragePoolType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OntapVirtualStoragePoolType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OntapVirtualStoragePoolType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OntapVirtualStoragePoolType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OntapVirtualStoragePoolTypeValidator().Validate(ctx, m, opts...)
}

type ValidateOntapVirtualStoragePoolType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOntapVirtualStoragePoolType) LabelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for labels")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for labels")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for labels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map labels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items labels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOntapVirtualStoragePoolType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OntapVirtualStoragePoolType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OntapVirtualStoragePoolType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["labels"]; exists {
		vOpts := append(opts, db.WithValidateField("labels"))
		if err := fv(ctx, m.GetLabels(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volume_defaults"]; exists {

		vOpts := append(opts, db.WithValidateField("volume_defaults"))
		if err := fv(ctx, m.GetVolumeDefaults(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["zone"]; exists {

		vOpts := append(opts, db.WithValidateField("zone"))
		if err := fv(ctx, m.GetZone(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOntapVirtualStoragePoolTypeValidator = func() *ValidateOntapVirtualStoragePoolType {
	v := &ValidateOntapVirtualStoragePoolType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLabels := v.LabelsValidationRuleHandler
	rulesLabels := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "128",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "20",
		"ves.io.schema.rules.map.values.string.max_len": "128",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhLabels(rulesLabels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OntapVirtualStoragePoolType.labels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["labels"] = vFn

	v.FldValidators["volume_defaults"] = OntapVolumeDefaultsValidator().Validate

	return v
}()

func OntapVirtualStoragePoolTypeValidator() db.Validator {
	return DefaultOntapVirtualStoragePoolTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OntapVolumeDefaults) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OntapVolumeDefaults) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OntapVolumeDefaults) DeepCopy() *OntapVolumeDefaults {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OntapVolumeDefaults{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OntapVolumeDefaults) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OntapVolumeDefaults) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OntapVolumeDefaultsValidator().Validate(ctx, m, opts...)
}

type ValidateOntapVolumeDefaults struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOntapVolumeDefaults) QosPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for qos_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOntapVolumeDefaults) QosPolicyChoiceQosPolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_QosPolicy, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for qos_policy")
	}
	return oValidatorFn_QosPolicy, nil
}
func (v *ValidateOntapVolumeDefaults) QosPolicyChoiceAdaptiveQosPolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AdaptiveQosPolicy, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for adaptive_qos_policy")
	}
	return oValidatorFn_AdaptiveQosPolicy, nil
}

func (v *ValidateOntapVolumeDefaults) SpaceReserveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for space_reserve")
	}

	return validatorFn, nil
}

func (v *ValidateOntapVolumeDefaults) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OntapVolumeDefaults)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OntapVolumeDefaults got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["encryption"]; exists {

		vOpts := append(opts, db.WithValidateField("encryption"))
		if err := fv(ctx, m.GetEncryption(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["export_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("export_policy"))
		if err := fv(ctx, m.GetExportPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["qos_policy_choice"]; exists {
		val := m.GetQosPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("qos_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetQosPolicyChoice().(type) {
	case *OntapVolumeDefaults_NoQos:
		if fv, exists := v.FldValidators["qos_policy_choice.no_qos"]; exists {
			val := m.GetQosPolicyChoice().(*OntapVolumeDefaults_NoQos).NoQos
			vOpts := append(opts,
				db.WithValidateField("qos_policy_choice"),
				db.WithValidateField("no_qos"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OntapVolumeDefaults_QosPolicy:
		if fv, exists := v.FldValidators["qos_policy_choice.qos_policy"]; exists {
			val := m.GetQosPolicyChoice().(*OntapVolumeDefaults_QosPolicy).QosPolicy
			vOpts := append(opts,
				db.WithValidateField("qos_policy_choice"),
				db.WithValidateField("qos_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OntapVolumeDefaults_AdaptiveQosPolicy:
		if fv, exists := v.FldValidators["qos_policy_choice.adaptive_qos_policy"]; exists {
			val := m.GetQosPolicyChoice().(*OntapVolumeDefaults_AdaptiveQosPolicy).AdaptiveQosPolicy
			vOpts := append(opts,
				db.WithValidateField("qos_policy_choice"),
				db.WithValidateField("adaptive_qos_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["security_style"]; exists {

		vOpts := append(opts, db.WithValidateField("security_style"))
		if err := fv(ctx, m.GetSecurityStyle(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["snapshot_dir"]; exists {

		vOpts := append(opts, db.WithValidateField("snapshot_dir"))
		if err := fv(ctx, m.GetSnapshotDir(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["snapshot_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("snapshot_policy"))
		if err := fv(ctx, m.GetSnapshotPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["snapshot_reserve"]; exists {

		vOpts := append(opts, db.WithValidateField("snapshot_reserve"))
		if err := fv(ctx, m.GetSnapshotReserve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["space_reserve"]; exists {

		vOpts := append(opts, db.WithValidateField("space_reserve"))
		if err := fv(ctx, m.GetSpaceReserve(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["split_on_clone"]; exists {

		vOpts := append(opts, db.WithValidateField("split_on_clone"))
		if err := fv(ctx, m.GetSplitOnClone(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tiering_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("tiering_policy"))
		if err := fv(ctx, m.GetTieringPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unix_permissions"]; exists {

		vOpts := append(opts, db.WithValidateField("unix_permissions"))
		if err := fv(ctx, m.GetUnixPermissions(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOntapVolumeDefaultsValidator = func() *ValidateOntapVolumeDefaults {
	v := &ValidateOntapVolumeDefaults{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQosPolicyChoice := v.QosPolicyChoiceValidationRuleHandler
	rulesQosPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhQosPolicyChoice(rulesQosPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OntapVolumeDefaults.qos_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["qos_policy_choice"] = vFn

	vrhQosPolicyChoiceQosPolicy := v.QosPolicyChoiceQosPolicyValidationRuleHandler
	rulesQosPolicyChoiceQosPolicy := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["qos_policy_choice.qos_policy"], err = vrhQosPolicyChoiceQosPolicy(rulesQosPolicyChoiceQosPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OntapVolumeDefaults.qos_policy_choice_qos_policy: %s", err)
		panic(errMsg)
	}
	vrhQosPolicyChoiceAdaptiveQosPolicy := v.QosPolicyChoiceAdaptiveQosPolicyValidationRuleHandler
	rulesQosPolicyChoiceAdaptiveQosPolicy := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["qos_policy_choice.adaptive_qos_policy"], err = vrhQosPolicyChoiceAdaptiveQosPolicy(rulesQosPolicyChoiceAdaptiveQosPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OntapVolumeDefaults.qos_policy_choice_adaptive_qos_policy: %s", err)
		panic(errMsg)
	}

	v.FldValidators["qos_policy_choice.qos_policy"] = vFnMap["qos_policy_choice.qos_policy"]
	v.FldValidators["qos_policy_choice.adaptive_qos_policy"] = vFnMap["qos_policy_choice.adaptive_qos_policy"]

	vrhSpaceReserve := v.SpaceReserveValidationRuleHandler
	rulesSpaceReserve := map[string]string{
		"ves.io.schema.rules.string.in": "[\"none\",\"thick\"]",
	}
	vFn, err = vrhSpaceReserve(rulesSpaceReserve)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OntapVolumeDefaults.space_reserve: %s", err)
		panic(errMsg)
	}
	v.FldValidators["space_reserve"] = vFn

	return v
}()

func OntapVolumeDefaultsValidator() db.Validator {
	return DefaultOntapVolumeDefaultsValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenebsMayastorPoolType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenebsMayastorPoolType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenebsMayastorPoolType) DeepCopy() *OpenebsMayastorPoolType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenebsMayastorPoolType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenebsMayastorPoolType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenebsMayastorPoolType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenebsMayastorPoolTypeValidator().Validate(ctx, m, opts...)
}

type ValidateOpenebsMayastorPoolType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenebsMayastorPoolType) PoolNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pool_name")
	}

	return validatorFn, nil
}

func (v *ValidateOpenebsMayastorPoolType) NodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}

	return validatorFn, nil
}

func (v *ValidateOpenebsMayastorPoolType) PoolDiskDevicesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for pool_disk_devices")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for pool_disk_devices")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated pool_disk_devices")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items pool_disk_devices")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOpenebsMayastorPoolType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenebsMayastorPoolType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenebsMayastorPoolType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["node"]; exists {

		vOpts := append(opts, db.WithValidateField("node"))
		if err := fv(ctx, m.GetNode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_disk_devices"]; exists {
		vOpts := append(opts, db.WithValidateField("pool_disk_devices"))
		if err := fv(ctx, m.GetPoolDiskDevices(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_name"]; exists {

		vOpts := append(opts, db.WithValidateField("pool_name"))
		if err := fv(ctx, m.GetPoolName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenebsMayastorPoolTypeValidator = func() *ValidateOpenebsMayastorPoolType {
	v := &ValidateOpenebsMayastorPoolType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPoolName := v.PoolNameValidationRuleHandler
	rulesPoolName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhPoolName(rulesPoolName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenebsMayastorPoolType.pool_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pool_name"] = vFn

	vrhNode := v.NodeValidationRuleHandler
	rulesNode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
	}
	vFn, err = vrhNode(rulesNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenebsMayastorPoolType.node: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node"] = vFn

	vrhPoolDiskDevices := v.PoolDiskDevicesValidationRuleHandler
	rulesPoolDiskDevices := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "10",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhPoolDiskDevices(rulesPoolDiskDevices)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenebsMayastorPoolType.pool_disk_devices: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pool_disk_devices"] = vFn

	return v
}()

func OpenebsMayastorPoolTypeValidator() db.Validator {
	return DefaultOpenebsMayastorPoolTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PsoArrayConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PsoArrayConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *PsoArrayConfiguration) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetFlashArray().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting PsoArrayConfiguration.flash_array")
	}

	if err := m.GetFlashBlade().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting PsoArrayConfiguration.flash_blade")
	}

	return nil
}

func (m *PsoArrayConfiguration) DeepCopy() *PsoArrayConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PsoArrayConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PsoArrayConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PsoArrayConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PsoArrayConfigurationValidator().Validate(ctx, m, opts...)
}

type ValidatePsoArrayConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePsoArrayConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PsoArrayConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PsoArrayConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["flash_array"]; exists {

		vOpts := append(opts, db.WithValidateField("flash_array"))
		if err := fv(ctx, m.GetFlashArray(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flash_blade"]; exists {

		vOpts := append(opts, db.WithValidateField("flash_blade"))
		if err := fv(ctx, m.GetFlashBlade(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPsoArrayConfigurationValidator = func() *ValidatePsoArrayConfiguration {
	v := &ValidatePsoArrayConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["flash_array"] = FlashArrayTypeValidator().Validate

	v.FldValidators["flash_blade"] = FlashBladeTypeValidator().Validate

	return v
}()

func PsoArrayConfigurationValidator() db.Validator {
	return DefaultPsoArrayConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetStorageDeviceList().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.storage_device_list")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDcClusterGroupChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInsideVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkConnectorsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkFirewallDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOutsideVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStorageInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStorageStaticRoutesChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetUsbPolicyChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *ReplaceSpecType) GetDcClusterGroupChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetDcClusterGroupChoice().(type) {
	case *ReplaceSpecType_NoDcClusterGroup:

	case *ReplaceSpecType_DcClusterGroup:

		vref := m.GetDcClusterGroup()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		odri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	case *ReplaceSpecType_DcClusterGroupInside:

		vref := m.GetDcClusterGroupInside()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		odri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_inside",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetDcClusterGroupChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetDcClusterGroupChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetDcClusterGroupChoice().(type) {
	case *ReplaceSpecType_NoDcClusterGroup:

	case *ReplaceSpecType_DcClusterGroup:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroup()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *ReplaceSpecType_DcClusterGroupInside:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupInside()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *ReplaceSpecType) GetInsideVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetInsideVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.inside_virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "inside_virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetInsideVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetInsideVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetInsideVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetInterfaceChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetInterfaceChoice().(type) {
	case *ReplaceSpecType_InterfaceList:
		odrInfos, err = m.GetInterfaceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "interface_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *ReplaceSpecType_DeviceList:
		odrInfos, err = m.GetDeviceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "device_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *ReplaceSpecType_DefaultConfig:

	}

	return drInfos, err
}

func (m *ReplaceSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetLogsReceiverChoice().(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:

	case *ReplaceSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		odri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:

	case *ReplaceSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *ReplaceSpecType) GetNetworkConnectorsDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetNetworkConnectors() {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.network_connectors[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_connector.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network_connectors",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetNetworkConnectorsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetNetworkConnectorsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_connector.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_connector")
	}
	for _, ref := range m.GetNetworkConnectors() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetNetworkFirewallDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetNetworkFirewall() {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.network_firewall[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_firewall.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "network_firewall",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetNetworkFirewallDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetNetworkFirewallDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_firewall.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_firewall")
	}
	for _, ref := range m.GetNetworkFirewall() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetOutsideVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetOutsideVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.outside_virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "outside_virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetOutsideVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetOutsideVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetOutsideVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetStorageInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetStorageInterfaceChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetStorageInterfaceChoice().(type) {
	case *ReplaceSpecType_NoStorageInterfaces:

	case *ReplaceSpecType_StorageInterfaceList:
		odrInfos, err = m.GetStorageInterfaceList().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "storage_interface_list." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetStorageStaticRoutesChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.GetStorageStaticRoutesChoice() == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetStorageStaticRoutesChoice().(type) {
	case *ReplaceSpecType_NoStorageStaticRoutes:

	case *ReplaceSpecType_StorageStaticRoutes:
		odrInfos, err = m.GetStorageStaticRoutes().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "storage_static_routes." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

func (m *ReplaceSpecType) GetUsbPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetUsbPolicyChoice().(type) {
	case *ReplaceSpecType_DenyAllUsb:

	case *ReplaceSpecType_AllowAllUsb:

	case *ReplaceSpecType_UsbPolicy:

		vref := m.GetUsbPolicy()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("usb_policy.Object")
		odri := db.DRefInfo{
			RefdType:   "usb_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "usb_policy",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetUsbPolicyChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetUsbPolicyChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetUsbPolicyChoice().(type) {
	case *ReplaceSpecType_DenyAllUsb:

	case *ReplaceSpecType_AllowAllUsb:

	case *ReplaceSpecType_UsbPolicy:
		refdType, err := d.TypeForEntryKind("", "", "usb_policy.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: usb_policy")
		}

		vref := m.GetUsbPolicy()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "usb_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) BondChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bond_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) DcClusterGroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dc_cluster_group_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) GpuChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for gpu_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) StorageClassChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_class_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) StorageDeviceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_device_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) StorageInterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) StorageStaticRoutesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_static_routes_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) UsbPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for usb_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) NetworkConnectorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for network_connectors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated network_connectors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items network_connectors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) NetworkFirewallValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for network_firewall")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated network_firewall")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items network_firewall")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OutsideVirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for outside_virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated outside_virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items outside_virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) InsideVirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for inside_virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated inside_virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items inside_virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bond_choice"]; exists {
		val := m.GetBondChoice()
		vOpts := append(opts,
			db.WithValidateField("bond_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBondChoice().(type) {
	case *ReplaceSpecType_NoBondDevices:
		if fv, exists := v.FldValidators["bond_choice.no_bond_devices"]; exists {
			val := m.GetBondChoice().(*ReplaceSpecType_NoBondDevices).NoBondDevices
			vOpts := append(opts,
				db.WithValidateField("bond_choice"),
				db.WithValidateField("no_bond_devices"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_BondDeviceList:
		if fv, exists := v.FldValidators["bond_choice.bond_device_list"]; exists {
			val := m.GetBondChoice().(*ReplaceSpecType_BondDeviceList).BondDeviceList
			vOpts := append(opts,
				db.WithValidateField("bond_choice"),
				db.WithValidateField("bond_device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dc_cluster_group_choice"]; exists {
		val := m.GetDcClusterGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("dc_cluster_group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDcClusterGroupChoice().(type) {
	case *ReplaceSpecType_NoDcClusterGroup:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.no_dc_cluster_group"]; exists {
			val := m.GetDcClusterGroupChoice().(*ReplaceSpecType_NoDcClusterGroup).NoDcClusterGroup
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("no_dc_cluster_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DcClusterGroup:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group"]; exists {
			val := m.GetDcClusterGroupChoice().(*ReplaceSpecType_DcClusterGroup).DcClusterGroup
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DcClusterGroupInside:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside"]; exists {
			val := m.GetDcClusterGroupChoice().(*ReplaceSpecType_DcClusterGroupInside).DcClusterGroupInside
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group_inside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enable_default_fleet_config_download"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_default_fleet_config_download"))
		if err := fv(ctx, m.GetEnableDefaultFleetConfigDownload(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gpu_choice"]; exists {
		val := m.GetGpuChoice()
		vOpts := append(opts,
			db.WithValidateField("gpu_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGpuChoice().(type) {
	case *ReplaceSpecType_DisableGpu:
		if fv, exists := v.FldValidators["gpu_choice.disable_gpu"]; exists {
			val := m.GetGpuChoice().(*ReplaceSpecType_DisableGpu).DisableGpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("disable_gpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_EnableGpu:
		if fv, exists := v.FldValidators["gpu_choice.enable_gpu"]; exists {
			val := m.GetGpuChoice().(*ReplaceSpecType_EnableGpu).EnableGpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("enable_gpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_EnableVgpu:
		if fv, exists := v.FldValidators["gpu_choice.enable_vgpu"]; exists {
			val := m.GetGpuChoice().(*ReplaceSpecType_EnableVgpu).EnableVgpu
			vOpts := append(opts,
				db.WithValidateField("gpu_choice"),
				db.WithValidateField("enable_vgpu"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["inside_virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("inside_virtual_network"))
		if err := fv(ctx, m.GetInsideVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *ReplaceSpecType_InterfaceList:
		if fv, exists := v.FldValidators["interface_choice.interface_list"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_InterfaceList).InterfaceList
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("interface_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DeviceList:
		if fv, exists := v.FldValidators["interface_choice.device_list"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_DeviceList).DeviceList
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DefaultConfig:
		if fv, exists := v.FldValidators["interface_choice.default_config"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_DefaultConfig).DefaultConfig
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("default_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_connectors"]; exists {
		vOpts := append(opts, db.WithValidateField("network_connectors"))
		if err := fv(ctx, m.GetNetworkConnectors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_firewall"]; exists {
		vOpts := append(opts, db.WithValidateField("network_firewall"))
		if err := fv(ctx, m.GetNetworkFirewall(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("outside_virtual_network"))
		if err := fv(ctx, m.GetOutsideVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_class_choice"]; exists {
		val := m.GetStorageClassChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_class_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageClassChoice().(type) {
	case *ReplaceSpecType_DefaultStorageClass:
		if fv, exists := v.FldValidators["storage_class_choice.default_storage_class"]; exists {
			val := m.GetStorageClassChoice().(*ReplaceSpecType_DefaultStorageClass).DefaultStorageClass
			vOpts := append(opts,
				db.WithValidateField("storage_class_choice"),
				db.WithValidateField("default_storage_class"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_StorageClassList:
		if fv, exists := v.FldValidators["storage_class_choice.storage_class_list"]; exists {
			val := m.GetStorageClassChoice().(*ReplaceSpecType_StorageClassList).StorageClassList
			vOpts := append(opts,
				db.WithValidateField("storage_class_choice"),
				db.WithValidateField("storage_class_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_device_choice"]; exists {
		val := m.GetStorageDeviceChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_device_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageDeviceChoice().(type) {
	case *ReplaceSpecType_NoStorageDevice:
		if fv, exists := v.FldValidators["storage_device_choice.no_storage_device"]; exists {
			val := m.GetStorageDeviceChoice().(*ReplaceSpecType_NoStorageDevice).NoStorageDevice
			vOpts := append(opts,
				db.WithValidateField("storage_device_choice"),
				db.WithValidateField("no_storage_device"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_StorageDeviceList:
		if fv, exists := v.FldValidators["storage_device_choice.storage_device_list"]; exists {
			val := m.GetStorageDeviceChoice().(*ReplaceSpecType_StorageDeviceList).StorageDeviceList
			vOpts := append(opts,
				db.WithValidateField("storage_device_choice"),
				db.WithValidateField("storage_device_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_interface_choice"]; exists {
		val := m.GetStorageInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageInterfaceChoice().(type) {
	case *ReplaceSpecType_NoStorageInterfaces:
		if fv, exists := v.FldValidators["storage_interface_choice.no_storage_interfaces"]; exists {
			val := m.GetStorageInterfaceChoice().(*ReplaceSpecType_NoStorageInterfaces).NoStorageInterfaces
			vOpts := append(opts,
				db.WithValidateField("storage_interface_choice"),
				db.WithValidateField("no_storage_interfaces"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_StorageInterfaceList:
		if fv, exists := v.FldValidators["storage_interface_choice.storage_interface_list"]; exists {
			val := m.GetStorageInterfaceChoice().(*ReplaceSpecType_StorageInterfaceList).StorageInterfaceList
			vOpts := append(opts,
				db.WithValidateField("storage_interface_choice"),
				db.WithValidateField("storage_interface_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_static_routes_choice"]; exists {
		val := m.GetStorageStaticRoutesChoice()
		vOpts := append(opts,
			db.WithValidateField("storage_static_routes_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStorageStaticRoutesChoice().(type) {
	case *ReplaceSpecType_NoStorageStaticRoutes:
		if fv, exists := v.FldValidators["storage_static_routes_choice.no_storage_static_routes"]; exists {
			val := m.GetStorageStaticRoutesChoice().(*ReplaceSpecType_NoStorageStaticRoutes).NoStorageStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("storage_static_routes_choice"),
				db.WithValidateField("no_storage_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_StorageStaticRoutes:
		if fv, exists := v.FldValidators["storage_static_routes_choice.storage_static_routes"]; exists {
			val := m.GetStorageStaticRoutesChoice().(*ReplaceSpecType_StorageStaticRoutes).StorageStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("storage_static_routes_choice"),
				db.WithValidateField("storage_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["usb_policy_choice"]; exists {
		val := m.GetUsbPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("usb_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetUsbPolicyChoice().(type) {
	case *ReplaceSpecType_DenyAllUsb:
		if fv, exists := v.FldValidators["usb_policy_choice.deny_all_usb"]; exists {
			val := m.GetUsbPolicyChoice().(*ReplaceSpecType_DenyAllUsb).DenyAllUsb
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("deny_all_usb"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AllowAllUsb:
		if fv, exists := v.FldValidators["usb_policy_choice.allow_all_usb"]; exists {
			val := m.GetUsbPolicyChoice().(*ReplaceSpecType_AllowAllUsb).AllowAllUsb
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("allow_all_usb"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_UsbPolicy:
		if fv, exists := v.FldValidators["usb_policy_choice.usb_policy"]; exists {
			val := m.GetUsbPolicyChoice().(*ReplaceSpecType_UsbPolicy).UsbPolicy
			vOpts := append(opts,
				db.WithValidateField("usb_policy_choice"),
				db.WithValidateField("usb_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBondChoice := v.BondChoiceValidationRuleHandler
	rulesBondChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBondChoice(rulesBondChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.bond_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bond_choice"] = vFn

	vrhDcClusterGroupChoice := v.DcClusterGroupChoiceValidationRuleHandler
	rulesDcClusterGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDcClusterGroupChoice(rulesDcClusterGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.dc_cluster_group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dc_cluster_group_choice"] = vFn

	vrhGpuChoice := v.GpuChoiceValidationRuleHandler
	rulesGpuChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhGpuChoice(rulesGpuChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.gpu_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["gpu_choice"] = vFn

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhStorageClassChoice := v.StorageClassChoiceValidationRuleHandler
	rulesStorageClassChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageClassChoice(rulesStorageClassChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.storage_class_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_class_choice"] = vFn

	vrhStorageDeviceChoice := v.StorageDeviceChoiceValidationRuleHandler
	rulesStorageDeviceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageDeviceChoice(rulesStorageDeviceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.storage_device_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_device_choice"] = vFn

	vrhStorageInterfaceChoice := v.StorageInterfaceChoiceValidationRuleHandler
	rulesStorageInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageInterfaceChoice(rulesStorageInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.storage_interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_interface_choice"] = vFn

	vrhStorageStaticRoutesChoice := v.StorageStaticRoutesChoiceValidationRuleHandler
	rulesStorageStaticRoutesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStorageStaticRoutesChoice(rulesStorageStaticRoutesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.storage_static_routes_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_static_routes_choice"] = vFn

	vrhUsbPolicyChoice := v.UsbPolicyChoiceValidationRuleHandler
	rulesUsbPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhUsbPolicyChoice(rulesUsbPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.usb_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["usb_policy_choice"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhNetworkConnectors := v.NetworkConnectorsValidationRuleHandler
	rulesNetworkConnectors := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
	}
	vFn, err = vrhNetworkConnectors(rulesNetworkConnectors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.network_connectors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_connectors"] = vFn

	vrhNetworkFirewall := v.NetworkFirewallValidationRuleHandler
	rulesNetworkFirewall := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhNetworkFirewall(rulesNetworkFirewall)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.network_firewall: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_firewall"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhOutsideVirtualNetwork := v.OutsideVirtualNetworkValidationRuleHandler
	rulesOutsideVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhOutsideVirtualNetwork(rulesOutsideVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.outside_virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_virtual_network"] = vFn

	vrhInsideVirtualNetwork := v.InsideVirtualNetworkValidationRuleHandler
	rulesInsideVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhInsideVirtualNetwork(rulesInsideVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.inside_virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_virtual_network"] = vFn

	v.FldValidators["bond_choice.bond_device_list"] = FleetBondDevicesListTypeValidator().Validate

	v.FldValidators["dc_cluster_group_choice.dc_cluster_group"] = ves_io_schema_views.ObjectRefTypeValidator().Validate
	v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["gpu_choice.enable_vgpu"] = VGPUConfigurationValidator().Validate

	v.FldValidators["interface_choice.interface_list"] = FleetInterfaceListTypeValidator().Validate
	v.FldValidators["interface_choice.device_list"] = FleetDeviceListTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["storage_class_choice.storage_class_list"] = FleetStorageClassListTypeValidator().Validate

	v.FldValidators["storage_device_choice.storage_device_list"] = FleetStorageDeviceListTypeValidator().Validate

	v.FldValidators["storage_interface_choice.storage_interface_list"] = FleetInterfaceListTypeValidator().Validate

	v.FldValidators["storage_static_routes_choice.storage_static_routes"] = FleetStorageStaticRoutesListTypeValidator().Validate

	v.FldValidators["usb_policy_choice.usb_policy"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageClassCustomType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageClassCustomType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageClassCustomType) DeepCopy() *StorageClassCustomType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageClassCustomType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageClassCustomType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageClassCustomType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageClassCustomTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageClassCustomType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageClassCustomType) YamlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for yaml")
	}

	return validatorFn, nil
}

func (v *ValidateStorageClassCustomType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageClassCustomType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageClassCustomType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["yaml"]; exists {

		vOpts := append(opts, db.WithValidateField("yaml"))
		if err := fv(ctx, m.GetYaml(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageClassCustomTypeValidator = func() *ValidateStorageClassCustomType {
	v := &ValidateStorageClassCustomType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhYaml := v.YamlValidationRuleHandler
	rulesYaml := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhYaml(rulesYaml)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassCustomType.yaml: %s", err)
		panic(errMsg)
	}
	v.FldValidators["yaml"] = vFn

	return v
}()

func StorageClassCustomTypeValidator() db.Validator {
	return DefaultStorageClassCustomTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageClassDellIsilonF800Type) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageClassDellIsilonF800Type) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageClassDellIsilonF800Type) DeepCopy() *StorageClassDellIsilonF800Type {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageClassDellIsilonF800Type{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageClassDellIsilonF800Type) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageClassDellIsilonF800Type) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageClassDellIsilonF800TypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageClassDellIsilonF800Type struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageClassDellIsilonF800Type) HttpsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for https_choice")
	}
	return validatorFn, nil
}

func (v *ValidateStorageClassDellIsilonF800Type) HttpsChoiceAzServiceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AzServiceName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for az_service_name")
	}
	return oValidatorFn_AzServiceName, nil
}
func (v *ValidateStorageClassDellIsilonF800Type) HttpsChoiceAzServiceIpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AzServiceIpAddress, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for az_service_ip_address")
	}
	return oValidatorFn_AzServiceIpAddress, nil
}

func (v *ValidateStorageClassDellIsilonF800Type) IscsiAccessZoneValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for iscsi_access_zone")
	}

	return validatorFn, nil
}

func (v *ValidateStorageClassDellIsilonF800Type) BasePathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for base_path")
	}

	return validatorFn, nil
}

func (v *ValidateStorageClassDellIsilonF800Type) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageClassDellIsilonF800Type)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageClassDellIsilonF800Type got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["base_path"]; exists {

		vOpts := append(opts, db.WithValidateField("base_path"))
		if err := fv(ctx, m.GetBasePath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["https_choice"]; exists {
		val := m.GetHttpsChoice()
		vOpts := append(opts,
			db.WithValidateField("https_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpsChoice().(type) {
	case *StorageClassDellIsilonF800Type_AzServiceName:
		if fv, exists := v.FldValidators["https_choice.az_service_name"]; exists {
			val := m.GetHttpsChoice().(*StorageClassDellIsilonF800Type_AzServiceName).AzServiceName
			vOpts := append(opts,
				db.WithValidateField("https_choice"),
				db.WithValidateField("az_service_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageClassDellIsilonF800Type_AzServiceIpAddress:
		if fv, exists := v.FldValidators["https_choice.az_service_ip_address"]; exists {
			val := m.GetHttpsChoice().(*StorageClassDellIsilonF800Type_AzServiceIpAddress).AzServiceIpAddress
			vOpts := append(opts,
				db.WithValidateField("https_choice"),
				db.WithValidateField("az_service_ip_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["iscsi_access_zone"]; exists {

		vOpts := append(opts, db.WithValidateField("iscsi_access_zone"))
		if err := fv(ctx, m.GetIscsiAccessZone(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["root_client_enable"]; exists {

		vOpts := append(opts, db.WithValidateField("root_client_enable"))
		if err := fv(ctx, m.GetRootClientEnable(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageClassDellIsilonF800TypeValidator = func() *ValidateStorageClassDellIsilonF800Type {
	v := &ValidateStorageClassDellIsilonF800Type{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHttpsChoice := v.HttpsChoiceValidationRuleHandler
	rulesHttpsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpsChoice(rulesHttpsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassDellIsilonF800Type.https_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["https_choice"] = vFn

	vrhHttpsChoiceAzServiceName := v.HttpsChoiceAzServiceNameValidationRuleHandler
	rulesHttpsChoiceAzServiceName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFnMap["https_choice.az_service_name"], err = vrhHttpsChoiceAzServiceName(rulesHttpsChoiceAzServiceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageClassDellIsilonF800Type.https_choice_az_service_name: %s", err)
		panic(errMsg)
	}
	vrhHttpsChoiceAzServiceIpAddress := v.HttpsChoiceAzServiceIpAddressValidationRuleHandler
	rulesHttpsChoiceAzServiceIpAddress := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["https_choice.az_service_ip_address"], err = vrhHttpsChoiceAzServiceIpAddress(rulesHttpsChoiceAzServiceIpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageClassDellIsilonF800Type.https_choice_az_service_ip_address: %s", err)
		panic(errMsg)
	}

	v.FldValidators["https_choice.az_service_name"] = vFnMap["https_choice.az_service_name"]
	v.FldValidators["https_choice.az_service_ip_address"] = vFnMap["https_choice.az_service_ip_address"]

	vrhIscsiAccessZone := v.IscsiAccessZoneValidationRuleHandler
	rulesIscsiAccessZone := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhIscsiAccessZone(rulesIscsiAccessZone)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassDellIsilonF800Type.iscsi_access_zone: %s", err)
		panic(errMsg)
	}
	v.FldValidators["iscsi_access_zone"] = vFn

	vrhBasePath := v.BasePathValidationRuleHandler
	rulesBasePath := map[string]string{
		"ves.io.schema.rules.string.max_len":        "256",
		"ves.io.schema.rules.string.unix_file_path": "true",
	}
	vFn, err = vrhBasePath(rulesBasePath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassDellIsilonF800Type.base_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["base_path"] = vFn

	return v
}()

func StorageClassDellIsilonF800TypeValidator() db.Validator {
	return DefaultStorageClassDellIsilonF800TypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageClassHPENimbusStorageAf40Type) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageClassHPENimbusStorageAf40Type) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageClassHPENimbusStorageAf40Type) DeepCopy() *StorageClassHPENimbusStorageAf40Type {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageClassHPENimbusStorageAf40Type{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageClassHPENimbusStorageAf40Type) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageClassHPENimbusStorageAf40Type) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageClassHPENimbusStorageAf40TypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageClassHPENimbusStorageAf40Type struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageClassHPENimbusStorageAf40Type) PerfPolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for perf_policy")
	}

	return validatorFn, nil
}

func (v *ValidateStorageClassHPENimbusStorageAf40Type) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageClassHPENimbusStorageAf40Type)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageClassHPENimbusStorageAf40Type got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["limit_iops"]; exists {

		vOpts := append(opts, db.WithValidateField("limit_iops"))
		if err := fv(ctx, m.GetLimitIops(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit_mbps"]; exists {

		vOpts := append(opts, db.WithValidateField("limit_mbps"))
		if err := fv(ctx, m.GetLimitMbps(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["perf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("perf_policy"))
		if err := fv(ctx, m.GetPerfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageClassHPENimbusStorageAf40TypeValidator = func() *ValidateStorageClassHPENimbusStorageAf40Type {
	v := &ValidateStorageClassHPENimbusStorageAf40Type{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPerfPolicy := v.PerfPolicyValidationRuleHandler
	rulesPerfPolicy := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhPerfPolicy(rulesPerfPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassHPENimbusStorageAf40Type.perf_policy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["perf_policy"] = vFn

	return v
}()

func StorageClassHPENimbusStorageAf40TypeValidator() db.Validator {
	return DefaultStorageClassHPENimbusStorageAf40TypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageClassNetappTridentType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageClassNetappTridentType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageClassNetappTridentType) DeepCopy() *StorageClassNetappTridentType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageClassNetappTridentType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageClassNetappTridentType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageClassNetappTridentType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageClassNetappTridentTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageClassNetappTridentType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageClassNetappTridentType) StoragePoolsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_pools")
	}

	return validatorFn, nil
}

func (v *ValidateStorageClassNetappTridentType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageClassNetappTridentType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageClassNetappTridentType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["selector"]; exists {

		vOpts := append(opts, db.WithValidateField("selector"))
		for key, value := range m.GetSelector() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_pools"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_pools"))
		if err := fv(ctx, m.GetStoragePools(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageClassNetappTridentTypeValidator = func() *ValidateStorageClassNetappTridentType {
	v := &ValidateStorageClassNetappTridentType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStoragePools := v.StoragePoolsValidationRuleHandler
	rulesStoragePools := map[string]string{
		"ves.io.schema.rules.string.max_len": "512",
	}
	vFn, err = vrhStoragePools(rulesStoragePools)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassNetappTridentType.storage_pools: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_pools"] = vFn

	return v
}()

func StorageClassNetappTridentTypeValidator() db.Validator {
	return DefaultStorageClassNetappTridentTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageClassOpenebsEnterpriseType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageClassOpenebsEnterpriseType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageClassOpenebsEnterpriseType) DeepCopy() *StorageClassOpenebsEnterpriseType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageClassOpenebsEnterpriseType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageClassOpenebsEnterpriseType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageClassOpenebsEnterpriseType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageClassOpenebsEnterpriseTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageClassOpenebsEnterpriseType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageClassOpenebsEnterpriseType) ProtocolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for protocol")
	}

	return validatorFn, nil
}

func (v *ValidateStorageClassOpenebsEnterpriseType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageClassOpenebsEnterpriseType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageClassOpenebsEnterpriseType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol"))
		if err := fv(ctx, m.GetProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["replication"]; exists {

		vOpts := append(opts, db.WithValidateField("replication"))
		if err := fv(ctx, m.GetReplication(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageClassOpenebsEnterpriseTypeValidator = func() *ValidateStorageClassOpenebsEnterpriseType {
	v := &ValidateStorageClassOpenebsEnterpriseType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhProtocol := v.ProtocolValidationRuleHandler
	rulesProtocol := map[string]string{
		"ves.io.schema.rules.string.in": "[\"nvmf\"]",
	}
	vFn, err = vrhProtocol(rulesProtocol)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassOpenebsEnterpriseType.protocol: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protocol"] = vFn

	return v
}()

func StorageClassOpenebsEnterpriseTypeValidator() db.Validator {
	return DefaultStorageClassOpenebsEnterpriseTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageClassPureServiceOrchestratorType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageClassPureServiceOrchestratorType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageClassPureServiceOrchestratorType) DeepCopy() *StorageClassPureServiceOrchestratorType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageClassPureServiceOrchestratorType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageClassPureServiceOrchestratorType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageClassPureServiceOrchestratorType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageClassPureServiceOrchestratorTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageClassPureServiceOrchestratorType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageClassPureServiceOrchestratorType) BackendValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for backend")
	}

	return validatorFn, nil
}

func (v *ValidateStorageClassPureServiceOrchestratorType) IopsLimitValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for iops_limit")
	}

	return validatorFn, nil
}

func (v *ValidateStorageClassPureServiceOrchestratorType) BandwidthLimitValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bandwidth_limit")
	}

	return validatorFn, nil
}

func (v *ValidateStorageClassPureServiceOrchestratorType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageClassPureServiceOrchestratorType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageClassPureServiceOrchestratorType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["backend"]; exists {

		vOpts := append(opts, db.WithValidateField("backend"))
		if err := fv(ctx, m.GetBackend(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bandwidth_limit"]; exists {

		vOpts := append(opts, db.WithValidateField("bandwidth_limit"))
		if err := fv(ctx, m.GetBandwidthLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["iops_limit"]; exists {

		vOpts := append(opts, db.WithValidateField("iops_limit"))
		if err := fv(ctx, m.GetIopsLimit(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageClassPureServiceOrchestratorTypeValidator = func() *ValidateStorageClassPureServiceOrchestratorType {
	v := &ValidateStorageClassPureServiceOrchestratorType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBackend := v.BackendValidationRuleHandler
	rulesBackend := map[string]string{
		"ves.io.schema.rules.string.in": "[\"block\",\"file\"]",
	}
	vFn, err = vrhBackend(rulesBackend)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassPureServiceOrchestratorType.backend: %s", err)
		panic(errMsg)
	}
	v.FldValidators["backend"] = vFn

	vrhIopsLimit := v.IopsLimitValidationRuleHandler
	rulesIopsLimit := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,100-100000000",
	}
	vFn, err = vrhIopsLimit(rulesIopsLimit)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassPureServiceOrchestratorType.iops_limit: %s", err)
		panic(errMsg)
	}
	v.FldValidators["iops_limit"] = vFn

	vrhBandwidthLimit := v.BandwidthLimitValidationRuleHandler
	rulesBandwidthLimit := map[string]string{
		"ves.io.schema.rules.string.max_len": "12",
	}
	vFn, err = vrhBandwidthLimit(rulesBandwidthLimit)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageClassPureServiceOrchestratorType.bandwidth_limit: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bandwidth_limit"] = vFn

	return v
}()

func StorageClassPureServiceOrchestratorTypeValidator() db.Validator {
	return DefaultStorageClassPureServiceOrchestratorTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDeviceDellIsilonF800Type) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDeviceDellIsilonF800Type) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *StorageDeviceDellIsilonF800Type) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDeviceDellIsilonF800Type.password")
	}

	return nil
}

func (m *StorageDeviceDellIsilonF800Type) DeepCopy() *StorageDeviceDellIsilonF800Type {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDeviceDellIsilonF800Type{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDeviceDellIsilonF800Type) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDeviceDellIsilonF800Type) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDeviceDellIsilonF800TypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDeviceDellIsilonF800Type struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDeviceDellIsilonF800Type) AddressChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address_choice")
	}
	return validatorFn, nil
}

func (v *ValidateStorageDeviceDellIsilonF800Type) AddressChoiceApiServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ApiServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_server_name")
	}
	return oValidatorFn_ApiServerName, nil
}
func (v *ValidateStorageDeviceDellIsilonF800Type) AddressChoiceApiServerIpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ApiServerIpAddress, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_server_ip_address")
	}
	return oValidatorFn_ApiServerIpAddress, nil
}

func (v *ValidateStorageDeviceDellIsilonF800Type) HttpsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for https_choice")
	}
	return validatorFn, nil
}

func (v *ValidateStorageDeviceDellIsilonF800Type) HttpsChoiceTrustedCaUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_TrustedCaUrl, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_url")
	}
	return oValidatorFn_TrustedCaUrl, nil
}

func (v *ValidateStorageDeviceDellIsilonF800Type) UsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for username")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceDellIsilonF800Type) ApiServerPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_server_port")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceDellIsilonF800Type) IscsiAccessZoneValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for iscsi_access_zone")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceDellIsilonF800Type) VolumePrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volume_prefix")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceDellIsilonF800Type) BasePathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for base_path")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceDellIsilonF800Type) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDeviceDellIsilonF800Type)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDeviceDellIsilonF800Type got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address_choice"]; exists {
		val := m.GetAddressChoice()
		vOpts := append(opts,
			db.WithValidateField("address_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAddressChoice().(type) {
	case *StorageDeviceDellIsilonF800Type_ApiServerName:
		if fv, exists := v.FldValidators["address_choice.api_server_name"]; exists {
			val := m.GetAddressChoice().(*StorageDeviceDellIsilonF800Type_ApiServerName).ApiServerName
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("api_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageDeviceDellIsilonF800Type_ApiServerIpAddress:
		if fv, exists := v.FldValidators["address_choice.api_server_ip_address"]; exists {
			val := m.GetAddressChoice().(*StorageDeviceDellIsilonF800Type_ApiServerIpAddress).ApiServerIpAddress
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("api_server_ip_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["api_server_port"]; exists {

		vOpts := append(opts, db.WithValidateField("api_server_port"))
		if err := fv(ctx, m.GetApiServerPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["base_path"]; exists {

		vOpts := append(opts, db.WithValidateField("base_path"))
		if err := fv(ctx, m.GetBasePath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["https_choice"]; exists {
		val := m.GetHttpsChoice()
		vOpts := append(opts,
			db.WithValidateField("https_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpsChoice().(type) {
	case *StorageDeviceDellIsilonF800Type_SecureNetwork:
		if fv, exists := v.FldValidators["https_choice.secure_network"]; exists {
			val := m.GetHttpsChoice().(*StorageDeviceDellIsilonF800Type_SecureNetwork).SecureNetwork
			vOpts := append(opts,
				db.WithValidateField("https_choice"),
				db.WithValidateField("secure_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageDeviceDellIsilonF800Type_TrustedCaUrl:
		if fv, exists := v.FldValidators["https_choice.trusted_ca_url"]; exists {
			val := m.GetHttpsChoice().(*StorageDeviceDellIsilonF800Type_TrustedCaUrl).TrustedCaUrl
			vOpts := append(opts,
				db.WithValidateField("https_choice"),
				db.WithValidateField("trusted_ca_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["iscsi_access_zone"]; exists {

		vOpts := append(opts, db.WithValidateField("iscsi_access_zone"))
		if err := fv(ctx, m.GetIscsiAccessZone(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volume_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("volume_prefix"))
		if err := fv(ctx, m.GetVolumePrefix(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDeviceDellIsilonF800TypeValidator = func() *ValidateStorageDeviceDellIsilonF800Type {
	v := &ValidateStorageDeviceDellIsilonF800Type{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddressChoice := v.AddressChoiceValidationRuleHandler
	rulesAddressChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAddressChoice(rulesAddressChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceDellIsilonF800Type.address_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_choice"] = vFn

	vrhAddressChoiceApiServerName := v.AddressChoiceApiServerNameValidationRuleHandler
	rulesAddressChoiceApiServerName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFnMap["address_choice.api_server_name"], err = vrhAddressChoiceApiServerName(rulesAddressChoiceApiServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceDellIsilonF800Type.address_choice_api_server_name: %s", err)
		panic(errMsg)
	}
	vrhAddressChoiceApiServerIpAddress := v.AddressChoiceApiServerIpAddressValidationRuleHandler
	rulesAddressChoiceApiServerIpAddress := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["address_choice.api_server_ip_address"], err = vrhAddressChoiceApiServerIpAddress(rulesAddressChoiceApiServerIpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceDellIsilonF800Type.address_choice_api_server_ip_address: %s", err)
		panic(errMsg)
	}

	v.FldValidators["address_choice.api_server_name"] = vFnMap["address_choice.api_server_name"]
	v.FldValidators["address_choice.api_server_ip_address"] = vFnMap["address_choice.api_server_ip_address"]

	vrhHttpsChoice := v.HttpsChoiceValidationRuleHandler
	rulesHttpsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpsChoice(rulesHttpsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceDellIsilonF800Type.https_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["https_choice"] = vFn

	vrhHttpsChoiceTrustedCaUrl := v.HttpsChoiceTrustedCaUrlValidationRuleHandler
	rulesHttpsChoiceTrustedCaUrl := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "131072",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFnMap["https_choice.trusted_ca_url"], err = vrhHttpsChoiceTrustedCaUrl(rulesHttpsChoiceTrustedCaUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceDellIsilonF800Type.https_choice_trusted_ca_url: %s", err)
		panic(errMsg)
	}

	v.FldValidators["https_choice.trusted_ca_url"] = vFnMap["https_choice.trusted_ca_url"]

	vrhUsername := v.UsernameValidationRuleHandler
	rulesUsername := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "128",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhUsername(rulesUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceDellIsilonF800Type.username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["username"] = vFn

	vrhApiServerPort := v.ApiServerPortValidationRuleHandler
	rulesApiServerPort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhApiServerPort(rulesApiServerPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceDellIsilonF800Type.api_server_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_server_port"] = vFn

	vrhIscsiAccessZone := v.IscsiAccessZoneValidationRuleHandler
	rulesIscsiAccessZone := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhIscsiAccessZone(rulesIscsiAccessZone)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceDellIsilonF800Type.iscsi_access_zone: %s", err)
		panic(errMsg)
	}
	v.FldValidators["iscsi_access_zone"] = vFn

	vrhVolumePrefix := v.VolumePrefixValidationRuleHandler
	rulesVolumePrefix := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhVolumePrefix(rulesVolumePrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceDellIsilonF800Type.volume_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volume_prefix"] = vFn

	vrhBasePath := v.BasePathValidationRuleHandler
	rulesBasePath := map[string]string{
		"ves.io.schema.rules.string.max_len":        "256",
		"ves.io.schema.rules.string.unix_file_path": "true",
	}
	vFn, err = vrhBasePath(rulesBasePath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceDellIsilonF800Type.base_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["base_path"] = vFn

	v.FldValidators["password"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func StorageDeviceDellIsilonF800TypeValidator() db.Validator {
	return DefaultStorageDeviceDellIsilonF800TypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDeviceHPENimbusStorageAf40Type) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDeviceHPENimbusStorageAf40Type) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *StorageDeviceHPENimbusStorageAf40Type) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDeviceHPENimbusStorageAf40Type.password")
	}

	return nil
}

func (m *StorageDeviceHPENimbusStorageAf40Type) DeepCopy() *StorageDeviceHPENimbusStorageAf40Type {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDeviceHPENimbusStorageAf40Type{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDeviceHPENimbusStorageAf40Type) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDeviceHPENimbusStorageAf40Type) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDeviceHPENimbusStorageAf40TypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDeviceHPENimbusStorageAf40Type struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDeviceHPENimbusStorageAf40Type) StorageServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_server_name")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceHPENimbusStorageAf40Type) StorageServerIpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_server_ip_address")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceHPENimbusStorageAf40Type) ApiServerPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_server_port")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceHPENimbusStorageAf40Type) UsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for username")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceHPENimbusStorageAf40Type) PerfPolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for perf_policy")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceHPENimbusStorageAf40Type) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDeviceHPENimbusStorageAf40Type)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDeviceHPENimbusStorageAf40Type got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_server_port"]; exists {

		vOpts := append(opts, db.WithValidateField("api_server_port"))
		if err := fv(ctx, m.GetApiServerPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit_iops"]; exists {

		vOpts := append(opts, db.WithValidateField("limit_iops"))
		if err := fv(ctx, m.GetLimitIops(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit_mbps"]; exists {

		vOpts := append(opts, db.WithValidateField("limit_mbps"))
		if err := fv(ctx, m.GetLimitMbps(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["perf_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("perf_policy"))
		if err := fv(ctx, m.GetPerfPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_server_ip_address"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_server_ip_address"))
		if err := fv(ctx, m.GetStorageServerIpAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_server_name"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_server_name"))
		if err := fv(ctx, m.GetStorageServerName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDeviceHPENimbusStorageAf40TypeValidator = func() *ValidateStorageDeviceHPENimbusStorageAf40Type {
	v := &ValidateStorageDeviceHPENimbusStorageAf40Type{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStorageServerName := v.StorageServerNameValidationRuleHandler
	rulesStorageServerName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFn, err = vrhStorageServerName(rulesStorageServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceHPENimbusStorageAf40Type.storage_server_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_server_name"] = vFn

	vrhStorageServerIpAddress := v.StorageServerIpAddressValidationRuleHandler
	rulesStorageServerIpAddress := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhStorageServerIpAddress(rulesStorageServerIpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceHPENimbusStorageAf40Type.storage_server_ip_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_server_ip_address"] = vFn

	vrhApiServerPort := v.ApiServerPortValidationRuleHandler
	rulesApiServerPort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhApiServerPort(rulesApiServerPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceHPENimbusStorageAf40Type.api_server_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_server_port"] = vFn

	vrhUsername := v.UsernameValidationRuleHandler
	rulesUsername := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "128",
		"ves.io.schema.rules.string.uri_ref":   "true",
	}
	vFn, err = vrhUsername(rulesUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceHPENimbusStorageAf40Type.username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["username"] = vFn

	vrhPerfPolicy := v.PerfPolicyValidationRuleHandler
	rulesPerfPolicy := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhPerfPolicy(rulesPerfPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceHPENimbusStorageAf40Type.perf_policy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["perf_policy"] = vFn

	v.FldValidators["password"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func StorageDeviceHPENimbusStorageAf40TypeValidator() db.Validator {
	return DefaultStorageDeviceHPENimbusStorageAf40TypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDeviceNetappBackendOntapNasType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDeviceNetappBackendOntapNasType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *StorageDeviceNetappBackendOntapNasType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDeviceNetappBackendOntapNasType.password")
	}

	if err := m.GetClientPrivateKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDeviceNetappBackendOntapNasType.client_private_key")
	}

	return nil
}

func (m *StorageDeviceNetappBackendOntapNasType) DeepCopy() *StorageDeviceNetappBackendOntapNasType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDeviceNetappBackendOntapNasType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDeviceNetappBackendOntapNasType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDeviceNetappBackendOntapNasType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDeviceNetappBackendOntapNasTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDeviceNetappBackendOntapNasType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) DataLifDataLifIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DataLifIp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for data_lif_ip")
	}
	return oValidatorFn_DataLifIp, nil
}
func (v *ValidateStorageDeviceNetappBackendOntapNasType) DataLifDataLifDnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DataLifDnsName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for data_lif_dns_name")
	}
	return oValidatorFn_DataLifDnsName, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) ManagementLifValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for management_lif")
	}
	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) ManagementLifManagementLifIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ManagementLifIp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for management_lif_ip")
	}
	return oValidatorFn_ManagementLifIp, nil
}
func (v *ValidateStorageDeviceNetappBackendOntapNasType) ManagementLifManagementLifDnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ManagementLifDnsName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for management_lif_dns_name")
	}
	return oValidatorFn_ManagementLifDnsName, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) StorageDriverNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_driver_name")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) BackendNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for backend_name")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) SvmValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for svm")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) UsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for username")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) LabelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for labels")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for labels")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for labels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map labels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items labels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) StorageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*OntapVirtualStoragePoolType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := OntapVirtualStoragePoolTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for storage")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OntapVirtualStoragePoolType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OntapVirtualStoragePoolType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated storage")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items storage")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) ClientCertificateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_certificate")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) TrustedCaCertificateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_certificate")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapNasType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDeviceNetappBackendOntapNasType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDeviceNetappBackendOntapNasType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auto_export_cidrs"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_export_cidrs"))
		if err := fv(ctx, m.GetAutoExportCidrs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_export_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_export_policy"))
		if err := fv(ctx, m.GetAutoExportPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["backend_name"]; exists {

		vOpts := append(opts, db.WithValidateField("backend_name"))
		if err := fv(ctx, m.GetBackendName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_certificate"]; exists {

		vOpts := append(opts, db.WithValidateField("client_certificate"))
		if err := fv(ctx, m.GetClientCertificate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_private_key"]; exists {

		vOpts := append(opts, db.WithValidateField("client_private_key"))
		if err := fv(ctx, m.GetClientPrivateKey(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDataLif().(type) {
	case *StorageDeviceNetappBackendOntapNasType_DataLifIp:
		if fv, exists := v.FldValidators["data_lif.data_lif_ip"]; exists {
			val := m.GetDataLif().(*StorageDeviceNetappBackendOntapNasType_DataLifIp).DataLifIp
			vOpts := append(opts,
				db.WithValidateField("data_lif"),
				db.WithValidateField("data_lif_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageDeviceNetappBackendOntapNasType_DataLifDnsName:
		if fv, exists := v.FldValidators["data_lif.data_lif_dns_name"]; exists {
			val := m.GetDataLif().(*StorageDeviceNetappBackendOntapNasType_DataLifDnsName).DataLifDnsName
			vOpts := append(opts,
				db.WithValidateField("data_lif"),
				db.WithValidateField("data_lif_dns_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {
		vOpts := append(opts, db.WithValidateField("labels"))
		if err := fv(ctx, m.GetLabels(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit_aggregate_usage"]; exists {

		vOpts := append(opts, db.WithValidateField("limit_aggregate_usage"))
		if err := fv(ctx, m.GetLimitAggregateUsage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit_volume_size"]; exists {

		vOpts := append(opts, db.WithValidateField("limit_volume_size"))
		if err := fv(ctx, m.GetLimitVolumeSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["management_lif"]; exists {
		val := m.GetManagementLif()
		vOpts := append(opts,
			db.WithValidateField("management_lif"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetManagementLif().(type) {
	case *StorageDeviceNetappBackendOntapNasType_ManagementLifIp:
		if fv, exists := v.FldValidators["management_lif.management_lif_ip"]; exists {
			val := m.GetManagementLif().(*StorageDeviceNetappBackendOntapNasType_ManagementLifIp).ManagementLifIp
			vOpts := append(opts,
				db.WithValidateField("management_lif"),
				db.WithValidateField("management_lif_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName:
		if fv, exists := v.FldValidators["management_lif.management_lif_dns_name"]; exists {
			val := m.GetManagementLif().(*StorageDeviceNetappBackendOntapNasType_ManagementLifDnsName).ManagementLifDnsName
			vOpts := append(opts,
				db.WithValidateField("management_lif"),
				db.WithValidateField("management_lif_dns_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["nfs_mount_options"]; exists {

		vOpts := append(opts, db.WithValidateField("nfs_mount_options"))
		if err := fv(ctx, m.GetNfsMountOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage"]; exists {
		vOpts := append(opts, db.WithValidateField("storage"))
		if err := fv(ctx, m.GetStorage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_driver_name"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_driver_name"))
		if err := fv(ctx, m.GetStorageDriverName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_prefix"))
		if err := fv(ctx, m.GetStoragePrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["svm"]; exists {

		vOpts := append(opts, db.WithValidateField("svm"))
		if err := fv(ctx, m.GetSvm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trusted_ca_certificate"]; exists {

		vOpts := append(opts, db.WithValidateField("trusted_ca_certificate"))
		if err := fv(ctx, m.GetTrustedCaCertificate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volume_defaults"]; exists {

		vOpts := append(opts, db.WithValidateField("volume_defaults"))
		if err := fv(ctx, m.GetVolumeDefaults(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDeviceNetappBackendOntapNasTypeValidator = func() *ValidateStorageDeviceNetappBackendOntapNasType {
	v := &ValidateStorageDeviceNetappBackendOntapNasType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDataLifDataLifIp := v.DataLifDataLifIpValidationRuleHandler
	rulesDataLifDataLifIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["data_lif.data_lif_ip"], err = vrhDataLifDataLifIp(rulesDataLifDataLifIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceNetappBackendOntapNasType.data_lif_data_lif_ip: %s", err)
		panic(errMsg)
	}
	vrhDataLifDataLifDnsName := v.DataLifDataLifDnsNameValidationRuleHandler
	rulesDataLifDataLifDnsName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFnMap["data_lif.data_lif_dns_name"], err = vrhDataLifDataLifDnsName(rulesDataLifDataLifDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceNetappBackendOntapNasType.data_lif_data_lif_dns_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["data_lif.data_lif_ip"] = vFnMap["data_lif.data_lif_ip"]
	v.FldValidators["data_lif.data_lif_dns_name"] = vFnMap["data_lif.data_lif_dns_name"]

	vrhManagementLif := v.ManagementLifValidationRuleHandler
	rulesManagementLif := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhManagementLif(rulesManagementLif)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapNasType.management_lif: %s", err)
		panic(errMsg)
	}
	v.FldValidators["management_lif"] = vFn

	vrhManagementLifManagementLifIp := v.ManagementLifManagementLifIpValidationRuleHandler
	rulesManagementLifManagementLifIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["management_lif.management_lif_ip"], err = vrhManagementLifManagementLifIp(rulesManagementLifManagementLifIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceNetappBackendOntapNasType.management_lif_management_lif_ip: %s", err)
		panic(errMsg)
	}
	vrhManagementLifManagementLifDnsName := v.ManagementLifManagementLifDnsNameValidationRuleHandler
	rulesManagementLifManagementLifDnsName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFnMap["management_lif.management_lif_dns_name"], err = vrhManagementLifManagementLifDnsName(rulesManagementLifManagementLifDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceNetappBackendOntapNasType.management_lif_management_lif_dns_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["management_lif.management_lif_ip"] = vFnMap["management_lif.management_lif_ip"]
	v.FldValidators["management_lif.management_lif_dns_name"] = vFnMap["management_lif.management_lif_dns_name"]

	vrhStorageDriverName := v.StorageDriverNameValidationRuleHandler
	rulesStorageDriverName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"ontap-nas\",\"ontap-nas-economy\",\"ontap-nas-flexgroup\"]",
	}
	vFn, err = vrhStorageDriverName(rulesStorageDriverName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapNasType.storage_driver_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_driver_name"] = vFn

	vrhBackendName := v.BackendNameValidationRuleHandler
	rulesBackendName := map[string]string{
		"ves.io.schema.rules.string.max_len": "50",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhBackendName(rulesBackendName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapNasType.backend_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["backend_name"] = vFn

	vrhSvm := v.SvmValidationRuleHandler
	rulesSvm := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhSvm(rulesSvm)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapNasType.svm: %s", err)
		panic(errMsg)
	}
	v.FldValidators["svm"] = vFn

	vrhUsername := v.UsernameValidationRuleHandler
	rulesUsername := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhUsername(rulesUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapNasType.username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["username"] = vFn

	vrhLabels := v.LabelsValidationRuleHandler
	rulesLabels := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "128",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "20",
		"ves.io.schema.rules.map.values.string.max_len": "128",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhLabels(rulesLabels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapNasType.labels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["labels"] = vFn

	vrhStorage := v.StorageValidationRuleHandler
	rulesStorage := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStorage(rulesStorage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapNasType.storage: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage"] = vFn

	vrhClientCertificate := v.ClientCertificateValidationRuleHandler
	rulesClientCertificate := map[string]string{
		"ves.io.schema.rules.string.max_len": "8192",
	}
	vFn, err = vrhClientCertificate(rulesClientCertificate)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapNasType.client_certificate: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_certificate"] = vFn

	vrhTrustedCaCertificate := v.TrustedCaCertificateValidationRuleHandler
	rulesTrustedCaCertificate := map[string]string{
		"ves.io.schema.rules.string.max_len": "8192",
	}
	vFn, err = vrhTrustedCaCertificate(rulesTrustedCaCertificate)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapNasType.trusted_ca_certificate: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_certificate"] = vFn

	v.FldValidators["password"] = ves_io_schema.SecretTypeValidator().Validate

	v.FldValidators["auto_export_cidrs"] = ves_io_schema_views.PrefixStringListTypeValidator().Validate

	v.FldValidators["volume_defaults"] = OntapVolumeDefaultsValidator().Validate

	v.FldValidators["client_private_key"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func StorageDeviceNetappBackendOntapNasTypeValidator() db.Validator {
	return DefaultStorageDeviceNetappBackendOntapNasTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDeviceNetappBackendOntapSanType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDeviceNetappBackendOntapSanType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *StorageDeviceNetappBackendOntapSanType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDeviceNetappBackendOntapSanType.password")
	}

	if err := m.GetUseChap().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDeviceNetappBackendOntapSanType.use_chap")
	}

	if err := m.GetClientPrivateKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDeviceNetappBackendOntapSanType.client_private_key")
	}

	return nil
}

func (m *StorageDeviceNetappBackendOntapSanType) DeepCopy() *StorageDeviceNetappBackendOntapSanType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDeviceNetappBackendOntapSanType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDeviceNetappBackendOntapSanType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDeviceNetappBackendOntapSanType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDeviceNetappBackendOntapSanTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDeviceNetappBackendOntapSanType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) DataLifDataLifIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DataLifIp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for data_lif_ip")
	}
	return oValidatorFn_DataLifIp, nil
}
func (v *ValidateStorageDeviceNetappBackendOntapSanType) DataLifDataLifDnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DataLifDnsName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for data_lif_dns_name")
	}
	return oValidatorFn_DataLifDnsName, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) ManagementLifValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for management_lif")
	}
	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) ManagementLifManagementLifIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ManagementLifIp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for management_lif_ip")
	}
	return oValidatorFn_ManagementLifIp, nil
}
func (v *ValidateStorageDeviceNetappBackendOntapSanType) ManagementLifManagementLifDnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ManagementLifDnsName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for management_lif_dns_name")
	}
	return oValidatorFn_ManagementLifDnsName, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) StorageDriverNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_driver_name")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) SvmValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for svm")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) UsernameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for username")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) IgroupNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for igroup_name")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) StoragePrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_prefix")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) LimitAggregateUsageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for limit_aggregate_usage")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) LabelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for labels")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for labels")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for labels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map labels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items labels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) StorageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*OntapVirtualStoragePoolType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := OntapVirtualStoragePoolTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for storage")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OntapVirtualStoragePoolType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OntapVirtualStoragePoolType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated storage")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items storage")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) ClientCertificateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_certificate")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) TrustedCaCertificateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_certificate")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappBackendOntapSanType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDeviceNetappBackendOntapSanType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDeviceNetappBackendOntapSanType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetChapChoice().(type) {
	case *StorageDeviceNetappBackendOntapSanType_NoChap:
		if fv, exists := v.FldValidators["chap_choice.no_chap"]; exists {
			val := m.GetChapChoice().(*StorageDeviceNetappBackendOntapSanType_NoChap).NoChap
			vOpts := append(opts,
				db.WithValidateField("chap_choice"),
				db.WithValidateField("no_chap"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageDeviceNetappBackendOntapSanType_UseChap:
		if fv, exists := v.FldValidators["chap_choice.use_chap"]; exists {
			val := m.GetChapChoice().(*StorageDeviceNetappBackendOntapSanType_UseChap).UseChap
			vOpts := append(opts,
				db.WithValidateField("chap_choice"),
				db.WithValidateField("use_chap"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["client_certificate"]; exists {

		vOpts := append(opts, db.WithValidateField("client_certificate"))
		if err := fv(ctx, m.GetClientCertificate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_private_key"]; exists {

		vOpts := append(opts, db.WithValidateField("client_private_key"))
		if err := fv(ctx, m.GetClientPrivateKey(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetDataLif().(type) {
	case *StorageDeviceNetappBackendOntapSanType_DataLifIp:
		if fv, exists := v.FldValidators["data_lif.data_lif_ip"]; exists {
			val := m.GetDataLif().(*StorageDeviceNetappBackendOntapSanType_DataLifIp).DataLifIp
			vOpts := append(opts,
				db.WithValidateField("data_lif"),
				db.WithValidateField("data_lif_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageDeviceNetappBackendOntapSanType_DataLifDnsName:
		if fv, exists := v.FldValidators["data_lif.data_lif_dns_name"]; exists {
			val := m.GetDataLif().(*StorageDeviceNetappBackendOntapSanType_DataLifDnsName).DataLifDnsName
			vOpts := append(opts,
				db.WithValidateField("data_lif"),
				db.WithValidateField("data_lif_dns_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["igroup_name"]; exists {

		vOpts := append(opts, db.WithValidateField("igroup_name"))
		if err := fv(ctx, m.GetIgroupName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {
		vOpts := append(opts, db.WithValidateField("labels"))
		if err := fv(ctx, m.GetLabels(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit_aggregate_usage"]; exists {

		vOpts := append(opts, db.WithValidateField("limit_aggregate_usage"))
		if err := fv(ctx, m.GetLimitAggregateUsage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit_volume_size"]; exists {

		vOpts := append(opts, db.WithValidateField("limit_volume_size"))
		if err := fv(ctx, m.GetLimitVolumeSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["management_lif"]; exists {
		val := m.GetManagementLif()
		vOpts := append(opts,
			db.WithValidateField("management_lif"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetManagementLif().(type) {
	case *StorageDeviceNetappBackendOntapSanType_ManagementLifIp:
		if fv, exists := v.FldValidators["management_lif.management_lif_ip"]; exists {
			val := m.GetManagementLif().(*StorageDeviceNetappBackendOntapSanType_ManagementLifIp).ManagementLifIp
			vOpts := append(opts,
				db.WithValidateField("management_lif"),
				db.WithValidateField("management_lif_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName:
		if fv, exists := v.FldValidators["management_lif.management_lif_dns_name"]; exists {
			val := m.GetManagementLif().(*StorageDeviceNetappBackendOntapSanType_ManagementLifDnsName).ManagementLifDnsName
			vOpts := append(opts,
				db.WithValidateField("management_lif"),
				db.WithValidateField("management_lif_dns_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage"]; exists {
		vOpts := append(opts, db.WithValidateField("storage"))
		if err := fv(ctx, m.GetStorage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_driver_name"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_driver_name"))
		if err := fv(ctx, m.GetStorageDriverName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_prefix"))
		if err := fv(ctx, m.GetStoragePrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["svm"]; exists {

		vOpts := append(opts, db.WithValidateField("svm"))
		if err := fv(ctx, m.GetSvm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trusted_ca_certificate"]; exists {

		vOpts := append(opts, db.WithValidateField("trusted_ca_certificate"))
		if err := fv(ctx, m.GetTrustedCaCertificate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volume_defaults"]; exists {

		vOpts := append(opts, db.WithValidateField("volume_defaults"))
		if err := fv(ctx, m.GetVolumeDefaults(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDeviceNetappBackendOntapSanTypeValidator = func() *ValidateStorageDeviceNetappBackendOntapSanType {
	v := &ValidateStorageDeviceNetappBackendOntapSanType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDataLifDataLifIp := v.DataLifDataLifIpValidationRuleHandler
	rulesDataLifDataLifIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["data_lif.data_lif_ip"], err = vrhDataLifDataLifIp(rulesDataLifDataLifIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceNetappBackendOntapSanType.data_lif_data_lif_ip: %s", err)
		panic(errMsg)
	}
	vrhDataLifDataLifDnsName := v.DataLifDataLifDnsNameValidationRuleHandler
	rulesDataLifDataLifDnsName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFnMap["data_lif.data_lif_dns_name"], err = vrhDataLifDataLifDnsName(rulesDataLifDataLifDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceNetappBackendOntapSanType.data_lif_data_lif_dns_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["data_lif.data_lif_ip"] = vFnMap["data_lif.data_lif_ip"]
	v.FldValidators["data_lif.data_lif_dns_name"] = vFnMap["data_lif.data_lif_dns_name"]

	vrhManagementLif := v.ManagementLifValidationRuleHandler
	rulesManagementLif := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhManagementLif(rulesManagementLif)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.management_lif: %s", err)
		panic(errMsg)
	}
	v.FldValidators["management_lif"] = vFn

	vrhManagementLifManagementLifIp := v.ManagementLifManagementLifIpValidationRuleHandler
	rulesManagementLifManagementLifIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFnMap["management_lif.management_lif_ip"], err = vrhManagementLifManagementLifIp(rulesManagementLifManagementLifIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceNetappBackendOntapSanType.management_lif_management_lif_ip: %s", err)
		panic(errMsg)
	}
	vrhManagementLifManagementLifDnsName := v.ManagementLifManagementLifDnsNameValidationRuleHandler
	rulesManagementLifManagementLifDnsName := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFnMap["management_lif.management_lif_dns_name"], err = vrhManagementLifManagementLifDnsName(rulesManagementLifManagementLifDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StorageDeviceNetappBackendOntapSanType.management_lif_management_lif_dns_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["management_lif.management_lif_ip"] = vFnMap["management_lif.management_lif_ip"]
	v.FldValidators["management_lif.management_lif_dns_name"] = vFnMap["management_lif.management_lif_dns_name"]

	vrhStorageDriverName := v.StorageDriverNameValidationRuleHandler
	rulesStorageDriverName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"ontap-san\",\"ontap-san-economy\",\"ontap-nas-flexgroup\"]",
	}
	vFn, err = vrhStorageDriverName(rulesStorageDriverName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.storage_driver_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_driver_name"] = vFn

	vrhSvm := v.SvmValidationRuleHandler
	rulesSvm := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhSvm(rulesSvm)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.svm: %s", err)
		panic(errMsg)
	}
	v.FldValidators["svm"] = vFn

	vrhUsername := v.UsernameValidationRuleHandler
	rulesUsername := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhUsername(rulesUsername)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.username: %s", err)
		panic(errMsg)
	}
	v.FldValidators["username"] = vFn

	vrhIgroupName := v.IgroupNameValidationRuleHandler
	rulesIgroupName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhIgroupName(rulesIgroupName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.igroup_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["igroup_name"] = vFn

	vrhStoragePrefix := v.StoragePrefixValidationRuleHandler
	rulesStoragePrefix := map[string]string{
		"ves.io.schema.rules.string.max_len": "80",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhStoragePrefix(rulesStoragePrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.storage_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_prefix"] = vFn

	vrhLimitAggregateUsage := v.LimitAggregateUsageValidationRuleHandler
	rulesLimitAggregateUsage := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFn, err = vrhLimitAggregateUsage(rulesLimitAggregateUsage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.limit_aggregate_usage: %s", err)
		panic(errMsg)
	}
	v.FldValidators["limit_aggregate_usage"] = vFn

	vrhLabels := v.LabelsValidationRuleHandler
	rulesLabels := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "128",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "20",
		"ves.io.schema.rules.map.values.string.max_len": "128",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhLabels(rulesLabels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.labels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["labels"] = vFn

	vrhStorage := v.StorageValidationRuleHandler
	rulesStorage := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStorage(rulesStorage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.storage: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage"] = vFn

	vrhClientCertificate := v.ClientCertificateValidationRuleHandler
	rulesClientCertificate := map[string]string{
		"ves.io.schema.rules.string.max_len": "8192",
	}
	vFn, err = vrhClientCertificate(rulesClientCertificate)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.client_certificate: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_certificate"] = vFn

	vrhTrustedCaCertificate := v.TrustedCaCertificateValidationRuleHandler
	rulesTrustedCaCertificate := map[string]string{
		"ves.io.schema.rules.string.max_len": "8192",
	}
	vFn, err = vrhTrustedCaCertificate(rulesTrustedCaCertificate)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappBackendOntapSanType.trusted_ca_certificate: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_certificate"] = vFn

	v.FldValidators["chap_choice.use_chap"] = DeviceNetappBackendOntapSanChapTypeValidator().Validate

	v.FldValidators["password"] = ves_io_schema.SecretTypeValidator().Validate

	v.FldValidators["volume_defaults"] = OntapVolumeDefaultsValidator().Validate

	v.FldValidators["client_private_key"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func StorageDeviceNetappBackendOntapSanTypeValidator() db.Validator {
	return DefaultStorageDeviceNetappBackendOntapSanTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDeviceNetappTridentType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDeviceNetappTridentType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *StorageDeviceNetappTridentType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetNetappBackendOntapNas().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDeviceNetappTridentType.netapp_backend_ontap_nas")
	}

	if err := m.GetNetappBackendOntapSan().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDeviceNetappTridentType.netapp_backend_ontap_san")
	}

	return nil
}

func (m *StorageDeviceNetappTridentType) DeepCopy() *StorageDeviceNetappTridentType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDeviceNetappTridentType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDeviceNetappTridentType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDeviceNetappTridentType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDeviceNetappTridentTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDeviceNetappTridentType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDeviceNetappTridentType) BackendChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for backend_choice")
	}
	return validatorFn, nil
}

func (v *ValidateStorageDeviceNetappTridentType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDeviceNetappTridentType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDeviceNetappTridentType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["backend_choice"]; exists {
		val := m.GetBackendChoice()
		vOpts := append(opts,
			db.WithValidateField("backend_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBackendChoice().(type) {
	case *StorageDeviceNetappTridentType_NetappBackendOntapNas:
		if fv, exists := v.FldValidators["backend_choice.netapp_backend_ontap_nas"]; exists {
			val := m.GetBackendChoice().(*StorageDeviceNetappTridentType_NetappBackendOntapNas).NetappBackendOntapNas
			vOpts := append(opts,
				db.WithValidateField("backend_choice"),
				db.WithValidateField("netapp_backend_ontap_nas"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageDeviceNetappTridentType_NetappBackendOntapSan:
		if fv, exists := v.FldValidators["backend_choice.netapp_backend_ontap_san"]; exists {
			val := m.GetBackendChoice().(*StorageDeviceNetappTridentType_NetappBackendOntapSan).NetappBackendOntapSan
			vOpts := append(opts,
				db.WithValidateField("backend_choice"),
				db.WithValidateField("netapp_backend_ontap_san"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDeviceNetappTridentTypeValidator = func() *ValidateStorageDeviceNetappTridentType {
	v := &ValidateStorageDeviceNetappTridentType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBackendChoice := v.BackendChoiceValidationRuleHandler
	rulesBackendChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBackendChoice(rulesBackendChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceNetappTridentType.backend_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["backend_choice"] = vFn

	v.FldValidators["backend_choice.netapp_backend_ontap_nas"] = StorageDeviceNetappBackendOntapNasTypeValidator().Validate
	v.FldValidators["backend_choice.netapp_backend_ontap_san"] = StorageDeviceNetappBackendOntapSanTypeValidator().Validate

	return v
}()

func StorageDeviceNetappTridentTypeValidator() db.Validator {
	return DefaultStorageDeviceNetappTridentTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDeviceOpenebsEnterpriseType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDeviceOpenebsEnterpriseType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageDeviceOpenebsEnterpriseType) DeepCopy() *StorageDeviceOpenebsEnterpriseType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDeviceOpenebsEnterpriseType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDeviceOpenebsEnterpriseType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDeviceOpenebsEnterpriseType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDeviceOpenebsEnterpriseTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDeviceOpenebsEnterpriseType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDeviceOpenebsEnterpriseType) MayastorPoolsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*OpenebsMayastorPoolType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := OpenebsMayastorPoolTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for mayastor_pools")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OpenebsMayastorPoolType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OpenebsMayastorPoolType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated mayastor_pools")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items mayastor_pools")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStorageDeviceOpenebsEnterpriseType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDeviceOpenebsEnterpriseType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDeviceOpenebsEnterpriseType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mayastor_pools"]; exists {
		vOpts := append(opts, db.WithValidateField("mayastor_pools"))
		if err := fv(ctx, m.GetMayastorPools(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDeviceOpenebsEnterpriseTypeValidator = func() *ValidateStorageDeviceOpenebsEnterpriseType {
	v := &ValidateStorageDeviceOpenebsEnterpriseType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMayastorPools := v.MayastorPoolsValidationRuleHandler
	rulesMayastorPools := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "50",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhMayastorPools(rulesMayastorPools)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDeviceOpenebsEnterpriseType.mayastor_pools: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mayastor_pools"] = vFn

	return v
}()

func StorageDeviceOpenebsEnterpriseTypeValidator() db.Validator {
	return DefaultStorageDeviceOpenebsEnterpriseTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDevicePureStorageServiceOrchestratorType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDevicePureStorageServiceOrchestratorType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *StorageDevicePureStorageServiceOrchestratorType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetArrays().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StorageDevicePureStorageServiceOrchestratorType.arrays")
	}

	return nil
}

func (m *StorageDevicePureStorageServiceOrchestratorType) DeepCopy() *StorageDevicePureStorageServiceOrchestratorType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDevicePureStorageServiceOrchestratorType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDevicePureStorageServiceOrchestratorType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDevicePureStorageServiceOrchestratorType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDevicePureStorageServiceOrchestratorTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDevicePureStorageServiceOrchestratorType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDevicePureStorageServiceOrchestratorType) ClusterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_id")
	}

	return validatorFn, nil
}

func (v *ValidateStorageDevicePureStorageServiceOrchestratorType) ArraysValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for arrays")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStorageDevicePureStorageServiceOrchestratorType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDevicePureStorageServiceOrchestratorType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDevicePureStorageServiceOrchestratorType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["arrays"]; exists {

		vOpts := append(opts, db.WithValidateField("arrays"))
		if err := fv(ctx, m.GetArrays(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cluster_id"]; exists {

		vOpts := append(opts, db.WithValidateField("cluster_id"))
		if err := fv(ctx, m.GetClusterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["enable_storage_topology"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_storage_topology"))
		if err := fv(ctx, m.GetEnableStorageTopology(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["enable_strict_topology"]; exists {

		vOpts := append(opts, db.WithValidateField("enable_strict_topology"))
		if err := fv(ctx, m.GetEnableStrictTopology(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDevicePureStorageServiceOrchestratorTypeValidator = func() *ValidateStorageDevicePureStorageServiceOrchestratorType {
	v := &ValidateStorageDevicePureStorageServiceOrchestratorType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClusterId := v.ClusterIdValidationRuleHandler
	rulesClusterId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "22",
		"ves.io.schema.rules.string.min_len":   "1",
		"ves.io.schema.rules.string.pattern":   "^[a-z0-9_]*$",
	}
	vFn, err = vrhClusterId(rulesClusterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDevicePureStorageServiceOrchestratorType.cluster_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_id"] = vFn

	vrhArrays := v.ArraysValidationRuleHandler
	rulesArrays := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhArrays(rulesArrays)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageDevicePureStorageServiceOrchestratorType.arrays: %s", err)
		panic(errMsg)
	}
	v.FldValidators["arrays"] = vFn

	return v
}()

func StorageDevicePureStorageServiceOrchestratorTypeValidator() db.Validator {
	return DefaultStorageDevicePureStorageServiceOrchestratorTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VGPUConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VGPUConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VGPUConfiguration) DeepCopy() *VGPUConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VGPUConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VGPUConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VGPUConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VGPUConfigurationValidator().Validate(ctx, m, opts...)
}

type ValidateVGPUConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVGPUConfiguration) ServerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_address")
	}

	return validatorFn, nil
}

func (v *ValidateVGPUConfiguration) ServerPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_port")
	}

	return validatorFn, nil
}

func (v *ValidateVGPUConfiguration) FeatureTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(VGPUFeatureType)
		return int32(i)
	}
	// VGPUFeatureType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, VGPUFeatureType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for feature_type")
	}

	return validatorFn, nil
}

func (v *ValidateVGPUConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VGPUConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VGPUConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["feature_type"]; exists {

		vOpts := append(opts, db.WithValidateField("feature_type"))
		if err := fv(ctx, m.GetFeatureType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["server_address"]; exists {

		vOpts := append(opts, db.WithValidateField("server_address"))
		if err := fv(ctx, m.GetServerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["server_port"]; exists {

		vOpts := append(opts, db.WithValidateField("server_port"))
		if err := fv(ctx, m.GetServerPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVGPUConfigurationValidator = func() *ValidateVGPUConfiguration {
	v := &ValidateVGPUConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServerAddress := v.ServerAddressValidationRuleHandler
	rulesServerAddress := map[string]string{
		"ves.io.schema.rules.string.hostname_or_ip": "true",
	}
	vFn, err = vrhServerAddress(rulesServerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VGPUConfiguration.server_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_address"] = vFn

	vrhServerPort := v.ServerPortValidationRuleHandler
	rulesServerPort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhServerPort(rulesServerPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VGPUConfiguration.server_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_port"] = vFn

	vrhFeatureType := v.FeatureTypeValidationRuleHandler
	rulesFeatureType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhFeatureType(rulesFeatureType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VGPUConfiguration.feature_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["feature_type"] = vFn

	return v
}()

func VGPUConfigurationValidator() db.Validator {
	return DefaultVGPUConfigurationValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetBondChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BondChoice.(type) {
	case nil:
		o.BondChoice = nil

	case *CreateSpecType_BondDeviceList:
		o.BondChoice = &GlobalSpecType_BondDeviceList{BondDeviceList: of.BondDeviceList}

	case *CreateSpecType_NoBondDevices:
		o.BondChoice = &GlobalSpecType_NoBondDevices{NoBondDevices: of.NoBondDevices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetBondChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BondChoice.(type) {
	case nil:
		r.BondChoice = nil

	case *GlobalSpecType_BondDeviceList:
		r.BondChoice = &CreateSpecType_BondDeviceList{BondDeviceList: of.BondDeviceList}

	case *GlobalSpecType_NoBondDevices:
		r.BondChoice = &CreateSpecType_NoBondDevices{NoBondDevices: of.NoBondDevices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetDcClusterGroupChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DcClusterGroupChoice.(type) {
	case nil:
		o.DcClusterGroupChoice = nil

	case *CreateSpecType_DcClusterGroup:
		o.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroup{DcClusterGroup: of.DcClusterGroup}

	case *CreateSpecType_DcClusterGroupInside:
		o.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroupInside{DcClusterGroupInside: of.DcClusterGroupInside}

	case *CreateSpecType_NoDcClusterGroup:
		o.DcClusterGroupChoice = &GlobalSpecType_NoDcClusterGroup{NoDcClusterGroup: of.NoDcClusterGroup}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetDcClusterGroupChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DcClusterGroupChoice.(type) {
	case nil:
		r.DcClusterGroupChoice = nil

	case *GlobalSpecType_DcClusterGroup:
		r.DcClusterGroupChoice = &CreateSpecType_DcClusterGroup{DcClusterGroup: of.DcClusterGroup}

	case *GlobalSpecType_DcClusterGroupInside:
		r.DcClusterGroupChoice = &CreateSpecType_DcClusterGroupInside{DcClusterGroupInside: of.DcClusterGroupInside}

	case *GlobalSpecType_NoDcClusterGroup:
		r.DcClusterGroupChoice = &CreateSpecType_NoDcClusterGroup{NoDcClusterGroup: of.NoDcClusterGroup}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetGpuChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.GpuChoice.(type) {
	case nil:
		o.GpuChoice = nil

	case *CreateSpecType_DisableGpu:
		o.GpuChoice = &GlobalSpecType_DisableGpu{DisableGpu: of.DisableGpu}

	case *CreateSpecType_EnableGpu:
		o.GpuChoice = &GlobalSpecType_EnableGpu{EnableGpu: of.EnableGpu}

	case *CreateSpecType_EnableVgpu:
		o.GpuChoice = &GlobalSpecType_EnableVgpu{EnableVgpu: of.EnableVgpu}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetGpuChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.GpuChoice.(type) {
	case nil:
		r.GpuChoice = nil

	case *GlobalSpecType_DisableGpu:
		r.GpuChoice = &CreateSpecType_DisableGpu{DisableGpu: of.DisableGpu}

	case *GlobalSpecType_EnableGpu:
		r.GpuChoice = &CreateSpecType_EnableGpu{EnableGpu: of.EnableGpu}

	case *GlobalSpecType_EnableVgpu:
		r.GpuChoice = &CreateSpecType_EnableVgpu{EnableVgpu: of.EnableVgpu}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetLogsReceiverChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LogsReceiverChoice.(type) {
	case nil:
		o.LogsReceiverChoice = nil

	case *CreateSpecType_LogReceiver:
		o.LogsReceiverChoice = &GlobalSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *CreateSpecType_LogsStreamingDisabled:
		o.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetLogsReceiverChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LogsReceiverChoice.(type) {
	case nil:
		r.LogsReceiverChoice = nil

	case *GlobalSpecType_LogReceiver:
		r.LogsReceiverChoice = &CreateSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GlobalSpecType_LogsStreamingDisabled:
		r.LogsReceiverChoice = &CreateSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetStorageClassChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageClassChoice.(type) {
	case nil:
		o.StorageClassChoice = nil

	case *CreateSpecType_DefaultStorageClass:
		o.StorageClassChoice = &GlobalSpecType_DefaultStorageClass{DefaultStorageClass: of.DefaultStorageClass}

	case *CreateSpecType_StorageClassList:
		o.StorageClassChoice = &GlobalSpecType_StorageClassList{StorageClassList: of.StorageClassList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetStorageClassChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageClassChoice.(type) {
	case nil:
		r.StorageClassChoice = nil

	case *GlobalSpecType_DefaultStorageClass:
		r.StorageClassChoice = &CreateSpecType_DefaultStorageClass{DefaultStorageClass: of.DefaultStorageClass}

	case *GlobalSpecType_StorageClassList:
		r.StorageClassChoice = &CreateSpecType_StorageClassList{StorageClassList: of.StorageClassList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetStorageDeviceChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageDeviceChoice.(type) {
	case nil:
		o.StorageDeviceChoice = nil

	case *CreateSpecType_NoStorageDevice:
		o.StorageDeviceChoice = &GlobalSpecType_NoStorageDevice{NoStorageDevice: of.NoStorageDevice}

	case *CreateSpecType_StorageDeviceList:
		o.StorageDeviceChoice = &GlobalSpecType_StorageDeviceList{StorageDeviceList: of.StorageDeviceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetStorageDeviceChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageDeviceChoice.(type) {
	case nil:
		r.StorageDeviceChoice = nil

	case *GlobalSpecType_NoStorageDevice:
		r.StorageDeviceChoice = &CreateSpecType_NoStorageDevice{NoStorageDevice: of.NoStorageDevice}

	case *GlobalSpecType_StorageDeviceList:
		r.StorageDeviceChoice = &CreateSpecType_StorageDeviceList{StorageDeviceList: of.StorageDeviceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetStorageInterfaceChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageInterfaceChoice.(type) {
	case nil:
		o.StorageInterfaceChoice = nil

	case *CreateSpecType_NoStorageInterfaces:
		o.StorageInterfaceChoice = &GlobalSpecType_NoStorageInterfaces{NoStorageInterfaces: of.NoStorageInterfaces}

	case *CreateSpecType_StorageInterfaceList:
		o.StorageInterfaceChoice = &GlobalSpecType_StorageInterfaceList{StorageInterfaceList: of.StorageInterfaceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetStorageInterfaceChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageInterfaceChoice.(type) {
	case nil:
		r.StorageInterfaceChoice = nil

	case *GlobalSpecType_NoStorageInterfaces:
		r.StorageInterfaceChoice = &CreateSpecType_NoStorageInterfaces{NoStorageInterfaces: of.NoStorageInterfaces}

	case *GlobalSpecType_StorageInterfaceList:
		r.StorageInterfaceChoice = &CreateSpecType_StorageInterfaceList{StorageInterfaceList: of.StorageInterfaceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetStorageStaticRoutesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageStaticRoutesChoice.(type) {
	case nil:
		o.StorageStaticRoutesChoice = nil

	case *CreateSpecType_NoStorageStaticRoutes:
		o.StorageStaticRoutesChoice = &GlobalSpecType_NoStorageStaticRoutes{NoStorageStaticRoutes: of.NoStorageStaticRoutes}

	case *CreateSpecType_StorageStaticRoutes:
		o.StorageStaticRoutesChoice = &GlobalSpecType_StorageStaticRoutes{StorageStaticRoutes: of.StorageStaticRoutes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetStorageStaticRoutesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageStaticRoutesChoice.(type) {
	case nil:
		r.StorageStaticRoutesChoice = nil

	case *GlobalSpecType_NoStorageStaticRoutes:
		r.StorageStaticRoutesChoice = &CreateSpecType_NoStorageStaticRoutes{NoStorageStaticRoutes: of.NoStorageStaticRoutes}

	case *GlobalSpecType_StorageStaticRoutes:
		r.StorageStaticRoutesChoice = &CreateSpecType_StorageStaticRoutes{StorageStaticRoutes: of.StorageStaticRoutes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetUsbPolicyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.UsbPolicyChoice.(type) {
	case nil:
		o.UsbPolicyChoice = nil

	case *CreateSpecType_AllowAllUsb:
		o.UsbPolicyChoice = &GlobalSpecType_AllowAllUsb{AllowAllUsb: of.AllowAllUsb}

	case *CreateSpecType_DenyAllUsb:
		o.UsbPolicyChoice = &GlobalSpecType_DenyAllUsb{DenyAllUsb: of.DenyAllUsb}

	case *CreateSpecType_UsbPolicy:
		o.UsbPolicyChoice = &GlobalSpecType_UsbPolicy{UsbPolicy: of.UsbPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetUsbPolicyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.UsbPolicyChoice.(type) {
	case nil:
		r.UsbPolicyChoice = nil

	case *GlobalSpecType_AllowAllUsb:
		r.UsbPolicyChoice = &CreateSpecType_AllowAllUsb{AllowAllUsb: of.AllowAllUsb}

	case *GlobalSpecType_DenyAllUsb:
		r.UsbPolicyChoice = &CreateSpecType_DenyAllUsb{DenyAllUsb: of.DenyAllUsb}

	case *GlobalSpecType_UsbPolicy:
		r.UsbPolicyChoice = &CreateSpecType_UsbPolicy{UsbPolicy: of.UsbPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetBondChoiceFromGlobalSpecType(f)
	m.GetDcClusterGroupChoiceFromGlobalSpecType(f)
	m.EnableDefaultFleetConfigDownload = f.GetEnableDefaultFleetConfigDownload()
	m.FleetLabel = f.GetFleetLabel()
	m.GetGpuChoiceFromGlobalSpecType(f)
	m.InsideVirtualNetwork = f.GetInsideVirtualNetwork()

	m.GetLogsReceiverChoiceFromGlobalSpecType(f)
	m.NetworkConnectors = f.GetNetworkConnectors()
	m.NetworkFirewall = f.GetNetworkFirewall()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideVirtualNetwork = f.GetOutsideVirtualNetwork()
	m.GetStorageClassChoiceFromGlobalSpecType(f)
	m.GetStorageDeviceChoiceFromGlobalSpecType(f)
	m.GetStorageInterfaceChoiceFromGlobalSpecType(f)
	m.GetStorageStaticRoutesChoiceFromGlobalSpecType(f)
	m.GetUsbPolicyChoiceFromGlobalSpecType(f)
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetBondChoiceToGlobalSpecType(f)
	m1.SetDcClusterGroupChoiceToGlobalSpecType(f)
	f.EnableDefaultFleetConfigDownload = m1.EnableDefaultFleetConfigDownload
	f.FleetLabel = m1.FleetLabel
	m1.SetGpuChoiceToGlobalSpecType(f)
	f.InsideVirtualNetwork = m1.InsideVirtualNetwork

	m1.SetLogsReceiverChoiceToGlobalSpecType(f)
	f.NetworkConnectors = m1.NetworkConnectors
	f.NetworkFirewall = m1.NetworkFirewall
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideVirtualNetwork = m1.OutsideVirtualNetwork
	m1.SetStorageClassChoiceToGlobalSpecType(f)
	m1.SetStorageDeviceChoiceToGlobalSpecType(f)
	m1.SetStorageInterfaceChoiceToGlobalSpecType(f)
	m1.SetStorageStaticRoutesChoiceToGlobalSpecType(f)
	m1.SetUsbPolicyChoiceToGlobalSpecType(f)
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetBondChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BondChoice.(type) {
	case nil:
		o.BondChoice = nil

	case *GetSpecType_BondDeviceList:
		o.BondChoice = &GlobalSpecType_BondDeviceList{BondDeviceList: of.BondDeviceList}

	case *GetSpecType_NoBondDevices:
		o.BondChoice = &GlobalSpecType_NoBondDevices{NoBondDevices: of.NoBondDevices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetBondChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BondChoice.(type) {
	case nil:
		r.BondChoice = nil

	case *GlobalSpecType_BondDeviceList:
		r.BondChoice = &GetSpecType_BondDeviceList{BondDeviceList: of.BondDeviceList}

	case *GlobalSpecType_NoBondDevices:
		r.BondChoice = &GetSpecType_NoBondDevices{NoBondDevices: of.NoBondDevices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDcClusterGroupChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DcClusterGroupChoice.(type) {
	case nil:
		o.DcClusterGroupChoice = nil

	case *GetSpecType_DcClusterGroup:
		o.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroup{DcClusterGroup: of.DcClusterGroup}

	case *GetSpecType_DcClusterGroupInside:
		o.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroupInside{DcClusterGroupInside: of.DcClusterGroupInside}

	case *GetSpecType_NoDcClusterGroup:
		o.DcClusterGroupChoice = &GlobalSpecType_NoDcClusterGroup{NoDcClusterGroup: of.NoDcClusterGroup}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDcClusterGroupChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DcClusterGroupChoice.(type) {
	case nil:
		r.DcClusterGroupChoice = nil

	case *GlobalSpecType_DcClusterGroup:
		r.DcClusterGroupChoice = &GetSpecType_DcClusterGroup{DcClusterGroup: of.DcClusterGroup}

	case *GlobalSpecType_DcClusterGroupInside:
		r.DcClusterGroupChoice = &GetSpecType_DcClusterGroupInside{DcClusterGroupInside: of.DcClusterGroupInside}

	case *GlobalSpecType_NoDcClusterGroup:
		r.DcClusterGroupChoice = &GetSpecType_NoDcClusterGroup{NoDcClusterGroup: of.NoDcClusterGroup}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetGpuChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.GpuChoice.(type) {
	case nil:
		o.GpuChoice = nil

	case *GetSpecType_DisableGpu:
		o.GpuChoice = &GlobalSpecType_DisableGpu{DisableGpu: of.DisableGpu}

	case *GetSpecType_EnableGpu:
		o.GpuChoice = &GlobalSpecType_EnableGpu{EnableGpu: of.EnableGpu}

	case *GetSpecType_EnableVgpu:
		o.GpuChoice = &GlobalSpecType_EnableVgpu{EnableVgpu: of.EnableVgpu}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetGpuChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.GpuChoice.(type) {
	case nil:
		r.GpuChoice = nil

	case *GlobalSpecType_DisableGpu:
		r.GpuChoice = &GetSpecType_DisableGpu{DisableGpu: of.DisableGpu}

	case *GlobalSpecType_EnableGpu:
		r.GpuChoice = &GetSpecType_EnableGpu{EnableGpu: of.EnableGpu}

	case *GlobalSpecType_EnableVgpu:
		r.GpuChoice = &GetSpecType_EnableVgpu{EnableVgpu: of.EnableVgpu}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetLogsReceiverChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LogsReceiverChoice.(type) {
	case nil:
		o.LogsReceiverChoice = nil

	case *GetSpecType_LogReceiver:
		o.LogsReceiverChoice = &GlobalSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GetSpecType_LogsStreamingDisabled:
		o.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetLogsReceiverChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LogsReceiverChoice.(type) {
	case nil:
		r.LogsReceiverChoice = nil

	case *GlobalSpecType_LogReceiver:
		r.LogsReceiverChoice = &GetSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GlobalSpecType_LogsStreamingDisabled:
		r.LogsReceiverChoice = &GetSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetStorageClassChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageClassChoice.(type) {
	case nil:
		o.StorageClassChoice = nil

	case *GetSpecType_DefaultStorageClass:
		o.StorageClassChoice = &GlobalSpecType_DefaultStorageClass{DefaultStorageClass: of.DefaultStorageClass}

	case *GetSpecType_StorageClassList:
		o.StorageClassChoice = &GlobalSpecType_StorageClassList{StorageClassList: of.StorageClassList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetStorageClassChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageClassChoice.(type) {
	case nil:
		r.StorageClassChoice = nil

	case *GlobalSpecType_DefaultStorageClass:
		r.StorageClassChoice = &GetSpecType_DefaultStorageClass{DefaultStorageClass: of.DefaultStorageClass}

	case *GlobalSpecType_StorageClassList:
		r.StorageClassChoice = &GetSpecType_StorageClassList{StorageClassList: of.StorageClassList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetStorageDeviceChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageDeviceChoice.(type) {
	case nil:
		o.StorageDeviceChoice = nil

	case *GetSpecType_NoStorageDevice:
		o.StorageDeviceChoice = &GlobalSpecType_NoStorageDevice{NoStorageDevice: of.NoStorageDevice}

	case *GetSpecType_StorageDeviceList:
		o.StorageDeviceChoice = &GlobalSpecType_StorageDeviceList{StorageDeviceList: of.StorageDeviceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetStorageDeviceChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageDeviceChoice.(type) {
	case nil:
		r.StorageDeviceChoice = nil

	case *GlobalSpecType_NoStorageDevice:
		r.StorageDeviceChoice = &GetSpecType_NoStorageDevice{NoStorageDevice: of.NoStorageDevice}

	case *GlobalSpecType_StorageDeviceList:
		r.StorageDeviceChoice = &GetSpecType_StorageDeviceList{StorageDeviceList: of.StorageDeviceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetStorageInterfaceChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageInterfaceChoice.(type) {
	case nil:
		o.StorageInterfaceChoice = nil

	case *GetSpecType_NoStorageInterfaces:
		o.StorageInterfaceChoice = &GlobalSpecType_NoStorageInterfaces{NoStorageInterfaces: of.NoStorageInterfaces}

	case *GetSpecType_StorageInterfaceList:
		o.StorageInterfaceChoice = &GlobalSpecType_StorageInterfaceList{StorageInterfaceList: of.StorageInterfaceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetStorageInterfaceChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageInterfaceChoice.(type) {
	case nil:
		r.StorageInterfaceChoice = nil

	case *GlobalSpecType_NoStorageInterfaces:
		r.StorageInterfaceChoice = &GetSpecType_NoStorageInterfaces{NoStorageInterfaces: of.NoStorageInterfaces}

	case *GlobalSpecType_StorageInterfaceList:
		r.StorageInterfaceChoice = &GetSpecType_StorageInterfaceList{StorageInterfaceList: of.StorageInterfaceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetStorageStaticRoutesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageStaticRoutesChoice.(type) {
	case nil:
		o.StorageStaticRoutesChoice = nil

	case *GetSpecType_NoStorageStaticRoutes:
		o.StorageStaticRoutesChoice = &GlobalSpecType_NoStorageStaticRoutes{NoStorageStaticRoutes: of.NoStorageStaticRoutes}

	case *GetSpecType_StorageStaticRoutes:
		o.StorageStaticRoutesChoice = &GlobalSpecType_StorageStaticRoutes{StorageStaticRoutes: of.StorageStaticRoutes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetStorageStaticRoutesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageStaticRoutesChoice.(type) {
	case nil:
		r.StorageStaticRoutesChoice = nil

	case *GlobalSpecType_NoStorageStaticRoutes:
		r.StorageStaticRoutesChoice = &GetSpecType_NoStorageStaticRoutes{NoStorageStaticRoutes: of.NoStorageStaticRoutes}

	case *GlobalSpecType_StorageStaticRoutes:
		r.StorageStaticRoutesChoice = &GetSpecType_StorageStaticRoutes{StorageStaticRoutes: of.StorageStaticRoutes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetUsbPolicyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.UsbPolicyChoice.(type) {
	case nil:
		o.UsbPolicyChoice = nil

	case *GetSpecType_AllowAllUsb:
		o.UsbPolicyChoice = &GlobalSpecType_AllowAllUsb{AllowAllUsb: of.AllowAllUsb}

	case *GetSpecType_DenyAllUsb:
		o.UsbPolicyChoice = &GlobalSpecType_DenyAllUsb{DenyAllUsb: of.DenyAllUsb}

	case *GetSpecType_UsbPolicy:
		o.UsbPolicyChoice = &GlobalSpecType_UsbPolicy{UsbPolicy: of.UsbPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetUsbPolicyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.UsbPolicyChoice.(type) {
	case nil:
		r.UsbPolicyChoice = nil

	case *GlobalSpecType_AllowAllUsb:
		r.UsbPolicyChoice = &GetSpecType_AllowAllUsb{AllowAllUsb: of.AllowAllUsb}

	case *GlobalSpecType_DenyAllUsb:
		r.UsbPolicyChoice = &GetSpecType_DenyAllUsb{DenyAllUsb: of.DenyAllUsb}

	case *GlobalSpecType_UsbPolicy:
		r.UsbPolicyChoice = &GetSpecType_UsbPolicy{UsbPolicy: of.UsbPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetBondChoiceFromGlobalSpecType(f)
	m.GetDcClusterGroupChoiceFromGlobalSpecType(f)
	m.EnableDefaultFleetConfigDownload = f.GetEnableDefaultFleetConfigDownload()
	m.FleetLabel = f.GetFleetLabel()
	m.GetGpuChoiceFromGlobalSpecType(f)
	m.InsideVirtualNetwork = f.GetInsideVirtualNetwork()

	m.GetLogsReceiverChoiceFromGlobalSpecType(f)
	m.NetworkConnectors = f.GetNetworkConnectors()
	m.NetworkFirewall = f.GetNetworkFirewall()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideVirtualNetwork = f.GetOutsideVirtualNetwork()
	m.GetStorageClassChoiceFromGlobalSpecType(f)
	m.GetStorageDeviceChoiceFromGlobalSpecType(f)
	m.GetStorageInterfaceChoiceFromGlobalSpecType(f)
	m.GetStorageStaticRoutesChoiceFromGlobalSpecType(f)
	m.GetUsbPolicyChoiceFromGlobalSpecType(f)
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetBondChoiceToGlobalSpecType(f)
	m1.SetDcClusterGroupChoiceToGlobalSpecType(f)
	f.EnableDefaultFleetConfigDownload = m1.EnableDefaultFleetConfigDownload
	f.FleetLabel = m1.FleetLabel
	m1.SetGpuChoiceToGlobalSpecType(f)
	f.InsideVirtualNetwork = m1.InsideVirtualNetwork

	m1.SetLogsReceiverChoiceToGlobalSpecType(f)
	f.NetworkConnectors = m1.NetworkConnectors
	f.NetworkFirewall = m1.NetworkFirewall
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideVirtualNetwork = m1.OutsideVirtualNetwork
	m1.SetStorageClassChoiceToGlobalSpecType(f)
	m1.SetStorageDeviceChoiceToGlobalSpecType(f)
	m1.SetStorageInterfaceChoiceToGlobalSpecType(f)
	m1.SetStorageStaticRoutesChoiceToGlobalSpecType(f)
	m1.SetUsbPolicyChoiceToGlobalSpecType(f)
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetBondChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BondChoice.(type) {
	case nil:
		o.BondChoice = nil

	case *ReplaceSpecType_BondDeviceList:
		o.BondChoice = &GlobalSpecType_BondDeviceList{BondDeviceList: of.BondDeviceList}

	case *ReplaceSpecType_NoBondDevices:
		o.BondChoice = &GlobalSpecType_NoBondDevices{NoBondDevices: of.NoBondDevices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetBondChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BondChoice.(type) {
	case nil:
		r.BondChoice = nil

	case *GlobalSpecType_BondDeviceList:
		r.BondChoice = &ReplaceSpecType_BondDeviceList{BondDeviceList: of.BondDeviceList}

	case *GlobalSpecType_NoBondDevices:
		r.BondChoice = &ReplaceSpecType_NoBondDevices{NoBondDevices: of.NoBondDevices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetDcClusterGroupChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DcClusterGroupChoice.(type) {
	case nil:
		o.DcClusterGroupChoice = nil

	case *ReplaceSpecType_DcClusterGroup:
		o.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroup{DcClusterGroup: of.DcClusterGroup}

	case *ReplaceSpecType_DcClusterGroupInside:
		o.DcClusterGroupChoice = &GlobalSpecType_DcClusterGroupInside{DcClusterGroupInside: of.DcClusterGroupInside}

	case *ReplaceSpecType_NoDcClusterGroup:
		o.DcClusterGroupChoice = &GlobalSpecType_NoDcClusterGroup{NoDcClusterGroup: of.NoDcClusterGroup}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetDcClusterGroupChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DcClusterGroupChoice.(type) {
	case nil:
		r.DcClusterGroupChoice = nil

	case *GlobalSpecType_DcClusterGroup:
		r.DcClusterGroupChoice = &ReplaceSpecType_DcClusterGroup{DcClusterGroup: of.DcClusterGroup}

	case *GlobalSpecType_DcClusterGroupInside:
		r.DcClusterGroupChoice = &ReplaceSpecType_DcClusterGroupInside{DcClusterGroupInside: of.DcClusterGroupInside}

	case *GlobalSpecType_NoDcClusterGroup:
		r.DcClusterGroupChoice = &ReplaceSpecType_NoDcClusterGroup{NoDcClusterGroup: of.NoDcClusterGroup}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetGpuChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.GpuChoice.(type) {
	case nil:
		o.GpuChoice = nil

	case *ReplaceSpecType_DisableGpu:
		o.GpuChoice = &GlobalSpecType_DisableGpu{DisableGpu: of.DisableGpu}

	case *ReplaceSpecType_EnableGpu:
		o.GpuChoice = &GlobalSpecType_EnableGpu{EnableGpu: of.EnableGpu}

	case *ReplaceSpecType_EnableVgpu:
		o.GpuChoice = &GlobalSpecType_EnableVgpu{EnableVgpu: of.EnableVgpu}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetGpuChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.GpuChoice.(type) {
	case nil:
		r.GpuChoice = nil

	case *GlobalSpecType_DisableGpu:
		r.GpuChoice = &ReplaceSpecType_DisableGpu{DisableGpu: of.DisableGpu}

	case *GlobalSpecType_EnableGpu:
		r.GpuChoice = &ReplaceSpecType_EnableGpu{EnableGpu: of.EnableGpu}

	case *GlobalSpecType_EnableVgpu:
		r.GpuChoice = &ReplaceSpecType_EnableVgpu{EnableVgpu: of.EnableVgpu}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetLogsReceiverChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LogsReceiverChoice.(type) {
	case nil:
		o.LogsReceiverChoice = nil

	case *ReplaceSpecType_LogReceiver:
		o.LogsReceiverChoice = &GlobalSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *ReplaceSpecType_LogsStreamingDisabled:
		o.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetLogsReceiverChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LogsReceiverChoice.(type) {
	case nil:
		r.LogsReceiverChoice = nil

	case *GlobalSpecType_LogReceiver:
		r.LogsReceiverChoice = &ReplaceSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GlobalSpecType_LogsStreamingDisabled:
		r.LogsReceiverChoice = &ReplaceSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetStorageClassChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageClassChoice.(type) {
	case nil:
		o.StorageClassChoice = nil

	case *ReplaceSpecType_DefaultStorageClass:
		o.StorageClassChoice = &GlobalSpecType_DefaultStorageClass{DefaultStorageClass: of.DefaultStorageClass}

	case *ReplaceSpecType_StorageClassList:
		o.StorageClassChoice = &GlobalSpecType_StorageClassList{StorageClassList: of.StorageClassList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetStorageClassChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageClassChoice.(type) {
	case nil:
		r.StorageClassChoice = nil

	case *GlobalSpecType_DefaultStorageClass:
		r.StorageClassChoice = &ReplaceSpecType_DefaultStorageClass{DefaultStorageClass: of.DefaultStorageClass}

	case *GlobalSpecType_StorageClassList:
		r.StorageClassChoice = &ReplaceSpecType_StorageClassList{StorageClassList: of.StorageClassList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetStorageDeviceChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageDeviceChoice.(type) {
	case nil:
		o.StorageDeviceChoice = nil

	case *ReplaceSpecType_NoStorageDevice:
		o.StorageDeviceChoice = &GlobalSpecType_NoStorageDevice{NoStorageDevice: of.NoStorageDevice}

	case *ReplaceSpecType_StorageDeviceList:
		o.StorageDeviceChoice = &GlobalSpecType_StorageDeviceList{StorageDeviceList: of.StorageDeviceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetStorageDeviceChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageDeviceChoice.(type) {
	case nil:
		r.StorageDeviceChoice = nil

	case *GlobalSpecType_NoStorageDevice:
		r.StorageDeviceChoice = &ReplaceSpecType_NoStorageDevice{NoStorageDevice: of.NoStorageDevice}

	case *GlobalSpecType_StorageDeviceList:
		r.StorageDeviceChoice = &ReplaceSpecType_StorageDeviceList{StorageDeviceList: of.StorageDeviceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetStorageInterfaceChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageInterfaceChoice.(type) {
	case nil:
		o.StorageInterfaceChoice = nil

	case *ReplaceSpecType_NoStorageInterfaces:
		o.StorageInterfaceChoice = &GlobalSpecType_NoStorageInterfaces{NoStorageInterfaces: of.NoStorageInterfaces}

	case *ReplaceSpecType_StorageInterfaceList:
		o.StorageInterfaceChoice = &GlobalSpecType_StorageInterfaceList{StorageInterfaceList: of.StorageInterfaceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetStorageInterfaceChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageInterfaceChoice.(type) {
	case nil:
		r.StorageInterfaceChoice = nil

	case *GlobalSpecType_NoStorageInterfaces:
		r.StorageInterfaceChoice = &ReplaceSpecType_NoStorageInterfaces{NoStorageInterfaces: of.NoStorageInterfaces}

	case *GlobalSpecType_StorageInterfaceList:
		r.StorageInterfaceChoice = &ReplaceSpecType_StorageInterfaceList{StorageInterfaceList: of.StorageInterfaceList}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetStorageStaticRoutesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.StorageStaticRoutesChoice.(type) {
	case nil:
		o.StorageStaticRoutesChoice = nil

	case *ReplaceSpecType_NoStorageStaticRoutes:
		o.StorageStaticRoutesChoice = &GlobalSpecType_NoStorageStaticRoutes{NoStorageStaticRoutes: of.NoStorageStaticRoutes}

	case *ReplaceSpecType_StorageStaticRoutes:
		o.StorageStaticRoutesChoice = &GlobalSpecType_StorageStaticRoutes{StorageStaticRoutes: of.StorageStaticRoutes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetStorageStaticRoutesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.StorageStaticRoutesChoice.(type) {
	case nil:
		r.StorageStaticRoutesChoice = nil

	case *GlobalSpecType_NoStorageStaticRoutes:
		r.StorageStaticRoutesChoice = &ReplaceSpecType_NoStorageStaticRoutes{NoStorageStaticRoutes: of.NoStorageStaticRoutes}

	case *GlobalSpecType_StorageStaticRoutes:
		r.StorageStaticRoutesChoice = &ReplaceSpecType_StorageStaticRoutes{StorageStaticRoutes: of.StorageStaticRoutes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetUsbPolicyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.UsbPolicyChoice.(type) {
	case nil:
		o.UsbPolicyChoice = nil

	case *ReplaceSpecType_AllowAllUsb:
		o.UsbPolicyChoice = &GlobalSpecType_AllowAllUsb{AllowAllUsb: of.AllowAllUsb}

	case *ReplaceSpecType_DenyAllUsb:
		o.UsbPolicyChoice = &GlobalSpecType_DenyAllUsb{DenyAllUsb: of.DenyAllUsb}

	case *ReplaceSpecType_UsbPolicy:
		o.UsbPolicyChoice = &GlobalSpecType_UsbPolicy{UsbPolicy: of.UsbPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetUsbPolicyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.UsbPolicyChoice.(type) {
	case nil:
		r.UsbPolicyChoice = nil

	case *GlobalSpecType_AllowAllUsb:
		r.UsbPolicyChoice = &ReplaceSpecType_AllowAllUsb{AllowAllUsb: of.AllowAllUsb}

	case *GlobalSpecType_DenyAllUsb:
		r.UsbPolicyChoice = &ReplaceSpecType_DenyAllUsb{DenyAllUsb: of.DenyAllUsb}

	case *GlobalSpecType_UsbPolicy:
		r.UsbPolicyChoice = &ReplaceSpecType_UsbPolicy{UsbPolicy: of.UsbPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetBondChoiceFromGlobalSpecType(f)
	m.GetDcClusterGroupChoiceFromGlobalSpecType(f)
	m.EnableDefaultFleetConfigDownload = f.GetEnableDefaultFleetConfigDownload()
	m.GetGpuChoiceFromGlobalSpecType(f)
	m.InsideVirtualNetwork = f.GetInsideVirtualNetwork()

	m.GetLogsReceiverChoiceFromGlobalSpecType(f)
	m.NetworkConnectors = f.GetNetworkConnectors()
	m.NetworkFirewall = f.GetNetworkFirewall()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideVirtualNetwork = f.GetOutsideVirtualNetwork()
	m.GetStorageClassChoiceFromGlobalSpecType(f)
	m.GetStorageDeviceChoiceFromGlobalSpecType(f)
	m.GetStorageInterfaceChoiceFromGlobalSpecType(f)
	m.GetStorageStaticRoutesChoiceFromGlobalSpecType(f)
	m.GetUsbPolicyChoiceFromGlobalSpecType(f)
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetBondChoiceToGlobalSpecType(f)
	m1.SetDcClusterGroupChoiceToGlobalSpecType(f)
	f.EnableDefaultFleetConfigDownload = m1.EnableDefaultFleetConfigDownload
	m1.SetGpuChoiceToGlobalSpecType(f)
	f.InsideVirtualNetwork = m1.InsideVirtualNetwork

	m1.SetLogsReceiverChoiceToGlobalSpecType(f)
	f.NetworkConnectors = m1.NetworkConnectors
	f.NetworkFirewall = m1.NetworkFirewall
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideVirtualNetwork = m1.OutsideVirtualNetwork
	m1.SetStorageClassChoiceToGlobalSpecType(f)
	m1.SetStorageDeviceChoiceToGlobalSpecType(f)
	m1.SetStorageInterfaceChoiceToGlobalSpecType(f)
	m1.SetStorageStaticRoutesChoiceToGlobalSpecType(f)
	m1.SetUsbPolicyChoiceToGlobalSpecType(f)
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}
