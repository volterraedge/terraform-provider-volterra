// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package service_policy

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"

	google_protobuf "github.com/gogo/protobuf/types"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	multierror "github.com/hashicorp/go-multierror"
	"go.uber.org/zap"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/client/configapi"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

const (
	// CreateRequestFQN is the fully-qualified-name of the CreateRequest message
	CreateRequestFQN = "ves.io.schema.service_policy.CreateRequest"
	// CreateResponseFQN is the fully-qualified-name of the CreateResponse message
	CreateResponseFQN = "ves.io.schema.service_policy.CreateResponse"
	// ReplaceRequestFQN is the fully-qualified-name of the ReplaceRequest message
	ReplaceRequestFQN = "ves.io.schema.service_policy.ReplaceRequest"
	// ReplaceResponseFQN is the fully-qualified-name of the ReplaceResponse message
	ReplaceResponseFQN = "ves.io.schema.service_policy.ReplaceResponse"
	// GetRequestFQN is the fully-qualified-name of the GetRequest message
	GetRequestFQN = "ves.io.schema.service_policy.GetRequest"
	// GetResponseFQN is the fully-qualified-name of the GetResponse message
	GetResponseFQN = "ves.io.schema.service_policy.GetResponse"
	// ListRequestFQN is the fully-qualified-name of the ListRequest message
	ListRequestFQN = "ves.io.schema.service_policy.ListRequest"
	// ListResponseFQN is the fully-qualified-name of the ListResponse message
	ListResponseFQN = "ves.io.schema.service_policy.ListResponse"
	// DeleteRequestFQN is the fully-qualified-name of the DeleteRequest message
	DeleteRequestFQN = "ves.io.schema.service_policy.DeleteRequest"
	// DeleteResponseFQN is the fully-qualified-name of the DeleteResponse message
	DeleteResponseFQN = "ves.io.schema.service_policy.DeleteResponse"
)

// CLIENT side
func NewCreateRequest(e db.Entry) (*CreateRequest, error) {
	r := &CreateRequest{}
	if e == nil {
		return r, nil
	}
	r.FromObject(e)
	return r, nil
}

func NewReplaceRequest(e db.Entry) (*ReplaceRequest, error) {
	r := &ReplaceRequest{}
	if e == nil {
		return r, nil
	}
	r.FromObject(e)
	return r, nil
}

func NewGetRequest(key string, opts ...server.CRUDCallOpt) (*GetRequest, error) {
	strs := strings.Split(key, "/")
	if len(strs) != 2 {
		return nil, fmt.Errorf("key must have namespace and name separated by /, but found %s", key)
	}
	ccOpts := server.NewCRUDCallOpts()
	for _, o := range opts {
		o(ccOpts)
	}
	var rspFmt GetResponseFormatCode
	switch ccOpts.ResponseFormat {
	case server.DefaultForm:
		rspFmt = GET_RSP_FORMAT_DEFAULT
	case server.CreateRequestForm:
		rspFmt = GET_RSP_FORMAT_FOR_CREATE
	case server.ReplaceRequestForm:
		rspFmt = GET_RSP_FORMAT_FOR_REPLACE
	case server.StatusForm:
		rspFmt = GET_RSP_FORMAT_STATUS
	case server.GetSpecForm:
		rspFmt = GET_RSP_FORMAT_READ
	case server.BrokenRefsForm:
		rspFmt = GET_RSP_FORMAT_BROKEN_REFERENCES
	default:
		return nil, fmt.Errorf("Unsupported Response Format %s", ccOpts.ResponseFormat)
	}
	return &GetRequest{Namespace: strs[0], Name: strs[1], ResponseFormat: rspFmt}, nil
}
func (m *GetRequest) ResponseFormatString() string {
	return m.GetResponseFormat().String()
}

func NewListRequest(opts ...server.CRUDCallOpt) *ListRequest {
	ccOpts := server.NewCRUDCallOpts()
	for _, o := range opts {
		o(ccOpts)
	}
	return &ListRequest{Namespace: ccOpts.Namespace}
}

func NewDeleteRequest(key string) (*DeleteRequest, error) {
	strs := strings.Split(key, "/")
	if len(strs) != 2 {
		return nil, fmt.Errorf("key must have namespace and name separated by /, but found %s", key)
	}
	return &DeleteRequest{Namespace: strs[0], Name: strs[1]}, nil
}

// GRPC Client
type crudAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient APIClient
}

func (c *crudAPIGrpcClient) Create(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) (db.Entry, error) {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	var req *CreateRequest
	if cco.RequestProto != nil {
		r, ok := cco.RequestProto.(*CreateRequest)
		if !ok {
			return nil, fmt.Errorf("%T is not *CreateRequest", cco.RequestProto)
		}
		req = r
	} else {
		r, err := NewCreateRequest(e)
		if err != nil {
			return nil, errors.Wrap(err, "Create")
		}
		req = r
		if cco.ObjToMsgConverter != nil {
			if err := cco.ObjToMsgConverter(e, req); err != nil {
				return nil, err
			}
		}
	}

	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := c.grpcClient.Create(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return nil, err
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	obj := NewDBObject(nil)
	rsp.ToObject(obj)
	if cco.MsgToObjConverter != nil {
		if err := cco.MsgToObjConverter(rsp, obj); err != nil {
			return nil, err
		}
	}
	return obj, nil

}

func (c *crudAPIGrpcClient) Replace(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) error {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	var req *ReplaceRequest
	if cco.RequestProto != nil {
		r, ok := cco.RequestProto.(*ReplaceRequest)
		if !ok {
			return fmt.Errorf("%T is not *ReplaceRequest", cco.RequestProto)
		}
		req = r
	} else {
		r, err := NewReplaceRequest(e)
		if err != nil {
			return errors.Wrap(err, "Replace")
		}
		req = r
		if cco.ObjToMsgConverter != nil {
			if err := cco.ObjToMsgConverter(e, req); err != nil {
				return err
			}
		}
	}

	ctx = client.AddHdrsToCtx(cco.Headers, ctx)
	req.ResourceVersion = cco.ResourceVersion

	rsp, err := c.grpcClient.Replace(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return err
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return nil

}

func (c *crudAPIGrpcClient) GetRaw(ctx context.Context, key string, opts ...server.CRUDCallOpt) (*GetResponse, error) {
	req, err := NewGetRequest(key, opts...)
	if err != nil {
		return nil, errors.Wrap(err, "Get")
	}
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := c.grpcClient.Get(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return nil, err
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rsp.ResourceVersion
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func (c *crudAPIGrpcClient) Get(ctx context.Context, key string, opts ...server.CRUDCallOpt) (db.Entry, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	if gRsp != nil {
		obj := NewDBObject(nil)
		gRsp.ToObject(obj)
		return obj, err
	}
	return nil, err

}

func (c *crudAPIGrpcClient) GetDetail(ctx context.Context, key string, nef db.NewEntryFunc, opts ...server.CRUDCallOpt) (*server.GetResponse, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	respDetail := server.GetResponse{}
	if gRsp != nil {
		respDetail.Entry = NewDBObject(nil)
		gRsp.ToObject(respDetail.Entry)
		for _, status := range gRsp.Status {
			respDetail.BackRefs = append(respDetail.BackRefs, NewDBStatusObject(status))
		}

		return &respDetail, err
	}
	return nil, err

}

func (c *crudAPIGrpcClient) ListIDs(ctx context.Context, opts ...server.CRUDCallOpt) ([]string, error) {

	idSet := []string{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return idSet, err
	}
	for _, li := range listRsp.GetItems() {
		idSet = append(idSet, li.GetUid())
	}
	return idSet, err

}

func (c *crudAPIGrpcClient) ListItems(ctx context.Context, opts ...server.CRUDCallOpt) ([]server.ListItem, error) {

	sliSet := []server.ListItem{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return sliSet, err
	}
	for _, li := range listRsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err

}

func (c *crudAPIGrpcClient) List(ctx context.Context, opts ...server.CRUDCallOpt) (*ListResponse, error) {
	req := NewListRequest(opts...)

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		req.LabelFilter = cco.LabelFilter[0]
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}
	req.ReportFields = cco.ReportFields
	req.ReportStatusFields = cco.ReportStatusFields
	rsp, err := c.grpcClient.List(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return nil, err
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func (c *crudAPIGrpcClient) ListStream(ctx context.Context, opts ...server.CRUDCallOpt) (server.ListStreamRsp, error) {
	return nil, fmt.Errorf("Not implemented")
}

func (c *crudAPIGrpcClient) Delete(ctx context.Context, key string, opts ...server.CRUDCallOpt) error {

	req, err := NewDeleteRequest(key)
	if err != nil {
		return errors.Wrap(err, "Delete")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := c.grpcClient.Delete(ctx, req, cco.GrpcCallOpts...)
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err

}

func NewCRUDAPIGrpcClient(cc *grpc.ClientConn) server.CRUDClient {
	ccl := &crudAPIGrpcClient{cc, NewAPIClient(cc)}
	return ccl
}

// REST Client
type crudAPIRestClient struct {
	baseURL string
	client  http.Client
}

func (c *crudAPIRestClient) Create(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) (db.Entry, error) {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	got := 0
	if e != nil {
		got++
	}
	if cco.RequestProto != nil {
		got++
	}
	if cco.RequestJSON != "" {
		got++
	}
	if got != 1 {
		return nil, fmt.Errorf("Only one of entry(%v), WithRequestProto()(%v) or WithRequestJSON()(%v) should be specified", e, cco.RequestProto, cco.RequestJSON)
	}

	var jsn string
	if cco.RequestJSON != "" {
		jsn = cco.RequestJSON
	} else {
		var req *CreateRequest
		if cco.RequestProto != nil {
			r, ok := cco.RequestProto.(*CreateRequest)
			if !ok {
				return nil, fmt.Errorf("%T is not *CreateRequest", cco.RequestProto)
			}
			req = r
		} else {
			r, err := NewCreateRequest(e)
			if err != nil {
				return nil, errors.Wrap(err, "Creating new create request")
			}
			req = r
			if cco.ObjToMsgConverter != nil {
				if err := cco.ObjToMsgConverter(e, req); err != nil {
					return nil, err
				}
			}
		}

		j, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "RestClient Create")
		}
		jsn = j
	}

	var namespace string
	reqMap := make(map[string]interface{})
	if err := json.Unmarshal([]byte(jsn), &reqMap); err != nil {
		return nil, errors.Wrapf(err, "Unmarshaling json to find namespace/name")
	}
	md, ok := reqMap["metadata"].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("Request %s does not have 'metadata'", jsn)
	}
	if val, ok := md["namespace"].(string); ok {
		namespace = val
	} else {
		return nil, fmt.Errorf("Request %s does not have 'metadata.namespace'", jsn)
	}

	url := fmt.Sprintf("%s/public/namespaces/%s/service_policys", c.baseURL, namespace)

	hReq, err := http.NewRequest("POST", url, bytes.NewBuffer([]byte(jsn)))
	if err != nil {
		return nil, err
	}
	hReq = hReq.WithContext(ctx)

	client.AddHdrsToReq(cco.Headers, hReq)
	hReq.Header.Set("Content-Type", "application/json")

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()
	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return nil, fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return nil, fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}
	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient create")
	}

	rspo := &CreateResponse{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return nil, errors.Wrap(err, "Converting json to response protobuf message")
	}
	configapi.TranscribeCall(ctx, jsn, string(body))
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}

	obj := NewDBObject(nil)
	rspo.ToObject(obj)
	if cco.MsgToObjConverter != nil {
		if err := cco.MsgToObjConverter(rspo, obj); err != nil {
			return nil, err
		}
	}
	return obj, nil

}

func (c *crudAPIRestClient) Replace(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) error {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	got := 0
	if e != nil {
		got++
	}
	if cco.RequestProto != nil {
		got++
	}
	if cco.RequestJSON != "" {
		got++
	}
	if got != 1 {
		return fmt.Errorf("Only one of entry(%v), WithRequestProto()(%v) or WithRequestJSON()(%v) should be specified", e, cco.RequestProto, cco.RequestJSON)
	}

	var jsn string
	if cco.RequestJSON != "" {
		jsn = cco.RequestJSON
	} else {
		var rReq *ReplaceRequest
		if cco.RequestProto != nil {
			r, ok := cco.RequestProto.(*ReplaceRequest)
			if !ok {
				return fmt.Errorf("%T is not *ReplaceRequest", cco.RequestProto)
			}
			rReq = r
		} else {
			r, err := NewReplaceRequest(e)
			if err != nil {
				return errors.Wrap(err, "Creating new replace request")
			}
			rReq = r
			if cco.ObjToMsgConverter != nil {
				if err := cco.ObjToMsgConverter(e, rReq); err != nil {
					return err
				}
			}
		}

		rReq.ResourceVersion = cco.ResourceVersion
		j, err := codec.ToJSON(rReq, codec.ToWithUseProtoFieldName())
		if err != nil {
			return errors.Wrap(err, "RestClient Replace")
		}
		jsn = j
	}

	var namespace, name string
	_ = namespace
	reqMap := make(map[string]interface{})
	if err := json.Unmarshal([]byte(jsn), &reqMap); err != nil {
		return errors.Wrapf(err, "Unmarshaling json to find namespace/name")
	}
	md, ok := reqMap["metadata"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("Request %s does not have 'metadata'", jsn)
	}

	if val, ok := md["namespace"].(string); ok {
		namespace = val
	} else {
		return fmt.Errorf("Request %s does not have 'metadata.namespace'", jsn)
	}

	if val, ok := md["name"].(string); ok {
		name = val
	} else {
		return fmt.Errorf("Request %s does not have 'metadata.name'", jsn)
	}

	url := fmt.Sprintf("%s/public/namespaces/%s/service_policys/%s", c.baseURL, namespace, name)

	hReq, err := http.NewRequest(http.MethodPut, url, bytes.NewBuffer([]byte(jsn)))
	if err != nil {
		return errors.Wrap(err, "RestClient replace")
	}
	hReq = hReq.WithContext(ctx)
	client.AddHdrsToReq(cco.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return err
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return fmt.Errorf("Unsuccessful PUT at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}

	if _, err := io.ReadAll(rsp.Body); err != nil {
		return errors.Wrap(err, "RestClient replace")
	}

	configapi.TranscribeCall(ctx, jsn, nil)
	return nil

}

func (c *crudAPIRestClient) GetRaw(ctx context.Context, key string, opts ...server.CRUDCallOpt) (*GetResponse, error) {
	req, err := NewGetRequest(key, opts...)
	if err != nil {
		return nil, errors.Wrap(err, "Get")
	}

	url := fmt.Sprintf("%s/public/namespaces/%s/service_policys/%s", c.baseURL, req.Namespace, req.Name)
	hReq, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	hReq = hReq.WithContext(ctx)

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	client.AddHdrsToReq(cco.Headers, hReq)

	q := hReq.URL.Query()
	q.Add("response_format", fmt.Sprintf("%d", req.ResponseFormat))
	hReq.URL.RawQuery += q.Encode()

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()
	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return nil, fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return nil, fmt.Errorf("Unsuccessful GET at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}
	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient Get")
	}

	rspo := &GetResponse{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return nil, errors.Wrap(err, "Converting json to response protobuf message")
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rspo.ResourceVersion
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}
	configapi.TranscribeCall(ctx, req, rspo)
	return rspo, nil
}

func (c *crudAPIRestClient) Get(ctx context.Context, key string, opts ...server.CRUDCallOpt) (db.Entry, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	if gRsp != nil {
		obj := NewDBObject(nil)
		gRsp.ToObject(obj)
		return obj, err
	}
	return nil, err

}

func (c *crudAPIRestClient) GetDetail(ctx context.Context, key string, nef db.NewEntryFunc, opts ...server.CRUDCallOpt) (*server.GetResponse, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	respDetail := server.GetResponse{}
	if gRsp != nil {
		respDetail.Entry = NewDBObject(nil)
		gRsp.ToObject(respDetail.Entry)
		for _, status := range gRsp.Status {
			respDetail.BackRefs = append(respDetail.BackRefs, NewDBStatusObject(status))
		}

		return &respDetail, err
	}

	return nil, err

}

func (c *crudAPIRestClient) ListIDs(ctx context.Context, opts ...server.CRUDCallOpt) ([]string, error) {

	idSet := []string{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return idSet, err
	}
	for _, li := range listRsp.GetItems() {
		idSet = append(idSet, li.GetUid())
	}
	return idSet, err

}

func (c *crudAPIRestClient) ListItems(ctx context.Context, opts ...server.CRUDCallOpt) ([]server.ListItem, error) {

	sliSet := []server.ListItem{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return sliSet, err
	}
	for _, li := range listRsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err

}

func (c *crudAPIRestClient) List(ctx context.Context, opts ...server.CRUDCallOpt) (*ListResponse, error) {
	req := NewListRequest(opts...)
	_ = req
	url := fmt.Sprintf("%s/public/namespaces/%s/service_policys", c.baseURL, req.Namespace)

	hReq, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	hReq = hReq.WithContext(ctx)

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	client.AddHdrsToReq(cco.Headers, hReq)

	q := hReq.URL.Query()
	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		q.Add("label_filter", cco.LabelFilter[0])
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}

	for _, fName := range cco.ReportFields {
		q.Add("report_fields", fName)
	}
	for _, fName := range cco.ReportStatusFields {
		q.Add("report_status_fields", fName)
	}

	hReq.URL.RawQuery += q.Encode()
	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()
	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return nil, fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return nil, fmt.Errorf("Unsuccessful List at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}
	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient List")
	}

	rspo := &ListResponse{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return nil, errors.Wrap(err, "Converting json to response protobuf message")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}
	configapi.TranscribeCall(ctx, req, rspo)
	return rspo, nil
}

func (c *crudAPIRestClient) ListStream(ctx context.Context, opts ...server.CRUDCallOpt) (server.ListStreamRsp, error) {
	return nil, fmt.Errorf("Not implemented")
}

func (c *crudAPIRestClient) Delete(ctx context.Context, key string, opts ...server.CRUDCallOpt) error {

	var jsn string
	var dReq *DeleteRequest
	var err error

	dReq, err = NewDeleteRequest(key)
	if err != nil {
		return errors.Wrap(err, "Delete")
	}

	url := fmt.Sprintf("%s/public/namespaces/%s/service_policys/%s", c.baseURL, dReq.Namespace, dReq.Name)
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.FailIfReferredDelete {
		dReq.FailIfReferred = true
	}

	j, err := codec.ToJSON(dReq, codec.ToWithUseProtoFieldName())
	if err != nil {
		return errors.Wrap(err, "RestClient Delete converting protobuf to json")
	}
	jsn = j

	hReq, err := http.NewRequest(http.MethodDelete, url, bytes.NewBuffer([]byte(jsn)))
	if err != nil {
		return errors.Wrap(err, "RestClient delete")
	}
	hReq = hReq.WithContext(ctx)
	client.AddHdrsToReq(cco.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return err
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return fmt.Errorf("Unsuccessful DELETE at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}

	_, err = io.ReadAll(rsp.Body)
	if err != nil {
		return errors.Wrap(err, "RestClient delete")
	}
	configapi.TranscribeCall(ctx, dReq, nil)

	return nil

}

func NewCRUDAPIRestClient(baseURL string, cl http.Client) server.CRUDClient {
	var bURL string
	if strings.HasSuffix(baseURL, "/") {
		bURL = baseURL[:len(baseURL)-1]
	} else {
		bURL = baseURL
	}
	crcl := &crudAPIRestClient{bURL, cl}
	return crcl
}

// INPROC Client (satisfying APIClient interface)
type APIInprocClient struct {
	svc svcfw.Service
}

func (c *APIInprocClient) Create(ctx context.Context, req *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.service_policy")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.service_policy.API.Create")
	rsp, err := oah.Create(ctx, req)
	if err != nil {
		return rsp, err
	}
	return rsp, nil
}

func (c *APIInprocClient) Replace(ctx context.Context, req *ReplaceRequest, opts ...grpc.CallOption) (*ReplaceResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.service_policy")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.service_policy.API.Replace")
	if rsp, err := oah.Replace(ctx, req); err != nil {
		return rsp, err
	}
	return NewObjectReplaceRsp(nil)
}

func (c *APIInprocClient) Get(ctx context.Context, req *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.service_policy")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.service_policy.API.Get")
	rsp, err := oah.Get(ctx, req)
	if err != nil {
		return rsp, err
	}
	return rsp, nil
}

func (c *APIInprocClient) List(ctx context.Context, req *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.service_policy")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.service_policy.API.List")
	rsp, err := oah.List(ctx, req)
	if err != nil {
		return rsp, err
	}
	return rsp, nil
}

func (c *APIInprocClient) Delete(ctx context.Context, req *DeleteRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.service_policy")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.service_policy.API.Delete")
	rsp, err := oah.Delete(ctx, req)
	if err != nil {
		return rsp, err
	}
	return rsp, nil
}

func NewAPIInprocClient(svc svcfw.Service) APIClient {
	return &APIInprocClient{svc: svc}
}

// INPROC CRUD Client (satisfying server.CRUDClient interface)
type crudAPIInprocClient struct {
	cl APIClient
}

func (c *crudAPIInprocClient) Create(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) (db.Entry, error) {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req, err := NewCreateRequest(e)
	if err != nil {
		return nil, errors.Wrap(err, "Creating new create request")
	}
	if cco.ObjToMsgConverter != nil {
		if err := cco.ObjToMsgConverter(e, req); err != nil {
			return nil, err
		}
	}

	rsp, err := c.cl.Create(ctx, req)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	if err != nil {
		return nil, err
	}
	obj := NewDBObject(nil)
	rsp.ToObject(obj)
	if cco.MsgToObjConverter != nil {
		if err := cco.MsgToObjConverter(rsp, obj); err != nil {
			return nil, err
		}
	}
	return obj, nil

}

func (c *crudAPIInprocClient) Replace(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) error {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req, err := NewReplaceRequest(e)
	if err != nil {
		return errors.Wrap(err, "Creating new replace request")
	}
	if cco.ObjToMsgConverter != nil {
		if err := cco.ObjToMsgConverter(e, req); err != nil {
			return err
		}
	}

	req.ResourceVersion = cco.ResourceVersion

	rsp, err := c.cl.Replace(ctx, req)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err

}

func (c *crudAPIInprocClient) GetRaw(ctx context.Context, key string, opts ...server.CRUDCallOpt) (*GetResponse, error) {
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	req, err := NewGetRequest(key, opts...)
	if err != nil {
		return nil, errors.Wrap(err, "Get")
	}
	rsp, err := c.cl.Get(ctx, req)
	if err != nil {
		return nil, err
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rsp.ResourceVersion
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func (c *crudAPIInprocClient) Get(ctx context.Context, key string, opts ...server.CRUDCallOpt) (db.Entry, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	if gRsp != nil {
		obj := NewDBObject(nil)
		gRsp.ToObject(obj)
		return obj, err
	}
	return nil, err

}

func (c *crudAPIInprocClient) GetDetail(ctx context.Context, key string, nef db.NewEntryFunc, opts ...server.CRUDCallOpt) (*server.GetResponse, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	respDetail := server.GetResponse{}
	if gRsp != nil {
		respDetail.Entry = NewDBObject(nil)
		gRsp.ToObject(respDetail.Entry)
		for _, status := range gRsp.Status {
			respDetail.BackRefs = append(respDetail.BackRefs, NewDBStatusObject(status))
		}

		return &respDetail, err
	}

	return nil, err

}

func (c *crudAPIInprocClient) ListIDs(ctx context.Context, opts ...server.CRUDCallOpt) ([]string, error) {

	idSet := []string{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return idSet, err
	}
	for _, li := range listRsp.GetItems() {
		idSet = append(idSet, li.GetUid())
	}
	return idSet, err

}

func (c *crudAPIInprocClient) ListItems(ctx context.Context, opts ...server.CRUDCallOpt) ([]server.ListItem, error) {

	sliSet := []server.ListItem{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return sliSet, err
	}
	for _, li := range listRsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err

}

func (c *crudAPIInprocClient) List(ctx context.Context, opts ...server.CRUDCallOpt) (*ListResponse, error) {
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req := NewListRequest(opts...)
	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		req.LabelFilter = cco.LabelFilter[0]
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}

	rsp, err := c.cl.List(ctx, req)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, err
}

func (c *crudAPIInprocClient) ListStream(ctx context.Context, opts ...server.CRUDCallOpt) (server.ListStreamRsp, error) {
	return nil, fmt.Errorf("Not implemented")
}

func (c *crudAPIInprocClient) Delete(ctx context.Context, key string, opts ...server.CRUDCallOpt) error {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req, err := NewDeleteRequest(key)
	if err != nil {
		return errors.Wrap(err, "Delete")
	}

	rsp, err := c.cl.Delete(ctx, req)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err

}

func newCRUDAPIInprocClient(svc svcfw.Service) *crudAPIInprocClient {
	return &crudAPIInprocClient{cl: NewAPIInprocClient(svc)}
}

func NewCRUDAPIInprocClient(svc svcfw.Service) server.CRUDClient {
	return newCRUDAPIInprocClient(svc)
}

// SERVER side
type APISrv struct {
	oType   string
	tblName string
	sf      svcfw.Service

	opts *server.CrudServerOpts
	// derived from opts
	apiWrapper *server.DBAPIWrapper

	// resource handler function pointers
}

func (s *APISrv) validateTransport(ctx context.Context) error {
	if s.sf.IsTransportNotSupported("ves.io.schema.service_policy.API", server.TransportFromContext(ctx)) {
		userMsg := fmt.Sprintf("ves.io.schema.service_policy.API not allowed in transport '%s'", server.TransportFromContext(ctx))
		err := svcfw.NewPermissionDeniedError(userMsg, fmt.Errorf(userMsg))
		return server.GRPCStatusFromError(err).Err()
	}
	return nil
}

func (s *APISrv) Create(ctx context.Context, req *CreateRequest) (*CreateResponse, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if err := svcfw.FillOneofDefaultChoice(ctx, s.sf, req); err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy.API.Create"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				if !server.NoReqValidateFromContext(ctx) {
					err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
					return nil, server.GRPCStatusFromError(err).Err()
				}
				s.sf.Logger().Warn(server.NoReqValidateAcceptLog, zap.String("rpc_fqn", "ves.io.schema.service_policy.API.Create"), zap.Error(err))
			}
		}
	}
	reqMsgFQN := "ves.io.schema.service_policy.CreateRequest"
	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.sf, reqMsgFQN, req)
	var retErr error
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'ves.io.schema.service_policy.API.Create' operation on 'service_policy'"
		if retErr == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	obj := NewDBObject(nil)
	req.ToObject(obj)
	if conv, exists := s.sf.Config().MsgToObjConverters[reqMsgFQN]; exists {
		if err := conv(req, obj); err != nil {
			retErr = err
			return nil, err
		}
	}
	obj.SystemMetadata = &ves_io_schema.SystemObjectMetaType{}
	rsrcReq := &server.ResourceCreateRequest{Entry: obj}
	rsrcRsp, err := s.opts.RsrcHandler.CreateFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "CreateResource"))
		retErr = err
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rsp, err := NewObjectCreateRsp(rsrcRsp.Entry)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "CreateResponse"))
		retErr = err
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rspMsgFQN := "ves.io.schema.service_policy.CreateResponse"
	if conv, exists := s.sf.Config().ObjToMsgConverters[rspMsgFQN]; exists {
		if err := conv(rsrcRsp.Entry, rsp); err != nil {
			retErr = err
			return nil, err
		}
	}
	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.sf, "ves.io.schema.service_policy.API.CreateResponse", rsp)...)
	return rsp, nil
}

func (s *APISrv) Replace(ctx context.Context, req *ReplaceRequest) (*ReplaceResponse, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if req.Spec == nil {
		err := fmt.Errorf("Nil spec in Replace Request")
		return nil, svcfw.NewInvalidInputError(err.Error(), err)
	}
	if err := svcfw.FillOneofDefaultChoice(ctx, s.sf, req); err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy.API.Replace"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				if !server.NoReqValidateFromContext(ctx) {
					err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
					return nil, server.GRPCStatusFromError(err).Err()
				}
				s.sf.Logger().Warn(server.NoReqValidateAcceptLog, zap.String("rpc_fqn", "ves.io.schema.service_policy.API.Replace"), zap.Error(err))
			}
		}
	}
	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.sf, "ves.io.schema.service_policy.API.ReplaceRequest", req)
	var retErr error
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'ves.io.schema.service_policy.API.Replace' operation on 'service_policy'"
		if retErr == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	rsrcReq := &server.ResourceReplaceRequest{RequestMsg: req}
	rsrcRsp, err := s.opts.RsrcHandler.ReplaceFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "ReplaceResource"))
		retErr = err
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rsp, err := NewObjectReplaceRsp(rsrcRsp.Entry)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "ReplaceResponse"))
		retErr = err
		return nil, server.GRPCStatusFromError(err).Err()
	}
	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.sf, "ves.io.schema.service_policy.API.ReplaceResponse", rsp)...)
	return rsp, nil
}

func (s *APISrv) Get(ctx context.Context, req *GetRequest) (*GetResponse, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy.API.Get"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}
	tenant := server.TenantFromContext(ctx)
	rsrcReq := &server.ResourceGetRequest{IsPublic: true, Tenant: tenant, Namespace: req.GetNamespace(), Name: req.GetName()}
	switch req.ResponseFormat {
	case GET_RSP_FORMAT_FOR_CREATE:
		rsrcReq.RspInCreateForm = true

	case GET_RSP_FORMAT_FOR_REPLACE:
		rsrcReq.RspInReplaceForm = true

	case GET_RSP_FORMAT_READ:
		rsrcReq.RspInReadForm = true

	case GET_RSP_FORMAT_STATUS:
		rsrcReq.RspInStatusForm = true

	case GET_RSP_FORMAT_REFERRING_OBJECTS:
		rsrcReq.RspInReferringObjectsForm = true

	case GET_RSP_FORMAT_BROKEN_REFERENCES:
		rsrcReq.RspInBrokenReferencesForm = true

	}

	rsrcRsp, err := s.opts.RsrcHandler.GetFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "GetResource"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rsp, err := NewObjectGetRsp(ctx, s.sf, req, rsrcRsp)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "GetResponse"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rspMsgFQN := "ves.io.schema.service_policy.GetResponse"
	if conv, exists := s.sf.Config().ObjToMsgConverters[rspMsgFQN]; exists {
		if err := conv(rsrcRsp.Entry, rsp); err != nil {
			return nil, err
		}
	}
	return rsp, nil
}

func (s *APISrv) List(ctx context.Context, req *ListRequest) (*ListResponse, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy.API.List"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}
	var merr *multierror.Error
	rsrcReq := &server.ResourceListRequest{
		Namespace:   req.Namespace,
		LabelFilter: req.LabelFilter,
		RspStreamed: false,
	}
	if len(req.ReportStatusFields) > 0 {
		rsrcReq.ReportStatusFields = &req.ReportStatusFields
	}
	rsrcRsp, err := s.opts.RsrcHandler.ListFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		merr = multierror.Append(merr, errors.Wrap(err, "ListResource"))
	}
	rsp, err := NewListResponse(ctx, req, s.sf, rsrcRsp)
	if err != nil {
		merr = multierror.Append(merr, errors.Wrap(err, "ListResponse allocation failed"))
	}
	if merr != nil {
		if rsp == nil {
			return nil, merr
		}
		rsp.Errors = append(rsp.Errors, &ves_io_schema.ErrorType{
			Code:    ves_io_schema.EINTERNAL,
			Message: merr.Error(),
		})

	}
	return rsp, nil
}

func (s *APISrv) Delete(ctx context.Context, req *DeleteRequest) (*google_protobuf.Empty, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy.API.Delete"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				if !server.NoReqValidateFromContext(ctx) {
					err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
					return nil, server.GRPCStatusFromError(err).Err()
				}
				s.sf.Logger().Warn(server.NoReqValidateAcceptLog, zap.String("rpc_fqn", "ves.io.schema.service_policy.API.Delete"), zap.Error(err))
			}
		}
	}
	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.sf, "ves.io.schema.service_policy.API.DeleteRequest", req)
	var retErr error
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'ves.io.schema.service_policy.API.Delete' operation on 'service_policy'"
		if retErr == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	tenant := server.TenantFromContext(ctx)
	key := fmt.Sprintf("%s/%s/%s", tenant, req.GetNamespace(), req.GetName())
	rsrcReq := &server.ResourceDeleteRequest{Key: key}
	rsrcReq.FailIfReferred = req.FailIfReferred
	_, err := s.opts.RsrcHandler.DeleteFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "DeleteResource"))
		retErr = err
		return nil, server.GRPCStatusFromError(err).Err()
	}
	return &google_protobuf.Empty{}, nil
}

// Assert that APISrv implements the generated gRPC APIServer interface
var _ APIServer = &APISrv{}

func NewCRUDAPIServer(oType string, tblName string, sf svcfw.Service, opts ...server.CRUDServerOpt) (server.APIHandler, string) {
	// convert ves.io.examplesvc.objectone.Object to
	//         ves.io.examplesvc.objectone.API
	sl := strings.Split(oType, ".")
	csOpts := server.NewCRUDServerOpts()
	for _, o := range opts {
		o(csOpts)
	}
	wrapper := server.NewDBAPIWrapper(csOpts.APIWrapperOpts...)
	s := &APISrv{
		oType:      oType,
		tblName:    tblName,
		sf:         sf,
		opts:       csOpts,
		apiWrapper: wrapper,
	}
	return s, fmt.Sprintf("%s.API", strings.Join(sl[:len(sl)-1], "."))
}

func (r *Object) Key() string {
	m := r.GetMetadata()
	if m == nil {
		return ""
	}
	return strings.Join([]string{m.Namespace, m.Name}, "/")
}

func (r *Object) Uid() string {
	return r.SystemMetadata.Uid
}

func (r *ListResponse) GetKeys() []string {
	var ret []string
	for _, i := range r.Items {
		ret = append(ret, i.Namespace+"/"+i.Name)
	}
	return ret
}

// Implement server.SROListItem interface on ListResponseItem
func (l *ListResponseItem) GetObjUid() string {
	return l.Uid
}

func (l *ListResponseItem) GetObjTenant() string {
	return l.Tenant
}

func (l *ListResponseItem) GetObjNamespace() string {
	return l.Namespace
}

func (l *ListResponseItem) GetObjName() string {
	return l.Name
}

func (l *ListResponseItem) GetObjLabels() map[string]string {
	return l.Labels
}

func NewObjectCreateRsp(e db.Entry) (*CreateResponse, error) {
	switch e.(type) {
	case nil:
		return nil, nil
	case *DBObject:
		rsp := &CreateResponse{}
		rsp.FromObject(e)
		return rsp, nil
	}
	return nil, fmt.Errorf("Entry not of type *DBObject in NewObjectCreateRsp")
}

func NewObjectReplaceRsp(e db.Entry) (*ReplaceResponse, error) {
	return &ReplaceResponse{}, nil
}

func NewObjectGetRsp(ctx context.Context, sf svcfw.Service, req *GetRequest, rsrcRsp *server.ResourceGetResponse) (*GetResponse, error) {
	rsp := &GetResponse{}
	e := rsrcRsp.Entry
	if e == nil {
		return rsp, nil
	}
	o, ok := e.(*DBObject)
	if !ok {
		return nil, fmt.Errorf("entry not of type *DBObject in NewObjectGetRsp")
	}

	rsp.ResourceVersion = rsrcRsp.ResourceVersion
	var merr *multierror.Error
	buildReadForm := func() {
		rsp.Metadata = &ves_io_schema.ObjectGetMetaType{}
		rsp.Metadata.FromObjectMetaType(o.Metadata)
		rsp.SystemMetadata = &ves_io_schema.SystemObjectGetMetaType{}
		rsp.SystemMetadata.FromSystemObjectMetaType(o.SystemMetadata)
		rsp.Spec = &GetSpecType{}
		if redactor, ok := e.(db.Redactor); ok {
			if err := redactor.Redact(ctx); err != nil {
				merr = multierror.Append(merr, errors.WithMessage(err, "Error while redacting entry"))
				return
			}
		}
		rsp.Spec.FromGlobalSpecType(o.Spec.GcSpec)

	}
	_ = buildReadForm
	buildStatusForm := func() {
		for _, statusEnt := range rsrcRsp.BackRefs {
			statusObj, ok := statusEnt.ToStore().(*StatusObject)
			if !ok {
				merr = multierror.Append(merr, fmt.Errorf("%T is not *StatusObject", statusEnt))
				continue
			}
			rsp.Status = append(rsp.Status, statusObj)
		}

	}
	_ = buildStatusForm
	buildReferringObjectsForm := func() {
		for _, br := range rsrcRsp.ReferringObjects {
			rsp.ReferringObjects = append(rsp.ReferringObjects, &ves_io_schema.ObjectRefType{
				Kind:      db.KindForEntryType(br.Type),
				Uid:       br.UID,
				Tenant:    br.Tenant,
				Namespace: br.Namespace,
				Name:      br.Name,
			})
		}

	}
	_ = buildReferringObjectsForm
	buildBrokenReferencesForm := func() {
		for _, br := range rsrcRsp.DeletedReferredObjects {
			rsp.DeletedReferredObjects = append(rsp.DeletedReferredObjects, &ves_io_schema.ObjectRefType{
				Kind:      db.KindForEntryType(br.Type),
				Uid:       br.UID,
				Tenant:    br.Tenant,
				Namespace: br.Namespace,
				Name:      br.Name,
			})
		}
		for _, br := range rsrcRsp.DisabledReferredObjects {
			rsp.DisabledReferredObjects = append(rsp.DisabledReferredObjects, &ves_io_schema.ObjectRefType{
				Kind:      db.KindForEntryType(br.Type),
				Uid:       br.UID,
				Tenant:    br.Tenant,
				Namespace: br.Namespace,
				Name:      br.Name,
			})
		}

	}
	_ = buildBrokenReferencesForm

	switch req.ResponseFormat {

	case GET_RSP_FORMAT_FOR_CREATE:
		createReq, err := NewCreateRequest(e)
		if err != nil {
			return nil, errors.Wrap(err, "Building CreateRequest from entry")
		}
		// Name has to be specified for a new create
		createReq.Metadata.Name = ""
		rsp.CreateForm = createReq

	case GET_RSP_FORMAT_FOR_REPLACE:
		replaceReq, err := NewReplaceRequest(e)
		if err != nil {
			return nil, errors.Wrap(err, "Building ReplaceRequest from entry")
		}
		rsp.ReplaceForm = replaceReq

	case GET_RSP_FORMAT_STATUS:
		buildStatusForm()

	case GET_RSP_FORMAT_READ:
		buildReadForm()

	case GET_RSP_FORMAT_REFERRING_OBJECTS:
		buildReferringObjectsForm()

	case GET_RSP_FORMAT_BROKEN_REFERENCES:
		buildBrokenReferencesForm()

	default:
		buildReadForm()

		buildStatusForm()
	}

	return rsp, errors.ErrOrNil(merr)
}

func NewListResponse(ctx context.Context, req *ListRequest, sf svcfw.Service, rsrcRsp *server.ResourceListResponse) (*ListResponse, error) {
	if req == nil {
		return nil, fmt.Errorf("Nil ListRequest")
	}
	if rsrcRsp == nil {
		return nil, fmt.Errorf("Nil ResourceResponse")
	}

	errStrs := []string{}
	resp := &ListResponse{}
	resp.Items = []*ListResponseItem{}

	for _, rsrcItem := range rsrcRsp.Items {
		if rsrcItem == nil {
			errStrs = append(errStrs, fmt.Sprintf("Nil ResourceListResponseItem"))
			continue
		}

		e := rsrcItem.Entry
		o, ok := e.(*DBObject)
		if !ok {
			resp.Errors = append(resp.Errors, &ves_io_schema.ErrorType{
				Code:    ves_io_schema.EINTERNAL,
				Message: fmt.Sprintf("Entry %T not of type *DBObject in NewListResponse", e),
			})

			continue
		}
		if redactor, ok := e.(db.Redactor); ok {
			if err := redactor.Redact(ctx); err != nil {
				resp.Errors = append(resp.Errors, &ves_io_schema.ErrorType{
					Code:    ves_io_schema.EINTERNAL,
					Message: fmt.Sprintf("Error while redacting in NewListResponse: %s", err),
				})
				continue
			}
		}
		item := &ListResponseItem{
			Tenant:    o.GetSystemMetadata().GetTenant(),
			Namespace: o.GetMetadata().GetNamespace(),
			Name:      o.GetMetadata().GetName(),
			Uid:       o.GetMetadata().GetUid(),
			OwnerView: o.GetSystemMetadata().GetOwnerView(),
			Labels:    o.GetMetadata().GetLabels(),
		}

		item.Description = o.GetMetadata().GetDescription()
		item.Annotations = o.GetMetadata().GetAnnotations()
		item.Disabled = o.GetMetadata().GetDisable()

		if len(req.ReportFields) > 0 {
			item.Metadata = &ves_io_schema.ObjectGetMetaType{}
			item.Metadata.FromObjectMetaType(o.Metadata)
			item.SystemMetadata = &ves_io_schema.SystemObjectGetMetaType{}
			item.SystemMetadata.FromSystemObjectMetaType(o.SystemMetadata)

			if o.Object.GetSpec().GetGcSpec() != nil {
				msgFQN := "ves.io.schema.service_policy.GetResponse"
				if conv, exists := sf.Config().ObjToMsgConverters[msgFQN]; exists {
					getSpec := &GetSpecType{}
					getSpec.FromGlobalSpecType(o.Spec.GcSpec)
					getRsp := &GetResponse{Spec: getSpec}
					if err := conv(o, getRsp); err != nil {
						resp.Errors = append(resp.Errors, &ves_io_schema.ErrorType{
							Code:    ves_io_schema.EINTERNAL,
							Message: fmt.Sprintf("Converting entry to getResponse: %s", err),
						})

						continue
					}
					item.GetSpec = getRsp.Spec
				} else {
					item.GetSpec = &GetSpecType{}
					item.GetSpec.FromGlobalSpecType(o.Spec.GcSpec)
				}
			}

		}

		if len(req.ReportStatusFields) > 0 {
			for _, sroStatus := range rsrcItem.StatusSet {
				statusDBO, ok := sroStatus.(*DBStatusObject)
				if !ok {
					resp.Errors = append(resp.Errors, &ves_io_schema.ErrorType{
						Code:    ves_io_schema.EINTERNAL,
						Message: fmt.Sprintf("sro.Status %T is not of type *DBStatusObject in NewListResponse", sroStatus),
					})

					continue
				}
				item.StatusSet = append(item.StatusSet, statusDBO.StatusObject)
			}
		}

		resp.Items = append(resp.Items, item)
	}
	return resp, nil
}

func RegisterGwAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterAPIHandlerClient(ctx, mux, NewAPIInprocClient(s))
}

var APISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "service policy object",
        "description": "A service_policy object consists of an unordered list of predicates and a list of service policy rules. The predicates are evaluated against a set of input\nfields that are extracted from or derived from an L7 request API. Any predicates that are not specified in a policy are implicitly considered to be true. The\nrules in the policy are also evaluated against the input fields. They are treated as an ordered or unordered list depending on the value of the rule combining\nalgorithm. A request API is considered to match a policy if all predicates in the policy evaluate to true and the request API matches one of the rules in the\npolicy.\n\nIf the configured rule combining algorithm is FIRST_MATCH, the rules in the policy are evaluated sequentially till a matching rule is identified. If the rule\ncombining algorithm is ALLOW_OVERRIDES all rules with an ALLOW action are evaluated prior to rules with a DENY action. If it is DENY_OVERRIDES, all rules with\na DENY action are evaluated prior to rules with a ALLOW action.\n\nA service policy is part of an ordered list of policies in one or more service policy sets. If a request API matches a policy, the resulting action for the\npolicy is the action configured in the matching rule. If a request API does not match a given policy, the next policy in the service policy set is evaluated.",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{metadata.namespace}/service_policys": {
            "post": {
                "summary": "Create Service Policy",
                "description": "Create service_policy creates a new object in the storage backend for metadata.namespace.",
                "operationId": "ves.io.schema.service_policy.API.Create",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/service_policyCreateResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "metadata.namespace",
                        "description": "namespace\n\nx-example: \"staging\"\nThis defines the workspace within which each the configuration object is to be created.\nMust be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service_policyCreateRequest"
                        }
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-service_policy-api-create"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy.API.Create"
            },
            "x-displayname": "Service Policy",
            "x-ves-proto-service": "ves.io.schema.service_policy.API",
            "x-ves-proto-service-type": "AUTO_CRUD_PUBLIC"
        },
        "/public/namespaces/{metadata.namespace}/service_policys/{metadata.name}": {
            "put": {
                "summary": "Replace Service Policy",
                "description": "Replace service_policy replaces an existing object in the storage backend for metadata.namespace.",
                "operationId": "ves.io.schema.service_policy.API.Replace",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/service_policyReplaceResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "metadata.namespace",
                        "description": "namespace\n\nx-example: \"staging\"\nThis defines the workspace within which each the configuration object is to be created.\nMust be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "metadata.name",
                        "description": "name\n\nx-example: \"acmecorp-web\"\nThe configuration object to be replaced will be looked up by name",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service_policyReplaceRequest"
                        }
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-service_policy-api-replace"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy.API.Replace"
            },
            "x-displayname": "Service Policy",
            "x-ves-proto-service": "ves.io.schema.service_policy.API",
            "x-ves-proto-service-type": "AUTO_CRUD_PUBLIC"
        },
        "/public/namespaces/{namespace}/service_policys": {
            "get": {
                "summary": "List Service Policy",
                "description": "List the set of service_policy in a namespace",
                "operationId": "ves.io.schema.service_policy.API.List",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/service_policyListResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"ns1\"\nNamespace to scope the listing of service_policy",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "label_filter",
                        "description": "x-example: \"env in (staging, testing), tier in (web, db)\"\nA LabelSelectorType expression that every item in list response will satisfy",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Label Filter"
                    },
                    {
                        "name": "report_fields",
                        "description": "x-example: \"\"\nExtra fields to return along with summary fields",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Report Fields"
                    },
                    {
                        "name": "report_status_fields",
                        "description": "x-example: \"\"\nExtra status fields to return along with summary fields",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Report Status Fields"
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-service_policy-api-list"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy.API.List"
            },
            "x-displayname": "Service Policy",
            "x-ves-proto-service": "ves.io.schema.service_policy.API",
            "x-ves-proto-service-type": "AUTO_CRUD_PUBLIC"
        },
        "/public/namespaces/{namespace}/service_policys/{name}": {
            "get": {
                "summary": "Get Service Policy",
                "description": "Get service_policy reads a given object from storage backend for metadata.namespace.",
                "operationId": "ves.io.schema.service_policy.API.Get",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/service_policyGetResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"ns1\"\nThe namespace in which the configuration object is present",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "name\n\nx-example: \"name\"\nThe name of the configuration object to be fetched",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    },
                    {
                        "name": "response_format",
                        "description": "The format in which the configuration object is to be fetched. This could be for example\n    - in GetSpec form for the contents of object\n    - in CreateRequest form to create a new similar object\n    - to ReplaceRequest form to replace changeable values\n\nDefault format of returned resource\nResponse should be in CreateRequest format\nResponse should be in ReplaceRequest format\nResponse should be in StatusObject(s) format\nResponse should be in format of GetSpecType\nResponse should have other objects referring to this object\nResponse should have deleted and disabled objects referrred by this object",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "enum": [
                            "GET_RSP_FORMAT_DEFAULT",
                            "GET_RSP_FORMAT_FOR_CREATE",
                            "GET_RSP_FORMAT_FOR_REPLACE",
                            "GET_RSP_FORMAT_STATUS",
                            "GET_RSP_FORMAT_READ",
                            "GET_RSP_FORMAT_REFERRING_OBJECTS",
                            "GET_RSP_FORMAT_BROKEN_REFERENCES"
                        ],
                        "default": "GET_RSP_FORMAT_DEFAULT",
                        "x-displayname": "Broken Referred Objects"
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-service_policy-api-get"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy.API.Get"
            },
            "delete": {
                "summary": "Delete Service Policy",
                "description": "Delete the specified service_policy",
                "operationId": "ves.io.schema.service_policy.API.Delete",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {}
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"ns1\"\nNamespace in which the configuration object is present",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "name\n\nx-example: \"name\"\nName of the configuration object",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/service_policyDeleteRequest"
                        }
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-service_policy-api-delete"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy.API.Delete"
            },
            "x-displayname": "Service Policy",
            "x-ves-proto-service": "ves.io.schema.service_policy.API",
            "x-ves-proto-service-type": "AUTO_CRUD_PUBLIC"
        }
    },
    "definitions": {
        "app_firewallAppFirewallViolationType": {
            "type": "string",
            "description": "List of all supported Violation Types\n\nVIOL_NONE\nVIOL_FILETYPE\nVIOL_METHOD\nVIOL_MANDATORY_HEADER\nVIOL_HTTP_RESPONSE_STATUS\nVIOL_REQUEST_MAX_LENGTH\nVIOL_FILE_UPLOAD\nVIOL_FILE_UPLOAD_IN_BODY\nVIOL_XML_MALFORMED\nVIOL_JSON_MALFORMED\nVIOL_ASM_COOKIE_MODIFIED\nVIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS\nVIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE\nVIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT\nVIOL_HTTP_PROTOCOL_NULL_IN_REQUEST\nVIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION\nVIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START\nVIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST\nVIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING\nVIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS\nVIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER\nVIOL_EVASION_DIRECTORY_TRAVERSALS\nVIOL_MALFORMED_REQUEST\nVIOL_EVASION_MULTIPLE_DECODING\nVIOL_DATA_GUARD\nVIOL_EVASION_APACHE_WHITESPACE\nVIOL_COOKIE_MODIFIED\nVIOL_EVASION_IIS_UNICODE_CODEPOINTS\nVIOL_EVASION_IIS_BACKSLASHES\nVIOL_EVASION_PERCENT_U_DECODING\nVIOL_EVASION_BARE_BYTE_DECODING\nVIOL_EVASION_BAD_UNESCAPE\nVIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORMDATA_REQUEST_PARSING\nVIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST\nVIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS\nVIOL_ENCODING\nVIOL_COOKIE_MALFORMED\nVIOL_GRAPHQL_FORMAT\nVIOL_GRAPHQL_MALFORMED\nVIOL_GRAPHQL_INTROSPECTION_QUERY",
            "title": "App Firewall Violation Type",
            "enum": [
                "VIOL_NONE",
                "VIOL_FILETYPE",
                "VIOL_METHOD",
                "VIOL_MANDATORY_HEADER",
                "VIOL_HTTP_RESPONSE_STATUS",
                "VIOL_REQUEST_MAX_LENGTH",
                "VIOL_FILE_UPLOAD",
                "VIOL_FILE_UPLOAD_IN_BODY",
                "VIOL_XML_MALFORMED",
                "VIOL_JSON_MALFORMED",
                "VIOL_ASM_COOKIE_MODIFIED",
                "VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS",
                "VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE",
                "VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT",
                "VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST",
                "VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION",
                "VIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START",
                "VIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST",
                "VIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING",
                "VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS",
                "VIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER",
                "VIOL_EVASION_DIRECTORY_TRAVERSALS",
                "VIOL_MALFORMED_REQUEST",
                "VIOL_EVASION_MULTIPLE_DECODING",
                "VIOL_DATA_GUARD",
                "VIOL_EVASION_APACHE_WHITESPACE",
                "VIOL_COOKIE_MODIFIED",
                "VIOL_EVASION_IIS_UNICODE_CODEPOINTS",
                "VIOL_EVASION_IIS_BACKSLASHES",
                "VIOL_EVASION_PERCENT_U_DECODING",
                "VIOL_EVASION_BARE_BYTE_DECODING",
                "VIOL_EVASION_BAD_UNESCAPE",
                "VIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORMDATA_REQUEST_PARSING",
                "VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST",
                "VIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS",
                "VIOL_ENCODING",
                "VIOL_COOKIE_MALFORMED",
                "VIOL_GRAPHQL_FORMAT",
                "VIOL_GRAPHQL_MALFORMED",
                "VIOL_GRAPHQL_INTROSPECTION_QUERY"
            ],
            "default": "VIOL_NONE",
            "x-displayname": "App Firewall Violation Type",
            "x-ves-proto-enum": "ves.io.schema.app_firewall.AppFirewallViolationType"
        },
        "app_firewallAttackType": {
            "type": "string",
            "description": "List of all Attack Types\n\nATTACK_TYPE_NONE\nATTACK_TYPE_NON_BROWSER_CLIENT\nATTACK_TYPE_OTHER_APPLICATION_ATTACKS\nATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE\nATTACK_TYPE_DETECTION_EVASION\nATTACK_TYPE_VULNERABILITY_SCAN\nATTACK_TYPE_ABUSE_OF_FUNCTIONALITY\nATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS\nATTACK_TYPE_BUFFER_OVERFLOW\nATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION\nATTACK_TYPE_INFORMATION_LEAKAGE\nATTACK_TYPE_DIRECTORY_INDEXING\nATTACK_TYPE_PATH_TRAVERSAL\nATTACK_TYPE_XPATH_INJECTION\nATTACK_TYPE_LDAP_INJECTION\nATTACK_TYPE_SERVER_SIDE_CODE_INJECTION\nATTACK_TYPE_COMMAND_EXECUTION\nATTACK_TYPE_SQL_INJECTION\nATTACK_TYPE_CROSS_SITE_SCRIPTING\nATTACK_TYPE_DENIAL_OF_SERVICE\nATTACK_TYPE_HTTP_PARSER_ATTACK\nATTACK_TYPE_SESSION_HIJACKING\nATTACK_TYPE_HTTP_RESPONSE_SPLITTING\nATTACK_TYPE_FORCEFUL_BROWSING\nATTACK_TYPE_REMOTE_FILE_INCLUDE\nATTACK_TYPE_MALICIOUS_FILE_UPLOAD\nATTACK_TYPE_GRAPHQL_PARSER_ATTACK",
            "title": "AttackType",
            "enum": [
                "ATTACK_TYPE_NONE",
                "ATTACK_TYPE_NON_BROWSER_CLIENT",
                "ATTACK_TYPE_OTHER_APPLICATION_ATTACKS",
                "ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE",
                "ATTACK_TYPE_DETECTION_EVASION",
                "ATTACK_TYPE_VULNERABILITY_SCAN",
                "ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY",
                "ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS",
                "ATTACK_TYPE_BUFFER_OVERFLOW",
                "ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION",
                "ATTACK_TYPE_INFORMATION_LEAKAGE",
                "ATTACK_TYPE_DIRECTORY_INDEXING",
                "ATTACK_TYPE_PATH_TRAVERSAL",
                "ATTACK_TYPE_XPATH_INJECTION",
                "ATTACK_TYPE_LDAP_INJECTION",
                "ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION",
                "ATTACK_TYPE_COMMAND_EXECUTION",
                "ATTACK_TYPE_SQL_INJECTION",
                "ATTACK_TYPE_CROSS_SITE_SCRIPTING",
                "ATTACK_TYPE_DENIAL_OF_SERVICE",
                "ATTACK_TYPE_HTTP_PARSER_ATTACK",
                "ATTACK_TYPE_SESSION_HIJACKING",
                "ATTACK_TYPE_HTTP_RESPONSE_SPLITTING",
                "ATTACK_TYPE_FORCEFUL_BROWSING",
                "ATTACK_TYPE_REMOTE_FILE_INCLUDE",
                "ATTACK_TYPE_MALICIOUS_FILE_UPLOAD",
                "ATTACK_TYPE_GRAPHQL_PARSER_ATTACK"
            ],
            "default": "ATTACK_TYPE_NONE",
            "x-displayname": "Attack Types",
            "x-ves-proto-enum": "ves.io.schema.app_firewall.AttackType"
        },
        "ioschemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "ioschemaObjectRefType": {
            "type": "object",
            "description": "This type establishes a 'direct reference' from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name for public API and Uid for private API\nThis type of reference is called direct because the relation is explicit and concrete (as opposed\nto selector reference which builds a group based on labels of selectee objects)",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.ObjectRefType",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then kind will hold the referred object's kind (e.g. \"route\")\n\nExample: - \"virtual_site\"-",
                    "title": "kind",
                    "x-displayname": "Kind",
                    "x-ves-example": "virtual_site"
                },
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contactus-route\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contactus-route"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then uid will hold the referred object's(e.g. route's) uid.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "policyAppFirewallAttackTypeContext": {
            "type": "object",
            "description": "App Firewall Attack Type context changes to be applied for this request",
            "title": "App Firewall Attack Type Context",
            "x-displayname": "App Firewall Attack Type Context",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallAttackTypeContext",
            "properties": {
                "context": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Context",
                    "$ref": "#/definitions/policyDetectionContext",
                    "x-displayname": "Context",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "context_name": {
                    "type": "string",
                    "description": " Relevant only for contexts: Header, Cookie and Parameter.\n Name of the Context that the WAF Exclusion Rules will check.\n Wildcard matching can be used by prefixing or suffixing the context name\n with an wildcard asterisk (*).\n\nExample: - \"exampleuser-agent for Header\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Context Name",
                    "maxLength": 128,
                    "x-displayname": "Context Name",
                    "x-ves-example": "example: user-agent for Header",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "exclude_attack_type": {
                    "description": "\nExample: - \"ATTACK_TYPE_SQL_INJECTION\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "AttackType",
                    "$ref": "#/definitions/app_firewallAttackType",
                    "x-displayname": "Attack Type",
                    "x-ves-example": "ATTACK_TYPE_SQL_INJECTION",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "policyAppFirewallDetectionControl": {
            "type": "object",
            "description": "Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.",
            "title": "App Firewall Detection Control",
            "x-displayname": "App Firewall Detection Control",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallDetectionControl",
            "properties": {
                "exclude_attack_type_contexts": {
                    "type": "array",
                    "description": " Attack Types to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Attack Types Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallAttackTypeContext"
                    },
                    "x-displayname": "Attack Types",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_bot_name_contexts": {
                    "type": "array",
                    "description": " Bot Names to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Bot Names Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyBotNameContext"
                    },
                    "x-displayname": "Bot Names",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_signature_contexts": {
                    "type": "array",
                    "description": " Signature IDs to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 1024\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Signature Contexts",
                    "maxItems": 1024,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallSignatureContext"
                    },
                    "x-displayname": "Signature IDs",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "1024",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_violation_contexts": {
                    "type": "array",
                    "description": " Violations to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Violation Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallViolationContext"
                    },
                    "x-displayname": "Violations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyAppFirewallSignatureContext": {
            "type": "object",
            "description": "App Firewall signature context changes to be applied for this request",
            "title": "App Firewall Signature Context",
            "x-displayname": "App Firewall Signature Context",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallSignatureContext",
            "properties": {
                "context": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Context",
                    "$ref": "#/definitions/policyDetectionContext",
                    "x-displayname": "Context",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "context_name": {
                    "type": "string",
                    "description": " Relevant only for contexts: Header, Cookie and Parameter.\n Name of the Context that the WAF Exclusion Rules will check.\n Wildcard matching can be used by prefixing or suffixing the context name\n with an wildcard asterisk (*).\n\nExample: - \"exampleuser-agent for Header\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Context Name",
                    "maxLength": 128,
                    "x-displayname": "Context Name",
                    "x-ves-example": "example: user-agent for Header",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "signature_id": {
                    "type": "integer",
                    "description": " The allowed values for signature id are 0 and in the range of 200000001-299999999.\n 0 implies that all signatures will be excluded for the specified context.\n\nExample: - \"10000001\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 299999999\n",
                    "title": "SignatureID",
                    "format": "int64",
                    "x-displayname": "SignatureID",
                    "x-ves-example": "10000001",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "299999999"
                    }
                }
            }
        },
        "policyAppFirewallViolationContext": {
            "type": "object",
            "description": "App Firewall violation context changes to be applied for this request",
            "title": "App Firewall Violation Context",
            "x-displayname": "App Firewall Violation Context",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallViolationContext",
            "properties": {
                "context": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Context",
                    "$ref": "#/definitions/policyDetectionContext",
                    "x-displayname": "Context",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "context_name": {
                    "type": "string",
                    "description": " Relevant only for contexts: Header, Cookie and Parameter.\n Name of the Context that the WAF Exclusion Rules will check.\n Wildcard matching can be used by prefixing or suffixing the context name\n with an wildcard asterisk (*).\n\nExample: - \"exampleuser-agent for Header\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Context Name",
                    "maxLength": 128,
                    "x-displayname": "Context Name",
                    "x-ves-example": "example: user-agent for Header",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "exclude_violation": {
                    "description": "\nExample: - \"VIOL_MANDATORY_HEADER\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "ViolationType",
                    "$ref": "#/definitions/app_firewallAppFirewallViolationType",
                    "x-displayname": "Violation Type",
                    "x-ves-example": "VIOL_MANDATORY_HEADER",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "policyAppTrafficType": {
            "type": "string",
            "description": "x-displayName: \"App Traffic type\"\nApplication traffic type\n\n - WEB: WebTrafficType\n\nx-displayName: \"Web Traffic\"\nWeb application traffic type.\n - MOBILE: MobileTrafficType\n\nx-displayName: \"Mobile Traffic\"\nMobile application traffic type.",
            "title": "AppTrafficType",
            "enum": [
                "WEB",
                "MOBILE"
            ],
            "default": "WEB"
        },
        "policyArgMatcherType": {
            "type": "object",
            "description": "A argument matcher specifies the name of a single argument in the body and the criteria to match it.\nA argument matcher can check for one of the following:\n* Presence or absence of the argument\n* At least one of the values for the argument in the request satisfies the MatcherType item",
            "title": "ArgMatcherType",
            "x-displayname": "Argument Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.ArgMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the argument is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the argument is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert Match of the expression defined",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the Arg. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " x-example: \"phones[_]\"\n x-example: \"cars.make.toyota.models[1]\"\n x-example: \"cars.make.honda.models[_]\"\n x-example: \"cars.make[_].models[_]\"\n A case-sensitive JSON path in the HTTP request body.\n\nExample: - \"name\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.json_path: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Argument Name",
                    "x-ves-example": "name",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.json_path": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyAsnMatchList": {
            "type": "object",
            "description": "An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
            "title": "Asn Match List",
            "x-displayname": "ASN Match List",
            "x-ves-proto-message": "ves.io.schema.policy.AsnMatchList",
            "properties": {
                "as_numbers": {
                    "type": "array",
                    "description": " An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.\n\nExample: - \"[713, 7932, 847325, 4683, 15269, 1000001]\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "as numbers",
                    "minItems": 1,
                    "maxItems": 16,
                    "items": {
                        "type": "integer",
                        "format": "int64"
                    },
                    "x-displayname": "AS Numbers",
                    "x-ves-example": "[713, 7932, 847325, 4683, 15269, 1000001]",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyAsnMatcherType": {
            "type": "object",
            "description": "Match any AS number contained in the list of bgp_asn_sets.",
            "title": "asn matcher type",
            "x-displayname": "ASN Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.AsnMatcherType",
            "properties": {
                "asn_sets": {
                    "type": "array",
                    "description": " A list of references to bgp_asn_set objects.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 4\n",
                    "title": "asn_sets",
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "BGP ASN Sets",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "4"
                    }
                }
            }
        },
        "policyBotNameContext": {
            "type": "object",
            "description": "Specifies bot to be excluded by its name.",
            "title": "Bot Name Context",
            "x-displayname": "Bot Name",
            "x-ves-proto-message": "ves.io.schema.policy.BotNameContext",
            "properties": {
                "bot_name": {
                    "type": "string",
                    "description": "\nExample: - \"Hydra\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "BotName",
                    "x-displayname": "Bot Name",
                    "x-ves-example": "Hydra",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "policyChallengeAction": {
            "type": "string",
            "description": "x-displayName: \"Challenge Action\"\nThe challenge options to use when a policy based challenge is configured.\n\n - DEFAULT_CHALLENGE: DEFAULT_CHALLENGE\n\nx-displayName: \"Default Challenge\"\nDefault challenge.\n - ENABLE_JAVASCRIPT_CHALLENGE: ENABLE_JAVASCRIPT_CHALLENGE\n\nx-displayName: \"Enable Javascript Challenge\"\nEnable javascript challenge.\n - ENABLE_CAPTCHA_CHALLENGE: ENABLE_CAPTCHA_CHALLENGE\n\nx-displayName: \"Enable Captcha Challenge\"\nCaptcha challenge.\n - DISABLE_CHALLENGE: DISABLE_CHALLENGE\n\nx-displayName: \"Disable Challenge\"\nDisable challenge\n - TEMPORARY_BLOCKING: TEMPORARY_BLOCKING\n\nx-displayName: \"Block Temporarily\"\nBlock the user temporarily.",
            "title": "Challenge Action",
            "enum": [
                "DEFAULT_CHALLENGE",
                "ENABLE_JAVASCRIPT_CHALLENGE",
                "ENABLE_CAPTCHA_CHALLENGE",
                "DISABLE_CHALLENGE",
                "TEMPORARY_BLOCKING"
            ],
            "default": "DEFAULT_CHALLENGE"
        },
        "policyContentRewriteAction": {
            "type": "object",
            "description": "x-displayName: \"Content Rewrite Action\"\nRewrite HTML response action to insert HTML content such as Javascript \u003cscript\u003e tags into the HTML document",
            "title": "ContentRewriteAction",
            "properties": {
                "element_selector": {
                    "type": "string",
                    "description": "x-displayName: \"Element selector to rewrite\"\nx-example: \"value\"\nx-required\nElement selector to insert into.",
                    "title": "Element selector"
                },
                "insert_content": {
                    "type": "string",
                    "description": "x-displayName: \"HTML Content to insert\"\nx-example: \"value\"\nHTML content to insert.",
                    "title": "Insert Content"
                },
                "inserted_types": {
                    "type": "object",
                    "description": "x-displayName: \"Inserted types\"\nInserted types of security configuration like Bot Defense, Client Side Defense.",
                    "title": "Inserted types"
                },
                "position": {
                    "description": "x-displayName: \"HTML position\"\nPosition of HTML content to be inserted within HTML tag.",
                    "title": "Position",
                    "$ref": "#/definitions/policyHTMLPosition"
                }
            }
        },
        "policyCookieMatcherType": {
            "type": "object",
            "description": "A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each\ncookie in the request.\nA cookie matcher can check for one of the following:\n* Presence or absence of the cookie\n* At least one of the values for the cookie in the request satisfies the MatcherType item",
            "title": "CookieMatcherType",
            "x-displayname": "Cookie Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.CookieMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the cookie is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the cookie is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert Match of the expression defined",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the cookie. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " A case-sensitive cookie name.\n\nExample: - \"Session\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Cookie Name",
                    "x-ves-example": "Session",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyCountryCode": {
            "type": "string",
            "description": "ISO 3166 Aplpha-2 country codes\n",
            "title": "CountryCode",
            "enum": [
                "COUNTRY_NONE",
                "COUNTRY_AD",
                "COUNTRY_AE",
                "COUNTRY_AF",
                "COUNTRY_AG",
                "COUNTRY_AI",
                "COUNTRY_AL",
                "COUNTRY_AM",
                "COUNTRY_AN",
                "COUNTRY_AO",
                "COUNTRY_AQ",
                "COUNTRY_AR",
                "COUNTRY_AS",
                "COUNTRY_AT",
                "COUNTRY_AU",
                "COUNTRY_AW",
                "COUNTRY_AX",
                "COUNTRY_AZ",
                "COUNTRY_BA",
                "COUNTRY_BB",
                "COUNTRY_BD",
                "COUNTRY_BE",
                "COUNTRY_BF",
                "COUNTRY_BG",
                "COUNTRY_BH",
                "COUNTRY_BI",
                "COUNTRY_BJ",
                "COUNTRY_BL",
                "COUNTRY_BM",
                "COUNTRY_BN",
                "COUNTRY_BO",
                "COUNTRY_BQ",
                "COUNTRY_BR",
                "COUNTRY_BS",
                "COUNTRY_BT",
                "COUNTRY_BV",
                "COUNTRY_BW",
                "COUNTRY_BY",
                "COUNTRY_BZ",
                "COUNTRY_CA",
                "COUNTRY_CC",
                "COUNTRY_CD",
                "COUNTRY_CF",
                "COUNTRY_CG",
                "COUNTRY_CH",
                "COUNTRY_CI",
                "COUNTRY_CK",
                "COUNTRY_CL",
                "COUNTRY_CM",
                "COUNTRY_CN",
                "COUNTRY_CO",
                "COUNTRY_CR",
                "COUNTRY_CS",
                "COUNTRY_CU",
                "COUNTRY_CV",
                "COUNTRY_CW",
                "COUNTRY_CX",
                "COUNTRY_CY",
                "COUNTRY_CZ",
                "COUNTRY_DE",
                "COUNTRY_DJ",
                "COUNTRY_DK",
                "COUNTRY_DM",
                "COUNTRY_DO",
                "COUNTRY_DZ",
                "COUNTRY_EC",
                "COUNTRY_EE",
                "COUNTRY_EG",
                "COUNTRY_EH",
                "COUNTRY_ER",
                "COUNTRY_ES",
                "COUNTRY_ET",
                "COUNTRY_FI",
                "COUNTRY_FJ",
                "COUNTRY_FK",
                "COUNTRY_FM",
                "COUNTRY_FO",
                "COUNTRY_FR",
                "COUNTRY_GA",
                "COUNTRY_GB",
                "COUNTRY_GD",
                "COUNTRY_GE",
                "COUNTRY_GF",
                "COUNTRY_GG",
                "COUNTRY_GH",
                "COUNTRY_GI",
                "COUNTRY_GL",
                "COUNTRY_GM",
                "COUNTRY_GN",
                "COUNTRY_GP",
                "COUNTRY_GQ",
                "COUNTRY_GR",
                "COUNTRY_GS",
                "COUNTRY_GT",
                "COUNTRY_GU",
                "COUNTRY_GW",
                "COUNTRY_GY",
                "COUNTRY_HK",
                "COUNTRY_HM",
                "COUNTRY_HN",
                "COUNTRY_HR",
                "COUNTRY_HT",
                "COUNTRY_HU",
                "COUNTRY_ID",
                "COUNTRY_IE",
                "COUNTRY_IL",
                "COUNTRY_IM",
                "COUNTRY_IN",
                "COUNTRY_IO",
                "COUNTRY_IQ",
                "COUNTRY_IR",
                "COUNTRY_IS",
                "COUNTRY_IT",
                "COUNTRY_JE",
                "COUNTRY_JM",
                "COUNTRY_JO",
                "COUNTRY_JP",
                "COUNTRY_KE",
                "COUNTRY_KG",
                "COUNTRY_KH",
                "COUNTRY_KI",
                "COUNTRY_KM",
                "COUNTRY_KN",
                "COUNTRY_KP",
                "COUNTRY_KR",
                "COUNTRY_KW",
                "COUNTRY_KY",
                "COUNTRY_KZ",
                "COUNTRY_LA",
                "COUNTRY_LB",
                "COUNTRY_LC",
                "COUNTRY_LI",
                "COUNTRY_LK",
                "COUNTRY_LR",
                "COUNTRY_LS",
                "COUNTRY_LT",
                "COUNTRY_LU",
                "COUNTRY_LV",
                "COUNTRY_LY",
                "COUNTRY_MA",
                "COUNTRY_MC",
                "COUNTRY_MD",
                "COUNTRY_ME",
                "COUNTRY_MF",
                "COUNTRY_MG",
                "COUNTRY_MH",
                "COUNTRY_MK",
                "COUNTRY_ML",
                "COUNTRY_MM",
                "COUNTRY_MN",
                "COUNTRY_MO",
                "COUNTRY_MP",
                "COUNTRY_MQ",
                "COUNTRY_MR",
                "COUNTRY_MS",
                "COUNTRY_MT",
                "COUNTRY_MU",
                "COUNTRY_MV",
                "COUNTRY_MW",
                "COUNTRY_MX",
                "COUNTRY_MY",
                "COUNTRY_MZ",
                "COUNTRY_NA",
                "COUNTRY_NC",
                "COUNTRY_NE",
                "COUNTRY_NF",
                "COUNTRY_NG",
                "COUNTRY_NI",
                "COUNTRY_NL",
                "COUNTRY_NO",
                "COUNTRY_NP",
                "COUNTRY_NR",
                "COUNTRY_NU",
                "COUNTRY_NZ",
                "COUNTRY_OM",
                "COUNTRY_PA",
                "COUNTRY_PE",
                "COUNTRY_PF",
                "COUNTRY_PG",
                "COUNTRY_PH",
                "COUNTRY_PK",
                "COUNTRY_PL",
                "COUNTRY_PM",
                "COUNTRY_PN",
                "COUNTRY_PR",
                "COUNTRY_PS",
                "COUNTRY_PT",
                "COUNTRY_PW",
                "COUNTRY_PY",
                "COUNTRY_QA",
                "COUNTRY_RE",
                "COUNTRY_RO",
                "COUNTRY_RS",
                "COUNTRY_RU",
                "COUNTRY_RW",
                "COUNTRY_SA",
                "COUNTRY_SB",
                "COUNTRY_SC",
                "COUNTRY_SD",
                "COUNTRY_SE",
                "COUNTRY_SG",
                "COUNTRY_SH",
                "COUNTRY_SI",
                "COUNTRY_SJ",
                "COUNTRY_SK",
                "COUNTRY_SL",
                "COUNTRY_SM",
                "COUNTRY_SN",
                "COUNTRY_SO",
                "COUNTRY_SR",
                "COUNTRY_SS",
                "COUNTRY_ST",
                "COUNTRY_SV",
                "COUNTRY_SX",
                "COUNTRY_SY",
                "COUNTRY_SZ",
                "COUNTRY_TC",
                "COUNTRY_TD",
                "COUNTRY_TF",
                "COUNTRY_TG",
                "COUNTRY_TH",
                "COUNTRY_TJ",
                "COUNTRY_TK",
                "COUNTRY_TL",
                "COUNTRY_TM",
                "COUNTRY_TN",
                "COUNTRY_TO",
                "COUNTRY_TR",
                "COUNTRY_TT",
                "COUNTRY_TV",
                "COUNTRY_TW",
                "COUNTRY_TZ",
                "COUNTRY_UA",
                "COUNTRY_UG",
                "COUNTRY_UM",
                "COUNTRY_US",
                "COUNTRY_UY",
                "COUNTRY_UZ",
                "COUNTRY_VA",
                "COUNTRY_VC",
                "COUNTRY_VE",
                "COUNTRY_VG",
                "COUNTRY_VI",
                "COUNTRY_VN",
                "COUNTRY_VU",
                "COUNTRY_WF",
                "COUNTRY_WS",
                "COUNTRY_XK",
                "COUNTRY_XT",
                "COUNTRY_YE",
                "COUNTRY_YT",
                "COUNTRY_ZA",
                "COUNTRY_ZM",
                "COUNTRY_ZW"
            ],
            "default": "COUNTRY_NONE",
            "x-displayname": "Country Code",
            "x-ves-proto-enum": "ves.io.schema.policy.CountryCode"
        },
        "policyDataGuardControl": {
            "type": "object",
            "description": "x-displayName: \"Data Guard Control\"\nData Guard changes to be applied for this request",
            "title": "Data Guard Control",
            "properties": {
                "policy_name": {
                    "type": "string",
                    "description": "x-displayName: \"Policy Name\"\nx-example: \"value\"\nSets the BD Policy to use",
                    "title": "Set BD Policy name"
                }
            }
        },
        "policyDetectionContext": {
            "type": "string",
            "description": "The available contexts for Exclusion rules.\n\n - CONTEXT_ANY: CONTEXT_ANY\n\nDetection will be excluded for all contexts.\n - CONTEXT_BODY: CONTEXT_BODY\n\nDetection will be excluded for the request body.\n - CONTEXT_REQUEST: CONTEXT_REQUEST\n\nDetection will be excluded for the request.\n - CONTEXT_RESPONSE: CONTEXT_RESPONSE\n\n - CONTEXT_PARAMETER: CONTEXT_PARAMETER\n\nDetection will be excluded for the parameters. The parameter name is required in the Context name field. If the field is left empty, the detection will be excluded for all parameters.\n - CONTEXT_HEADER: CONTEXT_HEADER\n\nDetection will be excluded for the headers. The header name is required in the Context name field. If the field is left empty, the detection will be excluded for all headers.\n - CONTEXT_COOKIE: CONTEXT_COOKIE\n\nDetection will be excluded for the cookies. The cookie name is required in the Context name field. If the field is left empty, the detection will be excluded for all cookies.\n - CONTEXT_URL: CONTEXT_URL\n\nDetection will be excluded for the request URL.\n - CONTEXT_URI: CONTEXT_URI\n",
            "title": "Detection Context",
            "enum": [
                "CONTEXT_ANY",
                "CONTEXT_BODY",
                "CONTEXT_REQUEST",
                "CONTEXT_RESPONSE",
                "CONTEXT_PARAMETER",
                "CONTEXT_HEADER",
                "CONTEXT_COOKIE",
                "CONTEXT_URL",
                "CONTEXT_URI"
            ],
            "default": "CONTEXT_ANY",
            "x-displayname": "WAF Exclusion Context Options",
            "x-ves-proto-enum": "ves.io.schema.policy.DetectionContext"
        },
        "policyGraphQLSettingsType": {
            "type": "object",
            "description": "x-displayName: \"GraphQL Settings\"\nGraphQL configuration.",
            "title": "GraphQL Settings",
            "properties": {
                "disable_introspection": {
                    "description": "x-displayName: \"Disable\"\nDisable introspection queries for the load balancer.",
                    "title": "Disable Introspection Queries",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "enable_introspection": {
                    "description": "x-displayName: \"Enable\"\nEnable introspection queries for the load balancer.",
                    "title": "Enable Introspection Queries",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "max_batched_queries": {
                    "type": "integer",
                    "description": "x-displayName: \"Maximum Batched Queries\"\nx-example: \"10\"\nx-required\nSpecify maximum number of queries in a single batched request.",
                    "title": "Max Batched Queries",
                    "format": "int64"
                },
                "max_depth": {
                    "type": "integer",
                    "description": "x-displayName: \"Maximum Structure Depth\"\nx-example: \"10\"\nx-required\nSpecify maximum depth for the GraphQL query.",
                    "title": "Max Depth",
                    "format": "int64"
                },
                "max_total_length": {
                    "type": "integer",
                    "description": "x-displayName: \"Maximum Total Length\"\nx-example: \"5000\"\nx-required\nSpecify maximum length in bytes for the GraphQL query.",
                    "title": "Max Total Length",
                    "format": "int64"
                },
                "max_value_length": {
                    "type": "integer",
                    "description": "x-displayName: \"Maximum Value Length\"\nx-example: \"1024\"\nx-required\nSpecify maximum value length in bytes for the GraphQL query.",
                    "title": "Max Value Length",
                    "format": "int64"
                },
                "policy_name": {
                    "type": "string",
                    "description": "x-displayName: \"Policy Name\"\nx-example: \"graphql\"\nSets the BD Policy to use",
                    "title": "Set BD Policy name"
                }
            }
        },
        "policyHTMLPosition": {
            "type": "string",
            "description": "x-displayName: \"HTML Position\"\nPosition of the HTML tag to insert in HTML document\n\n - BEGINNING: x-displayName: \"Beginning of HTML tag\"\nBeginning of HTML tag.\n - END: x-displayName: \"End of HTML tag\"\nEnd of HTML tag.\n - BEFORE: x-displayName: \"Before HTML tag\"\nBefore HTML tag.\n - AFTER: x-displayName: \"After HTML tag\"\nAfter HTML tag.",
            "title": "HTMLPosition",
            "enum": [
                "BEGINNING",
                "END",
                "BEFORE",
                "AFTER"
            ],
            "default": "BEGINNING"
        },
        "policyHttpMethodMatcherType": {
            "type": "object",
            "description": "A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list.\nThe result of the match based on the method list is inverted if invert_matcher is true.",
            "title": "HttpMethodMatcherType",
            "x-displayname": "HTTP Method Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.HttpMethodMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Method Matcher"
                },
                "methods": {
                    "type": "array",
                    "description": " List of methods values to match against.\n\nExample: - \"['GET', 'POST', 'DELETE']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "methods",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "Method List",
                    "x-ves-example": "['GET', 'POST', 'DELETE']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyIPThreatCategory": {
            "type": "string",
            "description": "The IP threat categories to use when a policy based IP threat category is configured.\n\n - SPAM_SOURCES: SPAM_SOURCES\n\n - WINDOWS_EXPLOITS: WINDOWS_EXPLOITS\n\n - WEB_ATTACKS: WEB_ATTACKS\n\n - BOTNETS: BOTNETS\n\n - SCANNERS: SCANNERS\n\n - REPUTATION: REPUTATION\n\n - PHISHING: PHISHING\n\n - PROXY: PROXY\n\n - MOBILE_THREATS: MOBILE_THREATS\n\n - TOR_PROXY: TOR_PROXY\n\n - DENIAL_OF_SERVICE: DENIAL_OF_SERVICE\n\n - NETWORK: NETWORK\n",
            "title": "IP Threat Category",
            "enum": [
                "SPAM_SOURCES",
                "WINDOWS_EXPLOITS",
                "WEB_ATTACKS",
                "BOTNETS",
                "SCANNERS",
                "REPUTATION",
                "PHISHING",
                "PROXY",
                "MOBILE_THREATS",
                "TOR_PROXY",
                "DENIAL_OF_SERVICE",
                "NETWORK"
            ],
            "default": "SPAM_SOURCES",
            "x-displayname": "IP Threat Category",
            "x-ves-proto-enum": "ves.io.schema.policy.IPThreatCategory"
        },
        "policyIpMatcherType": {
            "type": "object",
            "description": "Match any ip prefix contained in the list of ip_prefix_sets.\nThe result of the match is inverted if invert_matcher is true.",
            "title": "ip matcher type",
            "x-displayname": "IP Prefix Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.IpMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert IP Matcher"
                },
                "prefix_sets": {
                    "type": "array",
                    "description": " A list of references to ip_prefix_set objects.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 4\n",
                    "title": "prefix_sets",
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "IP Prefix Sets",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "4"
                    }
                }
            }
        },
        "policyJA4TlsFingerprintMatcherType": {
            "type": "object",
            "description": "An extended version of JA3 that includes additional fields for more comprehensive fingerprinting of\nSSL/TLS clients and potentially has a different structure and length.",
            "title": "JA4TlsFingerprintMatcherType",
            "x-displayname": "JA4 TLS Fingerprint Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.JA4TlsFingerprintMatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact JA4 TLS fingerprint to match the input JA4 TLS fingerprint against\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 36\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "36",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyJWTClaimMatcherType": {
            "type": "object",
            "description": "A JWT claim matcher specifies the name of a single JWT claim and the criteria for the input request to match it.\nThe input has a list of actual values for each JWT claim name in the JWT payload.\nA JWT claim matcher can check for one of the following:\n* Presence or absence of the JWT Claim in the input\n* At least one of the values for the JWT Claim in the input satisfies the MatcherType item",
            "title": "JWTClaimMatcherType",
            "x-displayname": "JWT Claim Matcher",
            "x-ves-displayorder": "1,2,6",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.JWTClaimMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the JWT Claim is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the JWT Claim is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the JWT Claim. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " JWT claim name.\n\nExample: - \"user_id\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "JWT Claim Name",
                    "x-ves-example": "user_id",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyKnownTlsFingerprintClass": {
            "type": "string",
            "description": "Specifies known TLS fingerprint classes\n\n - TLS_FINGERPRINT_NONE: TLS_FINGERPRINT_NONE\n\nNo TLS fingerprint\n - ANY_MALICIOUS_FINGERPRINT: ANY_MALICIOUS_FINGERPRINT\n\nTLS fingerprints known to be associated with malicious clients\n - ADWARE: ADWARE\n\nTLS fingerprints known to be associated with adware\n - ADWIND: ADWIND\n\nTLS fingerprints known to be associated with adwind\n - DRIDEX: DRIDEX\n\nTLS fingerprints known to be associated with dridex\n - GOOTKIT: GOOTKIT\n\nTLS fingerprints known to be associated with gootkit\n - GOZI: GOZI\n\nTLS fingerprints known to be associated with gozi\n - JBIFROST: JBIFROST\n\nTLS fingerprints known to be associated with jbifrost\n - QUAKBOT: QUAKBOT\n\nTLS fingerprints known to be associated with quakbot\n - RANSOMWARE: RANSOMWARE\n\nTLS fingerprints known to be associated with ransomware\n - TROLDESH: TROLDESH\n\nTLS fingerprints known to be associated with troldesh\n - TOFSEE: TOFSEE\n\nTLS fingerprints known to be associated with tofsee\n - TORRENTLOCKER: TORRENTLOCKER\n\nTLS fingerprints known to be associated with torrentlocker\n - TRICKBOT: TRICKBOT\n\nTLS fingerprints known to be associated with trickbot",
            "title": "TLS known fingerprint class",
            "enum": [
                "TLS_FINGERPRINT_NONE",
                "ANY_MALICIOUS_FINGERPRINT",
                "ADWARE",
                "ADWIND",
                "DRIDEX",
                "GOOTKIT",
                "GOZI",
                "JBIFROST",
                "QUAKBOT",
                "RANSOMWARE",
                "TROLDESH",
                "TOFSEE",
                "TORRENTLOCKER",
                "TRICKBOT"
            ],
            "default": "TLS_FINGERPRINT_NONE",
            "x-displayname": "TLS known fingerprint class",
            "x-ves-proto-enum": "ves.io.schema.policy.KnownTlsFingerprintClass"
        },
        "policyMalwareProtectionSettings": {
            "type": "object",
            "description": "x-displayName: \"Malware Protection Settings\"\nSettings for handling malware protection detection.",
            "title": "Malware Protection Settings",
            "properties": {
                "action": {
                    "description": "x-displayName: \"Action\"\nx-required\nAction to be taken when malware is detected",
                    "title": "Action",
                    "$ref": "#/definitions/schemaAction"
                }
            }
        },
        "policyMaskingConfig": {
            "type": "object",
            "description": "x-displayName: \"Masking Configuration\"\nMasking configuration comprise a list of masking fields values and an action - mask or report.",
            "title": "Masking Configuration",
            "properties": {
                "fields": {
                    "type": "array",
                    "description": "x-displayName: \"Fields Values\"\nx-example: \"[user.password, credit_card]\"\nA list of JSONPath fields values to match the request/response payload against.",
                    "title": "Fields",
                    "items": {
                        "type": "string"
                    }
                },
                "mask": {
                    "description": "x-displayName: \"Mask Sensitive Data\"\nMask sensitive data action",
                    "title": "Mask Sensitive Data",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "report": {
                    "description": "x-displayName: \"Report Sensitive Data\"\nReport sensitive data action",
                    "title": "Report sensitive data",
                    "$ref": "#/definitions/ioschemaEmpty"
                }
            }
        },
        "policyMatcherType": {
            "type": "object",
            "description": "A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of exact values and a list of regular expressions.",
            "title": "MatcherType",
            "x-displayname": "Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.MatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact values to match the input against.\n\nExample: - \"['new york', 'london', 'sydney', 'tokyo', 'cairo']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 64,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['new york', 'london', 'sydney', 'tokyo', 'cairo']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input against.\n\nExample: - \"['^new .*$', 'san f.*', '.* del .*']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "regex values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^new .*$', 'san f.*', '.* del .*']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "transformers": {
                    "type": "array",
                    "description": " An ordered list of transformers (starting from index 0) to be applied to the path before matching.\n\nExample: - \"[BASE64_DECODE, LOWER_CASE]-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 9\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "transformers",
                    "maxItems": 9,
                    "items": {
                        "$ref": "#/definitions/policyTransformer"
                    },
                    "x-displayname": "Transformers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "9",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyMatcherTypeBasic": {
            "type": "object",
            "description": "A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of exact values and a list of regular expressions.",
            "title": "MatcherTypeBasic",
            "x-displayname": "Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.MatcherTypeBasic",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact values to match the input against.\n\nExample: - \"['new york', 'london', 'sydney', 'tokyo', 'cairo']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 64,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['new york', 'london', 'sydney', 'tokyo', 'cairo']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input against.\n\nExample: - \"['^new .*$', 'san f.*', '.* del .*']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "regex values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^new .*$', 'san f.*', '.* del .*']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyModifyAction": {
            "type": "object",
            "description": "Modify behavior for a matching request. The modification could be to entirely skip processing.",
            "title": "Select Modification Action",
            "x-displayname": "Select Modification Action",
            "x-ves-oneof-field-action_type": "[\"default\",\"skip_processing\"]",
            "x-ves-proto-message": "ves.io.schema.policy.ModifyAction",
            "properties": {
                "default": {
                    "description": "Exclusive with [skip_processing]\n Perform the default enforcement for this request",
                    "title": "Do not modify",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Do not modify"
                },
                "skip_processing": {
                    "description": "Exclusive with [default]\n Do not perform enforcement for this request",
                    "title": "Skip Processing",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip Processing"
                }
            }
        },
        "policyOasValidationActionType": {
            "type": "string",
            "description": "x-displayName: \"OpenAPI Validation Action\"\nOpenAPI Validation Action Type\n\n - OAS_NONE: OAS_NONE\n\nx-displayName: \"No Operation\"\nAllow the request/response (don't validate OpenAPI specification)\n - OAS_REPORT_VIOLATION: OAS_REPORT_VIOLATION\n\nx-displayName: \"Report Violation\"\nIf OpenAPI violation occurs, allow the request/response and report it (API security event)\n - OAS_BLOCK_VIOLATION: OAS_BLOCK_VIOLATION\n\nx-displayName: \"Block Violation\"\nIf OpenAPI violation occurs, block the request/response and report it (API security event)\n - OAS_BLOCK: OAS_BLOCK\n\nx-displayName: \"Block\"\nblock the request/response and report it (API security event)\n - OAS_REPORT: OAS_REPORT\n\nx-displayName: \"Report\"\nallow the request/response and report it (API security event)",
            "title": "OpenAPI Validation Action",
            "enum": [
                "OAS_NONE",
                "OAS_REPORT_VIOLATION",
                "OAS_BLOCK_VIOLATION",
                "OAS_BLOCK",
                "OAS_REPORT"
            ],
            "default": "OAS_NONE"
        },
        "policyOpenApiValidationAction": {
            "type": "object",
            "description": "x-displayName: \"OpenAPI Validation Action\"\nOpenAPI Validation configuration",
            "title": "OpenAPI Validation Action",
            "properties": {
                "oas_response_validation_action": {
                    "description": "x-displayName: \"OpenAPI Response Validation Action\"\nx-required\nThe action to perform if OpenAPI response validation fails",
                    "title": "OpenApi Response Validation Action",
                    "$ref": "#/definitions/policyOasValidationActionType"
                },
                "oas_validation_action": {
                    "description": "x-displayName: \"OpenAPI Request Validation Action\"\nx-required\nThe action to perform if OpenAPI request validation fails (or if set by fall through rule)",
                    "title": "OpenApi Request Validation Action",
                    "$ref": "#/definitions/policyOasValidationActionType"
                },
                "request_properties_selection": {
                    "type": "array",
                    "description": "x-displayName: \"Request Properties Selection\"\nList of properties of the request to validate according to the OpenAPI specification file (a.k.a. swagger)",
                    "title": "Request Properties Selection",
                    "items": {
                        "$ref": "#/definitions/schemaOpenApiValidationProperties"
                    }
                },
                "response_properties_selection": {
                    "type": "array",
                    "description": "x-displayName: \"Response Properties Selection\"\nList of properties of the response to validate according to the OpenAPI specification file (a.k.a. swagger)",
                    "title": "Response Properties Selection",
                    "items": {
                        "$ref": "#/definitions/schemaOpenApiValidationProperties"
                    }
                }
            }
        },
        "policyPrefixMatchList": {
            "type": "object",
            "description": "List of IP Prefix strings to match against.",
            "title": "IP Prefix Match List",
            "x-displayname": "IP Prefix Match List",
            "x-ves-proto-message": "ves.io.schema.policy.PrefixMatchList",
            "properties": {
                "invert_match": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Match Result"
                },
                "ip_prefixes": {
                    "type": "array",
                    "description": " List of IPv4 prefix strings.\n\nExample: - \"192.168.20.0/24\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv4_prefix: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ip prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Prefix List",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "ipv6_prefixes": {
                    "type": "array",
                    "description": " List of IPv6 prefix strings.\n\nExample: - \"fd48:fa09:d9d4::/48\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv6_prefix: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ipv6 prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Prefix List",
                    "x-ves-example": "fd48:fa09:d9d4::/48",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv6_prefix": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyRequestConstraintType": {
            "type": "object",
            "title": "RequestConstraintType",
            "x-displayname": "Request Constraints",
            "x-ves-oneof-field-max_cookie_count_choice": "[\"max_cookie_count_exceeds\",\"max_cookie_count_none\"]",
            "x-ves-oneof-field-max_cookie_key_size_choice": "[\"max_cookie_key_size_exceeds\",\"max_cookie_key_size_none\"]",
            "x-ves-oneof-field-max_cookie_value_size_choice": "[\"max_cookie_value_size_exceeds\",\"max_cookie_value_size_none\"]",
            "x-ves-oneof-field-max_header_count_choice": "[\"max_header_count_exceeds\",\"max_header_count_none\"]",
            "x-ves-oneof-field-max_header_key_size_choice": "[\"max_header_key_size_exceeds\",\"max_header_key_size_none\"]",
            "x-ves-oneof-field-max_header_value_size_choice": "[\"max_header_value_size_exceeds\",\"max_header_value_size_none\"]",
            "x-ves-oneof-field-max_parameter_count_choice": "[\"max_parameter_count_exceeds\",\"max_parameter_count_none\"]",
            "x-ves-oneof-field-max_parameter_name_size_choice": "[\"max_parameter_name_size_exceeds\",\"max_parameter_name_size_none\"]",
            "x-ves-oneof-field-max_parameter_value_size_choice": "[\"max_parameter_value_size_exceeds\",\"max_parameter_value_size_none\"]",
            "x-ves-oneof-field-max_query_size_choice": "[\"max_query_size_exceeds\",\"max_query_size_none\"]",
            "x-ves-oneof-field-max_request_line_size_choice": "[\"max_request_line_size_exceeds\",\"max_request_line_size_none\"]",
            "x-ves-oneof-field-max_request_size_choice": "[\"max_request_size_exceeds\",\"max_request_size_none\"]",
            "x-ves-oneof-field-max_url_size_choice": "[\"max_url_size_exceeds\",\"max_url_size_none\"]",
            "x-ves-proto-message": "ves.io.schema.policy.RequestConstraintType",
            "properties": {
                "max_cookie_count_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_cookie_count_none]\n\nExample: - \"40\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 1024\n",
                    "title": "max_cookie_count_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Count for all Cookies that exceed this value",
                    "x-ves-example": "40",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "1024"
                    }
                },
                "max_cookie_count_none": {
                    "description": "Exclusive with [max_cookie_count_exceeds]\n",
                    "title": "max_cookie_count_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_cookie_key_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_cookie_key_size_none]\n\nExample: - \"64\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 1024\n",
                    "title": "max_cookie_key_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Name Size per Cookie that exceed this value",
                    "x-ves-example": "64",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "1024"
                    }
                },
                "max_cookie_key_size_none": {
                    "description": "Exclusive with [max_cookie_key_size_exceeds]\n",
                    "title": "max_cookie_key_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_cookie_value_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_cookie_value_size_none]\n\nExample: - \"4096\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 32768\n",
                    "title": "max_cookie_value_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Value Size per Cookie that exceed this value",
                    "x-ves-example": "4096",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "32768"
                    }
                },
                "max_cookie_value_size_none": {
                    "description": "Exclusive with [max_cookie_value_size_exceeds]\n",
                    "title": "max_cookie_value_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_header_count_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_header_count_none]\n\nExample: - \"20\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 40\n",
                    "title": "max_header_count_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Count for all Headers that exceed this value",
                    "x-ves-example": "20",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "40"
                    }
                },
                "max_header_count_none": {
                    "description": "Exclusive with [max_header_count_exceeds]\n",
                    "title": "max_header_count_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_header_key_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_header_key_size_none]\n\nExample: - \"32\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 1024\n",
                    "title": "max_header_key_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Name Size per Header that exceed this value",
                    "x-ves-example": "32",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "1024"
                    }
                },
                "max_header_key_size_none": {
                    "description": "Exclusive with [max_header_key_size_exceeds]\n",
                    "title": "max_header_key_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_header_value_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_header_value_size_none]\n\nExample: - \"1024\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 64000\n",
                    "title": "max_header_value_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Value Size per Header that exceed this value",
                    "x-ves-example": "1024",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "64000"
                    }
                },
                "max_header_value_size_none": {
                    "description": "Exclusive with [max_header_value_size_exceeds]\n",
                    "title": "max_header_value_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_parameter_count_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_parameter_count_none]\n\nExample: - \"4\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 1024\n",
                    "title": "max_parameter_count_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Parameter Count that exceed this value",
                    "x-ves-example": "4",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "1024"
                    }
                },
                "max_parameter_count_none": {
                    "description": "Exclusive with [max_parameter_count_exceeds]\n",
                    "title": "max_parameter_count_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_parameter_name_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_parameter_name_size_none]\n\nExample: - \"64\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 1024\n",
                    "title": "max_parameter_name_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Parameter Name Size that exceed this value",
                    "x-ves-example": "64",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "1024"
                    }
                },
                "max_parameter_name_size_none": {
                    "description": "Exclusive with [max_parameter_name_size_exceeds]\n",
                    "title": "max_parameter_name_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_parameter_value_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_parameter_value_size_none]\n\nExample: - \"1000\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 1073741824\n",
                    "title": "max_parameter_value_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Parameter Value Size that exceed this value",
                    "x-ves-example": "1000",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "1073741824"
                    }
                },
                "max_parameter_value_size_none": {
                    "description": "Exclusive with [max_parameter_value_size_exceeds]\n",
                    "title": "max_parameter_value_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_query_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_query_size_none]\n\nExample: - \"4096\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 60000\n",
                    "title": "max_query_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the URL Query Size that exceed this value",
                    "x-ves-example": "4096",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "60000"
                    }
                },
                "max_query_size_none": {
                    "description": "Exclusive with [max_query_size_exceeds]\n",
                    "title": "max_query_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_request_line_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_request_line_size_none]\n\nExample: - \"4096\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 65536\n",
                    "title": "max_query_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Request Line Size that exceed this value",
                    "x-ves-example": "4096",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "65536"
                    }
                },
                "max_request_line_size_none": {
                    "description": "Exclusive with [max_request_line_size_exceeds]\n",
                    "title": "max_request_line_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_request_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_request_size_none]\n\nExample: - \"32768\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 65536\n",
                    "title": "max_request_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the Request Size that exceed this value",
                    "x-ves-example": "32768",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "65536"
                    }
                },
                "max_request_size_none": {
                    "description": "Exclusive with [max_request_size_exceeds]\n",
                    "title": "max_request_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                },
                "max_url_size_exceeds": {
                    "type": "integer",
                    "description": "Exclusive with [max_url_size_none]\n\nExample: - \"4096\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 128000\n",
                    "title": "max_url_size_exceeds",
                    "format": "int64",
                    "x-displayname": "Match on the URL Size that exceed this value",
                    "x-ves-example": "4096",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "128000"
                    }
                },
                "max_url_size_none": {
                    "description": "Exclusive with [max_url_size_exceeds]\n",
                    "title": "max_url_size_none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Configured"
                }
            }
        },
        "policyRoleMatcherType": {
            "type": "object",
            "description": "x-displayName: \"Role Matcher\"\nA role matcher specifies a single value for matching an input list of roles. The match is considered successful if the specified value is present in the input\nlist.",
            "title": "RoleMatcherType",
            "properties": {
                "match": {
                    "type": "string",
                    "description": "x-displayName: \"Role\"\nx-required\nx-example: \"ves-io-monitor-role\"\nx-example: \"ves-io-uam-role\"\nx-example: \"custom-role-security-czar'\"\nValue of the expected role.",
                    "title": "match"
                }
            }
        },
        "policyRuleAction": {
            "type": "string",
            "description": "The rule action determines the disposition of the input request API. If a policy matches a rule with an ALLOW action, the processing of the request proceeds\nforward. If it matches a rule with a DENY action, the processing of the request is terminated and an appropriate message/code returned to the originator. If\nit matches a rule with a NEXT_POLICY_SET action, evaluation of the current policy set terminates and evaluation of the next policy set in the chain begins.\n\n - DENY: DENY\n\nDeny the request.\n - ALLOW: ALLOW\n\nAllow the request to proceed.\n - NEXT_POLICY_SET: NEXT_POLICY_SET\n\nTerminate evaluation of the current policy set and begin evaluating the next policy set in the chain. Note that the evaluation of any remaining policies\nin the current policy set is skipped.\n - NEXT_POLICY: NEXT_POLICY\n\nTerminate evaluation of the current policy and begin evaluating the next policy in the policy set. Note that the evaluation of any remaining rules in the\ncurrent policy is skipped.\n - LAST_POLICY: LAST_POLICY\n\nTerminate evaluation of the current policy and begin evaluating the last policy in the policy set. Note that the evaluation of any remaining rules in the\ncurrent policy is skipped.\n - GOTO_POLICY: GOTO_POLICY\n\nTerminate evaluation of the current policy and begin evaluating a specific policy in the policy set. The policy is specified using the goto_policy field in\nthe rule and must be after the current policy in the policy set.",
            "title": "Rule Action",
            "enum": [
                "DENY",
                "ALLOW",
                "NEXT_POLICY"
            ],
            "default": "DENY",
            "x-displayname": "Rule Action",
            "x-ves-proto-enum": "ves.io.schema.policy.RuleAction"
        },
        "policyRuleCombiningAlgorithm": {
            "type": "string",
            "description": "x-displayName: \"Rule Combining Algorithm\"\nThe rule combining algorithm for a policy determines how the list of rules in the policy is evaluated.\nIf any of the rules is configured with a App Firewall action, the rule combining algorithm must be configured to be FIRST_MATCH.\n\n- FIRST_MATCH Rules are evaluated sequentially till a matching rule is identified\n- ALLOW_OVERRIDES Rules with an ALLOW action are evaluated prior to rules with a DENY action\n- DENY_OVERRIDES Rules with a DENY action are evaluated prior to rules with an ALLOW action\n\n - FIRST_MATCH: First Match\n\nx-displayName: \"First Rule Match\"\nRules are evaluated sequentially till a matching rule is identified\n - DENY_OVERRIDES: Deny Overrides\n\nx-displayName: \"Deny Rule Overrides\"\nRules with a DENY action are evaluated prior to rules with an ALLOW action\n - ALLOW_OVERRIDES: Allow Overrides\n\nx-displayName: \"Allow Rule Overrides\"\nRules with an ALLOW action are evaluated prior to rules with a DENY action",
            "title": "RuleCombiningAlgorithm",
            "enum": [
                "FIRST_MATCH",
                "DENY_OVERRIDES",
                "ALLOW_OVERRIDES"
            ],
            "default": "FIRST_MATCH"
        },
        "policySegmentPolicyType": {
            "type": "object",
            "description": "Configure source and destination segment for policy",
            "title": "Segment Choice",
            "x-displayname": "Configure Segments",
            "x-ves-oneof-field-dst_segment_choice": "[\"dst_any\",\"dst_segments\",\"intra_segment\"]",
            "x-ves-oneof-field-src_segment_choice": "[\"src_any\",\"src_segments\"]",
            "x-ves-proto-message": "ves.io.schema.policy.SegmentPolicyType",
            "properties": {
                "dst_any": {
                    "description": "Exclusive with [dst_segments intra_segment]\n Traffic is not matched against any segment",
                    "title": "Any segment",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any"
                },
                "dst_segments": {
                    "description": "Exclusive with [dst_any intra_segment]\n Traffic is matched against destination segment in selected segments",
                    "title": "List of segments",
                    "$ref": "#/definitions/viewsSegmentRefList",
                    "x-displayname": "Segments"
                },
                "intra_segment": {
                    "description": "Exclusive with [dst_any dst_segments]\n Traffic is matched for source and destination on the same segment",
                    "title": "Intra Segment Policy",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Intra Segment"
                },
                "src_any": {
                    "description": "Exclusive with [src_segments]\n Traffic is not matched against any segment",
                    "title": "Any segment",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any"
                },
                "src_segments": {
                    "description": "Exclusive with [src_any]\n Source traffic is matched against selected segments",
                    "title": "List of segments",
                    "$ref": "#/definitions/viewsSegmentRefList",
                    "x-displayname": "Segments"
                }
            }
        },
        "policyShapeBotBlockMitigationActionType": {
            "type": "object",
            "description": "x-displayName: \"Block bot mitigation\"\nBlock request and respond with custom content.",
            "title": "ShapeBotBlockMitigationActionType",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "x-displayName: \"Body\"\nx-example: \"string://LzxwPiBZb3VyIHJlcXVlc3Qgd2FzIGJsb2NrZWQgPC9wPg==\"\nCustom body message is of type uri_ref. Currently supported URL schemes is string:///.\nFor string:/// scheme, message needs to be encoded in Base64 format.\nYou can specify this message as base64 encoded plain text message e.g. \"Your request was blocked\"\nor it can be HTML paragraph or a body string encoded as base64 string\nE.g. \"\u003cp\u003e Your request was blocked \u003c/p\u003e\". Base64 encoded string for this html is \"LzxwPiBZb3VyIHJlcXVlc3Qgd2FzIGJsb2NrZWQgPC9wPg==\"",
                    "title": "body"
                },
                "body_hash": {
                    "type": "string",
                    "description": "x-displayName: \"Body Hash\"\nx-example: \"92959a96fd69146c5fe7cbde6e5720f2\"\nRepresents the corresponding MD5 Hash for the body message.",
                    "title": "body_hash"
                },
                "status": {
                    "description": "x-displayName: \"Status\"\nHTTP Status code to respond with",
                    "title": "Status",
                    "$ref": "#/definitions/schemaHttpStatusCode"
                }
            }
        },
        "policyShapeBotFlagMitigationActionChoiceType": {
            "type": "object",
            "description": "x-displayName: \"Select Flag Bot Mitigation Action\"\nFlag mitigation action.",
            "title": "ShapeBotFlagMitigationActionChoiceType",
            "properties": {
                "append_headers": {
                    "description": "x-displayName: \"Append Headers\"\nAppend mitigation headers.",
                    "title": "append_headers",
                    "$ref": "#/definitions/policyShapeBotFlagMitigationActionType"
                },
                "no_headers": {
                    "description": "x-displayName: \"No Headers\"\nNo mitigation headers.",
                    "title": "no_headers",
                    "$ref": "#/definitions/ioschemaEmpty"
                }
            }
        },
        "policyShapeBotFlagMitigationActionType": {
            "type": "object",
            "description": "x-displayName: \"Append Flag Mitigation Headers\"\nAppend flag mitigation headers to forwarded request.",
            "title": "ShapeBotFlagMitigationActionType",
            "properties": {
                "auto_type_header_name": {
                    "type": "string",
                    "description": "x-displayName: \"Automation Type Header Name\"\nx-example: \"Bot-Automation-Type\"\nx-required\nA case-insensitive HTTP header name.",
                    "title": "auto_type_header_name"
                },
                "inference_header_name": {
                    "type": "string",
                    "description": "x-displayName: \"Inference Header Name\"\nx-example: \"Bot-Inference\"\nx-required\nA case-insensitive HTTP header name.",
                    "title": "inference_header_name"
                }
            }
        },
        "policyShapeBotMitigationAction": {
            "type": "object",
            "description": "x-displayName: \"Bot Mitigation Action\"\nModify Bot Defense behavior for a matching request.",
            "title": "ShapeBotMitigationAction",
            "properties": {
                "block": {
                    "description": "x-displayName: \"Block\"\nBlock bot request and send response with custom content.",
                    "title": "Block",
                    "$ref": "#/definitions/policyShapeBotBlockMitigationActionType"
                },
                "flag": {
                    "description": "x-displayName: \"Flag\"\nFlag the request while not taking any invasive actions.",
                    "title": "Flag",
                    "$ref": "#/definitions/policyShapeBotFlagMitigationActionChoiceType"
                },
                "none": {
                    "description": "x-displayName: \"No Action\"\nNo mitigation actions.",
                    "title": "None",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "redirect": {
                    "description": "x-displayName: \"Redirect\"\nRedirect bot request to a custom URI.",
                    "title": "Redirect",
                    "$ref": "#/definitions/policyShapeBotRedirectMitigationActionType"
                }
            }
        },
        "policyShapeBotRedirectMitigationActionType": {
            "type": "object",
            "description": "x-displayName: \"Redirect bot mitigation\"\nRedirect request to a custom URI.",
            "title": "ShapeBotRedirectMitigationTypeAction",
            "properties": {
                "uri": {
                    "type": "string",
                    "description": "x-displayName: \"URI\"\nx-example: \"Enter URI\"\nx-required\nURI location for redirect may be relative or absolute.",
                    "title": "URI"
                }
            }
        },
        "policyShapeProtectedEndpointAction": {
            "type": "object",
            "description": "x-displayName: \"Protected Endpoint Action\"\nProtected Endpoint Action",
            "title": "ShapeProtectedEndpointAction",
            "properties": {
                "allow_goodbot": {
                    "type": "boolean",
                    "description": "x-displayName: \"Good bot\"\nx-required\nGood bot",
                    "title": "GoodBot",
                    "format": "boolean"
                },
                "app_traffic_type": {
                    "description": "x-displayName: \"Traffic type\"\nx-required\nTraffic type",
                    "title": "Application traffic type",
                    "$ref": "#/definitions/policyAppTrafficType"
                },
                "flow_label": {
                    "type": "string",
                    "description": "x-displayName: \"Flow Label\"\nx-example: \"Flight.CheckIn\"\nx-required\nFlow label",
                    "title": "Flow label"
                },
                "mitigation": {
                    "description": "x-displayName: \"Mitigation\"\nx-required\nMitigation action for protected endpoint",
                    "title": "Mitigation",
                    "$ref": "#/definitions/policyShapeBotMitigationAction"
                },
                "transaction_result": {
                    "description": "x-displayName: \"Transaction Result\"\nSuccess/failure Criteria for transaction result",
                    "title": "Transaction Result",
                    "$ref": "#/definitions/schemaBotDefenseTransactionResultType"
                },
                "web_scraping": {
                    "type": "boolean",
                    "description": "x-displayName: \"Web scraping\"\nx-required\nWeb scraping protection enabled for protected endpoint",
                    "title": "Web scraping",
                    "format": "boolean"
                }
            }
        },
        "policyStringMatcherType": {
            "type": "object",
            "description": "A matcher specifies a list of values for matching an input string. The match is considered successful if the input value is present in the list. The result of\nthe match is inverted if invert_matcher is true.",
            "title": "StringMatcherType",
            "x-displayname": "String Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.StringMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert String Matcher"
                },
                "match": {
                    "type": "array",
                    "description": " A list of exact values to match the input against.\n\nExample: - \"['new york', 'london', 'sydney', 'tokyo', 'cairo']\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.max_bytes: 63\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "match",
                    "maxItems": 64,
                    "items": {
                        "type": "string",
                        "maxLength": 63
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['new york', 'london', 'sydney', 'tokyo', 'cairo']",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "63",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyTlsFingerprintMatcherType": {
            "type": "object",
            "description": "A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known\nclasses of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input\nfingerprint is not one of the excluded values.",
            "title": "TlsFingerprintMatcherType",
            "x-displayname": "TLS Fingerprint Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.TlsFingerprintMatcherType",
            "properties": {
                "classes": {
                    "type": "array",
                    "description": " A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ADWARE', 'TRICKBOT']-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "classes",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyKnownTlsFingerprintClass"
                    },
                    "x-displayname": "TLS fingerprint classes",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 32\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "32",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "excluded_values": {
                    "type": "array",
                    "description": " A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one\n or more known TLS fingerprint classes in the enclosing matcher.\n\nExample: - \"['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 32\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "excluded values",
                    "maxItems": 32,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Excluded Values",
                    "x-ves-example": "['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "32",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyTransformer": {
            "type": "string",
            "description": "Transformers to be applied on the part of the request before matching.\n\n - TRANSFORMER_NONE: transformer none\n\nNo transformers enabled\n - LOWER_CASE: lower case\n\nConvert string to lower case\n - UPPER_CASE: upper case\n\nConvert string to upper case\n - BASE64_DECODE: base64 decode\n\nDecode string assuming base64 encoding\n - NORMALIZE_PATH: normalize path\n\nNormalize URL path so that /a/b/../c will be transformed to /a/c\n - REMOVE_WHITESPACE: remove whitespace\n\nRemove whitespaces\n - URL_DECODE: URL decode\n\nDecode string assuming URL encoding as per rfc1738\n - TRIM_LEFT: trim left\n\nRemove whitespace from the left side of the input string\n - TRIM_RIGHT: trim right\n\nRemove whitespace from the right side of the input string\n - TRIM: trim\n\nRemove whitespace from the both sides of the input string",
            "title": "Transformer",
            "enum": [
                "LOWER_CASE",
                "UPPER_CASE",
                "BASE64_DECODE",
                "NORMALIZE_PATH",
                "REMOVE_WHITESPACE",
                "URL_DECODE",
                "TRIM_LEFT",
                "TRIM_RIGHT",
                "TRIM"
            ],
            "default": "TRANSFORMER_NONE",
            "x-displayname": "Transformer",
            "x-ves-proto-enum": "ves.io.schema.policy.Transformer"
        },
        "policyURLItem": {
            "type": "object",
            "description": "x-displayName: \"URL Item\"\nA URL item specifies exact or regular expression match criteria for the domain and path.",
            "title": "url item",
            "properties": {
                "domain_regex": {
                    "type": "string",
                    "description": "x-displayName: \"Domain Regex\"\nx-example: \"*.mybloggingwebsite.org\"\nA regular expression to match the domain against.",
                    "title": "domain regex"
                },
                "domain_value": {
                    "type": "string",
                    "description": "x-displayName: \"Domain Value\"\nx-example: \"www.mybloggingwebsite.org\"\nAn exact value to match the domain against.",
                    "title": "domain value"
                },
                "path_prefix": {
                    "type": "string",
                    "description": "x-displayName: \"Path Prefix\"\nx-example: \"/api/web/namespaces/project179/users/\"\nAn prefix value to match the path against.",
                    "title": "path prefix"
                },
                "path_regex": {
                    "type": "string",
                    "description": "x-displayName: \"Path Regex\"\nx-example: \"^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$\"\nA regular expression to match the path against.",
                    "title": "path regex"
                },
                "path_value": {
                    "type": "string",
                    "description": "x-displayName: \"Path Value\"\nx-example: \"/api/web/namespaces/project179/users/user1\"\nAn exact value to match the path against.",
                    "title": "path value"
                }
            }
        },
        "policyURLMatcherType": {
            "type": "object",
            "description": "x-displayName: \"URL Matcher\"\nA URL matcher specifies a list of URL items as match criteria. The match is considered successful if the input domain and path match any of the URL items.\nThe result of the match is inverted if invert_matcher is true.",
            "title": "url matcher type",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": "x-displayName: \"Invert URL Matcher\"\nInvert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean"
                },
                "url_items": {
                    "type": "array",
                    "description": "x-displayName: \"URL Items\"\nx-required\nA list of URL items used as match criteria. The match is considered successful if the domain and path match any of the URL items.",
                    "title": "url items",
                    "items": {
                        "$ref": "#/definitions/policyURLItem"
                    }
                }
            }
        },
        "policyWafAction": {
            "type": "object",
            "description": "Modify App Firewall behavior for a matching request. The modification could either be to entirely skip firewall processing or to customize the firewall rules\nto be applied as defined by App Firewall Rule Control settings.",
            "title": "App Firewall Action",
            "x-displayname": "App Firewall Action",
            "x-ves-oneof-field-action_type": "[\"app_firewall_detection_control\",\"none\",\"waf_skip_processing\"]",
            "x-ves-proto-message": "ves.io.schema.policy.WafAction",
            "properties": {
                "app_firewall_detection_control": {
                    "description": "Exclusive with [none waf_skip_processing]\n Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.\n\nValidation Rules:\n  ves.io.schema.rules.message.required_one_nonzero_field: true\n",
                    "title": "App Firewall Detection control",
                    "$ref": "#/definitions/policyAppFirewallDetectionControl",
                    "x-displayname": "App Firewall Detection Control",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required_one_nonzero_field": "true"
                    }
                },
                "none": {
                    "description": "Exclusive with [app_firewall_detection_control waf_skip_processing]\n Perform normal App Firewall processing for this request",
                    "title": "Normal App Firewall Processing",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Do not modify App Firewall Processing"
                },
                "waf_skip_processing": {
                    "description": "Exclusive with [app_firewall_detection_control none]\n Skip all App Firewall processing for this request",
                    "title": "Skip App Firewall Processing",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip App Firewall Processing"
                }
            }
        },
        "protobufAny": {
            "type": "object",
            "description": "-Any- contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an -Any- value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field -@type- which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n-value- which holds the custom JSON in addition to the -@type-\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
            "properties": {
                "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n-path/google.protobuf.Duration-). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme -http-, -https-, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, -https- is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than -http-, -https- (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                }
            }
        },
        "rate_limiterInputHours": {
            "type": "object",
            "description": "x-displayName: \"Hours\"\nInput Duration Hours",
            "title": "Hours",
            "properties": {
                "duration": {
                    "type": "integer",
                    "description": "x-displayName: \"Duration\"",
                    "title": "Duration",
                    "format": "int64"
                }
            }
        },
        "rate_limiterInputMinutes": {
            "type": "object",
            "description": "x-displayName: \"Minutes\"\nInput Duration Minutes",
            "title": "Minutes",
            "properties": {
                "duration": {
                    "type": "integer",
                    "description": "x-displayName: \"Duration\"",
                    "title": "Duration",
                    "format": "int64"
                }
            }
        },
        "rate_limiterInputSeconds": {
            "type": "object",
            "description": "x-displayName: \"Seconds\"\nInput Duration Seconds",
            "title": "Seconds",
            "properties": {
                "duration": {
                    "type": "integer",
                    "description": "x-displayName: \"Duration\"",
                    "title": "Duration",
                    "format": "int64"
                }
            }
        },
        "rate_limiterRateLimitBlockAction": {
            "type": "object",
            "description": "x-displayName: \"Rate Limit Block Action\"\nAction where a user is blocked from making further requests after exceeding rate limit threshold.",
            "title": "RateLimitBlockAction",
            "properties": {
                "hours": {
                    "description": "x-displayName: \"Hours\"\nUser block mitigation time in Hours",
                    "title": "Hours",
                    "$ref": "#/definitions/rate_limiterInputHours"
                },
                "minutes": {
                    "description": "x-displayName: \"Minutes\"\nUser block mitigation time in Minutes",
                    "title": "Minutes",
                    "$ref": "#/definitions/rate_limiterInputMinutes"
                },
                "seconds": {
                    "description": "x-displayName: \"Seconds\"\nUser block mitigation time in Seconds",
                    "title": "Seconds",
                    "$ref": "#/definitions/rate_limiterInputSeconds"
                }
            }
        },
        "rate_limiterRateLimitPeriodUnit": {
            "type": "string",
            "description": "x-displayName: \"Rate Limit Period Unit\"\nUnit for the period per which the rate limit is applied.\n\n - SECOND: Second\n\nx-displayName: \"Seconds\"\nRate limit period unit is seconds\n - MINUTE: Minute\n\nx-displayName: \"Minutes\"\nRate limit period unit is minutes\n - HOUR: Hour\n\nx-displayName: \"Hours\"\nRate limit period unit is hours\n - DAY: Day\n\nx-displayName: \"Days\"\nRate limit period unit is days",
            "title": "RateLimitPeriodUnit",
            "enum": [
                "SECOND",
                "MINUTE",
                "HOUR",
                "DAY"
            ],
            "default": "SECOND"
        },
        "rate_limiterRateLimitValue": {
            "type": "object",
            "description": "x-displayName: \"Rate Limit Value\"\nA tuple consisting of a rate limit period unit and the total number of allowed requests for that period.",
            "title": "RateLimitValue",
            "properties": {
                "action_block": {
                    "description": "x-displayName: \"Block\"\nBlocks the user for a specified duration of time",
                    "title": "Block Action",
                    "$ref": "#/definitions/rate_limiterRateLimitBlockAction"
                },
                "burst_multiplier": {
                    "type": "integer",
                    "description": "x-displayName: \"Burst Multiplier\"\nx-example: \"1\"\nThe maximum burst of requests to accommodate, expressed as a multiple of the rate.",
                    "title": "burst_multiplier",
                    "format": "int64"
                },
                "disabled": {
                    "description": "x-displayName: \"Disabled\"",
                    "title": "Disabled",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "period_multiplier": {
                    "type": "integer",
                    "description": "x-displayName: \"Periods\"\nx-example: \"1\"\nThis setting, combined with Per Period units, provides a duration",
                    "title": "period_multiplier",
                    "format": "int64"
                },
                "total_number": {
                    "type": "integer",
                    "description": "x-displayName: \"Number Of Requests\"\nx-example: \"1\"\nx-required\nThe total number of allowed requests per rate-limiting period.",
                    "title": "total_number",
                    "format": "int64"
                },
                "unit": {
                    "description": "x-displayName: \"Per Period\"\nx-required\nUnit for the period per which the rate limit is applied.",
                    "title": "unit",
                    "$ref": "#/definitions/rate_limiterRateLimitPeriodUnit"
                }
            }
        },
        "rate_limiterRateLimiterMode": {
            "type": "string",
            "description": "x-displayName: \"Rate Limiter Mode\"\n\n - RATE_LIMITER_MODE_NOT_SHARED: Not Shared\n\nx-displayName: \"Not Shared\"\nAllot unique pool of request limits for each reference to a rate_limiter object.\n - RATE_LIMITER_MODE_SHARED: Shared\n\nx-displayName: \"Shared\"\nUse a common pool of request limits for all references to a rate_limiter object.",
            "title": "RateLimiterMode",
            "enum": [
                "RATE_LIMITER_MODE_NOT_SHARED",
                "RATE_LIMITER_MODE_SHARED"
            ],
            "default": "RATE_LIMITER_MODE_NOT_SHARED"
        },
        "schemaAction": {
            "type": "object",
            "description": "x-displayName: \"Action\"",
            "title": "action",
            "properties": {
                "block": {
                    "description": "x-displayName: \"Block\"\nBlock the request and report the issue",
                    "title": "block",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "report": {
                    "description": "x-displayName: \"Report\"\nAllow the request and report the issue",
                    "title": "report",
                    "$ref": "#/definitions/ioschemaEmpty"
                }
            }
        },
        "schemaBotDefenseTransactionResultCondition": {
            "type": "object",
            "description": "x-displayName: \"Bot Defense Transaction Result Condition\"\nBot Defense Transaction Result Condition",
            "title": "BotDefenseTransactionResultCondition",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Header Name\"\nx-example: \"Accept-Encoding\"\nA case-insensitive HTTP header name.",
                    "title": "name"
                },
                "regex_values": {
                    "type": "array",
                    "description": "x-displayName: \"Regex Values\"\nx-example: \"['^new .*$', 'san f.*', '.* del .*']\"\nA list of regular expressions to match the input against.",
                    "title": "regex values",
                    "items": {
                        "type": "string"
                    }
                },
                "status": {
                    "description": "x-displayName: \"HTTP Status code\"\nx-required\nHTTP Status code",
                    "title": "HTTP Status code for response",
                    "$ref": "#/definitions/schemaHttpStatusCode"
                }
            }
        },
        "schemaBotDefenseTransactionResultType": {
            "type": "object",
            "description": "x-displayName: \"Bot Defense Transaction Result Type\"\nBot Defense Transaction ResultType",
            "title": "BotDefenseTransactionResultType",
            "properties": {
                "failure_conditions": {
                    "type": "array",
                    "description": "x-displayName: \"Failure Conditions\"\nFailure Conditions",
                    "title": "Failure Conditions",
                    "items": {
                        "$ref": "#/definitions/schemaBotDefenseTransactionResultCondition"
                    }
                },
                "success_conditions": {
                    "type": "array",
                    "description": "x-displayName: \"Success Conditions\"\nSuccess Conditions",
                    "title": "Success Conditions",
                    "items": {
                        "$ref": "#/definitions/schemaBotDefenseTransactionResultCondition"
                    }
                }
            }
        },
        "schemaConditionType": {
            "type": "object",
            "description": "Conditions are used in the object status to describe the current state of the\nobject, e.g. Ready, Succeeded, etc.",
            "title": "ConditionType",
            "x-displayname": "Status Condition",
            "x-ves-proto-message": "ves.io.schema.ConditionType",
            "properties": {
                "hostname": {
                    "type": "string",
                    "description": " Hostname of the instance of the site that sent the status",
                    "title": "hostname",
                    "x-displayname": "Hostname"
                },
                "last_update_time": {
                    "type": "string",
                    "description": " Last time the condition was updated",
                    "title": "last_update_time",
                    "format": "date-time",
                    "x-displayname": "Last Updated"
                },
                "reason": {
                    "type": "string",
                    "description": " x-reason: \"Insufficient memory in data plane\"\n A human readable string explaining the reason for reaching this condition\n\nExample: - \"value\"-",
                    "title": "reason",
                    "x-displayname": "Reason",
                    "x-ves-example": "value"
                },
                "service_name": {
                    "type": "string",
                    "description": " Name of the service that sent the status",
                    "title": "service name",
                    "x-displayname": "Service Name"
                },
                "status": {
                    "type": "string",
                    "description": " Status of the condition\n \"Success\" Validtion has succeded. Requested operation was successful.\n \"Failed\"  Validation has failed.\n \"Incomplete\" Validation of configuration has failed due to missing configuration.\n \"Installed\" Validation has passed and configuration has been installed in data path or K8s\n \"Down\" Configuration is operationally down. e.g. down interface\n \"Disabled\" Configuration is administratively disabled i.e. ObjectMetaType.Disable = true.\n \"NotApplicable\" Configuration is not applicable e.g. tenant service_policy_set(s) in system namespace are not applicable on REs\n\nExample: - \"Failed\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.in: [\\\"Success\\\",\\\"Failed\\\",\\\"Incomplete\\\",\\\"Installed\\\",\\\"Down\\\",\\\"Disabled\\\",\\\"NotApplicable\\\"]\n",
                    "title": "status",
                    "x-displayname": "Status",
                    "x-ves-example": "Failed",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.in": "[\\\"Success\\\",\\\"Failed\\\",\\\"Incomplete\\\",\\\"Installed\\\",\\\"Down\\\",\\\"Disabled\\\",\\\"NotApplicable\\\"]"
                    }
                },
                "type": {
                    "type": "string",
                    "description": " Type of the condition\n \"Validation\" represents validation user given configuration object\n \"Operational\" represents operational status of a given configuration object\n\nExample: - \"Operational\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.in: [\\\"Validation\\\",\\\"Operational\\\"]\n",
                    "title": "type",
                    "x-displayname": "Type",
                    "x-ves-example": "Operational",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.in": "[\\\"Validation\\\",\\\"Operational\\\"]"
                    }
                }
            }
        },
        "schemaErrorCode": {
            "type": "string",
            "description": "Union of all possible error-codes from system\n\n - EOK: No error\n - EPERMS: Permissions error\n - EBADINPUT: Input is not correct\n - ENOTFOUND: Not found\n - EEXISTS: Already exists\n - EUNKNOWN: Unknown/catchall error\n - ESERIALIZE: Error in serializing/de-serializing\n - EINTERNAL: Server error\n - EPARTIAL: Partial error",
            "title": "ErrorCode",
            "enum": [
                "EOK",
                "EPERMS",
                "EBADINPUT",
                "ENOTFOUND",
                "EEXISTS",
                "EUNKNOWN",
                "ESERIALIZE",
                "EINTERNAL",
                "EPARTIAL"
            ],
            "default": "EOK",
            "x-displayname": "Error Code",
            "x-ves-proto-enum": "ves.io.schema.ErrorCode"
        },
        "schemaErrorType": {
            "type": "object",
            "description": "Information about a error in API operation",
            "title": "ErrorType",
            "x-displayname": "Error Type",
            "x-ves-proto-message": "ves.io.schema.ErrorType",
            "properties": {
                "code": {
                    "description": " A simple general code by category",
                    "title": "code",
                    "$ref": "#/definitions/schemaErrorCode",
                    "x-displayname": "Code"
                },
                "error_obj": {
                    "description": " A structured error object for machine parsing",
                    "title": "error_obj",
                    "$ref": "#/definitions/protobufAny",
                    "x-displayname": "Error Object"
                },
                "message": {
                    "type": "string",
                    "description": " A human readable string of the error\n\nExample: - \"value\"-",
                    "title": "message",
                    "x-displayname": "Message",
                    "x-ves-example": "value"
                }
            }
        },
        "schemaHttpMethod": {
            "type": "string",
            "description": "Specifies the HTTP method used to access a resource.\n\nAny HTTP Method",
            "title": "HttpMethod",
            "enum": [
                "ANY",
                "GET",
                "HEAD",
                "POST",
                "PUT",
                "DELETE",
                "CONNECT",
                "OPTIONS",
                "TRACE",
                "PATCH",
                "COPY"
            ],
            "default": "ANY",
            "x-displayname": "HTTP Method",
            "x-ves-proto-enum": "ves.io.schema.HttpMethod"
        },
        "schemaHttpStatusCode": {
            "type": "string",
            "description": "x-displayName: \"HTTP Status Code\"\nHTTP response status codes\n\n - EmptyStatusCode: x-displayName: \"0 Empty Status Code\"\nEmptyStatusCode response codes means it is not specified\n - Continue: x-displayName: \"100 Continue\"\nContinue status code\n - OK: x-displayName: \"200 OK\"\nOK status code\n - Created: x-displayName: \"201 Created\"\nCreated status code\n - Accepted: x-displayName: \"202 Accepted\"\nAccepted status code\n - NonAuthoritativeInformation: x-displayName: \"203 Non Authoritative Information\"\nNon Authoritative Information status code\n - NoContent: x-displayName: \"204 No Content\"\nNo Content status code\n - ResetContent: x-displayName: \"205 Reset Content\"\nReset Content status code\n - PartialContent: x-displayName: \"206 Partial Content\"\nPartial Content status code\n - MultiStatus: x-displayName: \"207 Multi Status\"\nMulti Status status code\n - AlreadyReported: x-displayName: \"208 Already Reported\"\nAlready Reported status code\n - IMUsed: x-displayName: \"226 Im Used\"\nIm Used status code\n - MultipleChoices: x-displayName: \"300 Multiple Choices\"\nMultiple Choices status code\n - MovedPermanently: x-displayName: \"301 Moved Permanently\"\nMoved Permanently status code\n - Found: x-displayName: \"302 Found\"\nFound status code\n - SeeOther: x-displayName: \"303 See Other\"\nSee Other status code\n - NotModified: x-displayName: \"304 Not Modified\"\nNot Modified status code\n - UseProxy: x-displayName: \"305 Use Proxy\"\nUse Proxy status code\n - TemporaryRedirect: x-displayName: \"307 Temporary Redirect\"\nTemporary Redirect status code\n - PermanentRedirect: x-displayName: \"308 Permanent Redirect\"\nPermanent Redirect status code\n - BadRequest: x-displayName: \"400 Bad Request\"\nBad Request status code\n - Unauthorized: x-displayName: \"401 Unauthorized\"\nUnauthorized status code\n - PaymentRequired: x-displayName: \"402 Payment Required\"\nPayment Required status code\n - Forbidden: x-displayName: \"403 Forbidden\"\nForbidden status code\n - NotFound: x-displayName: \"404 Not Found\"\nNot Found status code\n - MethodNotAllowed: x-displayName: \"405 Method Not Allowed\"\nMethod Not Allowed status code\n - NotAcceptable: x-displayName: \"406 Not Acceptable\"\nNot Acceptable status code\n - ProxyAuthenticationRequired: x-displayName: \"407 Proxy Authentication Required\"\nProxy Authentication Required status code\n - RequestTimeout: x-displayName: \"408 Request Timeout\"\nRequest Timeout status code\n - Conflict: x-displayName: \"409 Conflict\"\nConflict status code\n - Gone: x-displayName: \"410 Gone\"\nGone status code\n - LengthRequired: x-displayName: \"411 Length Required\"\nLength Required status code\n - PreconditionFailed: x-displayName: \"412 Precondition Failed\"\nPrecondition Failed status code\n - PayloadTooLarge: x-displayName: \"413 Payload Too Large\"\nPayload Too Large status code\n - URITooLong: x-displayName: \"414 Uri Too Long\"\nUri Too Long status code\n - UnsupportedMediaType: x-displayName: \"415 Unsupported Media Type\"\nUnsupported Media Type status code\n - RangeNotSatisfiable: x-displayName: \"416 Range Not Satisfiable\"\nRange Not Satisfiable status code\n - ExpectationFailed: x-displayName: \"417 Expectation Failed\"\nExpectation Failed status code\n - MisdirectedRequest: x-displayName: \"421 Misdirected Request\"\nMisdirected Request status code\n - UnprocessableEntity: x-displayName: \"422 Unprocessable Entity\"\nUnprocessable Entity status code\n - Locked: x-displayName: \"423 Locked\"\nLocked status code\n - FailedDependency: x-displayName: \"424 Failed Dependency\"\nFailed Dependency status code\n - UpgradeRequired: x-displayName: \"426 Upgrade Required\"\nUpgrade Required status code\n - PreconditionRequired: x-displayName: \"428 Precondition Required\"\nPrecondition Required status code\n - TooManyRequests: x-displayName: \"429 Too Many Requests\"\nToo Many Requests status code\n - RequestHeaderFieldsTooLarge: x-displayName: \"431 Request Header Fields Too Large\"\nRequest Header Fields Too Large status code\n - InternalServerError: x-displayName: \"500 Internal Server Error\"\nInternal Server Error status code\n - NotImplemented: x-displayName: \"501 Not Implemented\"\nNot Implemented status code\n - BadGateway: x-displayName: \"502 Bad Gateway\"\nBad Gateway status code\n - ServiceUnavailable: x-displayName: \"503 Service Unavailable\"\nService Unavailable status code\n - GatewayTimeout: x-displayName: \"504 Gateway Timeout\"\nGateway Timeout status code\n - HTTPVersionNotSupported: x-displayName: \"505 Http Version Not Supported\"\nHttp Version Not Supported status code\n - VariantAlsoNegotiates: x-displayName: \"506 Variant Also Negotiates\"\nVariant Also Negotiates status code\n - InsufficientStorage: x-displayName: \"507 Insufficient Storage\"\nInsufficient Storage status code\n - LoopDetected: x-displayName: \"508 Loop Detected\"\nLoop Detected status code\n - NotExtended: x-displayName: \"510 Not Extended\"\nNot Extended status code\n - NetworkAuthenticationRequired: x-displayName: \"511 Network Authentication Required\"\nNetwork Authentication Required status code",
            "title": "HttpStatusCode",
            "enum": [
                "EmptyStatusCode",
                "Continue",
                "OK",
                "Created",
                "Accepted",
                "NonAuthoritativeInformation",
                "NoContent",
                "ResetContent",
                "PartialContent",
                "MultiStatus",
                "AlreadyReported",
                "IMUsed",
                "MultipleChoices",
                "MovedPermanently",
                "Found",
                "SeeOther",
                "NotModified",
                "UseProxy",
                "TemporaryRedirect",
                "PermanentRedirect",
                "BadRequest",
                "Unauthorized",
                "PaymentRequired",
                "Forbidden",
                "NotFound",
                "MethodNotAllowed",
                "NotAcceptable",
                "ProxyAuthenticationRequired",
                "RequestTimeout",
                "Conflict",
                "Gone",
                "LengthRequired",
                "PreconditionFailed",
                "PayloadTooLarge",
                "URITooLong",
                "UnsupportedMediaType",
                "RangeNotSatisfiable",
                "ExpectationFailed",
                "MisdirectedRequest",
                "UnprocessableEntity",
                "Locked",
                "FailedDependency",
                "UpgradeRequired",
                "PreconditionRequired",
                "TooManyRequests",
                "RequestHeaderFieldsTooLarge",
                "InternalServerError",
                "NotImplemented",
                "BadGateway",
                "ServiceUnavailable",
                "GatewayTimeout",
                "HTTPVersionNotSupported",
                "VariantAlsoNegotiates",
                "InsufficientStorage",
                "LoopDetected",
                "NotExtended",
                "NetworkAuthenticationRequired"
            ],
            "default": "EmptyStatusCode"
        },
        "schemaInitializerType": {
            "type": "object",
            "description": "Initializer is information about an initializer that has not yet completed.",
            "title": "InitializerType",
            "x-displayname": "Initializer",
            "x-ves-proto-message": "ves.io.schema.InitializerType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " name of the service that is responsible for initializing this object.",
                    "title": "name",
                    "x-displayname": "Name"
                }
            }
        },
        "schemaInitializersType": {
            "type": "object",
            "description": "Initializers tracks the progress of initialization of a configuration object",
            "title": "InitializersType",
            "x-displayname": "Initializers",
            "x-ves-proto-message": "ves.io.schema.InitializersType",
            "properties": {
                "pending": {
                    "type": "array",
                    "description": " Pending is a list of initializers that must execute in order before this object is initialized.\n When the last pending initializer is removed, and no failing result is set, the initializers\n struct will be set to nil and the object is considered as initialized and visible to all\n clients.",
                    "title": "pending",
                    "items": {
                        "$ref": "#/definitions/schemaInitializerType"
                    },
                    "x-displayname": "Pending"
                },
                "result": {
                    "description": " If result is set with the Failure field, the object will be persisted to storage and then deleted,\n ensuring that other clients can observe the deletion.",
                    "title": "result",
                    "$ref": "#/definitions/schemaStatusType",
                    "x-displayname": "Result"
                }
            }
        },
        "schemaLabelMatcherType": {
            "type": "object",
            "description": "A label matcher specifies a list of label keys whose values need to match for\nsource/client and destination/server. Note that the actual label values are not\nspecified and do not matter. This allows an ability to scope grouping by the\nlabel key name.",
            "title": "LabelMatcherType",
            "x-displayname": "Label Matcher",
            "x-ves-proto-message": "ves.io.schema.LabelMatcherType",
            "properties": {
                "keys": {
                    "type": "array",
                    "description": " The list of label key names that have to match\n\nExample: - \"['environment', 'location', 'deployment']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_len: 64\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "keys",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 64
                    },
                    "x-displayname": "Keys",
                    "x-ves-example": "['environment', 'location', 'deployment']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_len": "64",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemaLabelSelectorType": {
            "type": "object",
            "description": "This type can be used to establish a 'selector reference' from one object(called selector) to\na set of other objects(called selectees) based on the value of expresssions.\nA label selector is a label query over a set of resources. An empty label selector matches all objects.\nA null label selector matches no objects. Label selector is immutable.\nexpressions is a list of strings of label selection expression.\nEach string has \",\" separated values which are \"AND\" and all strings are logically \"OR\".\nBNF for expression string\n\u003cselector-syntax\u003e         ::= \u003crequirement\u003e | \u003crequirement\u003e \",\" \u003cselector-syntax\u003e\n\u003crequirement\u003e             ::= [!] KEY [ \u003cset-based-restriction\u003e | \u003cexact-match-restriction\u003e ]\n\u003cset-based-restriction\u003e   ::= \"\" | \u003cinclusion-exclusion\u003e \u003cvalue-set\u003e\n\u003cinclusion-exclusion\u003e     ::= \u003cinclusion\u003e | \u003cexclusion\u003e\n\u003cexclusion\u003e               ::= \"notin\"\n\u003cinclusion\u003e               ::= \"in\"\n\u003cvalue-set\u003e               ::= \"(\" \u003cvalues\u003e \")\"\n\u003cvalues\u003e                  ::= VALUE | VALUE \",\" \u003cvalues\u003e\n\u003cexact-match-restriction\u003e ::= [\"=\"|\"==\"|\"!=\"] VALUE",
            "title": "LabelSelectorType",
            "x-displayname": "Label Selector",
            "x-ves-proto-message": "ves.io.schema.LabelSelectorType",
            "properties": {
                "expressions": {
                    "type": "array",
                    "description": " expressions contains the kubernetes style label expression for selections.\n\nExample: - \"region in (us-west1, us-west2),tier in (staging)\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.k8s_label_selector: true\n  ves.io.schema.rules.repeated.items.string.max_len: 4096\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.max_items: 1\n",
                    "title": "expressions",
                    "maxItems": 1,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 4096
                    },
                    "x-displayname": "Selector Expression",
                    "x-ves-example": "region in (us-west1, us-west2),tier in (staging)",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.k8s_label_selector": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "4096",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.max_items": "1"
                    }
                }
            }
        },
        "schemaMessageMetaType": {
            "type": "object",
            "description": "MessageMetaType is metadata (common attributes) of a message that only certain messages\nhave. This information is propagated to the metadata of a child object that gets created\nfrom the containing message during view processing.\nThe information in this type can be specified by user during create and replace APIs.",
            "title": "MessageMetaType",
            "x-displayname": "Message Metadata",
            "x-ves-proto-message": "ves.io.schema.MessageMetaType",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " Human readable description.\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "description",
                    "maxLength": 256,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of the message.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.min_len: 1\n  ves.io.schema.rules.string.ves_object_name: true\n",
                    "title": "name",
                    "minLength": 1,
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.min_len": "1",
                        "ves.io.schema.rules.string.ves_object_name": "true"
                    }
                }
            }
        },
        "schemaObjectCreateMetaType": {
            "type": "object",
            "description": "ObjectCreateMetaType is metadata that can be specified in Create request of an object.",
            "title": "ObjectCreateMetaType",
            "x-displayname": "Create Metadata",
            "x-ves-proto-message": "ves.io.schema.ObjectCreateMetaType",
            "properties": {
                "annotations": {
                    "type": "object",
                    "description": " Annotations is an unstructured key value map stored with a resource that may be\n set by external tools to store and retrieve arbitrary metadata. They are not\n queryable and should be preserved when modifying objects.\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 64\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.values.string.max_len: 1024\n  ves.io.schema.rules.map.values.string.min_len: 1\n",
                    "title": "annotations",
                    "x-displayname": "Annotation",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "64",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.values.string.max_len": "1024",
                        "ves.io.schema.rules.map.values.string.min_len": "1"
                    }
                },
                "description": {
                    "type": "string",
                    "description": " Human readable description for the object\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 1200\n",
                    "title": "description",
                    "maxLength": 1200,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "1200"
                    }
                },
                "disable": {
                    "type": "boolean",
                    "description": " A value of true will administratively disable the object\n\nExample: - \"true\"-",
                    "title": "disable",
                    "format": "boolean",
                    "x-displayname": "Disable"
                },
                "labels": {
                    "type": "object",
                    "description": " Map of string keys and values that can be used to organize and categorize\n (scope and select) objects as chosen by the user. Values specified here will be used\n by selector expression\n\nExample: - \"value\"-",
                    "title": "labels",
                    "x-displayname": "Labels"
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of configuration object. It has to be unique within the namespace.\n It can only be specified during create API and cannot be changed during replace API.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " This defines the workspace within which each the configuration object is to be created.\n Must be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"\n\nExample: - \"staging\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "staging"
                }
            }
        },
        "schemaObjectGetMetaType": {
            "type": "object",
            "description": "ObjectGetMetaType is metadata that can be specified in Get/Create response of an object.",
            "title": "ObjectGetMetaType",
            "x-displayname": "Get Metadata",
            "x-ves-proto-message": "ves.io.schema.ObjectGetMetaType",
            "properties": {
                "annotations": {
                    "type": "object",
                    "description": " Annotations is an unstructured key value map stored with a resource that may be\n set by external tools to store and retrieve arbitrary metadata. They are not\n queryable and should be preserved when modifying objects.\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 64\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.values.string.max_len: 1024\n  ves.io.schema.rules.map.values.string.min_len: 1\n",
                    "title": "annotations",
                    "x-displayname": "Annotation",
                    "x-ves-example": "value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "64",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.values.string.max_len": "1024",
                        "ves.io.schema.rules.map.values.string.min_len": "1"
                    }
                },
                "description": {
                    "type": "string",
                    "description": " Human readable description for the object\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 1200\n",
                    "title": "description",
                    "maxLength": 1200,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "1200"
                    }
                },
                "disable": {
                    "type": "boolean",
                    "description": " A value of true will administratively disable the object\n\nExample: - \"true\"-",
                    "title": "disable",
                    "format": "boolean",
                    "x-displayname": "Disable",
                    "x-ves-example": "true"
                },
                "labels": {
                    "type": "object",
                    "description": " Map of string keys and values that can be used to organize and categorize\n (scope and select) objects as chosen by the user. Values specified here will be used\n by selector expression\n\nExample: - \"value\"-",
                    "title": "labels",
                    "x-displayname": "Labels",
                    "x-ves-example": "value"
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of configuration object. It has to be unique within the namespace.\n It can only be specified during create API and cannot be changed during replace API.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " This defines the workspace within which each the configuration object is to be created.\n Must be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"\n\nExample: - \"staging\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "staging"
                }
            }
        },
        "schemaObjectReplaceMetaType": {
            "type": "object",
            "description": "ObjectReplaceMetaType is metadata that can be specified in Replace request of an object.",
            "title": "ObjectReplaceMetaType",
            "x-displayname": "Replace Metadata",
            "x-ves-proto-message": "ves.io.schema.ObjectReplaceMetaType",
            "properties": {
                "annotations": {
                    "type": "object",
                    "description": " Annotations is an unstructured key value map stored with a resource that may be\n set by external tools to store and retrieve arbitrary metadata. They are not\n queryable and should be preserved when modifying objects.\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 64\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.values.string.max_len: 1024\n  ves.io.schema.rules.map.values.string.min_len: 1\n",
                    "title": "annotations",
                    "x-displayname": "Annotations",
                    "x-ves-example": "value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "64",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.values.string.max_len": "1024",
                        "ves.io.schema.rules.map.values.string.min_len": "1"
                    }
                },
                "description": {
                    "type": "string",
                    "description": " Human readable description for the object\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 1200\n",
                    "title": "description",
                    "maxLength": 1200,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "1200"
                    }
                },
                "disable": {
                    "type": "boolean",
                    "description": " A value of true will administratively disable the object\n\nExample: - \"true\"-",
                    "title": "disable",
                    "format": "boolean",
                    "x-displayname": "Disable"
                },
                "labels": {
                    "type": "object",
                    "description": " Map of string keys and values that can be used to organize and categorize\n (scope and select) objects as chosen by the user. Values specified here will be used\n by selector expression\n\nExample: - \"value\"-",
                    "title": "labels",
                    "x-displayname": "Labels",
                    "x-ves-example": "value"
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of configuration object. It has to be unique within the namespace.\n It can only be specified during create API and cannot be changed during replace API.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " This defines the workspace within which each the configuration object is to be created.\n Must be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"\n\nExample: - \"staging\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "staging"
                }
            }
        },
        "schemaOpenApiValidationProperties": {
            "type": "string",
            "description": "x-displayName: \"OpenAPI Validation Properties\"\nList of required properties to validate against the OpenAPI spec\n\n - PROPERTY_QUERY_PARAMETERS: x-displayName: \"Query Parameters\"\nValidate that all query parameters are according to the OpenAPI specification\n - PROPERTY_PATH_PARAMETERS: x-displayName: \"Path Parameters\"\nValidate that all path parameters are according to the OpenAPI specification\n - PROPERTY_CONTENT_TYPE: x-displayName: \"Content-type\"\nValidate that the content type of the request is according to the OpenAPI specification\n - PROPERTY_COOKIE_PARAMETERS: x-displayName: \"Cookie Parameters\"\nValidate that all cookies are according to the OpenAPI specification\n - PROPERTY_HTTP_HEADERS: x-displayName: \"HTTP Headers\"\nValidate that all HTTP headers are according to the OpenAPI specification\n - PROPERTY_HTTP_BODY: x-displayName: \"HTTP Body\"\nValidate that the body is according to the OpenAPI specification\n - PROPERTY_SECURITY_SCHEMA: x-displayName: \"Security Schema\"\nValidate that the security schema is according to the OpenAPI specification\n - PROPERTY_RESPONSE_CODE: x-displayName: \"Response Code\"\nValidate that the response code is according to the OpenAPI specification",
            "title": "OpenApiValidationProperties",
            "enum": [
                "PROPERTY_QUERY_PARAMETERS",
                "PROPERTY_PATH_PARAMETERS",
                "PROPERTY_CONTENT_TYPE",
                "PROPERTY_COOKIE_PARAMETERS",
                "PROPERTY_HTTP_HEADERS",
                "PROPERTY_HTTP_BODY",
                "PROPERTY_SECURITY_SCHEMA",
                "PROPERTY_RESPONSE_CODE"
            ],
            "default": "PROPERTY_QUERY_PARAMETERS"
        },
        "schemaStatusMetaType": {
            "type": "object",
            "description": "StatusMetaType is metadata that all status must have.",
            "title": "StatusMetaType",
            "x-displayname": "Metadata",
            "x-ves-proto-message": "ves.io.schema.StatusMetaType",
            "properties": {
                "creation_timestamp": {
                    "type": "string",
                    "description": " creation_timestamp is when the status object was created. It is used to find/tie-break\n for latest status object from same origin",
                    "title": "creation_timestamp",
                    "format": "date-time",
                    "x-displayname": "Creation Timestamp"
                },
                "creator_class": {
                    "type": "string",
                    "description": " Class of creator which created this StatusObject. This will be service's DNS FQDN.\n This will be set by the system based on client certificate information.\n\nExample: - \"ver.re1.int.ves.io\"-",
                    "title": "creator_class",
                    "x-displayname": "Creator Class",
                    "x-ves-example": "ver.re1.int.ves.io"
                },
                "creator_id": {
                    "type": "string",
                    "description": " ID of creator which created this StatusObject. This will be a concrete identifier for service (e.g.\n identifying the environment also). This will be set by the system based on client certificate\n information\n\nExample: - \"ver-instance-1\"-",
                    "title": "creator_id",
                    "x-displayname": "Creator ID",
                    "x-ves-example": "ver-instance-1"
                },
                "publish": {
                    "description": " Decides wether this status object will be propagated to user.",
                    "title": "publish",
                    "$ref": "#/definitions/schemaStatusPublishType",
                    "x-displayname": "Publish"
                },
                "status_id": {
                    "type": "string",
                    "description": " status_id is a field used by the generator to distinguish (if necessary) between two status\n objects for the same config object from the same site and same service and potentially same\n daemon(creator-id)",
                    "title": "status_id",
                    "x-displayname": "Status ID"
                },
                "uid": {
                    "type": "string",
                    "description": " uid is the unique in time and space value for a StatusObject.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                },
                "vtrp_id": {
                    "type": "string",
                    "description": " Origin of this status exchanged by VTRP.",
                    "title": "vtrp_id",
                    "x-displayname": "VTRP ID"
                },
                "vtrp_stale": {
                    "type": "boolean",
                    "description": " Indicate whether mars deems this object to be stale via graceful restart timer information",
                    "title": "vtrp_stale",
                    "format": "boolean",
                    "x-displayname": "VTRP Stale"
                }
            }
        },
        "schemaStatusPublishType": {
            "type": "string",
            "description": "StatusPublishType is all possible publish operations on a StatusObject\n\n - STATUS_DO_NOT_PUBLISH: Do Not Publish\n\nDo not propagate this status to user. This could be because status is only informational\n - STATUS_PUBLISH: Publish\n\nPropagate this status up to user as it might be actionable",
            "title": "StatusPublishType",
            "enum": [
                "STATUS_DO_NOT_PUBLISH",
                "STATUS_PUBLISH"
            ],
            "default": "STATUS_DO_NOT_PUBLISH",
            "x-displayname": "Status Publish Type",
            "x-ves-proto-enum": "ves.io.schema.StatusPublishType"
        },
        "schemaStatusType": {
            "type": "object",
            "description": "Status is a return value for calls that don't return other objects.",
            "title": "StatusType",
            "x-displayname": "Status",
            "x-ves-proto-message": "ves.io.schema.StatusType",
            "properties": {
                "code": {
                    "type": "integer",
                    "description": " Suggested HTTP return code for this status, 0 if not set.\n\nExample: - \"0\"-",
                    "title": "code",
                    "format": "int32",
                    "x-displayname": "Code",
                    "x-ves-example": "0"
                },
                "reason": {
                    "type": "string",
                    "description": " A human-readable description of why this operation is in the\n \"Failure\" status. If this value is empty there\n is no information available.\n\nExample: - \"value\"-",
                    "title": "reason",
                    "x-displayname": "Reason",
                    "x-ves-example": "value"
                },
                "status": {
                    "type": "string",
                    "description": " Status of the operation.\n One of: \"Success\" or \"Failure\".\n\nExample: - \"value\"-",
                    "title": "status",
                    "x-displayname": "Status",
                    "x-ves-example": "value"
                }
            }
        },
        "schemaSystemObjectGetMetaType": {
            "type": "object",
            "description": "SystemObjectGetMetaType is metadata generated or populated by the system for all persisted objects and\ncannot be updated directly by users.",
            "title": "SystemObjectGetMetaType",
            "x-displayname": "System Metadata",
            "x-ves-proto-message": "ves.io.schema.SystemObjectGetMetaType",
            "properties": {
                "creation_timestamp": {
                    "type": "string",
                    "description": " CreationTimestamp is a timestamp representing the server time when this object was\n created. It is not guaranteed to be set in happens-before order across separate operations.\n Clients may not set this value. It is represented in RFC3339 form and is in UTC.",
                    "title": "creation_timestamp",
                    "format": "date-time",
                    "x-displayname": "Creation Timestamp"
                },
                "creator_class": {
                    "type": "string",
                    "description": " A value identifying the class of the user or service which created this configuration object.\n\nExample: - \"value\"-",
                    "title": "creator_class",
                    "x-displayname": "Creator Class",
                    "x-ves-example": "prism"
                },
                "creator_id": {
                    "type": "string",
                    "description": " A value identifying the exact user or service that created this configuration object\n\nExample: - \"value\"-",
                    "title": "creator_id",
                    "x-displayname": "Creator ID",
                    "x-ves-example": "admin@acmecorp.com"
                },
                "deletion_timestamp": {
                    "type": "string",
                    "description": " DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This\n field is set by the server when a graceful deletion is requested by the user, and is not\n directly settable by a client. The resource is expected to be deleted (no longer visible\n from resource lists, and not reachable by name) after the time in this field, once the\n finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.\n Once the deletionTimestamp is set, this value may not be unset or be set further into the\n future, although it may be shortened or the resource may be deleted prior to this time.\n For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react\n by sending a graceful termination signal to the containers in the pod. After that 30 seconds,\n the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,\n remove the pod from the API. In the presence of network partitions, this object may still\n exist after this timestamp, until an administrator or automated process can determine the\n resource is fully terminated.\n If not set, graceful deletion of the object has not been requested.\n\n Populated by the system when a graceful deletion is requested.\n Read-only.",
                    "title": "deletion_timestamp",
                    "format": "date-time",
                    "x-displayname": "Deletion Timestamp"
                },
                "finalizers": {
                    "type": "array",
                    "description": " Must be empty before the object is deleted from the registry. Each entry\n is an identifier for the responsible component that will remove the entry\n from the list. If the deletionTimestamp of the object is non-nil, entries\n in this list can only be removed.\n\nExample: - \"value\"-",
                    "title": "finalizers",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Finalizers",
                    "x-ves-example": "value"
                },
                "initializers": {
                    "description": " An initializer is a controller which enforces some system invariant at object creation time.\n This field is a list of initializers that have not yet acted on this object. If nil or empty,\n this object has been completely initialized. Otherwise, the object is considered uninitialized\n and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to\n observe uninitialized objects.\n\n When an object is created, the system will populate this list with the current set of initializers.\n Only privileged users may set or modify this list. Once it is empty, it may not be modified further\n by any user.",
                    "title": "initializers",
                    "$ref": "#/definitions/schemaInitializersType",
                    "x-displayname": "Initializers"
                },
                "labels": {
                    "type": "object",
                    "description": " Map of string keys and values that can be used to organize and categorize\n (scope and select) objects as chosen by the operator or software. Values here can be interpreted\n by software(backend or frontend) to enable certain behavior e.g. things marked as soft-deleted(restorable).\n\nExample: - \"'ves.io/soft-deleted''true'\"-",
                    "title": "labels",
                    "x-displayname": "Labels",
                    "x-ves-example": "'ves.io/soft-deleted': 'true'"
                },
                "modification_timestamp": {
                    "type": "string",
                    "description": " ModificationTimestamp is a timestamp representing the server time when this object was\n last modified.",
                    "title": "modification_timestamp",
                    "format": "date-time",
                    "x-displayname": "Modification Timestamp"
                },
                "object_index": {
                    "type": "integer",
                    "description": " Unique index for the object. Some objects need a unique integer index to be allocated\n for each object type. This field will be populated for all objects that need it and will\n be zero otherwise.\n\nExample: - \"0\"-",
                    "title": "object_index",
                    "format": "int64",
                    "x-displayname": "Object Index",
                    "x-ves-example": "0"
                },
                "owner_view": {
                    "description": " Reference to the view object that owns this object.\n If there is no view owner, this field will be nil.\n If not nil, this object can only be edited/deleted through the view",
                    "title": "owner_view",
                    "$ref": "#/definitions/schemaViewRefType",
                    "x-displayname": "Owner View"
                },
                "tenant": {
                    "type": "string",
                    "description": " Tenant to which this configuration object belongs to. The value for this is found from\n presented credentials.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " uid is the unique in time and space value for this object. It is generated by\n the server on successful creation of an object and is not allowed to change on Replace\n API. The value of is taken from uid field of ObjectMetaType, if provided.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "schemaViewRefType": {
            "type": "object",
            "description": "ViewRefType represents a reference to a view",
            "title": "ViewRefType",
            "x-displayname": "View Reference",
            "x-ves-proto-message": "ves.io.schema.ViewRefType",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": " Kind of the view object\n\nExample: - \"http_proxy\"-",
                    "title": "kind",
                    "x-displayname": "Kind",
                    "x-ves-example": "http_proxy"
                },
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contactus-route\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contactus-route"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "uid": {
                    "type": "string",
                    "description": " UID of the view object\n\nExample: - \"f3744323-1adf-4aaa-a5dc-0707c1d1bd82\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "f3744323-1adf-4aaa-a5dc-0707c1d1bd82"
                }
            }
        },
        "schemapolicyBotAction": {
            "type": "object",
            "description": "Modify Bot protection behavior for a matching request. The modification could be to entirely skip Bot processing.",
            "title": "Bot Action",
            "x-displayname": "Bot Action",
            "x-ves-oneof-field-action_type": "[\"bot_skip_processing\",\"none\"]",
            "x-ves-proto-message": "ves.io.schema.policy.BotAction",
            "properties": {
                "bot_skip_processing": {
                    "description": "Exclusive with [none]\n Skip all Bot processing for this request",
                    "title": "Skip Bot Processing",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip Bot Processing"
                },
                "none": {
                    "description": "Exclusive with [bot_skip_processing]\n Perform normal Bot processing for this request",
                    "title": "Normal Bot Processing",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Do not modify Bot Processing"
                }
            }
        },
        "schemapolicyHeaderMatcherType": {
            "type": "object",
            "description": "A header matcher specifies the name of a single HTTP header and the criteria for the input request to match it. The input has a list of actual values for each\nheader name in the original HTTP request.\nA header matcher can check for one of the following:\n* Presence or absence of the header in the input\n* At least one of the values for the header in the input satisfies the MatcherType item",
            "title": "HeaderMatcherType",
            "x-displayname": "Header Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.HeaderMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the header is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the header is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Header Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the header. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " A case-insensitive HTTP header name.\n\nExample: - \"Accept-Encoding\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_header_field: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Header Name",
                    "x-ves-example": "Accept-Encoding",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_header_field": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "schemapolicyPathMatcherType": {
            "type": "object",
            "description": "A path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.",
            "title": "PathMatcherType",
            "x-displayname": "Path Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.PathMatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact path values to match the input HTTP path against.\n\nExample: - \"['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.http_path: true\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.http_path": "true",
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Path Matcher"
                },
                "prefix_values": {
                    "type": "array",
                    "description": " A list of path prefix values to match the input HTTP path against.\n\nExample: - \"['/api/web/namespaces/project179/users/', '/api/config/namespaces/', '/api/data/namespaces/']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.http_path: true\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "prefix values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Prefix Values",
                    "x-ves-example": "['/api/web/namespaces/project179/users/', '/api/config/namespaces/', '/api/data/namespaces/']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.http_path": "true",
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input HTTP path against.\n\nExample: - \"['^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$', '/api/data/namespaces/proj404/virtual_hosts/([a-z]([-a-z0-9]*[a-z0-9])?)$']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "regex values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$', '/api/data/namespaces/proj404/virtual_hosts/([a-z]([-a-z0-9]*[a-z0-9])?)$']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "suffix_values": {
                    "type": "array",
                    "description": " A list of path suffix values to match the input HTTP path against.\n\nExample: - \"['.exe', '.shtml', '.wmz']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 64\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Suffix values",
                    "maxItems": 64,
                    "items": {
                        "type": "string",
                        "maxLength": 64
                    },
                    "x-displayname": "Suffix Values",
                    "x-ves-example": "['.exe', '.shtml', '.wmz']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "64",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "transformers": {
                    "type": "array",
                    "description": " An ordered list of transformers (starting from index 0) to be applied to the path before matching.\n\nExample: - \"[BASE64_DECODE, LOWER_CASE]-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 9\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "transformers",
                    "maxItems": 9,
                    "items": {
                        "$ref": "#/definitions/policyTransformer"
                    },
                    "x-displayname": "Transformers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "9",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemapolicyPortMatcherType": {
            "type": "object",
            "description": "A port matcher specifies a list of port ranges as match criteria. The match is considered successful if the input port falls within any of the port ranges.\nThe result of the match is inverted if invert_matcher is true.",
            "title": "port matcher type",
            "x-displayname": "Port Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.PortMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Port Matcher"
                },
                "ports": {
                    "type": "array",
                    "description": " A list of strings, each of which is a single port value or a tuple of start and end port values separated by \"-\". The start and end values are considered\n to be part of the range.\n\nExample: - \"8000-8191\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.port_range: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "port ranges",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Port Ranges",
                    "x-ves-example": "8000-8191",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.port_range": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemapolicyQueryParameterMatcherType": {
            "type": "object",
            "description": "A query parameter matcher specifies the name of a single query parameter and the criteria for the input request to match it. The input has a list of actual\nvalues for each query parameter name in the original HTTP request.\nA query parameter matcher can check for one of the following:\n* Presence or absence of the query parameter in the input\n* At least one of the values for the query parameter in the input satisfies the MatcherType item",
            "title": "QueryParameterMatcherType",
            "x-displayname": "Query Parameter Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.QueryParameterMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the query parameter is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the query parameter is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Query Parameter Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the given query parameter. The match is successful if any of the values for the query parameter satisfies the\n criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "key": {
                    "type": "string",
                    "description": " A case-sensitive HTTP query parameter name.\n\nExample: - \"sourceid\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "key",
                    "maxLength": 256,
                    "x-displayname": "Query Parameter Name",
                    "x-ves-example": "sourceid",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "schemarate_limiterGlobalSpecType": {
            "type": "object",
            "description": "x-displayName: \"Specification\"\nShape of rate_limiter in the storage backend.",
            "title": "GlobalSpecType",
            "properties": {
                "limits": {
                    "type": "array",
                    "description": "x-displayName: \"Rate Limit Values\"\nx-required\nA list of RateLimitValues that specifies the total number of allowed requests for each specified period.",
                    "title": "limits",
                    "items": {
                        "$ref": "#/definitions/rate_limiterRateLimitValue"
                    }
                },
                "mode": {
                    "description": "x-displayName: \"Rate Limiter Mode\"\nSpecifies if the request limits are shared across all references to this rate limiter or unique rate limits are allotted for each reference.",
                    "title": "mode",
                    "$ref": "#/definitions/rate_limiterRateLimiterMode"
                },
                "user_identification": {
                    "type": "array",
                    "description": "x-displayName: \"User Identification Policy\"\nA reference to user_identification object.\nThe rules in the user_identification object are evaluated to determine the user identifier to be rate limited.",
                    "title": "user_identification",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    }
                }
            }
        },
        "schemaservice_policyCreateSpecType": {
            "type": "object",
            "description": "Create service_policy creates a new object in the storage backend for metadata.namespace.",
            "title": "Create service policy",
            "x-displayname": "Create Service Policy",
            "x-ves-oneof-field-rule_choice": "[\"allow_all_requests\",\"allow_list\",\"deny_all_requests\",\"deny_list\",\"rule_list\"]",
            "x-ves-oneof-field-server_choice": "[\"any_server\",\"server_name\",\"server_name_matcher\",\"server_selector\"]",
            "x-ves-proto-message": "ves.io.schema.service_policy.CreateSpecType",
            "properties": {
                "allow_all_requests": {
                    "description": "Exclusive with [allow_list deny_all_requests deny_list rule_list]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Allow All Requests"
                },
                "allow_list": {
                    "description": "Exclusive with [allow_all_requests deny_all_requests deny_list rule_list]\n",
                    "$ref": "#/definitions/service_policySourceList",
                    "x-displayname": "Allowed Sources"
                },
                "any_server": {
                    "description": "Exclusive with [server_name server_name_matcher server_selector]\n Any Server",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Server"
                },
                "deny_all_requests": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_list rule_list]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Deny All Requests"
                },
                "deny_list": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_all_requests rule_list]\n",
                    "$ref": "#/definitions/service_policySourceList",
                    "x-displayname": "Denied Sources"
                },
                "rule_list": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_all_requests deny_list]\n",
                    "$ref": "#/definitions/service_policyRuleList",
                    "x-displayname": "Custom Rule List"
                },
                "server_name": {
                    "type": "string",
                    "description": "Exclusive with [any_server server_name_matcher server_selector]\n The expected name of the server to which the request API is directed. The actual names for the server are extracted from the HTTP Host header and the name\n of the virtual_host to which the request is directed. If the request is directed to a virtual K8s service, the actual names also contain the name of that\n service.\n The predicate evaluates to true if any of the actual names is the same as the expected server name.\n\nExample: - \"database.production.customer.volterra.us\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "maxLength": 256,
                    "x-displayname": "Server Name",
                    "x-ves-example": "database.production.customer.volterra.us",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                },
                "server_name_matcher": {
                    "description": "Exclusive with [any_server server_name server_selector]\n A list of exact values and/or regular expressions for the expected name of the server. The actual names of server are extracted from the HTTP Host header\n and the name of the virtual_host to which the request is directed. If the request is directed to a virtual K8s service, the actual names also contain the\n name of that service.\n This is a generalized version of the server name predicate that allows the same rule to be applicable to a set of server rather than a single server.\n The predicate evaluates to true if any of the server's actual names match any of the exact values or regular expressions in the server name matcher.",
                    "$ref": "#/definitions/policyMatcherTypeBasic",
                    "x-displayname": "Group of Servers by Name"
                },
                "server_selector": {
                    "description": "Exclusive with [any_server server_name server_name_matcher]\n A label selector that describes the expected set of servers. The labels associated with the server to which the API request is directed are used to evaluate\n the label expressions in the selector. These labels are derived from the server TLS certificate and the virtual host object for the server. If the request is\n directed to a virtual K8s service, the K8s labels for the service are also included in the set of server labels.\n This is a more flexible and powerful version of the server name matcher predicate that allows a given policy to be applicable to a set of servers based on the\n server labels rather than being limited to relying on patterns in the server name.\n The predicate evaluates to true if the expressions in the label selector are true for the server labels.",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Group of Servers by Label Selector"
                }
            }
        },
        "schemaservice_policyGetSpecType": {
            "type": "object",
            "description": "Get service_policy reads a given object from storage backend for metadata.namespace.",
            "title": "Get service policy",
            "x-displayname": "Get Service Policy",
            "x-ves-oneof-field-rule_choice": "[\"allow_all_requests\",\"allow_list\",\"deny_all_requests\",\"deny_list\",\"legacy_rule_list\",\"rule_list\"]",
            "x-ves-oneof-field-server_choice": "[\"any_server\",\"server_name\",\"server_name_matcher\",\"server_selector\"]",
            "x-ves-proto-message": "ves.io.schema.service_policy.GetSpecType",
            "properties": {
                "allow_all_requests": {
                    "description": "Exclusive with [allow_list deny_all_requests deny_list legacy_rule_list rule_list]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Allow All Requests"
                },
                "allow_list": {
                    "description": "Exclusive with [allow_all_requests deny_all_requests deny_list legacy_rule_list rule_list]\n",
                    "$ref": "#/definitions/service_policySourceList",
                    "x-displayname": "Allowed Sources"
                },
                "any_server": {
                    "description": "Exclusive with [server_name server_name_matcher server_selector]\n Any Server",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Server"
                },
                "deny_all_requests": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_list legacy_rule_list rule_list]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Deny All Requests"
                },
                "deny_list": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_all_requests legacy_rule_list rule_list]\n",
                    "$ref": "#/definitions/service_policySourceList",
                    "x-displayname": "Denied Sources"
                },
                "legacy_rule_list": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_all_requests deny_list rule_list]\n",
                    "$ref": "#/definitions/service_policyLegacyRuleList",
                    "x-displayname": "Legacy Rule List"
                },
                "rule_list": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_all_requests deny_list legacy_rule_list]\n",
                    "$ref": "#/definitions/service_policyRuleList",
                    "x-displayname": "Custom Rule List"
                },
                "server_name": {
                    "type": "string",
                    "description": "Exclusive with [any_server server_name_matcher server_selector]\n The expected name of the server to which the request API is directed. The actual names for the server are extracted from the HTTP Host header and the name\n of the virtual_host to which the request is directed. If the request is directed to a virtual K8s service, the actual names also contain the name of that\n service.\n The predicate evaluates to true if any of the actual names is the same as the expected server name.\n\nExample: - \"database.production.customer.volterra.us\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "maxLength": 256,
                    "x-displayname": "Server Name",
                    "x-ves-example": "database.production.customer.volterra.us",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                },
                "server_name_matcher": {
                    "description": "Exclusive with [any_server server_name server_selector]\n A list of exact values and/or regular expressions for the expected name of the server. The actual names of server are extracted from the HTTP Host header\n and the name of the virtual_host to which the request is directed. If the request is directed to a virtual K8s service, the actual names also contain the\n name of that service.\n This is a generalized version of the server name predicate that allows the same rule to be applicable to a set of server rather than a single server.\n The predicate evaluates to true if any of the server's actual names match any of the exact values or regular expressions in the server name matcher.",
                    "$ref": "#/definitions/policyMatcherTypeBasic",
                    "x-displayname": "Group of Servers by Name"
                },
                "server_selector": {
                    "description": "Exclusive with [any_server server_name server_name_matcher]\n A label selector that describes the expected set of servers. The labels associated with the server to which the API request is directed are used to evaluate\n the label expressions in the selector. These labels are derived from the server TLS certificate and the virtual host object for the server. If the request is\n directed to a virtual K8s service, the K8s labels for the service are also included in the set of server labels.\n This is a more flexible and powerful version of the server name matcher predicate that allows a given policy to be applicable to a set of servers based on the\n server labels rather than being limited to relying on patterns in the server name.\n The predicate evaluates to true if the expressions in the label selector are true for the server labels.",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Group of Servers by Label Selector"
                }
            }
        },
        "schemaservice_policyReplaceSpecType": {
            "type": "object",
            "description": "Replace service_policy replaces an existing object in the storage backend for metadata.namespace.",
            "title": "Replace service policy",
            "x-displayname": "Replace Service Policy",
            "x-ves-oneof-field-rule_choice": "[\"allow_all_requests\",\"allow_list\",\"deny_all_requests\",\"deny_list\",\"legacy_rule_list\",\"rule_list\"]",
            "x-ves-oneof-field-server_choice": "[\"any_server\",\"server_name\",\"server_name_matcher\",\"server_selector\"]",
            "x-ves-proto-message": "ves.io.schema.service_policy.ReplaceSpecType",
            "properties": {
                "allow_all_requests": {
                    "description": "Exclusive with [allow_list deny_all_requests deny_list legacy_rule_list rule_list]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Allow All Requests"
                },
                "allow_list": {
                    "description": "Exclusive with [allow_all_requests deny_all_requests deny_list legacy_rule_list rule_list]\n",
                    "$ref": "#/definitions/service_policySourceList",
                    "x-displayname": "Allowed Sources"
                },
                "any_server": {
                    "description": "Exclusive with [server_name server_name_matcher server_selector]\n Any Server",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Server"
                },
                "deny_all_requests": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_list legacy_rule_list rule_list]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Deny All Requests"
                },
                "deny_list": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_all_requests legacy_rule_list rule_list]\n",
                    "$ref": "#/definitions/service_policySourceList",
                    "x-displayname": "Denied Sources"
                },
                "legacy_rule_list": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_all_requests deny_list rule_list]\n",
                    "$ref": "#/definitions/service_policyLegacyRuleList",
                    "x-displayname": "Legacy Rule List"
                },
                "rule_list": {
                    "description": "Exclusive with [allow_all_requests allow_list deny_all_requests deny_list legacy_rule_list]\n",
                    "$ref": "#/definitions/service_policyRuleList",
                    "x-displayname": "Custom Rule List"
                },
                "server_name": {
                    "type": "string",
                    "description": "Exclusive with [any_server server_name_matcher server_selector]\n The expected name of the server to which the request API is directed. The actual names for the server are extracted from the HTTP Host header and the name\n of the virtual_host to which the request is directed. If the request is directed to a virtual K8s service, the actual names also contain the name of that\n service.\n The predicate evaluates to true if any of the actual names is the same as the expected server name.\n\nExample: - \"database.production.customer.volterra.us\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "maxLength": 256,
                    "x-displayname": "Server Name",
                    "x-ves-example": "database.production.customer.volterra.us",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                },
                "server_name_matcher": {
                    "description": "Exclusive with [any_server server_name server_selector]\n A list of exact values and/or regular expressions for the expected name of the server. The actual names of server are extracted from the HTTP Host header\n and the name of the virtual_host to which the request is directed. If the request is directed to a virtual K8s service, the actual names also contain the\n name of that service.\n This is a generalized version of the server name predicate that allows the same rule to be applicable to a set of server rather than a single server.\n The predicate evaluates to true if any of the server's actual names match any of the exact values or regular expressions in the server name matcher.",
                    "$ref": "#/definitions/policyMatcherTypeBasic",
                    "x-displayname": "Group of Servers by Name"
                },
                "server_selector": {
                    "description": "Exclusive with [any_server server_name server_name_matcher]\n A label selector that describes the expected set of servers. The labels associated with the server to which the API request is directed are used to evaluate\n the label expressions in the selector. These labels are derived from the server TLS certificate and the virtual host object for the server. If the request is\n directed to a virtual K8s service, the K8s labels for the service are also included in the set of server labels.\n This is a more flexible and powerful version of the server name matcher predicate that allows a given policy to be applicable to a set of servers based on the\n server labels rather than being limited to relying on patterns in the server name.\n The predicate evaluates to true if the expressions in the label selector are true for the server labels.",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Group of Servers by Label Selector"
                }
            }
        },
        "schemaservice_policy_ruleGlobalSpecType": {
            "type": "object",
            "description": "Shape of service_policy_rule in the storage backend.",
            "title": "GlobalSpecType",
            "x-displayname": "Specification",
            "x-ves-oneof-field-asn_choice": "[\"any_asn\",\"asn_list\",\"asn_matcher\"]",
            "x-ves-oneof-field-client_choice": "[\"any_client\",\"client_name\",\"client_name_matcher\",\"client_selector\",\"ip_threat_category_list\"]",
            "x-ves-oneof-field-dst_asn_choice": "[]",
            "x-ves-oneof-field-dst_ip_choice": "[]",
            "x-ves-oneof-field-ip_choice": "[\"any_ip\",\"ip_matcher\",\"ip_prefix_list\"]",
            "x-ves-oneof-field-tls_fingerprint_choice": "[\"ja4_tls_fingerprint\",\"tls_fingerprint_matcher\"]",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.GlobalSpecType",
            "properties": {
                "action": {
                    "description": " Action to be enforced if the input request matches the rule.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "action",
                    "$ref": "#/definitions/policyRuleAction",
                    "x-displayname": "Action",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "any_asn": {
                    "description": "Exclusive with [asn_list asn_matcher]\n Any origin ASN.",
                    "title": "any asn",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Source ASN"
                },
                "any_client": {
                    "description": "Exclusive with [client_name client_name_matcher client_selector ip_threat_category_list]\n Any Client",
                    "title": "any ip",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Client"
                },
                "any_ip": {
                    "description": "Exclusive with [ip_matcher ip_prefix_list]\n Any Source IP",
                    "title": "any ip",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Source IP"
                },
                "api_group_matcher": {
                    "description": " The list of expected API group names to which the request API belongs. The actual list of API group names for the request API is determined from the api\n group and api group element configuration objects using the HTTP method and the HTTP path as inputs.\n The predicate evaluates to true if any of the actual API group names for the request is equal to any of the values in the api group matcher.",
                    "title": "api group matcher",
                    "$ref": "#/definitions/policyStringMatcherType",
                    "x-displayname": "API Group Matcher"
                },
                "arg_matchers": {
                    "type": "array",
                    "description": " A list of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances\n of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name.\n Note that all specified arg matcher predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "arg matchers",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyArgMatcherType"
                    },
                    "x-displayname": "Argument Matchers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "asn_list": {
                    "description": "Exclusive with [any_asn asn_matcher]\n List of 4-byte ASN values.\n The predicate evaluates to true if the origin ASN is present in the ASN list.",
                    "title": "asn list",
                    "$ref": "#/definitions/policyAsnMatchList",
                    "x-displayname": "ASN List"
                },
                "asn_matcher": {
                    "description": "Exclusive with [any_asn asn_list]\n List of references to BGP ASN Set objects.\n The predicate evaluates to true if the origin ASN is present in one of the BGP ASN Set objects.",
                    "title": "asn matcher",
                    "$ref": "#/definitions/policyAsnMatcherType",
                    "x-displayname": "BGP ASN Sets"
                },
                "body_matcher": {
                    "description": " Predicate for matching the request body string. The criteria for matching the request body is described in MatcherType.\n The actual request body value is extracted from the request API as a string.",
                    "title": "request body matcher",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Request Body Matcher"
                },
                "bot_action": {
                    "description": " Bot action to be enforced if the input request matches the rule.",
                    "title": "Bot Action",
                    "$ref": "#/definitions/schemapolicyBotAction",
                    "x-displayname": "Bot Action"
                },
                "client_name": {
                    "type": "string",
                    "description": "Exclusive with [any_client client_name_matcher client_selector ip_threat_category_list]\n The expected name of the client invoking the request API.\n The predicate evaluates to true if any of the actual names is the same as the expected client name.\n\nExample: - \"backend.production.customer.volterra.us\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "client name",
                    "maxLength": 256,
                    "x-displayname": "Client Name",
                    "x-ves-example": "backend.production.customer.volterra.us",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                },
                "client_name_matcher": {
                    "description": "Exclusive with [any_client client_name client_selector ip_threat_category_list]\n A list of exact values and/or regular expressions for the expected name of the client.\n This is a generalized version of the client name predicate that allows the same rule to be applicable to a set of clients rather than a single client.\n The predicate evaluates to true if any of the client's actual names match any of the exact values or regular expressions in the client name matcher.",
                    "title": "client name matcher",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Group of Clients by Name"
                },
                "client_selector": {
                    "description": "Exclusive with [any_client client_name client_name_matcher ip_threat_category_list]\n A label selector that describes the expected set of clients. The labels associated with the client making the API request are used to evaluate the label\n expressions in the selector. These labels can be derived from the client TLS certificate or from the volterra internal control plane.\n This is a more flexible and powerful version of the client name matcher predicate that allows a given rule to be applicable to a set of clients based on the\n client labels rather than being limited to relying on patterns in the client name.\n The predicate evaluates to true if the expressions in the label selector are true for the client labels.",
                    "title": "client selector",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Group of Clients by Label Selector"
                },
                "cookie_matchers": {
                    "type": "array",
                    "description": " A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances\n of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.\n Note that all specified cookie matcher predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "cookie matchers",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyCookieMatcherType"
                    },
                    "x-displayname": "Cookie Matchers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "domain_matcher": {
                    "description": " A list of exact values and/or regular expressions for the expected name of the domain. The actual value of domain is the host component\n from the URL. The predicate evaluates to true if the domain value matches any of the exact values or regular expressions in the domain\n matcher.",
                    "title": "domain matcher",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Domain Matcher"
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": " The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\n the configuration but is not applied anymore.\n\nExample: - \"2019-12-31:44:34.171543432Z\"-",
                    "title": "expiration timestamp",
                    "format": "date-time",
                    "x-displayname": "Expiration Timestamp",
                    "x-ves-example": "2019-12-31:44:34.171543432Z"
                },
                "headers": {
                    "type": "array",
                    "description": " A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType\n instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.\n Note that all specified header predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "headers",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemapolicyHeaderMatcherType"
                    },
                    "x-displayname": "HTTP Headers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "http_method": {
                    "description": " The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.\n The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.",
                    "title": "method",
                    "$ref": "#/definitions/policyHttpMethodMatcherType",
                    "x-displayname": "HTTP Method"
                },
                "ip_matcher": {
                    "description": "Exclusive with [any_ip ip_prefix_list]\n List of references to IP Prefix Set objects.\n The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes in the IP Prefix Sets.",
                    "title": "ip matcher",
                    "$ref": "#/definitions/policyIpMatcherType",
                    "x-displayname": "IP Prefix Sets"
                },
                "ip_prefix_list": {
                    "description": "Exclusive with [any_ip ip_matcher]\n List of IP Prefixes values.\n The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes from the list.",
                    "title": "ip prefix list",
                    "$ref": "#/definitions/policyPrefixMatchList",
                    "x-displayname": "IP Prefix List"
                },
                "ip_threat_category_list": {
                    "description": "Exclusive with [any_client client_name client_name_matcher client_selector]\n IP threat categories to choose from",
                    "title": "IP Threat Category List",
                    "$ref": "#/definitions/schemaservice_policy_ruleIPThreatCategoryListType",
                    "x-displayname": "List of IP Threat Categories"
                },
                "ja4_tls_fingerprint": {
                    "description": "Exclusive with [tls_fingerprint_matcher]\n An extended version of JA3 that includes additional fields for more comprehensive fingerprinting of\n SSL/TLS clients and potentially has a different structure and length.",
                    "title": "ja4 tls fingerprint",
                    "$ref": "#/definitions/policyJA4TlsFingerprintMatcherType",
                    "x-displayname": "JA4 TLS Fingerprint"
                },
                "jwt_claims": {
                    "type": "array",
                    "description": " A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType\n instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.\n Note that all specified JWT claim predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "JWT claims",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyJWTClaimMatcherType"
                    },
                    "x-displayname": "JWT Claims",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "label_matcher": {
                    "description": " A list of label keys that identify the label values that need to be the same for the client and server. Note that the actual label values are not specified\n here, just the label keys. This predicate facilitates reuse of rules and policies across multiple dimensions such as deployment, environment, and location.\n The predicate evaluates to true if the values of the client and server labels for all the keys specified in the label matcher are equal. The values of any\n other labels do not matter.\n\nExample: - \"['environment', 'location', 'deployment']\"-",
                    "title": "label matcher",
                    "$ref": "#/definitions/schemaLabelMatcherType",
                    "x-displayname": "Label Matcher",
                    "x-ves-example": "['environment', 'location', 'deployment']"
                },
                "mum_action": {
                    "description": " Specifies how Malicious User Mitigation is handled",
                    "title": "Malicious User Mitigation Action",
                    "$ref": "#/definitions/policyModifyAction",
                    "x-displayname": "Malicious User Mitigation Action"
                },
                "path": {
                    "description": " A list of exact values, prefixes and regular expressions for the expected value of the HTTP path. The actual value of the HTTP path is the unescaped path\n value extracted from the HTTP URL Resource, excluding any query and fragment information.\n The predicate evaluates to true if the actual path value matches any of the exact or prefix values or regular expressions in the path matcher.",
                    "title": "path",
                    "$ref": "#/definitions/schemapolicyPathMatcherType",
                    "x-displayname": "HTTP Path"
                },
                "port_matcher": {
                    "description": " The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.",
                    "title": "port matcher",
                    "$ref": "#/definitions/schemapolicyPortMatcherType",
                    "x-displayname": "Port Matcher"
                },
                "query_params": {
                    "type": "array",
                    "description": " A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances\n of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.\n Note that all specified query parameter predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "query params",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemapolicyQueryParameterMatcherType"
                    },
                    "x-displayname": "HTTP Query Parameters",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "request_constraints": {
                    "description": " Place limits on request based on the request attributes. The request matches if any of the attribute sizes exceed the corresponding maximum value.",
                    "title": "request constraints",
                    "$ref": "#/definitions/policyRequestConstraintType",
                    "x-displayname": "Request Constraints"
                },
                "segment_policy": {
                    "description": " Select source and destination segments where rule is applied\n Skip the configuration or set option as Any to ignore corresponding segment match",
                    "title": "Segments",
                    "$ref": "#/definitions/policySegmentPolicyType",
                    "x-displayname": "Configure Segments"
                },
                "tls_fingerprint_matcher": {
                    "description": "Exclusive with [ja4_tls_fingerprint]\n A method for uniquely identifying SSL/TLS clients by creating a 32-character MD5 hash based on the\n parameters of the Client Hello packet during the handshake.",
                    "title": "TLS JA3 fingerprint matcher",
                    "$ref": "#/definitions/policyTlsFingerprintMatcherType",
                    "x-displayname": "JA3 TLS Fingerprint"
                },
                "user_identity_matcher": {
                    "description": " Match the specified user identity. The format is prefixed by the type.\n\nExample: - \"IP-x.x.x.x\"-",
                    "title": "user identity matcher",
                    "$ref": "#/definitions/policyMatcherTypeBasic",
                    "x-displayname": "User Identity Matcher",
                    "x-ves-example": "IP-x.x.x.x"
                },
                "waf_action": {
                    "description": " App Firewall action to be enforced if the input request matches the rule.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "App Firewall Action",
                    "$ref": "#/definitions/policyWafAction",
                    "x-displayname": "App Firewall Action",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "schemaservice_policy_ruleIPThreatCategoryListType": {
            "type": "object",
            "description": "List of ip threat categories",
            "title": "IP Threat Category List Type",
            "x-displayname": "IP Threat Category List Type",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.IPThreatCategoryListType",
            "properties": {
                "ip_threat_categories": {
                    "type": "array",
                    "description": " The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "IP Threat Categories",
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/policyIPThreatCategory"
                    },
                    "x-displayname": "List of IP Threat Categories to choose",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "This type establishes a direct reference from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.views.ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contacts-route\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 128\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "name",
                    "minLength": 1,
                    "maxLength": 128,
                    "x-displayname": "Name",
                    "x-ves-example": "contacts-route",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "128",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "namespace",
                    "maxLength": 64,
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "tenant",
                    "maxLength": 64,
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                }
            }
        },
        "service_policyCreateRequest": {
            "type": "object",
            "description": "This is the input message of the 'Create' RPC",
            "title": "CreateRequest is used to create an instance of service_policy",
            "x-displayname": "Create Request",
            "x-ves-proto-message": "ves.io.schema.service_policy.CreateRequest",
            "properties": {
                "metadata": {
                    "description": " Standard object's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectCreateMetaType",
                    "x-displayname": "Metadata"
                },
                "spec": {
                    "description": " Specification of the desired behavior of the service_policy",
                    "title": "spec",
                    "$ref": "#/definitions/schemaservice_policyCreateSpecType",
                    "x-displayname": "Spec"
                }
            }
        },
        "service_policyCreateResponse": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy.CreateResponse",
            "properties": {
                "metadata": {
                    "description": " Standard object's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectGetMetaType",
                    "x-displayname": "Metadata"
                },
                "spec": {
                    "description": " Specification of the desired behavior of the service_policy",
                    "title": "spec",
                    "$ref": "#/definitions/schemaservice_policyGetSpecType",
                    "x-displayname": "Spec"
                },
                "system_metadata": {
                    "description": " System generated object's metadata",
                    "title": "system metadata",
                    "$ref": "#/definitions/schemaSystemObjectGetMetaType",
                    "x-displayname": "System Metadata"
                }
            }
        },
        "service_policyDeleteRequest": {
            "type": "object",
            "description": "This is the input message of the 'Delete' RPC.",
            "title": "DeleteRequest is used to delete a service_policy",
            "x-displayname": "Delete Request",
            "x-ves-proto-message": "ves.io.schema.service_policy.DeleteRequest",
            "properties": {
                "fail_if_referred": {
                    "type": "boolean",
                    "description": " Fail the delete operation if this object is being referred by other objects",
                    "title": "fail_if_referred",
                    "format": "boolean",
                    "x-displayname": "Fail-If-Referred"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the configuration object\n\nExample: - \"name\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "name"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace in which the configuration object is present\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                }
            }
        },
        "service_policyGetResponse": {
            "type": "object",
            "description": "This is the output message of the 'Get' RPC",
            "title": "GetResponse is the shape of a read service_policy",
            "x-displayname": "Get Response",
            "x-ves-proto-message": "ves.io.schema.service_policy.GetResponse",
            "properties": {
                "create_form": {
                    "description": "Format used to create a new similar object",
                    "title": "create_form",
                    "$ref": "#/definitions/service_policyCreateRequest",
                    "x-displayname": "CreateRequest Format"
                },
                "deleted_referred_objects": {
                    "type": "array",
                    "description": "The set of deleted objects that are referred by this object",
                    "title": "deleted_referred_objects",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Deleted Referred Objects"
                },
                "disabled_referred_objects": {
                    "type": "array",
                    "description": "The set of deleted objects that are referred by this object",
                    "title": "disabled_referred_objects",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Disabled Referred Objects"
                },
                "metadata": {
                    "description": " Standard object's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectGetMetaType",
                    "x-displayname": "Metadata"
                },
                "referring_objects": {
                    "type": "array",
                    "description": "The set of objects that are referring to this object in their spec",
                    "title": "referring_objects",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Referring Objects"
                },
                "replace_form": {
                    "description": "Format to replace changeable values in object",
                    "title": "replace_form",
                    "$ref": "#/definitions/service_policyReplaceRequest",
                    "x-displayname": "ReplaceRequest Format"
                },
                "spec": {
                    "description": " Specification of the desired behavior of the service_policy",
                    "title": "spec",
                    "$ref": "#/definitions/schemaservice_policyGetSpecType",
                    "x-displayname": "Spec"
                },
                "status": {
                    "type": "array",
                    "description": "The status reported by different services for this configuration object",
                    "title": "status",
                    "items": {
                        "$ref": "#/definitions/service_policyStatusObject"
                    },
                    "x-displayname": "Status"
                },
                "system_metadata": {
                    "description": " System generated object's metadata",
                    "title": "system metadata",
                    "$ref": "#/definitions/schemaSystemObjectGetMetaType",
                    "x-displayname": "System Metadata"
                }
            }
        },
        "service_policyGetResponseFormatCode": {
            "type": "string",
            "description": "x-displayName: \"Get Response Format\"\nThis is the various forms that can be requested to be sent in the GetResponse\n\n - GET_RSP_FORMAT_DEFAULT: x-displayName: \"Default Format\"\nDefault format of returned resource\n - GET_RSP_FORMAT_FOR_CREATE: x-displayName: \"Create request Format\"\nResponse should be in CreateRequest format\n - GET_RSP_FORMAT_FOR_REPLACE: x-displayName: \"Replace request format\"\nResponse should be in ReplaceRequest format\n - GET_RSP_FORMAT_STATUS: x-displayName: \"Status format\"\nResponse should be in StatusObject(s) format\n - GET_RSP_FORMAT_READ: x-displayName: \"GetSpecType format\"\nResponse should be in format of GetSpecType\n - GET_RSP_FORMAT_REFERRING_OBJECTS: x-displayName: \"Referring Objects\"\nResponse should have other objects referring to this object\n - GET_RSP_FORMAT_BROKEN_REFERENCES: x-displayName: \"Broken Referred Objects\"\nResponse should have deleted and disabled objects referrred by this object",
            "title": "GetResponseFormatCode",
            "enum": [
                "GET_RSP_FORMAT_DEFAULT",
                "GET_RSP_FORMAT_FOR_CREATE",
                "GET_RSP_FORMAT_FOR_REPLACE",
                "GET_RSP_FORMAT_STATUS",
                "GET_RSP_FORMAT_READ",
                "GET_RSP_FORMAT_REFERRING_OBJECTS",
                "GET_RSP_FORMAT_BROKEN_REFERENCES"
            ],
            "default": "GET_RSP_FORMAT_DEFAULT"
        },
        "service_policyLegacyRuleList": {
            "type": "object",
            "description": "A list of references to service_policy_rule objects.\nThe order of evaluation of the rules depends on the rule combining algorithm.",
            "title": "LegacyRuleList",
            "x-displayname": "Legacy Rules",
            "x-ves-proto-message": "ves.io.schema.service_policy.LegacyRuleList",
            "properties": {
                "rules": {
                    "type": "array",
                    "description": " A list of references to service_policy_rule objects.\n The order of evaluation of the rules depends on the rule combining algorithm.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n",
                    "title": "rules",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256"
                    }
                }
            }
        },
        "service_policyListResponse": {
            "type": "object",
            "description": "This is the output message of 'List' RPC.",
            "title": "ListResponse is the collection of service_policy",
            "x-displayname": "List Response",
            "x-ves-proto-message": "ves.io.schema.service_policy.ListResponse",
            "properties": {
                "errors": {
                    "type": "array",
                    "description": " Errors(if any) while listing items from collection",
                    "title": "errors",
                    "items": {
                        "$ref": "#/definitions/schemaErrorType"
                    },
                    "x-displayname": "Errors"
                },
                "items": {
                    "type": "array",
                    "description": " items represents the collection in response",
                    "title": "items",
                    "items": {
                        "$ref": "#/definitions/service_policyListResponseItem"
                    },
                    "x-displayname": "Items"
                }
            }
        },
        "service_policyListResponseItem": {
            "type": "object",
            "description": "By default a summary of service_policy is returned in 'List'. By setting\n'report_fields' in the ListRequest more details of each item can be got.",
            "title": "ListResponseItem is an individual item in a collection of service_policy",
            "x-displayname": "List Item",
            "x-ves-proto-message": "ves.io.schema.service_policy.ListResponseItem",
            "properties": {
                "annotations": {
                    "type": "object",
                    "description": " The set of annotations present on this service_policy",
                    "title": "annotations",
                    "x-displayname": "Annotations"
                },
                "description": {
                    "type": "string",
                    "description": " The description set for this service_policy",
                    "title": "description",
                    "x-displayname": "Description"
                },
                "disabled": {
                    "type": "boolean",
                    "description": " A value of true indicates service_policy is administratively disabled",
                    "title": "disabled",
                    "format": "boolean",
                    "x-displayname": "Disabled"
                },
                "get_spec": {
                    "description": " If ListRequest has any specified report_fields, it will appear in object",
                    "title": "get_spec",
                    "$ref": "#/definitions/schemaservice_policyGetSpecType",
                    "x-displayname": "Get Specification"
                },
                "labels": {
                    "type": "object",
                    "description": " The set of labels present on this service_policy",
                    "title": "labels",
                    "x-displayname": "Labels"
                },
                "metadata": {
                    "description": " If list request has report_fields set then metadata will\n contain all the metadata associated with the object.",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectGetMetaType",
                    "x-displayname": "Metadata"
                },
                "name": {
                    "type": "string",
                    "description": " The name of this service_policy\n\nExample: - \"name\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "name"
                },
                "namespace": {
                    "type": "string",
                    "description": " The namespace this item belongs to\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "owner_view": {
                    "description": " Reference to the view object that owns this object.\n If there is no view owner, this field will be nil.\n If not nil, this object can only be edited/deleted through the view",
                    "title": "owner_view",
                    "$ref": "#/definitions/schemaViewRefType",
                    "x-displayname": "Owner View"
                },
                "status_set": {
                    "type": "array",
                    "description": " The status reported by different services for this configuration object",
                    "title": "status",
                    "items": {
                        "$ref": "#/definitions/service_policyStatusObject"
                    },
                    "x-displayname": "Status"
                },
                "system_metadata": {
                    "description": " If list request has report_fields set then system_metadata will\n contain all the system generated details of this object.",
                    "title": "system_metadata",
                    "$ref": "#/definitions/schemaSystemObjectGetMetaType",
                    "x-displayname": "System Metadata"
                },
                "tenant": {
                    "type": "string",
                    "description": " The tenant this item belongs to\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " The unique uid of this service_policy\n\nExample: - \"d27938ba-967e-40a7-9709-57b8627f9f75\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d27938ba-967e-40a7-9709-57b8627f9f75"
                }
            }
        },
        "service_policyReplaceRequest": {
            "type": "object",
            "description": "This is the input message of the 'Replace' RPC",
            "title": "ReplaceRequest is used to replace contents of a service_policy",
            "x-displayname": "Replace Request",
            "x-ves-proto-message": "ves.io.schema.service_policy.ReplaceRequest",
            "properties": {
                "metadata": {
                    "description": " Standard object's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectReplaceMetaType",
                    "x-displayname": "Metadata"
                },
                "spec": {
                    "description": " Specification of the desired behavior of the service_policy",
                    "title": "spec",
                    "$ref": "#/definitions/schemaservice_policyReplaceSpecType",
                    "x-displayname": "Spec"
                }
            }
        },
        "service_policyReplaceResponse": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy.ReplaceResponse"
        },
        "service_policyRule": {
            "type": "object",
            "description": "A Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from\nor derived from an L7 request API. A request API is considered to match the simple rule if all predicates in the rule evaluate to true for that request. Any\npredicates that are not specified in a rule are implicitly considered to be true. If a request API matches a simple rule, the action for the simple rule is\nenforced.",
            "title": "rule",
            "x-displayname": "Rule",
            "x-ves-proto-message": "ves.io.schema.service_policy.Rule",
            "properties": {
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "spec": {
                    "description": " Specification for the rule including match predicates and actions.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "spec",
                    "$ref": "#/definitions/schemaservice_policy_ruleGlobalSpecType",
                    "x-displayname": "Rule Specification",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "service_policyRuleList": {
            "type": "object",
            "description": "A list of rules.\nThe order of evaluation of the rules depends on the rule combining algorithm.",
            "title": "rule list",
            "x-displayname": "Rule List",
            "x-ves-proto-message": "ves.io.schema.service_policy.RuleList",
            "properties": {
                "rules": {
                    "type": "array",
                    "description": " Define the list of rules (with an order) that should be evaluated by this service policy.\n Rules are evaluated from top to bottom in the list.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "title": "rules",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/service_policyRule"
                    },
                    "x-displayname": "Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                }
            }
        },
        "service_policySimpleRule": {
            "type": "object",
            "description": "x-displayName: \"Simple Rule\"\nA SimpleRule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from\nor derived from an L7 request API. A request API is considered to match the simple rule if all predicates in the rule evaluate to true for that request. Any\npredicates that are not specified in a rule are implicitly considered to be true. If a request API matches a simple rule, the action for the simple rule is\nenforced.\n\nA SimpleRule does not currently support any predicates that contain references to objects.",
            "title": "simple rule",
            "properties": {
                "action": {
                    "description": "x-displayName: \"Action\"\nAction to be enforced if the input request matches the rule.",
                    "title": "action",
                    "$ref": "#/definitions/policyRuleAction"
                },
                "additional_api_group_matchers": {
                    "type": "array",
                    "description": "x-displayName: \"Additional API Group Matchers\"\nAdditional API Group Match predicates.\nNote that all specified API Group Match predicates must evaluate to true.",
                    "title": "additional api group matchers",
                    "items": {
                        "$ref": "#/definitions/policyStringMatcherType"
                    }
                },
                "api_group_matcher": {
                    "description": "x-displayName: \"API Group Matcher\"\nThe list of expected API group names to which the request API belongs. The actual list of API group names for the request API is determined from the api\ngroup and api group element configuration objects using the HTTP method and the HTTP path as inputs.\nThe predicate evaluates to true if any of the actual API group names for the request is equal to any of the values in the api group matcher.",
                    "title": "api group matcher",
                    "$ref": "#/definitions/policyStringMatcherType"
                },
                "arg_matchers": {
                    "type": "array",
                    "description": "x-displayName: \"Argument Matchers\"\nA list of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances\nof ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name.\nNote that all specified arg matcher predicates must evaluate to true.",
                    "title": "arg matchers",
                    "items": {
                        "$ref": "#/definitions/policyArgMatcherType"
                    }
                },
                "asn_list": {
                    "description": "x-displayName: \"ASN List\"\nList of 4-byte ASN values.\nThe predicate evaluates to true if the origin ASN is present in the ASN list.",
                    "title": "asn list",
                    "$ref": "#/definitions/policyAsnMatchList"
                },
                "asn_matcher": {
                    "description": "x-displayName: \"ASN Matcher\"\nMatch any AS number contained in the list of bgp_asn_sets. A list of references to bgp_asn_set objects.",
                    "title": "asn matcher",
                    "$ref": "#/definitions/policyAsnMatcherType"
                },
                "body_matcher": {
                    "description": "x-displayName: \"Request Body Matcher\"\nPredicate for matching the request body string. The criteria for matching the request body is described in MatcherType.\nThe actual request body value is extracted from the request API as a string.",
                    "title": "body matcher",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "bot_action": {
                    "description": "x-displayName: \"Bot Action\"\nBot action to be enforced if the input request matches the rule.",
                    "title": "Bot Action",
                    "$ref": "#/definitions/schemapolicyBotAction"
                },
                "challenge_action": {
                    "description": "x-displayName: \"Select Challenge Action Type\"\nx-required\nSelect challenge action, enable javascript/captcha challenge or disable challenge",
                    "title": "challenge action",
                    "$ref": "#/definitions/policyChallengeAction"
                },
                "client_name": {
                    "type": "string",
                    "description": "x-displayName: \"Client Name\"\nx-example: \"backend.production.customer.volterra.us\"\nThe expected name of the client invoking the request API.\nThe predicate evaluates to true if any of the actual names is the same as the expected client name.",
                    "title": "client name"
                },
                "client_name_matcher": {
                    "description": "x-displayName: \"Group of Clients by Name\"\nA list of exact values and/or regular expressions for the expected name of the client.\nThis is a generalized version of the client name predicate that allows the same rule to be applicable to a set of clients rather than a single client.\nThe predicate evaluates to true if any of the client's actual names match any of the exact values or regular expressions in the client name matcher.",
                    "title": "client name matcher",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "client_role": {
                    "description": "x-displayName: \"Client Role\"\nThe expected role(s) of the client invoking the request API. The actual roles for the client are derived from the user and namespace information in the\nAPI request.\nThe predicate evaluates to true if any of the client's roles match the value(s) specified in client role.",
                    "title": "client role",
                    "$ref": "#/definitions/policyRoleMatcherType"
                },
                "client_selector": {
                    "description": "x-displayName: \"Group of Clients by Label Selector\"\nA label selector that describes the expected set of clients. The labels associated with the client making the API request are used to evaluate the label\nexpressions in the selector. These labels can be derived from the client TLS certificate or from the volterra internal control plane.\nThis is a more flexible and powerful version of the client name matcher predicate that allows a given rule to be applicable to a set of clients based on the\nclient labels rather than being limited to relying on patterns in the client name.\nThe predicate evaluates to true if the expressions in the label selector are true for the client labels.",
                    "title": "client selector",
                    "$ref": "#/definitions/schemaLabelSelectorType"
                },
                "content_rewrite_action": {
                    "description": "x-displayName: \"Shape Content Rewrite Action Type\"\nRewrite HTML response action to insert HTML content such as Javascript \u003cscript\u003e tags into the HTML document",
                    "title": "Shape Content Rewrite Action",
                    "$ref": "#/definitions/policyContentRewriteAction"
                },
                "cookie_matchers": {
                    "type": "array",
                    "description": "x-displayName: \"Cookie Matchers\"\nA list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances\nof CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.\nNote that all specified cookie matcher predicates must evaluate to true.",
                    "title": "cookie matchers",
                    "items": {
                        "$ref": "#/definitions/policyCookieMatcherType"
                    }
                },
                "description": {
                    "type": "string",
                    "description": "x-displayName: \"Description\"\nx-example: \"Deny access to Facebook\"\nDescription for the rule.",
                    "title": "description"
                },
                "domain_matcher": {
                    "description": "x-displayName: \"Domain Matcher\"\nA list of exact values and/or regular expressions for the expected name of the domain. The actual value of domain is the host component\nfrom the URL. The predicate evaluates to true if the domain value matches any of the exact values or regular expressions in the domain\nmatcher.",
                    "title": "domain matcher",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "dst_asn_list": {
                    "description": "x-displayName: \"Destination ASN List\"\nList of 4-byte ASN values.\nThe predicate evaluates to true if the destination ASN is present in the ASN list.",
                    "title": "dst asn list",
                    "$ref": "#/definitions/policyAsnMatchList"
                },
                "dst_asn_matcher": {
                    "description": "x-displayName: \"Destination BGP ASN Sets\"\nList of references to BGP ASN Set objects.\nThe predicate evaluates to true if the destination ASN is present in one of the BGP ASN Set objects.",
                    "title": "dst asn matcher",
                    "$ref": "#/definitions/policyAsnMatcherType"
                },
                "dst_ip_matcher": {
                    "description": "x-displayName: \"Destination IP Prefix Sets\"\nList of references to IP Prefix Set objects.\nThe predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes in the IP Prefix Sets.",
                    "title": "ip matcher",
                    "$ref": "#/definitions/policyIpMatcherType"
                },
                "dst_ip_prefix_list": {
                    "description": "x-displayName: \"Destination IP Prefix List\"\nList of IP Prefixes values.\nThe predicate evaluates to true if the destination address is covered by one or more of the IP Prefixes from the list.",
                    "title": "dst ip prefix list",
                    "$ref": "#/definitions/policyPrefixMatchList"
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": "x-displayName: \"Expiration Timestamp\"\nx-example: \"2019-12-31:44:34.171543432Z\"\nThe expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\nthe configuration but is not applied anymore.",
                    "title": "expiration timestamp",
                    "format": "date-time"
                },
                "goto_policy": {
                    "type": "array",
                    "description": "x-displayName: \"Goto Policy\"\nA reference to a service_policy object.\nTarget of the GOTO_POLICY action.\nThe target policy must be part of the current policy set and must be after the current policy in the policy set.",
                    "title": "goto_policy",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    }
                },
                "graphql_settings": {
                    "description": "x-displayName: \"GraphQL Settings\"\nGraphQL policy settings to be applied for this request",
                    "title": "GraphQL Settings",
                    "$ref": "#/definitions/policyGraphQLSettingsType"
                },
                "headers": {
                    "type": "array",
                    "description": "x-displayName: \"HTTP Headers\"\nA list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType\ninstances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.\nNote that all specified header predicates must evaluate to true.",
                    "title": "headers",
                    "items": {
                        "$ref": "#/definitions/schemapolicyHeaderMatcherType"
                    }
                },
                "http_method": {
                    "description": "x-displayName: \"HTTP Method\"\nThe list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.\nThe predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.",
                    "title": "method",
                    "$ref": "#/definitions/policyHttpMethodMatcherType"
                },
                "ip_matcher": {
                    "description": "x-displayName: \"IP Matcher\"\nMatch any IP prefix contained in the list of ip_prefix_sets.\nThe result of the match is inverted if invert_matcher is true.",
                    "title": "ip matcher",
                    "$ref": "#/definitions/policyIpMatcherType"
                },
                "ip_prefix_list": {
                    "description": "x-displayName: \"IP Prefix List\"\nList of IP Prefixes values.\nThe predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes from the list.",
                    "title": "ip prefix list",
                    "$ref": "#/definitions/policyPrefixMatchList"
                },
                "ip_reputation_action": {
                    "description": "x-displayName: \"IP Reputation Action\"\nSpecifies how IP Reputation is handled",
                    "title": "IP Reputation Action",
                    "$ref": "#/definitions/policyModifyAction"
                },
                "ja4_tls_fingerprint": {
                    "description": "x-displayName: \"JA4 TLS Fingerprint\"\nJA4 TLS fingerprints to be matched",
                    "title": "ja4 tls fingerprint",
                    "$ref": "#/definitions/policyJA4TlsFingerprintMatcherType"
                },
                "jwt_claims": {
                    "type": "array",
                    "description": "x-displayName: \"JWT Claims\"\nA list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType\ninstances. The actual JWT claims values are extracted from the JWT payload as a list of strings.\nNote that all specified JWT claim predicates must evaluate to true.",
                    "title": "JWT claims",
                    "items": {
                        "$ref": "#/definitions/policyJWTClaimMatcherType"
                    }
                },
                "label_matcher": {
                    "description": "x-displayName: \"Label Matcher\"\nx-example: \"['environment', 'location', 'deployment']\"\nA list of label keys that identify the label values that need to be the same for the client and server. Note that the actual label values are not specified\nhere, just the label keys. This predicate facilitates reuse of rules and policies across multiple dimensions such as deployment, environment, and location.\nThe predicate evaluates to true if the values of the client and server labels for all the keys specified in the label matcher are equal. The values of any\nother labels do not matter.",
                    "title": "label matcher",
                    "$ref": "#/definitions/schemaLabelMatcherType"
                },
                "malware_protection_action": {
                    "description": "x-displayName: \"Malware Protection Action\"\nSpecifies how Malware Protection is handled",
                    "title": "Malware Protection Action",
                    "$ref": "#/definitions/policyModifyAction"
                },
                "malware_protection_settings": {
                    "description": "x-displayName: \"Malware Protection Settings\"\nMalware protection settings for this request",
                    "title": "Malware Protection Settings",
                    "$ref": "#/definitions/policyMalwareProtectionSettings"
                },
                "metric_name_label": {
                    "type": "string",
                    "description": "x-displayName: \"Metric Name Label\"\nName label to use in service policy rule metrics generated for this simple rule.",
                    "title": "metric_name_label"
                },
                "mum_action": {
                    "description": "x-displayName: \"Malicious User Mitigation Action\"\nSpecifies how Malicious User Mitigation is handled",
                    "title": "Malicious User Mitigation Action",
                    "$ref": "#/definitions/policyModifyAction"
                },
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Name\"\nName of the rule.",
                    "title": "name"
                },
                "openapi_validation_action": {
                    "description": "x-displayName: \"OpenAPI Validation Action\"\nOpenAPI validation policy settings to be applied for this request",
                    "title": "OpenAPI Validation Action",
                    "$ref": "#/definitions/policyOpenApiValidationAction"
                },
                "origin_server_subsets_action": {
                    "type": "object",
                    "description": "x-displayName: \"Origin Server Subsets Action\"\nx-example: \"value\"\nAdd Labels for this origin server, these labels can be used to form subset.",
                    "title": "Origin Server Subsets Action"
                },
                "path": {
                    "description": "x-displayName: \"HTTP Path\"\nA list of exact values, prefixes and regular expressions for the expected value of the HTTP path. The actual value of the HTTP path is the unescaped path\nvalue extracted from the HTTP URL Resource, excluding any query and fragment information.\nThe predicate evaluates to true if the actual path value matches any of the exact or prefix values or regular expressions in the path matcher.",
                    "title": "path",
                    "$ref": "#/definitions/schemapolicyPathMatcherType"
                },
                "port_matcher": {
                    "description": "x-displayName: \"Port Matcher\"\nThe list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.",
                    "title": "port matcher",
                    "$ref": "#/definitions/schemapolicyPortMatcherType"
                },
                "query_params": {
                    "type": "array",
                    "description": "x-displayName: \"HTTP Query Parameters\"\nA list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances\nof QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.\nNote that all specified query parameter predicates must evaluate to true.",
                    "title": "query params",
                    "items": {
                        "$ref": "#/definitions/schemapolicyQueryParameterMatcherType"
                    }
                },
                "rate_limiter_specs": {
                    "type": "array",
                    "description": "x-displayName: \"Rate Limiter Specs\"\nSpecs for rate_limiter objects.\nApply the specified rate_limiters.\nMutually exclusive with rate_limiters.",
                    "title": "rate limiter specs",
                    "items": {
                        "$ref": "#/definitions/schemarate_limiterGlobalSpecType"
                    }
                },
                "rate_limiters": {
                    "type": "array",
                    "description": "x-displayName: \"Rate Limiters\"\nReferences to rate_limiter objects.\nApply the specified rate_limiters.\nMutually exclusive with rate_limiter_specs.",
                    "title": "rate limiters",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    }
                },
                "request_constraints": {
                    "description": "x-displayName: \"Request Constraints\"\nPlace limits on request based on the request attributes. The request matches if any of the attribute sizes exceed the corresponding maximum value.",
                    "title": "request constraints",
                    "$ref": "#/definitions/policyRequestConstraintType"
                },
                "response_masking_config": {
                    "description": "x-displayName: \"Response Masking Configuration\"\nSensitive data masking configuration to be applied for the response",
                    "title": "Response Masking Configuration",
                    "$ref": "#/definitions/policyMaskingConfig"
                },
                "scheme": {
                    "type": "array",
                    "description": "x-displayName: \"Scheme\"\nx-example: \"HTTPS\"\nThe scheme in the request.",
                    "title": "scheme",
                    "items": {
                        "type": "string"
                    }
                },
                "server_selector": {
                    "description": "x-displayName: \"Group of Servers by Label Selector\"\nA label selector that describes the expected set of servers.\nThe predicate evaluates to true if the expressions in the label selector are true for the server labels.",
                    "title": "server selector",
                    "$ref": "#/definitions/schemaLabelSelectorType"
                },
                "shape_protected_endpoint_action": {
                    "description": "x-displayName: \"Shape Protected Endpoint Action\"\nShape Protected Endpoint Action that include application traffic type and mitigation",
                    "title": "Shape Protected Endpoint Action",
                    "$ref": "#/definitions/policyShapeProtectedEndpointAction"
                },
                "threat_mesh_action": {
                    "description": "x-displayName: \"Threat Mesh Action\"\nSpecifies how Threat Mesh is handled",
                    "title": "Threat Mesh Action",
                    "$ref": "#/definitions/policyModifyAction"
                },
                "tls_fingerprint_matcher": {
                    "description": "x-displayName: \"JA3 TLS Fingerprint\"\nJA3 TLS fingerprints to be matched.\nThe predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.",
                    "title": "TLS JA3 fingerprint matcher",
                    "$ref": "#/definitions/policyTlsFingerprintMatcherType"
                },
                "url_matcher": {
                    "description": "x-displayName: \"URL Matcher\"\nA URL matcher specifies a list of URL items as match criteria. The match is considered successful if the domain and path match any of the URL items.",
                    "title": "url matcher",
                    "$ref": "#/definitions/policyURLMatcherType"
                },
                "user_identity_matcher": {
                    "description": "x-displayName: \"User Identity Matcher\"\nx-example: \"IP-x.x.x.x\"\nMatch the specified user identity. The format is prefixed by the type.",
                    "title": "user identity matcher",
                    "$ref": "#/definitions/policyMatcherTypeBasic"
                },
                "virtual_host_matcher": {
                    "description": "x-displayName: \"Virtual Host Matcher\"\nA list of exact values and/or regular expressions for the expected name of the virtual_host. The name of the virtual_host is is part of the context in\nwhich a service_policy_set is evaluated. The predicate evaluates to true if the virtual_host name matches any of the exact values or regular expressions\nin the virtual_host matcher.\nHidden because this will be used only in system generated rate limiting service_policy_sets.",
                    "title": "virtual host matcher",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "waf_action": {
                    "description": "x-displayName: \"App Firewall Action\"\nApp Firewall action to be enforced if the input request matches the rule.",
                    "title": "App Firewall Action",
                    "$ref": "#/definitions/policyWafAction"
                }
            }
        },
        "service_policySourceList": {
            "type": "object",
            "description": "List of sources. A request belongs to this list if it satisfies any of the match criteria.",
            "title": "source_list",
            "x-displayname": "Source List",
            "x-ves-displayorder": "2,3,4,5,6,7,8,10",
            "x-ves-oneof-field-default_action_choice": "[\"default_action_allow\",\"default_action_deny\",\"default_action_next_policy\"]",
            "x-ves-proto-message": "ves.io.schema.service_policy.SourceList",
            "properties": {
                "asn_list": {
                    "description": " Addresses that belong to the ASNs in the given list\n The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.",
                    "title": "asn_list",
                    "$ref": "#/definitions/policyAsnMatchList",
                    "x-displayname": "BGP ASN List"
                },
                "asn_set": {
                    "type": "array",
                    "description": " Addresses that belong to the ASNs in the given bgp_asn_set\n The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 4\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "asn_set",
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "BGP ASN Set",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "4",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "country_list": {
                    "type": "array",
                    "description": " Addresses that belong to one of the countries in the given list\n The country is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.not_in: [0]\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "country_list",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyCountryCode"
                    },
                    "x-displayname": "Country List",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.not_in": "[0]",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "default_action_allow": {
                    "description": "Exclusive with [default_action_deny default_action_next_policy]\n Allow all requests",
                    "title": "Allow",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Allow"
                },
                "default_action_deny": {
                    "description": "Exclusive with [default_action_allow default_action_next_policy]\n Deny all requests",
                    "title": "Deny",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Deny"
                },
                "default_action_next_policy": {
                    "description": "Exclusive with [default_action_allow default_action_deny]\n Evaluate the next service policy",
                    "title": "Next Policy",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Next Policy"
                },
                "ip_prefix_set": {
                    "type": "array",
                    "description": " Addresses that are covered by the prefixes in the given ip_prefix_set\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 4\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ip_prefix_set",
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "IP Prefix Set",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "4",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "prefix_list": {
                    "description": " Addresses that are covered by the given list of IPv4 prefixes",
                    "title": "prefix_list",
                    "$ref": "#/definitions/viewsPrefixStringListType",
                    "x-displayname": "IPv4 Prefix List"
                },
                "tls_fingerprint_classes": {
                    "type": "array",
                    "description": " A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "tls_fingerprint_classes",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyKnownTlsFingerprintClass"
                    },
                    "x-displayname": "TLS Fingerprint Classes",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "tls_fingerprint_values": {
                    "type": "array",
                    "description": " A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"1aa7bf8b97e540ca5edd75f7b8384bfa\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 32\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "tls_fingerprint_classes",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "TLS Fingerprint Values",
                    "x-ves-example": "1aa7bf8b97e540ca5edd75f7b8384bfa",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "32",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "service_policyStatusObject": {
            "type": "object",
            "description": "Most recently observed status of object",
            "title": "Status of service Policy",
            "x-displayname": "Status",
            "x-ves-proto-message": "ves.io.schema.service_policy.StatusObject",
            "properties": {
                "conditions": {
                    "type": "array",
                    "description": " Conditions reported by various component of the system",
                    "title": "conditions",
                    "items": {
                        "$ref": "#/definitions/schemaConditionType"
                    },
                    "x-displayname": "Conditions"
                },
                "metadata": {
                    "description": " Standard status's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaStatusMetaType",
                    "x-displayname": "Metadata"
                },
                "object_refs": {
                    "type": "array",
                    "description": " Object reference",
                    "title": "object_refs",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Config Object"
                }
            }
        },
        "viewsPrefixStringListType": {
            "type": "object",
            "description": "x-example: \"192.168.20.0/24\"\nList of IPv4 prefixes that represent an endpoint",
            "title": "ipv4 prefix list",
            "x-displayname": "IPv4 Prefix List",
            "x-ves-proto-message": "ves.io.schema.views.PrefixStringListType",
            "properties": {
                "ipv6_prefixes": {
                    "type": "array",
                    "description": " List of IPv6 prefix strings.\n\nExample: - \"fd48:fa09:d9d4::/48\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv6_prefix: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ipv6 prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Prefix List",
                    "x-ves-example": "fd48:fa09:d9d4::/48",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv6_prefix": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "prefixes": {
                    "type": "array",
                    "description": " List of IPv4 prefixes that represent an endpoint\n\nExample: - \"192.168.20.0/24\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv4_prefix: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ipv4 prefix list",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Prefix List",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "viewsSegmentRefList": {
            "type": "object",
            "description": "List of references to Segments",
            "title": "Segment List",
            "x-displayname": "Segment List",
            "x-ves-proto-message": "ves.io.schema.views.SegmentRefList",
            "properties": {
                "segments": {
                    "type": "array",
                    "description": " Select list of segments\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Segments",
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "Segments",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        }
    },
    "x-displayname": "Service Policy",
    "x-ves-proto-file": "ves.io/schema/service_policy/public_crudapi.proto"
}`
