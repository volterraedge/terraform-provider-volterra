// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/service_policy/types.proto

package service_policy

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	rate_limiter "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/rate_limiter"
	service_policy_rule "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy_rule"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// simple rule
//
// x-displayName: "Simple Rule"
// A SimpleRule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from
// or derived from an L7 request API. A request API is considered to match the simple rule if all predicates in the rule evaluate to true for that request. Any
// predicates that are not specified in a rule are implicitly considered to be true. If a request API matches a simple rule, the action for the simple rule is
// enforced.
//
// A SimpleRule does not currently support any predicates that contain references to objects.
type SimpleRule struct {
	// name
	//
	// x-displayName: "Name"
	// Name of the rule.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// metric_name_label
	//
	// x-displayName: "Metric Name Label"
	// Name label to use in service policy rule metrics generated for this simple rule.
	MetricNameLabel string `protobuf:"bytes,17,opt,name=metric_name_label,json=metricNameLabel,proto3" json:"metric_name_label,omitempty"`
	// action
	//
	// x-displayName: "Action"
	// Action to be enforced if the input request matches the rule.
	Action policy.RuleAction `protobuf:"varint,2,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// domain matcher
	//
	// x-displayName: "Domain Matcher"
	// A list of exact values and/or regular expressions for the expected name of the domain. The actual value of domain is the host component
	// from the URL. The predicate evaluates to true if the domain value matches any of the exact values or regular expressions in the domain
	// matcher.
	DomainMatcher *policy.MatcherType `protobuf:"bytes,3,opt,name=domain_matcher,json=domainMatcher,proto3" json:"domain_matcher,omitempty"`
	// path
	//
	// x-displayName: "HTTP Path"
	// A list of exact values, prefixes and regular expressions for the expected value of the HTTP path. The actual value of the HTTP path is the unescaped path
	// value extracted from the HTTP URL Resource, excluding any query and fragment information.
	// The predicate evaluates to true if the actual path value matches any of the exact or prefix values or regular expressions in the path matcher.
	Path *policy.PathMatcherType `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// headers
	//
	// x-displayName: "HTTP Headers"
	// A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType
	// instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.
	// Note that all specified header predicates must evaluate to true.
	Headers []*policy.HeaderMatcherType `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty"`
	// method
	//
	// x-displayName: "HTTP Method"
	// The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.
	// The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.
	HttpMethod *policy.HttpMethodMatcherType `protobuf:"bytes,6,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	// App Firewall Action
	//
	// x-displayName: "App Firewall Action"
	// App Firewall action to be enforced if the input request matches the rule.
	WafAction *policy.WafAction `protobuf:"bytes,7,opt,name=waf_action,json=wafAction,proto3" json:"waf_action,omitempty"`
	// expiration timestamp
	//
	// x-displayName: "Expiration Timestamp"
	// x-example: "2019-12-31:44:34.171543432Z"
	// The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in
	// the configuration but is not applied anymore.
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,8,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// scheme
	//
	// x-displayName: "Scheme"
	// x-example: "HTTPS"
	// The scheme in the request.
	Scheme []string `protobuf:"bytes,12,rep,name=scheme,proto3" json:"scheme,omitempty"`
	// port matcher
	//
	// x-displayName: "Port Matcher"
	// The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.
	PortMatcher *policy.PortMatcherType `protobuf:"bytes,10,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Deny access to Facebook"
	// Description for the rule.
	Description string `protobuf:"bytes,11,opt,name=description,proto3" json:"description,omitempty"`
	// url matcher
	//
	// x-displayName: "URL Matcher"
	// A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the domain and path match any of the URL items.
	UrlMatcher *policy.URLMatcherType `protobuf:"bytes,13,opt,name=url_matcher,json=urlMatcher,proto3" json:"url_matcher,omitempty"`
	// l4 dest matcher
	//
	// x-displayName: "L4 Destination Matcher"
	// A L4 Destination matcher specifies a list of IPv4 prefixes and a TCP port range as match criteria. The match is considered successful if the destination
	// IP matches one of the prefixes and the destination port belongs to the port range.
	L4DestMatcher *policy.L4DestMatcherType `protobuf:"bytes,14,opt,name=l4_dest_matcher,json=l4DestMatcher,proto3" json:"l4_dest_matcher,omitempty"`
	// ip prefix list
	//
	// x-displayName: "IP Prefix List"
	// List of IP Prefixes values.
	// The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes from the list.
	IpPrefixList *policy.PrefixMatchList `protobuf:"bytes,15,opt,name=ip_prefix_list,json=ipPrefixList,proto3" json:"ip_prefix_list,omitempty"`
	// dst ip prefix list
	//
	// x-displayName: "Destination IP Prefix List"
	// List of IP Prefixes values.
	// The predicate evaluates to true if the destination address is covered by one or more of the IP Prefixes from the list.
	DstIpPrefixList *policy.PrefixMatchList `protobuf:"bytes,16,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,proto3" json:"dst_ip_prefix_list,omitempty"`
	// TLS JA3 fingerprint matcher
	//
	// x-displayName: "TLS Fingerprint Matcher"
	// TLS JA3 fingerprints to be matched.
	// The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.
	TlsFingerprintMatcher *policy.TlsFingerprintMatcherType `protobuf:"bytes,18,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher,proto3" json:"tls_fingerprint_matcher,omitempty"`
	// asn list
	//
	// x-displayName: "ASN List"
	// List of 4-byte ASN values.
	// The predicate evaluates to true if the origin ASN is present in the ASN list.
	AsnList *policy.AsnMatchList `protobuf:"bytes,19,opt,name=asn_list,json=asnList,proto3" json:"asn_list,omitempty"`
	// api group matcher
	//
	// x-displayName: "API Group Matcher"
	// The list of expected API group names to which the request API belongs. The actual list of API group names for the request API is determined from the api
	// group and api group element configuration objects using the HTTP method and the HTTP path as inputs.
	// The predicate evaluates to true if any of the actual API group names for the request is equal to any of the values in the api group matcher.
	ApiGroupMatcher *policy.StringMatcherType `protobuf:"bytes,20,opt,name=api_group_matcher,json=apiGroupMatcher,proto3" json:"api_group_matcher,omitempty"`
	// additional api group matchers
	//
	// x-displayName: "Additional API Group Matchers"
	// Additional API Group Match predicates.
	// Note that all specified API Group Match predicates must evaluate to true.
	AdditionalApiGroupMatchers []*policy.StringMatcherType `protobuf:"bytes,45,rep,name=additional_api_group_matchers,json=additionalApiGroupMatchers,proto3" json:"additional_api_group_matchers,omitempty"`
	// client role
	//
	// x-displayName: "Client Role"
	// The expected role(s) of the client invoking the request API. The actual roles for the client are derived from the user and namespace information in the
	// API request.
	// The predicate evaluates to true if any of the client's roles match the value(s) specified in client role.
	ClientRole *policy.RoleMatcherType `protobuf:"bytes,21,opt,name=client_role,json=clientRole,proto3" json:"client_role,omitempty"`
	// client selector
	//
	// x-displayName: "Group of Clients by Label Selector"
	// A label selector that describes the expected set of clients. The labels associated with the client making the API request are used to evaluate the label
	// expressions in the selector. These labels can be derived from the client TLS certificate or from the volterra internal control plane.
	// This is a more flexible and powerful version of the client name matcher predicate that allows a given rule to be applicable to a set of clients based on the
	// client labels rather than being limited to relying on patterns in the client name.
	// The predicate evaluates to true if the expressions in the label selector are true for the client labels.
	ClientSelector *schema.LabelSelectorType `protobuf:"bytes,22,opt,name=client_selector,json=clientSelector,proto3" json:"client_selector,omitempty"`
	// server selector
	//
	// x-displayName: "Group of Servers by Label Selector"
	// A label selector that describes the expected set of servers.
	// The predicate evaluates to true if the expressions in the label selector are true for the server labels.
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,23,opt,name=server_selector,json=serverSelector,proto3" json:"server_selector,omitempty"`
	// label matcher
	//
	// x-displayName: "Label Matcher"
	// x-example: "['environment', 'location', 'deployment']"
	// A list of label keys that identify the label values that need to be the same for the client and server. Note that the actual label values are not specified
	// here, just the label keys. This predicate facilitates reuse of rules and policies across multiple dimensions such as deployment, environment, and location.
	// The predicate evaluates to true if the values of the client and server labels for all the keys specified in the label matcher are equal. The values of any
	// other labels do not matter.
	LabelMatcher *schema.LabelMatcherType `protobuf:"bytes,24,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	// Bot Action
	//
	// x-displayName: "Bot Action"
	// Bot action to be enforced if the input request matches the rule.
	BotAction *policy.BotAction `protobuf:"bytes,25,opt,name=bot_action,json=botAction,proto3" json:"bot_action,omitempty"`
	// Shape Content Rewrite Action
	//
	// x-displayName: "Shape Content Rewrite Action Type"
	// Rewrite HTML response action to insert HTML content such as Javascript <script> tags into the HTML document
	ContentRewriteAction *policy.ContentRewriteAction `protobuf:"bytes,26,opt,name=content_rewrite_action,json=contentRewriteAction,proto3" json:"content_rewrite_action,omitempty"`
	// Shape Protected Endpoint Action
	//
	// x-displayName: "Shape Protected Endpoint Action"
	// Shape Protected Endpoint Action that include application traffic type and mitigation
	ShapeProtectedEndpointAction *policy.ShapeProtectedEndpointAction `protobuf:"bytes,27,opt,name=shape_protected_endpoint_action,json=shapeProtectedEndpointAction,proto3" json:"shape_protected_endpoint_action,omitempty"`
	// rate limiters
	//
	// x-displayName: "Rate Limiters"
	// References to rate_limiter objects.
	// Apply the specified rate_limiters.
	// Mutually exclusive with rate_limiter_specs.
	RateLimiters []*schema.ObjectRefType `protobuf:"bytes,28,rep,name=rate_limiters,json=rateLimiters,proto3" json:"rate_limiters,omitempty"`
	// rate limiter specs
	//
	// x-displayName: "Rate Limiter Specs"
	// Specs for rate_limiter objects.
	// Apply the specified rate_limiters.
	// Mutually exclusive with rate_limiters.
	RateLimiterSpecs []*rate_limiter.GlobalSpecType `protobuf:"bytes,29,rep,name=rate_limiter_specs,json=rateLimiterSpecs,proto3" json:"rate_limiter_specs,omitempty"`
	// Malicious User Mitigation Action
	//
	// x-displayName: "Malicious User Mitigation Action"
	// Specifies how Malicious User Mitigation is handled
	MumAction *policy.ModifyAction `protobuf:"bytes,30,opt,name=mum_action,json=mumAction,proto3" json:"mum_action,omitempty"`
	// IP Reputation Action
	//
	// x-displayName: "IP Reputation Action"
	// Specifies how IP Reputation is handled
	IpReputationAction *policy.ModifyAction `protobuf:"bytes,31,opt,name=ip_reputation_action,json=ipReputationAction,proto3" json:"ip_reputation_action,omitempty"`
	// goto_policy
	//
	// x-displayName: "Goto Policy"
	// A reference to a service_policy object.
	// Target of the GOTO_POLICY action.
	// The target policy must be part of the current policy set and must be after the current policy in the policy set.
	GotoPolicy []*schema.ObjectRefType `protobuf:"bytes,32,rep,name=goto_policy,json=gotoPolicy,proto3" json:"goto_policy,omitempty"`
	// ip matcher
	//
	// x-displayName: "IP Matcher"
	// Match any IP prefix contained in the list of ip_prefix_sets.
	// The result of the match is inverted if invert_matcher is true.
	IpMatcher *policy.IpMatcherType `protobuf:"bytes,33,opt,name=ip_matcher,json=ipMatcher,proto3" json:"ip_matcher,omitempty"`
	// asn matcher
	//
	// x-displayName: "ASN Matcher"
	// Match any AS number contained in the list of bgp_asn_sets. A list of references to bgp_asn_set objects.
	AsnMatcher *policy.AsnMatcherType `protobuf:"bytes,34,opt,name=asn_matcher,json=asnMatcher,proto3" json:"asn_matcher,omitempty"`
	// user identity matcher
	//
	// x-displayName: "User Identity Matcher"
	// x-example: "IP-x.x.x.x"
	// Match the specified user identity. The format is prefixed by the type.
	UserIdentityMatcher *policy.MatcherTypeBasic `protobuf:"bytes,35,opt,name=user_identity_matcher,json=userIdentityMatcher,proto3" json:"user_identity_matcher,omitempty"`
	// body matcher
	//
	// x-displayName: "Request Body Matcher"
	// Predicate for matching the request body string. The criteria for matching the request body is described in MatcherType.
	// The actual request body value is extracted from the request API as a string.
	BodyMatcher *policy.MatcherType `protobuf:"bytes,36,opt,name=body_matcher,json=bodyMatcher,proto3" json:"body_matcher,omitempty"`
	// virtual host matcher
	//
	// x-displayName: "Virtual Host Matcher"
	// A list of exact values and/or regular expressions for the expected name of the virtual_host. The name of the virtual_host is is part of the context in
	// which a service_policy_set is evaluated. The predicate evaluates to true if the virtual_host name matches any of the exact values or regular expressions
	// in the virtual_host matcher.
	// Hidden because this will be used only in system generated rate limiting service_policy_sets.
	VirtualHostMatcher *policy.MatcherType `protobuf:"bytes,37,opt,name=virtual_host_matcher,json=virtualHostMatcher,proto3" json:"virtual_host_matcher,omitempty"`
	// challenge action
	//
	// x-displayName: "Select Challenge Action Type"
	// x-required
	// Select challenge action, enable javascript/captcha challenge or disable challenge
	ChallengeAction policy.ChallengeAction `protobuf:"varint,38,opt,name=challenge_action,json=challengeAction,proto3,enum=ves.io.schema.policy.ChallengeAction" json:"challenge_action,omitempty"`
	// query params
	//
	// x-displayName: "HTTP Query Parameters"
	// A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances
	// of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.
	// Note that all specified query parameter predicates must evaluate to true.
	QueryParams []*policy.QueryParameterMatcherType `protobuf:"bytes,39,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	// arg matchers
	//
	// x-displayName: "Argument Matchers"
	// A list of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances
	// of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name.
	// Note that all specified arg matcher predicates must evaluate to true.
	ArgMatchers []*policy.ArgMatcherType `protobuf:"bytes,40,rep,name=arg_matchers,json=argMatchers,proto3" json:"arg_matchers,omitempty"`
	// cookie matchers
	//
	// x-displayName: "Cookie Matchers"
	// A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances
	// of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.
	// Note that all specified cookie matcher predicates must evaluate to true.
	CookieMatchers []*policy.CookieMatcherType `protobuf:"bytes,41,rep,name=cookie_matchers,json=cookieMatchers,proto3" json:"cookie_matchers,omitempty"`
	// request constraints
	//
	// x-displayName: "Request Constraints"
	// Place limits on request based on the request attributes. The request matches if any of the attribute sizes exceed the corresponding maximum value.
	RequestConstraints *policy.RequestConstraintType `protobuf:"bytes,42,opt,name=request_constraints,json=requestConstraints,proto3" json:"request_constraints,omitempty"`
	// GraphQL Settings
	//
	// x-displayName: "GraphQL Settings"
	// GraphQL policy settings to be applied for this request
	GraphqlSettings *policy.GraphQLSettingsType `protobuf:"bytes,43,opt,name=graphql_settings,json=graphqlSettings,proto3" json:"graphql_settings,omitempty"`
	// OpenAPI Validation Action
	//
	// x-displayName: "OpenAPI Validation Action"
	// OpenAPI validation policy settings to be applied for this request
	OpenapiValidationAction *policy.OpenApiValidationAction `protobuf:"bytes,44,opt,name=openapi_validation_action,json=openapiValidationAction,proto3" json:"openapi_validation_action,omitempty"`
	// client name
	//
	// x-displayName: "Client Name"
	// x-example: "backend.production.customer.volterra.us"
	// The expected name of the client invoking the request API.
	// The predicate evaluates to true if any of the actual names is the same as the expected client name.
	ClientName string `protobuf:"bytes,46,opt,name=client_name,json=clientName,proto3" json:"client_name,omitempty"`
	// client name matcher
	//
	// x-displayName: "Group of Clients by Name"
	// A list of exact values and/or regular expressions for the expected name of the client.
	// This is a generalized version of the client name predicate that allows the same rule to be applicable to a set of clients rather than a single client.
	// The predicate evaluates to true if any of the client's actual names match any of the exact values or regular expressions in the client name matcher.
	ClientNameMatcher *policy.MatcherType `protobuf:"bytes,47,opt,name=client_name_matcher,json=clientNameMatcher,proto3" json:"client_name_matcher,omitempty"`
	// ip matcher
	//
	// x-displayName: "Destination IP Prefix Sets"
	// List of references to IP Prefix Set objects.
	// The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes in the IP Prefix Sets.
	DstIpMatcher *policy.IpMatcherType `protobuf:"bytes,48,opt,name=dst_ip_matcher,json=dstIpMatcher,proto3" json:"dst_ip_matcher,omitempty"`
	// dst asn list
	//
	// x-displayName: "Destination ASN List"
	// List of 4-byte ASN values.
	// The predicate evaluates to true if the destination ASN is present in the ASN list.
	DstAsnList *policy.AsnMatchList `protobuf:"bytes,49,opt,name=dst_asn_list,json=dstAsnList,proto3" json:"dst_asn_list,omitempty"`
	// dst asn matcher
	//
	// x-displayName: "Destination BGP ASN Sets"
	// List of references to BGP ASN Set objects.
	// The predicate evaluates to true if the destination ASN is present in one of the BGP ASN Set objects.
	DstAsnMatcher *policy.AsnMatcherType `protobuf:"bytes,50,opt,name=dst_asn_matcher,json=dstAsnMatcher,proto3" json:"dst_asn_matcher,omitempty"`
	// Origin Server Subsets Action
	//
	// x-displayName: "Origin Server Subsets Action"
	// x-example: "value"
	// Add Labels for this origin server, these labels can be used to form subset.
	OriginServerSubsetsAction map[string]string `protobuf:"bytes,51,rep,name=origin_server_subsets_action,json=originServerSubsetsAction,proto3" json:"origin_server_subsets_action,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// JWT claims
	//
	// x-displayName: "JWT Claims"
	// A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType
	// instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.
	// Note that all specified JWT claim predicates must evaluate to true.
	JwtClaims []*policy.JWTClaimMatcherType `protobuf:"bytes,52,rep,name=jwt_claims,json=jwtClaims,proto3" json:"jwt_claims,omitempty"`
}

func (m *SimpleRule) Reset()      { *m = SimpleRule{} }
func (*SimpleRule) ProtoMessage() {}
func (*SimpleRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{0}
}
func (m *SimpleRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SimpleRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleRule.Merge(m, src)
}
func (m *SimpleRule) XXX_Size() int {
	return m.Size()
}
func (m *SimpleRule) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleRule.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleRule proto.InternalMessageInfo

func (m *SimpleRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SimpleRule) GetMetricNameLabel() string {
	if m != nil {
		return m.MetricNameLabel
	}
	return ""
}

func (m *SimpleRule) GetAction() policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return policy.DENY
}

func (m *SimpleRule) GetDomainMatcher() *policy.MatcherType {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *SimpleRule) GetPath() *policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *SimpleRule) GetHeaders() []*policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *SimpleRule) GetHttpMethod() *policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *SimpleRule) GetWafAction() *policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *SimpleRule) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *SimpleRule) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *SimpleRule) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *SimpleRule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SimpleRule) GetUrlMatcher() *policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *SimpleRule) GetL4DestMatcher() *policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *SimpleRule) GetIpPrefixList() *policy.PrefixMatchList {
	if m != nil {
		return m.IpPrefixList
	}
	return nil
}

func (m *SimpleRule) GetDstIpPrefixList() *policy.PrefixMatchList {
	if m != nil {
		return m.DstIpPrefixList
	}
	return nil
}

func (m *SimpleRule) GetTlsFingerprintMatcher() *policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *SimpleRule) GetAsnList() *policy.AsnMatchList {
	if m != nil {
		return m.AsnList
	}
	return nil
}

func (m *SimpleRule) GetApiGroupMatcher() *policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *SimpleRule) GetAdditionalApiGroupMatchers() []*policy.StringMatcherType {
	if m != nil {
		return m.AdditionalApiGroupMatchers
	}
	return nil
}

func (m *SimpleRule) GetClientRole() *policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *SimpleRule) GetClientSelector() *schema.LabelSelectorType {
	if m != nil {
		return m.ClientSelector
	}
	return nil
}

func (m *SimpleRule) GetServerSelector() *schema.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *SimpleRule) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *SimpleRule) GetBotAction() *policy.BotAction {
	if m != nil {
		return m.BotAction
	}
	return nil
}

func (m *SimpleRule) GetContentRewriteAction() *policy.ContentRewriteAction {
	if m != nil {
		return m.ContentRewriteAction
	}
	return nil
}

func (m *SimpleRule) GetShapeProtectedEndpointAction() *policy.ShapeProtectedEndpointAction {
	if m != nil {
		return m.ShapeProtectedEndpointAction
	}
	return nil
}

func (m *SimpleRule) GetRateLimiters() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiters
	}
	return nil
}

func (m *SimpleRule) GetRateLimiterSpecs() []*rate_limiter.GlobalSpecType {
	if m != nil {
		return m.RateLimiterSpecs
	}
	return nil
}

func (m *SimpleRule) GetMumAction() *policy.ModifyAction {
	if m != nil {
		return m.MumAction
	}
	return nil
}

func (m *SimpleRule) GetIpReputationAction() *policy.ModifyAction {
	if m != nil {
		return m.IpReputationAction
	}
	return nil
}

func (m *SimpleRule) GetGotoPolicy() []*schema.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

func (m *SimpleRule) GetIpMatcher() *policy.IpMatcherType {
	if m != nil {
		return m.IpMatcher
	}
	return nil
}

func (m *SimpleRule) GetAsnMatcher() *policy.AsnMatcherType {
	if m != nil {
		return m.AsnMatcher
	}
	return nil
}

func (m *SimpleRule) GetUserIdentityMatcher() *policy.MatcherTypeBasic {
	if m != nil {
		return m.UserIdentityMatcher
	}
	return nil
}

func (m *SimpleRule) GetBodyMatcher() *policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *SimpleRule) GetVirtualHostMatcher() *policy.MatcherType {
	if m != nil {
		return m.VirtualHostMatcher
	}
	return nil
}

func (m *SimpleRule) GetChallengeAction() policy.ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return policy.DEFAULT_CHALLENGE
}

func (m *SimpleRule) GetQueryParams() []*policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *SimpleRule) GetArgMatchers() []*policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *SimpleRule) GetCookieMatchers() []*policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *SimpleRule) GetRequestConstraints() *policy.RequestConstraintType {
	if m != nil {
		return m.RequestConstraints
	}
	return nil
}

func (m *SimpleRule) GetGraphqlSettings() *policy.GraphQLSettingsType {
	if m != nil {
		return m.GraphqlSettings
	}
	return nil
}

func (m *SimpleRule) GetOpenapiValidationAction() *policy.OpenApiValidationAction {
	if m != nil {
		return m.OpenapiValidationAction
	}
	return nil
}

func (m *SimpleRule) GetClientName() string {
	if m != nil {
		return m.ClientName
	}
	return ""
}

func (m *SimpleRule) GetClientNameMatcher() *policy.MatcherType {
	if m != nil {
		return m.ClientNameMatcher
	}
	return nil
}

func (m *SimpleRule) GetDstIpMatcher() *policy.IpMatcherType {
	if m != nil {
		return m.DstIpMatcher
	}
	return nil
}

func (m *SimpleRule) GetDstAsnList() *policy.AsnMatchList {
	if m != nil {
		return m.DstAsnList
	}
	return nil
}

func (m *SimpleRule) GetDstAsnMatcher() *policy.AsnMatcherType {
	if m != nil {
		return m.DstAsnMatcher
	}
	return nil
}

func (m *SimpleRule) GetOriginServerSubsetsAction() map[string]string {
	if m != nil {
		return m.OriginServerSubsetsAction
	}
	return nil
}

func (m *SimpleRule) GetJwtClaims() []*policy.JWTClaimMatcherType {
	if m != nil {
		return m.JwtClaims
	}
	return nil
}

// source_list
//
// x-displayName: "Source List"
// List of sources. A request belongs to this list if it satisfies any of the match criteria.
type SourceList struct {
	// prefix_list
	//
	// x-displayName: "IPv4 Prefix List"
	// Addresses that are covered by the given list of IPv4 prefixes
	PrefixList *views.PrefixStringListType `protobuf:"bytes,2,opt,name=prefix_list,json=prefixList,proto3" json:"prefix_list,omitempty"`
	// ip_prefix_set
	//
	// x-displayName: "IP Prefix Set"
	// Addresses that are covered by the prefixes in the given ip_prefix_set
	IpPrefixSet []*views.ObjectRefType `protobuf:"bytes,3,rep,name=ip_prefix_set,json=ipPrefixSet,proto3" json:"ip_prefix_set,omitempty"`
	// asn_list
	//
	// x-displayName: "BGP ASN List"
	// Addresses that belong to the ASNs in the given list
	// The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.
	AsnList *policy.AsnMatchList `protobuf:"bytes,4,opt,name=asn_list,json=asnList,proto3" json:"asn_list,omitempty"`
	// asn_set
	//
	// x-displayName: "BGP ASN Set"
	// Addresses that belong to the ASNs in the given bgp_asn_set
	// The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.
	AsnSet []*views.ObjectRefType `protobuf:"bytes,5,rep,name=asn_set,json=asnSet,proto3" json:"asn_set,omitempty"`
	// country_list
	//
	// x-displayName: "Country List"
	// Addresses that belong to one of the countries in the given list
	// The country is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.
	CountryList []policy.CountryCode `protobuf:"varint,6,rep,packed,name=country_list,json=countryList,proto3,enum=ves.io.schema.policy.CountryCode" json:"country_list,omitempty"`
	// tls_fingerprint_classes
	//
	// x-displayName: "TLS Fingerprint Classes"
	// A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.
	TlsFingerprintClasses []policy.KnownTlsFingerprintClass `protobuf:"varint,7,rep,packed,name=tls_fingerprint_classes,json=tlsFingerprintClasses,proto3,enum=ves.io.schema.policy.KnownTlsFingerprintClass" json:"tls_fingerprint_classes,omitempty"`
	// tls_fingerprint_classes
	//
	// x-displayName: "TLS Fingerprint Values"
	// x-example: "1aa7bf8b97e540ca5edd75f7b8384bfa"
	// A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.
	TlsFingerprintValues []string `protobuf:"bytes,8,rep,name=tls_fingerprint_values,json=tlsFingerprintValues,proto3" json:"tls_fingerprint_values,omitempty"`
	// Default Action
	//
	// x-displayName: "Default Action"
	// x-required
	// Default action for requests from source that do not belong to this list
	//
	// Types that are valid to be assigned to DefaultActionChoice:
	//	*SourceList_DefaultActionNextPolicy
	//	*SourceList_DefaultActionDeny
	//	*SourceList_DefaultActionAllow
	DefaultActionChoice isSourceList_DefaultActionChoice `protobuf_oneof:"default_action_choice"`
}

func (m *SourceList) Reset()      { *m = SourceList{} }
func (*SourceList) ProtoMessage() {}
func (*SourceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{1}
}
func (m *SourceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SourceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceList.Merge(m, src)
}
func (m *SourceList) XXX_Size() int {
	return m.Size()
}
func (m *SourceList) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceList.DiscardUnknown(m)
}

var xxx_messageInfo_SourceList proto.InternalMessageInfo

type isSourceList_DefaultActionChoice interface {
	isSourceList_DefaultActionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SourceList_DefaultActionNextPolicy struct {
	DefaultActionNextPolicy *schema.Empty `protobuf:"bytes,11,opt,name=default_action_next_policy,json=defaultActionNextPolicy,proto3,oneof" json:"default_action_next_policy,omitempty"`
}
type SourceList_DefaultActionDeny struct {
	DefaultActionDeny *schema.Empty `protobuf:"bytes,12,opt,name=default_action_deny,json=defaultActionDeny,proto3,oneof" json:"default_action_deny,omitempty"`
}
type SourceList_DefaultActionAllow struct {
	DefaultActionAllow *schema.Empty `protobuf:"bytes,13,opt,name=default_action_allow,json=defaultActionAllow,proto3,oneof" json:"default_action_allow,omitempty"`
}

func (*SourceList_DefaultActionNextPolicy) isSourceList_DefaultActionChoice() {}
func (*SourceList_DefaultActionDeny) isSourceList_DefaultActionChoice()       {}
func (*SourceList_DefaultActionAllow) isSourceList_DefaultActionChoice()      {}

func (m *SourceList) GetDefaultActionChoice() isSourceList_DefaultActionChoice {
	if m != nil {
		return m.DefaultActionChoice
	}
	return nil
}

func (m *SourceList) GetPrefixList() *views.PrefixStringListType {
	if m != nil {
		return m.PrefixList
	}
	return nil
}

func (m *SourceList) GetIpPrefixSet() []*views.ObjectRefType {
	if m != nil {
		return m.IpPrefixSet
	}
	return nil
}

func (m *SourceList) GetAsnList() *policy.AsnMatchList {
	if m != nil {
		return m.AsnList
	}
	return nil
}

func (m *SourceList) GetAsnSet() []*views.ObjectRefType {
	if m != nil {
		return m.AsnSet
	}
	return nil
}

func (m *SourceList) GetCountryList() []policy.CountryCode {
	if m != nil {
		return m.CountryList
	}
	return nil
}

func (m *SourceList) GetTlsFingerprintClasses() []policy.KnownTlsFingerprintClass {
	if m != nil {
		return m.TlsFingerprintClasses
	}
	return nil
}

func (m *SourceList) GetTlsFingerprintValues() []string {
	if m != nil {
		return m.TlsFingerprintValues
	}
	return nil
}

func (m *SourceList) GetDefaultActionNextPolicy() *schema.Empty {
	if x, ok := m.GetDefaultActionChoice().(*SourceList_DefaultActionNextPolicy); ok {
		return x.DefaultActionNextPolicy
	}
	return nil
}

func (m *SourceList) GetDefaultActionDeny() *schema.Empty {
	if x, ok := m.GetDefaultActionChoice().(*SourceList_DefaultActionDeny); ok {
		return x.DefaultActionDeny
	}
	return nil
}

func (m *SourceList) GetDefaultActionAllow() *schema.Empty {
	if x, ok := m.GetDefaultActionChoice().(*SourceList_DefaultActionAllow); ok {
		return x.DefaultActionAllow
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SourceList) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SourceList_DefaultActionNextPolicy)(nil),
		(*SourceList_DefaultActionDeny)(nil),
		(*SourceList_DefaultActionAllow)(nil),
	}
}

// rule
//
// x-displayName: "Rule"
// A Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from
// or derived from an L7 request API. A request API is considered to match the simple rule if all predicates in the rule evaluate to true for that request. Any
// predicates that are not specified in a rule are implicitly considered to be true. If a request API matches a simple rule, the action for the simple rule is
// enforced.
type Rule struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// spec
	//
	// x-displayName: "Rule Specification"
	// x-required
	// Specification for the rule including match predicates and actions.
	Spec *service_policy_rule.GlobalSpecType `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *Rule) Reset()      { *m = Rule{} }
func (*Rule) ProtoMessage() {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{2}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

func (m *Rule) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Rule) GetSpec() *service_policy_rule.GlobalSpecType {
	if m != nil {
		return m.Spec
	}
	return nil
}

// rule list
//
// x-displayName: "Rule List"
// A list of rules.
// The order of evaluation of the rules depends on the rule combining algorithm.
type RuleList struct {
	// rules
	//
	// x-displayName: "Rules"
	// Define the list of rules (with an order) that should be evaluated by this service policy.
	// Rules are evaluated from top to bottom in the list.
	Rules []*Rule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *RuleList) Reset()      { *m = RuleList{} }
func (*RuleList) ProtoMessage() {}
func (*RuleList) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{3}
}
func (m *RuleList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RuleList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleList.Merge(m, src)
}
func (m *RuleList) XXX_Size() int {
	return m.Size()
}
func (m *RuleList) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleList.DiscardUnknown(m)
}

var xxx_messageInfo_RuleList proto.InternalMessageInfo

func (m *RuleList) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// LegacyRuleList
//
// x-displayName: "Legacy Rules"
// A list of references to service_policy_rule objects.
// The order of evaluation of the rules depends on the rule combining algorithm.
type LegacyRuleList struct {
	// rules
	//
	// x-displayName: "Rules"
	// A list of references to service_policy_rule objects.
	// The order of evaluation of the rules depends on the rule combining algorithm.
	Rules []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *LegacyRuleList) Reset()      { *m = LegacyRuleList{} }
func (*LegacyRuleList) ProtoMessage() {}
func (*LegacyRuleList) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{4}
}
func (m *LegacyRuleList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LegacyRuleList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LegacyRuleList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LegacyRuleList.Merge(m, src)
}
func (m *LegacyRuleList) XXX_Size() int {
	return m.Size()
}
func (m *LegacyRuleList) XXX_DiscardUnknown() {
	xxx_messageInfo_LegacyRuleList.DiscardUnknown(m)
}

var xxx_messageInfo_LegacyRuleList proto.InternalMessageInfo

func (m *LegacyRuleList) GetRules() []*schema.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Specification"
// Shape of service_policy in the storage backend.
type GlobalSpecType struct {
	// algo
	//
	// x-displayName: "Rule Combining Algorithm"
	// x-required
	// The rule combining algorithm determines how the list of rules in the policy is evaluated.
	//
	// - FIRST_MATCH Rules are evaluated sequentially till a matching rule is identified
	// - ALLOW_OVERRIDES Rules with an ALLOW action are evaluated prior to rules with a DENY action
	// - DENY_OVERRIDES Rules with a DENY action are evaluated prior to rules with an ALLOW action
	Algo policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// server choice
	//
	// x-displayName: "Server Selection"
	// x-required
	// Select servers for which the policy will be applied.
	//
	// Types that are valid to be assigned to ServerChoice:
	//	*GlobalSpecType_AnyServer
	//	*GlobalSpecType_ServerName
	//	*GlobalSpecType_ServerSelector
	//	*GlobalSpecType_ServerNameMatcher
	ServerChoice isGlobalSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	// port matcher
	//
	// x-displayName: "Port Matcher"
	// The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.
	PortMatcher *policy.PortMatcherType `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	// role
	//
	// x-displayName: "Role"
	// The expected role of the client invoking the request API. The actual roles for the client are derived from the user and namespace information in the API
	// request.
	// The predicate evaluates to true if any of the client's roles match the value specified in role.
	Role *policy.RoleMatcherType `protobuf:"bytes,7,opt,name=role,proto3" json:"role,omitempty"`
	// deny_info
	//
	// x-displayName: "Deny Information"
	// Detailed information including HTTP response code and error message to be sent when the policy action is DENY.
	DenyInfo *policy.DenyInformation `protobuf:"bytes,8,opt,name=deny_info,json=denyInfo,proto3" json:"deny_info,omitempty"`
	// Default Forwarding Classes
	//
	// x-displayName: "Default Forwarding Classes"
	// Ordered list of forwarding class to use for traffic that match the enclosing rule
	// Action valid only when the policy is used PBR
	DefaultForwardingClasses []*schema.ObjectRefType `protobuf:"bytes,9,rep,name=default_forwarding_classes,json=defaultForwardingClasses,proto3" json:"default_forwarding_classes,omitempty"`
	// rules
	//
	// x-displayName: "Rules"
	// A list of references to service_policy_rule objects.
	// The order of evaluation of the rules depends on the rule combining algorithm.
	// TBD mark as hidden + internal after implementation is ready
	Rules []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=rules,proto3" json:"rules,omitempty"`
	// rule choice
	//
	// x-displayName: "Select Policy Rules"
	// x-required
	// Allowed/Denied Sources rules provide the ability to allow/deny lists of IP addresses, countries, TLS fingerprints and ASNs.
	// Custom rules provide more flexibility to define your own logic to control incoming requests.
	//
	// Types that are valid to be assigned to RuleChoice:
	//	*GlobalSpecType_AllowList
	//	*GlobalSpecType_DenyList
	//	*GlobalSpecType_RuleList
	//	*GlobalSpecType_LegacyRuleList
	//	*GlobalSpecType_AllowAllRequests
	//	*GlobalSpecType_DenyAllRequests
	//	*GlobalSpecType_InternallyGenerated
	RuleChoice isGlobalSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
	// Segments
	//
	// x-displayName: "Configure Segments"
	// Select source and destination segments where rule is applied
	// Skip the configuration or set option as Any to ignore corresponding segment match
	SegmentPolicy *policy.SegmentPolicyType `protobuf:"bytes,28,opt,name=segment_policy,json=segmentPolicy,proto3" json:"segment_policy,omitempty"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal,proto3" json:"view_internal,omitempty"`
	// simple_rules
	//
	// x-displayName: "Simple Rules"
	// A list of SimpleRules.
	// The order of evaluation of the simple rules depends on the rule combining algorithm.
	// This is mutually exclusive with the rules field and is for internal use only.
	SimpleRules []*SimpleRule `protobuf:"bytes,1001,rep,name=simple_rules,json=simpleRules,proto3" json:"simple_rules,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{5}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_ServerChoice interface {
	isGlobalSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_RuleChoice interface {
	isGlobalSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type GlobalSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type GlobalSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}
type GlobalSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type GlobalSpecType_AllowList struct {
	AllowList *SourceList `protobuf:"bytes,21,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type GlobalSpecType_DenyList struct {
	DenyList *SourceList `protobuf:"bytes,22,opt,name=deny_list,json=denyList,proto3,oneof" json:"deny_list,omitempty"`
}
type GlobalSpecType_RuleList struct {
	RuleList *RuleList `protobuf:"bytes,23,opt,name=rule_list,json=ruleList,proto3,oneof" json:"rule_list,omitempty"`
}
type GlobalSpecType_LegacyRuleList struct {
	LegacyRuleList *LegacyRuleList `protobuf:"bytes,24,opt,name=legacy_rule_list,json=legacyRuleList,proto3,oneof" json:"legacy_rule_list,omitempty"`
}
type GlobalSpecType_AllowAllRequests struct {
	AllowAllRequests *schema.Empty `protobuf:"bytes,26,opt,name=allow_all_requests,json=allowAllRequests,proto3,oneof" json:"allow_all_requests,omitempty"`
}
type GlobalSpecType_DenyAllRequests struct {
	DenyAllRequests *schema.Empty `protobuf:"bytes,27,opt,name=deny_all_requests,json=denyAllRequests,proto3,oneof" json:"deny_all_requests,omitempty"`
}
type GlobalSpecType_InternallyGenerated struct {
	InternallyGenerated *schema.Empty `protobuf:"bytes,25,opt,name=internally_generated,json=internallyGenerated,proto3,oneof" json:"internally_generated,omitempty"`
}

func (*GlobalSpecType_AnyServer) isGlobalSpecType_ServerChoice()         {}
func (*GlobalSpecType_ServerName) isGlobalSpecType_ServerChoice()        {}
func (*GlobalSpecType_ServerSelector) isGlobalSpecType_ServerChoice()    {}
func (*GlobalSpecType_ServerNameMatcher) isGlobalSpecType_ServerChoice() {}
func (*GlobalSpecType_AllowList) isGlobalSpecType_RuleChoice()           {}
func (*GlobalSpecType_DenyList) isGlobalSpecType_RuleChoice()            {}
func (*GlobalSpecType_RuleList) isGlobalSpecType_RuleChoice()            {}
func (*GlobalSpecType_LegacyRuleList) isGlobalSpecType_RuleChoice()      {}
func (*GlobalSpecType_AllowAllRequests) isGlobalSpecType_RuleChoice()    {}
func (*GlobalSpecType_DenyAllRequests) isGlobalSpecType_RuleChoice()     {}
func (*GlobalSpecType_InternallyGenerated) isGlobalSpecType_RuleChoice() {}

func (m *GlobalSpecType) GetServerChoice() isGlobalSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}
func (m *GlobalSpecType) GetRuleChoice() isGlobalSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *GlobalSpecType) GetAlgo() policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return policy.FIRST_MATCH
}

func (m *GlobalSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *GlobalSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GlobalSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *GlobalSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetRole() *policy.RoleMatcherType {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *GlobalSpecType) GetDenyInfo() *policy.DenyInformation {
	if m != nil {
		return m.DenyInfo
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultForwardingClasses() []*schema.ObjectRefType {
	if m != nil {
		return m.DefaultForwardingClasses
	}
	return nil
}

func (m *GlobalSpecType) GetRules() []*schema.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *GlobalSpecType) GetAllowList() *SourceList {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *GlobalSpecType) GetDenyList() *SourceList {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_DenyList); ok {
		return x.DenyList
	}
	return nil
}

func (m *GlobalSpecType) GetRuleList() *RuleList {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_RuleList); ok {
		return x.RuleList
	}
	return nil
}

func (m *GlobalSpecType) GetLegacyRuleList() *LegacyRuleList {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_LegacyRuleList); ok {
		return x.LegacyRuleList
	}
	return nil
}

func (m *GlobalSpecType) GetAllowAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_AllowAllRequests); ok {
		return x.AllowAllRequests
	}
	return nil
}

func (m *GlobalSpecType) GetDenyAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_DenyAllRequests); ok {
		return x.DenyAllRequests
	}
	return nil
}

func (m *GlobalSpecType) GetInternallyGenerated() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_InternallyGenerated); ok {
		return x.InternallyGenerated
	}
	return nil
}

func (m *GlobalSpecType) GetSegmentPolicy() *policy.SegmentPolicyType {
	if m != nil {
		return m.SegmentPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

func (m *GlobalSpecType) GetSimpleRules() []*SimpleRule {
	if m != nil {
		return m.SimpleRules
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_AnyServer)(nil),
		(*GlobalSpecType_ServerName)(nil),
		(*GlobalSpecType_ServerSelector)(nil),
		(*GlobalSpecType_ServerNameMatcher)(nil),
		(*GlobalSpecType_AllowList)(nil),
		(*GlobalSpecType_DenyList)(nil),
		(*GlobalSpecType_RuleList)(nil),
		(*GlobalSpecType_LegacyRuleList)(nil),
		(*GlobalSpecType_AllowAllRequests)(nil),
		(*GlobalSpecType_DenyAllRequests)(nil),
		(*GlobalSpecType_InternallyGenerated)(nil),
	}
}

// Create service policy
//
// x-displayName: "Create Service Policy"
// Create service_policy creates a new object in the storage backend for metadata.namespace.
type CreateSpecType struct {
	Algo policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// Types that are valid to be assigned to ServerChoice:
	//	*CreateSpecType_AnyServer
	//	*CreateSpecType_ServerName
	//	*CreateSpecType_ServerSelector
	//	*CreateSpecType_ServerNameMatcher
	ServerChoice isCreateSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	PortMatcher  *policy.PortMatcherType       `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	// Types that are valid to be assigned to RuleChoice:
	//	*CreateSpecType_AllowList
	//	*CreateSpecType_DenyList
	//	*CreateSpecType_RuleList
	//	*CreateSpecType_LegacyRuleList
	//	*CreateSpecType_AllowAllRequests
	//	*CreateSpecType_DenyAllRequests
	//	*CreateSpecType_InternallyGenerated
	RuleChoice    isCreateSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
	SegmentPolicy *policy.SegmentPolicyType   `protobuf:"bytes,28,opt,name=segment_policy,json=segmentPolicy,proto3" json:"segment_policy,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{6}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_ServerChoice interface {
	isCreateSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_RuleChoice interface {
	isCreateSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type CreateSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type CreateSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}
type CreateSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type CreateSpecType_AllowList struct {
	AllowList *SourceList `protobuf:"bytes,21,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type CreateSpecType_DenyList struct {
	DenyList *SourceList `protobuf:"bytes,22,opt,name=deny_list,json=denyList,proto3,oneof" json:"deny_list,omitempty"`
}
type CreateSpecType_RuleList struct {
	RuleList *RuleList `protobuf:"bytes,23,opt,name=rule_list,json=ruleList,proto3,oneof" json:"rule_list,omitempty"`
}
type CreateSpecType_LegacyRuleList struct {
	LegacyRuleList *LegacyRuleList `protobuf:"bytes,24,opt,name=legacy_rule_list,json=legacyRuleList,proto3,oneof" json:"legacy_rule_list,omitempty"`
}
type CreateSpecType_AllowAllRequests struct {
	AllowAllRequests *schema.Empty `protobuf:"bytes,26,opt,name=allow_all_requests,json=allowAllRequests,proto3,oneof" json:"allow_all_requests,omitempty"`
}
type CreateSpecType_DenyAllRequests struct {
	DenyAllRequests *schema.Empty `protobuf:"bytes,27,opt,name=deny_all_requests,json=denyAllRequests,proto3,oneof" json:"deny_all_requests,omitempty"`
}
type CreateSpecType_InternallyGenerated struct {
	InternallyGenerated *schema.Empty `protobuf:"bytes,25,opt,name=internally_generated,json=internallyGenerated,proto3,oneof" json:"internally_generated,omitempty"`
}

func (*CreateSpecType_AnyServer) isCreateSpecType_ServerChoice()         {}
func (*CreateSpecType_ServerName) isCreateSpecType_ServerChoice()        {}
func (*CreateSpecType_ServerSelector) isCreateSpecType_ServerChoice()    {}
func (*CreateSpecType_ServerNameMatcher) isCreateSpecType_ServerChoice() {}
func (*CreateSpecType_AllowList) isCreateSpecType_RuleChoice()           {}
func (*CreateSpecType_DenyList) isCreateSpecType_RuleChoice()            {}
func (*CreateSpecType_RuleList) isCreateSpecType_RuleChoice()            {}
func (*CreateSpecType_LegacyRuleList) isCreateSpecType_RuleChoice()      {}
func (*CreateSpecType_AllowAllRequests) isCreateSpecType_RuleChoice()    {}
func (*CreateSpecType_DenyAllRequests) isCreateSpecType_RuleChoice()     {}
func (*CreateSpecType_InternallyGenerated) isCreateSpecType_RuleChoice() {}

func (m *CreateSpecType) GetServerChoice() isCreateSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}
func (m *CreateSpecType) GetRuleChoice() isCreateSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *CreateSpecType) GetAlgo() policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return policy.FIRST_MATCH
}

func (m *CreateSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*CreateSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *CreateSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *CreateSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *CreateSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *CreateSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAllowList() *SourceList {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *CreateSpecType) GetDenyList() *SourceList {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_DenyList); ok {
		return x.DenyList
	}
	return nil
}

func (m *CreateSpecType) GetRuleList() *RuleList {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_RuleList); ok {
		return x.RuleList
	}
	return nil
}

func (m *CreateSpecType) GetLegacyRuleList() *LegacyRuleList {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_LegacyRuleList); ok {
		return x.LegacyRuleList
	}
	return nil
}

func (m *CreateSpecType) GetAllowAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_AllowAllRequests); ok {
		return x.AllowAllRequests
	}
	return nil
}

func (m *CreateSpecType) GetDenyAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_DenyAllRequests); ok {
		return x.DenyAllRequests
	}
	return nil
}

func (m *CreateSpecType) GetInternallyGenerated() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_InternallyGenerated); ok {
		return x.InternallyGenerated
	}
	return nil
}

func (m *CreateSpecType) GetSegmentPolicy() *policy.SegmentPolicyType {
	if m != nil {
		return m.SegmentPolicy
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_AnyServer)(nil),
		(*CreateSpecType_ServerName)(nil),
		(*CreateSpecType_ServerSelector)(nil),
		(*CreateSpecType_ServerNameMatcher)(nil),
		(*CreateSpecType_AllowList)(nil),
		(*CreateSpecType_DenyList)(nil),
		(*CreateSpecType_RuleList)(nil),
		(*CreateSpecType_LegacyRuleList)(nil),
		(*CreateSpecType_AllowAllRequests)(nil),
		(*CreateSpecType_DenyAllRequests)(nil),
		(*CreateSpecType_InternallyGenerated)(nil),
	}
}

// Replace service policy
//
// x-displayName: "Replace Service Policy"
// Replace service_policy replaces an existing object in the storage backend for metadata.namespace.
type ReplaceSpecType struct {
	Algo policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// Types that are valid to be assigned to ServerChoice:
	//	*ReplaceSpecType_AnyServer
	//	*ReplaceSpecType_ServerName
	//	*ReplaceSpecType_ServerSelector
	//	*ReplaceSpecType_ServerNameMatcher
	ServerChoice isReplaceSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	PortMatcher  *policy.PortMatcherType        `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	// Types that are valid to be assigned to RuleChoice:
	//	*ReplaceSpecType_AllowList
	//	*ReplaceSpecType_DenyList
	//	*ReplaceSpecType_RuleList
	//	*ReplaceSpecType_LegacyRuleList
	//	*ReplaceSpecType_AllowAllRequests
	//	*ReplaceSpecType_DenyAllRequests
	//	*ReplaceSpecType_InternallyGenerated
	RuleChoice    isReplaceSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
	SegmentPolicy *policy.SegmentPolicyType    `protobuf:"bytes,28,opt,name=segment_policy,json=segmentPolicy,proto3" json:"segment_policy,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{7}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_ServerChoice interface {
	isReplaceSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_RuleChoice interface {
	isReplaceSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type ReplaceSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type ReplaceSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}
type ReplaceSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type ReplaceSpecType_AllowList struct {
	AllowList *SourceList `protobuf:"bytes,21,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type ReplaceSpecType_DenyList struct {
	DenyList *SourceList `protobuf:"bytes,22,opt,name=deny_list,json=denyList,proto3,oneof" json:"deny_list,omitempty"`
}
type ReplaceSpecType_RuleList struct {
	RuleList *RuleList `protobuf:"bytes,23,opt,name=rule_list,json=ruleList,proto3,oneof" json:"rule_list,omitempty"`
}
type ReplaceSpecType_LegacyRuleList struct {
	LegacyRuleList *LegacyRuleList `protobuf:"bytes,24,opt,name=legacy_rule_list,json=legacyRuleList,proto3,oneof" json:"legacy_rule_list,omitempty"`
}
type ReplaceSpecType_AllowAllRequests struct {
	AllowAllRequests *schema.Empty `protobuf:"bytes,26,opt,name=allow_all_requests,json=allowAllRequests,proto3,oneof" json:"allow_all_requests,omitempty"`
}
type ReplaceSpecType_DenyAllRequests struct {
	DenyAllRequests *schema.Empty `protobuf:"bytes,27,opt,name=deny_all_requests,json=denyAllRequests,proto3,oneof" json:"deny_all_requests,omitempty"`
}
type ReplaceSpecType_InternallyGenerated struct {
	InternallyGenerated *schema.Empty `protobuf:"bytes,25,opt,name=internally_generated,json=internallyGenerated,proto3,oneof" json:"internally_generated,omitempty"`
}

func (*ReplaceSpecType_AnyServer) isReplaceSpecType_ServerChoice()         {}
func (*ReplaceSpecType_ServerName) isReplaceSpecType_ServerChoice()        {}
func (*ReplaceSpecType_ServerSelector) isReplaceSpecType_ServerChoice()    {}
func (*ReplaceSpecType_ServerNameMatcher) isReplaceSpecType_ServerChoice() {}
func (*ReplaceSpecType_AllowList) isReplaceSpecType_RuleChoice()           {}
func (*ReplaceSpecType_DenyList) isReplaceSpecType_RuleChoice()            {}
func (*ReplaceSpecType_RuleList) isReplaceSpecType_RuleChoice()            {}
func (*ReplaceSpecType_LegacyRuleList) isReplaceSpecType_RuleChoice()      {}
func (*ReplaceSpecType_AllowAllRequests) isReplaceSpecType_RuleChoice()    {}
func (*ReplaceSpecType_DenyAllRequests) isReplaceSpecType_RuleChoice()     {}
func (*ReplaceSpecType_InternallyGenerated) isReplaceSpecType_RuleChoice() {}

func (m *ReplaceSpecType) GetServerChoice() isReplaceSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetRuleChoice() isReplaceSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetAlgo() policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return policy.FIRST_MATCH
}

func (m *ReplaceSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *ReplaceSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *ReplaceSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAllowList() *SourceList {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *ReplaceSpecType) GetDenyList() *SourceList {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_DenyList); ok {
		return x.DenyList
	}
	return nil
}

func (m *ReplaceSpecType) GetRuleList() *RuleList {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_RuleList); ok {
		return x.RuleList
	}
	return nil
}

func (m *ReplaceSpecType) GetLegacyRuleList() *LegacyRuleList {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_LegacyRuleList); ok {
		return x.LegacyRuleList
	}
	return nil
}

func (m *ReplaceSpecType) GetAllowAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_AllowAllRequests); ok {
		return x.AllowAllRequests
	}
	return nil
}

func (m *ReplaceSpecType) GetDenyAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_DenyAllRequests); ok {
		return x.DenyAllRequests
	}
	return nil
}

func (m *ReplaceSpecType) GetInternallyGenerated() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_InternallyGenerated); ok {
		return x.InternallyGenerated
	}
	return nil
}

func (m *ReplaceSpecType) GetSegmentPolicy() *policy.SegmentPolicyType {
	if m != nil {
		return m.SegmentPolicy
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_AnyServer)(nil),
		(*ReplaceSpecType_ServerName)(nil),
		(*ReplaceSpecType_ServerSelector)(nil),
		(*ReplaceSpecType_ServerNameMatcher)(nil),
		(*ReplaceSpecType_AllowList)(nil),
		(*ReplaceSpecType_DenyList)(nil),
		(*ReplaceSpecType_RuleList)(nil),
		(*ReplaceSpecType_LegacyRuleList)(nil),
		(*ReplaceSpecType_AllowAllRequests)(nil),
		(*ReplaceSpecType_DenyAllRequests)(nil),
		(*ReplaceSpecType_InternallyGenerated)(nil),
	}
}

// Get service policy
//
// x-displayName: "Get Service Policy"
// Get service_policy reads a given object from storage backend for metadata.namespace.
type GetSpecType struct {
	Algo policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// Types that are valid to be assigned to ServerChoice:
	//	*GetSpecType_AnyServer
	//	*GetSpecType_ServerName
	//	*GetSpecType_ServerSelector
	//	*GetSpecType_ServerNameMatcher
	ServerChoice isGetSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	PortMatcher  *policy.PortMatcherType    `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	Rules        []*schema.ObjectRefType    `protobuf:"bytes,4,rep,name=rules,proto3" json:"rules,omitempty"`
	// Types that are valid to be assigned to RuleChoice:
	//	*GetSpecType_AllowList
	//	*GetSpecType_DenyList
	//	*GetSpecType_RuleList
	//	*GetSpecType_LegacyRuleList
	//	*GetSpecType_AllowAllRequests
	//	*GetSpecType_DenyAllRequests
	//	*GetSpecType_InternallyGenerated
	RuleChoice    isGetSpecType_RuleChoice  `protobuf_oneof:"rule_choice"`
	SegmentPolicy *policy.SegmentPolicyType `protobuf:"bytes,28,opt,name=segment_policy,json=segmentPolicy,proto3" json:"segment_policy,omitempty"`
	SimpleRules   []*SimpleRule             `protobuf:"bytes,1001,rep,name=simple_rules,json=simpleRules,proto3" json:"simple_rules,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{8}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_ServerChoice interface {
	isGetSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_RuleChoice interface {
	isGetSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type GetSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type GetSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}
type GetSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type GetSpecType_AllowList struct {
	AllowList *SourceList `protobuf:"bytes,21,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type GetSpecType_DenyList struct {
	DenyList *SourceList `protobuf:"bytes,22,opt,name=deny_list,json=denyList,proto3,oneof" json:"deny_list,omitempty"`
}
type GetSpecType_RuleList struct {
	RuleList *RuleList `protobuf:"bytes,23,opt,name=rule_list,json=ruleList,proto3,oneof" json:"rule_list,omitempty"`
}
type GetSpecType_LegacyRuleList struct {
	LegacyRuleList *LegacyRuleList `protobuf:"bytes,24,opt,name=legacy_rule_list,json=legacyRuleList,proto3,oneof" json:"legacy_rule_list,omitempty"`
}
type GetSpecType_AllowAllRequests struct {
	AllowAllRequests *schema.Empty `protobuf:"bytes,26,opt,name=allow_all_requests,json=allowAllRequests,proto3,oneof" json:"allow_all_requests,omitempty"`
}
type GetSpecType_DenyAllRequests struct {
	DenyAllRequests *schema.Empty `protobuf:"bytes,27,opt,name=deny_all_requests,json=denyAllRequests,proto3,oneof" json:"deny_all_requests,omitempty"`
}
type GetSpecType_InternallyGenerated struct {
	InternallyGenerated *schema.Empty `protobuf:"bytes,25,opt,name=internally_generated,json=internallyGenerated,proto3,oneof" json:"internally_generated,omitempty"`
}

func (*GetSpecType_AnyServer) isGetSpecType_ServerChoice()         {}
func (*GetSpecType_ServerName) isGetSpecType_ServerChoice()        {}
func (*GetSpecType_ServerSelector) isGetSpecType_ServerChoice()    {}
func (*GetSpecType_ServerNameMatcher) isGetSpecType_ServerChoice() {}
func (*GetSpecType_AllowList) isGetSpecType_RuleChoice()           {}
func (*GetSpecType_DenyList) isGetSpecType_RuleChoice()            {}
func (*GetSpecType_RuleList) isGetSpecType_RuleChoice()            {}
func (*GetSpecType_LegacyRuleList) isGetSpecType_RuleChoice()      {}
func (*GetSpecType_AllowAllRequests) isGetSpecType_RuleChoice()    {}
func (*GetSpecType_DenyAllRequests) isGetSpecType_RuleChoice()     {}
func (*GetSpecType_InternallyGenerated) isGetSpecType_RuleChoice() {}

func (m *GetSpecType) GetServerChoice() isGetSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}
func (m *GetSpecType) GetRuleChoice() isGetSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *GetSpecType) GetAlgo() policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return policy.FIRST_MATCH
}

func (m *GetSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*GetSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *GetSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GetSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *GetSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *GetSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GetSpecType) GetRules() []*schema.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *GetSpecType) GetAllowList() *SourceList {
	if x, ok := m.GetRuleChoice().(*GetSpecType_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *GetSpecType) GetDenyList() *SourceList {
	if x, ok := m.GetRuleChoice().(*GetSpecType_DenyList); ok {
		return x.DenyList
	}
	return nil
}

func (m *GetSpecType) GetRuleList() *RuleList {
	if x, ok := m.GetRuleChoice().(*GetSpecType_RuleList); ok {
		return x.RuleList
	}
	return nil
}

func (m *GetSpecType) GetLegacyRuleList() *LegacyRuleList {
	if x, ok := m.GetRuleChoice().(*GetSpecType_LegacyRuleList); ok {
		return x.LegacyRuleList
	}
	return nil
}

func (m *GetSpecType) GetAllowAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GetSpecType_AllowAllRequests); ok {
		return x.AllowAllRequests
	}
	return nil
}

func (m *GetSpecType) GetDenyAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GetSpecType_DenyAllRequests); ok {
		return x.DenyAllRequests
	}
	return nil
}

func (m *GetSpecType) GetInternallyGenerated() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GetSpecType_InternallyGenerated); ok {
		return x.InternallyGenerated
	}
	return nil
}

func (m *GetSpecType) GetSegmentPolicy() *policy.SegmentPolicyType {
	if m != nil {
		return m.SegmentPolicy
	}
	return nil
}

func (m *GetSpecType) GetSimpleRules() []*SimpleRule {
	if m != nil {
		return m.SimpleRules
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_AnyServer)(nil),
		(*GetSpecType_ServerName)(nil),
		(*GetSpecType_ServerSelector)(nil),
		(*GetSpecType_ServerNameMatcher)(nil),
		(*GetSpecType_AllowList)(nil),
		(*GetSpecType_DenyList)(nil),
		(*GetSpecType_RuleList)(nil),
		(*GetSpecType_LegacyRuleList)(nil),
		(*GetSpecType_AllowAllRequests)(nil),
		(*GetSpecType_DenyAllRequests)(nil),
		(*GetSpecType_InternallyGenerated)(nil),
	}
}

func init() {
	proto.RegisterType((*SimpleRule)(nil), "ves.io.schema.service_policy.SimpleRule")
	golang_proto.RegisterType((*SimpleRule)(nil), "ves.io.schema.service_policy.SimpleRule")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.service_policy.SimpleRule.OriginServerSubsetsActionEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.service_policy.SimpleRule.OriginServerSubsetsActionEntry")
	proto.RegisterType((*SourceList)(nil), "ves.io.schema.service_policy.SourceList")
	golang_proto.RegisterType((*SourceList)(nil), "ves.io.schema.service_policy.SourceList")
	proto.RegisterType((*Rule)(nil), "ves.io.schema.service_policy.Rule")
	golang_proto.RegisterType((*Rule)(nil), "ves.io.schema.service_policy.Rule")
	proto.RegisterType((*RuleList)(nil), "ves.io.schema.service_policy.RuleList")
	golang_proto.RegisterType((*RuleList)(nil), "ves.io.schema.service_policy.RuleList")
	proto.RegisterType((*LegacyRuleList)(nil), "ves.io.schema.service_policy.LegacyRuleList")
	golang_proto.RegisterType((*LegacyRuleList)(nil), "ves.io.schema.service_policy.LegacyRuleList")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/service_policy/types.proto", fileDescriptor_27dbd931e83f25b2)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/service_policy/types.proto", fileDescriptor_27dbd931e83f25b2)
}

var fileDescriptor_27dbd931e83f25b2 = []byte{
	// 5394 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0x4f, 0x6c, 0x1c, 0xd7,
	0x79, 0xd7, 0x88, 0x94, 0x48, 0x3d, 0x52, 0xe4, 0x6a, 0x44, 0x4b, 0x6b, 0xd9, 0xa1, 0x27, 0x8c,
	0xed, 0xc8, 0x34, 0x45, 0xbd, 0xff, 0xf3, 0x9e, 0x81, 0x06, 0x11, 0x69, 0x59, 0x92, 0x2d, 0xc9,
	0xf2, 0x52, 0x4d, 0xdc, 0x34, 0xc9, 0xfa, 0xfd, 0x25, 0xd7, 0x5e, 0xee, 0xae, 0x67, 0x86, 0x92,
	0x09, 0x54, 0xa8, 0x91, 0x02, 0x45, 0x7a, 0x4b, 0x7d, 0x28, 0x8a, 0x9c, 0x7a, 0x2c, 0xd4, 0x7b,
	0x0f, 0x95, 0x0b, 0x18, 0x01, 0x0a, 0x14, 0x41, 0x81, 0xfa, 0x56, 0xa3, 0xa7, 0x44, 0x46, 0x81,
	0x24, 0x05, 0x8a, 0xa0, 0xe8, 0x29, 0xa7, 0x62, 0xfe, 0xec, 0x72, 0x97, 0x5a, 0x32, 0x72, 0x9c,
	0x04, 0x39, 0xf8, 0xc4, 0x9d, 0x37, 0xdf, 0xf7, 0xfb, 0xbe, 0x79, 0xef, 0x7b, 0xdf, 0xbf, 0xf7,
	0x08, 0xce, 0xdf, 0x71, 0xe9, 0x6a, 0xab, 0x7b, 0x31, 0x35, 0x5b, 0x6e, 0x5b, 0x5d, 0x4c, 0x5d,
	0x72, 0xa7, 0x65, 0x5c, 0xb3, 0xd7, 0x6d, 0xb7, 0xcc, 0xee, 0xc5, 0x6c, 0xb7, 0xe7, 0xd2, 0xd5,
	0x5e, 0xd2, 0xcd, 0xba, 0xe1, 0xd3, 0x25, 0xe5, 0x6a, 0x49, 0xb9, 0x3a, 0x4a, 0x79, 0xee, 0xc2,
	0x66, 0x2b, 0xdb, 0xda, 0xd1, 0xab, 0xa6, 0xbb, 0x7d, 0x71, 0xb3, 0xbb, 0xd9, 0xbd, 0x58, 0x30,
	0xe9, 0x1d, 0x5f, 0x3c, 0x15, 0x0f, 0xc5, 0xaf, 0x12, 0xec, 0xdc, 0x33, 0x9b, 0xdd, 0xee, 0x66,
	0xdb, 0xed, 0x51, 0x65, 0xad, 0x6d, 0x97, 0x66, 0x6a, 0xbb, 0x57, 0x11, 0x3c, 0x35, 0xaa, 0x57,
	0xb7, 0x97, 0xb5, 0xba, 0x9d, 0x4a, 0x95, 0x73, 0xd1, 0xe8, 0xcb, 0x47, 0x95, 0x3d, 0xf7, 0xfc,
	0x28, 0x45, 0xa2, 0x32, 0xd7, 0x6c, 0xb7, 0xb6, 0x5b, 0x99, 0x4b, 0x46, 0xe8, 0x2e, 0x1c, 0xf6,
	0xf9, 0xcd, 0x64, 0xa7, 0xed, 0x46, 0xc8, 0x9f, 0x1c, 0x25, 0x1f, 0x7e, 0xf5, 0xf4, 0xe8, 0xab,
	0x3b, 0xaa, 0xdd, 0xb2, 0x2a, 0x73, 0xe3, 0x35, 0xbe, 0xd3, 0x72, 0x77, 0x9b, 0xa3, 0xdf, 0xf4,
	0xcc, 0xa3, 0x14, 0xe9, 0xb0, 0x80, 0xa5, 0xff, 0x89, 0x00, 0xd8, 0x68, 0x6d, 0xf7, 0xda, 0xae,
	0xb1, 0xd3, 0x76, 0x61, 0x08, 0x26, 0x3b, 0x6a, 0xdb, 0xd5, 0x83, 0x28, 0x38, 0x7f, 0xa2, 0x51,
	0xfc, 0x0e, 0x97, 0xc1, 0xa9, 0x6d, 0x97, 0x25, 0x2d, 0xd3, 0xcc, 0x1f, 0x9b, 0x6d, 0xa5, 0x5d,
	0xbb, 0x7e, 0xaa, 0x20, 0x98, 0x2f, 0x5f, 0xdc, 0x54, 0xdb, 0xee, 0x7a, 0x3e, 0x1c, 0x0a, 0x70,
	0x5c, 0x99, 0x5c, 0x81, 0xfa, 0xd1, 0x28, 0x38, 0x3f, 0x87, 0xa3, 0xd5, 0xd1, 0xf5, 0x2d, 0xa7,
	0x60, 0x35, 0x97, 0x75, 0xa9, 0xa0, 0x6b, 0x54, 0xf4, 0xe1, 0x55, 0x30, 0x67, 0xbb, 0xdb, 0xaa,
	0xd5, 0x69, 0x6e, 0xab, 0xcc, 0x6c, 0xb9, 0xa4, 0x3e, 0x11, 0x05, 0xe7, 0x67, 0xf0, 0x97, 0xc7,
	0x23, 0xdc, 0x28, 0x89, 0x6e, 0xef, 0xf6, 0x5c, 0xe3, 0x64, 0xc9, 0x58, 0x0d, 0x85, 0x12, 0x4c,
	0xf6, 0x54, 0xb6, 0x55, 0x9f, 0x2c, 0xf8, 0x9f, 0x1b, 0xcf, 0x7f, 0x4b, 0x65, 0x5b, 0xc3, 0x18,
	0x05, 0x4b, 0x78, 0x03, 0x4c, 0x6d, 0x39, 0x65, 0x5d, 0x92, 0xd6, 0x8f, 0x45, 0x13, 0xe7, 0x67,
	0xf0, 0x57, 0xc7, 0x73, 0x5f, 0x2d, 0x88, 0x86, 0xf8, 0xd7, 0xc0, 0x3f, 0xfd, 0xfc, 0xa3, 0x89,
	0x63, 0x1f, 0x04, 0x47, 0x6b, 0xb5, 0x46, 0x1f, 0x23, 0xbc, 0x0e, 0x66, 0xb6, 0xb2, 0xac, 0xd7,
	0xdc, 0x76, 0xd9, 0x56, 0xd7, 0xd6, 0x8f, 0x17, 0x0a, 0xbd, 0x78, 0x00, 0x64, 0x96, 0xf5, 0x6e,
	0x14, 0x74, 0xc3, 0x6a, 0x81, 0xad, 0xc1, 0x70, 0xf8, 0x35, 0x00, 0xee, 0x2a, 0xdf, 0xac, 0xe6,
	0x77, 0xaa, 0x00, 0x7b, 0x66, 0x3c, 0xd8, 0x37, 0x95, 0xaf, 0xa6, 0xf7, 0xc4, 0xdd, 0xfe, 0xcf,
	0xf0, 0x06, 0x58, 0x70, 0xef, 0xf5, 0x5a, 0x89, 0xca, 0x9f, 0x9a, 0x83, 0xad, 0x51, 0x9f, 0x2e,
	0x90, 0xce, 0xad, 0x96, 0x9b, 0x67, 0xb5, 0xbf, 0x79, 0x56, 0x6f, 0xf7, 0x29, 0x1a, 0xa7, 0xf7,
	0xf8, 0x06, 0x83, 0xe1, 0x5b, 0xe0, 0x78, 0x21, 0xd4, 0xd5, 0x67, 0xa3, 0x89, 0xf3, 0x27, 0xd6,
	0xae, 0xe6, 0x33, 0x70, 0xf1, 0x83, 0x60, 0x65, 0x69, 0x39, 0x39, 0xdf, 0x78, 0xfe, 0x4f, 0x97,
	0x2e, 0xdd, 0xfc, 0x93, 0xa5, 0x95, 0x68, 0xe9, 0xea, 0xed, 0xdb, 0xb7, 0xfa, 0x7f, 0x37, 0xf2,
	0x1f, 0xb7, 0xd7, 0x8b, 0xe7, 0xdb, 0xd7, 0x37, 0x96, 0xbe, 0x33, 0x98, 0xb5, 0xc9, 0xfe, 0xaf,
	0x7a, 0xd0, 0xa8, 0x70, 0xc3, 0xab, 0x60, 0xb6, 0xd7, 0x4d, 0xb2, 0x81, 0x41, 0x80, 0x43, 0x17,
	0xb4, 0x9b, 0x64, 0xc3, 0x33, 0x37, 0xd3, 0xdb, 0x1b, 0x08, 0x57, 0xc0, 0x8c, 0x75, 0xa9, 0x49,
	0x5a, 0xc5, 0xe6, 0xa8, 0xcf, 0xe4, 0xc6, 0x5b, 0x2d, 0x59, 0x32, 0x51, 0x7f, 0xff, 0x68, 0x63,
	0xf8, 0x75, 0x78, 0x19, 0xcc, 0xec, 0x24, 0xed, 0x81, 0xd8, 0x93, 0x85, 0xd8, 0x67, 0xc7, 0x8b,
	0xfd, 0xe3, 0xc6, 0xf5, 0x91, 0xf5, 0xda, 0x49, 0xda, 0x7d, 0xa1, 0x6f, 0x82, 0xf9, 0x36, 0x6d,
	0x5a, 0x97, 0xee, 0x7d, 0xc1, 0x5c, 0x01, 0x75, 0x80, 0x51, 0x5d, 0xa7, 0x2f, 0xbb, 0x74, 0xf8,
	0x1b, 0xd6, 0xa6, 0x3e, 0xb9, 0x17, 0xfc, 0xec, 0x41, 0x10, 0x34, 0x4e, 0xb6, 0x87, 0xdf, 0x85,
	0xaf, 0x81, 0xb9, 0x56, 0xaf, 0xd9, 0x4b, 0x9c, 0x6f, 0xbd, 0xd7, 0x6c, 0xb7, 0xd2, 0xac, 0x3e,
	0x7f, 0xe8, 0xd4, 0x14, 0x84, 0x05, 0xf3, 0xf5, 0x56, 0x9a, 0x35, 0x66, 0x5b, 0xbd, 0x72, 0x28,
	0x7f, 0x0a, 0x1b, 0x20, 0xb4, 0x69, 0xd6, 0xdc, 0x07, 0x58, 0xfb, 0x2c, 0x80, 0xf3, 0x36, 0xcd,
	0xae, 0x0d, 0x63, 0x6e, 0x82, 0xb3, 0x59, 0x3b, 0x6d, 0xfa, 0x56, 0x67, 0xd3, 0x25, 0xbd, 0xa4,
	0xd5, 0xd9, 0x9b, 0x82, 0xb0, 0x00, 0xbe, 0x38, 0x1e, 0xf8, 0x76, 0x3b, 0x7d, 0x65, 0x8f, 0x67,
	0x78, 0x62, 0x9f, 0xc8, 0xc6, 0xbd, 0x0a, 0xff, 0x08, 0x4c, 0xab, 0xb4, 0x53, 0xaa, 0x7c, 0xba,
	0x40, 0x5e, 0x1a, 0x8f, 0x7c, 0x29, 0xed, 0xec, 0xe9, 0x3b, 0xa5, 0xd2, 0x4e, 0xa1, 0xe7, 0x06,
	0x38, 0xa5, 0x7a, 0xad, 0xe6, 0x66, 0xd2, 0xdd, 0xe9, 0x0d, 0x34, 0x5c, 0x38, 0x6c, 0x91, 0x36,
	0xb2, 0xa4, 0xd5, 0xd9, 0x1c, 0xd6, 0x6c, 0x5e, 0xf5, 0x5a, 0x57, 0x72, 0x80, 0xbe, 0x4e, 0x77,
	0xc0, 0x97, 0x94, 0xb5, 0xad, 0xdc, 0x94, 0x54, 0xbb, 0xf9, 0x08, 0x7e, 0x5a, 0xbf, 0x70, 0x98,
	0x6b, 0x79, 0x44, 0xc0, 0x90, 0x6b, 0x99, 0x6c, 0x9c, 0xdb, 0x43, 0xbe, 0x34, 0x2a, 0x36, 0x0d,
	0x5f, 0x01, 0x33, 0xa6, 0xdd, 0x72, 0x9d, 0xac, 0x99, 0x74, 0xdb, 0xae, 0xfe, 0xc4, 0x61, 0x2b,
	0xd8, 0xe8, 0xb6, 0xdd, 0x88, 0xdd, 0x96, 0x9c, 0xf9, 0x70, 0x78, 0x0d, 0xcc, 0x57, 0x38, 0xa9,
	0x6b, 0x3b, 0x93, 0x75, 0x93, 0xfa, 0x99, 0x02, 0x6b, 0xbf, 0x33, 0x2f, 0x5c, 0xfe, 0x46, 0x45,
	0x53, 0xc0, 0xcc, 0x95, 0x8c, 0xfd, 0xb1, 0x1c, 0x2a, 0x0f, 0x7e, 0x2e, 0xd9, 0x83, 0x3a, 0xfb,
	0xb8, 0x50, 0x25, 0xe3, 0x00, 0xea, 0x65, 0x70, 0xb2, 0x88, 0x3c, 0x83, 0x65, 0xaa, 0x8f, 0x75,
	0x80, 0x05, 0xd0, 0xf0, 0x97, 0xcd, 0xb6, 0x87, 0x46, 0x72, 0x1f, 0xaa, 0xbb, 0x59, 0xdf, 0x87,
	0x3e, 0x79, 0x98, 0x0f, 0x5d, 0xeb, 0x66, 0x7d, 0x1f, 0xaa, 0xfb, 0x3f, 0xc3, 0xb7, 0xc0, 0x19,
	0xd3, 0xed, 0x64, 0xc5, 0x24, 0xbb, 0xbb, 0x49, 0x2b, 0x73, 0x7d, 0xac, 0x73, 0x05, 0xd6, 0xf2,
	0x78, 0xac, 0xf5, 0x92, 0xa7, 0x51, 0xb2, 0x54, 0xb0, 0x0b, 0x66, 0xcc, 0x68, 0xb8, 0x0b, 0x9e,
	0x49, 0xb7, 0x54, 0xcf, 0x35, 0x73, 0x3f, 0xec, 0x4c, 0xe6, 0x6c, 0xd3, 0x75, 0x6c, 0xaf, 0x9b,
	0xef, 0xa1, 0x4a, 0xd4, 0x53, 0x85, 0x28, 0x7c, 0x80, 0xfd, 0xe4, 0xcc, 0xb7, 0xfa, 0xbc, 0x97,
	0x2b, 0xd6, 0x4a, 0xe4, 0xd3, 0xe9, 0x21, 0x6f, 0xc3, 0x6f, 0x83, 0x93, 0xc3, 0x29, 0x4d, 0x5a,
	0x7f, 0xba, 0x30, 0xd4, 0xa7, 0xf7, 0x09, 0x7a, 0x5d, 0xbf, 0xed, 0x4c, 0xd6, 0x70, 0xbe, 0xb0,
	0xce, 0x27, 0xef, 0xdf, 0x9b, 0x1d, 0xe6, 0x1a, 0x18, 0xeb, 0xd1, 0x46, 0x31, 0x7e, 0xbd, 0x02,
	0x0b, 0x2d, 0x08, 0x87, 0xe9, 0x9a, 0x69, 0xcf, 0x99, 0xb4, 0xfe, 0xa5, 0x42, 0xc4, 0xfe, 0x69,
	0x1b, 0x26, 0x5c, 0xbd, 0xd2, 0xee, 0x6a, 0xd5, 0xde, 0xe8, 0x39, 0xb3, 0x6f, 0x3b, 0x1c, 0x6d,
	0xd4, 0x86, 0x24, 0xe4, 0x04, 0x69, 0x78, 0x09, 0x80, 0xed, 0x9d, 0xed, 0xfe, 0x4c, 0x2d, 0x1e,
	0xe6, 0x12, 0x6e, 0x74, 0x6d, 0xcb, 0xef, 0xf6, 0xd7, 0x78, 0x7b, 0x67, 0xbb, 0x9a, 0x86, 0xdb,
	0x60, 0xa1, 0xd5, 0x6b, 0x26, 0xae, 0xb7, 0x93, 0x95, 0xa1, 0xb2, 0x02, 0x7b, 0xe6, 0xb1, 0xc1,
	0xc2, 0x56, 0xaf, 0x31, 0x60, 0xaf, 0x50, 0xbf, 0x05, 0x66, 0x36, 0xbb, 0x59, 0xb7, 0x4a, 0x02,
	0xeb, 0xd1, 0x63, 0x4c, 0xed, 0x53, 0xf7, 0xef, 0xcd, 0x8d, 0xe6, 0x8e, 0x83, 0x4f, 0x0f, 0x1a,
	0x20, 0x47, 0xbb, 0x55, 0x8c, 0x86, 0x6b, 0x00, 0xb4, 0xf6, 0xfc, 0xd7, 0x97, 0x0b, 0x3d, 0xbf,
	0x32, 0x5e, 0xcf, 0x6b, 0xbd, 0xe1, 0xcd, 0x71, 0xa2, 0x35, 0xf0, 0x5a, 0x97, 0xc1, 0x4c, 0xee,
	0x49, 0xfb, 0x20, 0x4b, 0x87, 0x05, 0xbd, 0xbe, 0x33, 0xed, 0x3b, 0x0f, 0x35, 0x78, 0x0e, 0xbf,
	0x05, 0x9e, 0xd8, 0x49, 0x5d, 0xd2, 0x6c, 0x59, 0xd7, 0xc9, 0x5a, 0xd9, 0xee, 0x00, 0xf0, 0x2b,
	0x05, 0xe0, 0xf3, 0xbf, 0x36, 0x9b, 0x5b, 0x53, 0x69, 0xcb, 0x34, 0x4e, 0xe7, 0x20, 0xd7, 0x2a,
	0x8c, 0x3e, 0xf6, 0xcb, 0x60, 0x56, 0x77, 0xed, 0x1e, 0xe4, 0xb3, 0x8f, 0x9b, 0x20, 0xce, 0xe4,
	0x6c, 0x7d, 0x94, 0x0d, 0xb0, 0x70, 0xa7, 0x95, 0x64, 0x3b, 0xaa, 0xdd, 0xdc, 0xea, 0x0e, 0xc5,
	0xe6, 0xe7, 0x1e, 0x17, 0x2d, 0xac, 0xd8, 0xaf, 0x76, 0xf7, 0x22, 0xf2, 0x2d, 0x50, 0x33, 0x5b,
	0xaa, 0xdd, 0x76, 0x9d, 0xcd, 0x81, 0x47, 0x78, 0xbe, 0xc8, 0x80, 0x0f, 0x70, 0xc0, 0xeb, 0x7d,
	0xea, 0xca, 0x64, 0xe6, 0xcd, 0xe8, 0x40, 0xd8, 0x00, 0xb3, 0xef, 0xee, 0xb8, 0x64, 0xb7, 0xd9,
	0x53, 0x89, 0xda, 0x4e, 0xeb, 0x5f, 0x2d, 0x0c, 0xe6, 0x80, 0xb8, 0xf9, 0x46, 0x4e, 0x79, 0x2b,
	0x27, 0x74, 0xd9, 0x48, 0x5e, 0xda, 0x98, 0x79, 0x77, 0xf0, 0x2a, 0x0d, 0xaf, 0x80, 0x59, 0x95,
	0x6c, 0xee, 0x05, 0xa2, 0xf3, 0x05, 0xe6, 0x41, 0x8b, 0x9c, 0x8c, 0x84, 0xb9, 0x19, 0x35, 0x78,
	0x4e, 0xc3, 0x5b, 0x60, 0xde, 0x74, 0xbb, 0xef, 0xb4, 0xdc, 0x1e, 0xd6, 0x0b, 0x87, 0x05, 0xb5,
	0xf5, 0x82, 0x78, 0x18, 0x6e, 0xce, 0x0c, 0x0f, 0xa5, 0xa1, 0x06, 0xa7, 0x13, 0xf7, 0xee, 0x4e,
	0x9e, 0x2c, 0x99, 0x6e, 0x27, 0xcd, 0x12, 0xd5, 0xea, 0x64, 0x69, 0x7d, 0xf9, 0xb0, 0x94, 0xb9,
	0x51, 0x32, 0xac, 0x0f, 0xe8, 0x0b, 0xfb, 0x99, 0xfc, 0x38, 0xcf, 0x98, 0xc2, 0x64, 0xff, 0xcb,
	0x34, 0xfc, 0x0e, 0xa8, 0x6d, 0x26, 0xaa, 0xb7, 0xf5, 0x6e, 0xbb, 0x99, 0xba, 0x2c, 0x6b, 0x75,
	0x36, 0xd3, 0xfa, 0x8b, 0x85, 0x80, 0x17, 0xc6, 0x0b, 0xb8, 0x92, 0x53, 0xbf, 0x71, 0x7d, 0xa3,
	0x22, 0x1e, 0xcd, 0xc9, 0xe6, 0x2b, 0xac, 0xfe, 0xdb, 0x30, 0x01, 0x4f, 0x76, 0x7b, 0xae, 0x93,
	0x07, 0xfc, 0xaa, 0x4e, 0x1b, 0x72, 0x1e, 0x2b, 0x85, 0x9c, 0x0b, 0xe3, 0xe5, 0xbc, 0xde, 0x73,
	0x9d, 0x4b, 0xbd, 0xd6, 0x37, 0x06, 0x5c, 0xa5, 0x0d, 0xec, 0xc9, 0x3a, 0x5b, 0x01, 0xef, 0xa7,
	0x08, 0x5f, 0x1c, 0xc4, 0xfc, 0xa2, 0x6c, 0x5b, 0x1d, 0x49, 0x6c, 0xcf, 0xbf, 0x7f, 0xb4, 0x1f,
	0xd8, 0xf3, 0x0a, 0x2d, 0x7c, 0x03, 0x9c, 0x1e, 0x22, 0x1e, 0x18, 0xfe, 0xc5, 0xc7, 0x35, 0xfc,
	0x53, 0x7b, 0x58, 0x7d, 0xbb, 0xbf, 0x06, 0xe6, 0xaa, 0xe4, 0xb1, 0x8f, 0x06, 0x1f, 0xdf, 0xfb,
	0xcc, 0x16, 0x69, 0xe3, 0xd0, 0xee, 0xce, 0xa1, 0x06, 0xe9, 0x1c, 0x7a, 0xec, 0x74, 0x0e, 0xd8,
	0x34, 0xbb, 0x54, 0x65, 0x74, 0xd7, 0xc1, 0x7c, 0x1f, 0xa5, 0xaf, 0x11, 0xfe, 0x0c, 0xae, 0xec,
	0x64, 0x09, 0xd5, 0xd7, 0xe9, 0xaf, 0x03, 0xf0, 0x74, 0x37, 0x69, 0x6d, 0xb6, 0x3a, 0xcd, 0x7e,
	0x1e, 0xb3, 0xa3, 0x53, 0x97, 0xa5, 0xfd, 0x65, 0x25, 0x85, 0xd5, 0x5f, 0x59, 0x3d, 0xac, 0x8b,
	0xb1, 0xba, 0x57, 0x5f, 0xaf, 0xbe, 0x5e, 0x80, 0x6d, 0x94, 0xa9, 0x4d, 0x09, 0x55, 0xae, 0xe4,
	0xe5, 0x4e, 0x96, 0xec, 0xee, 0x2d, 0xf8, 0x93, 0xdd, 0x83, 0x08, 0x43, 0x05, 0xc0, 0xdb, 0x77,
	0xb3, 0xa6, 0x69, 0xab, 0xd6, 0x76, 0x5a, 0xa7, 0x85, 0x02, 0x07, 0xd8, 0xef, 0xab, 0xdf, 0xbc,
	0xbd, 0x9e, 0x93, 0x0d, 0xbb, 0xd7, 0xb3, 0xbf, 0xb8, 0x07, 0xac, 0xdb, 0xee, 0xa2, 0x95, 0xcc,
	0xa5, 0xd9, 0x50, 0xd5, 0x7a, 0xe2, 0xed, 0xbb, 0x59, 0x41, 0x9d, 0x9e, 0xbb, 0x0e, 0x16, 0x0f,
	0x57, 0x34, 0xac, 0x81, 0x89, 0x77, 0xdc, 0x6e, 0xd5, 0x26, 0xc8, 0x7f, 0x86, 0x0b, 0xe0, 0xd8,
	0x1d, 0xd5, 0xde, 0x71, 0x45, 0xe1, 0x7f, 0xa2, 0x51, 0x3e, 0xbc, 0x74, 0x54, 0x04, 0x2f, 0x1d,
	0xff, 0xf1, 0x83, 0x3c, 0x62, 0xbd, 0x3a, 0x39, 0x7d, 0xa2, 0x06, 0x96, 0xfe, 0xf9, 0x1c, 0x00,
	0x1b, 0xdd, 0x9d, 0xc4, 0xb8, 0x62, 0xbd, 0x6e, 0x81, 0x99, 0xe1, 0xb2, 0xe3, 0xe8, 0xd8, 0xed,
	0x58, 0xb4, 0x2d, 0xaa, 0xaa, 0xa3, 0xcc, 0x8f, 0x73, 0xde, 0xa1, 0xdd, 0x0e, 0x7a, 0x7b, 0xb5,
	0x47, 0x1b, 0x9c, 0xdc, 0xab, 0x65, 0x52, 0x97, 0xd5, 0x27, 0x8a, 0x29, 0x5a, 0x1a, 0x8b, 0x39,
	0x1a, 0x70, 0x9f, 0xbd, 0x7f, 0x6f, 0x94, 0x77, 0x6c, 0x79, 0x3a, 0xd3, 0x2f, 0x9f, 0x36, 0x5c,
	0x16, 0xae, 0x0f, 0x15, 0x20, 0x93, 0x8f, 0x6b, 0xb1, 0x95, 0xd6, 0x83, 0x32, 0xa4, 0x09, 0xf2,
	0x9f, 0x85, 0xb2, 0xc7, 0x1e, 0x5b, 0xd9, 0xa5, 0xfb, 0xf7, 0x66, 0xf4, 0x66, 0xaf, 0x59, 0x71,
	0x8e, 0xaf, 0xa4, 0x55, 0xda, 0xc9, 0xb5, 0x6c, 0x83, 0x59, 0xd3, 0xdd, 0xc9, 0x57, 0xae, 0xd4,
	0xf4, 0x78, 0x34, 0x71, 0x7e, 0xee, 0xa0, 0x2d, 0xbf, 0x5e, 0x52, 0xae, 0x77, 0xad, 0x5b, 0x7b,
	0x3e, 0x07, 0x3b, 0xf9, 0x41, 0x00, 0x96, 0xa6, 0xbf, 0x17, 0x1c, 0xab, 0x05, 0x4b, 0xc1, 0x91,
	0x81, 0xa0, 0xaf, 0x0f, 0xcf, 0x49, 0x05, 0x5f, 0x7c, 0xce, 0x9f, 0x3d, 0x5a, 0xfd, 0x99, 0xb6,
	0x4a, 0x53, 0x97, 0xd6, 0xa7, 0x0a, 0xc1, 0xab, 0xe3, 0x05, 0xbf, 0xd6, 0xe9, 0xde, 0xed, 0x8c,
	0x96, 0x80, 0xeb, 0x39, 0xdf, 0xda, 0xc2, 0x9e, 0x99, 0x0e, 0xc9, 0xdc, 0x57, 0x12, 0xae, 0x97,
	0x22, 0xc2, 0x7f, 0x38, 0x0d, 0xce, 0xec, 0x17, 0x5f, 0x18, 0x63, 0x5a, 0x9f, 0x2e, 0x1a, 0x15,
	0xff, 0x17, 0x3e, 0x7c, 0x10, 0xfc, 0x5b, 0x08, 0x22, 0xa4, 0x54, 0xac, 0xbd, 0xd0, 0x32, 0x76,
	0x8c, 0x42, 0xa3, 0x98, 0xb3, 0x36, 0x66, 0x3e, 0xd6, 0x82, 0x08, 0xaa, 0xbd, 0x02, 0x11, 0x31,
	0x56, 0x31, 0x6c, 0x15, 0x55, 0xd6, 0x41, 0xe9, 0x91, 0x8f, 0x05, 0x52, 0x16, 0x3b, 0x81, 0xad,
	0xf1, 0x0a, 0x43, 0x10, 0xc5, 0xd6, 0x32, 0xe8, 0x10, 0xc2, 0xc6, 0x62, 0x12, 0x13, 0xaa, 0x08,
	0x82, 0x5a, 0x42, 0xcf, 0x3d, 0xa5, 0x2a, 0x36, 0x16, 0x44, 0x48, 0x3b, 0xe2, 0x8c, 0xd3, 0x8e,
	0x29, 0x25, 0x2d, 0xe1, 0x8c, 0x3a, 0xee, 0x62, 0x48, 0xac, 0x40, 0x9e, 0x4b, 0x2c, 0x40, 0x64,
	0x18, 0x26, 0xcc, 0x12, 0x25, 0xb4, 0x94, 0x84, 0xea, 0xd8, 0x6b, 0x6d, 0x31, 0xa4, 0x96, 0x41,
	0x6d, 0x20, 0x13, 0x16, 0x44, 0x8e, 0x63, 0xc5, 0x3c, 0xb5, 0x8c, 0x08, 0xa3, 0x3d, 0xe2, 0xd2,
	0x60, 0xe5, 0x63, 0xa4, 0x9d, 0xc1, 0x44, 0x4a, 0x4d, 0x41, 0x64, 0xb1, 0x24, 0xcc, 0x30, 0xe1,
	0x1d, 0x8f, 0x79, 0x4c, 0xa9, 0x77, 0xc6, 0x08, 0x8e, 0xa8, 0x73, 0x8c, 0x30, 0x6e, 0x62, 0x10,
	0x59, 0x67, 0xbc, 0xa6, 0x42, 0x31, 0x12, 0x0b, 0xe9, 0xb4, 0x83, 0x02, 0x69, 0x21, 0x94, 0xd2,
	0x9a, 0x09, 0xe7, 0x08, 0x05, 0x11, 0x43, 0x86, 0x53, 0x13, 0xc7, 0x8e, 0x43, 0x4f, 0xa4, 0x80,
	0xce, 0x29, 0x09, 0x05, 0x97, 0x9a, 0x0b, 0xc3, 0x84, 0xca, 0x35, 0xd5, 0x52, 0x28, 0x4c, 0x9d,
	0xa3, 0x5a, 0x22, 0x42, 0x29, 0x15, 0xde, 0x6b, 0x16, 0x23, 0xea, 0xad, 0x88, 0xa1, 0x32, 0x20,
	0x22, 0xd4, 0x23, 0xaa, 0xb8, 0x54, 0x36, 0x86, 0x50, 0x1a, 0xc5, 0x04, 0x27, 0x24, 0x96, 0x18,
	0x09, 0xe5, 0x51, 0xec, 0x09, 0x88, 0x6c, 0xcc, 0x9d, 0xe3, 0xd4, 0xeb, 0x18, 0xc7, 0x24, 0x26,
	0xc4, 0x68, 0x47, 0x19, 0x53, 0x46, 0x20, 0x83, 0x25, 0x76, 0x1c, 0x44, 0xc2, 0x73, 0x23, 0x91,
	0xb0, 0x46, 0x33, 0xc1, 0x9c, 0xd6, 0x4e, 0x41, 0xe6, 0xb0, 0x31, 0x92, 0x32, 0x02, 0x1d, 0xc9,
	0xe7, 0xd4, 0x42, 0xc9, 0x1c, 0x17, 0x54, 0x48, 0x4b, 0x0c, 0x23, 0x0c, 0xcb, 0xd8, 0x58, 0x61,
	0xbd, 0xd7, 0x90, 0x1b, 0x2d, 0x41, 0xe4, 0x31, 0xd6, 0xd6, 0xb2, 0xd8, 0x91, 0x7c, 0x01, 0x9d,
	0xe0, 0xc6, 0x2a, 0x0a, 0xad, 0xc2, 0x56, 0x50, 0x27, 0x88, 0x06, 0x91, 0xd7, 0x4c, 0x08, 0x82,
	0xbc, 0x90, 0x18, 0x49, 0xc8, 0xf3, 0x29, 0xa3, 0xd4, 0x61, 0xa6, 0x8d, 0x20, 0x50, 0x53, 0x06,
	0x22, 0x68, 0x0c, 0x72, 0x82, 0x32, 0x2e, 0x1c, 0x8d, 0x91, 0x52, 0xc8, 0x72, 0xac, 0x2c, 0x45,
	0x4c, 0x28, 0xeb, 0xb8, 0x66, 0x20, 0xc2, 0x50, 0x62, 0x87, 0xbc, 0xf7, 0x9a, 0x32, 0x1b, 0x3b,
	0xaa, 0x90, 0x54, 0x2c, 0xf6, 0x52, 0x1b, 0xe6, 0x30, 0x24, 0x0a, 0x44, 0x16, 0x09, 0x45, 0xad,
	0x12, 0x54, 0x79, 0x26, 0x1d, 0x42, 0x50, 0x08, 0x8e, 0x15, 0x91, 0x5a, 0xb9, 0xd8, 0x48, 0x4b,
	0x41, 0xa4, 0x38, 0xc2, 0x52, 0x7a, 0xa9, 0x19, 0x44, 0xca, 0x1a, 0xcf, 0x05, 0xd4, 0x12, 0xc7,
	0xcc, 0xc6, 0xd2, 0x52, 0x65, 0x38, 0x88, 0x34, 0x11, 0x5c, 0x52, 0xae, 0x98, 0xa2, 0xd4, 0x22,
	0x6b, 0x8d, 0x11, 0x94, 0x68, 0x13, 0x33, 0x42, 0xb8, 0xf5, 0xc6, 0x81, 0x48, 0x50, 0x29, 0xbc,
	0xa3, 0x98, 0x8b, 0x98, 0x53, 0xab, 0xbd, 0xc4, 0x5c, 0x11, 0x81, 0x05, 0x71, 0xd2, 0x12, 0x2b,
	0x7c, 0xae, 0xa9, 0xb5, 0x48, 0x68, 0x6b, 0x09, 0x86, 0xd2, 0xa9, 0x18, 0x09, 0x29, 0x24, 0x24,
	0x50, 0x71, 0x2f, 0x09, 0xe1, 0x14, 0x44, 0x42, 0x4a, 0xa4, 0x88, 0x88, 0x1d, 0xcd, 0xf1, 0x51,
	0x4c, 0xa1, 0xc7, 0xcc, 0x72, 0xcf, 0x10, 0x91, 0x5e, 0x62, 0x0b, 0x22, 0x62, 0x85, 0x34, 0xd0,
	0x7a, 0x8d, 0xbc, 0xa2, 0x54, 0x22, 0xa4, 0x85, 0x57, 0x31, 0xc3, 0xc4, 0x79, 0x61, 0x9d, 0xd5,
	0x20, 0x72, 0x84, 0x40, 0x6d, 0x94, 0x94, 0x46, 0x28, 0x86, 0x19, 0x57, 0x0e, 0x61, 0xae, 0x18,
	0x33, 0xd4, 0xc4, 0x98, 0x19, 0x06, 0x22, 0x41, 0x1c, 0xa4, 0xda, 0x30, 0x61, 0x29, 0xc4, 0x5e,
	0x72, 0x42, 0xa4, 0x20, 0x46, 0x7b, 0x8c, 0x63, 0x4c, 0x35, 0xc4, 0x20, 0xd2, 0xc2, 0x0b, 0xc4,
	0x63, 0x62, 0xa0, 0x43, 0x16, 0x4b, 0x09, 0x05, 0xa1, 0xdc, 0x13, 0xad, 0xb4, 0x90, 0x58, 0x4b,
	0x0d, 0x22, 0xcb, 0x18, 0xf2, 0xca, 0x1b, 0xea, 0x29, 0xf4, 0xc8, 0x3a, 0x83, 0xb5, 0xa6, 0x4c,
	0x0a, 0xa8, 0xbd, 0x92, 0x54, 0x62, 0x10, 0x61, 0x09, 0x05, 0xf3, 0x90, 0x78, 0xe1, 0x84, 0x82,
	0xc4, 0x43, 0x4d, 0xa4, 0x34, 0xcc, 0xc4, 0xc6, 0x43, 0x0d, 0xb5, 0xc8, 0x6d, 0x5d, 0xc5, 0xca,
	0x22, 0xca, 0xa0, 0xf4, 0x96, 0x23, 0x6a, 0x62, 0xad, 0x89, 0x62, 0xd0, 0x50, 0x29, 0xb0, 0x16,
	0x06, 0x44, 0xda, 0x70, 0x43, 0x04, 0xf7, 0x34, 0xdf, 0x08, 0x32, 0xd6, 0xd2, 0x4a, 0xc7, 0xb0,
	0xa5, 0x31, 0xd6, 0x71, 0x8c, 0xad, 0x00, 0x91, 0x46, 0xc4, 0x42, 0x24, 0x28, 0x57, 0x36, 0x56,
	0x88, 0xaa, 0x18, 0x6a, 0x9f, 0x4f, 0x29, 0xe2, 0x71, 0xcc, 0x4c, 0x2c, 0x40, 0xc4, 0xa5, 0x70,
	0x84, 0x63, 0x24, 0x3d, 0x91, 0xb1, 0xa4, 0x18, 0x7a, 0x85, 0x99, 0x40, 0x1a, 0x23, 0xab, 0x4c,
	0xec, 0x0c, 0x88, 0x50, 0x8c, 0x30, 0x16, 0xb1, 0x80, 0x50, 0x19, 0x89, 0x34, 0xa1, 0x46, 0x59,
	0xcb, 0x84, 0xa0, 0xc6, 0x09, 0xc6, 0x78, 0xae, 0x29, 0x83, 0xd6, 0x38, 0x24, 0xac, 0x43, 0x5a,
	0x23, 0x4a, 0x1c, 0x97, 0x96, 0x5b, 0x2b, 0x29, 0x22, 0x5a, 0x10, 0xc6, 0xf2, 0x1d, 0x85, 0x18,
	0x54, 0x9e, 0x32, 0x44, 0xb5, 0xe0, 0xc2, 0x3a, 0xaf, 0x05, 0xa3, 0x56, 0x43, 0xcf, 0xb1, 0xa2,
	0x14, 0x81, 0xc8, 0x7a, 0x66, 0x08, 0x74, 0x3c, 0x86, 0x56, 0xab, 0xdc, 0xd8, 0x70, 0x0c, 0x9d,
	0x25, 0x1c, 0x72, 0x68, 0x3c, 0x64, 0x14, 0x44, 0x84, 0x19, 0xa8, 0x08, 0x32, 0x54, 0x20, 0x89,
	0x63, 0x0f, 0x31, 0x56, 0x44, 0x33, 0x02, 0x71, 0xbe, 0x35, 0xa1, 0x28, 0x3c, 0x9d, 0x31, 0x8e,
	0xe9, 0x98, 0x1b, 0xa1, 0x51, 0x4c, 0x63, 0x6c, 0x21, 0xa6, 0x31, 0x13, 0x32, 0x86, 0x8a, 0x42,
	0xae, 0x41, 0x24, 0x11, 0xa2, 0xb1, 0x54, 0x46, 0x28, 0x28, 0x10, 0x71, 0x16, 0x61, 0x8a, 0x34,
	0xe1, 0x82, 0x1b, 0x63, 0x95, 0x75, 0x12, 0x44, 0x90, 0x38, 0x24, 0xb8, 0x8a, 0xbd, 0x20, 0x58,
	0x30, 0x27, 0x09, 0xa1, 0xc8, 0x3a, 0x1a, 0x0b, 0x42, 0x28, 0x84, 0xdc, 0xe5, 0xf3, 0xe1, 0x2d,
	0x95, 0x31, 0xc6, 0x5e, 0x58, 0x84, 0x3c, 0xb1, 0x31, 0xb7, 0xc6, 0x09, 0xea, 0x85, 0x83, 0x52,
	0xaa, 0x38, 0xdf, 0xb7, 0x10, 0x42, 0xc6, 0x14, 0x42, 0x92, 0x2b, 0xe7, 0x94, 0xb0, 0x48, 0x1b,
	0x0e, 0xa5, 0x10, 0x4c, 0x2b, 0xc9, 0x08, 0x88, 0xa0, 0x14, 0x9e, 0x31, 0x87, 0x63, 0x2b, 0x0c,
	0xd5, 0x50, 0x31, 0x09, 0x11, 0xc4, 0x46, 0xdb, 0x7c, 0x85, 0x7d, 0xbe, 0x2b, 0x1d, 0xd1, 0x58,
	0x69, 0xe4, 0xa5, 0x62, 0xdc, 0x63, 0xaf, 0xa9, 0x91, 0x98, 0x0a, 0x8f, 0x3d, 0x45, 0x9c, 0xa0,
	0xdc, 0xf3, 0x53, 0xee, 0x72, 0x45, 0x94, 0x36, 0x46, 0x09, 0xa7, 0xa4, 0x56, 0x4a, 0x12, 0x6c,
	0x15, 0x17, 0xde, 0x6a, 0x86, 0x25, 0x88, 0xa8, 0x8d, 0x15, 0x16, 0x96, 0x7b, 0x8c, 0x39, 0x71,
	0x96, 0x23, 0xeb, 0x84, 0x30, 0x8a, 0x73, 0xa7, 0x21, 0x42, 0x8e, 0x80, 0x48, 0x63, 0xcd, 0x91,
	0xd5, 0xb1, 0x96, 0x54, 0x42, 0xc5, 0xa1, 0xc5, 0x31, 0x34, 0x46, 0x63, 0xa8, 0x29, 0xc7, 0x02,
	0x73, 0x10, 0x49, 0xcc, 0x62, 0x19, 0x43, 0xe4, 0x11, 0x65, 0x1c, 0x32, 0x27, 0x9d, 0x35, 0x50,
	0x43, 0xa4, 0x24, 0x44, 0x86, 0x5b, 0x06, 0xa2, 0x98, 0x4b, 0x84, 0x65, 0xac, 0x73, 0x36, 0x45,
	0x11, 0x26, 0xc4, 0x5b, 0xa8, 0xa0, 0x56, 0x0a, 0x2a, 0xc2, 0xf3, 0xe8, 0x81, 0xb8, 0xf3, 0xc6,
	0x43, 0x07, 0x21, 0x83, 0xd4, 0x5a, 0xef, 0xac, 0x75, 0x88, 0x68, 0xef, 0x94, 0x94, 0xb1, 0x64,
	0x18, 0x44, 0x88, 0x51, 0xa2, 0x62, 0x43, 0x39, 0x27, 0x44, 0x19, 0x1f, 0xe7, 0x4e, 0x0d, 0x22,
	0xad, 0x8c, 0xd1, 0x16, 0x16, 0x36, 0x66, 0xb9, 0x87, 0x54, 0x33, 0x25, 0x11, 0x44, 0x88, 0x79,
	0xaa, 0x19, 0x74, 0xc6, 0x19, 0x28, 0x2d, 0x85, 0x0a, 0x59, 0x0f, 0x22, 0x49, 0x72, 0xd2, 0x58,
	0x60, 0xcb, 0xa9, 0xb4, 0x4e, 0x33, 0x94, 0x3b, 0x54, 0xea, 0x8c, 0x8e, 0x11, 0xd5, 0x1a, 0x82,
	0x88, 0x39, 0x16, 0x13, 0x23, 0x8d, 0xf4, 0x42, 0xab, 0x18, 0x43, 0xe7, 0xa5, 0x46, 0xc2, 0x49,
	0x6f, 0x1c, 0x76, 0xd8, 0xc7, 0x20, 0x62, 0x12, 0x2a, 0x4c, 0xb0, 0xcd, 0x43, 0x1b, 0xa7, 0x50,
	0x7a, 0xa5, 0x63, 0xec, 0x62, 0x86, 0x95, 0x50, 0x98, 0xe7, 0x11, 0x48, 0x50, 0xa9, 0x21, 0xd5,
	0x56, 0x5b, 0x64, 0xb1, 0x96, 0x82, 0x78, 0xee, 0x84, 0xa2, 0x2c, 0x76, 0x90, 0x13, 0x9c, 0x47,
	0x20, 0x69, 0x30, 0x13, 0xd2, 0x21, 0x03, 0x9d, 0xf4, 0x8c, 0x10, 0x05, 0x31, 0x36, 0x1c, 0x43,
	0xe6, 0x65, 0x8c, 0xa4, 0x43, 0x20, 0x92, 0xdc, 0x69, 0xc5, 0x71, 0x1e, 0x3e, 0xb0, 0xa6, 0x31,
	0x87, 0x31, 0x92, 0x58, 0xab, 0x98, 0xe6, 0x06, 0xcd, 0xb4, 0x02, 0x51, 0x6c, 0x28, 0x82, 0xc6,
	0x09, 0x82, 0x9d, 0xa0, 0x42, 0x11, 0x82, 0x11, 0x25, 0xd8, 0x48, 0x25, 0xb0, 0x93, 0x31, 0xce,
	0x63, 0x03, 0xf7, 0x56, 0x10, 0x85, 0x91, 0x97, 0x9e, 0x18, 0xe6, 0xa5, 0xf7, 0xb1, 0x66, 0x86,
	0x13, 0xad, 0x0d, 0x8a, 0xa5, 0x05, 0x11, 0xb6, 0x22, 0x96, 0xd4, 0xe8, 0x58, 0xb3, 0xdc, 0x1f,
	0xc4, 0xda, 0x39, 0xcc, 0x25, 0x73, 0xb1, 0x34, 0x88, 0xc5, 0x1c, 0x82, 0xc8, 0x5b, 0x01, 0xbd,
	0x92, 0x86, 0x23, 0x0c, 0x8d, 0xcd, 0x0d, 0x95, 0x61, 0xc8, 0x10, 0xf4, 0xc4, 0x70, 0x4a, 0xf3,
	0x58, 0xc9, 0x62, 0x4f, 0x38, 0xc5, 0x9a, 0x3a, 0x12, 0x3b, 0x2c, 0x3c, 0x33, 0xda, 0x11, 0x88,
	0xa1, 0x91, 0x84, 0x20, 0x4d, 0x0d, 0x88, 0x24, 0xe4, 0x10, 0x52, 0x5c, 0xfa, 0x3f, 0xe6, 0x62,
	0xc6, 0x34, 0xa4, 0xc4, 0x40, 0x16, 0x63, 0x46, 0x55, 0x6e, 0x85, 0x86, 0x41, 0xcf, 0xf3, 0xcc,
	0x01, 0xc5, 0x84, 0xc7, 0x5c, 0xd3, 0x58, 0x2b, 0x0e, 0x05, 0xd3, 0x16, 0x1a, 0x6e, 0x9c, 0x03,
	0x91, 0xc1, 0x10, 0x69, 0x89, 0xbd, 0xd0, 0x54, 0x10, 0xaf, 0x88, 0x10, 0xda, 0xa1, 0x98, 0x5a,
	0xce, 0x45, 0x3e, 0x83, 0x14, 0x44, 0x5a, 0x42, 0x6d, 0xb5, 0x93, 0x1c, 0x29, 0x4e, 0x85, 0x87,
	0x14, 0xc7, 0x56, 0x63, 0xa4, 0x94, 0xe2, 0xc6, 0x68, 0x26, 0x41, 0x24, 0x3d, 0xc7, 0x86, 0x7a,
	0xcc, 0xb5, 0x84, 0x96, 0xd8, 0x98, 0xc5, 0xda, 0x29, 0x0e, 0xa5, 0x13, 0xd8, 0x63, 0xa7, 0x7c,
	0x9e, 0x95, 0x81, 0x0f, 0x82, 0xa9, 0xa5, 0x63, 0xc9, 0xc4, 0xdf, 0x06, 0xd1, 0xd8, 0x74, 0x6d,
	0x61, 0x34, 0x5d, 0xfb, 0x46, 0x91, 0x92, 0x85, 0x1b, 0xe0, 0x9c, 0x75, 0x5e, 0xed, 0xb4, 0xfb,
	0xdd, 0xcd, 0x66, 0xc7, 0xbd, 0x97, 0xf5, 0xbb, 0x64, 0x33, 0x45, 0x46, 0xbd, 0xb0, 0x2f, 0x5d,
	0xbc, 0xbc, 0xdd, 0xcb, 0x76, 0xaf, 0x1e, 0x69, 0x9c, 0xad, 0x38, 0xcb, 0xc2, 0xe4, 0xa6, 0x7b,
	0x2f, 0xab, 0xfa, 0x61, 0xaf, 0x80, 0xd3, 0xfb, 0x40, 0xad, 0xeb, 0xec, 0xd6, 0x67, 0x0f, 0x45,
	0x3b, 0x35, 0x82, 0xf6, 0xb2, 0xeb, 0xec, 0x86, 0x57, 0xc1, 0xc2, 0x3e, 0x1c, 0xd5, 0x6e, 0x77,
	0xef, 0x56, 0x27, 0x42, 0x07, 0x01, 0x85, 0x23, 0x40, 0x97, 0x72, 0x8e, 0x97, 0x4e, 0xff, 0xef,
	0xd7, 0x6a, 0x78, 0x85, 0xac, 0xd0, 0x15, 0xb6, 0xc2, 0x57, 0xe2, 0x15, 0xb1, 0x82, 0xe0, 0xda,
	0x05, 0xf0, 0xc4, 0x3e, 0x78, 0xb3, 0xd5, 0x6d, 0x19, 0x17, 0x2e, 0x7c, 0xf4, 0x20, 0x98, 0xf9,
	0xf8, 0x41, 0x00, 0x1e, 0x3e, 0x08, 0xa6, 0x11, 0x5a, 0x41, 0x78, 0x05, 0x91, 0x57, 0x27, 0xa7,
	0x41, 0x6d, 0x66, 0xe9, 0x1f, 0x01, 0x98, 0x2c, 0x8e, 0x6a, 0x5f, 0x02, 0xd3, 0xdb, 0x2e, 0x53,
	0x56, 0x65, 0xaa, 0xa8, 0xc3, 0x66, 0xf0, 0xe2, 0x3e, 0x85, 0x6e, 0xb8, 0x34, 0x55, 0x9b, 0xee,
	0x86, 0xcb, 0x54, 0x51, 0xdc, 0x0e, 0xe8, 0xc3, 0xd7, 0xc1, 0x64, 0xda, 0x73, 0xa6, 0x2a, 0xb7,
	0xd0, 0xa1, 0xe5, 0x6b, 0x71, 0x5e, 0xbd, 0xbf, 0x09, 0x3b, 0x9d, 0x17, 0x30, 0x1f, 0x7f, 0x18,
	0x04, 0x8d, 0x02, 0xe8, 0xa5, 0xbf, 0x3b, 0xf1, 0xa3, 0x07, 0xc1, 0x3c, 0x38, 0x09, 0xa6, 0x6f,
	0xf4, 0x65, 0x04, 0xe8, 0xc7, 0x0f, 0x82, 0xef, 0x9f, 0x00, 0x67, 0xc1, 0xe4, 0x4d, 0xb5, 0xed,
	0xce, 0xcd, 0x83, 0x93, 0x7d, 0xf9, 0xab, 0x1d, 0xb5, 0xed, 0xc0, 0x22, 0x98, 0xc9, 0x3f, 0x24,
	0x2a, 0xe7, 0xe9, 0xdc, 0x3c, 0x98, 0xc9, 0xa1, 0x56, 0xcb, 0xa9, 0x88, 0x02, 0xf0, 0x02, 0x98,
	0x2a, 0x4f, 0x3e, 0xd3, 0xb5, 0x45, 0x50, 0x2f, 0xde, 0x0d, 0x9d, 0xa6, 0xae, 0x96, 0x7f, 0xd2,
	0xda, 0x04, 0x0c, 0xc0, 0x12, 0x98, 0xbc, 0xa5, 0xb2, 0xad, 0xb5, 0x73, 0xe0, 0x4c, 0x41, 0xd7,
	0x53, 0xd9, 0xd6, 0xaa, 0x7b, 0x4f, 0x99, 0x7e, 0xea, 0x5f, 0x9b, 0x00, 0xcb, 0x60, 0x26, 0xa7,
	0x89, 0xca, 0xda, 0x6d, 0xed, 0x29, 0x70, 0x76, 0x8f, 0xb4, 0xaa, 0xf8, 0x06, 0xb4, 0xe7, 0x01,
	0x28, 0x68, 0x1b, 0x6e, 0xd3, 0xbd, 0x37, 0x8a, 0x9a, 0xe4, 0x43, 0x7b, 0x94, 0x7f, 0x33, 0x01,
	0x8e, 0xaf, 0x17, 0x6d, 0x91, 0x5a, 0xb0, 0xfc, 0x57, 0x13, 0xe0, 0x2f, 0x27, 0xc0, 0x19, 0x30,
	0x5f, 0x7e, 0x48, 0x67, 0xb7, 0x59, 0x76, 0x4c, 0xf0, 0xc4, 0xa5, 0xce, 0x2e, 0x08, 0x41, 0xad,
	0x18, 0x1f, 0xea, 0xc1, 0x00, 0x0b, 0x9e, 0xdb, 0x3f, 0xd6, 0xef, 0x5b, 0x8c, 0xe8, 0xbf, 0x54,
	0xab, 0x4d, 0x2c, 0xcf, 0x5e, 0xce, 0x47, 0xa2, 0x72, 0xe7, 0x34, 0x5e, 0x38, 0x84, 0x75, 0x44,
	0xc9, 0x23, 0x87, 0x4a, 0x19, 0x26, 0x2d, 0xa5, 0x14, 0x1f, 0xfd, 0x38, 0x52, 0x46, 0x26, 0xf8,
	0x08, 0x78, 0xbe, 0x5a, 0xa4, 0x31, 0xa4, 0x18, 0xac, 0x77, 0x3b, 0xbe, 0xb5, 0xb9, 0x93, 0x38,
	0x0b, 0xce, 0x80, 0x85, 0x61, 0xba, 0xfe, 0xc9, 0x10, 0xb8, 0x0e, 0x50, 0x31, 0xde, 0xea, 0x35,
	0xb3, 0xad, 0xc4, 0xa9, 0xac, 0x69, 0x54, 0xe6, 0x36, 0xbb, 0x55, 0xd1, 0xfa, 0xe8, 0x78, 0xcb,
	0xa5, 0x4b, 0x67, 0x6b, 0x13, 0xcb, 0xa7, 0x6e, 0x17, 0xc3, 0xd1, 0xfa, 0x60, 0x18, 0x06, 0xe0,
	0xcf, 0xc1, 0xd1, 0x6b, 0xb7, 0x6a, 0xc1, 0xf2, 0x5d, 0xb0, 0x03, 0xc2, 0xbe, 0x69, 0x75, 0x76,
	0x9b, 0xad, 0x5e, 0xb9, 0x1a, 0x17, 0xc1, 0x33, 0x7d, 0x69, 0x43, 0x0d, 0x88, 0xbd, 0x47, 0x97,
	0x2e, 0xcd, 0xd6, 0x26, 0x96, 0xa7, 0x6f, 0x55, 0x4f, 0x60, 0x15, 0x3c, 0xd5, 0x67, 0xe8, 0x4f,
	0xc0, 0x5e, 0xa3, 0x20, 0x5d, 0x9a, 0xaf, 0x4d, 0x2c, 0xcf, 0x94, 0xc4, 0xd1, 0x86, 0xcb, 0x52,
	0x70, 0x17, 0x4c, 0x5c, 0xda, 0xb8, 0x59, 0x0b, 0x96, 0x3b, 0xa0, 0x0d, 0x4e, 0x83, 0xd9, 0x81,
	0x06, 0x2a, 0xed, 0x94, 0x2a, 0x2c, 0x57, 0x13, 0xd6, 0x6f, 0x20, 0xac, 0xaa, 0xb4, 0xd9, 0xd9,
	0xd9, 0xd6, 0x2e, 0x49, 0x97, 0xe6, 0x6a, 0x13, 0xcb, 0xe0, 0xd2, 0x46, 0x74, 0xb3, 0x7c, 0x06,
	0x2f, 0x80, 0x27, 0x07, 0xb4, 0x7d, 0xf1, 0x55, 0xe5, 0x5f, 0x29, 0x7a, 0x69, 0xe3, 0x66, 0x29,
	0x18, 0x82, 0xe3, 0x2f, 0x17, 0x17, 0x22, 0x6a, 0xc1, 0xda, 0xb3, 0x20, 0x2a, 0xd8, 0x46, 0xaf,
	0x56, 0xec, 0xdf, 0x1a, 0x1c, 0xcc, 0x96, 0x1c, 0xa5, 0xc1, 0x1f, 0xcc, 0xb7, 0xcf, 0xf8, 0xbf,
	0x02, 0xa6, 0xca, 0x9b, 0x10, 0x69, 0x2d, 0x58, 0x3b, 0x53, 0x7d, 0x62, 0x75, 0xf9, 0xa1, 0x36,
	0xb1, 0x54, 0x5c, 0x1f, 0x01, 0x2b, 0x60, 0xb6, 0x68, 0x4f, 0x47, 0x65, 0x13, 0xba, 0x16, 0xac,
	0x9d, 0x03, 0xa7, 0x0a, 0xca, 0xe1, 0xfe, 0x76, 0x6d, 0x62, 0x69, 0xe2, 0x1d, 0xb7, 0x0b, 0x5e,
	0x04, 0x53, 0x65, 0xb3, 0x38, 0x27, 0x5c, 0xec, 0x5b, 0xca, 0x68, 0xaf, 0x79, 0x00, 0xfd, 0x22,
	0x00, 0x97, 0x07, 0x37, 0x13, 0x6a, 0xc1, 0xb9, 0xa7, 0xaa, 0x49, 0x1a, 0x77, 0xcd, 0x61, 0xe9,
	0x6d, 0x30, 0x9d, 0xbb, 0x9b, 0xa2, 0x43, 0xf1, 0x5d, 0x70, 0x2c, 0xf7, 0x6a, 0x69, 0x3d, 0x18,
	0xdb, 0x6e, 0xd9, 0xd7, 0xbf, 0xcb, 0xd9, 0xd6, 0x9e, 0xcd, 0x3d, 0x5e, 0x1e, 0xce, 0x8e, 0x7f,
	0x10, 0x4c, 0xd4, 0xde, 0x3f, 0xda, 0x8f, 0x6c, 0x30, 0x78, 0xf8, 0x93, 0x7f, 0x99, 0x38, 0xfe,
	0xc1, 0x87, 0xc5, 0xa9, 0x4c, 0x09, 0xbb, 0x94, 0x80, 0xb9, 0xeb, 0x6e, 0x53, 0x99, 0xdd, 0x81,
	0xc4, 0xb7, 0x46, 0x25, 0x1e, 0x7e, 0xf0, 0xb3, 0x72, 0xff, 0xde, 0xe9, 0x31, 0x4e, 0x78, 0x48,
	0xfa, 0x18, 0x99, 0xdf, 0x9f, 0x07, 0x73, 0xa3, 0x5e, 0x3a, 0x7c, 0x13, 0x4c, 0xaa, 0xf6, 0x66,
	0xb7, 0x08, 0x0f, 0x73, 0x78, 0xe5, 0xe0, 0xbb, 0x38, 0xeb, 0xdd, 0x6d, 0xdd, 0xea, 0xb4, 0x3a,
	0x9b, 0x97, 0xda, 0xf9, 0x06, 0xca, 0xb6, 0xb6, 0xd7, 0xce, 0x7c, 0x72, 0x2f, 0xf8, 0xcf, 0x07,
	0xc1, 0xcc, 0x2b, 0xd7, 0x1a, 0x1b, 0xb7, 0x9b, 0x37, 0x2e, 0xdd, 0x5e, 0xbf, 0x5a, 0x74, 0x26,
	0x0b, 0xc4, 0x90, 0x01, 0x90, 0x9b, 0x72, 0xd9, 0x14, 0xfd, 0x35, 0x61, 0xfa, 0x84, 0xea, 0xec,
	0x96, 0x8d, 0xc4, 0xf0, 0x02, 0x98, 0xa9, 0xfa, 0xa8, 0x45, 0xbb, 0xfa, 0xe8, 0xfe, 0x76, 0xf5,
	0xd5, 0x23, 0x0d, 0x50, 0x12, 0x14, 0x0d, 0xeb, 0xdb, 0x8f, 0x1e, 0x1f, 0x4f, 0x3c, 0xde, 0xf1,
	0xf1, 0xda, 0xd4, 0x0f, 0x3f, 0x0c, 0x26, 0x40, 0x10, 0x5c, 0x3d, 0xf2, 0xc8, 0x49, 0xf2, 0x9b,
	0xe0, 0xf4, 0x90, 0x12, 0x83, 0x36, 0xf1, 0xb1, 0xcf, 0x72, 0x40, 0x95, 0xe7, 0x0b, 0x7b, 0x8a,
	0xf6, 0xdb, 0xc5, 0x6f, 0xec, 0xbb, 0xb0, 0x72, 0xfc, 0x33, 0x5c, 0x58, 0xd9, 0xeb, 0xfd, 0x8e,
	0xdc, 0x5c, 0x59, 0x03, 0x93, 0xc5, 0x69, 0xfe, 0xd4, 0x67, 0x38, 0xcd, 0xdf, 0x83, 0x2a, 0x78,
	0xc3, 0xd7, 0xc0, 0x89, 0x3c, 0xff, 0x69, 0xb6, 0x3a, 0xbe, 0x5b, 0xdd, 0xf6, 0x39, 0x00, 0x28,
	0xcf, 0x7a, 0xae, 0x75, 0x7c, 0x37, 0xd9, 0x56, 0xa3, 0x07, 0x10, 0xd3, 0xb6, 0x7a, 0x13, 0xbe,
	0x1f, 0xec, 0x65, 0x6c, 0xbe, 0x9b, 0xdc, 0x55, 0x89, 0x6d, 0x75, 0x36, 0x07, 0x0d, 0xbe, 0x13,
	0x8f, 0x61, 0xde, 0xcf, 0xde, 0xbf, 0x57, 0xdb, 0xcf, 0x5a, 0x09, 0x1a, 0x64, 0x8e, 0x13, 0x8d,
	0x7a, 0x25, 0xe5, 0x95, 0x01, 0x65, 0xbf, 0xc3, 0xf7, 0xed, 0xfe, 0x5e, 0x9a, 0x7c, 0x0c, 0x61,
	0xe7, 0xc7, 0xef, 0xa5, 0x21, 0x79, 0xd5, 0x96, 0xaa, 0xf6, 0x51, 0xf8, 0x16, 0x00, 0x45, 0x96,
	0x57, 0x76, 0x4a, 0xcb, 0x5b, 0x14, 0xe7, 0x7f, 0x4d, 0x83, 0x7f, 0xd0, 0xcf, 0x5e, 0x7b, 0x22,
	0xdf, 0x99, 0xb5, 0x1f, 0x7e, 0x18, 0xcc, 0xa6, 0x5b, 0x2a, 0x71, 0x76, 0x25, 0xda, 0x49, 0x5d,
	0x72, 0x35, 0x68, 0x9c, 0x28, 0x40, 0x2b, 0xef, 0x53, 0xae, 0x47, 0x21, 0xe0, 0xcc, 0x6f, 0x4b,
	0x40, 0xb1, 0x44, 0x05, 0xfe, 0x65, 0x70, 0x22, 0xff, 0x94, 0x12, 0xff, 0xec, 0x58, 0xb3, 0x1e,
	0xe3, 0xe1, 0x72, 0xd6, 0x1c, 0x26, 0xe9, 0xbb, 0xac, 0x2e, 0xa8, 0xb5, 0x0b, 0x27, 0xd6, 0xdc,
	0x43, 0x2b, 0x2f, 0x5d, 0xac, 0x1c, 0x8e, 0x36, 0xea, 0xfa, 0x0e, 0xd6, 0x78, 0xae, 0x3d, 0xea,
	0x23, 0x5f, 0x06, 0x61, 0x39, 0xf3, 0xaa, 0xdd, 0x6e, 0x56, 0xe7, 0x77, 0x69, 0x75, 0xb1, 0x62,
	0xbc, 0x73, 0x09, 0x1a, 0xb5, 0x82, 0xe3, 0x52, 0xbb, 0x5d, 0x1d, 0x06, 0xa6, 0xe1, 0x1a, 0x38,
	0x55, 0xcc, 0xee, 0x08, 0xc8, 0x53, 0x87, 0x82, 0xcc, 0xe7, 0x0c, 0xc3, 0x18, 0x0d, 0xb0, 0xd0,
	0xea, 0x64, 0x2e, 0xe9, 0xa8, 0x76, 0x7b, 0xb7, 0xb9, 0xe9, 0x3a, 0x2e, 0x51, 0x99, 0xb3, 0xd5,
	0x85, 0x91, 0xb1, 0x30, 0x83, 0xbd, 0x72, 0x35, 0x68, 0x9c, 0xde, 0x63, 0xbe, 0xd2, 0xe7, 0x0d,
	0xff, 0x22, 0x00, 0x73, 0xa9, 0xdb, 0xdc, 0xce, 0x73, 0x9e, 0xaa, 0xbc, 0x79, 0xfa, 0xd0, 0x9b,
	0x46, 0x25, 0x6d, 0x59, 0xd2, 0x14, 0xa6, 0x4c, 0x7e, 0xf9, 0x20, 0x08, 0xee, 0x7f, 0x18, 0xbc,
	0xb8, 0x3c, 0x61, 0x92, 0x6c, 0x79, 0x2a, 0xcd, 0xd4, 0x66, 0xab, 0xb3, 0xb9, 0x3c, 0xd9, 0x4b,
	0xba, 0x76, 0x79, 0x36, 0xed, 0xfa, 0x4c, 0xab, 0xce, 0x3b, 0xcd, 0x6d, 0x67, 0x96, 0xa7, 0xbc,
	0xb3, 0x89, 0xda, 0xee, 0x35, 0x4e, 0xa6, 0xc3, 0x38, 0xe1, 0x77, 0xc1, 0xc9, 0xe2, 0x9a, 0x68,
	0x5f, 0xc3, 0xfa, 0xcf, 0xa6, 0xc6, 0x9e, 0x5a, 0x8c, 0x3b, 0x71, 0x58, 0xb8, 0x7f, 0x6f, 0x94,
	0xb9, 0x70, 0x0d, 0xb3, 0xf9, 0xd0, 0xb5, 0x6a, 0x24, 0x7c, 0x0b, 0xcc, 0xa6, 0xc5, 0x71, 0x57,
	0xb3, 0xdc, 0xa2, 0x3f, 0x9f, 0x2a, 0xf6, 0xe8, 0xf9, 0xc7, 0x3d, 0x21, 0x5b, 0x0b, 0x1f, 0xd9,
	0x99, 0xd3, 0x8d, 0x99, 0x74, 0xf0, 0x3e, 0x7d, 0x49, 0xfc, 0xe8, 0x41, 0x40, 0xc1, 0x49, 0x30,
	0x55, 0xc6, 0x94, 0x34, 0x3c, 0x8a, 0x20, 0x98, 0x01, 0xc7, 0x8a, 0xb7, 0xe1, 0x51, 0x0c, 0xc1,
	0x19, 0x50, 0xab, 0x26, 0x2f, 0x1a, 0x38, 0xfd, 0xa3, 0x58, 0xac, 0x3d, 0x07, 0x4e, 0x56, 0x8e,
	0xff, 0x80, 0x3a, 0x0b, 0xaf, 0xb0, 0x15, 0xb2, 0xb6, 0x02, 0x66, 0x0a, 0x83, 0xaf, 0x88, 0xbe,
	0xf4, 0xd1, 0x83, 0xe0, 0xec, 0xc7, 0x0f, 0x82, 0x85, 0x87, 0x0f, 0x82, 0x53, 0x98, 0xac, 0x60,
	0xb4, 0x82, 0xf1, 0x0a, 0xe6, 0x2b, 0x38, 0x5e, 0xc1, 0xb4, 0xac, 0xca, 0x5e, 0x9d, 0x9c, 0x5e,
	0xa8, 0x3d, 0xf1, 0xea, 0xf1, 0xe9, 0x5f, 0x4c, 0xd5, 0xfe, 0x7b, 0x6a, 0xe9, 0x3f, 0xa6, 0xc1,
	0xdc, 0x7a, 0x9e, 0x92, 0xba, 0x41, 0x28, 0xfe, 0xfa, 0x6f, 0x1e, 0x8a, 0x3f, 0x5f, 0xc8, 0xfd,
	0xf2, 0x98, 0x90, 0xbb, 0x2f, 0xcc, 0xbe, 0xf6, 0x1b, 0x87, 0xd9, 0xdf, 0x6b, 0x74, 0xbd, 0xfa,
	0x39, 0xa2, 0xeb, 0x68, 0x50, 0xbd, 0xf6, 0x79, 0x5c, 0xfc, 0xa8, 0x2f, 0xbf, 0xf2, 0x39, 0x7c,
	0xf9, 0xef, 0xc2, 0x69, 0xab, 0xdf, 0x92, 0xd3, 0x1e, 0xf2, 0x66, 0x7f, 0xb8, 0x6e, 0xfa, 0xda,
	0x67, 0x77, 0xd3, 0x07, 0x79, 0xe7, 0x9b, 0x9f, 0xd3, 0x39, 0xef, 0xf3, 0xb3, 0x2f, 0x9d, 0xfa,
	0xf1, 0xd7, 0xf6, 0x65, 0xe3, 0x6b, 0x4b, 0xfb, 0xdd, 0xcf, 0xa9, 0xef, 0xfd, 0x2a, 0x18, 0x1d,
	0x5a, 0x5b, 0x1c, 0xf5, 0x3d, 0xf3, 0xdf, 0xfb, 0x55, 0x30, 0x3c, 0xb0, 0xf4, 0xef, 0xd3, 0x60,
	0xbe, 0xe1, 0x7a, 0x6d, 0x65, 0xbe, 0x70, 0x2d, 0x5f, 0xb8, 0x96, 0xdf, 0xaf, 0x6b, 0x79, 0xf3,
	0xb7, 0xe3, 0x5a, 0xbe, 0xf0, 0x28, 0x7f, 0x50, 0x1e, 0xe5, 0xbf, 0x4e, 0x80, 0x99, 0x2b, 0x2e,
	0xfb, 0xc2, 0x9b, 0xfc, 0x21, 0x7a, 0x93, 0x57, 0x3f, 0x4b, 0xa5, 0x7b, 0x66, 0x7c, 0xa5, 0xdb,
	0xaf, 0x6b, 0xbf, 0xf0, 0x4c, 0x5f, 0x78, 0xa6, 0xdf, 0x89, 0x67, 0x0a, 0xaf, 0x7f, 0xce, 0x9a,
	0x6f, 0xb4, 0xbe, 0xfb, 0xdd, 0xf8, 0xb9, 0xb5, 0x1f, 0x04, 0x1f, 0xff, 0x74, 0xf1, 0xc8, 0x27,
	0x3f, 0x5d, 0x3c, 0xf2, 0xcb, 0x9f, 0x2e, 0x06, 0xef, 0x3f, 0x5c, 0x0c, 0xfe, 0xfe, 0xe1, 0x62,
	0xf0, 0xaf, 0x0f, 0x17, 0x83, 0x8f, 0x1f, 0x2e, 0x06, 0x9f, 0x3c, 0x5c, 0x0c, 0x7e, 0xf2, 0x70,
	0x31, 0xf8, 0xd9, 0xc3, 0xc5, 0x23, 0xbf, 0x7c, 0xb8, 0x18, 0xfc, 0xe0, 0xd3, 0xc5, 0x23, 0x1f,
	0x7d, 0xba, 0x18, 0x7c, 0xfc, 0xe9, 0xe2, 0x91, 0x4f, 0x3e, 0x5d, 0x3c, 0xf2, 0xad, 0xc6, 0x66,
	0xb7, 0xf7, 0xce, 0xe6, 0xea, 0x9d, 0x6e, 0x3b, 0x73, 0x49, 0xa2, 0x56, 0x77, 0xd2, 0x8b, 0xc5,
	0x0f, 0xdf, 0x4d, 0xb6, 0x2f, 0xf4, 0x92, 0xee, 0x9d, 0x96, 0x75, 0xc9, 0x85, 0xfe, 0xeb, 0x8b,
	0x3d, 0xbd, 0xd9, 0xbd, 0xe8, 0xde, 0xcb, 0xfa, 0xff, 0x01, 0x3a, 0xee, 0x1f, 0x41, 0xf5, 0xf1,
	0xe2, 0x5f, 0xed, 0xc8, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0xab, 0x9a, 0x46, 0xc6, 0x2e, 0x3b,
	0x00, 0x00,
}

func (this *SimpleRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleRule)
	if !ok {
		that2, ok := that.(SimpleRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.MetricNameLabel != that1.MetricNameLabel {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if len(this.AdditionalApiGroupMatchers) != len(that1.AdditionalApiGroupMatchers) {
		return false
	}
	for i := range this.AdditionalApiGroupMatchers {
		if !this.AdditionalApiGroupMatchers[i].Equal(that1.AdditionalApiGroupMatchers[i]) {
			return false
		}
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.BotAction.Equal(that1.BotAction) {
		return false
	}
	if !this.ContentRewriteAction.Equal(that1.ContentRewriteAction) {
		return false
	}
	if !this.ShapeProtectedEndpointAction.Equal(that1.ShapeProtectedEndpointAction) {
		return false
	}
	if len(this.RateLimiters) != len(that1.RateLimiters) {
		return false
	}
	for i := range this.RateLimiters {
		if !this.RateLimiters[i].Equal(that1.RateLimiters[i]) {
			return false
		}
	}
	if len(this.RateLimiterSpecs) != len(that1.RateLimiterSpecs) {
		return false
	}
	for i := range this.RateLimiterSpecs {
		if !this.RateLimiterSpecs[i].Equal(that1.RateLimiterSpecs[i]) {
			return false
		}
	}
	if !this.MumAction.Equal(that1.MumAction) {
		return false
	}
	if !this.IpReputationAction.Equal(that1.IpReputationAction) {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	if !this.UserIdentityMatcher.Equal(that1.UserIdentityMatcher) {
		return false
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if !this.VirtualHostMatcher.Equal(that1.VirtualHostMatcher) {
		return false
	}
	if this.ChallengeAction != that1.ChallengeAction {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if !this.RequestConstraints.Equal(that1.RequestConstraints) {
		return false
	}
	if !this.GraphqlSettings.Equal(that1.GraphqlSettings) {
		return false
	}
	if !this.OpenapiValidationAction.Equal(that1.OpenapiValidationAction) {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	if !this.DstIpMatcher.Equal(that1.DstIpMatcher) {
		return false
	}
	if !this.DstAsnList.Equal(that1.DstAsnList) {
		return false
	}
	if !this.DstAsnMatcher.Equal(that1.DstAsnMatcher) {
		return false
	}
	if len(this.OriginServerSubsetsAction) != len(that1.OriginServerSubsetsAction) {
		return false
	}
	for i := range this.OriginServerSubsetsAction {
		if this.OriginServerSubsetsAction[i] != that1.OriginServerSubsetsAction[i] {
			return false
		}
	}
	if len(this.JwtClaims) != len(that1.JwtClaims) {
		return false
	}
	for i := range this.JwtClaims {
		if !this.JwtClaims[i].Equal(that1.JwtClaims[i]) {
			return false
		}
	}
	return true
}
func (this *SourceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SourceList)
	if !ok {
		that2, ok := that.(SourceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixList.Equal(that1.PrefixList) {
		return false
	}
	if len(this.IpPrefixSet) != len(that1.IpPrefixSet) {
		return false
	}
	for i := range this.IpPrefixSet {
		if !this.IpPrefixSet[i].Equal(that1.IpPrefixSet[i]) {
			return false
		}
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	if len(this.AsnSet) != len(that1.AsnSet) {
		return false
	}
	for i := range this.AsnSet {
		if !this.AsnSet[i].Equal(that1.AsnSet[i]) {
			return false
		}
	}
	if len(this.CountryList) != len(that1.CountryList) {
		return false
	}
	for i := range this.CountryList {
		if this.CountryList[i] != that1.CountryList[i] {
			return false
		}
	}
	if len(this.TlsFingerprintClasses) != len(that1.TlsFingerprintClasses) {
		return false
	}
	for i := range this.TlsFingerprintClasses {
		if this.TlsFingerprintClasses[i] != that1.TlsFingerprintClasses[i] {
			return false
		}
	}
	if len(this.TlsFingerprintValues) != len(that1.TlsFingerprintValues) {
		return false
	}
	for i := range this.TlsFingerprintValues {
		if this.TlsFingerprintValues[i] != that1.TlsFingerprintValues[i] {
			return false
		}
	}
	if that1.DefaultActionChoice == nil {
		if this.DefaultActionChoice != nil {
			return false
		}
	} else if this.DefaultActionChoice == nil {
		return false
	} else if !this.DefaultActionChoice.Equal(that1.DefaultActionChoice) {
		return false
	}
	return true
}
func (this *SourceList_DefaultActionNextPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SourceList_DefaultActionNextPolicy)
	if !ok {
		that2, ok := that.(SourceList_DefaultActionNextPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultActionNextPolicy.Equal(that1.DefaultActionNextPolicy) {
		return false
	}
	return true
}
func (this *SourceList_DefaultActionDeny) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SourceList_DefaultActionDeny)
	if !ok {
		that2, ok := that.(SourceList_DefaultActionDeny)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultActionDeny.Equal(that1.DefaultActionDeny) {
		return false
	}
	return true
}
func (this *SourceList_DefaultActionAllow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SourceList_DefaultActionAllow)
	if !ok {
		that2, ok := that.(SourceList_DefaultActionAllow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultActionAllow.Equal(that1.DefaultActionAllow) {
		return false
	}
	return true
}
func (this *Rule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rule)
	if !ok {
		that2, ok := that.(Rule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RuleList)
	if !ok {
		that2, ok := that.(RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LegacyRuleList)
	if !ok {
		that2, ok := that.(LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.Role.Equal(that1.Role) {
		return false
	}
	if !this.DenyInfo.Equal(that1.DenyInfo) {
		return false
	}
	if len(this.DefaultForwardingClasses) != len(that1.DefaultForwardingClasses) {
		return false
	}
	for i := range this.DefaultForwardingClasses {
		if !this.DefaultForwardingClasses[i].Equal(that1.DefaultForwardingClasses[i]) {
			return false
		}
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	if !this.SegmentPolicy.Equal(that1.SegmentPolicy) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	if len(this.SimpleRules) != len(that1.SimpleRules) {
		return false
	}
	for i := range this.SimpleRules {
		if !this.SimpleRules[i].Equal(that1.SimpleRules[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyServer)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerName)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AllowList)
	if !ok {
		that2, ok := that.(GlobalSpecType_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DenyList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DenyList)
	if !ok {
		that2, ok := that.(GlobalSpecType_DenyList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyList.Equal(that1.DenyList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_RuleList)
	if !ok {
		that2, ok := that.(GlobalSpecType_RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LegacyRuleList)
	if !ok {
		that2, ok := that.(GlobalSpecType_LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRuleList.Equal(that1.LegacyRuleList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AllowAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AllowAllRequests)
	if !ok {
		that2, ok := that.(GlobalSpecType_AllowAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllRequests.Equal(that1.AllowAllRequests) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DenyAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DenyAllRequests)
	if !ok {
		that2, ok := that.(GlobalSpecType_DenyAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllRequests.Equal(that1.DenyAllRequests) {
		return false
	}
	return true
}
func (this *GlobalSpecType_InternallyGenerated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_InternallyGenerated)
	if !ok {
		that2, ok := that.(GlobalSpecType_InternallyGenerated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InternallyGenerated.Equal(that1.InternallyGenerated) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	if !this.SegmentPolicy.Equal(that1.SegmentPolicy) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyServer)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerName)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AllowList)
	if !ok {
		that2, ok := that.(CreateSpecType_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DenyList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DenyList)
	if !ok {
		that2, ok := that.(CreateSpecType_DenyList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyList.Equal(that1.DenyList) {
		return false
	}
	return true
}
func (this *CreateSpecType_RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_RuleList)
	if !ok {
		that2, ok := that.(CreateSpecType_RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	return true
}
func (this *CreateSpecType_LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LegacyRuleList)
	if !ok {
		that2, ok := that.(CreateSpecType_LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRuleList.Equal(that1.LegacyRuleList) {
		return false
	}
	return true
}
func (this *CreateSpecType_AllowAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AllowAllRequests)
	if !ok {
		that2, ok := that.(CreateSpecType_AllowAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllRequests.Equal(that1.AllowAllRequests) {
		return false
	}
	return true
}
func (this *CreateSpecType_DenyAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DenyAllRequests)
	if !ok {
		that2, ok := that.(CreateSpecType_DenyAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllRequests.Equal(that1.DenyAllRequests) {
		return false
	}
	return true
}
func (this *CreateSpecType_InternallyGenerated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_InternallyGenerated)
	if !ok {
		that2, ok := that.(CreateSpecType_InternallyGenerated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InternallyGenerated.Equal(that1.InternallyGenerated) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	if !this.SegmentPolicy.Equal(that1.SegmentPolicy) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyServer)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AllowList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DenyList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DenyList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DenyList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyList.Equal(that1.DenyList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_RuleList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LegacyRuleList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRuleList.Equal(that1.LegacyRuleList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AllowAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AllowAllRequests)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AllowAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllRequests.Equal(that1.AllowAllRequests) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DenyAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DenyAllRequests)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DenyAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllRequests.Equal(that1.DenyAllRequests) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_InternallyGenerated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_InternallyGenerated)
	if !ok {
		that2, ok := that.(ReplaceSpecType_InternallyGenerated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InternallyGenerated.Equal(that1.InternallyGenerated) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	if !this.SegmentPolicy.Equal(that1.SegmentPolicy) {
		return false
	}
	if len(this.SimpleRules) != len(that1.SimpleRules) {
		return false
	}
	for i := range this.SimpleRules {
		if !this.SimpleRules[i].Equal(that1.SimpleRules[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyServer)
	if !ok {
		that2, ok := that.(GetSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *GetSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerName)
	if !ok {
		that2, ok := that.(GetSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GetSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(GetSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *GetSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AllowList)
	if !ok {
		that2, ok := that.(GetSpecType_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *GetSpecType_DenyList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DenyList)
	if !ok {
		that2, ok := that.(GetSpecType_DenyList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyList.Equal(that1.DenyList) {
		return false
	}
	return true
}
func (this *GetSpecType_RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_RuleList)
	if !ok {
		that2, ok := that.(GetSpecType_RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	return true
}
func (this *GetSpecType_LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LegacyRuleList)
	if !ok {
		that2, ok := that.(GetSpecType_LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRuleList.Equal(that1.LegacyRuleList) {
		return false
	}
	return true
}
func (this *GetSpecType_AllowAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AllowAllRequests)
	if !ok {
		that2, ok := that.(GetSpecType_AllowAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllRequests.Equal(that1.AllowAllRequests) {
		return false
	}
	return true
}
func (this *GetSpecType_DenyAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DenyAllRequests)
	if !ok {
		that2, ok := that.(GetSpecType_DenyAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllRequests.Equal(that1.DenyAllRequests) {
		return false
	}
	return true
}
func (this *GetSpecType_InternallyGenerated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_InternallyGenerated)
	if !ok {
		that2, ok := that.(GetSpecType_InternallyGenerated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InternallyGenerated.Equal(that1.InternallyGenerated) {
		return false
	}
	return true
}
func (this *SimpleRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 55)
	s = append(s, "&service_policy.SimpleRule{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "MetricNameLabel: "+fmt.Sprintf("%#v", this.MetricNameLabel)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	if this.IpPrefixList != nil {
		s = append(s, "IpPrefixList: "+fmt.Sprintf("%#v", this.IpPrefixList)+",\n")
	}
	if this.DstIpPrefixList != nil {
		s = append(s, "DstIpPrefixList: "+fmt.Sprintf("%#v", this.DstIpPrefixList)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.AsnList != nil {
		s = append(s, "AsnList: "+fmt.Sprintf("%#v", this.AsnList)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.AdditionalApiGroupMatchers != nil {
		s = append(s, "AdditionalApiGroupMatchers: "+fmt.Sprintf("%#v", this.AdditionalApiGroupMatchers)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ClientSelector != nil {
		s = append(s, "ClientSelector: "+fmt.Sprintf("%#v", this.ClientSelector)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.BotAction != nil {
		s = append(s, "BotAction: "+fmt.Sprintf("%#v", this.BotAction)+",\n")
	}
	if this.ContentRewriteAction != nil {
		s = append(s, "ContentRewriteAction: "+fmt.Sprintf("%#v", this.ContentRewriteAction)+",\n")
	}
	if this.ShapeProtectedEndpointAction != nil {
		s = append(s, "ShapeProtectedEndpointAction: "+fmt.Sprintf("%#v", this.ShapeProtectedEndpointAction)+",\n")
	}
	if this.RateLimiters != nil {
		s = append(s, "RateLimiters: "+fmt.Sprintf("%#v", this.RateLimiters)+",\n")
	}
	if this.RateLimiterSpecs != nil {
		s = append(s, "RateLimiterSpecs: "+fmt.Sprintf("%#v", this.RateLimiterSpecs)+",\n")
	}
	if this.MumAction != nil {
		s = append(s, "MumAction: "+fmt.Sprintf("%#v", this.MumAction)+",\n")
	}
	if this.IpReputationAction != nil {
		s = append(s, "IpReputationAction: "+fmt.Sprintf("%#v", this.IpReputationAction)+",\n")
	}
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	if this.IpMatcher != nil {
		s = append(s, "IpMatcher: "+fmt.Sprintf("%#v", this.IpMatcher)+",\n")
	}
	if this.AsnMatcher != nil {
		s = append(s, "AsnMatcher: "+fmt.Sprintf("%#v", this.AsnMatcher)+",\n")
	}
	if this.UserIdentityMatcher != nil {
		s = append(s, "UserIdentityMatcher: "+fmt.Sprintf("%#v", this.UserIdentityMatcher)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.VirtualHostMatcher != nil {
		s = append(s, "VirtualHostMatcher: "+fmt.Sprintf("%#v", this.VirtualHostMatcher)+",\n")
	}
	s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.RequestConstraints != nil {
		s = append(s, "RequestConstraints: "+fmt.Sprintf("%#v", this.RequestConstraints)+",\n")
	}
	if this.GraphqlSettings != nil {
		s = append(s, "GraphqlSettings: "+fmt.Sprintf("%#v", this.GraphqlSettings)+",\n")
	}
	if this.OpenapiValidationAction != nil {
		s = append(s, "OpenapiValidationAction: "+fmt.Sprintf("%#v", this.OpenapiValidationAction)+",\n")
	}
	s = append(s, "ClientName: "+fmt.Sprintf("%#v", this.ClientName)+",\n")
	if this.ClientNameMatcher != nil {
		s = append(s, "ClientNameMatcher: "+fmt.Sprintf("%#v", this.ClientNameMatcher)+",\n")
	}
	if this.DstIpMatcher != nil {
		s = append(s, "DstIpMatcher: "+fmt.Sprintf("%#v", this.DstIpMatcher)+",\n")
	}
	if this.DstAsnList != nil {
		s = append(s, "DstAsnList: "+fmt.Sprintf("%#v", this.DstAsnList)+",\n")
	}
	if this.DstAsnMatcher != nil {
		s = append(s, "DstAsnMatcher: "+fmt.Sprintf("%#v", this.DstAsnMatcher)+",\n")
	}
	keysForOriginServerSubsetsAction := make([]string, 0, len(this.OriginServerSubsetsAction))
	for k, _ := range this.OriginServerSubsetsAction {
		keysForOriginServerSubsetsAction = append(keysForOriginServerSubsetsAction, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForOriginServerSubsetsAction)
	mapStringForOriginServerSubsetsAction := "map[string]string{"
	for _, k := range keysForOriginServerSubsetsAction {
		mapStringForOriginServerSubsetsAction += fmt.Sprintf("%#v: %#v,", k, this.OriginServerSubsetsAction[k])
	}
	mapStringForOriginServerSubsetsAction += "}"
	if this.OriginServerSubsetsAction != nil {
		s = append(s, "OriginServerSubsetsAction: "+mapStringForOriginServerSubsetsAction+",\n")
	}
	if this.JwtClaims != nil {
		s = append(s, "JwtClaims: "+fmt.Sprintf("%#v", this.JwtClaims)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SourceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&service_policy.SourceList{")
	if this.PrefixList != nil {
		s = append(s, "PrefixList: "+fmt.Sprintf("%#v", this.PrefixList)+",\n")
	}
	if this.IpPrefixSet != nil {
		s = append(s, "IpPrefixSet: "+fmt.Sprintf("%#v", this.IpPrefixSet)+",\n")
	}
	if this.AsnList != nil {
		s = append(s, "AsnList: "+fmt.Sprintf("%#v", this.AsnList)+",\n")
	}
	if this.AsnSet != nil {
		s = append(s, "AsnSet: "+fmt.Sprintf("%#v", this.AsnSet)+",\n")
	}
	s = append(s, "CountryList: "+fmt.Sprintf("%#v", this.CountryList)+",\n")
	s = append(s, "TlsFingerprintClasses: "+fmt.Sprintf("%#v", this.TlsFingerprintClasses)+",\n")
	s = append(s, "TlsFingerprintValues: "+fmt.Sprintf("%#v", this.TlsFingerprintValues)+",\n")
	if this.DefaultActionChoice != nil {
		s = append(s, "DefaultActionChoice: "+fmt.Sprintf("%#v", this.DefaultActionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SourceList_DefaultActionNextPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.SourceList_DefaultActionNextPolicy{` +
		`DefaultActionNextPolicy:` + fmt.Sprintf("%#v", this.DefaultActionNextPolicy) + `}`}, ", ")
	return s
}
func (this *SourceList_DefaultActionDeny) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.SourceList_DefaultActionDeny{` +
		`DefaultActionDeny:` + fmt.Sprintf("%#v", this.DefaultActionDeny) + `}`}, ", ")
	return s
}
func (this *SourceList_DefaultActionAllow) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.SourceList_DefaultActionAllow{` +
		`DefaultActionAllow:` + fmt.Sprintf("%#v", this.DefaultActionAllow) + `}`}, ", ")
	return s
}
func (this *Rule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&service_policy.Rule{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&service_policy.RuleList{")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&service_policy.LegacyRuleList{")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 24)
	s = append(s, "&service_policy.GlobalSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.Role != nil {
		s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	}
	if this.DenyInfo != nil {
		s = append(s, "DenyInfo: "+fmt.Sprintf("%#v", this.DenyInfo)+",\n")
	}
	if this.DefaultForwardingClasses != nil {
		s = append(s, "DefaultForwardingClasses: "+fmt.Sprintf("%#v", this.DefaultForwardingClasses)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	if this.SegmentPolicy != nil {
		s = append(s, "SegmentPolicy: "+fmt.Sprintf("%#v", this.SegmentPolicy)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	if this.SimpleRules != nil {
		s = append(s, "SimpleRules: "+fmt.Sprintf("%#v", this.SimpleRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DenyList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_DenyList{` +
		`DenyList:` + fmt.Sprintf("%#v", this.DenyList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_RuleList{` +
		`RuleList:` + fmt.Sprintf("%#v", this.RuleList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_LegacyRuleList{` +
		`LegacyRuleList:` + fmt.Sprintf("%#v", this.LegacyRuleList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AllowAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_AllowAllRequests{` +
		`AllowAllRequests:` + fmt.Sprintf("%#v", this.AllowAllRequests) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DenyAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_DenyAllRequests{` +
		`DenyAllRequests:` + fmt.Sprintf("%#v", this.DenyAllRequests) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_InternallyGenerated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_InternallyGenerated{` +
		`InternallyGenerated:` + fmt.Sprintf("%#v", this.InternallyGenerated) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&service_policy.CreateSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	if this.SegmentPolicy != nil {
		s = append(s, "SegmentPolicy: "+fmt.Sprintf("%#v", this.SegmentPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DenyList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_DenyList{` +
		`DenyList:` + fmt.Sprintf("%#v", this.DenyList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_RuleList{` +
		`RuleList:` + fmt.Sprintf("%#v", this.RuleList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_LegacyRuleList{` +
		`LegacyRuleList:` + fmt.Sprintf("%#v", this.LegacyRuleList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AllowAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_AllowAllRequests{` +
		`AllowAllRequests:` + fmt.Sprintf("%#v", this.AllowAllRequests) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DenyAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_DenyAllRequests{` +
		`DenyAllRequests:` + fmt.Sprintf("%#v", this.DenyAllRequests) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_InternallyGenerated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_InternallyGenerated{` +
		`InternallyGenerated:` + fmt.Sprintf("%#v", this.InternallyGenerated) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&service_policy.ReplaceSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	if this.SegmentPolicy != nil {
		s = append(s, "SegmentPolicy: "+fmt.Sprintf("%#v", this.SegmentPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DenyList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_DenyList{` +
		`DenyList:` + fmt.Sprintf("%#v", this.DenyList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_RuleList{` +
		`RuleList:` + fmt.Sprintf("%#v", this.RuleList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_LegacyRuleList{` +
		`LegacyRuleList:` + fmt.Sprintf("%#v", this.LegacyRuleList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AllowAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_AllowAllRequests{` +
		`AllowAllRequests:` + fmt.Sprintf("%#v", this.AllowAllRequests) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DenyAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_DenyAllRequests{` +
		`DenyAllRequests:` + fmt.Sprintf("%#v", this.DenyAllRequests) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_InternallyGenerated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_InternallyGenerated{` +
		`InternallyGenerated:` + fmt.Sprintf("%#v", this.InternallyGenerated) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&service_policy.GetSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	if this.SegmentPolicy != nil {
		s = append(s, "SegmentPolicy: "+fmt.Sprintf("%#v", this.SegmentPolicy)+",\n")
	}
	if this.SimpleRules != nil {
		s = append(s, "SimpleRules: "+fmt.Sprintf("%#v", this.SimpleRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DenyList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_DenyList{` +
		`DenyList:` + fmt.Sprintf("%#v", this.DenyList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_RuleList{` +
		`RuleList:` + fmt.Sprintf("%#v", this.RuleList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_LegacyRuleList{` +
		`LegacyRuleList:` + fmt.Sprintf("%#v", this.LegacyRuleList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AllowAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_AllowAllRequests{` +
		`AllowAllRequests:` + fmt.Sprintf("%#v", this.AllowAllRequests) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DenyAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_DenyAllRequests{` +
		`DenyAllRequests:` + fmt.Sprintf("%#v", this.DenyAllRequests) + `}`}, ", ")
	return s
}
func (this *GetSpecType_InternallyGenerated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_InternallyGenerated{` +
		`InternallyGenerated:` + fmt.Sprintf("%#v", this.InternallyGenerated) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SimpleRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JwtClaims) > 0 {
		for iNdEx := len(m.JwtClaims) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JwtClaims[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.OriginServerSubsetsAction) > 0 {
		keysForOriginServerSubsetsAction := make([]string, 0, len(m.OriginServerSubsetsAction))
		for k := range m.OriginServerSubsetsAction {
			keysForOriginServerSubsetsAction = append(keysForOriginServerSubsetsAction, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForOriginServerSubsetsAction)
		for iNdEx := len(keysForOriginServerSubsetsAction) - 1; iNdEx >= 0; iNdEx-- {
			v := m.OriginServerSubsetsAction[string(keysForOriginServerSubsetsAction[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForOriginServerSubsetsAction[iNdEx])
			copy(dAtA[i:], keysForOriginServerSubsetsAction[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForOriginServerSubsetsAction[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.DstAsnMatcher != nil {
		{
			size, err := m.DstAsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.DstAsnList != nil {
		{
			size, err := m.DstAsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	if m.DstIpMatcher != nil {
		{
			size, err := m.DstIpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	if m.ClientNameMatcher != nil {
		{
			size, err := m.ClientNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	if len(m.ClientName) > 0 {
		i -= len(m.ClientName)
		copy(dAtA[i:], m.ClientName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if len(m.AdditionalApiGroupMatchers) > 0 {
		for iNdEx := len(m.AdditionalApiGroupMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdditionalApiGroupMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if m.OpenapiValidationAction != nil {
		{
			size, err := m.OpenapiValidationAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.GraphqlSettings != nil {
		{
			size, err := m.GraphqlSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if m.RequestConstraints != nil {
		{
			size, err := m.RequestConstraints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.CookieMatchers) > 0 {
		for iNdEx := len(m.CookieMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.ArgMatchers) > 0 {
		for iNdEx := len(m.ArgMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArgMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	if m.ChallengeAction != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeAction))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.VirtualHostMatcher != nil {
		{
			size, err := m.VirtualHostMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.BodyMatcher != nil {
		{
			size, err := m.BodyMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.UserIdentityMatcher != nil {
		{
			size, err := m.UserIdentityMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.AsnMatcher != nil {
		{
			size, err := m.AsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.IpMatcher != nil {
		{
			size, err := m.IpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.GotoPolicy) > 0 {
		for iNdEx := len(m.GotoPolicy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GotoPolicy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x82
		}
	}
	if m.IpReputationAction != nil {
		{
			size, err := m.IpReputationAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.MumAction != nil {
		{
			size, err := m.MumAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RateLimiterSpecs) > 0 {
		for iNdEx := len(m.RateLimiterSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiterSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.RateLimiters) > 0 {
		for iNdEx := len(m.RateLimiters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if m.ShapeProtectedEndpointAction != nil {
		{
			size, err := m.ShapeProtectedEndpointAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.ContentRewriteAction != nil {
		{
			size, err := m.ContentRewriteAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.BotAction != nil {
		{
			size, err := m.BotAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.ClientSelector != nil {
		{
			size, err := m.ClientSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ClientRole != nil {
		{
			size, err := m.ClientRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ApiGroupMatcher != nil {
		{
			size, err := m.ApiGroupMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.TlsFingerprintMatcher != nil {
		{
			size, err := m.TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.MetricNameLabel) > 0 {
		i -= len(m.MetricNameLabel)
		copy(dAtA[i:], m.MetricNameLabel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MetricNameLabel)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.DstIpPrefixList != nil {
		{
			size, err := m.DstIpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.IpPrefixList != nil {
		{
			size, err := m.IpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.L4DestMatcher != nil {
		{
			size, err := m.L4DestMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.UrlMatcher != nil {
		{
			size, err := m.UrlMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Scheme) > 0 {
		for iNdEx := len(m.Scheme) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scheme[iNdEx])
			copy(dAtA[i:], m.Scheme[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Scheme[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.WafAction != nil {
		{
			size, err := m.WafAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.HttpMethod != nil {
		{
			size, err := m.HttpMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DomainMatcher != nil {
		{
			size, err := m.DomainMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultActionChoice != nil {
		{
			size := m.DefaultActionChoice.Size()
			i -= size
			if _, err := m.DefaultActionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.TlsFingerprintValues) > 0 {
		for iNdEx := len(m.TlsFingerprintValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TlsFingerprintValues[iNdEx])
			copy(dAtA[i:], m.TlsFingerprintValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsFingerprintValues[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TlsFingerprintClasses) > 0 {
		dAtA36 := make([]byte, len(m.TlsFingerprintClasses)*10)
		var j35 int
		for _, num := range m.TlsFingerprintClasses {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		i -= j35
		copy(dAtA[i:], dAtA36[:j35])
		i = encodeVarintTypes(dAtA, i, uint64(j35))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CountryList) > 0 {
		dAtA38 := make([]byte, len(m.CountryList)*10)
		var j37 int
		for _, num := range m.CountryList {
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		i -= j37
		copy(dAtA[i:], dAtA38[:j37])
		i = encodeVarintTypes(dAtA, i, uint64(j37))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AsnSet) > 0 {
		for iNdEx := len(m.AsnSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AsnSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.IpPrefixSet) > 0 {
		for iNdEx := len(m.IpPrefixSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpPrefixSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PrefixList != nil {
		{
			size, err := m.PrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SourceList_DefaultActionNextPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceList_DefaultActionNextPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultActionNextPolicy != nil {
		{
			size, err := m.DefaultActionNextPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *SourceList_DefaultActionDeny) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceList_DefaultActionDeny) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultActionDeny != nil {
		{
			size, err := m.DefaultActionDeny.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *SourceList_DefaultActionAllow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceList_DefaultActionAllow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultActionAllow != nil {
		{
			size, err := m.DefaultActionAllow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RuleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LegacyRuleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SimpleRules) > 0 {
		for iNdEx := len(m.SimpleRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SimpleRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xca
		}
	}
	if m.ViewInternal != nil {
		{
			size, err := m.ViewInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.SegmentPolicy != nil {
		{
			size, err := m.SegmentPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.DefaultForwardingClasses) > 0 {
		for iNdEx := len(m.DefaultForwardingClasses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DefaultForwardingClasses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.DenyInfo != nil {
		{
			size, err := m.DenyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Algo != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DenyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DenyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyList != nil {
		{
			size, err := m.DenyList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRuleList != nil {
		{
			size, err := m.LegacyRuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_InternallyGenerated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_InternallyGenerated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternallyGenerated != nil {
		{
			size, err := m.InternallyGenerated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AllowAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AllowAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllRequests != nil {
		{
			size, err := m.AllowAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DenyAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DenyAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllRequests != nil {
		{
			size, err := m.DenyAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SegmentPolicy != nil {
		{
			size, err := m.SegmentPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Algo != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DenyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DenyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyList != nil {
		{
			size, err := m.DenyList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRuleList != nil {
		{
			size, err := m.LegacyRuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_InternallyGenerated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_InternallyGenerated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternallyGenerated != nil {
		{
			size, err := m.InternallyGenerated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AllowAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AllowAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllRequests != nil {
		{
			size, err := m.AllowAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DenyAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DenyAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllRequests != nil {
		{
			size, err := m.DenyAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SegmentPolicy != nil {
		{
			size, err := m.SegmentPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Algo != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DenyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DenyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyList != nil {
		{
			size, err := m.DenyList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRuleList != nil {
		{
			size, err := m.LegacyRuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_InternallyGenerated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_InternallyGenerated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternallyGenerated != nil {
		{
			size, err := m.InternallyGenerated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AllowAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AllowAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllRequests != nil {
		{
			size, err := m.AllowAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DenyAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DenyAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllRequests != nil {
		{
			size, err := m.DenyAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SimpleRules) > 0 {
		for iNdEx := len(m.SimpleRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SimpleRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xca
		}
	}
	if m.SegmentPolicy != nil {
		{
			size, err := m.SegmentPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Algo != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DenyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DenyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyList != nil {
		{
			size, err := m.DenyList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRuleList != nil {
		{
			size, err := m.LegacyRuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_InternallyGenerated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_InternallyGenerated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternallyGenerated != nil {
		{
			size, err := m.InternallyGenerated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AllowAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AllowAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllRequests != nil {
		{
			size, err := m.AllowAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DenyAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DenyAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllRequests != nil {
		{
			size, err := m.DenyAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SimpleRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.MetricNameLabel)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BotAction != nil {
		l = m.BotAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ContentRewriteAction != nil {
		l = m.ContentRewriteAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ShapeProtectedEndpointAction != nil {
		l = m.ShapeProtectedEndpointAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiters) > 0 {
		for _, e := range m.RateLimiters {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterSpecs) > 0 {
		for _, e := range m.RateLimiterSpecs {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.MumAction != nil {
		l = m.MumAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IpReputationAction != nil {
		l = m.IpReputationAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.UserIdentityMatcher != nil {
		l = m.UserIdentityMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VirtualHostMatcher != nil {
		l = m.VirtualHostMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ChallengeAction != 0 {
		n += 2 + sovTypes(uint64(m.ChallengeAction))
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.RequestConstraints != nil {
		l = m.RequestConstraints.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.GraphqlSettings != nil {
		l = m.GraphqlSettings.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.OpenapiValidationAction != nil {
		l = m.OpenapiValidationAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.AdditionalApiGroupMatchers) > 0 {
		for _, e := range m.AdditionalApiGroupMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ClientName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstIpMatcher != nil {
		l = m.DstIpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnList != nil {
		l = m.DstAsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnMatcher != nil {
		l = m.DstAsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.OriginServerSubsetsAction) > 0 {
		for k, v := range m.OriginServerSubsetsAction {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.JwtClaims) > 0 {
		for _, e := range m.JwtClaims {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SourceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixList != nil {
		l = m.PrefixList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.IpPrefixSet) > 0 {
		for _, e := range m.IpPrefixSet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AsnSet) > 0 {
		for _, e := range m.AsnSet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CountryList) > 0 {
		l = 0
		for _, e := range m.CountryList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.TlsFingerprintClasses) > 0 {
		l = 0
		for _, e := range m.TlsFingerprintClasses {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.TlsFingerprintValues) > 0 {
		for _, s := range m.TlsFingerprintValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DefaultActionChoice != nil {
		n += m.DefaultActionChoice.Size()
	}
	return n
}

func (m *SourceList_DefaultActionNextPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultActionNextPolicy != nil {
		l = m.DefaultActionNextPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SourceList_DefaultActionDeny) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultActionDeny != nil {
		l = m.DefaultActionDeny.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SourceList_DefaultActionAllow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultActionAllow != nil {
		l = m.DefaultActionAllow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DenyInfo != nil {
		l = m.DenyInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DefaultForwardingClasses) > 0 {
		for _, e := range m.DefaultForwardingClasses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	if m.SegmentPolicy != nil {
		l = m.SegmentPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.SimpleRules) > 0 {
		for _, e := range m.SimpleRules {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DenyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyList != nil {
		l = m.DenyList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRuleList != nil {
		l = m.LegacyRuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_InternallyGenerated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternallyGenerated != nil {
		l = m.InternallyGenerated.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AllowAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllRequests != nil {
		l = m.AllowAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DenyAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllRequests != nil {
		l = m.DenyAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	if m.SegmentPolicy != nil {
		l = m.SegmentPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DenyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyList != nil {
		l = m.DenyList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRuleList != nil {
		l = m.LegacyRuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_InternallyGenerated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternallyGenerated != nil {
		l = m.InternallyGenerated.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AllowAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllRequests != nil {
		l = m.AllowAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DenyAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllRequests != nil {
		l = m.DenyAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	if m.SegmentPolicy != nil {
		l = m.SegmentPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DenyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyList != nil {
		l = m.DenyList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRuleList != nil {
		l = m.LegacyRuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_InternallyGenerated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternallyGenerated != nil {
		l = m.InternallyGenerated.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AllowAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllRequests != nil {
		l = m.AllowAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DenyAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllRequests != nil {
		l = m.DenyAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	if m.SegmentPolicy != nil {
		l = m.SegmentPolicy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.SimpleRules) > 0 {
		for _, e := range m.SimpleRules {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DenyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyList != nil {
		l = m.DenyList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRuleList != nil {
		l = m.LegacyRuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_InternallyGenerated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternallyGenerated != nil {
		l = m.InternallyGenerated.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AllowAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllRequests != nil {
		l = m.AllowAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DenyAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllRequests != nil {
		l = m.DenyAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SimpleRule) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(fmt.Sprintf("%v", f), "HeaderMatcherType", "policy.HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForRateLimiters := "[]*ObjectRefType{"
	for _, f := range this.RateLimiters {
		repeatedStringForRateLimiters += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiters += "}"
	repeatedStringForRateLimiterSpecs := "[]*GlobalSpecType{"
	for _, f := range this.RateLimiterSpecs {
		repeatedStringForRateLimiterSpecs += strings.Replace(fmt.Sprintf("%v", f), "GlobalSpecType", "rate_limiter.GlobalSpecType", 1) + ","
	}
	repeatedStringForRateLimiterSpecs += "}"
	repeatedStringForGotoPolicy := "[]*ObjectRefType{"
	for _, f := range this.GotoPolicy {
		repeatedStringForGotoPolicy += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForGotoPolicy += "}"
	repeatedStringForQueryParams := "[]*QueryParameterMatcherType{"
	for _, f := range this.QueryParams {
		repeatedStringForQueryParams += strings.Replace(fmt.Sprintf("%v", f), "QueryParameterMatcherType", "policy.QueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParams += "}"
	repeatedStringForArgMatchers := "[]*ArgMatcherType{"
	for _, f := range this.ArgMatchers {
		repeatedStringForArgMatchers += strings.Replace(fmt.Sprintf("%v", f), "ArgMatcherType", "policy.ArgMatcherType", 1) + ","
	}
	repeatedStringForArgMatchers += "}"
	repeatedStringForCookieMatchers := "[]*CookieMatcherType{"
	for _, f := range this.CookieMatchers {
		repeatedStringForCookieMatchers += strings.Replace(fmt.Sprintf("%v", f), "CookieMatcherType", "policy.CookieMatcherType", 1) + ","
	}
	repeatedStringForCookieMatchers += "}"
	repeatedStringForAdditionalApiGroupMatchers := "[]*StringMatcherType{"
	for _, f := range this.AdditionalApiGroupMatchers {
		repeatedStringForAdditionalApiGroupMatchers += strings.Replace(fmt.Sprintf("%v", f), "StringMatcherType", "policy.StringMatcherType", 1) + ","
	}
	repeatedStringForAdditionalApiGroupMatchers += "}"
	repeatedStringForJwtClaims := "[]*JWTClaimMatcherType{"
	for _, f := range this.JwtClaims {
		repeatedStringForJwtClaims += strings.Replace(fmt.Sprintf("%v", f), "JWTClaimMatcherType", "policy.JWTClaimMatcherType", 1) + ","
	}
	repeatedStringForJwtClaims += "}"
	keysForOriginServerSubsetsAction := make([]string, 0, len(this.OriginServerSubsetsAction))
	for k, _ := range this.OriginServerSubsetsAction {
		keysForOriginServerSubsetsAction = append(keysForOriginServerSubsetsAction, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForOriginServerSubsetsAction)
	mapStringForOriginServerSubsetsAction := "map[string]string{"
	for _, k := range keysForOriginServerSubsetsAction {
		mapStringForOriginServerSubsetsAction += fmt.Sprintf("%v: %v,", k, this.OriginServerSubsetsAction[k])
	}
	mapStringForOriginServerSubsetsAction += "}"
	s := strings.Join([]string{`&SimpleRule{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "policy.PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "policy.HttpMethodMatcherType", 1) + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "policy.WafAction", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "policy.URLMatcherType", 1) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "policy.L4DestMatcherType", 1) + `,`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`MetricNameLabel:` + fmt.Sprintf("%v", this.MetricNameLabel) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "policy.TlsFingerprintMatcherType", 1) + `,`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "policy.StringMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "policy.RoleMatcherType", 1) + `,`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`BotAction:` + strings.Replace(fmt.Sprintf("%v", this.BotAction), "BotAction", "policy.BotAction", 1) + `,`,
		`ContentRewriteAction:` + strings.Replace(fmt.Sprintf("%v", this.ContentRewriteAction), "ContentRewriteAction", "policy.ContentRewriteAction", 1) + `,`,
		`ShapeProtectedEndpointAction:` + strings.Replace(fmt.Sprintf("%v", this.ShapeProtectedEndpointAction), "ShapeProtectedEndpointAction", "policy.ShapeProtectedEndpointAction", 1) + `,`,
		`RateLimiters:` + repeatedStringForRateLimiters + `,`,
		`RateLimiterSpecs:` + repeatedStringForRateLimiterSpecs + `,`,
		`MumAction:` + strings.Replace(fmt.Sprintf("%v", this.MumAction), "ModifyAction", "policy.ModifyAction", 1) + `,`,
		`IpReputationAction:` + strings.Replace(fmt.Sprintf("%v", this.IpReputationAction), "ModifyAction", "policy.ModifyAction", 1) + `,`,
		`GotoPolicy:` + repeatedStringForGotoPolicy + `,`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`UserIdentityMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UserIdentityMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`VirtualHostMatcher:` + strings.Replace(fmt.Sprintf("%v", this.VirtualHostMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`QueryParams:` + repeatedStringForQueryParams + `,`,
		`ArgMatchers:` + repeatedStringForArgMatchers + `,`,
		`CookieMatchers:` + repeatedStringForCookieMatchers + `,`,
		`RequestConstraints:` + strings.Replace(fmt.Sprintf("%v", this.RequestConstraints), "RequestConstraintType", "policy.RequestConstraintType", 1) + `,`,
		`GraphqlSettings:` + strings.Replace(fmt.Sprintf("%v", this.GraphqlSettings), "GraphQLSettingsType", "policy.GraphQLSettingsType", 1) + `,`,
		`OpenapiValidationAction:` + strings.Replace(fmt.Sprintf("%v", this.OpenapiValidationAction), "OpenApiValidationAction", "policy.OpenApiValidationAction", 1) + `,`,
		`AdditionalApiGroupMatchers:` + repeatedStringForAdditionalApiGroupMatchers + `,`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`DstIpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstIpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`DstAsnList:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`DstAsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`OriginServerSubsetsAction:` + mapStringForOriginServerSubsetsAction + `,`,
		`JwtClaims:` + repeatedStringForJwtClaims + `,`,
		`}`,
	}, "")
	return s
}
func (this *SourceList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIpPrefixSet := "[]*ObjectRefType{"
	for _, f := range this.IpPrefixSet {
		repeatedStringForIpPrefixSet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForIpPrefixSet += "}"
	repeatedStringForAsnSet := "[]*ObjectRefType{"
	for _, f := range this.AsnSet {
		repeatedStringForAsnSet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForAsnSet += "}"
	s := strings.Join([]string{`&SourceList{`,
		`PrefixList:` + strings.Replace(fmt.Sprintf("%v", this.PrefixList), "PrefixStringListType", "views.PrefixStringListType", 1) + `,`,
		`IpPrefixSet:` + repeatedStringForIpPrefixSet + `,`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`AsnSet:` + repeatedStringForAsnSet + `,`,
		`CountryList:` + fmt.Sprintf("%v", this.CountryList) + `,`,
		`TlsFingerprintClasses:` + fmt.Sprintf("%v", this.TlsFingerprintClasses) + `,`,
		`TlsFingerprintValues:` + fmt.Sprintf("%v", this.TlsFingerprintValues) + `,`,
		`DefaultActionChoice:` + fmt.Sprintf("%v", this.DefaultActionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SourceList_DefaultActionNextPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SourceList_DefaultActionNextPolicy{`,
		`DefaultActionNextPolicy:` + strings.Replace(fmt.Sprintf("%v", this.DefaultActionNextPolicy), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SourceList_DefaultActionDeny) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SourceList_DefaultActionDeny{`,
		`DefaultActionDeny:` + strings.Replace(fmt.Sprintf("%v", this.DefaultActionDeny), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SourceList_DefaultActionAllow) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SourceList_DefaultActionAllow{`,
		`DefaultActionAllow:` + strings.Replace(fmt.Sprintf("%v", this.DefaultActionAllow), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Rule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Rule{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`Spec:` + strings.Replace(fmt.Sprintf("%v", this.Spec), "GlobalSpecType", "service_policy_rule.GlobalSpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RuleList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*Rule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "Rule", "Rule", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&RuleList{`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*ObjectRefType{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&LegacyRuleList{`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*ObjectRefType{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRules += "}"
	repeatedStringForDefaultForwardingClasses := "[]*ObjectRefType{"
	for _, f := range this.DefaultForwardingClasses {
		repeatedStringForDefaultForwardingClasses += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForDefaultForwardingClasses += "}"
	repeatedStringForSimpleRules := "[]*SimpleRule{"
	for _, f := range this.SimpleRules {
		repeatedStringForSimpleRules += strings.Replace(f.String(), "SimpleRule", "SimpleRule", 1) + ","
	}
	repeatedStringForSimpleRules += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + repeatedStringForRules + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`Role:` + strings.Replace(fmt.Sprintf("%v", this.Role), "RoleMatcherType", "policy.RoleMatcherType", 1) + `,`,
		`DenyInfo:` + strings.Replace(fmt.Sprintf("%v", this.DenyInfo), "DenyInformation", "policy.DenyInformation", 1) + `,`,
		`DefaultForwardingClasses:` + repeatedStringForDefaultForwardingClasses + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`SegmentPolicy:` + strings.Replace(fmt.Sprintf("%v", this.SegmentPolicy), "SegmentPolicyType", "policy.SegmentPolicyType", 1) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`SimpleRules:` + repeatedStringForSimpleRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DenyList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DenyList{`,
		`DenyList:` + strings.Replace(fmt.Sprintf("%v", this.DenyList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_RuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_RuleList{`,
		`RuleList:` + strings.Replace(fmt.Sprintf("%v", this.RuleList), "RuleList", "RuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LegacyRuleList{`,
		`LegacyRuleList:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRuleList), "LegacyRuleList", "LegacyRuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_InternallyGenerated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_InternallyGenerated{`,
		`InternallyGenerated:` + strings.Replace(fmt.Sprintf("%v", this.InternallyGenerated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AllowAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AllowAllRequests{`,
		`AllowAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DenyAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DenyAllRequests{`,
		`DenyAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`SegmentPolicy:` + strings.Replace(fmt.Sprintf("%v", this.SegmentPolicy), "SegmentPolicyType", "policy.SegmentPolicyType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DenyList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DenyList{`,
		`DenyList:` + strings.Replace(fmt.Sprintf("%v", this.DenyList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_RuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_RuleList{`,
		`RuleList:` + strings.Replace(fmt.Sprintf("%v", this.RuleList), "RuleList", "RuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LegacyRuleList{`,
		`LegacyRuleList:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRuleList), "LegacyRuleList", "LegacyRuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_InternallyGenerated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_InternallyGenerated{`,
		`InternallyGenerated:` + strings.Replace(fmt.Sprintf("%v", this.InternallyGenerated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AllowAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AllowAllRequests{`,
		`AllowAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DenyAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DenyAllRequests{`,
		`DenyAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`SegmentPolicy:` + strings.Replace(fmt.Sprintf("%v", this.SegmentPolicy), "SegmentPolicyType", "policy.SegmentPolicyType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DenyList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DenyList{`,
		`DenyList:` + strings.Replace(fmt.Sprintf("%v", this.DenyList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_RuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_RuleList{`,
		`RuleList:` + strings.Replace(fmt.Sprintf("%v", this.RuleList), "RuleList", "RuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LegacyRuleList{`,
		`LegacyRuleList:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRuleList), "LegacyRuleList", "LegacyRuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_InternallyGenerated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_InternallyGenerated{`,
		`InternallyGenerated:` + strings.Replace(fmt.Sprintf("%v", this.InternallyGenerated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AllowAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AllowAllRequests{`,
		`AllowAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DenyAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DenyAllRequests{`,
		`DenyAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*ObjectRefType{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRules += "}"
	repeatedStringForSimpleRules := "[]*SimpleRule{"
	for _, f := range this.SimpleRules {
		repeatedStringForSimpleRules += strings.Replace(f.String(), "SimpleRule", "SimpleRule", 1) + ","
	}
	repeatedStringForSimpleRules += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + repeatedStringForRules + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`SegmentPolicy:` + strings.Replace(fmt.Sprintf("%v", this.SegmentPolicy), "SegmentPolicyType", "policy.SegmentPolicyType", 1) + `,`,
		`SimpleRules:` + repeatedStringForSimpleRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DenyList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DenyList{`,
		`DenyList:` + strings.Replace(fmt.Sprintf("%v", this.DenyList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_RuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_RuleList{`,
		`RuleList:` + strings.Replace(fmt.Sprintf("%v", this.RuleList), "RuleList", "RuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LegacyRuleList{`,
		`LegacyRuleList:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRuleList), "LegacyRuleList", "LegacyRuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_InternallyGenerated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_InternallyGenerated{`,
		`InternallyGenerated:` + strings.Replace(fmt.Sprintf("%v", this.InternallyGenerated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AllowAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AllowAllRequests{`,
		`AllowAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DenyAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DenyAllRequests{`,
		`DenyAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SimpleRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= policy.RuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &policy.MatcherType{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpPrefixList == nil {
				m.IpPrefixList = &policy.PrefixMatchList{}
			}
			if err := m.IpPrefixList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIpPrefixList == nil {
				m.DstIpPrefixList = &policy.PrefixMatchList{}
			}
			if err := m.DstIpPrefixList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricNameLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricNameLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsnList == nil {
				m.AsnList = &policy.AsnMatchList{}
			}
			if err := m.AsnList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientSelector == nil {
				m.ClientSelector = &schema.LabelSelectorType{}
			}
			if err := m.ClientSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &schema.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotAction == nil {
				m.BotAction = &policy.BotAction{}
			}
			if err := m.BotAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentRewriteAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentRewriteAction == nil {
				m.ContentRewriteAction = &policy.ContentRewriteAction{}
			}
			if err := m.ContentRewriteAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShapeProtectedEndpointAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShapeProtectedEndpointAction == nil {
				m.ShapeProtectedEndpointAction = &policy.ShapeProtectedEndpointAction{}
			}
			if err := m.ShapeProtectedEndpointAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiters = append(m.RateLimiters, &schema.ObjectRefType{})
			if err := m.RateLimiters[len(m.RateLimiters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterSpecs = append(m.RateLimiterSpecs, &rate_limiter.GlobalSpecType{})
			if err := m.RateLimiterSpecs[len(m.RateLimiterSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MumAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MumAction == nil {
				m.MumAction = &policy.ModifyAction{}
			}
			if err := m.MumAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReputationAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpReputationAction == nil {
				m.IpReputationAction = &policy.ModifyAction{}
			}
			if err := m.IpReputationAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &schema.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpMatcher == nil {
				m.IpMatcher = &policy.IpMatcherType{}
			}
			if err := m.IpMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsnMatcher == nil {
				m.AsnMatcher = &policy.AsnMatcherType{}
			}
			if err := m.AsnMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdentityMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserIdentityMatcher == nil {
				m.UserIdentityMatcher = &policy.MatcherTypeBasic{}
			}
			if err := m.UserIdentityMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHostMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualHostMatcher == nil {
				m.VirtualHostMatcher = &policy.MatcherType{}
			}
			if err := m.VirtualHostMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAction", wireType)
			}
			m.ChallengeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAction |= policy.ChallengeAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestConstraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestConstraints == nil {
				m.RequestConstraints = &policy.RequestConstraintType{}
			}
			if err := m.RequestConstraints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphqlSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphqlSettings == nil {
				m.GraphqlSettings = &policy.GraphQLSettingsType{}
			}
			if err := m.GraphqlSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenapiValidationAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenapiValidationAction == nil {
				m.OpenapiValidationAction = &policy.OpenApiValidationAction{}
			}
			if err := m.OpenapiValidationAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalApiGroupMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalApiGroupMatchers = append(m.AdditionalApiGroupMatchers, &policy.StringMatcherType{})
			if err := m.AdditionalApiGroupMatchers[len(m.AdditionalApiGroupMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientNameMatcher == nil {
				m.ClientNameMatcher = &policy.MatcherType{}
			}
			if err := m.ClientNameMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIpMatcher == nil {
				m.DstIpMatcher = &policy.IpMatcherType{}
			}
			if err := m.DstIpMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstAsnList == nil {
				m.DstAsnList = &policy.AsnMatchList{}
			}
			if err := m.DstAsnList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstAsnMatcher == nil {
				m.DstAsnMatcher = &policy.AsnMatcherType{}
			}
			if err := m.DstAsnMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginServerSubsetsAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginServerSubsetsAction == nil {
				m.OriginServerSubsetsAction = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OriginServerSubsetsAction[mapkey] = mapvalue
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JwtClaims", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JwtClaims = append(m.JwtClaims, &policy.JWTClaimMatcherType{})
			if err := m.JwtClaims[len(m.JwtClaims)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrefixList == nil {
				m.PrefixList = &views.PrefixStringListType{}
			}
			if err := m.PrefixList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefixSet = append(m.IpPrefixSet, &views.ObjectRefType{})
			if err := m.IpPrefixSet[len(m.IpPrefixSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsnList == nil {
				m.AsnList = &policy.AsnMatchList{}
			}
			if err := m.AsnList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsnSet = append(m.AsnSet, &views.ObjectRefType{})
			if err := m.AsnSet[len(m.AsnSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v policy.CountryCode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= policy.CountryCode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CountryList = append(m.CountryList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.CountryList) == 0 {
					m.CountryList = make([]policy.CountryCode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v policy.CountryCode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= policy.CountryCode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CountryList = append(m.CountryList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryList", wireType)
			}
		case 7:
			if wireType == 0 {
				var v policy.KnownTlsFingerprintClass
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= policy.KnownTlsFingerprintClass(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TlsFingerprintClasses = append(m.TlsFingerprintClasses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.TlsFingerprintClasses) == 0 {
					m.TlsFingerprintClasses = make([]policy.KnownTlsFingerprintClass, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v policy.KnownTlsFingerprintClass
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= policy.KnownTlsFingerprintClass(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TlsFingerprintClasses = append(m.TlsFingerprintClasses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintClasses", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsFingerprintValues = append(m.TlsFingerprintValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultActionNextPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultActionChoice = &SourceList_DefaultActionNextPolicy{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultActionDeny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultActionChoice = &SourceList_DefaultActionDeny{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultActionAllow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultActionChoice = &SourceList_DefaultActionAllow{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &service_policy_rule.GlobalSpecType{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &Rule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LegacyRuleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LegacyRuleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LegacyRuleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &schema.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= policy.RuleCombiningAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &GlobalSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &schema.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &policy.RoleMatcherType{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenyInfo == nil {
				m.DenyInfo = &policy.DenyInformation{}
			}
			if err := m.DenyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultForwardingClasses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultForwardingClasses = append(m.DefaultForwardingClasses, &schema.ObjectRefType{})
			if err := m.DefaultForwardingClasses[len(m.DefaultForwardingClasses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_AnyServer{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_AllowList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_DenyList{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_RuleList{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyRuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_LegacyRuleList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternallyGenerated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_InternallyGenerated{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_AllowAllRequests{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_DenyAllRequests{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentPolicy == nil {
				m.SegmentPolicy = &policy.SegmentPolicyType{}
			}
			if err := m.SegmentPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SimpleRules = append(m.SimpleRules, &SimpleRule{})
			if err := m.SimpleRules[len(m.SimpleRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= policy.RuleCombiningAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &CreateSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_AnyServer{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_AllowList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_DenyList{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_RuleList{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyRuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_LegacyRuleList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternallyGenerated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_InternallyGenerated{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_AllowAllRequests{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_DenyAllRequests{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentPolicy == nil {
				m.SegmentPolicy = &policy.SegmentPolicyType{}
			}
			if err := m.SegmentPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= policy.RuleCombiningAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &ReplaceSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_AnyServer{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_AllowList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_DenyList{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_RuleList{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyRuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_LegacyRuleList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternallyGenerated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_InternallyGenerated{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_AllowAllRequests{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_DenyAllRequests{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentPolicy == nil {
				m.SegmentPolicy = &policy.SegmentPolicyType{}
			}
			if err := m.SegmentPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= policy.RuleCombiningAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &GetSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &schema.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_AnyServer{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_AllowList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_DenyList{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_RuleList{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyRuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_LegacyRuleList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternallyGenerated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_InternallyGenerated{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_AllowAllRequests{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_DenyAllRequests{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentPolicy == nil {
				m.SegmentPolicy = &policy.SegmentPolicyType{}
			}
			if err := m.SegmentPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SimpleRules = append(m.SimpleRules, &SimpleRule{})
			if err := m.SimpleRules[len(m.SimpleRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
