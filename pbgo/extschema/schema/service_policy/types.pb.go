// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/service_policy/types.proto

package service_policy

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	rate_limiter "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/rate_limiter"
	service_policy_rule "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy_rule"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// simple rule
//
// x-displayName: "Simple Rule"
// A SimpleRule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from
// or derived from an L7 request API. A request API is considered to match the simple rule if all predicates in the rule evaluate to true for that request. Any
// predicates that are not specified in a rule are implicitly considered to be true. If a request API matches a simple rule, the action for the simple rule is
// enforced.
//
// A SimpleRule does not currently support any predicates that contain references to objects.
type SimpleRule struct {
	// name
	//
	// x-displayName: "Name"
	// Name of the rule.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// metric_name_label
	//
	// x-displayName: "Metric Name Label"
	// Name label to use in service policy rule metrics generated for this simple rule.
	MetricNameLabel string `protobuf:"bytes,17,opt,name=metric_name_label,json=metricNameLabel,proto3" json:"metric_name_label,omitempty"`
	// action
	//
	// x-displayName: "Action"
	// Action to be enforced if the input request matches the rule.
	Action policy.RuleAction `protobuf:"varint,2,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// domain matcher
	//
	// x-displayName: "Domain Matcher"
	// A list of exact values and/or regular expressions for the expected name of the domain. The actual value of domain is the host component
	// from the URL. The predicate evaluates to true if the domain value matches any of the exact values or regular expressions in the domain
	// matcher.
	DomainMatcher *policy.MatcherType `protobuf:"bytes,3,opt,name=domain_matcher,json=domainMatcher,proto3" json:"domain_matcher,omitempty"`
	// path
	//
	// x-displayName: "HTTP Path"
	// A list of exact values, prefixes and regular expressions for the expected value of the HTTP path. The actual value of the HTTP path is the unescaped path
	// value extracted from the HTTP URL Resource, excluding any query and fragment information.
	// The predicate evaluates to true if the actual path value matches any of the exact or prefix values or regular expressions in the path matcher.
	Path *policy.PathMatcherType `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// headers
	//
	// x-displayName: "HTTP Headers"
	// A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType
	// instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.
	// Note that all specified header predicates must evaluate to true.
	Headers []*policy.HeaderMatcherType `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty"`
	// method
	//
	// x-displayName: "HTTP Method"
	// The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.
	// The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.
	HttpMethod *policy.HttpMethodMatcherType `protobuf:"bytes,6,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	// App Firewall Action
	//
	// x-displayName: "App Firewall Action"
	// App Firewall action to be enforced if the input request matches the rule.
	WafAction *policy.WafAction `protobuf:"bytes,7,opt,name=waf_action,json=wafAction,proto3" json:"waf_action,omitempty"`
	// expiration timestamp
	//
	// x-displayName: "Expiration Timestamp"
	// x-example: "2019-12-31:44:34.171543432Z"
	// The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in
	// the configuration but is not applied anymore.
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,8,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// scheme
	//
	// x-displayName: "Scheme"
	// x-example: "HTTPS"
	// The scheme in the request.
	Scheme []string `protobuf:"bytes,12,rep,name=scheme,proto3" json:"scheme,omitempty"`
	// port matcher
	//
	// x-displayName: "Port Matcher"
	// The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.
	PortMatcher *policy.PortMatcherType `protobuf:"bytes,10,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Deny access to Facebook"
	// Description for the rule.
	Description string `protobuf:"bytes,11,opt,name=description,proto3" json:"description,omitempty"`
	// url matcher
	//
	// x-displayName: "URL Matcher"
	// A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the domain and path match any of the URL items.
	UrlMatcher *policy.URLMatcherType `protobuf:"bytes,13,opt,name=url_matcher,json=urlMatcher,proto3" json:"url_matcher,omitempty"`
	// l4 dest matcher
	//
	// x-displayName: "L4 Destination Matcher"
	// A L4 Destination matcher specifies a list of IPv4 prefixes and a TCP port range as match criteria. The match is considered successful if the destination
	// IP matches one of the prefixes and the destination port belongs to the port range.
	L4DestMatcher *policy.L4DestMatcherType `protobuf:"bytes,14,opt,name=l4_dest_matcher,json=l4DestMatcher,proto3" json:"l4_dest_matcher,omitempty"`
	// ip prefix list
	//
	// x-displayName: "IPv4 Prefix List"
	// List of IPv4 Prefixes values.
	// The predicate evaluates to true if the client IPv4 Address is covered by one or more of the IPv4 Prefixes from the list.
	IpPrefixList *policy.PrefixMatchList `protobuf:"bytes,15,opt,name=ip_prefix_list,json=ipPrefixList,proto3" json:"ip_prefix_list,omitempty"`
	// dst ip prefix list
	//
	// x-displayName: "Destination IPv4 Prefix List"
	// List of IPv4 Prefixes values.
	// The predicate evaluates to true if the destination address is covered by one or more of the IPv4 Prefixes from the list.
	DstIpPrefixList *policy.PrefixMatchList `protobuf:"bytes,16,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,proto3" json:"dst_ip_prefix_list,omitempty"`
	// TLS JA3 fingerprint matcher
	//
	// x-displayName: "TLS Fingerprint Matcher"
	// TLS JA3 fingerprints to be matched.
	// The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.
	TlsFingerprintMatcher *policy.TlsFingerprintMatcherType `protobuf:"bytes,18,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher,proto3" json:"tls_fingerprint_matcher,omitempty"`
	// asn list
	//
	// x-displayName: "ASN List"
	// List of 4-byte ASN values.
	// The predicate evaluates to true if the origin ASN is present in the ASN list.
	AsnList *policy.AsnMatchList `protobuf:"bytes,19,opt,name=asn_list,json=asnList,proto3" json:"asn_list,omitempty"`
	// api group matcher
	//
	// x-displayName: "API Group Matcher"
	// The list of expected API group names to which the request API belongs. The actual list of API group names for the request API is determined from the api
	// group and api group element configuration objects using the HTTP method and the HTTP path as inputs.
	// The predicate evaluates to true if any of the actual API group names for the request is equal to any of the values in the api group matcher.
	ApiGroupMatcher *policy.StringMatcherType `protobuf:"bytes,20,opt,name=api_group_matcher,json=apiGroupMatcher,proto3" json:"api_group_matcher,omitempty"`
	// client role
	//
	// x-displayName: "Client Role"
	// The expected role(s) of the client invoking the request API. The actual roles for the client are derived from the user and namespace information in the
	// API request.
	// The predicate evaluates to true if any of the client's roles match the value(s) specified in client role.
	ClientRole *policy.RoleMatcherType `protobuf:"bytes,21,opt,name=client_role,json=clientRole,proto3" json:"client_role,omitempty"`
	// client selector
	//
	// x-displayName: "Group of Clients by Label Selector"
	// A label selector that describes the expected set of clients. The labels associated with the client making the API request are used to evaluate the label
	// expressions in the selector. These labels can be derived from the client TLS certificate or from the volterra internal control plane.
	// This is a more flexible and powerful version of the client name matcher predicate that allows a given rule to be applicable to a set of clients based on the
	// client labels rather than being limited to relying on patterns in the client name.
	// The predicate evaluates to true if the expressions in the label selector are true for the client labels.
	ClientSelector *schema.LabelSelectorType `protobuf:"bytes,22,opt,name=client_selector,json=clientSelector,proto3" json:"client_selector,omitempty"`
	// server selector
	//
	// x-displayName: "Group of Servers by Label Selector"
	// A label selector that describes the expected set of servers.
	// The predicate evaluates to true if the expressions in the label selector are true for the server labels.
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,23,opt,name=server_selector,json=serverSelector,proto3" json:"server_selector,omitempty"`
	// label matcher
	//
	// x-displayName: "Label Matcher"
	// x-example: "['environment', 'location', 'deployment']"
	// A list of label keys that identify the label values that need to be the same for the client and server. Note that the actual label values are not specified
	// here, just the label keys. This predicate facilitates reuse of rules and policies across multiple dimensions such as deployment, environment, and location.
	// The predicate evaluates to true if the values of the client and server labels for all the keys specified in the label matcher are equal. The values of any
	// other labels do not matter.
	LabelMatcher *schema.LabelMatcherType `protobuf:"bytes,24,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	// Bot Action
	//
	// x-displayName: "Bot Action"
	// Bot action to be enforced if the input request matches the rule.
	BotAction *policy.BotAction `protobuf:"bytes,25,opt,name=bot_action,json=botAction,proto3" json:"bot_action,omitempty"`
	// Shape Content Rewrite Action
	//
	// x-displayName: "Shape Content Rewrite Action Type"
	// Rewrite HTML response action to insert HTML content such as Javascript <script> tags into the HTML document
	ContentRewriteAction *policy.ContentRewriteAction `protobuf:"bytes,26,opt,name=content_rewrite_action,json=contentRewriteAction,proto3" json:"content_rewrite_action,omitempty"`
	// Shape Protected Endpoint Action
	//
	// x-displayName: "Shape Protected Endpoint Action"
	// Shape Protected Endpoint Action that include application traffic type and mitigation
	ShapeProtectedEndpointAction *policy.ShapeProtectedEndpointAction `protobuf:"bytes,27,opt,name=shape_protected_endpoint_action,json=shapeProtectedEndpointAction,proto3" json:"shape_protected_endpoint_action,omitempty"`
	// rate limiters
	//
	// x-displayName: "Rate Limiters"
	// References to rate_limiter objects.
	// Apply the specified rate_limiters.
	// Mutually exclusive with rate_limiter_specs.
	RateLimiters []*schema.ObjectRefType `protobuf:"bytes,28,rep,name=rate_limiters,json=rateLimiters,proto3" json:"rate_limiters,omitempty"`
	// rate limiter specs
	//
	// x-displayName: "Rate Limiter Specs"
	// Specs for rate_limiter objects.
	// Apply the specified rate_limiters.
	// Mutually exclusive with rate_limiters.
	RateLimiterSpecs []*rate_limiter.GlobalSpecType `protobuf:"bytes,29,rep,name=rate_limiter_specs,json=rateLimiterSpecs,proto3" json:"rate_limiter_specs,omitempty"`
	// Malicious User Mitigation Action
	//
	// x-displayName: "Malicious User Mitigation Action"
	// Specifies how Malicious User Mitigation is handled
	MumAction *policy.ModifyAction `protobuf:"bytes,30,opt,name=mum_action,json=mumAction,proto3" json:"mum_action,omitempty"`
	// IP Reputation Action
	//
	// x-displayName: "IP Reputation Action"
	// Specifies how IP Reputation is handled
	IpReputationAction *policy.ModifyAction `protobuf:"bytes,31,opt,name=ip_reputation_action,json=ipReputationAction,proto3" json:"ip_reputation_action,omitempty"`
	// goto_policy
	//
	// x-displayName: "Goto Policy"
	// A reference to a service_policy object.
	// Target of the GOTO_POLICY action.
	// The target policy must be part of the current policy set and must be after the current policy in the policy set.
	GotoPolicy []*schema.ObjectRefType `protobuf:"bytes,32,rep,name=goto_policy,json=gotoPolicy,proto3" json:"goto_policy,omitempty"`
	// ip matcher
	//
	// x-displayName: "IP Matcher"
	// Match any ip prefix contained in the list of ip_prefix_sets.
	// The result of the match is inverted if invert_matcher is true.
	IpMatcher *policy.IpMatcherType `protobuf:"bytes,33,opt,name=ip_matcher,json=ipMatcher,proto3" json:"ip_matcher,omitempty"`
	// asn matcher
	//
	// x-displayName: "ASN Matcher"
	// Match any AS number contained in the list of bgp_asn_sets. A list of references to bgp_asn_set objects.
	AsnMatcher *policy.AsnMatcherType `protobuf:"bytes,34,opt,name=asn_matcher,json=asnMatcher,proto3" json:"asn_matcher,omitempty"`
}

func (m *SimpleRule) Reset()      { *m = SimpleRule{} }
func (*SimpleRule) ProtoMessage() {}
func (*SimpleRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{0}
}
func (m *SimpleRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SimpleRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleRule.Merge(m, src)
}
func (m *SimpleRule) XXX_Size() int {
	return m.Size()
}
func (m *SimpleRule) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleRule.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleRule proto.InternalMessageInfo

func (m *SimpleRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SimpleRule) GetMetricNameLabel() string {
	if m != nil {
		return m.MetricNameLabel
	}
	return ""
}

func (m *SimpleRule) GetAction() policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return policy.DENY
}

func (m *SimpleRule) GetDomainMatcher() *policy.MatcherType {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *SimpleRule) GetPath() *policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *SimpleRule) GetHeaders() []*policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *SimpleRule) GetHttpMethod() *policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *SimpleRule) GetWafAction() *policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *SimpleRule) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *SimpleRule) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *SimpleRule) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *SimpleRule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SimpleRule) GetUrlMatcher() *policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *SimpleRule) GetL4DestMatcher() *policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *SimpleRule) GetIpPrefixList() *policy.PrefixMatchList {
	if m != nil {
		return m.IpPrefixList
	}
	return nil
}

func (m *SimpleRule) GetDstIpPrefixList() *policy.PrefixMatchList {
	if m != nil {
		return m.DstIpPrefixList
	}
	return nil
}

func (m *SimpleRule) GetTlsFingerprintMatcher() *policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *SimpleRule) GetAsnList() *policy.AsnMatchList {
	if m != nil {
		return m.AsnList
	}
	return nil
}

func (m *SimpleRule) GetApiGroupMatcher() *policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *SimpleRule) GetClientRole() *policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *SimpleRule) GetClientSelector() *schema.LabelSelectorType {
	if m != nil {
		return m.ClientSelector
	}
	return nil
}

func (m *SimpleRule) GetServerSelector() *schema.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *SimpleRule) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *SimpleRule) GetBotAction() *policy.BotAction {
	if m != nil {
		return m.BotAction
	}
	return nil
}

func (m *SimpleRule) GetContentRewriteAction() *policy.ContentRewriteAction {
	if m != nil {
		return m.ContentRewriteAction
	}
	return nil
}

func (m *SimpleRule) GetShapeProtectedEndpointAction() *policy.ShapeProtectedEndpointAction {
	if m != nil {
		return m.ShapeProtectedEndpointAction
	}
	return nil
}

func (m *SimpleRule) GetRateLimiters() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiters
	}
	return nil
}

func (m *SimpleRule) GetRateLimiterSpecs() []*rate_limiter.GlobalSpecType {
	if m != nil {
		return m.RateLimiterSpecs
	}
	return nil
}

func (m *SimpleRule) GetMumAction() *policy.ModifyAction {
	if m != nil {
		return m.MumAction
	}
	return nil
}

func (m *SimpleRule) GetIpReputationAction() *policy.ModifyAction {
	if m != nil {
		return m.IpReputationAction
	}
	return nil
}

func (m *SimpleRule) GetGotoPolicy() []*schema.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

func (m *SimpleRule) GetIpMatcher() *policy.IpMatcherType {
	if m != nil {
		return m.IpMatcher
	}
	return nil
}

func (m *SimpleRule) GetAsnMatcher() *policy.AsnMatcherType {
	if m != nil {
		return m.AsnMatcher
	}
	return nil
}

// source_list
//
// x-displayName: "Source List"
// List of sources. A request belongs to this list if it satifies any of the match criteria.
type SourceList struct {
	// prefix_list
	//
	// x-displayName: "IPv4 Prefix List"
	// Addresses that are covered by the given list of IPv4 prefixes
	PrefixList *views.PrefixStringListType `protobuf:"bytes,2,opt,name=prefix_list,json=prefixList,proto3" json:"prefix_list,omitempty"`
	// ip_prefix_set
	//
	// x-displayName: "IP Prefix Set"
	// Addresses that are covered by the prefixes in the given ip_prefix_set
	IpPrefixSet []*views.ObjectRefType `protobuf:"bytes,3,rep,name=ip_prefix_set,json=ipPrefixSet,proto3" json:"ip_prefix_set,omitempty"`
	// asn_list
	//
	// x-displayName: "BGP ASN List"
	// Addresses that belong to the ASNs in the given list
	// The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.
	AsnList *policy.AsnMatchList `protobuf:"bytes,4,opt,name=asn_list,json=asnList,proto3" json:"asn_list,omitempty"`
	// asn_set
	//
	// x-displayName: "BGP ASN Set"
	// Addresses that belong to the ASNs in the given bgp_asn_set
	// The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.
	AsnSet []*views.ObjectRefType `protobuf:"bytes,5,rep,name=asn_set,json=asnSet,proto3" json:"asn_set,omitempty"`
	// country_list
	//
	// x-displayName: "Country List"
	// Addresses that belong to one of the countries in the given list
	// The country is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.
	CountryList []policy.CountryCode `protobuf:"varint,6,rep,packed,name=country_list,json=countryList,proto3,enum=ves.io.schema.policy.CountryCode" json:"country_list,omitempty"`
	// tls_fingerprint_classes
	//
	// x-displayName: "TLS Fingerprint Classes"
	// A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.
	TlsFingerprintClasses []policy.KnownTlsFingerprintClass `protobuf:"varint,7,rep,packed,name=tls_fingerprint_classes,json=tlsFingerprintClasses,proto3,enum=ves.io.schema.policy.KnownTlsFingerprintClass" json:"tls_fingerprint_classes,omitempty"`
	// tls_fingerprint_classes
	//
	// x-displayName: "TLS Fingerprint Values"
	// x-example: "1aa7bf8b97e540ca5edd75f7b8384bfa"
	// A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.
	TlsFingerprintValues []string `protobuf:"bytes,8,rep,name=tls_fingerprint_values,json=tlsFingerprintValues,proto3" json:"tls_fingerprint_values,omitempty"`
	// Default Action
	//
	// x-displayName: "Default Action"
	// x-required
	// Default action for requests from source that do not belong to this list
	//
	// Types that are valid to be assigned to DefaultActionChoice:
	//	*SourceList_DefaultActionNextPolicy
	//	*SourceList_DefaultActionDeny
	//	*SourceList_DefaultActionAllow
	DefaultActionChoice isSourceList_DefaultActionChoice `protobuf_oneof:"default_action_choice"`
}

func (m *SourceList) Reset()      { *m = SourceList{} }
func (*SourceList) ProtoMessage() {}
func (*SourceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{1}
}
func (m *SourceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SourceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceList.Merge(m, src)
}
func (m *SourceList) XXX_Size() int {
	return m.Size()
}
func (m *SourceList) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceList.DiscardUnknown(m)
}

var xxx_messageInfo_SourceList proto.InternalMessageInfo

type isSourceList_DefaultActionChoice interface {
	isSourceList_DefaultActionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SourceList_DefaultActionNextPolicy struct {
	DefaultActionNextPolicy *schema.Empty `protobuf:"bytes,11,opt,name=default_action_next_policy,json=defaultActionNextPolicy,proto3,oneof" json:"default_action_next_policy,omitempty"`
}
type SourceList_DefaultActionDeny struct {
	DefaultActionDeny *schema.Empty `protobuf:"bytes,12,opt,name=default_action_deny,json=defaultActionDeny,proto3,oneof" json:"default_action_deny,omitempty"`
}
type SourceList_DefaultActionAllow struct {
	DefaultActionAllow *schema.Empty `protobuf:"bytes,13,opt,name=default_action_allow,json=defaultActionAllow,proto3,oneof" json:"default_action_allow,omitempty"`
}

func (*SourceList_DefaultActionNextPolicy) isSourceList_DefaultActionChoice() {}
func (*SourceList_DefaultActionDeny) isSourceList_DefaultActionChoice()       {}
func (*SourceList_DefaultActionAllow) isSourceList_DefaultActionChoice()      {}

func (m *SourceList) GetDefaultActionChoice() isSourceList_DefaultActionChoice {
	if m != nil {
		return m.DefaultActionChoice
	}
	return nil
}

func (m *SourceList) GetPrefixList() *views.PrefixStringListType {
	if m != nil {
		return m.PrefixList
	}
	return nil
}

func (m *SourceList) GetIpPrefixSet() []*views.ObjectRefType {
	if m != nil {
		return m.IpPrefixSet
	}
	return nil
}

func (m *SourceList) GetAsnList() *policy.AsnMatchList {
	if m != nil {
		return m.AsnList
	}
	return nil
}

func (m *SourceList) GetAsnSet() []*views.ObjectRefType {
	if m != nil {
		return m.AsnSet
	}
	return nil
}

func (m *SourceList) GetCountryList() []policy.CountryCode {
	if m != nil {
		return m.CountryList
	}
	return nil
}

func (m *SourceList) GetTlsFingerprintClasses() []policy.KnownTlsFingerprintClass {
	if m != nil {
		return m.TlsFingerprintClasses
	}
	return nil
}

func (m *SourceList) GetTlsFingerprintValues() []string {
	if m != nil {
		return m.TlsFingerprintValues
	}
	return nil
}

func (m *SourceList) GetDefaultActionNextPolicy() *schema.Empty {
	if x, ok := m.GetDefaultActionChoice().(*SourceList_DefaultActionNextPolicy); ok {
		return x.DefaultActionNextPolicy
	}
	return nil
}

func (m *SourceList) GetDefaultActionDeny() *schema.Empty {
	if x, ok := m.GetDefaultActionChoice().(*SourceList_DefaultActionDeny); ok {
		return x.DefaultActionDeny
	}
	return nil
}

func (m *SourceList) GetDefaultActionAllow() *schema.Empty {
	if x, ok := m.GetDefaultActionChoice().(*SourceList_DefaultActionAllow); ok {
		return x.DefaultActionAllow
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SourceList) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SourceList_DefaultActionNextPolicy)(nil),
		(*SourceList_DefaultActionDeny)(nil),
		(*SourceList_DefaultActionAllow)(nil),
	}
}

// rule
//
// x-displayName: "Rule"
// A Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from
// or derived from an L7 request API. A request API is considered to match the simple rule if all predicates in the rule evaluate to true for that request. Any
// predicates that are not specified in a rule are implicitly considered to be true. If a request API matches a simple rule, the action for the simple rule is
// enforced.
type Rule struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// spec
	//
	// x-displayName: "Rule Specification"
	// x-required
	// Specification for the rule including match predicates and actions.
	Spec *service_policy_rule.GlobalSpecType `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *Rule) Reset()      { *m = Rule{} }
func (*Rule) ProtoMessage() {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{2}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

func (m *Rule) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Rule) GetSpec() *service_policy_rule.GlobalSpecType {
	if m != nil {
		return m.Spec
	}
	return nil
}

// rule list
//
// x-displayName: "Rule List"
// A list of rules.
// The order of evaluation of the rules depends on the rule combining algorithm.
type RuleList struct {
	// rules
	//
	// x-displayName: "Rules"
	// Define the list of rules (with an order) that should be evaluated by this service policy.
	// Rules are evaluated from top to bottom in the list.
	Rules []*Rule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *RuleList) Reset()      { *m = RuleList{} }
func (*RuleList) ProtoMessage() {}
func (*RuleList) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{3}
}
func (m *RuleList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RuleList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleList.Merge(m, src)
}
func (m *RuleList) XXX_Size() int {
	return m.Size()
}
func (m *RuleList) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleList.DiscardUnknown(m)
}

var xxx_messageInfo_RuleList proto.InternalMessageInfo

func (m *RuleList) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// LegacyRuleList
//
// x-displayName: "Legacy Rules"
// A list of references to service_policy_rule objects.
// The order of evaluation of the rules depends on the rule combining algorithm.
type LegacyRuleList struct {
	// rules
	//
	// x-displayName: "Rules"
	// A list of references to service_policy_rule objects.
	// The order of evaluation of the rules depends on the rule combining algorithm.
	Rules []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *LegacyRuleList) Reset()      { *m = LegacyRuleList{} }
func (*LegacyRuleList) ProtoMessage() {}
func (*LegacyRuleList) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{4}
}
func (m *LegacyRuleList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LegacyRuleList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LegacyRuleList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LegacyRuleList.Merge(m, src)
}
func (m *LegacyRuleList) XXX_Size() int {
	return m.Size()
}
func (m *LegacyRuleList) XXX_DiscardUnknown() {
	xxx_messageInfo_LegacyRuleList.DiscardUnknown(m)
}

var xxx_messageInfo_LegacyRuleList proto.InternalMessageInfo

func (m *LegacyRuleList) GetRules() []*schema.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Specification"
// Shape of service_policy in the storage backend.
type GlobalSpecType struct {
	// algo
	//
	// x-displayName: "Rule Combining Algorithm"
	// x-required
	// The rule combining algorithm determines how the list of rules in the policy is evaluated.
	//
	// - FIRST_MATCH Rules are evaluated sequentially till a matching rule is identified
	// - ALLOW_OVERRIDES Rules with an ALLOW action are evaluated prior to rules with a DENY action
	// - DENY_OVERRIDES Rules with a DENY action are evaluated prior to rules with an ALLOW action
	Algo policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// server choice
	//
	// x-displayName: "Server Selection"
	// x-required
	// Select servers for which the policy the will be applied.
	//
	// Types that are valid to be assigned to ServerChoice:
	//	*GlobalSpecType_AnyServer
	//	*GlobalSpecType_ServerName
	//	*GlobalSpecType_ServerSelector
	//	*GlobalSpecType_ServerNameMatcher
	ServerChoice isGlobalSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	// port matcher
	//
	// x-displayName: "Port Matcher"
	// The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.
	PortMatcher *policy.PortMatcherType `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	// role
	//
	// x-displayName: "Role"
	// The expected role of the client invoking the request API. The actual roles for the client are derived from the user and namespace information in the API
	// request.
	// The predicate evaluates to true if any of the client's roles match the value specified in role.
	Role *policy.RoleMatcherType `protobuf:"bytes,7,opt,name=role,proto3" json:"role,omitempty"`
	// deny_info
	//
	// x-displayName: "Deny Information"
	// Detailed information including HTTP response code and error message to be sent when the policy action is DENY.
	DenyInfo *policy.DenyInformation `protobuf:"bytes,8,opt,name=deny_info,json=denyInfo,proto3" json:"deny_info,omitempty"`
	// Default Forwarding Classes
	//
	// x-displayName: "Default Forwarding Classes"
	// Ordered list of forwarding class to use for traffic that match the enclosing rule
	// Action valid only when the policy is used PBR
	DefaultForwardingClasses []*schema.ObjectRefType `protobuf:"bytes,9,rep,name=default_forwarding_classes,json=defaultForwardingClasses,proto3" json:"default_forwarding_classes,omitempty"`
	// rules
	//
	// x-displayName: "Rules"
	// A list of references to service_policy_rule objects.
	// The order of evaluation of the rules depends on the rule combining algorithm.
	// TBD mark as hidden + internal after implementation is ready
	Rules []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=rules,proto3" json:"rules,omitempty"`
	// rule choice
	//
	// x-displayName: "Select Policy Rules"
	// x-required
	// Allowed/Denied Sources rules provide the ability to allow/deny lists of IP addresses, countries, TLS fingerprints and ASNs.
	// Custom rules provide more flexibility to define your own logic to control incoming requests.
	//
	// Types that are valid to be assigned to RuleChoice:
	//	*GlobalSpecType_AllowList
	//	*GlobalSpecType_DenyList
	//	*GlobalSpecType_RuleList
	//	*GlobalSpecType_LegacyRuleList
	//	*GlobalSpecType_AllowAllRequests
	//	*GlobalSpecType_DenyAllRequests
	//	*GlobalSpecType_InternallyGenerated
	RuleChoice isGlobalSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal,proto3" json:"view_internal,omitempty"`
	// simple_rules
	//
	// x-displayName: "Simple Rules"
	// A list of SimpleRules.
	// The order of evaluation of the simple rules depends on the rule combining algorithm.
	// This is mutually exclusive with the rules field and is for internal use only.
	SimpleRules []*SimpleRule `protobuf:"bytes,1001,rep,name=simple_rules,json=simpleRules,proto3" json:"simple_rules,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{5}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_ServerChoice interface {
	isGlobalSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_RuleChoice interface {
	isGlobalSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type GlobalSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type GlobalSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}
type GlobalSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type GlobalSpecType_AllowList struct {
	AllowList *SourceList `protobuf:"bytes,21,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type GlobalSpecType_DenyList struct {
	DenyList *SourceList `protobuf:"bytes,22,opt,name=deny_list,json=denyList,proto3,oneof" json:"deny_list,omitempty"`
}
type GlobalSpecType_RuleList struct {
	RuleList *RuleList `protobuf:"bytes,23,opt,name=rule_list,json=ruleList,proto3,oneof" json:"rule_list,omitempty"`
}
type GlobalSpecType_LegacyRuleList struct {
	LegacyRuleList *LegacyRuleList `protobuf:"bytes,24,opt,name=legacy_rule_list,json=legacyRuleList,proto3,oneof" json:"legacy_rule_list,omitempty"`
}
type GlobalSpecType_AllowAllRequests struct {
	AllowAllRequests *schema.Empty `protobuf:"bytes,26,opt,name=allow_all_requests,json=allowAllRequests,proto3,oneof" json:"allow_all_requests,omitempty"`
}
type GlobalSpecType_DenyAllRequests struct {
	DenyAllRequests *schema.Empty `protobuf:"bytes,27,opt,name=deny_all_requests,json=denyAllRequests,proto3,oneof" json:"deny_all_requests,omitempty"`
}
type GlobalSpecType_InternallyGenerated struct {
	InternallyGenerated *schema.Empty `protobuf:"bytes,25,opt,name=internally_generated,json=internallyGenerated,proto3,oneof" json:"internally_generated,omitempty"`
}

func (*GlobalSpecType_AnyServer) isGlobalSpecType_ServerChoice()         {}
func (*GlobalSpecType_ServerName) isGlobalSpecType_ServerChoice()        {}
func (*GlobalSpecType_ServerSelector) isGlobalSpecType_ServerChoice()    {}
func (*GlobalSpecType_ServerNameMatcher) isGlobalSpecType_ServerChoice() {}
func (*GlobalSpecType_AllowList) isGlobalSpecType_RuleChoice()           {}
func (*GlobalSpecType_DenyList) isGlobalSpecType_RuleChoice()            {}
func (*GlobalSpecType_RuleList) isGlobalSpecType_RuleChoice()            {}
func (*GlobalSpecType_LegacyRuleList) isGlobalSpecType_RuleChoice()      {}
func (*GlobalSpecType_AllowAllRequests) isGlobalSpecType_RuleChoice()    {}
func (*GlobalSpecType_DenyAllRequests) isGlobalSpecType_RuleChoice()     {}
func (*GlobalSpecType_InternallyGenerated) isGlobalSpecType_RuleChoice() {}

func (m *GlobalSpecType) GetServerChoice() isGlobalSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}
func (m *GlobalSpecType) GetRuleChoice() isGlobalSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *GlobalSpecType) GetAlgo() policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return policy.FIRST_MATCH
}

func (m *GlobalSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *GlobalSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GlobalSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *GlobalSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetRole() *policy.RoleMatcherType {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *GlobalSpecType) GetDenyInfo() *policy.DenyInformation {
	if m != nil {
		return m.DenyInfo
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultForwardingClasses() []*schema.ObjectRefType {
	if m != nil {
		return m.DefaultForwardingClasses
	}
	return nil
}

func (m *GlobalSpecType) GetRules() []*schema.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *GlobalSpecType) GetAllowList() *SourceList {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *GlobalSpecType) GetDenyList() *SourceList {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_DenyList); ok {
		return x.DenyList
	}
	return nil
}

func (m *GlobalSpecType) GetRuleList() *RuleList {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_RuleList); ok {
		return x.RuleList
	}
	return nil
}

func (m *GlobalSpecType) GetLegacyRuleList() *LegacyRuleList {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_LegacyRuleList); ok {
		return x.LegacyRuleList
	}
	return nil
}

func (m *GlobalSpecType) GetAllowAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_AllowAllRequests); ok {
		return x.AllowAllRequests
	}
	return nil
}

func (m *GlobalSpecType) GetDenyAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_DenyAllRequests); ok {
		return x.DenyAllRequests
	}
	return nil
}

func (m *GlobalSpecType) GetInternallyGenerated() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_InternallyGenerated); ok {
		return x.InternallyGenerated
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

func (m *GlobalSpecType) GetSimpleRules() []*SimpleRule {
	if m != nil {
		return m.SimpleRules
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_AnyServer)(nil),
		(*GlobalSpecType_ServerName)(nil),
		(*GlobalSpecType_ServerSelector)(nil),
		(*GlobalSpecType_ServerNameMatcher)(nil),
		(*GlobalSpecType_AllowList)(nil),
		(*GlobalSpecType_DenyList)(nil),
		(*GlobalSpecType_RuleList)(nil),
		(*GlobalSpecType_LegacyRuleList)(nil),
		(*GlobalSpecType_AllowAllRequests)(nil),
		(*GlobalSpecType_DenyAllRequests)(nil),
		(*GlobalSpecType_InternallyGenerated)(nil),
	}
}

// Create service policy
//
// x-displayName: "Create Service Policy"
// Create service_policy creates a new object in the storage backend for metadata.namespace.
type CreateSpecType struct {
	Algo policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// Types that are valid to be assigned to ServerChoice:
	//	*CreateSpecType_AnyServer
	//	*CreateSpecType_ServerName
	//	*CreateSpecType_ServerSelector
	//	*CreateSpecType_ServerNameMatcher
	ServerChoice isCreateSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	PortMatcher  *policy.PortMatcherType       `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	// Types that are valid to be assigned to RuleChoice:
	//	*CreateSpecType_AllowList
	//	*CreateSpecType_DenyList
	//	*CreateSpecType_RuleList
	//	*CreateSpecType_LegacyRuleList
	//	*CreateSpecType_AllowAllRequests
	//	*CreateSpecType_DenyAllRequests
	//	*CreateSpecType_InternallyGenerated
	RuleChoice isCreateSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{6}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_ServerChoice interface {
	isCreateSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_RuleChoice interface {
	isCreateSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type CreateSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type CreateSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}
type CreateSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type CreateSpecType_AllowList struct {
	AllowList *SourceList `protobuf:"bytes,21,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type CreateSpecType_DenyList struct {
	DenyList *SourceList `protobuf:"bytes,22,opt,name=deny_list,json=denyList,proto3,oneof" json:"deny_list,omitempty"`
}
type CreateSpecType_RuleList struct {
	RuleList *RuleList `protobuf:"bytes,23,opt,name=rule_list,json=ruleList,proto3,oneof" json:"rule_list,omitempty"`
}
type CreateSpecType_LegacyRuleList struct {
	LegacyRuleList *LegacyRuleList `protobuf:"bytes,24,opt,name=legacy_rule_list,json=legacyRuleList,proto3,oneof" json:"legacy_rule_list,omitempty"`
}
type CreateSpecType_AllowAllRequests struct {
	AllowAllRequests *schema.Empty `protobuf:"bytes,26,opt,name=allow_all_requests,json=allowAllRequests,proto3,oneof" json:"allow_all_requests,omitempty"`
}
type CreateSpecType_DenyAllRequests struct {
	DenyAllRequests *schema.Empty `protobuf:"bytes,27,opt,name=deny_all_requests,json=denyAllRequests,proto3,oneof" json:"deny_all_requests,omitempty"`
}
type CreateSpecType_InternallyGenerated struct {
	InternallyGenerated *schema.Empty `protobuf:"bytes,25,opt,name=internally_generated,json=internallyGenerated,proto3,oneof" json:"internally_generated,omitempty"`
}

func (*CreateSpecType_AnyServer) isCreateSpecType_ServerChoice()         {}
func (*CreateSpecType_ServerName) isCreateSpecType_ServerChoice()        {}
func (*CreateSpecType_ServerSelector) isCreateSpecType_ServerChoice()    {}
func (*CreateSpecType_ServerNameMatcher) isCreateSpecType_ServerChoice() {}
func (*CreateSpecType_AllowList) isCreateSpecType_RuleChoice()           {}
func (*CreateSpecType_DenyList) isCreateSpecType_RuleChoice()            {}
func (*CreateSpecType_RuleList) isCreateSpecType_RuleChoice()            {}
func (*CreateSpecType_LegacyRuleList) isCreateSpecType_RuleChoice()      {}
func (*CreateSpecType_AllowAllRequests) isCreateSpecType_RuleChoice()    {}
func (*CreateSpecType_DenyAllRequests) isCreateSpecType_RuleChoice()     {}
func (*CreateSpecType_InternallyGenerated) isCreateSpecType_RuleChoice() {}

func (m *CreateSpecType) GetServerChoice() isCreateSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}
func (m *CreateSpecType) GetRuleChoice() isCreateSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *CreateSpecType) GetAlgo() policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return policy.FIRST_MATCH
}

func (m *CreateSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*CreateSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *CreateSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *CreateSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *CreateSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *CreateSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAllowList() *SourceList {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *CreateSpecType) GetDenyList() *SourceList {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_DenyList); ok {
		return x.DenyList
	}
	return nil
}

func (m *CreateSpecType) GetRuleList() *RuleList {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_RuleList); ok {
		return x.RuleList
	}
	return nil
}

func (m *CreateSpecType) GetLegacyRuleList() *LegacyRuleList {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_LegacyRuleList); ok {
		return x.LegacyRuleList
	}
	return nil
}

func (m *CreateSpecType) GetAllowAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_AllowAllRequests); ok {
		return x.AllowAllRequests
	}
	return nil
}

func (m *CreateSpecType) GetDenyAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_DenyAllRequests); ok {
		return x.DenyAllRequests
	}
	return nil
}

func (m *CreateSpecType) GetInternallyGenerated() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*CreateSpecType_InternallyGenerated); ok {
		return x.InternallyGenerated
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_AnyServer)(nil),
		(*CreateSpecType_ServerName)(nil),
		(*CreateSpecType_ServerSelector)(nil),
		(*CreateSpecType_ServerNameMatcher)(nil),
		(*CreateSpecType_AllowList)(nil),
		(*CreateSpecType_DenyList)(nil),
		(*CreateSpecType_RuleList)(nil),
		(*CreateSpecType_LegacyRuleList)(nil),
		(*CreateSpecType_AllowAllRequests)(nil),
		(*CreateSpecType_DenyAllRequests)(nil),
		(*CreateSpecType_InternallyGenerated)(nil),
	}
}

// Replace service policy
//
// x-displayName: "Replace Service Policy"
// Replace service_policy replaces an existing object in the storage backend for metadata.namespace.
type ReplaceSpecType struct {
	Algo policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// Types that are valid to be assigned to ServerChoice:
	//	*ReplaceSpecType_AnyServer
	//	*ReplaceSpecType_ServerName
	//	*ReplaceSpecType_ServerSelector
	//	*ReplaceSpecType_ServerNameMatcher
	ServerChoice isReplaceSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	PortMatcher  *policy.PortMatcherType        `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	// Types that are valid to be assigned to RuleChoice:
	//	*ReplaceSpecType_AllowList
	//	*ReplaceSpecType_DenyList
	//	*ReplaceSpecType_RuleList
	//	*ReplaceSpecType_LegacyRuleList
	//	*ReplaceSpecType_AllowAllRequests
	//	*ReplaceSpecType_DenyAllRequests
	//	*ReplaceSpecType_InternallyGenerated
	RuleChoice isReplaceSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{7}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_ServerChoice interface {
	isReplaceSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_RuleChoice interface {
	isReplaceSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type ReplaceSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type ReplaceSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}
type ReplaceSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type ReplaceSpecType_AllowList struct {
	AllowList *SourceList `protobuf:"bytes,21,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type ReplaceSpecType_DenyList struct {
	DenyList *SourceList `protobuf:"bytes,22,opt,name=deny_list,json=denyList,proto3,oneof" json:"deny_list,omitempty"`
}
type ReplaceSpecType_RuleList struct {
	RuleList *RuleList `protobuf:"bytes,23,opt,name=rule_list,json=ruleList,proto3,oneof" json:"rule_list,omitempty"`
}
type ReplaceSpecType_LegacyRuleList struct {
	LegacyRuleList *LegacyRuleList `protobuf:"bytes,24,opt,name=legacy_rule_list,json=legacyRuleList,proto3,oneof" json:"legacy_rule_list,omitempty"`
}
type ReplaceSpecType_AllowAllRequests struct {
	AllowAllRequests *schema.Empty `protobuf:"bytes,26,opt,name=allow_all_requests,json=allowAllRequests,proto3,oneof" json:"allow_all_requests,omitempty"`
}
type ReplaceSpecType_DenyAllRequests struct {
	DenyAllRequests *schema.Empty `protobuf:"bytes,27,opt,name=deny_all_requests,json=denyAllRequests,proto3,oneof" json:"deny_all_requests,omitempty"`
}
type ReplaceSpecType_InternallyGenerated struct {
	InternallyGenerated *schema.Empty `protobuf:"bytes,25,opt,name=internally_generated,json=internallyGenerated,proto3,oneof" json:"internally_generated,omitempty"`
}

func (*ReplaceSpecType_AnyServer) isReplaceSpecType_ServerChoice()         {}
func (*ReplaceSpecType_ServerName) isReplaceSpecType_ServerChoice()        {}
func (*ReplaceSpecType_ServerSelector) isReplaceSpecType_ServerChoice()    {}
func (*ReplaceSpecType_ServerNameMatcher) isReplaceSpecType_ServerChoice() {}
func (*ReplaceSpecType_AllowList) isReplaceSpecType_RuleChoice()           {}
func (*ReplaceSpecType_DenyList) isReplaceSpecType_RuleChoice()            {}
func (*ReplaceSpecType_RuleList) isReplaceSpecType_RuleChoice()            {}
func (*ReplaceSpecType_LegacyRuleList) isReplaceSpecType_RuleChoice()      {}
func (*ReplaceSpecType_AllowAllRequests) isReplaceSpecType_RuleChoice()    {}
func (*ReplaceSpecType_DenyAllRequests) isReplaceSpecType_RuleChoice()     {}
func (*ReplaceSpecType_InternallyGenerated) isReplaceSpecType_RuleChoice() {}

func (m *ReplaceSpecType) GetServerChoice() isReplaceSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetRuleChoice() isReplaceSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetAlgo() policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return policy.FIRST_MATCH
}

func (m *ReplaceSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *ReplaceSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *ReplaceSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAllowList() *SourceList {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *ReplaceSpecType) GetDenyList() *SourceList {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_DenyList); ok {
		return x.DenyList
	}
	return nil
}

func (m *ReplaceSpecType) GetRuleList() *RuleList {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_RuleList); ok {
		return x.RuleList
	}
	return nil
}

func (m *ReplaceSpecType) GetLegacyRuleList() *LegacyRuleList {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_LegacyRuleList); ok {
		return x.LegacyRuleList
	}
	return nil
}

func (m *ReplaceSpecType) GetAllowAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_AllowAllRequests); ok {
		return x.AllowAllRequests
	}
	return nil
}

func (m *ReplaceSpecType) GetDenyAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_DenyAllRequests); ok {
		return x.DenyAllRequests
	}
	return nil
}

func (m *ReplaceSpecType) GetInternallyGenerated() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_InternallyGenerated); ok {
		return x.InternallyGenerated
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_AnyServer)(nil),
		(*ReplaceSpecType_ServerName)(nil),
		(*ReplaceSpecType_ServerSelector)(nil),
		(*ReplaceSpecType_ServerNameMatcher)(nil),
		(*ReplaceSpecType_AllowList)(nil),
		(*ReplaceSpecType_DenyList)(nil),
		(*ReplaceSpecType_RuleList)(nil),
		(*ReplaceSpecType_LegacyRuleList)(nil),
		(*ReplaceSpecType_AllowAllRequests)(nil),
		(*ReplaceSpecType_DenyAllRequests)(nil),
		(*ReplaceSpecType_InternallyGenerated)(nil),
	}
}

// Get service policy
//
// x-displayName: "Get Service Policy"
// Get service_policy reads a given object from storage backend for metadata.namespace.
type GetSpecType struct {
	Algo policy.RuleCombiningAlgorithm `protobuf:"varint,1,opt,name=algo,proto3,enum=ves.io.schema.policy.RuleCombiningAlgorithm" json:"algo,omitempty"`
	// Types that are valid to be assigned to ServerChoice:
	//	*GetSpecType_AnyServer
	//	*GetSpecType_ServerName
	//	*GetSpecType_ServerSelector
	//	*GetSpecType_ServerNameMatcher
	ServerChoice isGetSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	PortMatcher  *policy.PortMatcherType    `protobuf:"bytes,6,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	Rules        []*schema.ObjectRefType    `protobuf:"bytes,4,rep,name=rules,proto3" json:"rules,omitempty"`
	// Types that are valid to be assigned to RuleChoice:
	//	*GetSpecType_AllowList
	//	*GetSpecType_DenyList
	//	*GetSpecType_RuleList
	//	*GetSpecType_LegacyRuleList
	//	*GetSpecType_AllowAllRequests
	//	*GetSpecType_DenyAllRequests
	//	*GetSpecType_InternallyGenerated
	RuleChoice  isGetSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
	SimpleRules []*SimpleRule            `protobuf:"bytes,1001,rep,name=simple_rules,json=simpleRules,proto3" json:"simple_rules,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_27dbd931e83f25b2, []int{8}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_ServerChoice interface {
	isGetSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_RuleChoice interface {
	isGetSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,11,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type GetSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type GetSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}
type GetSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,5,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type GetSpecType_AllowList struct {
	AllowList *SourceList `protobuf:"bytes,21,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type GetSpecType_DenyList struct {
	DenyList *SourceList `protobuf:"bytes,22,opt,name=deny_list,json=denyList,proto3,oneof" json:"deny_list,omitempty"`
}
type GetSpecType_RuleList struct {
	RuleList *RuleList `protobuf:"bytes,23,opt,name=rule_list,json=ruleList,proto3,oneof" json:"rule_list,omitempty"`
}
type GetSpecType_LegacyRuleList struct {
	LegacyRuleList *LegacyRuleList `protobuf:"bytes,24,opt,name=legacy_rule_list,json=legacyRuleList,proto3,oneof" json:"legacy_rule_list,omitempty"`
}
type GetSpecType_AllowAllRequests struct {
	AllowAllRequests *schema.Empty `protobuf:"bytes,26,opt,name=allow_all_requests,json=allowAllRequests,proto3,oneof" json:"allow_all_requests,omitempty"`
}
type GetSpecType_DenyAllRequests struct {
	DenyAllRequests *schema.Empty `protobuf:"bytes,27,opt,name=deny_all_requests,json=denyAllRequests,proto3,oneof" json:"deny_all_requests,omitempty"`
}
type GetSpecType_InternallyGenerated struct {
	InternallyGenerated *schema.Empty `protobuf:"bytes,25,opt,name=internally_generated,json=internallyGenerated,proto3,oneof" json:"internally_generated,omitempty"`
}

func (*GetSpecType_AnyServer) isGetSpecType_ServerChoice()         {}
func (*GetSpecType_ServerName) isGetSpecType_ServerChoice()        {}
func (*GetSpecType_ServerSelector) isGetSpecType_ServerChoice()    {}
func (*GetSpecType_ServerNameMatcher) isGetSpecType_ServerChoice() {}
func (*GetSpecType_AllowList) isGetSpecType_RuleChoice()           {}
func (*GetSpecType_DenyList) isGetSpecType_RuleChoice()            {}
func (*GetSpecType_RuleList) isGetSpecType_RuleChoice()            {}
func (*GetSpecType_LegacyRuleList) isGetSpecType_RuleChoice()      {}
func (*GetSpecType_AllowAllRequests) isGetSpecType_RuleChoice()    {}
func (*GetSpecType_DenyAllRequests) isGetSpecType_RuleChoice()     {}
func (*GetSpecType_InternallyGenerated) isGetSpecType_RuleChoice() {}

func (m *GetSpecType) GetServerChoice() isGetSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}
func (m *GetSpecType) GetRuleChoice() isGetSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *GetSpecType) GetAlgo() policy.RuleCombiningAlgorithm {
	if m != nil {
		return m.Algo
	}
	return policy.FIRST_MATCH
}

func (m *GetSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*GetSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *GetSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GetSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *GetSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *GetSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GetSpecType) GetRules() []*schema.ObjectRefType {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *GetSpecType) GetAllowList() *SourceList {
	if x, ok := m.GetRuleChoice().(*GetSpecType_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *GetSpecType) GetDenyList() *SourceList {
	if x, ok := m.GetRuleChoice().(*GetSpecType_DenyList); ok {
		return x.DenyList
	}
	return nil
}

func (m *GetSpecType) GetRuleList() *RuleList {
	if x, ok := m.GetRuleChoice().(*GetSpecType_RuleList); ok {
		return x.RuleList
	}
	return nil
}

func (m *GetSpecType) GetLegacyRuleList() *LegacyRuleList {
	if x, ok := m.GetRuleChoice().(*GetSpecType_LegacyRuleList); ok {
		return x.LegacyRuleList
	}
	return nil
}

func (m *GetSpecType) GetAllowAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GetSpecType_AllowAllRequests); ok {
		return x.AllowAllRequests
	}
	return nil
}

func (m *GetSpecType) GetDenyAllRequests() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GetSpecType_DenyAllRequests); ok {
		return x.DenyAllRequests
	}
	return nil
}

func (m *GetSpecType) GetInternallyGenerated() *schema.Empty {
	if x, ok := m.GetRuleChoice().(*GetSpecType_InternallyGenerated); ok {
		return x.InternallyGenerated
	}
	return nil
}

func (m *GetSpecType) GetSimpleRules() []*SimpleRule {
	if m != nil {
		return m.SimpleRules
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_AnyServer)(nil),
		(*GetSpecType_ServerName)(nil),
		(*GetSpecType_ServerSelector)(nil),
		(*GetSpecType_ServerNameMatcher)(nil),
		(*GetSpecType_AllowList)(nil),
		(*GetSpecType_DenyList)(nil),
		(*GetSpecType_RuleList)(nil),
		(*GetSpecType_LegacyRuleList)(nil),
		(*GetSpecType_AllowAllRequests)(nil),
		(*GetSpecType_DenyAllRequests)(nil),
		(*GetSpecType_InternallyGenerated)(nil),
	}
}

func init() {
	proto.RegisterType((*SimpleRule)(nil), "ves.io.schema.service_policy.SimpleRule")
	golang_proto.RegisterType((*SimpleRule)(nil), "ves.io.schema.service_policy.SimpleRule")
	proto.RegisterType((*SourceList)(nil), "ves.io.schema.service_policy.SourceList")
	golang_proto.RegisterType((*SourceList)(nil), "ves.io.schema.service_policy.SourceList")
	proto.RegisterType((*Rule)(nil), "ves.io.schema.service_policy.Rule")
	golang_proto.RegisterType((*Rule)(nil), "ves.io.schema.service_policy.Rule")
	proto.RegisterType((*RuleList)(nil), "ves.io.schema.service_policy.RuleList")
	golang_proto.RegisterType((*RuleList)(nil), "ves.io.schema.service_policy.RuleList")
	proto.RegisterType((*LegacyRuleList)(nil), "ves.io.schema.service_policy.LegacyRuleList")
	golang_proto.RegisterType((*LegacyRuleList)(nil), "ves.io.schema.service_policy.LegacyRuleList")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/service_policy/types.proto", fileDescriptor_27dbd931e83f25b2)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/service_policy/types.proto", fileDescriptor_27dbd931e83f25b2)
}

var fileDescriptor_27dbd931e83f25b2 = []byte{
	// 4743 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0xcd, 0x6f, 0x5c, 0xd7,
	0x75, 0xd7, 0xd3, 0x50, 0x22, 0x75, 0x49, 0x49, 0xa3, 0x91, 0x2c, 0x8f, 0x25, 0x87, 0x7e, 0x9e,
	0x38, 0xae, 0xac, 0xd0, 0xd4, 0xfd, 0xfe, 0x30, 0xd0, 0x20, 0x22, 0x2d, 0x5b, 0xb2, 0x25, 0x55,
	0x19, 0x2a, 0xad, 0x9b, 0xa6, 0x19, 0xdf, 0x8f, 0x73, 0xc9, 0x49, 0x86, 0x33, 0x93, 0x99, 0x47,
	0x49, 0x5c, 0x08, 0x35, 0x82, 0xa2, 0x59, 0x74, 0x13, 0x18, 0x2d, 0x50, 0x04, 0xe8, 0xbe, 0x50,
	0xff, 0x83, 0x2a, 0x0b, 0x23, 0x40, 0x81, 0x22, 0xe8, 0x42, 0x4b, 0xa3, 0xab, 0x44, 0xde, 0x24,
	0xe9, 0x26, 0x28, 0xba, 0xca, 0xa6, 0xc5, 0x7b, 0xf3, 0xc1, 0x19, 0x6a, 0xc4, 0xc8, 0x71, 0x12,
	0x64, 0xe1, 0x15, 0xdf, 0x3b, 0xef, 0x9c, 0xdf, 0x39, 0xef, 0xbc, 0x7b, 0x7f, 0xe7, 0xde, 0x7b,
	0x86, 0xe8, 0xc2, 0x1d, 0xe8, 0xaf, 0x36, 0x3b, 0x97, 0xfa, 0x7e, 0x0b, 0xb6, 0xed, 0xa5, 0x3e,
	0xf4, 0xee, 0x34, 0x3d, 0x34, 0xba, 0x9d, 0x56, 0xd3, 0xef, 0x5e, 0xca, 0x76, 0xbb, 0xd0, 0x5f,
	0xed, 0xf6, 0x3a, 0x59, 0xa7, 0xf2, 0xe2, 0x40, 0x73, 0x75, 0xa0, 0xb9, 0x3a, 0xad, 0x79, 0xee,
	0xf5, 0xcd, 0x66, 0xb6, 0xb5, 0xe3, 0x56, 0x7d, 0x67, 0xfb, 0xd2, 0x66, 0x67, 0xb3, 0x73, 0xa9,
	0x30, 0x72, 0x3b, 0xb1, 0xb8, 0x2b, 0x6e, 0x8a, 0xab, 0x01, 0xd8, 0xb9, 0x97, 0x36, 0x3b, 0x9d,
	0xcd, 0x16, 0xec, 0x69, 0x65, 0xcd, 0x6d, 0xe8, 0x67, 0x76, 0xbb, 0x3b, 0x54, 0x38, 0x3f, 0x1d,
	0x57, 0xa7, 0x9b, 0x35, 0x3b, 0xed, 0x61, 0x28, 0xe7, 0xd2, 0xe9, 0x87, 0x4f, 0x06, 0x7b, 0xee,
	0xd5, 0x69, 0x8d, 0x9e, 0xcd, 0xa0, 0xd1, 0x6a, 0x6e, 0x37, 0x33, 0xe8, 0x4d, 0xe9, 0xbd, 0x7e,
	0xd0, 0xeb, 0x37, 0x7a, 0x3b, 0x2d, 0x98, 0x52, 0x7f, 0x61, 0x5a, 0x7d, 0xf2, 0xd1, 0x8b, 0xd3,
	0x8f, 0xee, 0xd8, 0x56, 0x33, 0xd8, 0x0c, 0x66, 0x47, 0x7c, 0xa7, 0x09, 0x77, 0x1b, 0xd3, 0xef,
	0xf4, 0xd2, 0x93, 0x1a, 0xfd, 0x49, 0x07, 0xb5, 0x4f, 0x4e, 0x23, 0xb4, 0xd1, 0xdc, 0xee, 0xb6,
	0xa0, 0xbe, 0xd3, 0x82, 0x4a, 0x05, 0xcd, 0xb5, 0xed, 0x36, 0x54, 0x93, 0x34, 0xb9, 0x70, 0xac,
	0x5e, 0x5c, 0x57, 0x2e, 0xa2, 0x53, 0xdb, 0x90, 0xf5, 0x9a, 0xbe, 0x91, 0xdf, 0x36, 0x5a, 0xd6,
	0x41, 0xab, 0x7a, 0xaa, 0x50, 0x38, 0x39, 0x78, 0x70, 0xd3, 0x6e, 0xc3, 0xf5, 0x5c, 0x5c, 0xd1,
	0xe8, 0xa8, 0xf5, 0x79, 0x00, 0xd5, 0xc3, 0x69, 0x72, 0xe1, 0x04, 0x4d, 0x57, 0xa7, 0xbf, 0xef,
	0x20, 0x05, 0xab, 0xb9, 0xaf, 0xcb, 0x85, 0x5e, 0x7d, 0xa8, 0x5f, 0xb9, 0x8a, 0x4e, 0x84, 0xce,
	0xb6, 0x6d, 0xb6, 0x1b, 0xdb, 0x36, 0xf3, 0x5b, 0xd0, 0xab, 0x96, 0xd2, 0xe4, 0xc2, 0x22, 0x7d,
	0x79, 0x36, 0xc2, 0x8d, 0x81, 0xd2, 0xed, 0xdd, 0x2e, 0xd4, 0x8f, 0x0f, 0x0c, 0x87, 0xa2, 0x8a,
	0x41, 0x73, 0x5d, 0x9b, 0x6d, 0x55, 0xe7, 0x0a, 0xfb, 0x2f, 0xcd, 0xb6, 0xbf, 0x65, 0xb3, 0xad,
	0x49, 0x8c, 0xc2, 0xa4, 0x72, 0x03, 0xcd, 0x6f, 0x81, 0x0d, 0xd0, 0xeb, 0x57, 0x8f, 0xa4, 0xa5,
	0x0b, 0x8b, 0xf4, 0x4f, 0x66, 0x5b, 0x5f, 0x2d, 0x94, 0x26, 0xec, 0xd7, 0xd0, 0xbf, 0xfd, 0xe2,
	0xa3, 0xd2, 0x91, 0x0f, 0x93, 0xc3, 0xe5, 0x72, 0x7d, 0x84, 0x51, 0xb9, 0x8e, 0x16, 0xb7, 0xb2,
	0xac, 0xdb, 0xd8, 0x86, 0x6c, 0xab, 0x13, 0xaa, 0x47, 0x8b, 0x80, 0xbe, 0xfc, 0x14, 0xc8, 0x2c,
	0xeb, 0xde, 0x28, 0xf4, 0x26, 0xc3, 0x42, 0x5b, 0x63, 0x71, 0xe5, 0x2b, 0x08, 0xdd, 0xb5, 0xb1,
	0x31, 0xcc, 0xef, 0x7c, 0x01, 0xf6, 0xd2, 0x6c, 0xb0, 0xbf, 0xb0, 0x71, 0x98, 0xde, 0x63, 0x77,
	0x47, 0x97, 0x95, 0x1b, 0xe8, 0x0c, 0xdc, 0xeb, 0x36, 0x7b, 0x36, 0xbf, 0x6b, 0x8c, 0xa7, 0x46,
	0x75, 0xa1, 0x40, 0x3a, 0xb7, 0x3a, 0x98, 0x3c, 0xab, 0xa3, 0xc9, 0xb3, 0x7a, 0x7b, 0xa4, 0x51,
	0x3f, 0xbd, 0x67, 0x37, 0x16, 0x56, 0xde, 0x47, 0x47, 0x0b, 0xa7, 0x50, 0x5d, 0x4a, 0x4b, 0x17,
	0x8e, 0xad, 0x5d, 0xcd, 0x33, 0x70, 0xe9, 0xc3, 0x64, 0xa5, 0x76, 0xb1, 0x77, 0xa1, 0xfe, 0xea,
	0x5f, 0xd5, 0x2e, 0xdf, 0xfc, 0xcb, 0xda, 0x4a, 0x5a, 0xbb, 0x7a, 0xfb, 0xf6, 0xad, 0xd1, 0xdf,
	0x8d, 0xfc, 0xe2, 0xf6, 0x7a, 0x71, 0x7f, 0xfb, 0xfa, 0x46, 0xed, 0xaf, 0xc7, 0x59, 0x9b, 0x1b,
	0x5d, 0x55, 0x93, 0xfa, 0x10, 0xb7, 0x72, 0x15, 0x2d, 0x75, 0x3b, 0xbd, 0x6c, 0x3c, 0x20, 0xd0,
	0x81, 0x1f, 0xb4, 0xd3, 0xcb, 0x26, 0x33, 0xb7, 0xd8, 0xdd, 0x13, 0x54, 0x56, 0xd0, 0x62, 0x80,
	0xbe, 0xef, 0x35, 0x8b, 0xc9, 0x51, 0x5d, 0xcc, 0x07, 0xef, 0xf0, 0x93, 0xf5, 0x4a, 0xd5, 0x0f,
	0x0e, 0xd7, 0x27, 0x1f, 0x57, 0xae, 0xa0, 0xc5, 0x9d, 0x5e, 0x6b, 0xec, 0xf6, 0x78, 0xe1, 0xf6,
	0x95, 0xd9, 0x6e, 0xbf, 0x5e, 0xbf, 0x3e, 0xf5, 0xbd, 0x76, 0x7a, 0xad, 0x91, 0xd3, 0xf7, 0xd0,
	0xc9, 0x16, 0x6f, 0x04, 0xe8, 0xef, 0xbd, 0xc1, 0x89, 0x02, 0xea, 0x29, 0x83, 0xea, 0x3a, 0x7f,
	0x13, 0xfa, 0x93, 0xef, 0xb0, 0x36, 0xff, 0xf1, 0xfd, 0xe4, 0xe7, 0x0f, 0x93, 0xa4, 0x7e, 0xbc,
	0x35, 0xf9, 0xac, 0xf2, 0x2e, 0x3a, 0xd1, 0xec, 0x36, 0xba, 0x3d, 0x88, 0xcd, 0x7b, 0x8d, 0x56,
	0xb3, 0x9f, 0x55, 0x4f, 0x1e, 0x98, 0x9a, 0x42, 0xb1, 0x30, 0xbe, 0xde, 0xec, 0x67, 0xf5, 0xa5,
	0x66, 0x77, 0x20, 0xca, 0xef, 0x2a, 0x75, 0x54, 0x09, 0xfd, 0xac, 0xb1, 0x0f, 0xb0, 0xfc, 0x69,
	0x00, 0x4f, 0x86, 0x7e, 0x76, 0x6d, 0x12, 0x73, 0x13, 0x3d, 0x9f, 0xb5, 0xfa, 0x8d, 0xd8, 0x6c,
	0x6f, 0x42, 0xaf, 0xdb, 0x6b, 0xb6, 0xf7, 0x52, 0x50, 0x29, 0x80, 0x2f, 0xcd, 0x06, 0xbe, 0xdd,
	0xea, 0xbf, 0xb5, 0x67, 0x33, 0x99, 0xd8, 0xe7, 0xb2, 0x59, 0x8f, 0x2a, 0x7f, 0x8a, 0x16, 0x6c,
	0xbf, 0x3d, 0x08, 0xf9, 0x74, 0x81, 0x5c, 0x9b, 0x8d, 0x7c, 0xb9, 0xdf, 0xde, 0x8b, 0x77, 0xde,
	0xf6, 0xdb, 0x45, 0x9c, 0x1b, 0xe8, 0x94, 0xed, 0x36, 0x1b, 0x9b, 0xbd, 0xce, 0x4e, 0x77, 0x1c,
	0xe1, 0x99, 0x83, 0x3e, 0xd2, 0x46, 0xd6, 0x6b, 0xb6, 0x37, 0x27, 0x23, 0x3b, 0x69, 0xbb, 0xcd,
	0xb7, 0x73, 0x80, 0x51, 0x4c, 0x6f, 0xa1, 0x45, 0xdf, 0x6a, 0x42, 0x3b, 0x6b, 0xf4, 0x3a, 0x2d,
	0xa8, 0x3e, 0x77, 0x50, 0x26, 0xeb, 0x9d, 0x16, 0x4c, 0x8d, 0x9f, 0x81, 0x65, 0x2e, 0xae, 0x5c,
	0x43, 0x27, 0x87, 0x38, 0x7d, 0x68, 0x81, 0xcf, 0x3a, 0xbd, 0xea, 0xd9, 0x02, 0x6b, 0x3f, 0xa9,
	0x16, 0xd4, 0xbb, 0x31, 0xd4, 0x29, 0x60, 0x4e, 0x0c, 0x0c, 0x47, 0xb2, 0x1c, 0x2a, 0x2f, 0x42,
	0xd0, 0xdb, 0x83, 0x7a, 0xfe, 0x59, 0xa1, 0x06, 0x86, 0x63, 0xa8, 0x37, 0xd1, 0xf1, 0xa2, 0x02,
	0x8c, 0xd3, 0x55, 0x9d, 0x49, 0x44, 0x05, 0xd0, 0xe4, 0x9b, 0x2d, 0xb5, 0x26, 0x24, 0x39, 0x97,
	0xb9, 0x4e, 0x36, 0xe2, 0xb2, 0x17, 0x0e, 0xe2, 0xb2, 0xb5, 0x4e, 0x36, 0xe2, 0x32, 0x37, 0xba,
	0xac, 0xbc, 0x8f, 0xce, 0xfa, 0x4e, 0x3b, 0x2b, 0x92, 0x0c, 0x77, 0x7b, 0xcd, 0x0c, 0x46, 0x58,
	0xe7, 0x0a, 0xac, 0x8b, 0xb3, 0xb1, 0xd6, 0x07, 0x36, 0xf5, 0x81, 0xc9, 0x10, 0xf6, 0x8c, 0x9f,
	0x21, 0xad, 0xec, 0xa2, 0x97, 0xfa, 0x5b, 0xb6, 0x0b, 0x8d, 0x9c, 0x0f, 0xc1, 0x67, 0x10, 0x1a,
	0xd0, 0x0e, 0xdd, 0x4e, 0x3e, 0x96, 0x87, 0xae, 0xce, 0x17, 0xae, 0xe8, 0x53, 0x06, 0x4a, 0x6e,
	0x7c, 0x6b, 0x64, 0x7b, 0x65, 0x68, 0x3a, 0x74, 0xf9, 0x62, 0xff, 0x80, 0xa7, 0x95, 0x6f, 0xa2,
	0xe3, 0x93, 0x4b, 0x8b, 0x7e, 0xf5, 0xc5, 0xa2, 0x16, 0xbd, 0xb8, 0xcf, 0xd1, 0x9f, 0xb9, 0x6f,
	0x83, 0xcf, 0xea, 0x10, 0x0b, 0xae, 0x78, 0xe1, 0xc1, 0xfd, 0xa5, 0x49, 0xab, 0x31, 0xb3, 0x1e,
	0xae, 0x17, 0xf2, 0xeb, 0x43, 0xb0, 0x4a, 0x40, 0x95, 0x49, 0xbd, 0x46, 0xbf, 0x0b, 0xbe, 0x5f,
	0xfd, 0x42, 0xe1, 0x62, 0x7f, 0xda, 0x26, 0x15, 0x57, 0xdf, 0x6e, 0x75, 0x9c, 0x6d, 0x6d, 0x74,
	0xc1, 0xef, 0xab, 0x78, 0x87, 0xeb, 0xe5, 0x09, 0x0f, 0xb9, 0x42, 0xbf, 0x72, 0x19, 0xa1, 0xed,
	0x9d, 0xed, 0x51, 0xa6, 0x96, 0x0f, 0x9a, 0x9a, 0x37, 0x3a, 0xa1, 0x19, 0x77, 0x47, 0xdf, 0x78,
	0x7b, 0x67, 0x7b, 0x98, 0x86, 0xdb, 0xe8, 0x4c, 0xb3, 0xdb, 0xe8, 0x41, 0x77, 0x27, 0x1b, 0x94,
	0xac, 0x21, 0xd8, 0x4b, 0xcf, 0x0c, 0x56, 0x69, 0x76, 0xeb, 0x63, 0xf3, 0x21, 0xea, 0x37, 0xd0,
	0xe2, 0x66, 0x27, 0xeb, 0x0c, 0x17, 0x63, 0xd5, 0xf4, 0x19, 0x52, 0x7b, 0xfe, 0xc1, 0xfd, 0x13,
	0xd3, 0x6b, 0xb8, 0xf1, 0xab, 0x27, 0x75, 0x94, 0xa3, 0xdd, 0x2a, 0xa4, 0x95, 0x35, 0x84, 0x9a,
	0x7b, 0x3c, 0xf2, 0x72, 0x11, 0xe7, 0x17, 0x67, 0xc7, 0x79, 0xad, 0x3b, 0x39, 0x39, 0x8e, 0x35,
	0xc7, 0xec, 0x71, 0x05, 0x2d, 0xe6, 0x8c, 0x36, 0x02, 0xa9, 0x1d, 0x54, 0x7c, 0x46, 0xa4, 0x36,
	0x22, 0x0f, 0x3b, 0xbe, 0x7f, 0xe3, 0xe8, 0x4f, 0x1e, 0xe6, 0xe1, 0xbd, 0x33, 0xb7, 0x70, 0xac,
	0x8c, 0x6a, 0x3f, 0x3e, 0x87, 0xd0, 0x46, 0x67, 0xa7, 0xe7, 0xa1, 0xa0, 0xbd, 0x5b, 0x68, 0x71,
	0x92, 0xeb, 0x0f, 0x17, 0x3e, 0x5e, 0xdb, 0xe7, 0xa3, 0x58, 0x2b, 0x0e, 0xa9, 0x7e, 0xc0, 0x7a,
	0xb9, 0x6d, 0x91, 0x90, 0xb9, 0x47, 0x79, 0x51, 0x42, 0xdd, 0x3d, 0xc2, 0x6f, 0xa1, 0xe3, 0x7b,
	0x05, 0xa4, 0x0f, 0x59, 0xb5, 0x54, 0xe4, 0xb5, 0x36, 0x13, 0x73, 0x3a, 0xbb, 0xaf, 0x3c, 0xb8,
	0x3f, 0x6d, 0x3b, 0x4e, 0xee, 0x57, 0x27, 0xd6, 0x04, 0x8b, 0xa3, 0x9a, 0xb5, 0x01, 0x59, 0x65,
	0x7d, 0x82, 0xf5, 0xe7, 0x9e, 0x95, 0xf5, 0x87, 0x51, 0x8f, 0xb9, 0xbf, 0x81, 0xf2, 0xcb, 0x22,
	0xd8, 0x23, 0xcf, 0x1c, 0x6c, 0xed, 0xc1, 0xfd, 0x45, 0xb7, 0xd9, 0x6d, 0x0c, 0x2d, 0x67, 0x86,
	0x7a, 0xd4, 0xf6, 0xdb, 0x79, 0x94, 0x2d, 0xb4, 0xe4, 0x3b, 0x3b, 0xed, 0xac, 0xb7, 0x3b, 0x88,
	0xf4, 0x68, 0x5a, 0xba, 0x70, 0xe2, 0x69, 0xeb, 0xd9, 0xf5, 0x81, 0xe6, 0x7a, 0x27, 0xc0, 0xda,
	0xab, 0x39, 0xd8, 0xf1, 0x0f, 0x13, 0x54, 0x5b, 0xf8, 0x5e, 0x72, 0xa4, 0x9c, 0xd4, 0x92, 0x43,
	0xb3, 0x73, 0x32, 0x84, 0x2f, 0x5e, 0xe7, 0x83, 0xe4, 0xc9, 0x9a, 0xeb, 0x5b, 0xb6, 0xdf, 0x87,
	0x7e, 0x75, 0xbe, 0xf0, 0xbc, 0x3a, 0xdb, 0xf3, 0xbb, 0xed, 0xce, 0xdd, 0xf6, 0x74, 0xe1, 0x5d,
	0xcf, 0xed, 0xd6, 0xaa, 0x1f, 0x3d, 0x4c, 0x92, 0xbd, 0x65, 0xed, 0x84, 0xe3, 0x7d, 0xc5, 0x78,
	0x7d, 0xe0, 0xa6, 0xf2, 0xaf, 0xa7, 0xd1, 0xd9, 0xfd, 0x21, 0xdc, 0xb1, 0xad, 0x1d, 0xe8, 0x57,
	0x17, 0x8a, 0x25, 0xe2, 0xff, 0x56, 0x1e, 0x3f, 0x4c, 0xfe, 0xb3, 0x82, 0x52, 0x62, 0xad, 0x72,
	0x51, 0x3b, 0xa3, 0x40, 0x70, 0xec, 0xad, 0x80, 0x10, 0x94, 0x88, 0xca, 0x69, 0xa6, 0xb9, 0x8b,
	0x16, 0xa5, 0xcc, 0x07, 0x2b, 0x68, 0xb0, 0xdc, 0x06, 0xc0, 0x26, 0x92, 0xa8, 0x34, 0xb1, 0x81,
	0x82, 0xa6, 0xc1, 0x47, 0x4b, 0x31, 0x4a, 0x55, 0x08, 0x02, 0x03, 0x21, 0xd4, 0x07, 0xca, 0x14,
	0xe3, 0x96, 0x11, 0xec, 0x0c, 0x8e, 0x32, 0x72, 0x6e, 0x95, 0x0f, 0x28, 0x25, 0x0e, 0x18, 0x78,
	0x70, 0x20, 0xac, 0x35, 0x81, 0x49, 0xc1, 0x41, 0x82, 0xc2, 0x2c, 0x68, 0x12, 0xa5, 0xa1, 0x1a,
	0xa5, 0x5e, 0x50, 0x26, 0x02, 0xb3, 0xda, 0x19, 0xc3, 0xb8, 0x53, 0xd1, 0xb9, 0x40, 0x31, 0x0f,
	0x02, 0x3b, 0x8f, 0x85, 0x0e, 0x28, 0x05, 0x49, 0xad, 0x88, 0x3c, 0x08, 0xa6, 0xbd, 0x8b, 0x44,
	0x1a, 0x4f, 0x6d, 0x54, 0xc4, 0x81, 0xa7, 0xcc, 0x18, 0xc7, 0x51, 0x1a, 0xa8, 0x61, 0xc2, 0x0b,
	0x1d, 0x41, 0x2a, 0xa9, 0x38, 0x8f, 0xe0, 0xbd, 0x96, 0x84, 0x03, 0x08, 0x26, 0xa4, 0x57, 0x28,
	0x0d, 0xe0, 0xa3, 0xe3, 0xda, 0x0a, 0xa6, 0xb4, 0x01, 0x07, 0x58, 0x13, 0xa7, 0xb5, 0xb5, 0xce,
	0x09, 0x0d, 0xc0, 0x38, 0x4a, 0x05, 0xf1, 0x92, 0x7b, 0xa5, 0x40, 0xe2, 0xc8, 0x8c, 0xc6, 0x00,
	0xd6, 0x60, 0x2d, 0x8d, 0x93, 0xda, 0x0b, 0x6d, 0xf3, 0x48, 0x9d, 0xd1, 0x96, 0x72, 0x00, 0xee,
	0x0c, 0x61, 0x9c, 0x73, 0x1d, 0xa3, 0x13, 0x8a, 0xf0, 0x18, 0xb4, 0xc2, 0xd6, 0xa3, 0x94, 0xf1,
	0x48, 0xb8, 0x95, 0xc6, 0x06, 0x85, 0xb1, 0xf1, 0x56, 0x68, 0xc9, 0x98, 0x32, 0x94, 0x68, 0x1b,
	0x89, 0x8a, 0x0c, 0xa5, 0x41, 0x49, 0x00, 0xc9, 0xa3, 0x53, 0x54, 0x31, 0xc5, 0x98, 0x77, 0xc0,
	0x85, 0xb0, 0x5e, 0x13, 0x4f, 0x0d, 0x05, 0x89, 0x52, 0x1d, 0xa5, 0x37, 0x44, 0x07, 0xef, 0x84,
	0x16, 0xe0, 0x1c, 0x58, 0x2c, 0x80, 0x7a, 0x6f, 0xb8, 0x60, 0x18, 0x58, 0x9e, 0xd3, 0x80, 0x8d,
	0x00, 0xa9, 0xb9, 0x36, 0x81, 0x79, 0xc1, 0x04, 0x35, 0xca, 0x07, 0x1d, 0x62, 0x74, 0x58, 0x7a,
	0x67, 0x50, 0x1a, 0x29, 0x75, 0x21, 0x08, 0x05, 0x2c, 0xff, 0x80, 0xa0, 0xa5, 0x0f, 0x96, 0xe3,
	0x60, 0x69, 0xd0, 0x1c, 0x34, 0x73, 0x28, 0x8d, 0x4e, 0x68, 0xcd, 0x48, 0xd4, 0x86, 0x12, 0x83,
	0x65, 0x9e, 0x32, 0xce, 0x81, 0x0a, 0xe7, 0x35, 0xc3, 0x8e, 0x0b, 0x94, 0x62, 0xef, 0x09, 0x68,
	0x2e, 0xa4, 0x06, 0xae, 0x88, 0xb5, 0x24, 0x48, 0x6a, 0x03, 0x27, 0x42, 0xdb, 0x00, 0xd2, 0x09,
	0x94, 0x52, 0x6c, 0x28, 0x90, 0x18, 0xa3, 0xe3, 0x22, 0x28, 0xe0, 0x96, 0x18, 0x2b, 0x54, 0x34,
	0xce, 0x0b, 0xa0, 0x98, 0x59, 0x94, 0x06, 0xa2, 0x2d, 0x0f, 0x56, 0x73, 0x1b, 0x85, 0x01, 0x42,
	0xb0, 0xd6, 0x92, 0x5a, 0x66, 0x9c, 0x05, 0xe5, 0x4d, 0xe0, 0x28, 0xb5, 0x92, 0x50, 0x63, 0xa2,
	0x71, 0x02, 0x13, 0x1b, 0x7c, 0x94, 0x1a, 0x3b, 0x43, 0x95, 0x08, 0xca, 0x04, 0x6e, 0xbd, 0x44,
	0xa9, 0x63, 0x5a, 0x1a, 0x2e, 0xad, 0xb0, 0x9c, 0x07, 0x12, 0x82, 0xf7, 0x9a, 0x33, 0xe7, 0x95,
	0x60, 0x4c, 0x86, 0xe8, 0x01, 0xa5, 0x9a, 0x1b, 0x1d, 0x81, 0x53, 0xa9, 0x95, 0xe4, 0xc1, 0x45,
	0x43, 0xa5, 0x65, 0x9a, 0x6a, 0x06, 0x26, 0xb0, 0xa0, 0x63, 0x1e, 0x69, 0x08, 0x44, 0xbb, 0x10,
	0x18, 0xc5, 0x06, 0xac, 0x22, 0xda, 0x68, 0x83, 0x19, 0xb6, 0x32, 0x1a, 0xc6, 0x24, 0x47, 0xa9,
	0x36, 0x86, 0x58, 0xa6, 0x15, 0xf0, 0x1c, 0x9f, 0x28, 0x8e, 0x23, 0x15, 0x41, 0x46, 0x41, 0x98,
	0x89, 0x86, 0x06, 0x94, 0xb2, 0xa0, 0x8d, 0xc7, 0x21, 0x3a, 0x12, 0x2d, 0xe7, 0x86, 0x10, 0xa7,
	0xa3, 0x55, 0x82, 0x32, 0x88, 0x3a, 0x40, 0x70, 0x28, 0x05, 0xc6, 0xb0, 0xf3, 0xd6, 0x18, 0xaf,
	0xad, 0xa0, 0x42, 0x5a, 0x20, 0x54, 0x5a, 0x21, 0x3c, 0xf7, 0x8a, 0x0a, 0x2f, 0x50, 0xaa, 0x19,
	0x60, 0xee, 0xbc, 0xd0, 0x81, 0x63, 0x1a, 0x8d, 0x64, 0xcc, 0x68, 0xe6, 0x5d, 0xa4, 0x54, 0x51,
	0xee, 0x30, 0x45, 0xa9, 0xd3, 0x51, 0x13, 0xa9, 0x98, 0xc7, 0x40, 0x02, 0x35, 0x06, 0x6b, 0xc6,
	0x65, 0x64, 0xce, 0x3a, 0x6d, 0xa8, 0x33, 0x0e, 0xa5, 0x41, 0x08, 0x12, 0x6d, 0xf4, 0x3c, 0x72,
	0x1c, 0x49, 0x00, 0x4f, 0x9d, 0xe3, 0xc2, 0x68, 0xec, 0xa2, 0x35, 0xdc, 0x50, 0x94, 0x52, 0x83,
	0xb5, 0x88, 0x98, 0x45, 0x0d, 0xda, 0x62, 0x16, 0xb1, 0x63, 0xc6, 0x78, 0xe1, 0x95, 0x8f, 0xd8,
	0x61, 0xa7, 0xf3, 0xb1, 0x6e, 0x95, 0x0d, 0x84, 0x0b, 0x6c, 0x62, 0x90, 0x84, 0x7b, 0xe5, 0x1c,
	0xb3, 0x02, 0x7b, 0x6e, 0x34, 0x75, 0xda, 0xa3, 0xd4, 0x79, 0xe9, 0x99, 0x96, 0x91, 0xe7, 0x13,
	0xc1, 0x28, 0x67, 0x82, 0x01, 0x41, 0x03, 0x57, 0xd4, 0x29, 0x45, 0x83, 0x46, 0xa9, 0x23, 0x2c,
	0x60, 0xa2, 0xb9, 0xb4, 0x41, 0x59, 0xc2, 0xad, 0xc2, 0x2e, 0xe6, 0x29, 0x25, 0x52, 0x29, 0xe1,
	0x95, 0x46, 0xa9, 0x34, 0x1a, 0x98, 0xa4, 0xc4, 0x44, 0x66, 0x94, 0xe1, 0x14, 0x47, 0x4b, 0x85,
	0x26, 0x8e, 0x92, 0x60, 0xbd, 0x02, 0x8f, 0x52, 0xa2, 0x08, 0xa5, 0x5a, 0x69, 0x8c, 0xad, 0x37,
	0xc4, 0x31, 0xee, 0x6d, 0x08, 0x42, 0x6b, 0xee, 0x41, 0x0b, 0x21, 0xf3, 0x48, 0x05, 0x0e, 0x1e,
	0x88, 0x0e, 0x40, 0x9c, 0x23, 0x9c, 0x81, 0x34, 0x41, 0x86, 0x60, 0x38, 0x61, 0x4e, 0x33, 0x21,
	0xf2, 0x19, 0x45, 0x04, 0xb6, 0x91, 0x0b, 0xc2, 0x9d, 0x96, 0x3a, 0x40, 0x74, 0x5a, 0xf0, 0xe0,
	0x70, 0x94, 0xd4, 0x72, 0x4e, 0x50, 0x1a, 0xa2, 0xf0, 0x0c, 0x83, 0x54, 0x38, 0x38, 0x9b, 0x0f,
	0x36, 0xaa, 0x30, 0x04, 0x26, 0xb1, 0xc4, 0x3e, 0x62, 0xc1, 0x51, 0xca, 0x84, 0xc7, 0x96, 0x11,
	0xcf, 0x35, 0x31, 0x54, 0x45, 0x4c, 0xa9, 0x65, 0x4e, 0x30, 0x4c, 0xf3, 0xa9, 0x89, 0x75, 0xc1,
	0x74, 0xde, 0x83, 0x70, 0x4a, 0x7a, 0xed, 0x88, 0xe2, 0x8a, 0x06, 0x4c, 0xb9, 0x12, 0xda, 0x28,
	0x6c, 0x39, 0x96, 0x0e, 0xa5, 0x86, 0x10, 0xae, 0x8c, 0xf5, 0xda, 0x62, 0x4d, 0x18, 0x04, 0x42,
	0x39, 0x71, 0x4c, 0x6a, 0xe9, 0x7d, 0xb0, 0x01, 0x0c, 0x4a, 0x31, 0x03, 0xa2, 0xa5, 0x55, 0x51,
	0x33, 0xaa, 0x05, 0x18, 0xc6, 0x38, 0x09, 0xc0, 0x95, 0x66, 0x8c, 0x63, 0x2c, 0x21, 0xcf, 0x47,
	0x0c, 0xdc, 0x28, 0x4a, 0xa3, 0x0e, 0x84, 0x44, 0x16, 0x94, 0x0c, 0x1e, 0x34, 0x8f, 0x1a, 0xb0,
	0x31, 0x56, 0xe5, 0xf3, 0x16, 0x63, 0x2c, 0x84, 0x25, 0xc4, 0x48, 0x0b, 0x60, 0x75, 0x20, 0xce,
	0x4b, 0x6c, 0xb4, 0x16, 0xce, 0x1a, 0xc1, 0x50, 0x8a, 0x8d, 0x8e, 0x42, 0x00, 0x55, 0x41, 0x7b,
	0xee, 0xb0, 0x15, 0x06, 0x13, 0x4c, 0xbd, 0x0b, 0xf9, 0x17, 0x8e, 0xf9, 0xac, 0x04, 0xe6, 0xa8,
	0x75, 0x24, 0x1a, 0x2b, 0x64, 0xa4, 0xd1, 0x71, 0x6f, 0x28, 0xd7, 0x91, 0x46, 0x4e, 0x24, 0x23,
	0x39, 0xf3, 0x73, 0x09, 0x79, 0x20, 0xd6, 0x79, 0x6f, 0x35, 0x58, 0xe3, 0xac, 0x35, 0x8c, 0x06,
	0x2b, 0x75, 0x0c, 0x4e, 0x50, 0x83, 0x52, 0x1e, 0x94, 0xa5, 0x3a, 0xc8, 0x48, 0xa9, 0x64, 0x10,
	0x24, 0x09, 0xa0, 0xb5, 0xb7, 0x52, 0x82, 0xc3, 0x84, 0x00, 0x43, 0xa9, 0xa3, 0x4e, 0x92, 0xe0,
	0x94, 0x33, 0xdc, 0x60, 0x2b, 0x71, 0xa0, 0x0a, 0x7b, 0xef, 0x28, 0x76, 0x5c, 0x52, 0x4d, 0x25,
	0x4a, 0x0d, 0x15, 0xca, 0x28, 0x4c, 0x22, 0xe1, 0x42, 0x62, 0x01, 0x06, 0x82, 0xc7, 0x0e, 0x13,
	0x6b, 0x30, 0xf1, 0x32, 0x08, 0x94, 0x2a, 0x69, 0x08, 0x35, 0xca, 0xe5, 0x66, 0x96, 0x13, 0xca,
	0x58, 0x0c, 0xd8, 0x62, 0x67, 0x2d, 0xb6, 0x4c, 0xe6, 0xd5, 0x83, 0x48, 0x88, 0x3e, 0x62, 0xc0,
	0x58, 0x60, 0x1e, 0x42, 0x84, 0x10, 0x80, 0x30, 0x17, 0xc1, 0x1a, 0xa3, 0x8c, 0xa0, 0x28, 0x25,
	0x82, 0x33, 0xab, 0x3c, 0x97, 0x92, 0x31, 0xeb, 0xa3, 0xca, 0x49, 0x0d, 0x13, 0x67, 0xbd, 0x77,
	0x01, 0x17, 0x63, 0x2c, 0xc8, 0x88, 0xb9, 0x13, 0xd6, 0x10, 0x4c, 0x88, 0x88, 0xdc, 0x09, 0x0c,
	0x1e, 0x3c, 0x36, 0x81, 0x63, 0x4b, 0x42, 0x44, 0xa9, 0x61, 0xb9, 0xaa, 0xd2, 0x34, 0x48, 0x6e,
	0x02, 0x38, 0x41, 0x72, 0x42, 0xe5, 0xe0, 0x9d, 0x22, 0xdc, 0x39, 0x8c, 0x52, 0x01, 0x42, 0x31,
	0x6f, 0xbc, 0x89, 0xda, 0x59, 0x45, 0x31, 0x44, 0xe3, 0x88, 0x06, 0x13, 0x3d, 0x50, 0xa0, 0x51,
	0xa1, 0x54, 0x18, 0x6c, 0x29, 0xa3, 0x21, 0x2f, 0x6d, 0x92, 0x63, 0x13, 0xad, 0x53, 0x14, 0x94,
	0xa0, 0x56, 0x5b, 0x2a, 0xf3, 0x0a, 0xa4, 0xb9, 0x71, 0x98, 0xbb, 0xe0, 0x02, 0x09, 0xd4, 0x19,
	0xcd, 0xa2, 0x04, 0x6d, 0xb9, 0x50, 0x80, 0x25, 0xa3, 0x79, 0x05, 0x32, 0x9e, 0x0a, 0x6d, 0x80,
	0x78, 0x0c, 0x26, 0x0a, 0xc6, 0x2c, 0xa6, 0xd4, 0x4b, 0x8a, 0x45, 0x34, 0x8a, 0x18, 0x20, 0x28,
	0x35, 0x12, 0x9c, 0x95, 0x34, 0x2f, 0x1f, 0xd4, 0x71, 0x25, 0xb1, 0x22, 0x86, 0x3a, 0xab, 0x78,
	0x3e, 0xa0, 0x85, 0xb3, 0x28, 0x55, 0x9e, 0x13, 0xec, 0x41, 0x33, 0x0a, 0x9a, 0x6b, 0xcb, 0x18,
	0x25, 0x9c, 0x51, 0x6f, 0xac, 0xa6, 0x60, 0x14, 0xcd, 0x6b, 0x83, 0x8c, 0x41, 0x33, 0x4b, 0x49,
	0x34, 0x91, 0x79, 0x11, 0x4d, 0x8c, 0xca, 0x09, 0x2f, 0x99, 0x73, 0x9e, 0x28, 0x13, 0x50, 0x4a,
	0x83, 0x56, 0x86, 0x7b, 0xa7, 0x9c, 0xc8, 0xf9, 0x40, 0x39, 0x00, 0x2a, 0x8d, 0x00, 0x65, 0x3c,
	0x11, 0x4a, 0x62, 0x94, 0xc6, 0xa0, 0x71, 0xb4, 0xc6, 0x4b, 0x42, 0xb1, 0x0f, 0xf9, 0x40, 0x15,
	0x14, 0x0b, 0x82, 0x23, 0xf3, 0x92, 0xf3, 0xbc, 0x56, 0x0a, 0x15, 0x99, 0xe4, 0xd4, 0x71, 0x60,
	0x0a, 0xa8, 0x8e, 0xc2, 0x3b, 0x60, 0x98, 0x62, 0x6f, 0x18, 0x23, 0x8e, 0x7b, 0x94, 0x1a, 0x2c,
	0x31, 0xe6, 0x74, 0xc0, 0x7f, 0x02, 0x94, 0x10, 0x0e, 0x73, 0xe6, 0xb1, 0x50, 0x54, 0x70, 0x9b,
	0x8f, 0x42, 0x2f, 0x70, 0x94, 0xf9, 0xca, 0x81, 0x28, 0x26, 0x95, 0x74, 0x5c, 0x39, 0x2b, 0xb1,
	0x16, 0x2e, 0x60, 0x2f, 0x3d, 0x00, 0x4a, 0x3d, 0xc5, 0xc4, 0x19, 0x1a, 0xb5, 0xe3, 0x9a, 0x45,
	0xcb, 0xb4, 0x76, 0x40, 0x14, 0x0f, 0x52, 0xea, 0x3c, 0x83, 0x1c, 0xa5, 0xce, 0x60, 0x17, 0x1c,
	0x18, 0x49, 0xac, 0xe4, 0x3a, 0x62, 0x4e, 0x55, 0x70, 0x94, 0x58, 0x6b, 0xa5, 0xf7, 0x4e, 0x18,
	0x94, 0x9a, 0x28, 0xa9, 0xe7, 0x91, 0x4a, 0x67, 0x70, 0x60, 0x41, 0x09, 0xe5, 0xc0, 0x4a, 0x6c,
	0x40, 0xd3, 0x48, 0xc1, 0xc6, 0x7c, 0x55, 0x86, 0x3e, 0x4c, 0xe6, 0x6b, 0x47, 0x7a, 0xa5, 0x7f,
	0x4a, 0xd2, 0x99, 0xcb, 0xb5, 0x33, 0xd3, 0xcb, 0xb5, 0x3f, 0x2f, 0x96, 0x64, 0x95, 0x0d, 0x74,
	0x2e, 0x40, 0xb4, 0x3b, 0xad, 0xd1, 0x7e, 0xb6, 0xd1, 0x86, 0x7b, 0xd9, 0x68, 0x5f, 0xb4, 0x58,
	0x2c, 0xab, 0xcf, 0xec, 0x5b, 0x32, 0x5e, 0xd9, 0xee, 0x66, 0xbb, 0x57, 0x0f, 0xd5, 0x9f, 0x1f,
	0x5a, 0x0e, 0xf6, 0x54, 0x37, 0xe1, 0x5e, 0x36, 0xdc, 0x01, 0xbd, 0x85, 0x4e, 0xef, 0x03, 0x0d,
	0xd0, 0xde, 0xad, 0x2e, 0x1d, 0x88, 0x76, 0x6a, 0x0a, 0xed, 0x4d, 0x68, 0xef, 0x56, 0xae, 0xa2,
	0x33, 0xfb, 0x70, 0x6c, 0xab, 0xd5, 0xb9, 0x3b, 0x3c, 0x8b, 0x7b, 0x1a, 0x50, 0x65, 0x0a, 0xe8,
	0x72, 0x6e, 0xf1, 0xc6, 0xe9, 0xff, 0xf9, 0x4a, 0x99, 0xae, 0xb0, 0x15, 0xbe, 0x22, 0x56, 0xe4,
	0x8a, 0x5a, 0xd1, 0x2b, 0x04, 0xaf, 0xbd, 0x8e, 0x9e, 0xdb, 0x07, 0xef, 0xb7, 0x3a, 0x4d, 0x0f,
	0x95, 0x33, 0x1f, 0x3d, 0x4c, 0x16, 0x1f, 0x3d, 0x4c, 0xd0, 0xe3, 0x87, 0xc9, 0x02, 0x21, 0x2b,
	0x84, 0xae, 0x10, 0xf6, 0xce, 0xdc, 0x02, 0x2a, 0x2f, 0xd6, 0xfe, 0x19, 0xa1, 0xb9, 0xe2, 0x90,
	0xfc, 0x0d, 0xb4, 0xb0, 0x0d, 0x99, 0x0d, 0x36, 0xb3, 0xc5, 0x41, 0xf9, 0x22, 0x5d, 0xde, 0x17,
	0xd0, 0x0d, 0xe8, 0xf7, 0xed, 0x26, 0xdc, 0x80, 0xcc, 0x16, 0x3b, 0xb3, 0xb1, 0x7e, 0xe5, 0x5d,
	0x34, 0x97, 0x6f, 0xb8, 0x87, 0x7b, 0x2e, 0xb2, 0x7a, 0x50, 0xfb, 0xa3, 0xe8, 0x14, 0xec, 0xdf,
	0x76, 0x0f, 0x76, 0x31, 0x05, 0xc8, 0x1b, 0x7f, 0x7f, 0xec, 0x27, 0x0f, 0x93, 0xbf, 0x3b, 0x86,
	0x9e, 0x47, 0x73, 0x37, 0xed, 0x36, 0x9c, 0x3b, 0x89, 0x8e, 0x8f, 0x1c, 0xad, 0xb6, 0xed, 0x36,
	0xa0, 0x65, 0xb4, 0x98, 0x47, 0x9c, 0x0e, 0x12, 0x72, 0xee, 0x24, 0x5a, 0xcc, 0xed, 0x56, 0x07,
	0xef, 0x9c, 0x26, 0xe8, 0x35, 0x34, 0x3f, 0x38, 0x5c, 0xee, 0xaf, 0x2d, 0xa3, 0x6a, 0xf1, 0x6c,
	0xe2, 0xc0, 0x7a, 0x75, 0xf0, 0xa7, 0x5f, 0x2e, 0xe1, 0x04, 0xd5, 0xd0, 0xdc, 0x2d, 0x9b, 0x6d,
	0xad, 0x9d, 0x43, 0x67, 0x0b, 0xbd, 0xae, 0xcd, 0xb6, 0x56, 0xe1, 0x9e, 0xf5, 0xa3, 0x35, 0x7e,
	0xb9, 0x84, 0x2e, 0xa2, 0xc5, 0x5c, 0x27, 0x1d, 0xec, 0xd4, 0xd6, 0xce, 0xa3, 0xe7, 0xf7, 0x54,
	0x87, 0xfb, 0xbb, 0xb1, 0xee, 0x05, 0x84, 0x0a, 0xdd, 0x3a, 0x6c, 0xc2, 0xbd, 0x69, 0xd4, 0x5e,
	0x2e, 0xda, 0xd3, 0xfc, 0x87, 0x12, 0x3a, 0xba, 0x5e, 0x9c, 0x67, 0x95, 0x93, 0x8b, 0xdf, 0x2f,
	0xa1, 0xbf, 0x2d, 0xa1, 0xb3, 0xe8, 0xe4, 0xe0, 0x45, 0xda, 0xbb, 0x8d, 0xc1, 0x51, 0x17, 0x2d,
	0x5d, 0x6e, 0xef, 0xa2, 0x0a, 0x2a, 0x17, 0xf2, 0xe1, 0xb9, 0x59, 0x91, 0x83, 0x80, 0xbe, 0xb4,
	0x5f, 0x36, 0xda, 0x5d, 0x4f, 0xc5, 0x5f, 0x2b, 0x97, 0x4b, 0x17, 0x97, 0xae, 0xe4, 0x92, 0x74,
	0x30, 0x45, 0xea, 0xaf, 0x1d, 0x60, 0x3a, 0x15, 0xe4, 0xa1, 0x03, 0xbd, 0x4c, 0xaa, 0x0e, 0xbc,
	0x14, 0x2f, 0xfd, 0x2c, 0x5e, 0xa6, 0x12, 0x7c, 0x08, 0xbd, 0x3a, 0xfc, 0x48, 0x33, 0x54, 0x29,
	0x5a, 0xef, 0xb4, 0x63, 0x73, 0x73, 0xa7, 0x07, 0x01, 0x9d, 0x45, 0x67, 0x26, 0xf5, 0x46, 0x87,
	0x7e, 0xe8, 0x1d, 0x44, 0x0a, 0x79, 0xb3, 0xdb, 0xc8, 0xb6, 0x7a, 0x60, 0xb3, 0x86, 0xb7, 0x19,
	0x6c, 0x76, 0x86, 0x5b, 0xd4, 0x27, 0xe5, 0x4d, 0xe8, 0xd7, 0x9e, 0x2b, 0x97, 0x2e, 0x9e, 0xba,
	0x5d, 0x88, 0xd3, 0xf5, 0xb1, 0x18, 0xfd, 0x0d, 0x3a, 0x7c, 0xed, 0x56, 0x39, 0xb9, 0x78, 0x17,
	0xed, 0xa0, 0xca, 0x68, 0x60, 0xb5, 0x77, 0x1b, 0xcd, 0xee, 0xe0, 0x5b, 0x5c, 0x42, 0x2f, 0x8d,
	0x7c, 0x4d, 0x1c, 0x36, 0xec, 0xdd, 0x42, 0xbf, 0xb6, 0x54, 0x2e, 0x5d, 0x5c, 0xb8, 0x35, 0xbc,
	0x43, 0xab, 0xe8, 0xfc, 0xc8, 0x60, 0xf4, 0xfa, 0x7b, 0x87, 0x02, 0xfd, 0xda, 0xc9, 0x72, 0xe9,
	0xe2, 0xe2, 0x40, 0x39, 0xdd, 0x80, 0xac, 0x8f, 0xee, 0xa2, 0xd2, 0xe5, 0x8d, 0x9b, 0xe5, 0xe4,
	0x62, 0x1b, 0xb5, 0xd0, 0x69, 0xb4, 0x34, 0x8e, 0xc0, 0xf6, 0xdb, 0x83, 0x10, 0x2e, 0x0e, 0xd3,
	0x35, 0x3a, 0x2c, 0x58, 0xb5, 0xfd, 0x46, 0x7b, 0x67, 0xdb, 0x41, 0xaf, 0x5f, 0x3b, 0x51, 0x2e,
	0x5d, 0x44, 0x97, 0x37, 0xd2, 0x9b, 0x83, 0x7b, 0xf4, 0x1a, 0x7a, 0x61, 0xac, 0x3b, 0x72, 0x3f,
	0xdc, 0xe5, 0x0f, 0x03, 0xbd, 0xbc, 0x71, 0x73, 0xe0, 0x18, 0xa3, 0xa3, 0x6f, 0x16, 0x1d, 0xa7,
	0x72, 0xb2, 0xf6, 0x0a, 0x4a, 0x0b, 0xb3, 0xe9, 0xde, 0xd5, 0xfe, 0x89, 0x21, 0xd1, 0xd2, 0xc0,
	0x62, 0x30, 0xdc, 0x9f, 0x6e, 0xb7, 0x6f, 0xe8, 0x7f, 0x11, 0xcd, 0x0f, 0x5a, 0x4d, 0xfd, 0x72,
	0xb2, 0x76, 0x76, 0xf8, 0x8a, 0xc3, 0xee, 0x52, 0xb9, 0x54, 0x2b, 0xfa, 0x73, 0x68, 0x05, 0x2d,
	0x7d, 0x6d, 0x07, 0x7a, 0xbb, 0xe9, 0x2d, 0xdb, 0xb3, 0xdb, 0xb9, 0xe6, 0x39, 0x74, 0xaa, 0xd0,
	0xfc, 0x6e, 0x2e, 0x6e, 0x74, 0x07, 0xe2, 0x52, 0xad, 0xf4, 0x1d, 0xd8, 0x45, 0x5f, 0x46, 0xf3,
	0xeb, 0x9d, 0xce, 0x77, 0x9a, 0x90, 0x2b, 0x2e, 0x8f, 0xc6, 0x49, 0x21, 0x19, 0x45, 0xb1, 0x07,
	0xfd, 0x65, 0x84, 0xae, 0x8c, 0x5b, 0x3f, 0xe5, 0xe4, 0xdc, 0xf9, 0x61, 0x92, 0x66, 0xf5, 0x91,
	0x6a, 0xdf, 0x46, 0x0b, 0x39, 0xd9, 0x14, 0xa7, 0x11, 0xdf, 0x42, 0x47, 0x72, 0xf2, 0xea, 0x57,
	0x93, 0x99, 0x47, 0x2b, 0xd3, 0x3c, 0x57, 0xb4, 0x03, 0xd7, 0x5e, 0x79, 0x34, 0x3c, 0x6e, 0x38,
	0xfa, 0x61, 0x52, 0x2a, 0x7f, 0x70, 0x78, 0x54, 0xc0, 0x70, 0xf2, 0xf8, 0xa7, 0xff, 0x5e, 0x3a,
	0xfa, 0xe1, 0x8f, 0x8a, 0xe3, 0xb6, 0x01, 0x6c, 0x6d, 0x13, 0x9d, 0xb8, 0x0e, 0x9b, 0xd6, 0xef,
	0x8e, 0x3d, 0x7e, 0x7d, 0xda, 0xe3, 0xc1, 0x27, 0x7a, 0x2f, 0x3f, 0xb8, 0x7f, 0x7a, 0x06, 0xd7,
	0x4e, 0x78, 0x1f, 0x39, 0xfa, 0xe5, 0x71, 0x74, 0x62, 0x9a, 0x81, 0x2b, 0xef, 0xa1, 0x39, 0xdb,
	0xda, 0xec, 0x14, 0xd4, 0x7f, 0x82, 0xae, 0x3c, 0xbd, 0xc3, 0xb9, 0xde, 0xd9, 0x76, 0xcd, 0x76,
	0xb3, 0xbd, 0x79, 0xb9, 0x95, 0xcf, 0x99, 0x6c, 0x6b, 0x7b, 0xed, 0xec, 0xc7, 0xf7, 0x93, 0xff,
	0x7a, 0x98, 0x2c, 0xbe, 0x75, 0xad, 0xbe, 0x71, 0xbb, 0x71, 0xe3, 0xf2, 0xed, 0xf5, 0xab, 0x45,
	0x83, 0xa7, 0x40, 0xac, 0x08, 0x84, 0xf2, 0xf1, 0x3b, 0x38, 0x71, 0xff, 0x0d, 0x25, 0xf8, 0x98,
	0x6d, 0xef, 0x6e, 0x14, 0x8a, 0x95, 0xd7, 0xd1, 0xe2, 0xf0, 0x74, 0xbf, 0xe8, 0xdd, 0x1e, 0x9e,
	0xea, 0x6e, 0x5d, 0xf8, 0xe0, 0xf0, 0xd5, 0x43, 0x75, 0x34, 0x50, 0xc8, 0xab, 0x44, 0xe5, 0xf6,
	0x93, 0xcd, 0x80, 0xd2, 0xb3, 0x35, 0x03, 0xd6, 0xe6, 0x7f, 0xf8, 0xa3, 0xa4, 0x84, 0x92, 0xe4,
	0xea, 0xa1, 0x27, 0xfa, 0x02, 0xef, 0xa1, 0xd3, 0x13, 0x41, 0x8c, 0xcf, 0x2f, 0x8f, 0x14, 0xc8,
	0xaf, 0xfe, 0xc6, 0x26, 0xee, 0x9a, 0xed, 0x37, 0x7d, 0xbe, 0x16, 0xd8, 0x0b, 0x74, 0x74, 0x22,
	0xfa, 0xb5, 0x7d, 0x6d, 0xc0, 0xa3, 0x9f, 0xa2, 0x0d, 0xb8, 0xd7, 0x42, 0x9b, 0xea, 0x07, 0xae,
	0xa1, 0xb9, 0xa2, 0x37, 0x33, 0xff, 0x29, 0x7a, 0x33, 0x7b, 0x50, 0x85, 0x6d, 0xe5, 0x5d, 0x74,
	0x2c, 0x5f, 0xdb, 0x34, 0x9a, 0xed, 0xd8, 0x19, 0xf6, 0x50, 0x9f, 0x02, 0x94, 0xaf, 0x68, 0xae,
	0xb5, 0x63, 0xa7, 0xb7, 0x5d, 0x4c, 0x99, 0x3d, 0xa0, 0x85, 0x30, 0x7c, 0x52, 0xf9, 0x20, 0xd9,
	0x5b, 0x8d, 0xc5, 0x4e, 0xef, 0xae, 0xed, 0x85, 0x66, 0x7b, 0x73, 0x7c, 0x80, 0x77, 0xec, 0x19,
	0xc6, 0xf4, 0x2b, 0x0f, 0xee, 0x97, 0xf7, 0x9b, 0x0e, 0x1d, 0x8d, 0x57, 0x85, 0xa5, 0x7a, 0x75,
	0xe8, 0xe5, 0xad, 0xb1, 0xe6, 0xe8, 0xf4, 0xee, 0x9b, 0xa3, 0x09, 0x34, 0xf7, 0x0c, 0xce, 0x2e,
	0xcc, 0x9e, 0x40, 0x13, 0xfe, 0xa6, 0xe7, 0x51, 0xe5, 0x7d, 0x84, 0x8a, 0x15, 0xdc, 0xe0, 0x28,
	0x74, 0xd0, 0x13, 0xbb, 0x70, 0x30, 0x2b, 0xec, 0x1d, 0x58, 0xaf, 0x3d, 0x97, 0x53, 0x40, 0xf9,
	0x87, 0x3f, 0x4a, 0x96, 0xfa, 0x5b, 0xb6, 0x07, 0x61, 0x25, 0xdd, 0xe9, 0x43, 0xef, 0x6a, 0x52,
	0x3f, 0x56, 0x80, 0x0e, 0x29, 0x67, 0xf0, 0x3d, 0x0a, 0x07, 0x67, 0x7f, 0x57, 0x0e, 0x8a, 0x4f,
	0x54, 0xe0, 0x5f, 0x41, 0xc7, 0xf2, 0x57, 0x19, 0xe0, 0x3f, 0x3f, 0x73, 0x58, 0xcf, 0xa0, 0xb5,
	0xdc, 0x34, 0x87, 0xe9, 0x8d, 0x78, 0xaa, 0x83, 0xca, 0xad, 0x82, 0xb9, 0x1a, 0x7b, 0x68, 0x83,
	0x16, 0xda, 0xca, 0xc1, 0x68, 0xd3, 0x7c, 0xf7, 0xf4, 0x88, 0x4f, 0xb4, 0xa6, 0x89, 0xf1, 0x4d,
	0x54, 0x19, 0x64, 0xde, 0xb6, 0x5a, 0x8d, 0x1e, 0x7c, 0x77, 0x07, 0xfa, 0x59, 0x7f, 0xd8, 0x26,
	0x9b, 0x4d, 0x2e, 0x49, 0xbd, 0x5c, 0x58, 0x5c, 0x6e, 0xb5, 0xea, 0x43, 0xfd, 0xca, 0x1a, 0x3a,
	0x55, 0x64, 0x77, 0x0a, 0xe4, 0xfc, 0x81, 0x20, 0x27, 0x73, 0x83, 0x49, 0x8c, 0x3a, 0x3a, 0xd3,
	0x6c, 0x67, 0xd0, 0x6b, 0xdb, 0x56, 0x6b, 0xb7, 0xb1, 0x09, 0x6d, 0xe8, 0xd9, 0x0c, 0xc2, 0xb0,
	0xfd, 0x37, 0x13, 0x66, 0x3c, 0x57, 0xae, 0x26, 0xf5, 0xd3, 0x7b, 0xc6, 0x6f, 0x8f, 0x6c, 0x2b,
	0xdf, 0x42, 0xc7, 0x8b, 0x9f, 0xbd, 0x8c, 0x9e, 0x55, 0x7f, 0x3e, 0x3f, 0xb3, 0x21, 0x30, 0xeb,
	0x30, 0xff, 0xcc, 0x83, 0xfb, 0xd3, 0xc6, 0xc5, 0xa4, 0x5c, 0xca, 0x45, 0xd7, 0x86, 0x92, 0xca,
	0xfb, 0x68, 0xa9, 0x5f, 0xfc, 0x3c, 0xa6, 0x31, 0x98, 0x1c, 0xbf, 0x98, 0x2f, 0x66, 0xc7, 0x6f,
	0x1a, 0x59, 0xe3, 0x5f, 0xd4, 0xac, 0x55, 0x9e, 0x98, 0x13, 0x0b, 0xf5, 0xc5, 0xfe, 0xf8, 0x79,
	0xff, 0x8d, 0xf4, 0xc7, 0x0f, 0x93, 0x17, 0xd1, 0x71, 0x34, 0x3f, 0x60, 0xf3, 0x7e, 0xe5, 0x30,
	0xc1, 0x68, 0x11, 0x1d, 0x29, 0x9e, 0x56, 0x0e, 0x53, 0xbc, 0xf6, 0x25, 0x74, 0x7c, 0x48, 0xad,
	0x4f, 0xd9, 0xa5, 0xd0, 0x15, 0xb1, 0xc2, 0xd6, 0x56, 0xd0, 0x62, 0x31, 0xa4, 0x86, 0x4a, 0x5f,
	0xf8, 0xe8, 0x61, 0xf2, 0xfc, 0xa3, 0x87, 0xc9, 0x99, 0xc7, 0x0f, 0x93, 0x53, 0x94, 0xad, 0x50,
	0xb2, 0x42, 0xe9, 0x0a, 0x95, 0x2b, 0x54, 0xad, 0x50, 0x3e, 0xd8, 0xd3, 0xbc, 0x33, 0xb7, 0x70,
	0xa6, 0xfc, 0xdc, 0x3b, 0x47, 0x17, 0x7e, 0x39, 0x5f, 0xfe, 0xef, 0xf9, 0xda, 0xf7, 0x17, 0xd0,
	0x89, 0xf5, 0x7c, 0x9d, 0x07, 0xe3, 0x62, 0xf7, 0xd5, 0xdf, 0xbe, 0xd8, 0x7d, 0xb6, 0xa2, 0xf6,
	0xf2, 0x8c, 0xa2, 0xb6, 0xaf, 0x90, 0xbd, 0xfb, 0x5b, 0x17, 0xb2, 0x3f, 0x68, 0xfd, 0xba, 0xfa,
	0x19, 0xea, 0xd7, 0x74, 0xd9, 0xba, 0xf6, 0x59, 0x48, 0x74, 0x9a, 0x2d, 0xdf, 0xfe, 0x0c, 0x6c,
	0xf9, 0xfb, 0xa0, 0x45, 0xfb, 0x3b, 0xa2, 0xc5, 0x09, 0xbe, 0xf8, 0xe3, 0x25, 0xc2, 0x6b, 0x9f,
	0x9e, 0x08, 0x9f, 0xc2, 0x7f, 0x6f, 0x9c, 0xfa, 0xc9, 0x57, 0xf6, 0xad, 0x4f, 0xd7, 0x6a, 0xfb,
	0xe9, 0xe2, 0xd4, 0xf7, 0x7e, 0x9d, 0x4c, 0x8b, 0xd6, 0x96, 0xa7, 0xb9, 0xe2, 0xe4, 0xf7, 0x7e,
	0x9d, 0x4c, 0x0a, 0x6a, 0xff, 0x37, 0x8f, 0x4e, 0xd6, 0xa1, 0xdb, 0xb2, 0xfe, 0x73, 0x2a, 0xf8,
	0x9c, 0x0a, 0xfe, 0xb0, 0x54, 0xf0, 0xde, 0xef, 0x86, 0x0a, 0x3e, 0x67, 0x80, 0xcf, 0xc4, 0x00,
	0xff, 0x78, 0x0c, 0x2d, 0xbe, 0x0d, 0xd9, 0xe7, 0xb3, 0xff, 0x8f, 0x71, 0xf6, 0xbf, 0xf3, 0x69,
	0xf6, 0x6a, 0x67, 0x67, 0xef, 0xd5, 0x46, 0x3b, 0xb3, 0xcf, 0x99, 0xe4, 0x73, 0x26, 0x19, 0xec,
	0xa5, 0xae, 0x7f, 0xc6, 0xbd, 0xce, 0xf4, 0xbe, 0xe6, 0xf7, 0xc3, 0x4b, 0x6b, 0x3f, 0x48, 0x1e,
	0xfd, 0x6c, 0xf9, 0xd0, 0xc7, 0x3f, 0x5b, 0x3e, 0xf4, 0xab, 0x9f, 0x2d, 0x27, 0x1f, 0x3c, 0x5e,
	0x4e, 0xfe, 0xe5, 0xf1, 0x72, 0xf2, 0x1f, 0x8f, 0x97, 0x93, 0x47, 0x8f, 0x97, 0x93, 0x8f, 0x1f,
	0x2f, 0x27, 0x3f, 0x7d, 0xbc, 0x9c, 0xfc, 0xfc, 0xf1, 0xf2, 0xa1, 0x5f, 0x3d, 0x5e, 0x4e, 0x7e,
	0xf0, 0xc9, 0xf2, 0xa1, 0x8f, 0x3e, 0x59, 0x4e, 0x1e, 0x7d, 0xb2, 0x7c, 0xe8, 0xe3, 0x4f, 0x96,
	0x0f, 0x7d, 0xa3, 0xbe, 0xd9, 0xe9, 0x7e, 0x67, 0x73, 0xf5, 0x4e, 0xa7, 0x95, 0x41, 0xaf, 0x67,
	0x57, 0x77, 0xfa, 0x97, 0x8a, 0x8b, 0xd8, 0xe9, 0x6d, 0xbf, 0xde, 0xed, 0x75, 0xee, 0x34, 0x03,
	0xf4, 0x5e, 0x1f, 0x3d, 0xbe, 0xd4, 0x75, 0x9b, 0x9d, 0x4b, 0x70, 0x2f, 0x1b, 0xfd, 0x27, 0xc7,
	0xac, 0x7f, 0xe8, 0x70, 0x47, 0x8b, 0x9f, 0xcc, 0xb3, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x79,
	0x87, 0xf8, 0xb9, 0xf6, 0x32, 0x00, 0x00,
}

func (this *SimpleRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleRule)
	if !ok {
		that2, ok := that.(SimpleRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.MetricNameLabel != that1.MetricNameLabel {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.BotAction.Equal(that1.BotAction) {
		return false
	}
	if !this.ContentRewriteAction.Equal(that1.ContentRewriteAction) {
		return false
	}
	if !this.ShapeProtectedEndpointAction.Equal(that1.ShapeProtectedEndpointAction) {
		return false
	}
	if len(this.RateLimiters) != len(that1.RateLimiters) {
		return false
	}
	for i := range this.RateLimiters {
		if !this.RateLimiters[i].Equal(that1.RateLimiters[i]) {
			return false
		}
	}
	if len(this.RateLimiterSpecs) != len(that1.RateLimiterSpecs) {
		return false
	}
	for i := range this.RateLimiterSpecs {
		if !this.RateLimiterSpecs[i].Equal(that1.RateLimiterSpecs[i]) {
			return false
		}
	}
	if !this.MumAction.Equal(that1.MumAction) {
		return false
	}
	if !this.IpReputationAction.Equal(that1.IpReputationAction) {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *SourceList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SourceList)
	if !ok {
		that2, ok := that.(SourceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixList.Equal(that1.PrefixList) {
		return false
	}
	if len(this.IpPrefixSet) != len(that1.IpPrefixSet) {
		return false
	}
	for i := range this.IpPrefixSet {
		if !this.IpPrefixSet[i].Equal(that1.IpPrefixSet[i]) {
			return false
		}
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	if len(this.AsnSet) != len(that1.AsnSet) {
		return false
	}
	for i := range this.AsnSet {
		if !this.AsnSet[i].Equal(that1.AsnSet[i]) {
			return false
		}
	}
	if len(this.CountryList) != len(that1.CountryList) {
		return false
	}
	for i := range this.CountryList {
		if this.CountryList[i] != that1.CountryList[i] {
			return false
		}
	}
	if len(this.TlsFingerprintClasses) != len(that1.TlsFingerprintClasses) {
		return false
	}
	for i := range this.TlsFingerprintClasses {
		if this.TlsFingerprintClasses[i] != that1.TlsFingerprintClasses[i] {
			return false
		}
	}
	if len(this.TlsFingerprintValues) != len(that1.TlsFingerprintValues) {
		return false
	}
	for i := range this.TlsFingerprintValues {
		if this.TlsFingerprintValues[i] != that1.TlsFingerprintValues[i] {
			return false
		}
	}
	if that1.DefaultActionChoice == nil {
		if this.DefaultActionChoice != nil {
			return false
		}
	} else if this.DefaultActionChoice == nil {
		return false
	} else if !this.DefaultActionChoice.Equal(that1.DefaultActionChoice) {
		return false
	}
	return true
}
func (this *SourceList_DefaultActionNextPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SourceList_DefaultActionNextPolicy)
	if !ok {
		that2, ok := that.(SourceList_DefaultActionNextPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultActionNextPolicy.Equal(that1.DefaultActionNextPolicy) {
		return false
	}
	return true
}
func (this *SourceList_DefaultActionDeny) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SourceList_DefaultActionDeny)
	if !ok {
		that2, ok := that.(SourceList_DefaultActionDeny)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultActionDeny.Equal(that1.DefaultActionDeny) {
		return false
	}
	return true
}
func (this *SourceList_DefaultActionAllow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SourceList_DefaultActionAllow)
	if !ok {
		that2, ok := that.(SourceList_DefaultActionAllow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultActionAllow.Equal(that1.DefaultActionAllow) {
		return false
	}
	return true
}
func (this *Rule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rule)
	if !ok {
		that2, ok := that.(Rule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RuleList)
	if !ok {
		that2, ok := that.(RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LegacyRuleList)
	if !ok {
		that2, ok := that.(LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.Role.Equal(that1.Role) {
		return false
	}
	if !this.DenyInfo.Equal(that1.DenyInfo) {
		return false
	}
	if len(this.DefaultForwardingClasses) != len(that1.DefaultForwardingClasses) {
		return false
	}
	for i := range this.DefaultForwardingClasses {
		if !this.DefaultForwardingClasses[i].Equal(that1.DefaultForwardingClasses[i]) {
			return false
		}
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	if len(this.SimpleRules) != len(that1.SimpleRules) {
		return false
	}
	for i := range this.SimpleRules {
		if !this.SimpleRules[i].Equal(that1.SimpleRules[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyServer)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerName)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AllowList)
	if !ok {
		that2, ok := that.(GlobalSpecType_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DenyList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DenyList)
	if !ok {
		that2, ok := that.(GlobalSpecType_DenyList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyList.Equal(that1.DenyList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_RuleList)
	if !ok {
		that2, ok := that.(GlobalSpecType_RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LegacyRuleList)
	if !ok {
		that2, ok := that.(GlobalSpecType_LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRuleList.Equal(that1.LegacyRuleList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AllowAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AllowAllRequests)
	if !ok {
		that2, ok := that.(GlobalSpecType_AllowAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllRequests.Equal(that1.AllowAllRequests) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DenyAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DenyAllRequests)
	if !ok {
		that2, ok := that.(GlobalSpecType_DenyAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllRequests.Equal(that1.DenyAllRequests) {
		return false
	}
	return true
}
func (this *GlobalSpecType_InternallyGenerated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_InternallyGenerated)
	if !ok {
		that2, ok := that.(GlobalSpecType_InternallyGenerated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InternallyGenerated.Equal(that1.InternallyGenerated) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyServer)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerName)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AllowList)
	if !ok {
		that2, ok := that.(CreateSpecType_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DenyList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DenyList)
	if !ok {
		that2, ok := that.(CreateSpecType_DenyList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyList.Equal(that1.DenyList) {
		return false
	}
	return true
}
func (this *CreateSpecType_RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_RuleList)
	if !ok {
		that2, ok := that.(CreateSpecType_RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	return true
}
func (this *CreateSpecType_LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LegacyRuleList)
	if !ok {
		that2, ok := that.(CreateSpecType_LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRuleList.Equal(that1.LegacyRuleList) {
		return false
	}
	return true
}
func (this *CreateSpecType_AllowAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AllowAllRequests)
	if !ok {
		that2, ok := that.(CreateSpecType_AllowAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllRequests.Equal(that1.AllowAllRequests) {
		return false
	}
	return true
}
func (this *CreateSpecType_DenyAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DenyAllRequests)
	if !ok {
		that2, ok := that.(CreateSpecType_DenyAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllRequests.Equal(that1.DenyAllRequests) {
		return false
	}
	return true
}
func (this *CreateSpecType_InternallyGenerated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_InternallyGenerated)
	if !ok {
		that2, ok := that.(CreateSpecType_InternallyGenerated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InternallyGenerated.Equal(that1.InternallyGenerated) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyServer)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AllowList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DenyList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DenyList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DenyList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyList.Equal(that1.DenyList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_RuleList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LegacyRuleList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRuleList.Equal(that1.LegacyRuleList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AllowAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AllowAllRequests)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AllowAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllRequests.Equal(that1.AllowAllRequests) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DenyAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DenyAllRequests)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DenyAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllRequests.Equal(that1.DenyAllRequests) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_InternallyGenerated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_InternallyGenerated)
	if !ok {
		that2, ok := that.(ReplaceSpecType_InternallyGenerated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InternallyGenerated.Equal(that1.InternallyGenerated) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	if len(this.SimpleRules) != len(that1.SimpleRules) {
		return false
	}
	for i := range this.SimpleRules {
		if !this.SimpleRules[i].Equal(that1.SimpleRules[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyServer)
	if !ok {
		that2, ok := that.(GetSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *GetSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerName)
	if !ok {
		that2, ok := that.(GetSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GetSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(GetSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *GetSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AllowList)
	if !ok {
		that2, ok := that.(GetSpecType_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *GetSpecType_DenyList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DenyList)
	if !ok {
		that2, ok := that.(GetSpecType_DenyList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyList.Equal(that1.DenyList) {
		return false
	}
	return true
}
func (this *GetSpecType_RuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_RuleList)
	if !ok {
		that2, ok := that.(GetSpecType_RuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuleList.Equal(that1.RuleList) {
		return false
	}
	return true
}
func (this *GetSpecType_LegacyRuleList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LegacyRuleList)
	if !ok {
		that2, ok := that.(GetSpecType_LegacyRuleList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRuleList.Equal(that1.LegacyRuleList) {
		return false
	}
	return true
}
func (this *GetSpecType_AllowAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AllowAllRequests)
	if !ok {
		that2, ok := that.(GetSpecType_AllowAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowAllRequests.Equal(that1.AllowAllRequests) {
		return false
	}
	return true
}
func (this *GetSpecType_DenyAllRequests) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DenyAllRequests)
	if !ok {
		that2, ok := that.(GetSpecType_DenyAllRequests)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DenyAllRequests.Equal(that1.DenyAllRequests) {
		return false
	}
	return true
}
func (this *GetSpecType_InternallyGenerated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_InternallyGenerated)
	if !ok {
		that2, ok := that.(GetSpecType_InternallyGenerated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InternallyGenerated.Equal(that1.InternallyGenerated) {
		return false
	}
	return true
}
func (this *SimpleRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 37)
	s = append(s, "&service_policy.SimpleRule{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "MetricNameLabel: "+fmt.Sprintf("%#v", this.MetricNameLabel)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	if this.IpPrefixList != nil {
		s = append(s, "IpPrefixList: "+fmt.Sprintf("%#v", this.IpPrefixList)+",\n")
	}
	if this.DstIpPrefixList != nil {
		s = append(s, "DstIpPrefixList: "+fmt.Sprintf("%#v", this.DstIpPrefixList)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.AsnList != nil {
		s = append(s, "AsnList: "+fmt.Sprintf("%#v", this.AsnList)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ClientSelector != nil {
		s = append(s, "ClientSelector: "+fmt.Sprintf("%#v", this.ClientSelector)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.BotAction != nil {
		s = append(s, "BotAction: "+fmt.Sprintf("%#v", this.BotAction)+",\n")
	}
	if this.ContentRewriteAction != nil {
		s = append(s, "ContentRewriteAction: "+fmt.Sprintf("%#v", this.ContentRewriteAction)+",\n")
	}
	if this.ShapeProtectedEndpointAction != nil {
		s = append(s, "ShapeProtectedEndpointAction: "+fmt.Sprintf("%#v", this.ShapeProtectedEndpointAction)+",\n")
	}
	if this.RateLimiters != nil {
		s = append(s, "RateLimiters: "+fmt.Sprintf("%#v", this.RateLimiters)+",\n")
	}
	if this.RateLimiterSpecs != nil {
		s = append(s, "RateLimiterSpecs: "+fmt.Sprintf("%#v", this.RateLimiterSpecs)+",\n")
	}
	if this.MumAction != nil {
		s = append(s, "MumAction: "+fmt.Sprintf("%#v", this.MumAction)+",\n")
	}
	if this.IpReputationAction != nil {
		s = append(s, "IpReputationAction: "+fmt.Sprintf("%#v", this.IpReputationAction)+",\n")
	}
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	if this.IpMatcher != nil {
		s = append(s, "IpMatcher: "+fmt.Sprintf("%#v", this.IpMatcher)+",\n")
	}
	if this.AsnMatcher != nil {
		s = append(s, "AsnMatcher: "+fmt.Sprintf("%#v", this.AsnMatcher)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SourceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&service_policy.SourceList{")
	if this.PrefixList != nil {
		s = append(s, "PrefixList: "+fmt.Sprintf("%#v", this.PrefixList)+",\n")
	}
	if this.IpPrefixSet != nil {
		s = append(s, "IpPrefixSet: "+fmt.Sprintf("%#v", this.IpPrefixSet)+",\n")
	}
	if this.AsnList != nil {
		s = append(s, "AsnList: "+fmt.Sprintf("%#v", this.AsnList)+",\n")
	}
	if this.AsnSet != nil {
		s = append(s, "AsnSet: "+fmt.Sprintf("%#v", this.AsnSet)+",\n")
	}
	s = append(s, "CountryList: "+fmt.Sprintf("%#v", this.CountryList)+",\n")
	s = append(s, "TlsFingerprintClasses: "+fmt.Sprintf("%#v", this.TlsFingerprintClasses)+",\n")
	s = append(s, "TlsFingerprintValues: "+fmt.Sprintf("%#v", this.TlsFingerprintValues)+",\n")
	if this.DefaultActionChoice != nil {
		s = append(s, "DefaultActionChoice: "+fmt.Sprintf("%#v", this.DefaultActionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SourceList_DefaultActionNextPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.SourceList_DefaultActionNextPolicy{` +
		`DefaultActionNextPolicy:` + fmt.Sprintf("%#v", this.DefaultActionNextPolicy) + `}`}, ", ")
	return s
}
func (this *SourceList_DefaultActionDeny) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.SourceList_DefaultActionDeny{` +
		`DefaultActionDeny:` + fmt.Sprintf("%#v", this.DefaultActionDeny) + `}`}, ", ")
	return s
}
func (this *SourceList_DefaultActionAllow) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.SourceList_DefaultActionAllow{` +
		`DefaultActionAllow:` + fmt.Sprintf("%#v", this.DefaultActionAllow) + `}`}, ", ")
	return s
}
func (this *Rule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&service_policy.Rule{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&service_policy.RuleList{")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&service_policy.LegacyRuleList{")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&service_policy.GlobalSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.Role != nil {
		s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	}
	if this.DenyInfo != nil {
		s = append(s, "DenyInfo: "+fmt.Sprintf("%#v", this.DenyInfo)+",\n")
	}
	if this.DefaultForwardingClasses != nil {
		s = append(s, "DefaultForwardingClasses: "+fmt.Sprintf("%#v", this.DefaultForwardingClasses)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	if this.SimpleRules != nil {
		s = append(s, "SimpleRules: "+fmt.Sprintf("%#v", this.SimpleRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DenyList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_DenyList{` +
		`DenyList:` + fmt.Sprintf("%#v", this.DenyList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_RuleList{` +
		`RuleList:` + fmt.Sprintf("%#v", this.RuleList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_LegacyRuleList{` +
		`LegacyRuleList:` + fmt.Sprintf("%#v", this.LegacyRuleList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AllowAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_AllowAllRequests{` +
		`AllowAllRequests:` + fmt.Sprintf("%#v", this.AllowAllRequests) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DenyAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_DenyAllRequests{` +
		`DenyAllRequests:` + fmt.Sprintf("%#v", this.DenyAllRequests) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_InternallyGenerated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GlobalSpecType_InternallyGenerated{` +
		`InternallyGenerated:` + fmt.Sprintf("%#v", this.InternallyGenerated) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&service_policy.CreateSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DenyList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_DenyList{` +
		`DenyList:` + fmt.Sprintf("%#v", this.DenyList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_RuleList{` +
		`RuleList:` + fmt.Sprintf("%#v", this.RuleList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_LegacyRuleList{` +
		`LegacyRuleList:` + fmt.Sprintf("%#v", this.LegacyRuleList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AllowAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_AllowAllRequests{` +
		`AllowAllRequests:` + fmt.Sprintf("%#v", this.AllowAllRequests) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DenyAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_DenyAllRequests{` +
		`DenyAllRequests:` + fmt.Sprintf("%#v", this.DenyAllRequests) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_InternallyGenerated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.CreateSpecType_InternallyGenerated{` +
		`InternallyGenerated:` + fmt.Sprintf("%#v", this.InternallyGenerated) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&service_policy.ReplaceSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DenyList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_DenyList{` +
		`DenyList:` + fmt.Sprintf("%#v", this.DenyList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_RuleList{` +
		`RuleList:` + fmt.Sprintf("%#v", this.RuleList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_LegacyRuleList{` +
		`LegacyRuleList:` + fmt.Sprintf("%#v", this.LegacyRuleList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AllowAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_AllowAllRequests{` +
		`AllowAllRequests:` + fmt.Sprintf("%#v", this.AllowAllRequests) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DenyAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_DenyAllRequests{` +
		`DenyAllRequests:` + fmt.Sprintf("%#v", this.DenyAllRequests) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_InternallyGenerated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.ReplaceSpecType_InternallyGenerated{` +
		`InternallyGenerated:` + fmt.Sprintf("%#v", this.InternallyGenerated) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&service_policy.GetSpecType{")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	if this.SimpleRules != nil {
		s = append(s, "SimpleRules: "+fmt.Sprintf("%#v", this.SimpleRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DenyList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_DenyList{` +
		`DenyList:` + fmt.Sprintf("%#v", this.DenyList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_RuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_RuleList{` +
		`RuleList:` + fmt.Sprintf("%#v", this.RuleList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LegacyRuleList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_LegacyRuleList{` +
		`LegacyRuleList:` + fmt.Sprintf("%#v", this.LegacyRuleList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AllowAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_AllowAllRequests{` +
		`AllowAllRequests:` + fmt.Sprintf("%#v", this.AllowAllRequests) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DenyAllRequests) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_DenyAllRequests{` +
		`DenyAllRequests:` + fmt.Sprintf("%#v", this.DenyAllRequests) + `}`}, ", ")
	return s
}
func (this *GetSpecType_InternallyGenerated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy.GetSpecType_InternallyGenerated{` +
		`InternallyGenerated:` + fmt.Sprintf("%#v", this.InternallyGenerated) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SimpleRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AsnMatcher != nil {
		{
			size, err := m.AsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.IpMatcher != nil {
		{
			size, err := m.IpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.GotoPolicy) > 0 {
		for iNdEx := len(m.GotoPolicy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GotoPolicy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x82
		}
	}
	if m.IpReputationAction != nil {
		{
			size, err := m.IpReputationAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.MumAction != nil {
		{
			size, err := m.MumAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.RateLimiterSpecs) > 0 {
		for iNdEx := len(m.RateLimiterSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiterSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.RateLimiters) > 0 {
		for iNdEx := len(m.RateLimiters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if m.ShapeProtectedEndpointAction != nil {
		{
			size, err := m.ShapeProtectedEndpointAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.ContentRewriteAction != nil {
		{
			size, err := m.ContentRewriteAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.BotAction != nil {
		{
			size, err := m.BotAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.ClientSelector != nil {
		{
			size, err := m.ClientSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ClientRole != nil {
		{
			size, err := m.ClientRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ApiGroupMatcher != nil {
		{
			size, err := m.ApiGroupMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.TlsFingerprintMatcher != nil {
		{
			size, err := m.TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.MetricNameLabel) > 0 {
		i -= len(m.MetricNameLabel)
		copy(dAtA[i:], m.MetricNameLabel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MetricNameLabel)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.DstIpPrefixList != nil {
		{
			size, err := m.DstIpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.IpPrefixList != nil {
		{
			size, err := m.IpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.L4DestMatcher != nil {
		{
			size, err := m.L4DestMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.UrlMatcher != nil {
		{
			size, err := m.UrlMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Scheme) > 0 {
		for iNdEx := len(m.Scheme) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scheme[iNdEx])
			copy(dAtA[i:], m.Scheme[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Scheme[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.WafAction != nil {
		{
			size, err := m.WafAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.HttpMethod != nil {
		{
			size, err := m.HttpMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DomainMatcher != nil {
		{
			size, err := m.DomainMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultActionChoice != nil {
		{
			size := m.DefaultActionChoice.Size()
			i -= size
			if _, err := m.DefaultActionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.TlsFingerprintValues) > 0 {
		for iNdEx := len(m.TlsFingerprintValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TlsFingerprintValues[iNdEx])
			copy(dAtA[i:], m.TlsFingerprintValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsFingerprintValues[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TlsFingerprintClasses) > 0 {
		dAtA26 := make([]byte, len(m.TlsFingerprintClasses)*10)
		var j25 int
		for _, num := range m.TlsFingerprintClasses {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintTypes(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CountryList) > 0 {
		dAtA28 := make([]byte, len(m.CountryList)*10)
		var j27 int
		for _, num := range m.CountryList {
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintTypes(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AsnSet) > 0 {
		for iNdEx := len(m.AsnSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AsnSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.IpPrefixSet) > 0 {
		for iNdEx := len(m.IpPrefixSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpPrefixSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PrefixList != nil {
		{
			size, err := m.PrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SourceList_DefaultActionNextPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceList_DefaultActionNextPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultActionNextPolicy != nil {
		{
			size, err := m.DefaultActionNextPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *SourceList_DefaultActionDeny) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceList_DefaultActionDeny) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultActionDeny != nil {
		{
			size, err := m.DefaultActionDeny.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *SourceList_DefaultActionAllow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceList_DefaultActionAllow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultActionAllow != nil {
		{
			size, err := m.DefaultActionAllow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RuleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LegacyRuleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SimpleRules) > 0 {
		for iNdEx := len(m.SimpleRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SimpleRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xca
		}
	}
	if m.ViewInternal != nil {
		{
			size, err := m.ViewInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.DefaultForwardingClasses) > 0 {
		for iNdEx := len(m.DefaultForwardingClasses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DefaultForwardingClasses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.DenyInfo != nil {
		{
			size, err := m.DenyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Algo != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DenyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DenyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyList != nil {
		{
			size, err := m.DenyList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRuleList != nil {
		{
			size, err := m.LegacyRuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_InternallyGenerated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_InternallyGenerated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternallyGenerated != nil {
		{
			size, err := m.InternallyGenerated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AllowAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AllowAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllRequests != nil {
		{
			size, err := m.AllowAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DenyAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DenyAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllRequests != nil {
		{
			size, err := m.DenyAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Algo != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DenyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DenyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyList != nil {
		{
			size, err := m.DenyList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRuleList != nil {
		{
			size, err := m.LegacyRuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_InternallyGenerated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_InternallyGenerated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternallyGenerated != nil {
		{
			size, err := m.InternallyGenerated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AllowAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AllowAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllRequests != nil {
		{
			size, err := m.AllowAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DenyAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DenyAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllRequests != nil {
		{
			size, err := m.DenyAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Algo != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DenyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DenyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyList != nil {
		{
			size, err := m.DenyList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRuleList != nil {
		{
			size, err := m.LegacyRuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_InternallyGenerated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_InternallyGenerated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternallyGenerated != nil {
		{
			size, err := m.InternallyGenerated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AllowAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AllowAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllRequests != nil {
		{
			size, err := m.AllowAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DenyAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DenyAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllRequests != nil {
		{
			size, err := m.DenyAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SimpleRules) > 0 {
		for iNdEx := len(m.SimpleRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SimpleRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xca
		}
	}
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Algo != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Algo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DenyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DenyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyList != nil {
		{
			size, err := m.DenyList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_RuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_RuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuleList != nil {
		{
			size, err := m.RuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_LegacyRuleList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_LegacyRuleList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRuleList != nil {
		{
			size, err := m.LegacyRuleList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_InternallyGenerated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_InternallyGenerated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InternallyGenerated != nil {
		{
			size, err := m.InternallyGenerated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AllowAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AllowAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowAllRequests != nil {
		{
			size, err := m.AllowAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DenyAllRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DenyAllRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DenyAllRequests != nil {
		{
			size, err := m.DenyAllRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SimpleRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.MetricNameLabel)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BotAction != nil {
		l = m.BotAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ContentRewriteAction != nil {
		l = m.ContentRewriteAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ShapeProtectedEndpointAction != nil {
		l = m.ShapeProtectedEndpointAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiters) > 0 {
		for _, e := range m.RateLimiters {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RateLimiterSpecs) > 0 {
		for _, e := range m.RateLimiterSpecs {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.MumAction != nil {
		l = m.MumAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IpReputationAction != nil {
		l = m.IpReputationAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SourceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixList != nil {
		l = m.PrefixList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.IpPrefixSet) > 0 {
		for _, e := range m.IpPrefixSet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AsnSet) > 0 {
		for _, e := range m.AsnSet {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CountryList) > 0 {
		l = 0
		for _, e := range m.CountryList {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.TlsFingerprintClasses) > 0 {
		l = 0
		for _, e := range m.TlsFingerprintClasses {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.TlsFingerprintValues) > 0 {
		for _, s := range m.TlsFingerprintValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DefaultActionChoice != nil {
		n += m.DefaultActionChoice.Size()
	}
	return n
}

func (m *SourceList_DefaultActionNextPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultActionNextPolicy != nil {
		l = m.DefaultActionNextPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SourceList_DefaultActionDeny) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultActionDeny != nil {
		l = m.DefaultActionDeny.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SourceList_DefaultActionAllow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultActionAllow != nil {
		l = m.DefaultActionAllow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DenyInfo != nil {
		l = m.DenyInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DefaultForwardingClasses) > 0 {
		for _, e := range m.DefaultForwardingClasses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.SimpleRules) > 0 {
		for _, e := range m.SimpleRules {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DenyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyList != nil {
		l = m.DenyList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRuleList != nil {
		l = m.LegacyRuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_InternallyGenerated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternallyGenerated != nil {
		l = m.InternallyGenerated.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AllowAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllRequests != nil {
		l = m.AllowAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DenyAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllRequests != nil {
		l = m.DenyAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	return n
}

func (m *CreateSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DenyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyList != nil {
		l = m.DenyList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRuleList != nil {
		l = m.LegacyRuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_InternallyGenerated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternallyGenerated != nil {
		l = m.InternallyGenerated.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AllowAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllRequests != nil {
		l = m.AllowAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DenyAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllRequests != nil {
		l = m.DenyAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DenyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyList != nil {
		l = m.DenyList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRuleList != nil {
		l = m.LegacyRuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_InternallyGenerated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternallyGenerated != nil {
		l = m.InternallyGenerated.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AllowAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllRequests != nil {
		l = m.AllowAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DenyAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllRequests != nil {
		l = m.DenyAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + sovTypes(uint64(m.Algo))
	}
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	if len(m.SimpleRules) > 0 {
		for _, e := range m.SimpleRules {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DenyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyList != nil {
		l = m.DenyList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_RuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleList != nil {
		l = m.RuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LegacyRuleList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRuleList != nil {
		l = m.LegacyRuleList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_InternallyGenerated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternallyGenerated != nil {
		l = m.InternallyGenerated.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AllowAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllRequests != nil {
		l = m.AllowAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DenyAllRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DenyAllRequests != nil {
		l = m.DenyAllRequests.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SimpleRule) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(fmt.Sprintf("%v", f), "HeaderMatcherType", "policy.HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForRateLimiters := "[]*ObjectRefType{"
	for _, f := range this.RateLimiters {
		repeatedStringForRateLimiters += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiters += "}"
	repeatedStringForRateLimiterSpecs := "[]*GlobalSpecType{"
	for _, f := range this.RateLimiterSpecs {
		repeatedStringForRateLimiterSpecs += strings.Replace(fmt.Sprintf("%v", f), "GlobalSpecType", "rate_limiter.GlobalSpecType", 1) + ","
	}
	repeatedStringForRateLimiterSpecs += "}"
	repeatedStringForGotoPolicy := "[]*ObjectRefType{"
	for _, f := range this.GotoPolicy {
		repeatedStringForGotoPolicy += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForGotoPolicy += "}"
	s := strings.Join([]string{`&SimpleRule{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "policy.PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "policy.HttpMethodMatcherType", 1) + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "policy.WafAction", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "policy.URLMatcherType", 1) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "policy.L4DestMatcherType", 1) + `,`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`MetricNameLabel:` + fmt.Sprintf("%v", this.MetricNameLabel) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "policy.TlsFingerprintMatcherType", 1) + `,`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "policy.StringMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "policy.RoleMatcherType", 1) + `,`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`BotAction:` + strings.Replace(fmt.Sprintf("%v", this.BotAction), "BotAction", "policy.BotAction", 1) + `,`,
		`ContentRewriteAction:` + strings.Replace(fmt.Sprintf("%v", this.ContentRewriteAction), "ContentRewriteAction", "policy.ContentRewriteAction", 1) + `,`,
		`ShapeProtectedEndpointAction:` + strings.Replace(fmt.Sprintf("%v", this.ShapeProtectedEndpointAction), "ShapeProtectedEndpointAction", "policy.ShapeProtectedEndpointAction", 1) + `,`,
		`RateLimiters:` + repeatedStringForRateLimiters + `,`,
		`RateLimiterSpecs:` + repeatedStringForRateLimiterSpecs + `,`,
		`MumAction:` + strings.Replace(fmt.Sprintf("%v", this.MumAction), "ModifyAction", "policy.ModifyAction", 1) + `,`,
		`IpReputationAction:` + strings.Replace(fmt.Sprintf("%v", this.IpReputationAction), "ModifyAction", "policy.ModifyAction", 1) + `,`,
		`GotoPolicy:` + repeatedStringForGotoPolicy + `,`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SourceList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIpPrefixSet := "[]*ObjectRefType{"
	for _, f := range this.IpPrefixSet {
		repeatedStringForIpPrefixSet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForIpPrefixSet += "}"
	repeatedStringForAsnSet := "[]*ObjectRefType{"
	for _, f := range this.AsnSet {
		repeatedStringForAsnSet += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForAsnSet += "}"
	s := strings.Join([]string{`&SourceList{`,
		`PrefixList:` + strings.Replace(fmt.Sprintf("%v", this.PrefixList), "PrefixStringListType", "views.PrefixStringListType", 1) + `,`,
		`IpPrefixSet:` + repeatedStringForIpPrefixSet + `,`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`AsnSet:` + repeatedStringForAsnSet + `,`,
		`CountryList:` + fmt.Sprintf("%v", this.CountryList) + `,`,
		`TlsFingerprintClasses:` + fmt.Sprintf("%v", this.TlsFingerprintClasses) + `,`,
		`TlsFingerprintValues:` + fmt.Sprintf("%v", this.TlsFingerprintValues) + `,`,
		`DefaultActionChoice:` + fmt.Sprintf("%v", this.DefaultActionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SourceList_DefaultActionNextPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SourceList_DefaultActionNextPolicy{`,
		`DefaultActionNextPolicy:` + strings.Replace(fmt.Sprintf("%v", this.DefaultActionNextPolicy), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SourceList_DefaultActionDeny) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SourceList_DefaultActionDeny{`,
		`DefaultActionDeny:` + strings.Replace(fmt.Sprintf("%v", this.DefaultActionDeny), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SourceList_DefaultActionAllow) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SourceList_DefaultActionAllow{`,
		`DefaultActionAllow:` + strings.Replace(fmt.Sprintf("%v", this.DefaultActionAllow), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Rule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Rule{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`Spec:` + strings.Replace(fmt.Sprintf("%v", this.Spec), "GlobalSpecType", "service_policy_rule.GlobalSpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RuleList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*Rule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "Rule", "Rule", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&RuleList{`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*ObjectRefType{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&LegacyRuleList{`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*ObjectRefType{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRules += "}"
	repeatedStringForDefaultForwardingClasses := "[]*ObjectRefType{"
	for _, f := range this.DefaultForwardingClasses {
		repeatedStringForDefaultForwardingClasses += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForDefaultForwardingClasses += "}"
	repeatedStringForSimpleRules := "[]*SimpleRule{"
	for _, f := range this.SimpleRules {
		repeatedStringForSimpleRules += strings.Replace(f.String(), "SimpleRule", "SimpleRule", 1) + ","
	}
	repeatedStringForSimpleRules += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + repeatedStringForRules + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`Role:` + strings.Replace(fmt.Sprintf("%v", this.Role), "RoleMatcherType", "policy.RoleMatcherType", 1) + `,`,
		`DenyInfo:` + strings.Replace(fmt.Sprintf("%v", this.DenyInfo), "DenyInformation", "policy.DenyInformation", 1) + `,`,
		`DefaultForwardingClasses:` + repeatedStringForDefaultForwardingClasses + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`SimpleRules:` + repeatedStringForSimpleRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DenyList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DenyList{`,
		`DenyList:` + strings.Replace(fmt.Sprintf("%v", this.DenyList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_RuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_RuleList{`,
		`RuleList:` + strings.Replace(fmt.Sprintf("%v", this.RuleList), "RuleList", "RuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LegacyRuleList{`,
		`LegacyRuleList:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRuleList), "LegacyRuleList", "LegacyRuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_InternallyGenerated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_InternallyGenerated{`,
		`InternallyGenerated:` + strings.Replace(fmt.Sprintf("%v", this.InternallyGenerated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AllowAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AllowAllRequests{`,
		`AllowAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DenyAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DenyAllRequests{`,
		`DenyAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DenyList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DenyList{`,
		`DenyList:` + strings.Replace(fmt.Sprintf("%v", this.DenyList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_RuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_RuleList{`,
		`RuleList:` + strings.Replace(fmt.Sprintf("%v", this.RuleList), "RuleList", "RuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LegacyRuleList{`,
		`LegacyRuleList:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRuleList), "LegacyRuleList", "LegacyRuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_InternallyGenerated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_InternallyGenerated{`,
		`InternallyGenerated:` + strings.Replace(fmt.Sprintf("%v", this.InternallyGenerated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AllowAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AllowAllRequests{`,
		`AllowAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DenyAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DenyAllRequests{`,
		`DenyAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DenyList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DenyList{`,
		`DenyList:` + strings.Replace(fmt.Sprintf("%v", this.DenyList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_RuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_RuleList{`,
		`RuleList:` + strings.Replace(fmt.Sprintf("%v", this.RuleList), "RuleList", "RuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LegacyRuleList{`,
		`LegacyRuleList:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRuleList), "LegacyRuleList", "LegacyRuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_InternallyGenerated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_InternallyGenerated{`,
		`InternallyGenerated:` + strings.Replace(fmt.Sprintf("%v", this.InternallyGenerated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AllowAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AllowAllRequests{`,
		`AllowAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DenyAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DenyAllRequests{`,
		`DenyAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*ObjectRefType{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRules += "}"
	repeatedStringForSimpleRules := "[]*SimpleRule{"
	for _, f := range this.SimpleRules {
		repeatedStringForSimpleRules += strings.Replace(f.String(), "SimpleRule", "SimpleRule", 1) + ","
	}
	repeatedStringForSimpleRules += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + repeatedStringForRules + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`SimpleRules:` + repeatedStringForSimpleRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DenyList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DenyList{`,
		`DenyList:` + strings.Replace(fmt.Sprintf("%v", this.DenyList), "SourceList", "SourceList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_RuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_RuleList{`,
		`RuleList:` + strings.Replace(fmt.Sprintf("%v", this.RuleList), "RuleList", "RuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LegacyRuleList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LegacyRuleList{`,
		`LegacyRuleList:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRuleList), "LegacyRuleList", "LegacyRuleList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_InternallyGenerated) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_InternallyGenerated{`,
		`InternallyGenerated:` + strings.Replace(fmt.Sprintf("%v", this.InternallyGenerated), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AllowAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AllowAllRequests{`,
		`AllowAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.AllowAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DenyAllRequests) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DenyAllRequests{`,
		`DenyAllRequests:` + strings.Replace(fmt.Sprintf("%v", this.DenyAllRequests), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SimpleRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= policy.RuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &policy.MatcherType{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpPrefixList == nil {
				m.IpPrefixList = &policy.PrefixMatchList{}
			}
			if err := m.IpPrefixList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstIpPrefixList == nil {
				m.DstIpPrefixList = &policy.PrefixMatchList{}
			}
			if err := m.DstIpPrefixList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricNameLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricNameLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsnList == nil {
				m.AsnList = &policy.AsnMatchList{}
			}
			if err := m.AsnList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientSelector == nil {
				m.ClientSelector = &schema.LabelSelectorType{}
			}
			if err := m.ClientSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &schema.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BotAction == nil {
				m.BotAction = &policy.BotAction{}
			}
			if err := m.BotAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentRewriteAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContentRewriteAction == nil {
				m.ContentRewriteAction = &policy.ContentRewriteAction{}
			}
			if err := m.ContentRewriteAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShapeProtectedEndpointAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShapeProtectedEndpointAction == nil {
				m.ShapeProtectedEndpointAction = &policy.ShapeProtectedEndpointAction{}
			}
			if err := m.ShapeProtectedEndpointAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiters = append(m.RateLimiters, &schema.ObjectRefType{})
			if err := m.RateLimiters[len(m.RateLimiters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiterSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiterSpecs = append(m.RateLimiterSpecs, &rate_limiter.GlobalSpecType{})
			if err := m.RateLimiterSpecs[len(m.RateLimiterSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MumAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MumAction == nil {
				m.MumAction = &policy.ModifyAction{}
			}
			if err := m.MumAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReputationAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpReputationAction == nil {
				m.IpReputationAction = &policy.ModifyAction{}
			}
			if err := m.IpReputationAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &schema.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpMatcher == nil {
				m.IpMatcher = &policy.IpMatcherType{}
			}
			if err := m.IpMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsnMatcher == nil {
				m.AsnMatcher = &policy.AsnMatcherType{}
			}
			if err := m.AsnMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrefixList == nil {
				m.PrefixList = &views.PrefixStringListType{}
			}
			if err := m.PrefixList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefixSet = append(m.IpPrefixSet, &views.ObjectRefType{})
			if err := m.IpPrefixSet[len(m.IpPrefixSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsnList == nil {
				m.AsnList = &policy.AsnMatchList{}
			}
			if err := m.AsnList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsnSet = append(m.AsnSet, &views.ObjectRefType{})
			if err := m.AsnSet[len(m.AsnSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v policy.CountryCode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= policy.CountryCode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CountryList = append(m.CountryList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.CountryList) == 0 {
					m.CountryList = make([]policy.CountryCode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v policy.CountryCode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= policy.CountryCode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CountryList = append(m.CountryList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryList", wireType)
			}
		case 7:
			if wireType == 0 {
				var v policy.KnownTlsFingerprintClass
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= policy.KnownTlsFingerprintClass(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TlsFingerprintClasses = append(m.TlsFingerprintClasses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.TlsFingerprintClasses) == 0 {
					m.TlsFingerprintClasses = make([]policy.KnownTlsFingerprintClass, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v policy.KnownTlsFingerprintClass
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= policy.KnownTlsFingerprintClass(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TlsFingerprintClasses = append(m.TlsFingerprintClasses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintClasses", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsFingerprintValues = append(m.TlsFingerprintValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultActionNextPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultActionChoice = &SourceList_DefaultActionNextPolicy{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultActionDeny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultActionChoice = &SourceList_DefaultActionDeny{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultActionAllow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultActionChoice = &SourceList_DefaultActionAllow{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &service_policy_rule.GlobalSpecType{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &Rule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LegacyRuleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LegacyRuleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LegacyRuleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &schema.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= policy.RuleCombiningAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &GlobalSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &schema.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &policy.RoleMatcherType{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenyInfo == nil {
				m.DenyInfo = &policy.DenyInformation{}
			}
			if err := m.DenyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultForwardingClasses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultForwardingClasses = append(m.DefaultForwardingClasses, &schema.ObjectRefType{})
			if err := m.DefaultForwardingClasses[len(m.DefaultForwardingClasses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_AnyServer{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_AllowList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_DenyList{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_RuleList{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyRuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_LegacyRuleList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternallyGenerated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_InternallyGenerated{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_AllowAllRequests{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_DenyAllRequests{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SimpleRules = append(m.SimpleRules, &SimpleRule{})
			if err := m.SimpleRules[len(m.SimpleRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= policy.RuleCombiningAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &CreateSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_AnyServer{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_AllowList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_DenyList{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_RuleList{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyRuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_LegacyRuleList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternallyGenerated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_InternallyGenerated{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_AllowAllRequests{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &CreateSpecType_DenyAllRequests{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= policy.RuleCombiningAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &ReplaceSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_AnyServer{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_AllowList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_DenyList{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_RuleList{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyRuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_LegacyRuleList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternallyGenerated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_InternallyGenerated{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_AllowAllRequests{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_DenyAllRequests{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= policy.RuleCombiningAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &GetSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &schema.ObjectRefType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_AnyServer{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_AllowList{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_DenyList{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_RuleList{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyRuleList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_LegacyRuleList{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternallyGenerated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_InternallyGenerated{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_AllowAllRequests{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenyAllRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_DenyAllRequests{v}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SimpleRules = append(m.SimpleRules, &SimpleRule{})
			if err := m.SimpleRules[len(m.SimpleRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
