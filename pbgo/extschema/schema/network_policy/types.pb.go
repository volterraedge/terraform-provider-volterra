// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/network_policy/types.proto

package network_policy

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	network_policy_rule "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_policy_rule"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Applications
//
// x-displayName: "Applications"
// Application protocols like HTTP, SNMP
type ApplicationEnumType int32

const (
	// x-displayName: "HTTP"
	APPLICATION_HTTP ApplicationEnumType = 0
	// x-displayName: "HTTPS"
	APPLICATION_HTTPS ApplicationEnumType = 1
	// x-displayName: "SNMP"
	APPLICATION_SNMP ApplicationEnumType = 2
	// x-displayName: "DNS"
	APPLICATION_DNS ApplicationEnumType = 3
)

var ApplicationEnumType_name = map[int32]string{
	0: "APPLICATION_HTTP",
	1: "APPLICATION_HTTPS",
	2: "APPLICATION_SNMP",
	3: "APPLICATION_DNS",
}

var ApplicationEnumType_value = map[string]int32{
	"APPLICATION_HTTP":  0,
	"APPLICATION_HTTPS": 1,
	"APPLICATION_SNMP":  2,
	"APPLICATION_DNS":   3,
}

func (ApplicationEnumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{0}
}

// Endpoint Choice
//
// x-displayName: "Endpoint Choice"
// Shape of the endpoint choices for a view
type EndpointChoiceType struct {
	// endpoint_choice
	//
	// x-displayName: "Endpoint(s)"
	// x-required
	// Policy is for set of endpoints defined, rules are applied to connections to or from these endpoints.
	//
	// Types that are valid to be assigned to EndpointChoice:
	//	*EndpointChoiceType_PrefixList
	//	*EndpointChoiceType_Any
	//	*EndpointChoiceType_OutsideEndpoints
	//	*EndpointChoiceType_InsideEndpoints
	//	*EndpointChoiceType_Interface
	//	*EndpointChoiceType_Namespace
	//	*EndpointChoiceType_LabelSelector
	EndpointChoice isEndpointChoiceType_EndpointChoice `protobuf_oneof:"endpoint_choice"`
}

func (m *EndpointChoiceType) Reset()      { *m = EndpointChoiceType{} }
func (*EndpointChoiceType) ProtoMessage() {}
func (*EndpointChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{0}
}
func (m *EndpointChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndpointChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EndpointChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndpointChoiceType.Merge(m, src)
}
func (m *EndpointChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *EndpointChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_EndpointChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_EndpointChoiceType proto.InternalMessageInfo

type isEndpointChoiceType_EndpointChoice interface {
	isEndpointChoiceType_EndpointChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type EndpointChoiceType_PrefixList struct {
	PrefixList *views.PrefixStringListType `protobuf:"bytes,1,opt,name=prefix_list,json=prefixList,proto3,oneof" json:"prefix_list,omitempty"`
}
type EndpointChoiceType_Any struct {
	Any *schema.Empty `protobuf:"bytes,2,opt,name=any,proto3,oneof" json:"any,omitempty"`
}
type EndpointChoiceType_OutsideEndpoints struct {
	OutsideEndpoints *schema.Empty `protobuf:"bytes,3,opt,name=outside_endpoints,json=outsideEndpoints,proto3,oneof" json:"outside_endpoints,omitempty"`
}
type EndpointChoiceType_InsideEndpoints struct {
	InsideEndpoints *schema.Empty `protobuf:"bytes,4,opt,name=inside_endpoints,json=insideEndpoints,proto3,oneof" json:"inside_endpoints,omitempty"`
}
type EndpointChoiceType_Interface struct {
	Interface *views.ObjectRefType `protobuf:"bytes,5,opt,name=interface,proto3,oneof" json:"interface,omitempty"`
}
type EndpointChoiceType_Namespace struct {
	Namespace string `protobuf:"bytes,6,opt,name=namespace,proto3,oneof" json:"namespace,omitempty"`
}
type EndpointChoiceType_LabelSelector struct {
	LabelSelector *schema.LabelSelectorType `protobuf:"bytes,9,opt,name=label_selector,json=labelSelector,proto3,oneof" json:"label_selector,omitempty"`
}

func (*EndpointChoiceType_PrefixList) isEndpointChoiceType_EndpointChoice()       {}
func (*EndpointChoiceType_Any) isEndpointChoiceType_EndpointChoice()              {}
func (*EndpointChoiceType_OutsideEndpoints) isEndpointChoiceType_EndpointChoice() {}
func (*EndpointChoiceType_InsideEndpoints) isEndpointChoiceType_EndpointChoice()  {}
func (*EndpointChoiceType_Interface) isEndpointChoiceType_EndpointChoice()        {}
func (*EndpointChoiceType_Namespace) isEndpointChoiceType_EndpointChoice()        {}
func (*EndpointChoiceType_LabelSelector) isEndpointChoiceType_EndpointChoice()    {}

func (m *EndpointChoiceType) GetEndpointChoice() isEndpointChoiceType_EndpointChoice {
	if m != nil {
		return m.EndpointChoice
	}
	return nil
}

func (m *EndpointChoiceType) GetPrefixList() *views.PrefixStringListType {
	if x, ok := m.GetEndpointChoice().(*EndpointChoiceType_PrefixList); ok {
		return x.PrefixList
	}
	return nil
}

func (m *EndpointChoiceType) GetAny() *schema.Empty {
	if x, ok := m.GetEndpointChoice().(*EndpointChoiceType_Any); ok {
		return x.Any
	}
	return nil
}

func (m *EndpointChoiceType) GetOutsideEndpoints() *schema.Empty {
	if x, ok := m.GetEndpointChoice().(*EndpointChoiceType_OutsideEndpoints); ok {
		return x.OutsideEndpoints
	}
	return nil
}

func (m *EndpointChoiceType) GetInsideEndpoints() *schema.Empty {
	if x, ok := m.GetEndpointChoice().(*EndpointChoiceType_InsideEndpoints); ok {
		return x.InsideEndpoints
	}
	return nil
}

func (m *EndpointChoiceType) GetInterface() *views.ObjectRefType {
	if x, ok := m.GetEndpointChoice().(*EndpointChoiceType_Interface); ok {
		return x.Interface
	}
	return nil
}

func (m *EndpointChoiceType) GetNamespace() string {
	if x, ok := m.GetEndpointChoice().(*EndpointChoiceType_Namespace); ok {
		return x.Namespace
	}
	return ""
}

func (m *EndpointChoiceType) GetLabelSelector() *schema.LabelSelectorType {
	if x, ok := m.GetEndpointChoice().(*EndpointChoiceType_LabelSelector); ok {
		return x.LabelSelector
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EndpointChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EndpointChoiceType_PrefixList)(nil),
		(*EndpointChoiceType_Any)(nil),
		(*EndpointChoiceType_OutsideEndpoints)(nil),
		(*EndpointChoiceType_InsideEndpoints)(nil),
		(*EndpointChoiceType_Interface)(nil),
		(*EndpointChoiceType_Namespace)(nil),
		(*EndpointChoiceType_LabelSelector)(nil),
	}
}

// Applications
//
// x-displayName: "Applications"
// Application protocols like HTTP, SNMP
type ApplicationsType struct {
	// Applications
	//
	// x-displayName: "Application Protocols"
	// Application protocols like HTTP, SNMP
	Applications []ApplicationEnumType `protobuf:"varint,1,rep,packed,name=applications,proto3,enum=ves.io.schema.network_policy.ApplicationEnumType" json:"applications,omitempty"`
}

func (m *ApplicationsType) Reset()      { *m = ApplicationsType{} }
func (*ApplicationsType) ProtoMessage() {}
func (*ApplicationsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{1}
}
func (m *ApplicationsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ApplicationsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationsType.Merge(m, src)
}
func (m *ApplicationsType) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationsType) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationsType.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationsType proto.InternalMessageInfo

func (m *ApplicationsType) GetApplications() []ApplicationEnumType {
	if m != nil {
		return m.Applications
	}
	return nil
}

// Protocol and Port
//
// x-displayName: "Protocol and Port"
// Protocol and Port ranges
type ProtocolPortType struct {
	// protocol
	//
	// x-displayName: "Protocol"
	// Protocol in IP packet to be used as match criteria
	// Values are tcp, udp, and icmp
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// ports
	//
	// x-displayName: "List of Port Ranges"
	// x-example: "100-200"
	// List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192
	PortRanges []string `protobuf:"bytes,2,rep,name=port_ranges,json=portRanges,proto3" json:"port_ranges,omitempty"`
}

func (m *ProtocolPortType) Reset()      { *m = ProtocolPortType{} }
func (*ProtocolPortType) ProtoMessage() {}
func (*ProtocolPortType) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{2}
}
func (m *ProtocolPortType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolPortType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtocolPortType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolPortType.Merge(m, src)
}
func (m *ProtocolPortType) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolPortType) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolPortType.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolPortType proto.InternalMessageInfo

func (m *ProtocolPortType) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ProtocolPortType) GetPortRanges() []string {
	if m != nil {
		return m.PortRanges
	}
	return nil
}

// Network Policy Rule
//
// x-displayName: "Network Policy Rule"
// Shape of Network Policy Rule
type NetworkPolicyRuleType struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,25,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "mypolicy-allow-htpp"
	// Rule Name that will be used to query metrics for this rule.
	RuleName string `protobuf:"bytes,10,opt,name=rule_name,json=ruleName,proto3" json:"rule_name,omitempty"`
	// Description
	//
	// x-displayName: "Description"
	// x-example: "Rule to block outside ip"
	// Human readable description for the rule
	RuleDescription string `protobuf:"bytes,24,opt,name=rule_description,json=ruleDescription,proto3" json:"rule_description,omitempty"`
	// action
	//
	// x-displayName: "Action"
	// Action to be taken at rule match. Currently supported actions are Allow and Deny
	Action network_policy_rule.NetworkPolicyRuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.network_policy_rule.NetworkPolicyRuleAction" json:"action,omitempty"`
	// adv_action
	//
	// x-displayName: "Logging Action"
	// Enable or disable logging.
	AdvAction *network_policy_rule.NetworkPolicyRuleAdvancedAction `protobuf:"bytes,26,opt,name=adv_action,json=advAction,proto3" json:"adv_action,omitempty"`
	// Other Endpoint
	//
	// x-displayName: "Select Other Endpoint"
	// Other endpoint of ingress or egress session with policy endpoint of network policy.
	// If network policy rule is a ingress rule in network policy then other
	// endpoint indicates the source endpoint from which session is initiated. If network policy rule
	// is a egress rule in network policy then other endpoint indicates the destination endpoint to which
	// session is initiated from policy endpoint.
	//
	// Types that are valid to be assigned to OtherEndpoint:
	//	*NetworkPolicyRuleType_Any
	//	*NetworkPolicyRuleType_PrefixList
	//	*NetworkPolicyRuleType_OutsideEndpoints
	//	*NetworkPolicyRuleType_InsideEndpoints
	//	*NetworkPolicyRuleType_Namespace
	//	*NetworkPolicyRuleType_LabelSelector
	//	*NetworkPolicyRuleType_IpPrefixSet
	OtherEndpoint isNetworkPolicyRuleType_OtherEndpoint `protobuf_oneof:"other_endpoint"`
	// Traffic Type
	//
	// x-displayName: "Select Type of Traffic to Match"
	// Select type of traffic to match
	//
	// Types that are valid to be assigned to TrafficChoice:
	//	*NetworkPolicyRuleType_AllTraffic
	//	*NetworkPolicyRuleType_AllTcpTraffic
	//	*NetworkPolicyRuleType_AllUdpTraffic
	//	*NetworkPolicyRuleType_Applications
	//	*NetworkPolicyRuleType_ProtocolPortRange
	TrafficChoice isNetworkPolicyRuleType_TrafficChoice `protobuf_oneof:"traffic_choice"`
	// label matcher
	//
	// x-displayName: "Keys for Label Match"
	// x-example: "['site']"
	// list of label keys to be for which label values will be matched
	// Keys are "site" and rule lets "web" talk to "db", site in (abc, xyz) then "web" in site "abc"
	// can talk to "db" in site "abc" and can not talk to "db" in site "xyz"
	Keys []string `protobuf:"bytes,23,rep,name=keys,proto3" json:"keys,omitempty"`
	// label matcher
	//
	// x-displayName: "Label Matcher"
	// x-example: "['environment', 'location', 'deployment']"
	// A list of label keys that identify the label values that need to be the same for the source and destination endpoints. Note that the actual label values are
	// not specified here, just the label keys. This facilitates reuse of policies across multiple dimensions such as deployment, environment, and location.
	LabelMatcher *schema.LabelMatcherType `protobuf:"bytes,27,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
}

func (m *NetworkPolicyRuleType) Reset()      { *m = NetworkPolicyRuleType{} }
func (*NetworkPolicyRuleType) ProtoMessage() {}
func (*NetworkPolicyRuleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{3}
}
func (m *NetworkPolicyRuleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkPolicyRuleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkPolicyRuleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkPolicyRuleType.Merge(m, src)
}
func (m *NetworkPolicyRuleType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkPolicyRuleType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkPolicyRuleType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkPolicyRuleType proto.InternalMessageInfo

type isNetworkPolicyRuleType_OtherEndpoint interface {
	isNetworkPolicyRuleType_OtherEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isNetworkPolicyRuleType_TrafficChoice interface {
	isNetworkPolicyRuleType_TrafficChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NetworkPolicyRuleType_Any struct {
	Any *schema.Empty `protobuf:"bytes,11,opt,name=any,proto3,oneof" json:"any,omitempty"`
}
type NetworkPolicyRuleType_PrefixList struct {
	PrefixList *views.PrefixStringListType `protobuf:"bytes,12,opt,name=prefix_list,json=prefixList,proto3,oneof" json:"prefix_list,omitempty"`
}
type NetworkPolicyRuleType_OutsideEndpoints struct {
	OutsideEndpoints *schema.Empty `protobuf:"bytes,13,opt,name=outside_endpoints,json=outsideEndpoints,proto3,oneof" json:"outside_endpoints,omitempty"`
}
type NetworkPolicyRuleType_InsideEndpoints struct {
	InsideEndpoints *schema.Empty `protobuf:"bytes,14,opt,name=inside_endpoints,json=insideEndpoints,proto3,oneof" json:"inside_endpoints,omitempty"`
}
type NetworkPolicyRuleType_Namespace struct {
	Namespace string `protobuf:"bytes,15,opt,name=namespace,proto3,oneof" json:"namespace,omitempty"`
}
type NetworkPolicyRuleType_LabelSelector struct {
	LabelSelector *schema.LabelSelectorType `protobuf:"bytes,16,opt,name=label_selector,json=labelSelector,proto3,oneof" json:"label_selector,omitempty"`
}
type NetworkPolicyRuleType_IpPrefixSet struct {
	IpPrefixSet *schema.IpPrefixSetRefType `protobuf:"bytes,5,opt,name=ip_prefix_set,json=ipPrefixSet,proto3,oneof" json:"ip_prefix_set,omitempty"`
}
type NetworkPolicyRuleType_AllTraffic struct {
	AllTraffic *schema.Empty `protobuf:"bytes,18,opt,name=all_traffic,json=allTraffic,proto3,oneof" json:"all_traffic,omitempty"`
}
type NetworkPolicyRuleType_AllTcpTraffic struct {
	AllTcpTraffic *schema.Empty `protobuf:"bytes,19,opt,name=all_tcp_traffic,json=allTcpTraffic,proto3,oneof" json:"all_tcp_traffic,omitempty"`
}
type NetworkPolicyRuleType_AllUdpTraffic struct {
	AllUdpTraffic *schema.Empty `protobuf:"bytes,20,opt,name=all_udp_traffic,json=allUdpTraffic,proto3,oneof" json:"all_udp_traffic,omitempty"`
}
type NetworkPolicyRuleType_Applications struct {
	Applications *ApplicationsType `protobuf:"bytes,21,opt,name=applications,proto3,oneof" json:"applications,omitempty"`
}
type NetworkPolicyRuleType_ProtocolPortRange struct {
	ProtocolPortRange *ProtocolPortType `protobuf:"bytes,22,opt,name=protocol_port_range,json=protocolPortRange,proto3,oneof" json:"protocol_port_range,omitempty"`
}

func (*NetworkPolicyRuleType_Any) isNetworkPolicyRuleType_OtherEndpoint()               {}
func (*NetworkPolicyRuleType_PrefixList) isNetworkPolicyRuleType_OtherEndpoint()        {}
func (*NetworkPolicyRuleType_OutsideEndpoints) isNetworkPolicyRuleType_OtherEndpoint()  {}
func (*NetworkPolicyRuleType_InsideEndpoints) isNetworkPolicyRuleType_OtherEndpoint()   {}
func (*NetworkPolicyRuleType_Namespace) isNetworkPolicyRuleType_OtherEndpoint()         {}
func (*NetworkPolicyRuleType_LabelSelector) isNetworkPolicyRuleType_OtherEndpoint()     {}
func (*NetworkPolicyRuleType_IpPrefixSet) isNetworkPolicyRuleType_OtherEndpoint()       {}
func (*NetworkPolicyRuleType_AllTraffic) isNetworkPolicyRuleType_TrafficChoice()        {}
func (*NetworkPolicyRuleType_AllTcpTraffic) isNetworkPolicyRuleType_TrafficChoice()     {}
func (*NetworkPolicyRuleType_AllUdpTraffic) isNetworkPolicyRuleType_TrafficChoice()     {}
func (*NetworkPolicyRuleType_Applications) isNetworkPolicyRuleType_TrafficChoice()      {}
func (*NetworkPolicyRuleType_ProtocolPortRange) isNetworkPolicyRuleType_TrafficChoice() {}

func (m *NetworkPolicyRuleType) GetOtherEndpoint() isNetworkPolicyRuleType_OtherEndpoint {
	if m != nil {
		return m.OtherEndpoint
	}
	return nil
}
func (m *NetworkPolicyRuleType) GetTrafficChoice() isNetworkPolicyRuleType_TrafficChoice {
	if m != nil {
		return m.TrafficChoice
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetRuleName() string {
	if m != nil {
		return m.RuleName
	}
	return ""
}

func (m *NetworkPolicyRuleType) GetRuleDescription() string {
	if m != nil {
		return m.RuleDescription
	}
	return ""
}

func (m *NetworkPolicyRuleType) GetAction() network_policy_rule.NetworkPolicyRuleAction {
	if m != nil {
		return m.Action
	}
	return network_policy_rule.DENY
}

func (m *NetworkPolicyRuleType) GetAdvAction() *network_policy_rule.NetworkPolicyRuleAdvancedAction {
	if m != nil {
		return m.AdvAction
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetAny() *schema.Empty {
	if x, ok := m.GetOtherEndpoint().(*NetworkPolicyRuleType_Any); ok {
		return x.Any
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetPrefixList() *views.PrefixStringListType {
	if x, ok := m.GetOtherEndpoint().(*NetworkPolicyRuleType_PrefixList); ok {
		return x.PrefixList
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetOutsideEndpoints() *schema.Empty {
	if x, ok := m.GetOtherEndpoint().(*NetworkPolicyRuleType_OutsideEndpoints); ok {
		return x.OutsideEndpoints
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetInsideEndpoints() *schema.Empty {
	if x, ok := m.GetOtherEndpoint().(*NetworkPolicyRuleType_InsideEndpoints); ok {
		return x.InsideEndpoints
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetNamespace() string {
	if x, ok := m.GetOtherEndpoint().(*NetworkPolicyRuleType_Namespace); ok {
		return x.Namespace
	}
	return ""
}

func (m *NetworkPolicyRuleType) GetLabelSelector() *schema.LabelSelectorType {
	if x, ok := m.GetOtherEndpoint().(*NetworkPolicyRuleType_LabelSelector); ok {
		return x.LabelSelector
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetIpPrefixSet() *schema.IpPrefixSetRefType {
	if x, ok := m.GetOtherEndpoint().(*NetworkPolicyRuleType_IpPrefixSet); ok {
		return x.IpPrefixSet
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetAllTraffic() *schema.Empty {
	if x, ok := m.GetTrafficChoice().(*NetworkPolicyRuleType_AllTraffic); ok {
		return x.AllTraffic
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetAllTcpTraffic() *schema.Empty {
	if x, ok := m.GetTrafficChoice().(*NetworkPolicyRuleType_AllTcpTraffic); ok {
		return x.AllTcpTraffic
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetAllUdpTraffic() *schema.Empty {
	if x, ok := m.GetTrafficChoice().(*NetworkPolicyRuleType_AllUdpTraffic); ok {
		return x.AllUdpTraffic
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetApplications() *ApplicationsType {
	if x, ok := m.GetTrafficChoice().(*NetworkPolicyRuleType_Applications); ok {
		return x.Applications
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetProtocolPortRange() *ProtocolPortType {
	if x, ok := m.GetTrafficChoice().(*NetworkPolicyRuleType_ProtocolPortRange); ok {
		return x.ProtocolPortRange
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *NetworkPolicyRuleType) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NetworkPolicyRuleType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NetworkPolicyRuleType_Any)(nil),
		(*NetworkPolicyRuleType_PrefixList)(nil),
		(*NetworkPolicyRuleType_OutsideEndpoints)(nil),
		(*NetworkPolicyRuleType_InsideEndpoints)(nil),
		(*NetworkPolicyRuleType_Namespace)(nil),
		(*NetworkPolicyRuleType_LabelSelector)(nil),
		(*NetworkPolicyRuleType_IpPrefixSet)(nil),
		(*NetworkPolicyRuleType_AllTraffic)(nil),
		(*NetworkPolicyRuleType_AllTcpTraffic)(nil),
		(*NetworkPolicyRuleType_AllUdpTraffic)(nil),
		(*NetworkPolicyRuleType_Applications)(nil),
		(*NetworkPolicyRuleType_ProtocolPortRange)(nil),
	}
}

// Rule Choice
//
// x-displayName: "Rule Choice"
// Shape of Network Policy Rule Choice
type NetworkPolicyRuleChoice struct {
	// Ingress Rules
	//
	// x-displayName: "Ingress Rules"
	// Ordered list of rules applied to connections to policy endpoints.
	IngressRules []*NetworkPolicyRuleType `protobuf:"bytes,1,rep,name=ingress_rules,json=ingressRules,proto3" json:"ingress_rules,omitempty"`
	// Egress Rules
	//
	// x-displayName: "Egress Rules"
	// Ordered list of rules applied to connections from policy endpoints.
	EgressRules []*NetworkPolicyRuleType `protobuf:"bytes,2,rep,name=egress_rules,json=egressRules,proto3" json:"egress_rules,omitempty"`
}

func (m *NetworkPolicyRuleChoice) Reset()      { *m = NetworkPolicyRuleChoice{} }
func (*NetworkPolicyRuleChoice) ProtoMessage() {}
func (*NetworkPolicyRuleChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{4}
}
func (m *NetworkPolicyRuleChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkPolicyRuleChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkPolicyRuleChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkPolicyRuleChoice.Merge(m, src)
}
func (m *NetworkPolicyRuleChoice) XXX_Size() int {
	return m.Size()
}
func (m *NetworkPolicyRuleChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkPolicyRuleChoice.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkPolicyRuleChoice proto.InternalMessageInfo

func (m *NetworkPolicyRuleChoice) GetIngressRules() []*NetworkPolicyRuleType {
	if m != nil {
		return m.IngressRules
	}
	return nil
}

func (m *NetworkPolicyRuleChoice) GetEgressRules() []*NetworkPolicyRuleType {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

// Legacy Rule Choice
//
// x-displayName: "Legacy Rule Choice"
// Shape of Legacy Network Policy Rule Choice
type LegacyNetworkPolicyRuleChoice struct {
	// Ingress rules
	//
	// x-displayName: "Ingress Rules"
	// List of network policy rules that apply to incoming session for local endpoint
	// Sequence in which rule is configured (in repeated ingress rules) is the sequence in which ingress rules are applied
	// If ingress rules are not specified or is empty list, then policy will assume default deny and from ANY destination to local endpoint
	IngressRules []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=ingress_rules,json=ingressRules,proto3" json:"ingress_rules,omitempty"`
	// Egress rules
	//
	// x-displayName: "Egress Rules"
	// List of network policy rules that apply to outgoing session from local endpoint
	// Sequence in which rule is configured (in repeated egress rules) is the sequence in which egress rules are applied
	// If egress rules are not specified or is empty list, then policy will assume default deny and to ANY destination from local endpoint
	EgressRules []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=egress_rules,json=egressRules,proto3" json:"egress_rules,omitempty"`
}

func (m *LegacyNetworkPolicyRuleChoice) Reset()      { *m = LegacyNetworkPolicyRuleChoice{} }
func (*LegacyNetworkPolicyRuleChoice) ProtoMessage() {}
func (*LegacyNetworkPolicyRuleChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{5}
}
func (m *LegacyNetworkPolicyRuleChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LegacyNetworkPolicyRuleChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LegacyNetworkPolicyRuleChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LegacyNetworkPolicyRuleChoice.Merge(m, src)
}
func (m *LegacyNetworkPolicyRuleChoice) XXX_Size() int {
	return m.Size()
}
func (m *LegacyNetworkPolicyRuleChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_LegacyNetworkPolicyRuleChoice.DiscardUnknown(m)
}

var xxx_messageInfo_LegacyNetworkPolicyRuleChoice proto.InternalMessageInfo

func (m *LegacyNetworkPolicyRuleChoice) GetIngressRules() []*schema.ObjectRefType {
	if m != nil {
		return m.IngressRules
	}
	return nil
}

func (m *LegacyNetworkPolicyRuleChoice) GetEgressRules() []*schema.ObjectRefType {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

// Network policy specification
//
// x-displayName: "Specification"
// Desired state for Network policy
type GlobalSpecType struct {
	// Local Endpoint
	//
	// x-displayName: "Local Endpoint"
	// local_endpoint identifies the endpoint on which policy is applied.
	// Egress rules are applied to traffic coming out of local endpoint, where local endpoint is source.
	// Ingress rules are applied to traffic go to local endpoint, where local endpoint is destination.
	// Not specifying any endpoint will result in creation of ANY endpoint
	//
	// Types that are valid to be assigned to LocalEndpoint:
	//	*GlobalSpecType_Prefix
	//	*GlobalSpecType_PrefixSelector
	LocalEndpoint isGlobalSpecType_LocalEndpoint `protobuf_oneof:"local_endpoint"`
	// ingress rules
	//
	// x-displayName: "Ingress Rules"
	// List of network policy rules that apply to incoming session for local endpoint
	// Sequence in which rule is configured (in repeated ingress rules) is the sequence in which ingress rules are applied
	// If ingress rules are not specified or is empty list, then policy will assume default deny and from ANY destination to local endpoint
	IngressRules []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=ingress_rules,json=ingressRules,proto3" json:"ingress_rules,omitempty"`
	// egress rules
	//
	// x-displayName: "Egress Rules"
	// List of network policy rules that apply to outgoing session from local endpoint
	// Sequence in which rule is configured (in repeated egress rules) is the sequence in which egress rules are applied
	// If egress rules are not specified or is empty list, then policy will assume default deny and to ANY destination from local endpoint
	EgressRules []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=egress_rules,json=egressRules,proto3" json:"egress_rules,omitempty"`
	// Default Forwarding Classes
	//
	// x-displayName: "Default Forwarding Classes"
	// Ordered list of forwarding class to use for traffic that match any rules
	// Action valid only when policy is part of PBR.
	ForwardingClass []*schema.ObjectRefType `protobuf:"bytes,5,rep,name=forwarding_class,json=forwardingClass,proto3" json:"forwarding_class,omitempty"`
	// Policy Endpoint
	//
	// x-displayName: "Endpoint(s)"
	// Policy is for set of endpoints defined, rules are applied to connections to or from these endpoints.
	Endpoint *EndpointChoiceType `protobuf:"bytes,7,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Rule Choice
	//
	// x-displayName: "Rule Choice"
	// Style of Network Policy Rules used when the policy was created. This cannot be modified.
	//
	// Types that are valid to be assigned to RuleChoice:
	//	*GlobalSpecType_Rules
	//	*GlobalSpecType_LegacyRules
	RuleChoice isGlobalSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal,proto3" json:"view_internal,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{6}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_LocalEndpoint interface {
	isGlobalSpecType_LocalEndpoint()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_RuleChoice interface {
	isGlobalSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_Prefix struct {
	Prefix *schema.PrefixListType `protobuf:"bytes,1,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type GlobalSpecType_PrefixSelector struct {
	PrefixSelector *schema.LabelSelectorType `protobuf:"bytes,2,opt,name=prefix_selector,json=prefixSelector,proto3,oneof" json:"prefix_selector,omitempty"`
}
type GlobalSpecType_Rules struct {
	Rules *NetworkPolicyRuleChoice `protobuf:"bytes,9,opt,name=rules,proto3,oneof" json:"rules,omitempty"`
}
type GlobalSpecType_LegacyRules struct {
	LegacyRules *LegacyNetworkPolicyRuleChoice `protobuf:"bytes,10,opt,name=legacy_rules,json=legacyRules,proto3,oneof" json:"legacy_rules,omitempty"`
}

func (*GlobalSpecType_Prefix) isGlobalSpecType_LocalEndpoint()         {}
func (*GlobalSpecType_PrefixSelector) isGlobalSpecType_LocalEndpoint() {}
func (*GlobalSpecType_Rules) isGlobalSpecType_RuleChoice()             {}
func (*GlobalSpecType_LegacyRules) isGlobalSpecType_RuleChoice()       {}

func (m *GlobalSpecType) GetLocalEndpoint() isGlobalSpecType_LocalEndpoint {
	if m != nil {
		return m.LocalEndpoint
	}
	return nil
}
func (m *GlobalSpecType) GetRuleChoice() isGlobalSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *GlobalSpecType) GetPrefix() *schema.PrefixListType {
	if x, ok := m.GetLocalEndpoint().(*GlobalSpecType_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (m *GlobalSpecType) GetPrefixSelector() *schema.LabelSelectorType {
	if x, ok := m.GetLocalEndpoint().(*GlobalSpecType_PrefixSelector); ok {
		return x.PrefixSelector
	}
	return nil
}

func (m *GlobalSpecType) GetIngressRules() []*schema.ObjectRefType {
	if m != nil {
		return m.IngressRules
	}
	return nil
}

func (m *GlobalSpecType) GetEgressRules() []*schema.ObjectRefType {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

func (m *GlobalSpecType) GetForwardingClass() []*schema.ObjectRefType {
	if m != nil {
		return m.ForwardingClass
	}
	return nil
}

func (m *GlobalSpecType) GetEndpoint() *EndpointChoiceType {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *GlobalSpecType) GetRules() *NetworkPolicyRuleChoice {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_Rules); ok {
		return x.Rules
	}
	return nil
}

func (m *GlobalSpecType) GetLegacyRules() *LegacyNetworkPolicyRuleChoice {
	if x, ok := m.GetRuleChoice().(*GlobalSpecType_LegacyRules); ok {
		return x.LegacyRules
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_Prefix)(nil),
		(*GlobalSpecType_PrefixSelector)(nil),
		(*GlobalSpecType_Rules)(nil),
		(*GlobalSpecType_LegacyRules)(nil),
	}
}

// Create Network Policy
//
// x-displayName: "Create Network Policy"
// Creates a new network policy with configured parameters in specified namespace
type CreateSpecType struct {
	// Policy Endpoint
	//
	// x-displayName: "Endpoint(s)"
	// x-required
	// Policy is for set of endpoints defined, rules are applied to connections to or from these endpoints.
	Endpoint *EndpointChoiceType `protobuf:"bytes,7,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Rules
	//
	// x-displayName: "Rules"
	// Network Policy Rules
	Rules *NetworkPolicyRuleChoice `protobuf:"bytes,9,opt,name=rules,proto3" json:"rules,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{7}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetEndpoint() *EndpointChoiceType {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *CreateSpecType) GetRules() *NetworkPolicyRuleChoice {
	if m != nil {
		return m.Rules
	}
	return nil
}

// Replace Network Policy
//
// x-displayName: "Replace Network Policy"
// Replaces configured Network Policy with new set of parameters in specified namespace
type ReplaceSpecType struct {
	// Policy Endpoint
	//
	// x-displayName: "Endpoint(s)"
	// x-required
	// Policy is for set of endpoints defined, rules are applied to connections to or from these endpoints.
	Endpoint *EndpointChoiceType `protobuf:"bytes,7,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to RuleChoice:
	//	*ReplaceSpecType_Rules
	//	*ReplaceSpecType_LegacyRules
	RuleChoice isReplaceSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{8}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_RuleChoice interface {
	isReplaceSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_Rules struct {
	Rules *NetworkPolicyRuleChoice `protobuf:"bytes,9,opt,name=rules,proto3,oneof" json:"rules,omitempty"`
}
type ReplaceSpecType_LegacyRules struct {
	LegacyRules *LegacyNetworkPolicyRuleChoice `protobuf:"bytes,10,opt,name=legacy_rules,json=legacyRules,proto3,oneof" json:"legacy_rules,omitempty"`
}

func (*ReplaceSpecType_Rules) isReplaceSpecType_RuleChoice()       {}
func (*ReplaceSpecType_LegacyRules) isReplaceSpecType_RuleChoice() {}

func (m *ReplaceSpecType) GetRuleChoice() isReplaceSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetEndpoint() *EndpointChoiceType {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *ReplaceSpecType) GetRules() *NetworkPolicyRuleChoice {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_Rules); ok {
		return x.Rules
	}
	return nil
}

func (m *ReplaceSpecType) GetLegacyRules() *LegacyNetworkPolicyRuleChoice {
	if x, ok := m.GetRuleChoice().(*ReplaceSpecType_LegacyRules); ok {
		return x.LegacyRules
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_Rules)(nil),
		(*ReplaceSpecType_LegacyRules)(nil),
	}
}

// Get Network Policy
//
// x-displayName: "Get Network Policy"
// Gets Network Policy parameters in specified namespace
type GetSpecType struct {
	Endpoint *EndpointChoiceType `protobuf:"bytes,7,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to RuleChoice:
	//	*GetSpecType_Rules
	//	*GetSpecType_LegacyRules
	RuleChoice isGetSpecType_RuleChoice `protobuf_oneof:"rule_choice"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_401e6308fee3117f, []int{9}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_RuleChoice interface {
	isGetSpecType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_Rules struct {
	Rules *NetworkPolicyRuleChoice `protobuf:"bytes,9,opt,name=rules,proto3,oneof" json:"rules,omitempty"`
}
type GetSpecType_LegacyRules struct {
	LegacyRules *LegacyNetworkPolicyRuleChoice `protobuf:"bytes,10,opt,name=legacy_rules,json=legacyRules,proto3,oneof" json:"legacy_rules,omitempty"`
}

func (*GetSpecType_Rules) isGetSpecType_RuleChoice()       {}
func (*GetSpecType_LegacyRules) isGetSpecType_RuleChoice() {}

func (m *GetSpecType) GetRuleChoice() isGetSpecType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *GetSpecType) GetEndpoint() *EndpointChoiceType {
	if m != nil {
		return m.Endpoint
	}
	return nil
}

func (m *GetSpecType) GetRules() *NetworkPolicyRuleChoice {
	if x, ok := m.GetRuleChoice().(*GetSpecType_Rules); ok {
		return x.Rules
	}
	return nil
}

func (m *GetSpecType) GetLegacyRules() *LegacyNetworkPolicyRuleChoice {
	if x, ok := m.GetRuleChoice().(*GetSpecType_LegacyRules); ok {
		return x.LegacyRules
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_Rules)(nil),
		(*GetSpecType_LegacyRules)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.network_policy.ApplicationEnumType", ApplicationEnumType_name, ApplicationEnumType_value)
	golang_proto.RegisterEnum("ves.io.schema.network_policy.ApplicationEnumType", ApplicationEnumType_name, ApplicationEnumType_value)
	proto.RegisterType((*EndpointChoiceType)(nil), "ves.io.schema.network_policy.EndpointChoiceType")
	golang_proto.RegisterType((*EndpointChoiceType)(nil), "ves.io.schema.network_policy.EndpointChoiceType")
	proto.RegisterType((*ApplicationsType)(nil), "ves.io.schema.network_policy.ApplicationsType")
	golang_proto.RegisterType((*ApplicationsType)(nil), "ves.io.schema.network_policy.ApplicationsType")
	proto.RegisterType((*ProtocolPortType)(nil), "ves.io.schema.network_policy.ProtocolPortType")
	golang_proto.RegisterType((*ProtocolPortType)(nil), "ves.io.schema.network_policy.ProtocolPortType")
	proto.RegisterType((*NetworkPolicyRuleType)(nil), "ves.io.schema.network_policy.NetworkPolicyRuleType")
	golang_proto.RegisterType((*NetworkPolicyRuleType)(nil), "ves.io.schema.network_policy.NetworkPolicyRuleType")
	proto.RegisterType((*NetworkPolicyRuleChoice)(nil), "ves.io.schema.network_policy.NetworkPolicyRuleChoice")
	golang_proto.RegisterType((*NetworkPolicyRuleChoice)(nil), "ves.io.schema.network_policy.NetworkPolicyRuleChoice")
	proto.RegisterType((*LegacyNetworkPolicyRuleChoice)(nil), "ves.io.schema.network_policy.LegacyNetworkPolicyRuleChoice")
	golang_proto.RegisterType((*LegacyNetworkPolicyRuleChoice)(nil), "ves.io.schema.network_policy.LegacyNetworkPolicyRuleChoice")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_policy.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_policy.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_policy.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_policy.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_policy.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_policy.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_policy.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_policy.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/network_policy/types.proto", fileDescriptor_401e6308fee3117f)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/network_policy/types.proto", fileDescriptor_401e6308fee3117f)
}

var fileDescriptor_401e6308fee3117f = []byte{
	// 2080 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4d, 0x6c, 0xdb, 0xc8,
	0x15, 0xd6, 0x88, 0xb4, 0x2d, 0x3d, 0xc9, 0x12, 0x3d, 0xb6, 0x13, 0x5a, 0x9b, 0x55, 0x14, 0x6d,
	0xb0, 0xf5, 0x66, 0x19, 0xd9, 0x62, 0x36, 0x7f, 0x0e, 0xea, 0xc2, 0x72, 0xb2, 0x91, 0xbd, 0xb6,
	0x23, 0xd0, 0x4e, 0xd1, 0x9f, 0x6d, 0xb5, 0x34, 0x35, 0x96, 0xd9, 0x50, 0x24, 0x41, 0xd2, 0xce,
	0x1a, 0x68, 0x16, 0x41, 0xaf, 0xdb, 0x43, 0x9a, 0x1e, 0x5a, 0xe4, 0xd8, 0x53, 0x91, 0xd3, 0x9e,
	0xab, 0x1c, 0x8c, 0x00, 0x05, 0x8a, 0x3d, 0xf9, 0x18, 0xec, 0xa5, 0x1b, 0xe5, 0x92, 0xde, 0x82,
	0x1c, 0x8a, 0xb6, 0x40, 0xd1, 0x82, 0x43, 0x52, 0x3f, 0x94, 0xd6, 0xc9, 0x6e, 0x92, 0xa2, 0x37,
	0xce, 0x9b, 0xef, 0xbd, 0x37, 0xf3, 0x7e, 0xbe, 0x99, 0x21, 0x4c, 0xef, 0x12, 0xbb, 0xa0, 0x1a,
	0x33, 0xb6, 0xb2, 0x4d, 0x1a, 0xf2, 0x8c, 0x4e, 0x9c, 0x9b, 0x86, 0x75, 0xa3, 0x6a, 0x1a, 0x9a,
	0xaa, 0xec, 0xcd, 0x38, 0x7b, 0x26, 0xb1, 0x0b, 0xa6, 0x65, 0x38, 0x06, 0x3e, 0xe6, 0x21, 0x0b,
	0x1e, 0xb2, 0xd0, 0x8b, 0xcc, 0x9c, 0xae, 0xab, 0xce, 0xf6, 0xce, 0x66, 0x41, 0x31, 0x1a, 0x33,
	0x75, 0xa3, 0x6e, 0xcc, 0x50, 0xa5, 0xcd, 0x9d, 0x2d, 0x3a, 0xa2, 0x03, 0xfa, 0xe5, 0x19, 0xcb,
	0x1c, 0xed, 0x73, 0xeb, 0x4f, 0x9c, 0x3e, 0x6c, 0x3d, 0x55, 0x6b, 0x47, 0x23, 0xdd, 0x8b, 0xca,
	0xbc, 0xd5, 0x0b, 0x37, 0x4c, 0x47, 0x35, 0xf4, 0x60, 0x72, 0xaa, 0x77, 0xb2, 0x5b, 0xef, 0x58,
	0xef, 0xd4, 0xae, 0xac, 0xa9, 0x35, 0xd9, 0x21, 0xfe, 0x6c, 0x2e, 0x34, 0xab, 0x92, 0x9b, 0xd5,
	0x5e, 0xd3, 0xc7, 0xfb, 0x11, 0x76, 0xb7, 0x83, 0xfc, 0x5f, 0x59, 0xc0, 0x57, 0xf4, 0x9a, 0x69,
	0xa8, 0xba, 0xb3, 0xb8, 0x6d, 0xa8, 0x0a, 0xd9, 0xd8, 0x33, 0x09, 0x5e, 0x81, 0x84, 0x69, 0x91,
	0x2d, 0xf5, 0xd3, 0xaa, 0xa6, 0xda, 0x0e, 0x8f, 0x72, 0x68, 0x3a, 0x21, 0xbe, 0x57, 0xe8, 0x0d,
	0x2d, 0xb5, 0x56, 0xa8, 0x50, 0xdc, 0xba, 0x63, 0xa9, 0x7a, 0x7d, 0x45, 0xb5, 0x1d, 0x57, 0xbf,
	0x1c, 0x91, 0xc0, 0xd3, 0x77, 0x25, 0x78, 0x1a, 0x18, 0x59, 0xdf, 0xe3, 0xa3, 0xd4, 0xca, 0x44,
	0xc8, 0xca, 0x95, 0x86, 0xe9, 0xec, 0x95, 0x23, 0x92, 0x0b, 0xc1, 0x1b, 0x30, 0x66, 0xec, 0x38,
	0xb6, 0x5a, 0x23, 0x55, 0xe2, 0xaf, 0xca, 0xe6, 0x99, 0x6f, 0xd6, 0x2b, 0xa5, 0x5b, 0x5f, 0xff,
	0x99, 0x81, 0x7b, 0x0f, 0xd0, 0xb0, 0xbd, 0x67, 0x3b, 0xa4, 0x51, 0x8e, 0x48, 0x9c, 0x6f, 0x21,
	0xd8, 0x96, 0x8d, 0x25, 0xe0, 0x54, 0x3d, 0x64, 0x94, 0xfd, 0x76, 0x46, 0xd3, 0x9e, 0x81, 0x8e,
	0xcd, 0x8f, 0x21, 0xae, 0xea, 0x0e, 0xb1, 0xb6, 0x64, 0x85, 0xf0, 0x43, 0xd4, 0x58, 0x7e, 0x60,
	0x7c, 0xae, 0x6d, 0xfe, 0x82, 0x28, 0x8e, 0x44, 0xb6, 0xdc, 0xc0, 0x94, 0xf8, 0xfb, 0xb7, 0xc6,
	0x82, 0x62, 0x69, 0xeb, 0x3f, 0x6d, 0x22, 0x54, 0x8e, 0x48, 0x1d, 0x83, 0xf8, 0x22, 0xc4, 0x75,
	0xb9, 0x41, 0x6c, 0xd3, 0xb5, 0x3e, 0x9c, 0x43, 0xd3, 0xf1, 0xd2, 0x94, 0x8b, 0x72, 0x17, 0xc6,
	0xdd, 0x7b, 0x80, 0x92, 0xf6, 0xb6, 0x6c, 0x91, 0x9a, 0x90, 0xdb, 0xb1, 0x89, 0xe5, 0xaa, 0xb6,
	0xd1, 0x78, 0x1d, 0x52, 0x9a, 0xbc, 0x49, 0xb4, 0xaa, 0x4d, 0x34, 0xa2, 0x38, 0x86, 0xc5, 0xc7,
	0xe9, 0xea, 0x72, 0xa1, 0xd5, 0xad, 0xb8, 0xa0, 0x75, 0x1f, 0x43, 0xd7, 0x16, 0xbb, 0xf7, 0x00,
	0xb1, 0x10, 0x45, 0x4c, 0x39, 0x22, 0x8d, 0x6a, 0xdd, 0xd3, 0x73, 0x43, 0xcf, 0xe7, 0xa3, 0xc5,
	0xd9, 0x92, 0x00, 0xe9, 0x20, 0x82, 0x55, 0x85, 0x56, 0x0b, 0x9e, 0xda, 0x6f, 0x22, 0x74, 0xd0,
	0x44, 0xd0, 0x6a, 0xa2, 0xd1, 0xa2, 0x20, 0x0a, 0x67, 0x84, 0x0f, 0x84, 0xb3, 0xc2, 0x39, 0xe1,
	0xe2, 0x32, 0x1b, 0x03, 0x2e, 0x91, 0x37, 0x80, 0x5b, 0x30, 0x4d, 0x4d, 0x55, 0x64, 0x5a, 0x98,
	0xb4, 0xbc, 0xae, 0x43, 0x52, 0xee, 0x92, 0xf1, 0x28, 0xc7, 0x4c, 0xa7, 0xc4, 0x62, 0xe1, 0xb0,
	0xd6, 0x2d, 0x74, 0x59, 0xb9, 0xa2, 0xef, 0x34, 0x5c, 0x43, 0x52, 0x8f, 0x99, 0x39, 0xf6, 0xf9,
	0x3c, 0x2a, 0xe6, 0x7f, 0x8f, 0x80, 0xab, 0xb8, 0xc5, 0xad, 0x18, 0x5a, 0xc5, 0xb0, 0x68, 0x41,
	0xe2, 0x1f, 0x40, 0xcc, 0xf4, 0x65, 0xb4, 0x9a, 0xe3, 0xa5, 0x77, 0xbe, 0x6a, 0x22, 0x66, 0x61,
	0x65, 0xe5, 0x4f, 0x7f, 0xdb, 0x67, 0x8e, 0x5a, 0x93, 0x92, 0xfb, 0x2d, 0x31, 0x1b, 0x8b, 0x15,
	0x89, 0xb9, 0x7e, 0xb9, 0x22, 0xb1, 0x4b, 0x8b, 0xab, 0x15, 0xa9, 0xad, 0x84, 0x2f, 0x41, 0xc2,
	0x34, 0x2c, 0xa7, 0x6a, 0xc9, 0x7a, 0x9d, 0xd8, 0x7c, 0x34, 0xc7, 0x4c, 0xc7, 0x4b, 0x19, 0x57,
	0x19, 0xee, 0xa2, 0x91, 0xfc, 0x90, 0xc5, 0x7c, 0x81, 0x90, 0x3b, 0x1c, 0xbe, 0x8b, 0x18, 0xee,
	0x36, 0x92, 0xc0, 0x85, 0x4b, 0x14, 0x3d, 0x37, 0xfc, 0x7c, 0x9e, 0x29, 0x0a, 0x62, 0xfe, 0xb7,
	0x1c, 0x4c, 0xae, 0x79, 0xbb, 0xaa, 0xd0, 0x4d, 0x49, 0x3b, 0x9a, 0xd7, 0x70, 0x73, 0x10, 0x6b,
	0x10, 0x47, 0xae, 0xc9, 0x8e, 0xcc, 0x4f, 0xd1, 0x7c, 0x65, 0x43, 0xd1, 0x58, 0x25, 0xb6, 0x2d,
	0xd7, 0xc9, 0x2a, 0x71, 0x64, 0xba, 0xf5, 0x36, 0x1e, 0x9f, 0x84, 0xb8, 0x4b, 0x38, 0x55, 0xb7,
	0x06, 0x78, 0xa0, 0x9b, 0x1b, 0x79, 0x74, 0x0b, 0xb9, 0xf5, 0x22, 0xc5, 0xdc, 0x99, 0x35, 0xb9,
	0x41, 0xb0, 0x08, 0x1c, 0x45, 0xd5, 0x88, 0xad, 0x58, 0x2a, 0x65, 0x09, 0x9e, 0xef, 0x05, 0xa7,
	0x5d, 0xc0, 0xe5, 0xce, 0x3c, 0xfe, 0x18, 0x86, 0x65, 0x85, 0x22, 0xdd, 0x98, 0xa5, 0xc4, 0xb9,
	0x43, 0x33, 0x44, 0x69, 0xaf, 0xd0, 0xb7, 0xbf, 0x05, 0x6a, 0xa1, 0x14, 0xfb, 0xaa, 0x89, 0xd8,
	0xcb, 0x57, 0xd6, 0x7e, 0x2c, 0xf9, 0x36, 0xf1, 0x0d, 0x00, 0xb9, 0xb6, 0x5b, 0xf5, 0x3d, 0x64,
	0xe8, 0xae, 0x4b, 0xdf, 0xc9, 0x43, 0x6d, 0x57, 0xd6, 0x15, 0x52, 0x0b, 0x3c, 0xb9, 0x25, 0xf9,
	0xcc, 0xdd, 0x50, 0x5c, 0xae, 0xed, 0x7a, 0xc2, 0x80, 0x83, 0x12, 0x2f, 0xe6, 0xa0, 0x10, 0xf7,
	0x25, 0x5f, 0x8d, 0xfb, 0x06, 0x32, 0xda, 0xe8, 0x9b, 0x60, 0xb4, 0xd4, 0x2b, 0x32, 0x5a, 0x0f,
	0xe7, 0xa4, 0x5f, 0x91, 0x73, 0xb8, 0x57, 0xe6, 0x1c, 0x7c, 0x15, 0x46, 0x55, 0xb3, 0xea, 0xa7,
	0xc2, 0x26, 0x8e, 0xcf, 0xb2, 0x27, 0x42, 0x36, 0x97, 0x4c, 0x3f, 0x0b, 0x24, 0x20, 0xd9, 0x72,
	0x44, 0x4a, 0xa8, 0x1d, 0x29, 0x3e, 0x0f, 0x09, 0x59, 0xd3, 0xaa, 0x8e, 0x25, 0x6f, 0x6d, 0xa9,
	0x0a, 0x8f, 0x0f, 0x29, 0x01, 0x24, 0x81, 0xac, 0x69, 0x1b, 0x1e, 0x12, 0xcf, 0x43, 0x9a, 0x2a,
	0x2a, 0x66, 0x5b, 0x79, 0xfc, 0x50, 0xe5, 0x51, 0x57, 0x59, 0x31, 0x43, 0xfa, 0x3b, 0xb5, 0x8e,
	0xfe, 0xc4, 0x0b, 0xf5, 0xaf, 0xd7, 0xda, 0xfa, 0x1b, 0x21, 0x9a, 0x9c, 0xa4, 0xca, 0x85, 0x97,
	0xa6, 0x49, 0x4a, 0xb6, 0x65, 0xd4, 0xcb, 0x92, 0xf8, 0x13, 0x18, 0x0f, 0x58, 0xad, 0xda, 0xa1,
	0x34, 0xfe, 0xc8, 0xcb, 0x18, 0x0f, 0xf3, 0x6a, 0x19, 0x49, 0x63, 0x66, 0x97, 0x8c, 0xf2, 0x1d,
	0x9e, 0x01, 0xf6, 0x06, 0xd9, 0xb3, 0xf9, 0xa3, 0x94, 0x24, 0xdf, 0xf2, 0xe9, 0xc5, 0x25, 0xc7,
	0xa1, 0xbb, 0x28, 0xca, 0x71, 0xc1, 0x17, 0x8f, 0x24, 0x0a, 0xc4, 0x12, 0x78, 0xb9, 0xaf, 0x36,
	0x64, 0x47, 0xd9, 0x26, 0x16, 0xff, 0x16, 0x5d, 0xcc, 0xf1, 0x41, 0xe5, 0xb3, 0xea, 0x41, 0x68,
	0xf5, 0x24, 0x83, 0xea, 0xf9, 0xe2, 0x01, 0x42, 0x52, 0x52, 0xeb, 0x9a, 0x9f, 0xfb, 0x03, 0xfb,
	0xb0, 0x89, 0x32, 0xc0, 0xc3, 0x90, 0x4b, 0x11, 0x36, 0x4e, 0x8b, 0x67, 0x85, 0xa2, 0x20, 0x9e,
	0x13, 0x2e, 0x08, 0xc5, 0xf3, 0x82, 0x78, 0xfe, 0xcb, 0x26, 0xfa, 0x0f, 0x03, 0x47, 0x81, 0x75,
	0xd9, 0x31, 0x93, 0x86, 0xd1, 0x80, 0x4f, 0x0b, 0x6e, 0x5d, 0xc3, 0x14, 0x24, 0x5c, 0xbd, 0x9c,
	0x47, 0x1f, 0x19, 0x08, 0x98, 0x30, 0x87, 0xe0, 0xd7, 0x51, 0x48, 0x5d, 0x73, 0xb6, 0x89, 0x95,
	0x0b, 0x9a, 0xe7, 0xd4, 0x3f, 0x11, 0xfc, 0x1d, 0x01, 0x50, 0x8e, 0x11, 0x99, 0x05, 0x7d, 0x0f,
	0xbe, 0x07, 0x13, 0x5d, 0x2c, 0x52, 0xf0, 0xbe, 0x89, 0x9d, 0x4f, 0x73, 0xcc, 0xa9, 0xc4, 0x52,
	0x25, 0x57, 0xf1, 0x05, 0xf0, 0xfe, 0x00, 0x82, 0x10, 0x8f, 0xfc, 0x50, 0x95, 0x73, 0xd7, 0x3c,
	0x71, 0x6e, 0x29, 0xb8, 0x16, 0xd8, 0xf0, 0x5e, 0x7f, 0xdf, 0x8b, 0x93, 0x2e, 0x76, 0x49, 0x0f,
	0x43, 0xf9, 0xae, 0x76, 0xc6, 0x89, 0x4c, 0x7c, 0x2d, 0x18, 0x00, 0x17, 0xee, 0x56, 0xb8, 0x04,
	0x13, 0x3d, 0xad, 0x56, 0xb0, 0xc8, 0xd6, 0x4f, 0x67, 0x7f, 0x86, 0x93, 0x19, 0xf0, 0xd6, 0x99,
	0x73, 0xbb, 0x6b, 0x12, 0xc6, 0xfa, 0x50, 0x1c, 0x82, 0xdf, 0x20, 0x48, 0xfa, 0x15, 0x9b, 0x73,
	0xb3, 0x72, 0xea, 0x36, 0x82, 0xcf, 0x00, 0xf7, 0x34, 0x9d, 0x17, 0x93, 0x23, 0x7d, 0xfd, 0x24,
	0xba, 0x07, 0x6e, 0x20, 0xef, 0xea, 0x13, 0xd1, 0x3d, 0x83, 0xe1, 0x04, 0x4c, 0x75, 0x57, 0x6e,
	0xa1, 0x7b, 0x90, 0x67, 0x39, 0x66, 0x16, 0xc1, 0xe4, 0xc0, 0x62, 0x86, 0x77, 0x01, 0x68, 0xb1,
	0xe4, 0x3e, 0x22, 0x7b, 0x36, 0x87, 0x4a, 0x47, 0x00, 0xf7, 0x14, 0x58, 0xc1, 0x2d, 0x3b, 0x8e,
	0x29, 0x15, 0x21, 0x65, 0xb8, 0x99, 0x6c, 0x87, 0x13, 0x1f, 0xdf, 0x6f, 0xa2, 0xc4, 0x41, 0x13,
	0xc5, 0x5a, 0x4d, 0x34, 0x5e, 0x2c, 0x0a, 0x45, 0x51, 0x28, 0x9e, 0x11, 0x8a, 0x1f, 0x08, 0xc5,
	0xb3, 0x42, 0xf1, 0x9c, 0x70, 0xb6, 0x24, 0x40, 0xca, 0x5f, 0x64, 0x70, 0x05, 0xca, 0xec, 0x37,
	0x11, 0x3e, 0x68, 0xa2, 0xb1, 0x56, 0x13, 0xa5, 0x8a, 0x17, 0x84, 0xe2, 0x45, 0x41, 0x9c, 0x15,
	0xc4, 0xa2, 0x20, 0x8a, 0xcb, 0x6c, 0x8c, 0xe5, 0x86, 0x96, 0xd9, 0x58, 0x94, 0x63, 0x96, 0xd9,
	0x58, 0x8c, 0x8b, 0x2f, 0xb3, 0xb1, 0x61, 0x6e, 0x64, 0x99, 0x8d, 0x8d, 0x71, 0x78, 0x99, 0x8d,
	0x8d, 0x70, 0xb1, 0xfc, 0xef, 0xa2, 0x70, 0xb4, 0xef, 0x4c, 0xf3, 0x2e, 0xe3, 0xf8, 0x33, 0x18,
	0x55, 0xf5, 0xba, 0x45, 0x6c, 0x9b, 0x9e, 0x7d, 0xde, 0x55, 0x29, 0x21, 0x9e, 0x39, 0xbc, 0x4d,
	0x07, 0xde, 0x31, 0x4a, 0x27, 0x0f, 0x9a, 0x3d, 0x57, 0x94, 0xa0, 0x0d, 0x67, 0x29, 0xc5, 0x0f,
	0xdf, 0x7d, 0x80, 0xa2, 0x1c, 0x92, 0x92, 0xbe, 0x3f, 0xaf, 0x6b, 0x7e, 0x09, 0x49, 0xd2, 0xed,
	0x3e, 0xfa, 0xa6, 0xdd, 0x27, 0x48, 0xc7, 0x7b, 0xfe, 0xdf, 0x08, 0xde, 0x5e, 0x21, 0x75, 0x59,
	0xd9, 0xfb, 0xa6, 0xf8, 0xe8, 0x83, 0xe3, 0x73, 0x2c, 0xb4, 0xc0, 0xde, 0x4b, 0xf8, 0xfb, 0xf7,
	0x6f, 0x8d, 0x0f, 0xb8, 0x58, 0x0c, 0x58, 0x1b, 0x1f, 0x8e, 0x87, 0x36, 0x30, 0x1e, 0xaf, 0xd1,
	0x5d, 0xcf, 0xfe, 0x3f, 0x1f, 0x81, 0xd4, 0x55, 0xcd, 0xd8, 0x94, 0xb5, 0x75, 0x93, 0x28, 0xf4,
	0xa2, 0xf8, 0x7d, 0x18, 0xf6, 0x3a, 0xd0, 0x7f, 0x94, 0xbd, 0x1d, 0x72, 0x5d, 0x69, 0x5f, 0x3d,
	0xa8, 0x6f, 0xf6, 0x1f, 0x4d, 0x14, 0x29, 0x47, 0x24, 0x5f, 0x09, 0x5f, 0x87, 0x74, 0xbb, 0x81,
	0xfd, 0xa3, 0x3a, 0xfa, 0x1d, 0x8e, 0xea, 0x94, 0xe9, 0x9f, 0xae, 0xfe, 0x59, 0x5d, 0x0b, 0xa7,
	0x81, 0x79, 0x89, 0xb8, 0x9c, 0x78, 0x61, 0x5c, 0x42, 0xc1, 0xdf, 0x0c, 0x05, 0x9f, 0x7d, 0x3d,
	0x4e, 0xba, 0x43, 0x8e, 0x1b, 0xc0, 0x6d, 0x19, 0xd6, 0x4d, 0xd9, 0xaa, 0xa9, 0x7a, 0xbd, 0xaa,
	0x68, 0xb2, 0x6d, 0xf3, 0x43, 0x2f, 0xe1, 0xe7, 0xe4, 0xfd, 0x5b, 0x7d, 0x8a, 0xe1, 0x83, 0x8f,
	0x91, 0xd2, 0x1d, 0xc8, 0xa2, 0x8b, 0xc0, 0x2b, 0x10, 0x0b, 0xa8, 0x87, 0x1f, 0xa1, 0x89, 0x98,
	0x3d, 0xbc, 0xb7, 0xfa, 0x1f, 0xeb, 0x52, 0xdb, 0x02, 0x5e, 0x85, 0x21, 0x2f, 0x32, 0xde, 0x93,
	0xef, 0xec, 0xb7, 0x6c, 0x53, 0xcf, 0x66, 0x19, 0x49, 0x9e, 0x15, 0xfc, 0x09, 0x24, 0x35, 0xda,
	0x7d, 0x7e, 0xbc, 0x81, 0x5a, 0xbd, 0x74, 0xb8, 0xd5, 0x43, 0xfb, 0xb5, 0x8c, 0xa4, 0x84, 0x67,
	0xd2, 0x8b, 0xf6, 0xcf, 0x61, 0x94, 0xfe, 0xb5, 0xa0, 0x2f, 0x5f, 0x5d, 0xd6, 0xf8, 0xa7, 0x23,
	0x2f, 0xfd, 0x94, 0x9e, 0xb8, 0x7f, 0xab, 0x57, 0x99, 0xbe, 0x61, 0x92, 0xae, 0x68, 0xc9, 0x97,
	0x94, 0x32, 0x90, 0xd2, 0x0c, 0x45, 0xd6, 0x3a, 0xfc, 0x1e, 0xf3, 0xdf, 0xab, 0xc3, 0xa5, 0x77,
	0x20, 0x41, 0x1f, 0x44, 0x3e, 0x8b, 0x4f, 0xec, 0x37, 0x51, 0xdc, 0x27, 0x7e, 0xf6, 0xa2, 0x50,
	0x9c, 0x75, 0xcd, 0xb5, 0xd9, 0x3a, 0xc6, 0xc5, 0xf3, 0x9f, 0x47, 0x21, 0xb5, 0x68, 0x11, 0xd9,
	0x21, 0xed, 0x6e, 0x94, 0x5e, 0x3d, 0x7d, 0x25, 0x96, 0x3e, 0x55, 0x3a, 0x49, 0xfc, 0xe8, 0x75,
	0x24, 0xd1, 0x4f, 0xe1, 0xdc, 0x8f, 0xbe, 0x9c, 0x0f, 0x31, 0xc8, 0xc3, 0x26, 0x5a, 0x84, 0x29,
	0x98, 0xf0, 0x34, 0x72, 0x1f, 0x1a, 0x9d, 0x6b, 0x8c, 0x8d, 0xd1, 0x79, 0x78, 0x17, 0x4e, 0x2c,
	0x1a, 0xba, 0x4e, 0xe8, 0x6d, 0xc7, 0xce, 0x6d, 0x18, 0x39, 0x59, 0xaf, 0xe5, 0x3e, 0xb4, 0x8c,
	0x46, 0x37, 0xee, 0x62, 0xfe, 0x0e, 0x03, 0x69, 0x89, 0x98, 0x9a, 0xac, 0xbc, 0xd9, 0x70, 0xbc,
	0x9e, 0x9a, 0x8e, 0xbc, 0xc1, 0x9a, 0x8e, 0xf4, 0xd4, 0xf4, 0x1b, 0x0b, 0xf9, 0x85, 0x52, 0xb6,
	0xb7, 0x62, 0xd3, 0xbf, 0xfa, 0x17, 0xea, 0x16, 0xe4, 0x1f, 0x46, 0x21, 0x71, 0x95, 0x38, 0xed,
	0x74, 0xfc, 0x3f, 0x92, 0xcb, 0xff, 0x30, 0x11, 0x13, 0x7d, 0x89, 0x78, 0x3a, 0x8f, 0x5e, 0x14,
	0xc4, 0x53, 0x0d, 0x18, 0x1f, 0xf0, 0xa7, 0x09, 0x4f, 0x00, 0xb7, 0x50, 0xa9, 0xac, 0x2c, 0x2d,
	0x2e, 0x6c, 0x2c, 0x5d, 0x5b, 0xab, 0x96, 0x37, 0x36, 0x2a, 0x5c, 0x04, 0x4f, 0xc2, 0x58, 0x58,
	0xba, 0xce, 0xa1, 0x30, 0x78, 0x7d, 0x6d, 0xb5, 0xc2, 0x45, 0xf1, 0x38, 0xa4, 0xbb, 0xa5, 0x97,
	0xd7, 0xd6, 0x39, 0xa6, 0x74, 0x07, 0x1d, 0x3c, 0xce, 0x46, 0x1e, 0x3d, 0xce, 0x46, 0x9e, 0x3d,
	0xce, 0xa2, 0xdb, 0xad, 0x2c, 0xfa, 0x63, 0x2b, 0x8b, 0xfe, 0xd2, 0xca, 0xa2, 0x83, 0x56, 0x16,
	0x3d, 0x6a, 0x65, 0xd1, 0xd7, 0xad, 0x2c, 0x7a, 0xda, 0xca, 0x46, 0x9e, 0xb5, 0xb2, 0xe8, 0xce,
	0x93, 0x6c, 0x64, 0xff, 0x49, 0x16, 0x1d, 0x3c, 0xc9, 0x46, 0x1e, 0x3d, 0xc9, 0x46, 0x7e, 0x22,
	0xd5, 0x0d, 0xf3, 0x46, 0xbd, 0xb0, 0x6b, 0x68, 0x0e, 0xb1, 0x2c, 0xb9, 0xb0, 0x63, 0xcf, 0xd0,
	0x8f, 0x2d, 0xc3, 0x6a, 0x9c, 0x36, 0x2d, 0x63, 0x57, 0xad, 0x11, 0xeb, 0x74, 0x30, 0x3d, 0x63,
	0x6e, 0xd6, 0x8d, 0x19, 0xf2, 0xa9, 0xe3, 0xff, 0x0f, 0x1e, 0xf8, 0xf7, 0x7a, 0x73, 0x98, 0xde,
	0xa8, 0xcf, 0xfc, 0x37, 0x00, 0x00, 0xff, 0xff, 0x36, 0x78, 0x15, 0x38, 0x74, 0x17, 0x00, 0x00,
}

func (x ApplicationEnumType) String() string {
	s, ok := ApplicationEnumType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *EndpointChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointChoiceType)
	if !ok {
		that2, ok := that.(EndpointChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.EndpointChoice == nil {
		if this.EndpointChoice != nil {
			return false
		}
	} else if this.EndpointChoice == nil {
		return false
	} else if !this.EndpointChoice.Equal(that1.EndpointChoice) {
		return false
	}
	return true
}
func (this *EndpointChoiceType_PrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointChoiceType_PrefixList)
	if !ok {
		that2, ok := that.(EndpointChoiceType_PrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixList.Equal(that1.PrefixList) {
		return false
	}
	return true
}
func (this *EndpointChoiceType_Any) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointChoiceType_Any)
	if !ok {
		that2, ok := that.(EndpointChoiceType_Any)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Any.Equal(that1.Any) {
		return false
	}
	return true
}
func (this *EndpointChoiceType_OutsideEndpoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointChoiceType_OutsideEndpoints)
	if !ok {
		that2, ok := that.(EndpointChoiceType_OutsideEndpoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OutsideEndpoints.Equal(that1.OutsideEndpoints) {
		return false
	}
	return true
}
func (this *EndpointChoiceType_InsideEndpoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointChoiceType_InsideEndpoints)
	if !ok {
		that2, ok := that.(EndpointChoiceType_InsideEndpoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideEndpoints.Equal(that1.InsideEndpoints) {
		return false
	}
	return true
}
func (this *EndpointChoiceType_Interface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointChoiceType_Interface)
	if !ok {
		that2, ok := that.(EndpointChoiceType_Interface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Interface.Equal(that1.Interface) {
		return false
	}
	return true
}
func (this *EndpointChoiceType_Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointChoiceType_Namespace)
	if !ok {
		that2, ok := that.(EndpointChoiceType_Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *EndpointChoiceType_LabelSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointChoiceType_LabelSelector)
	if !ok {
		that2, ok := that.(EndpointChoiceType_LabelSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LabelSelector.Equal(that1.LabelSelector) {
		return false
	}
	return true
}
func (this *ApplicationsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApplicationsType)
	if !ok {
		that2, ok := that.(ApplicationsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Applications) != len(that1.Applications) {
		return false
	}
	for i := range this.Applications {
		if this.Applications[i] != that1.Applications[i] {
			return false
		}
	}
	return true
}
func (this *ProtocolPortType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolPortType)
	if !ok {
		that2, ok := that.(ProtocolPortType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if len(this.PortRanges) != len(that1.PortRanges) {
		return false
	}
	for i := range this.PortRanges {
		if this.PortRanges[i] != that1.PortRanges[i] {
			return false
		}
	}
	return true
}
func (this *NetworkPolicyRuleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if this.RuleName != that1.RuleName {
		return false
	}
	if this.RuleDescription != that1.RuleDescription {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if !this.AdvAction.Equal(that1.AdvAction) {
		return false
	}
	if that1.OtherEndpoint == nil {
		if this.OtherEndpoint != nil {
			return false
		}
	} else if this.OtherEndpoint == nil {
		return false
	} else if !this.OtherEndpoint.Equal(that1.OtherEndpoint) {
		return false
	}
	if that1.TrafficChoice == nil {
		if this.TrafficChoice != nil {
			return false
		}
	} else if this.TrafficChoice == nil {
		return false
	} else if !this.TrafficChoice.Equal(that1.TrafficChoice) {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_Any) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_Any)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_Any)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Any.Equal(that1.Any) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_PrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_PrefixList)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_PrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixList.Equal(that1.PrefixList) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_OutsideEndpoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_OutsideEndpoints)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_OutsideEndpoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.OutsideEndpoints.Equal(that1.OutsideEndpoints) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_InsideEndpoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_InsideEndpoints)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_InsideEndpoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideEndpoints.Equal(that1.InsideEndpoints) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_Namespace)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_LabelSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_LabelSelector)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_LabelSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LabelSelector.Equal(that1.LabelSelector) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_IpPrefixSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_IpPrefixSet)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_IpPrefixSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixSet.Equal(that1.IpPrefixSet) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_AllTraffic) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_AllTraffic)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_AllTraffic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllTraffic.Equal(that1.AllTraffic) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_AllTcpTraffic) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_AllTcpTraffic)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_AllTcpTraffic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllTcpTraffic.Equal(that1.AllTcpTraffic) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_AllUdpTraffic) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_AllUdpTraffic)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_AllUdpTraffic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllUdpTraffic.Equal(that1.AllUdpTraffic) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_Applications) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_Applications)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_Applications)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Applications.Equal(that1.Applications) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleType_ProtocolPortRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleType_ProtocolPortRange)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleType_ProtocolPortRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProtocolPortRange.Equal(that1.ProtocolPortRange) {
		return false
	}
	return true
}
func (this *NetworkPolicyRuleChoice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkPolicyRuleChoice)
	if !ok {
		that2, ok := that.(NetworkPolicyRuleChoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.IngressRules) != len(that1.IngressRules) {
		return false
	}
	for i := range this.IngressRules {
		if !this.IngressRules[i].Equal(that1.IngressRules[i]) {
			return false
		}
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	return true
}
func (this *LegacyNetworkPolicyRuleChoice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LegacyNetworkPolicyRuleChoice)
	if !ok {
		that2, ok := that.(LegacyNetworkPolicyRuleChoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.IngressRules) != len(that1.IngressRules) {
		return false
	}
	for i := range this.IngressRules {
		if !this.IngressRules[i].Equal(that1.IngressRules[i]) {
			return false
		}
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LocalEndpoint == nil {
		if this.LocalEndpoint != nil {
			return false
		}
	} else if this.LocalEndpoint == nil {
		return false
	} else if !this.LocalEndpoint.Equal(that1.LocalEndpoint) {
		return false
	}
	if len(this.IngressRules) != len(that1.IngressRules) {
		return false
	}
	for i := range this.IngressRules {
		if !this.IngressRules[i].Equal(that1.IngressRules[i]) {
			return false
		}
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	if len(this.ForwardingClass) != len(that1.ForwardingClass) {
		return false
	}
	for i := range this.ForwardingClass {
		if !this.ForwardingClass[i].Equal(that1.ForwardingClass[i]) {
			return false
		}
	}
	if !this.Endpoint.Equal(that1.Endpoint) {
		return false
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Prefix)
	if !ok {
		that2, ok := that.(GlobalSpecType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Prefix.Equal(that1.Prefix) {
		return false
	}
	return true
}
func (this *GlobalSpecType_PrefixSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PrefixSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_PrefixSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrefixSelector.Equal(that1.PrefixSelector) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Rules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Rules)
	if !ok {
		that2, ok := that.(GlobalSpecType_Rules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rules.Equal(that1.Rules) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LegacyRules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LegacyRules)
	if !ok {
		that2, ok := that.(GlobalSpecType_LegacyRules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRules.Equal(that1.LegacyRules) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Endpoint.Equal(that1.Endpoint) {
		return false
	}
	if !this.Rules.Equal(that1.Rules) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Endpoint.Equal(that1.Endpoint) {
		return false
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Rules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Rules)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Rules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rules.Equal(that1.Rules) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LegacyRules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LegacyRules)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LegacyRules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRules.Equal(that1.LegacyRules) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Endpoint.Equal(that1.Endpoint) {
		return false
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_Rules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Rules)
	if !ok {
		that2, ok := that.(GetSpecType_Rules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rules.Equal(that1.Rules) {
		return false
	}
	return true
}
func (this *GetSpecType_LegacyRules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LegacyRules)
	if !ok {
		that2, ok := that.(GetSpecType_LegacyRules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyRules.Equal(that1.LegacyRules) {
		return false
	}
	return true
}
func (this *EndpointChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&network_policy.EndpointChoiceType{")
	if this.EndpointChoice != nil {
		s = append(s, "EndpointChoice: "+fmt.Sprintf("%#v", this.EndpointChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EndpointChoiceType_PrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.EndpointChoiceType_PrefixList{` +
		`PrefixList:` + fmt.Sprintf("%#v", this.PrefixList) + `}`}, ", ")
	return s
}
func (this *EndpointChoiceType_Any) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.EndpointChoiceType_Any{` +
		`Any:` + fmt.Sprintf("%#v", this.Any) + `}`}, ", ")
	return s
}
func (this *EndpointChoiceType_OutsideEndpoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.EndpointChoiceType_OutsideEndpoints{` +
		`OutsideEndpoints:` + fmt.Sprintf("%#v", this.OutsideEndpoints) + `}`}, ", ")
	return s
}
func (this *EndpointChoiceType_InsideEndpoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.EndpointChoiceType_InsideEndpoints{` +
		`InsideEndpoints:` + fmt.Sprintf("%#v", this.InsideEndpoints) + `}`}, ", ")
	return s
}
func (this *EndpointChoiceType_Interface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.EndpointChoiceType_Interface{` +
		`Interface:` + fmt.Sprintf("%#v", this.Interface) + `}`}, ", ")
	return s
}
func (this *EndpointChoiceType_Namespace) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.EndpointChoiceType_Namespace{` +
		`Namespace:` + fmt.Sprintf("%#v", this.Namespace) + `}`}, ", ")
	return s
}
func (this *EndpointChoiceType_LabelSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.EndpointChoiceType_LabelSelector{` +
		`LabelSelector:` + fmt.Sprintf("%#v", this.LabelSelector) + `}`}, ", ")
	return s
}
func (this *ApplicationsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_policy.ApplicationsType{")
	s = append(s, "Applications: "+fmt.Sprintf("%#v", this.Applications)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolPortType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_policy.ProtocolPortType{")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "PortRanges: "+fmt.Sprintf("%#v", this.PortRanges)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkPolicyRuleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&network_policy.NetworkPolicyRuleType{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "RuleName: "+fmt.Sprintf("%#v", this.RuleName)+",\n")
	s = append(s, "RuleDescription: "+fmt.Sprintf("%#v", this.RuleDescription)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.AdvAction != nil {
		s = append(s, "AdvAction: "+fmt.Sprintf("%#v", this.AdvAction)+",\n")
	}
	if this.OtherEndpoint != nil {
		s = append(s, "OtherEndpoint: "+fmt.Sprintf("%#v", this.OtherEndpoint)+",\n")
	}
	if this.TrafficChoice != nil {
		s = append(s, "TrafficChoice: "+fmt.Sprintf("%#v", this.TrafficChoice)+",\n")
	}
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkPolicyRuleType_Any) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_Any{` +
		`Any:` + fmt.Sprintf("%#v", this.Any) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_PrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_PrefixList{` +
		`PrefixList:` + fmt.Sprintf("%#v", this.PrefixList) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_OutsideEndpoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_OutsideEndpoints{` +
		`OutsideEndpoints:` + fmt.Sprintf("%#v", this.OutsideEndpoints) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_InsideEndpoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_InsideEndpoints{` +
		`InsideEndpoints:` + fmt.Sprintf("%#v", this.InsideEndpoints) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_Namespace) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_Namespace{` +
		`Namespace:` + fmt.Sprintf("%#v", this.Namespace) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_LabelSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_LabelSelector{` +
		`LabelSelector:` + fmt.Sprintf("%#v", this.LabelSelector) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_IpPrefixSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_IpPrefixSet{` +
		`IpPrefixSet:` + fmt.Sprintf("%#v", this.IpPrefixSet) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_AllTraffic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_AllTraffic{` +
		`AllTraffic:` + fmt.Sprintf("%#v", this.AllTraffic) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_AllTcpTraffic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_AllTcpTraffic{` +
		`AllTcpTraffic:` + fmt.Sprintf("%#v", this.AllTcpTraffic) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_AllUdpTraffic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_AllUdpTraffic{` +
		`AllUdpTraffic:` + fmt.Sprintf("%#v", this.AllUdpTraffic) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_Applications) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_Applications{` +
		`Applications:` + fmt.Sprintf("%#v", this.Applications) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleType_ProtocolPortRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.NetworkPolicyRuleType_ProtocolPortRange{` +
		`ProtocolPortRange:` + fmt.Sprintf("%#v", this.ProtocolPortRange) + `}`}, ", ")
	return s
}
func (this *NetworkPolicyRuleChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_policy.NetworkPolicyRuleChoice{")
	if this.IngressRules != nil {
		s = append(s, "IngressRules: "+fmt.Sprintf("%#v", this.IngressRules)+",\n")
	}
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LegacyNetworkPolicyRuleChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_policy.LegacyNetworkPolicyRuleChoice{")
	if this.IngressRules != nil {
		s = append(s, "IngressRules: "+fmt.Sprintf("%#v", this.IngressRules)+",\n")
	}
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&network_policy.GlobalSpecType{")
	if this.LocalEndpoint != nil {
		s = append(s, "LocalEndpoint: "+fmt.Sprintf("%#v", this.LocalEndpoint)+",\n")
	}
	if this.IngressRules != nil {
		s = append(s, "IngressRules: "+fmt.Sprintf("%#v", this.IngressRules)+",\n")
	}
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	if this.ForwardingClass != nil {
		s = append(s, "ForwardingClass: "+fmt.Sprintf("%#v", this.ForwardingClass)+",\n")
	}
	if this.Endpoint != nil {
		s = append(s, "Endpoint: "+fmt.Sprintf("%#v", this.Endpoint)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GlobalSpecType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_PrefixSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GlobalSpecType_PrefixSelector{` +
		`PrefixSelector:` + fmt.Sprintf("%#v", this.PrefixSelector) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Rules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GlobalSpecType_Rules{` +
		`Rules:` + fmt.Sprintf("%#v", this.Rules) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LegacyRules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GlobalSpecType_LegacyRules{` +
		`LegacyRules:` + fmt.Sprintf("%#v", this.LegacyRules) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_policy.CreateSpecType{")
	if this.Endpoint != nil {
		s = append(s, "Endpoint: "+fmt.Sprintf("%#v", this.Endpoint)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_policy.ReplaceSpecType{")
	if this.Endpoint != nil {
		s = append(s, "Endpoint: "+fmt.Sprintf("%#v", this.Endpoint)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_Rules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.ReplaceSpecType_Rules{` +
		`Rules:` + fmt.Sprintf("%#v", this.Rules) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LegacyRules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.ReplaceSpecType_LegacyRules{` +
		`LegacyRules:` + fmt.Sprintf("%#v", this.LegacyRules) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_policy.GetSpecType{")
	if this.Endpoint != nil {
		s = append(s, "Endpoint: "+fmt.Sprintf("%#v", this.Endpoint)+",\n")
	}
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_Rules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GetSpecType_Rules{` +
		`Rules:` + fmt.Sprintf("%#v", this.Rules) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LegacyRules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_policy.GetSpecType_LegacyRules{` +
		`LegacyRules:` + fmt.Sprintf("%#v", this.LegacyRules) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *EndpointChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndpointChoice != nil {
		{
			size := m.EndpointChoice.Size()
			i -= size
			if _, err := m.EndpointChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EndpointChoiceType_PrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointChoiceType_PrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrefixList != nil {
		{
			size, err := m.PrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EndpointChoiceType_Any) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointChoiceType_Any) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Any != nil {
		{
			size, err := m.Any.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EndpointChoiceType_OutsideEndpoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointChoiceType_OutsideEndpoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OutsideEndpoints != nil {
		{
			size, err := m.OutsideEndpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *EndpointChoiceType_InsideEndpoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointChoiceType_InsideEndpoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InsideEndpoints != nil {
		{
			size, err := m.InsideEndpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *EndpointChoiceType_Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointChoiceType_Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Interface != nil {
		{
			size, err := m.Interface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *EndpointChoiceType_Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointChoiceType_Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Namespace)
	copy(dAtA[i:], m.Namespace)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *EndpointChoiceType_LabelSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointChoiceType_LabelSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LabelSelector != nil {
		{
			size, err := m.LabelSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ApplicationsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Applications) > 0 {
		dAtA8 := make([]byte, len(m.Applications)*10)
		var j7 int
		for _, num := range m.Applications {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintTypes(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolPortType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolPortType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolPortType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PortRanges) > 0 {
		for iNdEx := len(m.PortRanges) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PortRanges[iNdEx])
			copy(dAtA[i:], m.PortRanges[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.PortRanges[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPolicyRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPolicyRuleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.AdvAction != nil {
		{
			size, err := m.AdvAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.RuleDescription) > 0 {
		i -= len(m.RuleDescription)
		copy(dAtA[i:], m.RuleDescription)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RuleDescription)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.TrafficChoice != nil {
		{
			size := m.TrafficChoice.Size()
			i -= size
			if _, err := m.TrafficChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OtherEndpoint != nil {
		{
			size := m.OtherEndpoint.Size()
			i -= size
			if _, err := m.OtherEndpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.RuleName) > 0 {
		i -= len(m.RuleName)
		copy(dAtA[i:], m.RuleName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RuleName)))
		i--
		dAtA[i] = 0x52
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPolicyRuleType_IpPrefixSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_IpPrefixSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixSet != nil {
		{
			size, err := m.IpPrefixSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_Any) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_Any) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Any != nil {
		{
			size, err := m.Any.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_PrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_PrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrefixList != nil {
		{
			size, err := m.PrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_OutsideEndpoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_OutsideEndpoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OutsideEndpoints != nil {
		{
			size, err := m.OutsideEndpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_InsideEndpoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_InsideEndpoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InsideEndpoints != nil {
		{
			size, err := m.InsideEndpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Namespace)
	copy(dAtA[i:], m.Namespace)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
	i--
	dAtA[i] = 0x7a
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_LabelSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_LabelSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LabelSelector != nil {
		{
			size, err := m.LabelSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_AllTraffic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_AllTraffic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllTraffic != nil {
		{
			size, err := m.AllTraffic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_AllTcpTraffic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_AllTcpTraffic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllTcpTraffic != nil {
		{
			size, err := m.AllTcpTraffic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_AllUdpTraffic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_AllUdpTraffic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllUdpTraffic != nil {
		{
			size, err := m.AllUdpTraffic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_Applications) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_Applications) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Applications != nil {
		{
			size, err := m.Applications.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleType_ProtocolPortRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleType_ProtocolPortRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProtocolPortRange != nil {
		{
			size, err := m.ProtocolPortRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *NetworkPolicyRuleChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPolicyRuleChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkPolicyRuleChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EgressRules) > 0 {
		for iNdEx := len(m.EgressRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EgressRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.IngressRules) > 0 {
		for iNdEx := len(m.IngressRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IngressRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LegacyNetworkPolicyRuleChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LegacyNetworkPolicyRuleChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LegacyNetworkPolicyRuleChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EgressRules) > 0 {
		for iNdEx := len(m.EgressRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EgressRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.IngressRules) > 0 {
		for iNdEx := len(m.IngressRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IngressRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ViewInternal != nil {
		{
			size, err := m.ViewInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ForwardingClass) > 0 {
		for iNdEx := len(m.ForwardingClass) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForwardingClass[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EgressRules) > 0 {
		for iNdEx := len(m.EgressRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EgressRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IngressRules) > 0 {
		for iNdEx := len(m.IngressRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IngressRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.LocalEndpoint != nil {
		{
			size := m.LocalEndpoint.Size()
			i -= size
			if _, err := m.LocalEndpoint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_PrefixSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_PrefixSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrefixSelector != nil {
		{
			size, err := m.PrefixSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Rules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Rules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rules != nil {
		{
			size, err := m.Rules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_LegacyRules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_LegacyRules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRules != nil {
		{
			size, err := m.LegacyRules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rules != nil {
		{
			size, err := m.Rules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_Rules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Rules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rules != nil {
		{
			size, err := m.Rules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_LegacyRules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_LegacyRules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRules != nil {
		{
			size, err := m.LegacyRules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_Rules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Rules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rules != nil {
		{
			size, err := m.Rules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_LegacyRules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_LegacyRules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyRules != nil {
		{
			size, err := m.LegacyRules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EndpointChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndpointChoice != nil {
		n += m.EndpointChoice.Size()
	}
	return n
}

func (m *EndpointChoiceType_PrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixList != nil {
		l = m.PrefixList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EndpointChoiceType_Any) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Any != nil {
		l = m.Any.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EndpointChoiceType_OutsideEndpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutsideEndpoints != nil {
		l = m.OutsideEndpoints.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EndpointChoiceType_InsideEndpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InsideEndpoints != nil {
		l = m.InsideEndpoints.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EndpointChoiceType_Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interface != nil {
		l = m.Interface.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EndpointChoiceType_Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *EndpointChoiceType_LabelSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LabelSelector != nil {
		l = m.LabelSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ApplicationsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Applications) > 0 {
		l = 0
		for _, e := range m.Applications {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *ProtocolPortType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.PortRanges) > 0 {
		for _, s := range m.PortRanges {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkPolicyRuleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.OtherEndpoint != nil {
		n += m.OtherEndpoint.Size()
	}
	l = len(m.RuleName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TrafficChoice != nil {
		n += m.TrafficChoice.Size()
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.RuleDescription)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AdvAction != nil {
		l = m.AdvAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NetworkPolicyRuleType_IpPrefixSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixSet != nil {
		l = m.IpPrefixSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_Any) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Any != nil {
		l = m.Any.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_PrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixList != nil {
		l = m.PrefixList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_OutsideEndpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutsideEndpoints != nil {
		l = m.OutsideEndpoints.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_InsideEndpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InsideEndpoints != nil {
		l = m.InsideEndpoints.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *NetworkPolicyRuleType_LabelSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LabelSelector != nil {
		l = m.LabelSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_AllTraffic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllTraffic != nil {
		l = m.AllTraffic.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_AllTcpTraffic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllTcpTraffic != nil {
		l = m.AllTcpTraffic.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_AllUdpTraffic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllUdpTraffic != nil {
		l = m.AllUdpTraffic.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_Applications) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Applications != nil {
		l = m.Applications.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleType_ProtocolPortRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolPortRange != nil {
		l = m.ProtocolPortRange.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkPolicyRuleChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IngressRules) > 0 {
		for _, e := range m.IngressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LegacyNetworkPolicyRuleChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IngressRules) > 0 {
		for _, e := range m.IngressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocalEndpoint != nil {
		n += m.LocalEndpoint.Size()
	}
	if len(m.IngressRules) > 0 {
		for _, e := range m.IngressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ForwardingClass) > 0 {
		for _, e := range m.ForwardingClass {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_PrefixSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrefixSelector != nil {
		l = m.PrefixSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Rules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rules != nil {
		l = m.Rules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LegacyRules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRules != nil {
		l = m.LegacyRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Rules != nil {
		l = m.Rules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_Rules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rules != nil {
		l = m.Rules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LegacyRules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRules != nil {
		l = m.LegacyRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	return n
}

func (m *GetSpecType_Rules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rules != nil {
		l = m.Rules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LegacyRules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyRules != nil {
		l = m.LegacyRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *EndpointChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointChoiceType{`,
		`EndpointChoice:` + fmt.Sprintf("%v", this.EndpointChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointChoiceType_PrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointChoiceType_PrefixList{`,
		`PrefixList:` + strings.Replace(fmt.Sprintf("%v", this.PrefixList), "PrefixStringListType", "views.PrefixStringListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointChoiceType_Any) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointChoiceType_Any{`,
		`Any:` + strings.Replace(fmt.Sprintf("%v", this.Any), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointChoiceType_OutsideEndpoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointChoiceType_OutsideEndpoints{`,
		`OutsideEndpoints:` + strings.Replace(fmt.Sprintf("%v", this.OutsideEndpoints), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointChoiceType_InsideEndpoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointChoiceType_InsideEndpoints{`,
		`InsideEndpoints:` + strings.Replace(fmt.Sprintf("%v", this.InsideEndpoints), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointChoiceType_Interface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointChoiceType_Interface{`,
		`Interface:` + strings.Replace(fmt.Sprintf("%v", this.Interface), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointChoiceType_Namespace) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointChoiceType_Namespace{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointChoiceType_LabelSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointChoiceType_LabelSelector{`,
		`LabelSelector:` + strings.Replace(fmt.Sprintf("%v", this.LabelSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ApplicationsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ApplicationsType{`,
		`Applications:` + fmt.Sprintf("%v", this.Applications) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolPortType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtocolPortType{`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`PortRanges:` + fmt.Sprintf("%v", this.PortRanges) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`OtherEndpoint:` + fmt.Sprintf("%v", this.OtherEndpoint) + `,`,
		`RuleName:` + fmt.Sprintf("%v", this.RuleName) + `,`,
		`TrafficChoice:` + fmt.Sprintf("%v", this.TrafficChoice) + `,`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`RuleDescription:` + fmt.Sprintf("%v", this.RuleDescription) + `,`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`AdvAction:` + strings.Replace(fmt.Sprintf("%v", this.AdvAction), "NetworkPolicyRuleAdvancedAction", "network_policy_rule.NetworkPolicyRuleAdvancedAction", 1) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_IpPrefixSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_IpPrefixSet{`,
		`IpPrefixSet:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixSet), "IpPrefixSetRefType", "schema.IpPrefixSetRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_Any) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_Any{`,
		`Any:` + strings.Replace(fmt.Sprintf("%v", this.Any), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_PrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_PrefixList{`,
		`PrefixList:` + strings.Replace(fmt.Sprintf("%v", this.PrefixList), "PrefixStringListType", "views.PrefixStringListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_OutsideEndpoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_OutsideEndpoints{`,
		`OutsideEndpoints:` + strings.Replace(fmt.Sprintf("%v", this.OutsideEndpoints), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_InsideEndpoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_InsideEndpoints{`,
		`InsideEndpoints:` + strings.Replace(fmt.Sprintf("%v", this.InsideEndpoints), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_Namespace) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_Namespace{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_LabelSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_LabelSelector{`,
		`LabelSelector:` + strings.Replace(fmt.Sprintf("%v", this.LabelSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_AllTraffic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_AllTraffic{`,
		`AllTraffic:` + strings.Replace(fmt.Sprintf("%v", this.AllTraffic), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_AllTcpTraffic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_AllTcpTraffic{`,
		`AllTcpTraffic:` + strings.Replace(fmt.Sprintf("%v", this.AllTcpTraffic), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_AllUdpTraffic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_AllUdpTraffic{`,
		`AllUdpTraffic:` + strings.Replace(fmt.Sprintf("%v", this.AllUdpTraffic), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_Applications) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_Applications{`,
		`Applications:` + strings.Replace(fmt.Sprintf("%v", this.Applications), "ApplicationsType", "ApplicationsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleType_ProtocolPortRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkPolicyRuleType_ProtocolPortRange{`,
		`ProtocolPortRange:` + strings.Replace(fmt.Sprintf("%v", this.ProtocolPortRange), "ProtocolPortType", "ProtocolPortType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkPolicyRuleChoice) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIngressRules := "[]*NetworkPolicyRuleType{"
	for _, f := range this.IngressRules {
		repeatedStringForIngressRules += strings.Replace(f.String(), "NetworkPolicyRuleType", "NetworkPolicyRuleType", 1) + ","
	}
	repeatedStringForIngressRules += "}"
	repeatedStringForEgressRules := "[]*NetworkPolicyRuleType{"
	for _, f := range this.EgressRules {
		repeatedStringForEgressRules += strings.Replace(f.String(), "NetworkPolicyRuleType", "NetworkPolicyRuleType", 1) + ","
	}
	repeatedStringForEgressRules += "}"
	s := strings.Join([]string{`&NetworkPolicyRuleChoice{`,
		`IngressRules:` + repeatedStringForIngressRules + `,`,
		`EgressRules:` + repeatedStringForEgressRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *LegacyNetworkPolicyRuleChoice) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIngressRules := "[]*ObjectRefType{"
	for _, f := range this.IngressRules {
		repeatedStringForIngressRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForIngressRules += "}"
	repeatedStringForEgressRules := "[]*ObjectRefType{"
	for _, f := range this.EgressRules {
		repeatedStringForEgressRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForEgressRules += "}"
	s := strings.Join([]string{`&LegacyNetworkPolicyRuleChoice{`,
		`IngressRules:` + repeatedStringForIngressRules + `,`,
		`EgressRules:` + repeatedStringForEgressRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIngressRules := "[]*ObjectRefType{"
	for _, f := range this.IngressRules {
		repeatedStringForIngressRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForIngressRules += "}"
	repeatedStringForEgressRules := "[]*ObjectRefType{"
	for _, f := range this.EgressRules {
		repeatedStringForEgressRules += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForEgressRules += "}"
	repeatedStringForForwardingClass := "[]*ObjectRefType{"
	for _, f := range this.ForwardingClass {
		repeatedStringForForwardingClass += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForForwardingClass += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`LocalEndpoint:` + fmt.Sprintf("%v", this.LocalEndpoint) + `,`,
		`IngressRules:` + repeatedStringForIngressRules + `,`,
		`EgressRules:` + repeatedStringForEgressRules + `,`,
		`ForwardingClass:` + repeatedStringForForwardingClass + `,`,
		`Endpoint:` + strings.Replace(this.Endpoint.String(), "EndpointChoiceType", "EndpointChoiceType", 1) + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Prefix{`,
		`Prefix:` + strings.Replace(fmt.Sprintf("%v", this.Prefix), "PrefixListType", "schema.PrefixListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PrefixSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PrefixSelector{`,
		`PrefixSelector:` + strings.Replace(fmt.Sprintf("%v", this.PrefixSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Rules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Rules{`,
		`Rules:` + strings.Replace(fmt.Sprintf("%v", this.Rules), "NetworkPolicyRuleChoice", "NetworkPolicyRuleChoice", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LegacyRules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LegacyRules{`,
		`LegacyRules:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRules), "LegacyNetworkPolicyRuleChoice", "LegacyNetworkPolicyRuleChoice", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Endpoint:` + strings.Replace(this.Endpoint.String(), "EndpointChoiceType", "EndpointChoiceType", 1) + `,`,
		`Rules:` + strings.Replace(this.Rules.String(), "NetworkPolicyRuleChoice", "NetworkPolicyRuleChoice", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Endpoint:` + strings.Replace(this.Endpoint.String(), "EndpointChoiceType", "EndpointChoiceType", 1) + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Rules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Rules{`,
		`Rules:` + strings.Replace(fmt.Sprintf("%v", this.Rules), "NetworkPolicyRuleChoice", "NetworkPolicyRuleChoice", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LegacyRules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LegacyRules{`,
		`LegacyRules:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRules), "LegacyNetworkPolicyRuleChoice", "LegacyNetworkPolicyRuleChoice", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Endpoint:` + strings.Replace(this.Endpoint.String(), "EndpointChoiceType", "EndpointChoiceType", 1) + `,`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Rules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Rules{`,
		`Rules:` + strings.Replace(fmt.Sprintf("%v", this.Rules), "NetworkPolicyRuleChoice", "NetworkPolicyRuleChoice", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LegacyRules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LegacyRules{`,
		`LegacyRules:` + strings.Replace(fmt.Sprintf("%v", this.LegacyRules), "LegacyNetworkPolicyRuleChoice", "LegacyNetworkPolicyRuleChoice", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *EndpointChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.PrefixStringListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointChoice = &EndpointChoiceType_PrefixList{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointChoice = &EndpointChoiceType_Any{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointChoice = &EndpointChoiceType_OutsideEndpoints{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointChoice = &EndpointChoiceType_InsideEndpoints{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointChoice = &EndpointChoiceType_Interface{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointChoice = &EndpointChoiceType_Namespace{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EndpointChoice = &EndpointChoiceType_LabelSelector{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v ApplicationEnumType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ApplicationEnumType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Applications = append(m.Applications, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Applications) == 0 {
					m.Applications = make([]ApplicationEnumType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ApplicationEnumType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ApplicationEnumType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Applications = append(m.Applications, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Applications", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolPortType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolPortType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolPortType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortRanges = append(m.PortRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPolicyRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPolicyRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPolicyRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= network_policy_rule.NetworkPolicyRuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.IpPrefixSetRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OtherEndpoint = &NetworkPolicyRuleType_IpPrefixSet{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OtherEndpoint = &NetworkPolicyRuleType_Any{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.PrefixStringListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OtherEndpoint = &NetworkPolicyRuleType_PrefixList{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OtherEndpoint = &NetworkPolicyRuleType_OutsideEndpoints{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideEndpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OtherEndpoint = &NetworkPolicyRuleType_InsideEndpoints{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherEndpoint = &NetworkPolicyRuleType_Namespace{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OtherEndpoint = &NetworkPolicyRuleType_LabelSelector{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllTraffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrafficChoice = &NetworkPolicyRuleType_AllTraffic{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllTcpTraffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrafficChoice = &NetworkPolicyRuleType_AllTcpTraffic{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllUdpTraffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrafficChoice = &NetworkPolicyRuleType_AllUdpTraffic{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applications", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ApplicationsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrafficChoice = &NetworkPolicyRuleType_Applications{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolPortRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProtocolPortType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrafficChoice = &NetworkPolicyRuleType_ProtocolPortRange{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvAction == nil {
				m.AdvAction = &network_policy_rule.NetworkPolicyRuleAdvancedAction{}
			}
			if err := m.AdvAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPolicyRuleChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPolicyRuleChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPolicyRuleChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressRules = append(m.IngressRules, &NetworkPolicyRuleType{})
			if err := m.IngressRules[len(m.IngressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, &NetworkPolicyRuleType{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LegacyNetworkPolicyRuleChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LegacyNetworkPolicyRuleChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LegacyNetworkPolicyRuleChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressRules = append(m.IngressRules, &schema.ObjectRefType{})
			if err := m.IngressRules[len(m.IngressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, &schema.ObjectRefType{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.PrefixListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &GlobalSpecType_Prefix{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalEndpoint = &GlobalSpecType_PrefixSelector{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressRules = append(m.IngressRules, &schema.ObjectRefType{})
			if err := m.IngressRules[len(m.IngressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, &schema.ObjectRefType{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingClass = append(m.ForwardingClass, &schema.ObjectRefType{})
			if err := m.ForwardingClass[len(m.ForwardingClass)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &EndpointChoiceType{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkPolicyRuleChoice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_Rules{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyNetworkPolicyRuleChoice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GlobalSpecType_LegacyRules{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &EndpointChoiceType{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rules == nil {
				m.Rules = &NetworkPolicyRuleChoice{}
			}
			if err := m.Rules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &EndpointChoiceType{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkPolicyRuleChoice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_Rules{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyNetworkPolicyRuleChoice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &ReplaceSpecType_LegacyRules{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &EndpointChoiceType{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkPolicyRuleChoice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_Rules{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyNetworkPolicyRuleChoice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &GetSpecType_LegacyRules{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
