// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/address_allocator/types.proto

package address_allocator

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Allocator Mode
//
// x-displayName: "Allocator Mode"
// Mode of the address allocator
type AllocatorMode int32

const (
	// x-displayName: "Local"
	// Address allocator is for VERs within the local cluster or site
	LOCAL AllocatorMode = 0
	// x-displayName: "Global per Site:Node"
	// Allocation is per site and then per node
	GLOBAL_PER_SITE_NODE AllocatorMode = 1
)

var AllocatorMode_name = map[int32]string{
	0: "LOCAL",
	1: "GLOBAL_PER_SITE_NODE",
}

var AllocatorMode_value = map[string]int32{
	"LOCAL":                0,
	"GLOBAL_PER_SITE_NODE": 1,
}

func (AllocatorMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bf718da8d8994be9, []int{0}
}

// Local Interface Address
//
// x-displayName: "Local Interface Address Type"
// Dictates how local interface address is derived from the allocated subnet
type LocalInterfaceAddressType int32

const (
	// x-displayName: "Offset from beginning of Subnet"
	//
	// Use Nth address of the allocated subnet as the local interface address, N being the
	// Local Interface Address Offset. For example, if the allocated subnet is 169.254.0.0/30,
	// Local Interface Address Offset is set to 2 and Local Interface Address Type is set to
	// "Offset from beginning of Subnet", local address of 169.254.0.2 is used.
	LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_BEGIN LocalInterfaceAddressType = 0
	// x-displayName: "Offset from end of Subnet"
	//
	// Use Nth last address of the allocated subnet as the local interface address, N being the
	// Local Interface Address Offset. For example, if the allocated subnet is 169.254.0.0/30,
	// Local Interface Address Offset is set to 1 and Local Interface Address Type is set to
	// "Offset from end of Subnet", local address of 169.254.0.2 is used.
	LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_END LocalInterfaceAddressType = 1
	// x-displayName: "Offset from Prefix"
	//
	// This case is used for external_connector
	LOCAL_INTERFACE_ADDRESS_FROM_PREFIX LocalInterfaceAddressType = 2
)

var LocalInterfaceAddressType_name = map[int32]string{
	0: "LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_BEGIN",
	1: "LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_END",
	2: "LOCAL_INTERFACE_ADDRESS_FROM_PREFIX",
}

var LocalInterfaceAddressType_value = map[string]int32{
	"LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_BEGIN": 0,
	"LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_END":   1,
	"LOCAL_INTERFACE_ADDRESS_FROM_PREFIX":              2,
}

func (LocalInterfaceAddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bf718da8d8994be9, []int{1}
}

// Address Allocation Scheme
//
// x-displayName: "Address Allocation Scheme"
// Decides the scheme to be used to allocate addresses from the configured address pool.
type AllocationScheme struct {
	// Allocation Unit
	//
	// x-displayName: "Allocation Unit"
	// x-required
	// x-example: "30"
	// Prefix length indicating the size of each allocated subnet. For example, if this is
	// specified as 30, subnets of /30 will be allocated from the given address pool.
	AllocationUnit uint32 `protobuf:"varint,1,opt,name=allocation_unit,json=allocationUnit,proto3" json:"allocation_unit,omitempty"`
	// Local Interface Address Type
	//
	// x-displayName: "Local Interface Address Type"
	//
	// Decides how address for local interface is derived from the allocated subnet.
	LocalInterfaceAddressType LocalInterfaceAddressType `protobuf:"varint,2,opt,name=local_interface_address_type,json=localInterfaceAddressType,proto3,enum=ves.io.schema.address_allocator.LocalInterfaceAddressType" json:"local_interface_address_type,omitempty"`
	// Local Interface Address Offset
	//
	// x-displayName: "Local Interface Address Offset"
	// x-example: "2"
	//
	// This is used to derive address for the local interface from the allocated subnet.
	//
	// If Local Interface Address Type is set to "Offset from beginning of Subnet", this offset value is added
	// to the allocated subnet and used as the local interface address. For example, if the allocated subnet is
	// 169.254.0.0/30 and offset is set to 2 with Local Interface Address Type set to "Offset from beginning
	// of Subnet", local interface address of 169.254.0.2 is used.
	//
	// If Local Interface Address Type is set to "Offset from end of Subnet", this offset value is subtracted
	// from the end of the allocated subnet and used as the local interface address. For example, if the allocated
	// subnet is 169.254.0.0/30 and offset is set to 1 with Local Interface Address Type set to "Offset from
	// end of Subnet", local interface address of 169.254.0.2 is used.
	LocalInterfaceAddressOffset uint32 `protobuf:"varint,3,opt,name=local_interface_address_offset,json=localInterfaceAddressOffset,proto3" json:"local_interface_address_offset,omitempty"`
}

func (m *AllocationScheme) Reset()      { *m = AllocationScheme{} }
func (*AllocationScheme) ProtoMessage() {}
func (*AllocationScheme) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf718da8d8994be9, []int{0}
}
func (m *AllocationScheme) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocationScheme) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllocationScheme) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationScheme.Merge(m, src)
}
func (m *AllocationScheme) XXX_Size() int {
	return m.Size()
}
func (m *AllocationScheme) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationScheme.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationScheme proto.InternalMessageInfo

func (m *AllocationScheme) GetAllocationUnit() uint32 {
	if m != nil {
		return m.AllocationUnit
	}
	return 0
}

func (m *AllocationScheme) GetLocalInterfaceAddressType() LocalInterfaceAddressType {
	if m != nil {
		return m.LocalInterfaceAddressType
	}
	return LOCAL_INTERFACE_ADDRESS_OFFSET_FROM_SUBNET_BEGIN
}

func (m *AllocationScheme) GetLocalInterfaceAddressOffset() uint32 {
	if m != nil {
		return m.LocalInterfaceAddressOffset
	}
	return 0
}

// Node Allocation
//
// x-displayName: "Node Allocation"
// Addresses allocated to Node
type NodePrefixType struct {
	// IP Subnet
	//
	// x-displayName: "IP Subnet"
	// Allocated IP subnet of the node
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Remote IP Subnet
	//
	// x-displayName: "Remote IP Subnet"
	// Remote IP subnet of the node
	RemotePrefix string `protobuf:"bytes,2,opt,name=remote_prefix,json=remotePrefix,proto3" json:"remote_prefix,omitempty"`
}

func (m *NodePrefixType) Reset()      { *m = NodePrefixType{} }
func (*NodePrefixType) ProtoMessage() {}
func (*NodePrefixType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf718da8d8994be9, []int{1}
}
func (m *NodePrefixType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodePrefixType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodePrefixType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodePrefixType.Merge(m, src)
}
func (m *NodePrefixType) XXX_Size() int {
	return m.Size()
}
func (m *NodePrefixType) XXX_DiscardUnknown() {
	xxx_messageInfo_NodePrefixType.DiscardUnknown(m)
}

var xxx_messageInfo_NodePrefixType proto.InternalMessageInfo

func (m *NodePrefixType) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *NodePrefixType) GetRemotePrefix() string {
	if m != nil {
		return m.RemotePrefix
	}
	return ""
}

// Node Allocation Map
//
// x-displayName: "Node Allocation Map"
// Allocated ip subnet per Node.
type NodePrefixMapType struct {
	// Node Prefix Map
	//
	// x-displayName: "Node Prefix Map"
	// Map of site:node to node prefix
	Endpoints map[string]*NodePrefixType `protobuf:"bytes,2,rep,name=endpoints,proto3" json:"endpoints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NodePrefixMapType) Reset()      { *m = NodePrefixMapType{} }
func (*NodePrefixMapType) ProtoMessage() {}
func (*NodePrefixMapType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf718da8d8994be9, []int{2}
}
func (m *NodePrefixMapType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodePrefixMapType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodePrefixMapType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodePrefixMapType.Merge(m, src)
}
func (m *NodePrefixMapType) XXX_Size() int {
	return m.Size()
}
func (m *NodePrefixMapType) XXX_DiscardUnknown() {
	xxx_messageInfo_NodePrefixMapType.DiscardUnknown(m)
}

var xxx_messageInfo_NodePrefixMapType proto.InternalMessageInfo

func (m *NodePrefixMapType) GetEndpoints() map[string]*NodePrefixType {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

// Global Specification
//
// x-displayName: "Global Specification"
// Address Allocator specification
type GlobalSpecType struct {
	// Address Allocator Mode
	//
	// x-displayName: "Address Allocator Mode"
	// x-required
	// Configures the mode the address allocator.
	// Currently, only local mode is supported - the address allocator is limited
	// to VERs within local cluster.
	Mode AllocatorMode `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.address_allocator.AllocatorMode" json:"mode,omitempty"`
	// Address Pool
	//
	// x-displayName: "Address Pool"
	// x-example: "10.1.1.0/24"
	// x-required
	// Address pool from which the allocator carves out subnets or addresses to its clients.
	AddressPool []string `protobuf:"bytes,4,rep,name=address_pool,json=addressPool,proto3" json:"address_pool,omitempty"`
	// Address Allocation Scheme
	//
	// x-displayName: "Address Allocation Scheme"
	// x-required
	// Configures the scheme to be used to allocate addresses from the configured address pool.
	AddressAllocationScheme *AllocationScheme `protobuf:"bytes,3,opt,name=address_allocation_scheme,json=addressAllocationScheme,proto3" json:"address_allocation_scheme,omitempty"`
	// Internal allocation
	//
	// x-displayName: "Internal allocation"
	// Per Site:Node Allocation in global per site node mode.
	AllocationMap *NodePrefixMapType `protobuf:"bytes,5,opt,name=allocation_map,json=allocationMap,proto3" json:"allocation_map,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf718da8d8994be9, []int{3}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetMode() AllocatorMode {
	if m != nil {
		return m.Mode
	}
	return LOCAL
}

func (m *GlobalSpecType) GetAddressPool() []string {
	if m != nil {
		return m.AddressPool
	}
	return nil
}

func (m *GlobalSpecType) GetAddressAllocationScheme() *AllocationScheme {
	if m != nil {
		return m.AddressAllocationScheme
	}
	return nil
}

func (m *GlobalSpecType) GetAllocationMap() *NodePrefixMapType {
	if m != nil {
		return m.AllocationMap
	}
	return nil
}

// Create Address Allocator
//
// x-displayName: "Create Address Allocator"
// Create Address Allocator will create an address allocator object in 'system' namespace of the user
type CreateSpecType struct {
	Mode                    AllocatorMode     `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.address_allocator.AllocatorMode" json:"mode,omitempty"`
	AddressPool             []string          `protobuf:"bytes,4,rep,name=address_pool,json=addressPool,proto3" json:"address_pool,omitempty"`
	AddressAllocationScheme *AllocationScheme `protobuf:"bytes,3,opt,name=address_allocation_scheme,json=addressAllocationScheme,proto3" json:"address_allocation_scheme,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf718da8d8994be9, []int{4}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetMode() AllocatorMode {
	if m != nil {
		return m.Mode
	}
	return LOCAL
}

func (m *CreateSpecType) GetAddressPool() []string {
	if m != nil {
		return m.AddressPool
	}
	return nil
}

func (m *CreateSpecType) GetAddressAllocationScheme() *AllocationScheme {
	if m != nil {
		return m.AddressAllocationScheme
	}
	return nil
}

// Get Address Allocator
//
// x-displayName: "Get Address Allocator"
// Get Address Allocator will get address allocator object from system namespace
type GetSpecType struct {
	Mode                    AllocatorMode     `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.address_allocator.AllocatorMode" json:"mode,omitempty"`
	AddressPool             []string          `protobuf:"bytes,4,rep,name=address_pool,json=addressPool,proto3" json:"address_pool,omitempty"`
	AddressAllocationScheme *AllocationScheme `protobuf:"bytes,3,opt,name=address_allocation_scheme,json=addressAllocationScheme,proto3" json:"address_allocation_scheme,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf718da8d8994be9, []int{5}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetMode() AllocatorMode {
	if m != nil {
		return m.Mode
	}
	return LOCAL
}

func (m *GetSpecType) GetAddressPool() []string {
	if m != nil {
		return m.AddressPool
	}
	return nil
}

func (m *GetSpecType) GetAddressAllocationScheme() *AllocationScheme {
	if m != nil {
		return m.AddressAllocationScheme
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.address_allocator.AllocatorMode", AllocatorMode_name, AllocatorMode_value)
	golang_proto.RegisterEnum("ves.io.schema.address_allocator.AllocatorMode", AllocatorMode_name, AllocatorMode_value)
	proto.RegisterEnum("ves.io.schema.address_allocator.LocalInterfaceAddressType", LocalInterfaceAddressType_name, LocalInterfaceAddressType_value)
	golang_proto.RegisterEnum("ves.io.schema.address_allocator.LocalInterfaceAddressType", LocalInterfaceAddressType_name, LocalInterfaceAddressType_value)
	proto.RegisterType((*AllocationScheme)(nil), "ves.io.schema.address_allocator.AllocationScheme")
	golang_proto.RegisterType((*AllocationScheme)(nil), "ves.io.schema.address_allocator.AllocationScheme")
	proto.RegisterType((*NodePrefixType)(nil), "ves.io.schema.address_allocator.NodePrefixType")
	golang_proto.RegisterType((*NodePrefixType)(nil), "ves.io.schema.address_allocator.NodePrefixType")
	proto.RegisterType((*NodePrefixMapType)(nil), "ves.io.schema.address_allocator.NodePrefixMapType")
	golang_proto.RegisterType((*NodePrefixMapType)(nil), "ves.io.schema.address_allocator.NodePrefixMapType")
	proto.RegisterMapType((map[string]*NodePrefixType)(nil), "ves.io.schema.address_allocator.NodePrefixMapType.EndpointsEntry")
	golang_proto.RegisterMapType((map[string]*NodePrefixType)(nil), "ves.io.schema.address_allocator.NodePrefixMapType.EndpointsEntry")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.address_allocator.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.address_allocator.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.address_allocator.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.address_allocator.CreateSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.address_allocator.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.address_allocator.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/address_allocator/types.proto", fileDescriptor_bf718da8d8994be9)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/address_allocator/types.proto", fileDescriptor_bf718da8d8994be9)
}

var fileDescriptor_bf718da8d8994be9 = []byte{
	// 906 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x56, 0x31, 0x6f, 0xdb, 0x46,
	0x14, 0xd6, 0x91, 0x96, 0x1d, 0x3d, 0xd9, 0x2a, 0x4d, 0x14, 0x08, 0xa5, 0xb8, 0x2c, 0xcb, 0x0c,
	0x35, 0xdc, 0x9a, 0x6c, 0x14, 0x17, 0x68, 0x3d, 0x14, 0x10, 0x6d, 0xca, 0x50, 0x21, 0x4b, 0x06,
	0x25, 0x03, 0x45, 0x17, 0x82, 0x92, 0x4e, 0x0a, 0x11, 0x8a, 0x47, 0x50, 0x27, 0x35, 0x46, 0x11,
	0xc0, 0xfd, 0x07, 0x45, 0xb2, 0xe5, 0x17, 0x74, 0x2a, 0x3a, 0x37, 0x4b, 0xd0, 0xa9, 0xe8, 0xe4,
	0xd1, 0x63, 0x2d, 0x2f, 0xe9, 0x96, 0xa9, 0x68, 0xb7, 0x82, 0x47, 0x2a, 0xb2, 0xec, 0x08, 0xae,
	0x81, 0x02, 0x1d, 0xb2, 0xbd, 0xe3, 0xf7, 0xbd, 0xef, 0x7d, 0xf7, 0xde, 0x9d, 0x4e, 0xf0, 0xd1,
	0x08, 0x0f, 0x34, 0x97, 0xe8, 0x83, 0xf6, 0x03, 0xdc, 0x77, 0x74, 0xa7, 0xd3, 0x09, 0xf1, 0x60,
	0x60, 0x3b, 0x9e, 0x47, 0xda, 0x0e, 0x25, 0xa1, 0x4e, 0x8f, 0x02, 0x3c, 0xd0, 0x82, 0x90, 0x50,
	0x22, 0xbe, 0x1f, 0x93, 0xb5, 0x98, 0xac, 0x5d, 0x21, 0x17, 0x36, 0x7b, 0x2e, 0x7d, 0x30, 0x6c,
	0x69, 0x6d, 0xd2, 0xd7, 0x7b, 0xa4, 0x47, 0x74, 0x96, 0xd7, 0x1a, 0x76, 0xd9, 0x8a, 0x2d, 0x58,
	0x14, 0xeb, 0x15, 0x6e, 0xcf, 0x16, 0xf7, 0x31, 0x4d, 0x80, 0x3b, 0xb3, 0x00, 0x09, 0xa8, 0x4b,
	0xfc, 0xc4, 0x45, 0xe1, 0xbd, 0x59, 0x30, 0x18, 0x51, 0xfb, 0x82, 0xc9, 0x42, 0x7e, 0x16, 0xbe,
	0x08, 0xad, 0xcd, 0x42, 0x23, 0xc7, 0x73, 0x3b, 0x0e, 0xc5, 0x09, 0xaa, 0x5c, 0x42, 0x5d, 0xfc,
	0x8d, 0x3d, 0x53, 0x59, 0x7d, 0xca, 0x81, 0x50, 0x8a, 0x37, 0xeb, 0x12, 0xbf, 0x11, 0xf1, 0xb0,
	0x58, 0x84, 0x77, 0x9c, 0xd7, 0xdf, 0xec, 0xa1, 0xef, 0x52, 0x09, 0x29, 0x68, 0x7d, 0xc5, 0xc8,
	0xfc, 0xfc, 0xc7, 0x0b, 0x7e, 0x61, 0x83, 0x93, 0x14, 0x2b, 0x37, 0x65, 0x1c, 0xfa, 0x2e, 0x15,
	0xbf, 0x85, 0xb5, 0x68, 0xed, 0xd9, 0xae, 0x4f, 0x71, 0xd8, 0x75, 0xda, 0xd8, 0x9e, 0x34, 0x33,
	0xf2, 0x2b, 0x71, 0x0a, 0x5a, 0xcf, 0x15, 0xb7, 0xb5, 0x6b, 0xfa, 0xad, 0x55, 0x23, 0x91, 0xca,
	0x44, 0xa3, 0x14, 0xe3, 0xcd, 0xa3, 0x00, 0x5b, 0x79, 0x6f, 0x1e, 0x24, 0xd6, 0x40, 0x9e, 0x57,
	0x9c, 0x74, 0xbb, 0x03, 0x4c, 0x25, 0xfe, 0xb2, 0xff, 0x3b, 0x6f, 0x54, 0xab, 0x33, 0xb6, 0x8a,
	0x21, 0x57, 0x23, 0x1d, 0x7c, 0x10, 0xe2, 0xae, 0xfb, 0x88, 0x55, 0x50, 0x61, 0x31, 0x60, 0x2b,
	0xd6, 0x89, 0x8c, 0x01, 0x91, 0x52, 0x3a, 0xe4, 0xff, 0x42, 0xc8, 0x4a, 0x10, 0x51, 0x87, 0x95,
	0x10, 0xf7, 0x09, 0xc5, 0x76, 0x42, 0xe5, 0xae, 0x50, 0x97, 0x63, 0x42, 0x2c, 0xac, 0x7e, 0xc7,
	0xc1, 0xea, 0xb4, 0xce, 0xbe, 0x13, 0xb0, 0x52, 0x8f, 0x21, 0x83, 0xfd, 0x4e, 0x40, 0x5c, 0x9f,
	0x0e, 0x24, 0x4e, 0xe1, 0xd7, 0xb3, 0xc5, 0xd2, 0xb5, 0x6d, 0xbb, 0x22, 0xa3, 0x99, 0x13, 0x0d,
	0xd3, 0xa7, 0xe1, 0x91, 0xb1, 0x16, 0xb9, 0x58, 0x7e, 0x86, 0x32, 0xea, 0x52, 0x98, 0x16, 0x90,
	0x74, 0xcc, 0x45, 0x1f, 0x16, 0x9f, 0x21, 0x5e, 0x38, 0x46, 0xd6, 0xb4, 0x62, 0xa1, 0x0f, 0xb9,
	0xd9, 0x54, 0x51, 0x00, 0xfe, 0x21, 0x3e, 0x8a, 0x37, 0x6e, 0x45, 0xa1, 0x68, 0x42, 0x7a, 0xe4,
	0x78, 0xc3, 0x78, 0xaa, 0xd9, 0xa2, 0x7e, 0x03, 0x7b, 0x6c, 0x94, 0x71, 0xf6, 0x36, 0xf7, 0x19,
	0x52, 0x7f, 0xe2, 0x21, 0xb7, 0xe7, 0x91, 0x96, 0xe3, 0x35, 0x02, 0xdc, 0x66, 0x0d, 0x30, 0x60,
	0xa1, 0x4f, 0x3a, 0x98, 0x15, 0xcc, 0x15, 0xb5, 0x6b, 0xc5, 0x4b, 0x93, 0x68, 0x9f, 0x74, 0xb0,
	0xc5, 0x72, 0xc5, 0x32, 0x2c, 0x4f, 0x88, 0x01, 0x21, 0x9e, 0xb4, 0xa0, 0xf0, 0xeb, 0x19, 0xe3,
	0x6e, 0xb4, 0x67, 0x78, 0x82, 0x96, 0xd4, 0x78, 0x1e, 0x6c, 0x32, 0x4f, 0x10, 0x27, 0x28, 0x93,
	0xe8, 0x16, 0xb2, 0xb2, 0x49, 0xe2, 0x01, 0x21, 0x9e, 0xd8, 0x87, 0xfc, 0xa5, 0x82, 0xd1, 0x95,
	0x60, 0x56, 0x30, 0x3b, 0x54, 0xd9, 0xe2, 0xbd, 0x7f, 0x6b, 0xf0, 0xf5, 0x05, 0xb3, 0x6e, 0x27,
	0x9c, 0x2b, 0x37, 0xaf, 0x05, 0x17, 0xee, 0x95, 0xdd, 0x77, 0x02, 0x29, 0xcd, 0x6a, 0x14, 0x6f,
	0x7e, 0x00, 0x8c, 0xa5, 0xd3, 0xc7, 0xe8, 0xe5, 0x73, 0x84, 0xac, 0x95, 0xa9, 0xe4, 0xbe, 0x13,
	0x6c, 0x7f, 0xfe, 0xcb, 0x73, 0xf4, 0x29, 0x28, 0x90, 0x4f, 0xce, 0xbc, 0x32, 0x75, 0xa1, 0x24,
	0x36, 0xf8, 0x7b, 0x1f, 0xdf, 0x87, 0x55, 0x58, 0x9e, 0x30, 0x58, 0x2b, 0xd0, 0xd6, 0x97, 0x0b,
	0xb7, 0x38, 0x81, 0x57, 0xff, 0x46, 0x90, 0xdb, 0x09, 0xb1, 0x43, 0xf1, 0x7f, 0x3a, 0xb2, 0x0f,
	0xde, 0x34, 0xb2, 0xff, 0x73, 0x1a, 0xdb, 0xab, 0xbf, 0x7d, 0x71, 0xe9, 0x6c, 0xaa, 0x7f, 0x22,
	0xc8, 0xee, 0x61, 0xfa, 0xd6, 0x6d, 0x7c, 0x63, 0x0b, 0x56, 0x66, 0xbc, 0x8b, 0x19, 0x48, 0x57,
	0xeb, 0x3b, 0xa5, 0xaa, 0x90, 0x12, 0x25, 0x78, 0x77, 0xaf, 0x5a, 0x37, 0x4a, 0x55, 0xfb, 0xc0,
	0xb4, 0xec, 0x46, 0xa5, 0x69, 0xda, 0xb5, 0xfa, 0xae, 0x29, 0xa0, 0x8d, 0x1f, 0x11, 0xe4, 0xe7,
	0xfe, 0xa2, 0x8b, 0x5b, 0xf0, 0x09, 0x93, 0xb0, 0x2b, 0xb5, 0xa6, 0x69, 0x95, 0x4b, 0x3b, 0xa6,
	0x5d, 0xda, 0xdd, 0xb5, 0xcc, 0x46, 0xc3, 0xae, 0x97, 0xcb, 0x0d, 0xb3, 0x69, 0x97, 0xad, 0xfa,
	0xbe, 0xdd, 0x38, 0x34, 0x6a, 0x66, 0xd3, 0x36, 0xcc, 0xbd, 0x4a, 0x4d, 0x48, 0x89, 0x45, 0xd0,
	0x6e, 0x90, 0x65, 0xd6, 0x76, 0x05, 0x24, 0x7e, 0x08, 0x77, 0xe7, 0xe5, 0x30, 0xf2, 0x81, 0x65,
	0x96, 0x2b, 0x5f, 0x09, 0x9c, 0xf1, 0x14, 0x9d, 0x9c, 0xc9, 0xa9, 0xd3, 0x33, 0x39, 0xf5, 0xea,
	0x4c, 0x46, 0xc7, 0x63, 0x19, 0xfd, 0x30, 0x96, 0xd1, 0xaf, 0x63, 0x19, 0x9d, 0x8c, 0x65, 0x74,
	0x3a, 0x96, 0xd1, 0xef, 0x63, 0x19, 0xbd, 0x1c, 0xcb, 0xa9, 0x57, 0x63, 0x19, 0x7d, 0x7f, 0x2e,
	0xa7, 0x5e, 0x9c, 0xcb, 0xe8, 0xe4, 0x5c, 0x4e, 0x9d, 0x9e, 0xcb, 0xa9, 0xaf, 0x0f, 0x7b, 0x24,
	0x78, 0xd8, 0xd3, 0x46, 0xc4, 0xa3, 0x38, 0x0c, 0x1d, 0x6d, 0x38, 0xd0, 0x59, 0xd0, 0x25, 0x61,
	0x7f, 0x33, 0x08, 0xc9, 0xc8, 0xed, 0xe0, 0x70, 0x73, 0x02, 0xeb, 0x41, 0xab, 0x47, 0x74, 0xfc,
	0x88, 0x26, 0xef, 0xf3, 0xbc, 0x7f, 0x2c, 0xad, 0x45, 0xf6, 0x58, 0xdf, 0xff, 0x27, 0x00, 0x00,
	0xff, 0xff, 0xde, 0x4a, 0x1a, 0xdc, 0xdb, 0x08, 0x00, 0x00,
}

func (x AllocatorMode) String() string {
	s, ok := AllocatorMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LocalInterfaceAddressType) String() string {
	s, ok := LocalInterfaceAddressType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AllocationScheme) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllocationScheme)
	if !ok {
		that2, ok := that.(AllocationScheme)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AllocationUnit != that1.AllocationUnit {
		return false
	}
	if this.LocalInterfaceAddressType != that1.LocalInterfaceAddressType {
		return false
	}
	if this.LocalInterfaceAddressOffset != that1.LocalInterfaceAddressOffset {
		return false
	}
	return true
}
func (this *NodePrefixType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodePrefixType)
	if !ok {
		that2, ok := that.(NodePrefixType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	if this.RemotePrefix != that1.RemotePrefix {
		return false
	}
	return true
}
func (this *NodePrefixMapType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodePrefixMapType)
	if !ok {
		that2, ok := that.(NodePrefixMapType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if len(this.AddressPool) != len(that1.AddressPool) {
		return false
	}
	for i := range this.AddressPool {
		if this.AddressPool[i] != that1.AddressPool[i] {
			return false
		}
	}
	if !this.AddressAllocationScheme.Equal(that1.AddressAllocationScheme) {
		return false
	}
	if !this.AllocationMap.Equal(that1.AllocationMap) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if len(this.AddressPool) != len(that1.AddressPool) {
		return false
	}
	for i := range this.AddressPool {
		if this.AddressPool[i] != that1.AddressPool[i] {
			return false
		}
	}
	if !this.AddressAllocationScheme.Equal(that1.AddressAllocationScheme) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if len(this.AddressPool) != len(that1.AddressPool) {
		return false
	}
	for i := range this.AddressPool {
		if this.AddressPool[i] != that1.AddressPool[i] {
			return false
		}
	}
	if !this.AddressAllocationScheme.Equal(that1.AddressAllocationScheme) {
		return false
	}
	return true
}
func (this *AllocationScheme) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&address_allocator.AllocationScheme{")
	s = append(s, "AllocationUnit: "+fmt.Sprintf("%#v", this.AllocationUnit)+",\n")
	s = append(s, "LocalInterfaceAddressType: "+fmt.Sprintf("%#v", this.LocalInterfaceAddressType)+",\n")
	s = append(s, "LocalInterfaceAddressOffset: "+fmt.Sprintf("%#v", this.LocalInterfaceAddressOffset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodePrefixType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&address_allocator.NodePrefixType{")
	s = append(s, "Prefix: "+fmt.Sprintf("%#v", this.Prefix)+",\n")
	s = append(s, "RemotePrefix: "+fmt.Sprintf("%#v", this.RemotePrefix)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodePrefixMapType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&address_allocator.NodePrefixMapType{")
	keysForEndpoints := make([]string, 0, len(this.Endpoints))
	for k, _ := range this.Endpoints {
		keysForEndpoints = append(keysForEndpoints, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpoints)
	mapStringForEndpoints := "map[string]*NodePrefixType{"
	for _, k := range keysForEndpoints {
		mapStringForEndpoints += fmt.Sprintf("%#v: %#v,", k, this.Endpoints[k])
	}
	mapStringForEndpoints += "}"
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+mapStringForEndpoints+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&address_allocator.GlobalSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AddressPool: "+fmt.Sprintf("%#v", this.AddressPool)+",\n")
	if this.AddressAllocationScheme != nil {
		s = append(s, "AddressAllocationScheme: "+fmt.Sprintf("%#v", this.AddressAllocationScheme)+",\n")
	}
	if this.AllocationMap != nil {
		s = append(s, "AllocationMap: "+fmt.Sprintf("%#v", this.AllocationMap)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&address_allocator.CreateSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AddressPool: "+fmt.Sprintf("%#v", this.AddressPool)+",\n")
	if this.AddressAllocationScheme != nil {
		s = append(s, "AddressAllocationScheme: "+fmt.Sprintf("%#v", this.AddressAllocationScheme)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&address_allocator.GetSpecType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "AddressPool: "+fmt.Sprintf("%#v", this.AddressPool)+",\n")
	if this.AddressAllocationScheme != nil {
		s = append(s, "AddressAllocationScheme: "+fmt.Sprintf("%#v", this.AddressAllocationScheme)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AllocationScheme) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocationScheme) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocationScheme) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LocalInterfaceAddressOffset != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LocalInterfaceAddressOffset))
		i--
		dAtA[i] = 0x18
	}
	if m.LocalInterfaceAddressType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LocalInterfaceAddressType))
		i--
		dAtA[i] = 0x10
	}
	if m.AllocationUnit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AllocationUnit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodePrefixType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodePrefixType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodePrefixType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemotePrefix) > 0 {
		i -= len(m.RemotePrefix)
		copy(dAtA[i:], m.RemotePrefix)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RemotePrefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodePrefixMapType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodePrefixMapType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodePrefixMapType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		keysForEndpoints := make([]string, 0, len(m.Endpoints))
		for k := range m.Endpoints {
			keysForEndpoints = append(keysForEndpoints, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForEndpoints)
		for iNdEx := len(keysForEndpoints) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Endpoints[string(keysForEndpoints[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForEndpoints[iNdEx])
			copy(dAtA[i:], keysForEndpoints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForEndpoints[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllocationMap != nil {
		{
			size, err := m.AllocationMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AddressPool) > 0 {
		for iNdEx := len(m.AddressPool) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddressPool[iNdEx])
			copy(dAtA[i:], m.AddressPool[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AddressPool[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.AddressAllocationScheme != nil {
		{
			size, err := m.AddressAllocationScheme.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressPool) > 0 {
		for iNdEx := len(m.AddressPool) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddressPool[iNdEx])
			copy(dAtA[i:], m.AddressPool[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AddressPool[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.AddressAllocationScheme != nil {
		{
			size, err := m.AddressAllocationScheme.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressPool) > 0 {
		for iNdEx := len(m.AddressPool) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddressPool[iNdEx])
			copy(dAtA[i:], m.AddressPool[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AddressPool[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.AddressAllocationScheme != nil {
		{
			size, err := m.AddressAllocationScheme.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AllocationScheme) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllocationUnit != 0 {
		n += 1 + sovTypes(uint64(m.AllocationUnit))
	}
	if m.LocalInterfaceAddressType != 0 {
		n += 1 + sovTypes(uint64(m.LocalInterfaceAddressType))
	}
	if m.LocalInterfaceAddressOffset != 0 {
		n += 1 + sovTypes(uint64(m.LocalInterfaceAddressOffset))
	}
	return n
}

func (m *NodePrefixType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RemotePrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NodePrefixMapType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for k, v := range m.Endpoints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AddressAllocationScheme != nil {
		l = m.AddressAllocationScheme.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AddressPool) > 0 {
		for _, s := range m.AddressPool {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AllocationMap != nil {
		l = m.AllocationMap.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AddressAllocationScheme != nil {
		l = m.AddressAllocationScheme.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AddressPool) > 0 {
		for _, s := range m.AddressPool {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.AddressAllocationScheme != nil {
		l = m.AddressAllocationScheme.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AddressPool) > 0 {
		for _, s := range m.AddressPool {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AllocationScheme) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllocationScheme{`,
		`AllocationUnit:` + fmt.Sprintf("%v", this.AllocationUnit) + `,`,
		`LocalInterfaceAddressType:` + fmt.Sprintf("%v", this.LocalInterfaceAddressType) + `,`,
		`LocalInterfaceAddressOffset:` + fmt.Sprintf("%v", this.LocalInterfaceAddressOffset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodePrefixType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodePrefixType{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`RemotePrefix:` + fmt.Sprintf("%v", this.RemotePrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodePrefixMapType) String() string {
	if this == nil {
		return "nil"
	}
	keysForEndpoints := make([]string, 0, len(this.Endpoints))
	for k, _ := range this.Endpoints {
		keysForEndpoints = append(keysForEndpoints, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpoints)
	mapStringForEndpoints := "map[string]*NodePrefixType{"
	for _, k := range keysForEndpoints {
		mapStringForEndpoints += fmt.Sprintf("%v: %v,", k, this.Endpoints[k])
	}
	mapStringForEndpoints += "}"
	s := strings.Join([]string{`&NodePrefixMapType{`,
		`Endpoints:` + mapStringForEndpoints + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AddressAllocationScheme:` + strings.Replace(this.AddressAllocationScheme.String(), "AllocationScheme", "AllocationScheme", 1) + `,`,
		`AddressPool:` + fmt.Sprintf("%v", this.AddressPool) + `,`,
		`AllocationMap:` + strings.Replace(this.AllocationMap.String(), "NodePrefixMapType", "NodePrefixMapType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AddressAllocationScheme:` + strings.Replace(this.AddressAllocationScheme.String(), "AllocationScheme", "AllocationScheme", 1) + `,`,
		`AddressPool:` + fmt.Sprintf("%v", this.AddressPool) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`AddressAllocationScheme:` + strings.Replace(this.AddressAllocationScheme.String(), "AllocationScheme", "AllocationScheme", 1) + `,`,
		`AddressPool:` + fmt.Sprintf("%v", this.AddressPool) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AllocationScheme) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocationScheme: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocationScheme: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationUnit", wireType)
			}
			m.AllocationUnit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocationUnit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalInterfaceAddressType", wireType)
			}
			m.LocalInterfaceAddressType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalInterfaceAddressType |= LocalInterfaceAddressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalInterfaceAddressOffset", wireType)
			}
			m.LocalInterfaceAddressOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalInterfaceAddressOffset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodePrefixType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodePrefixType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodePrefixType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemotePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodePrefixMapType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodePrefixMapType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodePrefixMapType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoints == nil {
				m.Endpoints = make(map[string]*NodePrefixType)
			}
			var mapkey string
			var mapvalue *NodePrefixType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NodePrefixType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Endpoints[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= AllocatorMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressAllocationScheme", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddressAllocationScheme == nil {
				m.AddressAllocationScheme = &AllocationScheme{}
			}
			if err := m.AddressAllocationScheme.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPool = append(m.AddressPool, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllocationMap == nil {
				m.AllocationMap = &NodePrefixMapType{}
			}
			if err := m.AllocationMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= AllocatorMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressAllocationScheme", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddressAllocationScheme == nil {
				m.AddressAllocationScheme = &AllocationScheme{}
			}
			if err := m.AddressAllocationScheme.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPool = append(m.AddressPool, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= AllocatorMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressAllocationScheme", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddressAllocationScheme == nil {
				m.AddressAllocationScheme = &AllocationScheme{}
			}
			if err := m.AddressAllocationScheme.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressPool = append(m.AddressPool, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
