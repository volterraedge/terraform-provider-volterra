// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package xc_saas

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *GetRegistrationDetailsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetRegistrationDetailsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetRegistrationDetailsRequest) DeepCopy() *GetRegistrationDetailsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetRegistrationDetailsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetRegistrationDetailsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetRegistrationDetailsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetRegistrationDetailsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetRegistrationDetailsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetRegistrationDetailsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetRegistrationDetailsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetRegistrationDetailsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["token"]; exists {

		vOpts := append(opts, db.WithValidateField("token"))
		if err := fv(ctx, m.GetToken(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetRegistrationDetailsRequestValidator = func() *ValidateGetRegistrationDetailsRequest {
	v := &ValidateGetRegistrationDetailsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetRegistrationDetailsRequestValidator() db.Validator {
	return DefaultGetRegistrationDetailsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetRegistrationDetailsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetRegistrationDetailsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetRegistrationDetailsResponse) DeepCopy() *GetRegistrationDetailsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetRegistrationDetailsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetRegistrationDetailsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetRegistrationDetailsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetRegistrationDetailsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGetRegistrationDetailsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetRegistrationDetailsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetRegistrationDetailsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetRegistrationDetailsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["console_url"]; exists {

		vOpts := append(opts, db.WithValidateField("console_url"))
		if err := fv(ctx, m.GetConsoleUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["error_message"]; exists {

		vOpts := append(opts, db.WithValidateField("error_message"))
		if err := fv(ctx, m.GetErrorMessage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetRegistrationDetailsResponseValidator = func() *ValidateGetRegistrationDetailsResponse {
	v := &ValidateGetRegistrationDetailsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetRegistrationDetailsResponseValidator() db.Validator {
	return DefaultGetRegistrationDetailsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SendEmailResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SendEmailResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SendEmailResponse) DeepCopy() *SendEmailResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SendEmailResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SendEmailResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SendEmailResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SendEmailResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSendEmailResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSendEmailResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SendEmailResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SendEmailResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["success"]; exists {

		vOpts := append(opts, db.WithValidateField("success"))
		if err := fv(ctx, m.GetSuccess(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSendEmailResponseValidator = func() *ValidateSendEmailResponse {
	v := &ValidateSendEmailResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SendEmailResponseValidator() db.Validator {
	return DefaultSendEmailResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SendSignupEmailRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SendSignupEmailRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SendSignupEmailRequest) DeepCopy() *SendSignupEmailRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SendSignupEmailRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SendSignupEmailRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SendSignupEmailRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SendSignupEmailRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSendSignupEmailRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSendSignupEmailRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SendSignupEmailRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SendSignupEmailRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["token"]; exists {

		vOpts := append(opts, db.WithValidateField("token"))
		if err := fv(ctx, m.GetToken(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSendSignupEmailRequestValidator = func() *ValidateSendSignupEmailRequest {
	v := &ValidateSendSignupEmailRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SendSignupEmailRequestValidator() db.Validator {
	return DefaultSendSignupEmailRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *XCSaaSSignupRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *XCSaaSSignupRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *XCSaaSSignupRequest) DeepCopy() *XCSaaSSignupRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &XCSaaSSignupRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *XCSaaSSignupRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *XCSaaSSignupRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return XCSaaSSignupRequestValidator().Validate(ctx, m, opts...)
}

type ValidateXCSaaSSignupRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateXCSaaSSignupRequest) DomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain")
	}

	return validatorFn, nil
}

func (v *ValidateXCSaaSSignupRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*XCSaaSSignupRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *XCSaaSSignupRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["token"]; exists {

		vOpts := append(opts, db.WithValidateField("token"))
		if err := fv(ctx, m.GetToken(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultXCSaaSSignupRequestValidator = func() *ValidateXCSaaSSignupRequest {
	v := &ValidateXCSaaSSignupRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomain := v.DomainValidationRuleHandler
	rulesDomain := map[string]string{
		"ves.io.schema.rules.string.max_len":         "17",
		"ves.io.schema.rules.string.min_len":         "1",
		"ves.io.schema.rules.string.not_in":          "[\"ves\",\"volterra\",\"ves-io\",\"f5xc\"]",
		"ves.io.schema.rules.string.ves_object_name": "true",
	}
	vFn, err = vrhDomain(rulesDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for XCSaaSSignupRequest.domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain"] = vFn

	return v
}()

func XCSaaSSignupRequestValidator() db.Validator {
	return DefaultXCSaaSSignupRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *XCSaaSSignupResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *XCSaaSSignupResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *XCSaaSSignupResponse) DeepCopy() *XCSaaSSignupResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &XCSaaSSignupResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *XCSaaSSignupResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *XCSaaSSignupResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return XCSaaSSignupResponseValidator().Validate(ctx, m, opts...)
}

type ValidateXCSaaSSignupResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateXCSaaSSignupResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*XCSaaSSignupResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *XCSaaSSignupResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultXCSaaSSignupResponseValidator = func() *ValidateXCSaaSSignupResponse {
	v := &ValidateXCSaaSSignupResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func XCSaaSSignupResponseValidator() db.Validator {
	return DefaultXCSaaSSignupResponseValidator
}
