// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package upgrade_status

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ApplicationObj) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApplicationObj) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApplicationObj) DeepCopy() *ApplicationObj {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApplicationObj{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApplicationObj) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApplicationObj) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApplicationObjValidator().Validate(ctx, m, opts...)
}

type ValidateApplicationObj struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApplicationObj) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApplicationObj)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApplicationObj got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["conditions"]; exists {

		vOpts := append(opts, db.WithValidateField("conditions"))
		for idx, item := range m.GetConditions() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["debug"]; exists {

		vOpts := append(opts, db.WithValidateField("debug"))
		if err := fv(ctx, m.GetDebug(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deploy_strategy"]; exists {

		vOpts := append(opts, db.WithValidateField("deploy_strategy"))
		if err := fv(ctx, m.GetDeployStrategy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["kind"]; exists {

		vOpts := append(opts, db.WithValidateField("kind"))
		if err := fv(ctx, m.GetKind(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApplicationObjValidator = func() *ValidateApplicationObj {
	v := &ValidateApplicationObj{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ApplicationObjValidator() db.Validator {
	return DefaultApplicationObjValidator
}

// augmented methods on protoc/std generated struct

func (m *Condition) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Condition) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Condition) DeepCopy() *Condition {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Condition{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Condition) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Condition) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConditionValidator().Validate(ctx, m, opts...)
}

type ValidateCondition struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCondition) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Condition)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Condition got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConditionValidator = func() *ValidateCondition {
	v := &ValidateCondition{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ConditionValidator() db.Validator {
	return DefaultConditionValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) SwUpgradeProgressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for sw_upgrade_progress")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["sw_upgrade_progress"]; exists {

		vOpts := append(opts, db.WithValidateField("sw_upgrade_progress"))
		if err := fv(ctx, m.GetSwUpgradeProgress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSwUpgradeProgress := v.SwUpgradeProgressValidationRuleHandler
	rulesSwUpgradeProgress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSwUpgradeProgress(rulesSwUpgradeProgress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.sw_upgrade_progress: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sw_upgrade_progress"] = vFn

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) SwUpgradeProgressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for sw_upgrade_progress")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["sw_upgrade_progress"]; exists {

		vOpts := append(opts, db.WithValidateField("sw_upgrade_progress"))
		if err := fv(ctx, m.GetSwUpgradeProgress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSwUpgradeProgress := v.SwUpgradeProgressValidationRuleHandler
	rulesSwUpgradeProgress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSwUpgradeProgress(rulesSwUpgradeProgress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.sw_upgrade_progress: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sw_upgrade_progress"] = vFn

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) SwUpgradeProgressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for sw_upgrade_progress")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["sw_upgrade_progress"]; exists {

		vOpts := append(opts, db.WithValidateField("sw_upgrade_progress"))
		if err := fv(ctx, m.GetSwUpgradeProgress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSwUpgradeProgress := v.SwUpgradeProgressValidationRuleHandler
	rulesSwUpgradeProgress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSwUpgradeProgress(rulesSwUpgradeProgress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.sw_upgrade_progress: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sw_upgrade_progress"] = vFn

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ImageDownload) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ImageDownload) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ImageDownload) DeepCopy() *ImageDownload {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ImageDownload{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ImageDownload) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ImageDownload) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ImageDownloadValidator().Validate(ctx, m, opts...)
}

type ValidateImageDownload struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateImageDownload) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ImageDownload)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ImageDownload got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["results"]; exists {

		vOpts := append(opts, db.WithValidateField("results"))
		for idx, item := range m.GetResults() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("start_timestamp"))
		if err := fv(ctx, m.GetStartTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultImageDownloadValidator = func() *ValidateImageDownload {
	v := &ValidateImageDownload{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ImageDownloadValidator() db.Validator {
	return DefaultImageDownloadValidator
}

// augmented methods on protoc/std generated struct

func (m *InstallResult) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InstallResult) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InstallResult) DeepCopy() *InstallResult {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InstallResult{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InstallResult) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InstallResult) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InstallResultValidator().Validate(ctx, m, opts...)
}

type ValidateInstallResult struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInstallResult) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InstallResult)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InstallResult got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInstallResultValidator = func() *ValidateInstallResult {
	v := &ValidateInstallResult{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InstallResultValidator() db.Validator {
	return DefaultInstallResultValidator
}

// augmented methods on protoc/std generated struct

func (m *NodeLevelUpgrade) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NodeLevelUpgrade) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NodeLevelUpgrade) DeepCopy() *NodeLevelUpgrade {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NodeLevelUpgrade{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NodeLevelUpgrade) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NodeLevelUpgrade) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeLevelUpgradeValidator().Validate(ctx, m, opts...)
}

type ValidateNodeLevelUpgrade struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNodeLevelUpgrade) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NodeLevelUpgrade)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NodeLevelUpgrade got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["results"]; exists {

		vOpts := append(opts, db.WithValidateField("results"))
		for idx, item := range m.GetResults() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("start_timestamp"))
		if err := fv(ctx, m.GetStartTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeLevelUpgradeValidator = func() *ValidateNodeLevelUpgrade {
	v := &ValidateNodeLevelUpgrade{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NodeLevelUpgradeValidator() db.Validator {
	return DefaultNodeLevelUpgradeValidator
}

// augmented methods on protoc/std generated struct

func (m *NodeUpgradeResult) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NodeUpgradeResult) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NodeUpgradeResult) DeepCopy() *NodeUpgradeResult {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NodeUpgradeResult{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NodeUpgradeResult) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NodeUpgradeResult) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeUpgradeResultValidator().Validate(ctx, m, opts...)
}

type ValidateNodeUpgradeResult struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNodeUpgradeResult) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NodeUpgradeResult)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NodeUpgradeResult got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["progress"]; exists {

		vOpts := append(opts, db.WithValidateField("progress"))
		if err := fv(ctx, m.GetProgress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["results"]; exists {

		vOpts := append(opts, db.WithValidateField("results"))
		for idx, item := range m.GetResults() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeUpgradeResultValidator = func() *ValidateNodeUpgradeResult {
	v := &ValidateNodeUpgradeResult{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NodeUpgradeResultValidator() db.Validator {
	return DefaultNodeUpgradeResultValidator
}

// augmented methods on protoc/std generated struct

func (m *OSNodeResult) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OSNodeResult) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OSNodeResult) DeepCopy() *OSNodeResult {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OSNodeResult{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OSNodeResult) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OSNodeResult) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OSNodeResultValidator().Validate(ctx, m, opts...)
}

type ValidateOSNodeResult struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOSNodeResult) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OSNodeResult)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OSNodeResult got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["results"]; exists {

		vOpts := append(opts, db.WithValidateField("results"))
		for idx, item := range m.GetResults() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOSNodeResultValidator = func() *ValidateOSNodeResult {
	v := &ValidateOSNodeResult{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OSNodeResultValidator() db.Validator {
	return DefaultOSNodeResultValidator
}

// augmented methods on protoc/std generated struct

func (m *OSSetup) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OSSetup) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OSSetup) DeepCopy() *OSSetup {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OSSetup{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OSSetup) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OSSetup) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OSSetupValidator().Validate(ctx, m, opts...)
}

type ValidateOSSetup struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOSSetup) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OSSetup)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OSSetup got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["results"]; exists {

		vOpts := append(opts, db.WithValidateField("results"))
		for idx, item := range m.GetResults() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("start_timestamp"))
		if err := fv(ctx, m.GetStartTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOSSetupValidator = func() *ValidateOSSetup {
	v := &ValidateOSSetup{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OSSetupValidator() db.Validator {
	return DefaultOSSetupValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) SwUpgradeProgressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for sw_upgrade_progress")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["sw_upgrade_progress"]; exists {

		vOpts := append(opts, db.WithValidateField("sw_upgrade_progress"))
		if err := fv(ctx, m.GetSwUpgradeProgress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSwUpgradeProgress := v.SwUpgradeProgressValidationRuleHandler
	rulesSwUpgradeProgress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSwUpgradeProgress(rulesSwUpgradeProgress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.sw_upgrade_progress: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sw_upgrade_progress"] = vFn

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SWUpgradeProgress) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SWUpgradeProgress) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SWUpgradeProgress) DeepCopy() *SWUpgradeProgress {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SWUpgradeProgress{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SWUpgradeProgress) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SWUpgradeProgress) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SWUpgradeProgressValidator().Validate(ctx, m, opts...)
}

type ValidateSWUpgradeProgress struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSWUpgradeProgress) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SWUpgradeProgress)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SWUpgradeProgress got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["failure_reason"]; exists {

		vOpts := append(opts, db.WithValidateField("failure_reason"))
		if err := fv(ctx, m.GetFailureReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["image_download"]; exists {

		vOpts := append(opts, db.WithValidateField("image_download"))
		if err := fv(ctx, m.GetImageDownload(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_level_upgrade"]; exists {

		vOpts := append(opts, db.WithValidateField("node_level_upgrade"))
		if err := fv(ctx, m.GetNodeLevelUpgrade(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["os_setup"]; exists {

		vOpts := append(opts, db.WithValidateField("os_setup"))
		if err := fv(ctx, m.GetOsSetup(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retries"]; exists {

		vOpts := append(opts, db.WithValidateField("retries"))
		if err := fv(ctx, m.GetRetries(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_level_upgrade"]; exists {

		vOpts := append(opts, db.WithValidateField("site_level_upgrade"))
		if err := fv(ctx, m.GetSiteLevelUpgrade(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validation"]; exists {

		vOpts := append(opts, db.WithValidateField("validation"))
		if err := fv(ctx, m.GetValidation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSWUpgradeProgressValidator = func() *ValidateSWUpgradeProgress {
	v := &ValidateSWUpgradeProgress{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SWUpgradeProgressValidator() db.Validator {
	return DefaultSWUpgradeProgressValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteLevelUpgrade) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteLevelUpgrade) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteLevelUpgrade) DeepCopy() *SiteLevelUpgrade {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteLevelUpgrade{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteLevelUpgrade) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteLevelUpgrade) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteLevelUpgradeValidator().Validate(ctx, m, opts...)
}

type ValidateSiteLevelUpgrade struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteLevelUpgrade) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteLevelUpgrade)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteLevelUpgrade got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["progress"]; exists {

		vOpts := append(opts, db.WithValidateField("progress"))
		if err := fv(ctx, m.GetProgress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["results"]; exists {

		vOpts := append(opts, db.WithValidateField("results"))
		for idx, item := range m.GetResults() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("start_timestamp"))
		if err := fv(ctx, m.GetStartTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteLevelUpgradeValidator = func() *ValidateSiteLevelUpgrade {
	v := &ValidateSiteLevelUpgrade{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteLevelUpgradeValidator() db.Validator {
	return DefaultSiteLevelUpgradeValidator
}

// augmented methods on protoc/std generated struct

func (m *StageApplication) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StageApplication) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StageApplication) DeepCopy() *StageApplication {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StageApplication{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StageApplication) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StageApplication) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StageApplicationValidator().Validate(ctx, m, opts...)
}

type ValidateStageApplication struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStageApplication) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StageApplication)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StageApplication got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["objects"]; exists {

		vOpts := append(opts, db.WithValidateField("objects"))
		for idx, item := range m.GetObjects() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStageApplicationValidator = func() *ValidateStageApplication {
	v := &ValidateStageApplication{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StageApplicationValidator() db.Validator {
	return DefaultStageApplicationValidator
}

// augmented methods on protoc/std generated struct

func (m *StageUpgradeResults) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StageUpgradeResults) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StageUpgradeResults) DeepCopy() *StageUpgradeResults {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StageUpgradeResults{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StageUpgradeResults) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StageUpgradeResults) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StageUpgradeResultsValidator().Validate(ctx, m, opts...)
}

type ValidateStageUpgradeResults struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStageUpgradeResults) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StageUpgradeResults)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StageUpgradeResults got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["applications"]; exists {

		vOpts := append(opts, db.WithValidateField("applications"))
		for idx, item := range m.GetApplications() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStageUpgradeResultsValidator = func() *ValidateStageUpgradeResults {
	v := &ValidateStageUpgradeResults{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StageUpgradeResultsValidator() db.Validator {
	return DefaultStageUpgradeResultsValidator
}

// augmented methods on protoc/std generated struct

func (m *UpgradeProgressCount) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpgradeProgressCount) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpgradeProgressCount) DeepCopy() *UpgradeProgressCount {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpgradeProgressCount{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpgradeProgressCount) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpgradeProgressCount) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpgradeProgressCountValidator().Validate(ctx, m, opts...)
}

type ValidateUpgradeProgressCount struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpgradeProgressCount) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpgradeProgressCount)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpgradeProgressCount got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["completed"]; exists {

		vOpts := append(opts, db.WithValidateField("completed"))
		if err := fv(ctx, m.GetCompleted(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total"]; exists {

		vOpts := append(opts, db.WithValidateField("total"))
		if err := fv(ctx, m.GetTotal(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpgradeProgressCountValidator = func() *ValidateUpgradeProgressCount {
	v := &ValidateUpgradeProgressCount{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpgradeProgressCountValidator() db.Validator {
	return DefaultUpgradeProgressCountValidator
}

// augmented methods on protoc/std generated struct

func (m *Validation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Validation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Validation) DeepCopy() *Validation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Validation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Validation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Validation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidationValidator().Validate(ctx, m, opts...)
}

type ValidateValidation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Validation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Validation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["results"]; exists {

		vOpts := append(opts, db.WithValidateField("results"))
		for idx, item := range m.GetResults() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("start_timestamp"))
		if err := fv(ctx, m.GetStartTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidationValidator = func() *ValidateValidation {
	v := &ValidateValidation{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidationValidator() db.Validator {
	return DefaultValidationValidator
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.SwUpgradeProgress = f.GetSwUpgradeProgress()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.SwUpgradeProgress = m1.SwUpgradeProgress
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.SwUpgradeProgress = f.GetSwUpgradeProgress()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.SwUpgradeProgress = m1.SwUpgradeProgress
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.SwUpgradeProgress = f.GetSwUpgradeProgress()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.SwUpgradeProgress = m1.SwUpgradeProgress
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
