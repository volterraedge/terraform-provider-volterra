// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/waf_suppression_rule/types.proto

package waf_suppression_rule

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	app_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_firewall"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Desired State
//
// x-displayName: "Desired State"
// Desired state represents the state of the detection once it is being considered as false positive.
type DesiredState int32

const (
	// x-displayName: "Disabled"
	DISABLED DesiredState = 0
	// x-displayName: "Auto Suppressed"
	AUTO_SUPPRESSED DesiredState = 1
)

var DesiredState_name = map[int32]string{
	0: "DISABLED",
	1: "AUTO_SUPPRESSED",
}

var DesiredState_value = map[string]int32{
	"DISABLED":        0,
	"AUTO_SUPPRESSED": 1,
}

func (DesiredState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb63cba8d1daa43c, []int{0}
}

// Context Type
//
// x-displayName: "Context Type"
// The origin type of the context, whether it is cookie, parameter or other
type ContextType int32

const (
	// x-displayName: "No_Context"
	NO_CONTEXT ContextType = 0
	// x-displayName: "Request"
	REQUEST ContextType = 1
	// x-displayName: "URL"
	URL ContextType = 2
	// x-displayName: "URI"
	URI ContextType = 3
	// x-displayName: "Parameter"
	PARAMETER ContextType = 4
	// x-displayName: "Header"
	HEADER ContextType = 5
	// x-displayName: "Cookie"
	COOKIE ContextType = 6
	// x-displayName: "Response"
	RESPONSE ContextType = 7
	// x-displayName: "Body"
	BODY ContextType = 8
)

var ContextType_name = map[int32]string{
	0: "NO_CONTEXT",
	1: "REQUEST",
	2: "URL",
	3: "URI",
	4: "PARAMETER",
	5: "HEADER",
	6: "COOKIE",
	7: "RESPONSE",
	8: "BODY",
}

var ContextType_value = map[string]int32{
	"NO_CONTEXT": 0,
	"REQUEST":    1,
	"URL":        2,
	"URI":        3,
	"PARAMETER":  4,
	"HEADER":     5,
	"COOKIE":     6,
	"RESPONSE":   7,
	"BODY":       8,
}

func (ContextType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb63cba8d1daa43c, []int{1}
}

// Context
//
// x-displayName: "Context For Suppression Rule"
// Defines the context in the suppression rule.
// Context will be compared with the detection's state as part of false positive process.
type Context struct {
	// type
	//
	// x-displayName: "Type"
	// x-example: "PARAMETER"
	// x-required
	// Context type configures the type of the context used for suppression rule
	Type ContextType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.waf_suppression_rule.ContextType" json:"type,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "__VIEWSTATE"
	// x-required
	// Context name configures the name of the context used for suppression rule
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Context) Reset()      { *m = Context{} }
func (*Context) ProtoMessage() {}
func (*Context) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb63cba8d1daa43c, []int{0}
}
func (m *Context) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Context) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Context.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Context) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Context.Merge(m, src)
}
func (m *Context) XXX_Size() int {
	return m.Size()
}
func (m *Context) XXX_DiscardUnknown() {
	xxx_messageInfo_Context.DiscardUnknown(m)
}

var xxx_messageInfo_Context proto.InternalMessageInfo

func (m *Context) GetType() ContextType {
	if m != nil {
		return m.Type
	}
	return NO_CONTEXT
}

func (m *Context) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Detections
//
// x-displayName: "Detections For Suppression Rule"
// Configuration of detections such as signatures or violations used for suppression rule
type Detections struct {
	// signatures
	//
	// x-displayName: "Signatures"
	// x-example: "["200020157", "200010243"]"
	// List of signatures' IDs. all signatures that should be considered as false positive as part of the rule's scope.
	Signatures []string `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
	// violations
	//
	// x-displayName: "Violations"
	// x-example: "["VIOL_EVASION_IIS_UNICODE_CODEPOINTS", "VIOL_EVASION_IIS_BACKSLASHES"]"
	// List of violations' IDs. all violations that should be considered as false positive as part of the rule's scope.
	Violations []app_firewall.AppFirewallViolationType `protobuf:"varint,2,rep,packed,name=violations,proto3,enum=ves.io.schema.app_firewall.AppFirewallViolationType" json:"violations,omitempty"`
}

func (m *Detections) Reset()      { *m = Detections{} }
func (*Detections) ProtoMessage() {}
func (*Detections) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb63cba8d1daa43c, []int{1}
}
func (m *Detections) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Detections) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Detections.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Detections) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Detections.Merge(m, src)
}
func (m *Detections) XXX_Size() int {
	return m.Size()
}
func (m *Detections) XXX_DiscardUnknown() {
	xxx_messageInfo_Detections.DiscardUnknown(m)
}

var xxx_messageInfo_Detections proto.InternalMessageInfo

func (m *Detections) GetSignatures() []string {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *Detections) GetViolations() []app_firewall.AppFirewallViolationType {
	if m != nil {
		return m.Violations
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Suppression WAF Rule Specification"
type GlobalSpecType struct {
	// contexts
	//
	// x-displayName: "Contexts"
	// Contexts represents list of contexts that should be considered as false positive.
	// context is combined of type (for example PARAMETER) and name (for example __VIEWSTATE)
	Contexts []*Context `protobuf:"bytes,2,rep,name=contexts,proto3" json:"contexts,omitempty"`
	// detections
	//
	// x-displayName: "Detections"
	// Detections represents all the IDs of any type of detection (lie signatures and violations)
	// which considered as false positive.
	Detections *Detections `protobuf:"bytes,3,opt,name=detections,proto3" json:"detections,omitempty"`
	// desired_state
	//
	// x-displayName: "Desired State"
	// State represents the detection's desired state once all the above attributes are being matched.
	DesiredState DesiredState `protobuf:"varint,4,opt,name=desired_state,json=desiredState,proto3,enum=ves.io.schema.waf_suppression_rule.DesiredState" json:"desired_state,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb63cba8d1daa43c, []int{2}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetContexts() []*Context {
	if m != nil {
		return m.Contexts
	}
	return nil
}

func (m *GlobalSpecType) GetDetections() *Detections {
	if m != nil {
		return m.Detections
	}
	return nil
}

func (m *GlobalSpecType) GetDesiredState() DesiredState {
	if m != nil {
		return m.DesiredState
	}
	return DISABLED
}

// Create WAF Suppression Rule
//
// x-displayName: "Create WAF Suppression Rule"
// CreateSpecType will create all suppression rule in the configuration from namespace metadata.namespace
type CreateSpecType struct {
	Contexts     []*Context   `protobuf:"bytes,1,rep,name=contexts,proto3" json:"contexts,omitempty"`
	Detections   *Detections  `protobuf:"bytes,2,opt,name=detections,proto3" json:"detections,omitempty"`
	DesiredState DesiredState `protobuf:"varint,3,opt,name=desired_state,json=desiredState,proto3,enum=ves.io.schema.waf_suppression_rule.DesiredState" json:"desired_state,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb63cba8d1daa43c, []int{3}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetContexts() []*Context {
	if m != nil {
		return m.Contexts
	}
	return nil
}

func (m *CreateSpecType) GetDetections() *Detections {
	if m != nil {
		return m.Detections
	}
	return nil
}

func (m *CreateSpecType) GetDesiredState() DesiredState {
	if m != nil {
		return m.DesiredState
	}
	return DISABLED
}

// Replace WAF Suppression Rule
//
// x-displayName: "Replace WAF Suppression Rule"
// Update the configuration by replacing the existing spec with the provided one.
type ReplaceSpecType struct {
	Contexts     []*Context   `protobuf:"bytes,1,rep,name=contexts,proto3" json:"contexts,omitempty"`
	Detections   *Detections  `protobuf:"bytes,2,opt,name=detections,proto3" json:"detections,omitempty"`
	DesiredState DesiredState `protobuf:"varint,3,opt,name=desired_state,json=desiredState,proto3,enum=ves.io.schema.waf_suppression_rule.DesiredState" json:"desired_state,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb63cba8d1daa43c, []int{4}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplaceSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetContexts() []*Context {
	if m != nil {
		return m.Contexts
	}
	return nil
}

func (m *ReplaceSpecType) GetDetections() *Detections {
	if m != nil {
		return m.Detections
	}
	return nil
}

func (m *ReplaceSpecType) GetDesiredState() DesiredState {
	if m != nil {
		return m.DesiredState
	}
	return DISABLED
}

// Get Suppression WAF Rule
//
// x-displayName: "Get WAF Suppression Rule"
// GetSpecType will read WAF suppression rule configuration from namespace metadata.namespace
type GetSpecType struct {
	Contexts     []*Context   `protobuf:"bytes,1,rep,name=contexts,proto3" json:"contexts,omitempty"`
	Detections   *Detections  `protobuf:"bytes,2,opt,name=detections,proto3" json:"detections,omitempty"`
	DesiredState DesiredState `protobuf:"varint,3,opt,name=desired_state,json=desiredState,proto3,enum=ves.io.schema.waf_suppression_rule.DesiredState" json:"desired_state,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb63cba8d1daa43c, []int{5}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSpecType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetContexts() []*Context {
	if m != nil {
		return m.Contexts
	}
	return nil
}

func (m *GetSpecType) GetDetections() *Detections {
	if m != nil {
		return m.Detections
	}
	return nil
}

func (m *GetSpecType) GetDesiredState() DesiredState {
	if m != nil {
		return m.DesiredState
	}
	return DISABLED
}

func init() {
	proto.RegisterEnum("ves.io.schema.waf_suppression_rule.DesiredState", DesiredState_name, DesiredState_value)
	proto.RegisterEnum("ves.io.schema.waf_suppression_rule.ContextType", ContextType_name, ContextType_value)
	proto.RegisterType((*Context)(nil), "ves.io.schema.waf_suppression_rule.Context")
	proto.RegisterType((*Detections)(nil), "ves.io.schema.waf_suppression_rule.Detections")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.waf_suppression_rule.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.waf_suppression_rule.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.waf_suppression_rule.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.waf_suppression_rule.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/waf_suppression_rule/types.proto", fileDescriptor_bb63cba8d1daa43c)
}

var fileDescriptor_bb63cba8d1daa43c = []byte{
	// 773 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x95, 0xcf, 0x6f, 0xd3, 0x48,
	0x14, 0xc7, 0x3d, 0x76, 0x9a, 0xa4, 0x93, 0x36, 0xf5, 0x4e, 0xf7, 0xe0, 0xcd, 0xae, 0x2c, 0xcb,
	0x87, 0xdd, 0xa8, 0xbb, 0xb5, 0x77, 0xd3, 0x3d, 0xed, 0x61, 0xa5, 0xfc, 0x30, 0xa5, 0xa2, 0x24,
	0xc1, 0x4e, 0x50, 0xcb, 0x25, 0x72, 0x92, 0x49, 0x6a, 0xe1, 0x64, 0x2c, 0xdb, 0x49, 0xdb, 0x03,
	0x52, 0xc4, 0x01, 0xc1, 0x01, 0xa8, 0x02, 0x7f, 0x04, 0x17, 0xfe, 0x01, 0x4e, 0x9c, 0x10, 0xe2,
	0xd4, 0x63, 0x8f, 0xd4, 0x95, 0x10, 0xdc, 0xfa, 0x27, 0x20, 0x3b, 0x4d, 0xea, 0x54, 0x14, 0x5a,
	0xa9, 0xc7, 0xde, 0xde, 0xcb, 0x7b, 0xdf, 0xef, 0x7b, 0xf3, 0x19, 0x2b, 0x03, 0xa5, 0x3e, 0x76,
	0x24, 0x83, 0xc8, 0x4e, 0x63, 0x0b, 0x77, 0x74, 0x79, 0x5b, 0x6f, 0xd5, 0x9c, 0x9e, 0x65, 0xd9,
	0xd8, 0x71, 0x0c, 0xd2, 0xad, 0xd9, 0x3d, 0x13, 0xcb, 0xee, 0xae, 0x85, 0x1d, 0xc9, 0xb2, 0x89,
	0x4b, 0x90, 0x38, 0xea, 0x97, 0x46, 0xfd, 0xd2, 0xb7, 0xfa, 0x53, 0xcb, 0x6d, 0xc3, 0xdd, 0xea,
	0xd5, 0xa5, 0x06, 0xe9, 0xc8, 0x6d, 0xd2, 0x26, 0x72, 0x20, 0xad, 0xf7, 0x5a, 0x41, 0x16, 0x24,
	0x41, 0x34, 0xb2, 0x4c, 0xfd, 0x3e, 0xbd, 0x82, 0x6e, 0x59, 0xb5, 0x96, 0x61, 0xe3, 0x6d, 0xdd,
	0x34, 0xc3, 0xa3, 0x53, 0xbf, 0x4e, 0xf7, 0x11, 0xcb, 0x35, 0x48, 0x77, 0x5c, 0xfc, 0x65, 0xba,
	0x18, 0xd6, 0xfd, 0x36, 0x5d, 0xea, 0xeb, 0xa6, 0xd1, 0xd4, 0x5d, 0x7c, 0x52, 0x15, 0xce, 0x54,
	0x0d, 0xbc, 0x5d, 0x9b, 0xb2, 0x16, 0x77, 0x60, 0x2c, 0x4f, 0xba, 0x2e, 0xde, 0x71, 0xd1, 0x26,
	0x8c, 0xf8, 0xce, 0x1c, 0x10, 0x40, 0x3a, 0x99, 0x91, 0xa5, 0x1f, 0xc3, 0x90, 0x4e, 0xa4, 0x95,
	0x5d, 0x0b, 0xe7, 0x7e, 0x7e, 0xf3, 0xe5, 0x2d, 0x33, 0xf3, 0x10, 0xd0, 0x2c, 0x18, 0x47, 0x02,
	0xa5, 0x06, 0x96, 0x08, 0xc1, 0x48, 0x57, 0xef, 0x60, 0x8e, 0x16, 0x40, 0x7a, 0x56, 0x0d, 0x62,
	0xf1, 0x13, 0x80, 0xb0, 0x80, 0x5d, 0xdc, 0x08, 0xd6, 0x41, 0xeb, 0x10, 0x3a, 0x46, 0xbb, 0xab,
	0xbb, 0x3d, 0x1b, 0x3b, 0x1c, 0x10, 0x98, 0xf4, 0x6c, 0xee, 0x2f, 0xdf, 0x08, 0x0d, 0xc1, 0x82,
	0x38, 0xbf, 0x94, 0xe0, 0x06, 0xef, 0x1e, 0x3d, 0x07, 0xe9, 0xc1, 0x6b, 0x2f, 0xe2, 0xff, 0x1c,
	0x1d, 0x02, 0x86, 0x7d, 0xfc, 0x47, 0x30, 0x6a, 0x08, 0x68, 0x0e, 0xa8, 0x21, 0x3d, 0x7a, 0x02,
	0x20, 0xec, 0x1b, 0xc4, 0xd4, 0x03, 0x73, 0x8e, 0x16, 0x98, 0x74, 0x32, 0xf3, 0xef, 0x99, 0x23,
	0x85, 0x2f, 0x43, 0xca, 0x5a, 0xd6, 0x8d, 0x93, 0xf8, 0xee, 0x58, 0x18, 0x9c, 0x6b, 0xc5, 0x1f,
	0x01, 0x87, 0x20, 0x26, 0x9e, 0x1e, 0x6e, 0x92, 0x0a, 0xd4, 0x39, 0xbb, 0x9c, 0x0e, 0x17, 0x9f,
	0xd2, 0x30, 0xb9, 0x6a, 0x92, 0xba, 0x6e, 0x6a, 0x16, 0x6e, 0xf8, 0x9e, 0xa8, 0x02, 0xe3, 0x8d,
	0x11, 0xba, 0xd1, 0x6e, 0x89, 0xcc, 0x9f, 0x97, 0xc0, 0x9d, 0x4b, 0x84, 0x86, 0xaa, 0x13, 0x27,
	0x54, 0x84, 0xb0, 0x39, 0x01, 0xca, 0x31, 0x02, 0x48, 0x27, 0x32, 0xd2, 0x45, 0x7c, 0x4f, 0xaf,
	0x41, 0x0d, 0x39, 0xa0, 0x2a, 0x9c, 0x6f, 0x62, 0xc7, 0xb0, 0x71, 0xb3, 0xe6, 0xb8, 0xba, 0x8b,
	0xb9, 0x48, 0xf0, 0x65, 0xfc, 0x7d, 0x31, 0xcb, 0x40, 0xa8, 0xf9, 0x3a, 0x75, 0xae, 0x19, 0xca,
	0xc4, 0x17, 0x34, 0x4c, 0xe6, 0x6d, 0xac, 0xbb, 0x78, 0xc2, 0x63, 0x35, 0xc4, 0x03, 0x5c, 0x9a,
	0xc7, 0xb9, 0x08, 0xe8, 0xab, 0x47, 0xc0, 0x5c, 0x05, 0x82, 0xff, 0x7e, 0xfa, 0xf0, 0xff, 0x99,
	0x4f, 0x42, 0x7c, 0x49, 0xc3, 0x05, 0x15, 0x5b, 0xa6, 0xde, 0xb8, 0xc6, 0x12, 0xc2, 0xb2, 0x47,
	0xc3, 0xc4, 0x2a, 0x76, 0xaf, 0x91, 0x4c, 0x90, 0x2c, 0xfd, 0x03, 0xe7, 0xc2, 0x02, 0x34, 0x07,
	0xe3, 0x85, 0x35, 0x2d, 0x9b, 0x5b, 0x57, 0x0a, 0x2c, 0x85, 0x16, 0xe1, 0x42, 0xb6, 0x5a, 0x29,
	0xd5, 0xb4, 0x6a, 0xb9, 0xac, 0x2a, 0x9a, 0xa6, 0x14, 0x58, 0xb0, 0x34, 0x00, 0x30, 0x11, 0xfa,
	0xaf, 0x46, 0x8b, 0x10, 0x16, 0x4b, 0xb5, 0x7c, 0xa9, 0x58, 0x51, 0x36, 0x2a, 0x2c, 0x95, 0x62,
	0x06, 0x0f, 0x00, 0x4a, 0xc0, 0x98, 0xaa, 0xdc, 0xa9, 0x2a, 0x5a, 0x85, 0x05, 0x28, 0x06, 0x99,
	0xaa, 0xba, 0xce, 0xd2, 0xa3, 0x60, 0x8d, 0x65, 0xd0, 0x3c, 0x9c, 0x2d, 0x67, 0xd5, 0xec, 0x6d,
	0xa5, 0xa2, 0xa8, 0x6c, 0x04, 0x41, 0x18, 0xbd, 0xa9, 0x64, 0x0b, 0x8a, 0xca, 0xce, 0xf8, 0x71,
	0xbe, 0x54, 0xba, 0xb5, 0xa6, 0xb0, 0x51, 0x7f, 0x1b, 0x55, 0xd1, 0xca, 0xa5, 0xa2, 0xa6, 0xb0,
	0x31, 0x14, 0x87, 0x91, 0x5c, 0xa9, 0xb0, 0xc9, 0xc6, 0x73, 0xcf, 0xc0, 0xfe, 0x21, 0x4f, 0x1d,
	0x1c, 0xf2, 0xd4, 0xf1, 0x21, 0x0f, 0x06, 0x1e, 0x0f, 0x5e, 0x79, 0x3c, 0x78, 0xef, 0xf1, 0x60,
	0xdf, 0xe3, 0xc1, 0x47, 0x8f, 0x07, 0x9f, 0x3d, 0x9e, 0x3a, 0xf6, 0x78, 0xb0, 0x77, 0xc4, 0x53,
	0xfb, 0x47, 0x3c, 0x75, 0x70, 0xc4, 0x53, 0xf7, 0x36, 0xda, 0xc4, 0xba, 0xdf, 0x96, 0xfa, 0xc4,
	0x74, 0xb1, 0x6d, 0xeb, 0x52, 0xcf, 0x91, 0x83, 0xa0, 0x45, 0xec, 0xce, 0xb2, 0x65, 0x93, 0xbe,
	0xd1, 0xc4, 0xf6, 0xf2, 0xb8, 0x2c, 0x5b, 0xf5, 0x36, 0x91, 0xfd, 0xfb, 0x1d, 0x3d, 0x78, 0xdf,
	0x79, 0xf8, 0xeb, 0xd1, 0xe0, 0x01, 0x5c, 0xf9, 0x1a, 0x00, 0x00, 0xff, 0xff, 0x62, 0x3b, 0xe2,
	0x95, 0x25, 0x08, 0x00, 0x00,
}

func (x DesiredState) String() string {
	s, ok := DesiredState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ContextType) String() string {
	s, ok := ContextType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Context) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Context)
	if !ok {
		that2, ok := that.(Context)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Detections) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Detections)
	if !ok {
		that2, ok := that.(Detections)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if this.Signatures[i] != that1.Signatures[i] {
			return false
		}
	}
	if len(this.Violations) != len(that1.Violations) {
		return false
	}
	for i := range this.Violations {
		if this.Violations[i] != that1.Violations[i] {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Contexts) != len(that1.Contexts) {
		return false
	}
	for i := range this.Contexts {
		if !this.Contexts[i].Equal(that1.Contexts[i]) {
			return false
		}
	}
	if !this.Detections.Equal(that1.Detections) {
		return false
	}
	if this.DesiredState != that1.DesiredState {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Contexts) != len(that1.Contexts) {
		return false
	}
	for i := range this.Contexts {
		if !this.Contexts[i].Equal(that1.Contexts[i]) {
			return false
		}
	}
	if !this.Detections.Equal(that1.Detections) {
		return false
	}
	if this.DesiredState != that1.DesiredState {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Contexts) != len(that1.Contexts) {
		return false
	}
	for i := range this.Contexts {
		if !this.Contexts[i].Equal(that1.Contexts[i]) {
			return false
		}
	}
	if !this.Detections.Equal(that1.Detections) {
		return false
	}
	if this.DesiredState != that1.DesiredState {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Contexts) != len(that1.Contexts) {
		return false
	}
	for i := range this.Contexts {
		if !this.Contexts[i].Equal(that1.Contexts[i]) {
			return false
		}
	}
	if !this.Detections.Equal(that1.Detections) {
		return false
	}
	if this.DesiredState != that1.DesiredState {
		return false
	}
	return true
}
func (this *Context) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&waf_suppression_rule.Context{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Detections) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&waf_suppression_rule.Detections{")
	s = append(s, "Signatures: "+fmt.Sprintf("%#v", this.Signatures)+",\n")
	s = append(s, "Violations: "+fmt.Sprintf("%#v", this.Violations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf_suppression_rule.GlobalSpecType{")
	if this.Contexts != nil {
		s = append(s, "Contexts: "+fmt.Sprintf("%#v", this.Contexts)+",\n")
	}
	if this.Detections != nil {
		s = append(s, "Detections: "+fmt.Sprintf("%#v", this.Detections)+",\n")
	}
	s = append(s, "DesiredState: "+fmt.Sprintf("%#v", this.DesiredState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf_suppression_rule.CreateSpecType{")
	if this.Contexts != nil {
		s = append(s, "Contexts: "+fmt.Sprintf("%#v", this.Contexts)+",\n")
	}
	if this.Detections != nil {
		s = append(s, "Detections: "+fmt.Sprintf("%#v", this.Detections)+",\n")
	}
	s = append(s, "DesiredState: "+fmt.Sprintf("%#v", this.DesiredState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf_suppression_rule.ReplaceSpecType{")
	if this.Contexts != nil {
		s = append(s, "Contexts: "+fmt.Sprintf("%#v", this.Contexts)+",\n")
	}
	if this.Detections != nil {
		s = append(s, "Detections: "+fmt.Sprintf("%#v", this.Detections)+",\n")
	}
	s = append(s, "DesiredState: "+fmt.Sprintf("%#v", this.DesiredState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf_suppression_rule.GetSpecType{")
	if this.Contexts != nil {
		s = append(s, "Contexts: "+fmt.Sprintf("%#v", this.Contexts)+",\n")
	}
	if this.Detections != nil {
		s = append(s, "Detections: "+fmt.Sprintf("%#v", this.Detections)+",\n")
	}
	s = append(s, "DesiredState: "+fmt.Sprintf("%#v", this.DesiredState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Context) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Context) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Context) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Detections) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Detections) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Detections) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Violations) > 0 {
		dAtA2 := make([]byte, len(m.Violations)*10)
		var j1 int
		for _, num := range m.Violations {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signatures[iNdEx])
			copy(dAtA[i:], m.Signatures[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Signatures[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DesiredState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredState))
		i--
		dAtA[i] = 0x20
	}
	if m.Detections != nil {
		{
			size, err := m.Detections.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Contexts) > 0 {
		for iNdEx := len(m.Contexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DesiredState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredState))
		i--
		dAtA[i] = 0x18
	}
	if m.Detections != nil {
		{
			size, err := m.Detections.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Contexts) > 0 {
		for iNdEx := len(m.Contexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DesiredState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredState))
		i--
		dAtA[i] = 0x18
	}
	if m.Detections != nil {
		{
			size, err := m.Detections.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Contexts) > 0 {
		for iNdEx := len(m.Contexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DesiredState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredState))
		i--
		dAtA[i] = 0x18
	}
	if m.Detections != nil {
		{
			size, err := m.Detections.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Contexts) > 0 {
		for iNdEx := len(m.Contexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Context) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Detections) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, s := range m.Signatures {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Violations) > 0 {
		l = 0
		for _, e := range m.Violations {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Contexts) > 0 {
		for _, e := range m.Contexts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Detections != nil {
		l = m.Detections.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DesiredState != 0 {
		n += 1 + sovTypes(uint64(m.DesiredState))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Contexts) > 0 {
		for _, e := range m.Contexts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Detections != nil {
		l = m.Detections.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DesiredState != 0 {
		n += 1 + sovTypes(uint64(m.DesiredState))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Contexts) > 0 {
		for _, e := range m.Contexts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Detections != nil {
		l = m.Detections.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DesiredState != 0 {
		n += 1 + sovTypes(uint64(m.DesiredState))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Contexts) > 0 {
		for _, e := range m.Contexts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Detections != nil {
		l = m.Detections.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DesiredState != 0 {
		n += 1 + sovTypes(uint64(m.DesiredState))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Context) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Context{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Detections) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Detections{`,
		`Signatures:` + fmt.Sprintf("%v", this.Signatures) + `,`,
		`Violations:` + fmt.Sprintf("%v", this.Violations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContexts := "[]*Context{"
	for _, f := range this.Contexts {
		repeatedStringForContexts += strings.Replace(f.String(), "Context", "Context", 1) + ","
	}
	repeatedStringForContexts += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Contexts:` + repeatedStringForContexts + `,`,
		`Detections:` + strings.Replace(this.Detections.String(), "Detections", "Detections", 1) + `,`,
		`DesiredState:` + fmt.Sprintf("%v", this.DesiredState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContexts := "[]*Context{"
	for _, f := range this.Contexts {
		repeatedStringForContexts += strings.Replace(f.String(), "Context", "Context", 1) + ","
	}
	repeatedStringForContexts += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`Contexts:` + repeatedStringForContexts + `,`,
		`Detections:` + strings.Replace(this.Detections.String(), "Detections", "Detections", 1) + `,`,
		`DesiredState:` + fmt.Sprintf("%v", this.DesiredState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContexts := "[]*Context{"
	for _, f := range this.Contexts {
		repeatedStringForContexts += strings.Replace(f.String(), "Context", "Context", 1) + ","
	}
	repeatedStringForContexts += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Contexts:` + repeatedStringForContexts + `,`,
		`Detections:` + strings.Replace(this.Detections.String(), "Detections", "Detections", 1) + `,`,
		`DesiredState:` + fmt.Sprintf("%v", this.DesiredState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContexts := "[]*Context{"
	for _, f := range this.Contexts {
		repeatedStringForContexts += strings.Replace(f.String(), "Context", "Context", 1) + ","
	}
	repeatedStringForContexts += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Contexts:` + repeatedStringForContexts + `,`,
		`Detections:` + strings.Replace(this.Detections.String(), "Detections", "Detections", 1) + `,`,
		`DesiredState:` + fmt.Sprintf("%v", this.DesiredState) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Context) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Context: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Context: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ContextType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Detections) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Detections: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Detections: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v app_firewall.AppFirewallViolationType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= app_firewall.AppFirewallViolationType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Violations = append(m.Violations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Violations) == 0 {
					m.Violations = make([]app_firewall.AppFirewallViolationType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v app_firewall.AppFirewallViolationType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= app_firewall.AppFirewallViolationType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Violations = append(m.Violations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Violations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contexts = append(m.Contexts, &Context{})
			if err := m.Contexts[len(m.Contexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detections == nil {
				m.Detections = &Detections{}
			}
			if err := m.Detections.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredState", wireType)
			}
			m.DesiredState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredState |= DesiredState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contexts = append(m.Contexts, &Context{})
			if err := m.Contexts[len(m.Contexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detections == nil {
				m.Detections = &Detections{}
			}
			if err := m.Detections.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredState", wireType)
			}
			m.DesiredState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredState |= DesiredState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contexts = append(m.Contexts, &Context{})
			if err := m.Contexts[len(m.Contexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detections == nil {
				m.Detections = &Detections{}
			}
			if err := m.Detections.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredState", wireType)
			}
			m.DesiredState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredState |= DesiredState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contexts = append(m.Contexts, &Context{})
			if err := m.Contexts[len(m.Contexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detections == nil {
				m.Detections = &Detections{}
			}
			if err := m.Detections.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredState", wireType)
			}
			m.DesiredState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredState |= DesiredState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
