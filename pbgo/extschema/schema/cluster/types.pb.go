// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/cluster/types.proto

package cluster

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// LoadbalancerAlgorithm
//
// x-displayName: "Load Balancer Algorithm"
// Different load balancing algorithms supported
// When a connection to a endpoint in an upstream cluster is required, the load balancer uses loadbalancer_algorithm
// to determine which host is selected.
type LoadbalancerAlgorithm int32

const (
	// ROUND_ROBIN
	//
	// x-displayName: "Round Robin"
	// Policy in which each healthy/available upstream endpoint is selected in round robin order.
	ROUND_ROBIN LoadbalancerAlgorithm = 0
	// LEAST_REQUEST
	//
	// x-displayName: "Least Request"
	// Policy in which loadbalancer picks the upstream endpoint which has the fewest active requests
	LEAST_REQUEST LoadbalancerAlgorithm = 1
	// RING_HASH
	//
	// x-displayName: "Ring Hash"
	// Policy implements consistent hashing to upstream endpoints using ring hash of endpoint names
	// Hash of the incoming request is calculated using request hash policy.
	// The ring/modulo hash load balancer implements consistent hashing to upstream hosts.
	// The algorithm is based on mapping all hosts onto a circle such that the addition or
	// removal of a host from the host set changes only affect 1/N requests. This technique
	// is also commonly known as “ketama” hashing. A consistent hashing load balancer is only
	// effective when protocol routing is used that specifies a value to hash on. The minimum
	// ring size governs the replication factor for each host in the ring. For example, if the
	// minimum ring size is 1024 and there are 16 hosts, each host will be replicated 64 times.
	RING_HASH LoadbalancerAlgorithm = 2
	// RANDOM
	//
	// x-displayName: "Random"
	// policy in which each available upstream endpoint is selected in random order.
	// The random load balancer selects a random healthy host. The random load balancer generally
	// performs better than round robin if no health checking policy is configured. Random selection
	// avoids bias towards the host in the set that comes after a failed host.
	RANDOM LoadbalancerAlgorithm = 3
	// Load Balancer Override
	//
	// x-displayName: "Load Balancer Override"
	// Hash policy is taken from from the load balancer which is using this origin pool
	LB_OVERRIDE LoadbalancerAlgorithm = 4
)

var LoadbalancerAlgorithm_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_REQUEST",
	2: "RING_HASH",
	3: "RANDOM",
	4: "LB_OVERRIDE",
}

var LoadbalancerAlgorithm_value = map[string]int32{
	"ROUND_ROBIN":   0,
	"LEAST_REQUEST": 1,
	"RING_HASH":     2,
	"RANDOM":        3,
	"LB_OVERRIDE":   4,
}

func (LoadbalancerAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{0}
}

// DnsDiscoveryType
//
// x-displayName: "DNS Discovery Type"
// Specifies whether to use the first address or all addresses returned by DNS resolver
type DnsDiscoveryType int32

const (
	// x-displayName: "Strict DNS"
	// Each returned IP address in the DNS result will be considered an explicit host in the upstream cluster
	STRICT_DNS DnsDiscoveryType = 0
	// x-displayName: "Logical DNS"
	// Uses only the first IP address returned when a new connection needs to be initiated
	LOGICAL_DNS DnsDiscoveryType = 1
)

var DnsDiscoveryType_name = map[int32]string{
	0: "STRICT_DNS",
	1: "LOGICAL_DNS",
}

var DnsDiscoveryType_value = map[string]int32{
	"STRICT_DNS":  0,
	"LOGICAL_DNS": 1,
}

func (DnsDiscoveryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{1}
}

// DnsLookupType
//
// x-displayName: "DNS Lookup Type"
// Address family in which DNS resolver should lookup for addresses
type DnsLookupType int32

const (
	// x-displayName: "Automatic IPV4/V6 DNS"
	// DNS resolver will first perform a lookup for addresses in the IPv6 family
	// and fallback to lookup for addresses in the IPv4 family
	AUTO DnsLookupType = 0
	// x-displayName: "IPV4 Only"
	// DNS resolver will only perform a lookup for addresses in IPv4 family
	V4_ONLY DnsLookupType = 1
	// x-displayName: "IPV6 Only"
	// DNS resolver will only perform a lookup for addresses in IPv6 family
	V6_ONLY DnsLookupType = 2
)

var DnsLookupType_name = map[int32]string{
	0: "AUTO",
	1: "V4_ONLY",
	2: "V6_ONLY",
}

var DnsLookupType_value = map[string]int32{
	"AUTO":    0,
	"V4_ONLY": 1,
	"V6_ONLY": 2,
}

func (DnsLookupType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{2}
}

// SubsetFallbackPolicy
//
// x-displayName: "Subset Fallback Policy"
// Enumeration for SubsetFallbackPolicy if subset match is not found.
type SubsetFallbackPolicy int32

const (
	// x-displayName: "No Fallback"
	// The request fails as if the cluster had no endpoint matching the subset policy
	NO_FALLBACK SubsetFallbackPolicy = 0
	// x-displayName: "Any Endpoint"
	// Any cluster endpoint may be selected if the cluster had no endpoint matching the subset policy
	ANY_ENDPOINT SubsetFallbackPolicy = 1
	// x-displayName: "Default Subset"
	// Load balancing is done over endpoints matching default_subset if the cluster had no
	// endpoint matching the subset policy
	DEFAULT_SUBSET SubsetFallbackPolicy = 2
)

var SubsetFallbackPolicy_name = map[int32]string{
	0: "NO_FALLBACK",
	1: "ANY_ENDPOINT",
	2: "DEFAULT_SUBSET",
}

var SubsetFallbackPolicy_value = map[string]int32{
	"NO_FALLBACK":    0,
	"ANY_ENDPOINT":   1,
	"DEFAULT_SUBSET": 2,
}

func (SubsetFallbackPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{3}
}

// EndpointSelectionPolicy
//
// x-displayName: "Endpoint Selection Policy"
// Policy for selection of endpoints from local site/remote site/both
type EndpointSelectionPolicy int32

const (
	// x-displayName: "All Endpoints"
	// Consider both remote and local endpoints for load balancing
	DISTRIBUTED EndpointSelectionPolicy = 0
	// x-displayName: "Local Endpoints Only"
	// LOCAL_ONLY: Consider only local endpoints for load balancing
	// Enable this policy to load balance ONLY among locally discovered endpoints
	LOCAL_ONLY EndpointSelectionPolicy = 1
	// x-displayName: "Local Endpoints Preferred"
	// Prefer the local endpoints for load balancing. If local endpoints are not present
	// remote endpoints will be considered.
	LOCAL_PREFERRED EndpointSelectionPolicy = 2
)

var EndpointSelectionPolicy_name = map[int32]string{
	0: "DISTRIBUTED",
	1: "LOCAL_ONLY",
	2: "LOCAL_PREFERRED",
}

var EndpointSelectionPolicy_value = map[string]int32{
	"DISTRIBUTED":     0,
	"LOCAL_ONLY":      1,
	"LOCAL_PREFERRED": 2,
}

func (EndpointSelectionPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{4}
}

// OutlierDetectionType
//
// x-displayName: "Outlier Detection"
// Outlier detection and ejection is the process of dynamically determining whether some number
// of hosts in an upstream cluster are performing unlike the others and removing them from the
// healthy load balancing set. Outlier detection is a form of passive health checking.
//
// Algorithm
//
// 1. A endpoint is determined to be an outlier (based on configured number of consecutive_5xx
//    or consecutive_gateway_failures) .
// 2. If no endpoints have been ejected, loadbalancer will eject the host immediately.
//    Otherwise, it checks to make sure the number of ejected hosts is below the allowed threshold
//    (specified via max_ejection_percent setting). If the number of ejected hosts is above the
//    threshold, the host is not ejected.
// 3. The endpoint is ejected for some number of milliseconds. Ejection means that the endpoint is marked
//    unhealthy and will not be used during load balancing. The number of milliseconds is equal to the
//    base_ejection_time value multiplied by the number of times the host has been ejected.
// 4. An ejected endpoint will automatically be brought back into service after the ejection time
//    has been satisfied
//
type OutlierDetectionType struct {
	// consecutive_5xx
	//
	// x-displayName: "Consecutive 5xx Count"
	// x-example: "3"
	// If an upstream endpoint returns some number of consecutive 5xx, it will be ejected.
	// Note that in this case a 5xx means an actual 5xx respond code, or an event that would
	// cause the HTTP router to return one on the upstream’s behalf(reset, connection failure, etc.)
	// consecutive_5xx indicates the number of consecutive 5xx responses required before
	// a consecutive 5xx ejection occurs. Defaults to 5.
	Consecutive_5Xx uint32 `protobuf:"varint,1,opt,name=consecutive_5xx,json=consecutive5xx,proto3" json:"consecutive_5xx,omitempty"`
	// interval
	//
	// x-displayName: "Interval"
	// x-example: "5000"
	// The time interval between ejection analysis sweeps. This can result in
	// both new ejections as well as endpoints being returned to service. Defaults
	// to 10000ms or 10s. Specified in milliseconds.
	Interval uint32 `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	// base_ejection_time
	//
	// x-displayName: "Base Ejection Time"
	// x-example: "20000"
	// The base time that a host is ejected for. The real time is equal to the
	// base time multiplied by the number of times the host has been ejected.
	// This causes hosts to get ejected for longer periods if they continue to fail.
	// Defaults to 30000ms or 30s. Specified in milliseconds.
	BaseEjectionTime uint32 `protobuf:"varint,3,opt,name=base_ejection_time,json=baseEjectionTime,proto3" json:"base_ejection_time,omitempty"`
	// max_ejection_percent
	//
	// x-displayName: "Max Ejection Percentage"
	// x-example: "20"
	// The maximum % of an upstream cluster that can be ejected due to outlier
	// detection. Defaults to 10% but will eject at least one host regardless of the value.
	MaxEjectionPercent uint32 `protobuf:"varint,4,opt,name=max_ejection_percent,json=maxEjectionPercent,proto3" json:"max_ejection_percent,omitempty"`
	// consecutive_gateway_failure
	//
	// x-displayName: "Consecutive Gateway Failure"
	// x-example: "5"
	// If an upstream endpoint returns some number of consecutive “gateway errors”
	// (502, 503 or 504 status code), it will be ejected. Note that this includes events
	// that would cause the HTTP router to return one of these status codes on the
	// upstream’s behalf (reset, connection failure, etc.).
	// consecutive_gateway_failure indicates the number of consecutive gateway failures
	// before a consecutive gateway failure ejection occurs. Defaults to 5.
	ConsecutiveGatewayFailure uint32 `protobuf:"varint,5,opt,name=consecutive_gateway_failure,json=consecutiveGatewayFailure,proto3" json:"consecutive_gateway_failure,omitempty"`
}

func (m *OutlierDetectionType) Reset()      { *m = OutlierDetectionType{} }
func (*OutlierDetectionType) ProtoMessage() {}
func (*OutlierDetectionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{0}
}
func (m *OutlierDetectionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutlierDetectionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OutlierDetectionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutlierDetectionType.Merge(m, src)
}
func (m *OutlierDetectionType) XXX_Size() int {
	return m.Size()
}
func (m *OutlierDetectionType) XXX_DiscardUnknown() {
	xxx_messageInfo_OutlierDetectionType.DiscardUnknown(m)
}

var xxx_messageInfo_OutlierDetectionType proto.InternalMessageInfo

func (m *OutlierDetectionType) GetConsecutive_5Xx() uint32 {
	if m != nil {
		return m.Consecutive_5Xx
	}
	return 0
}

func (m *OutlierDetectionType) GetInterval() uint32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *OutlierDetectionType) GetBaseEjectionTime() uint32 {
	if m != nil {
		return m.BaseEjectionTime
	}
	return 0
}

func (m *OutlierDetectionType) GetMaxEjectionPercent() uint32 {
	if m != nil {
		return m.MaxEjectionPercent
	}
	return 0
}

func (m *OutlierDetectionType) GetConsecutiveGatewayFailure() uint32 {
	if m != nil {
		return m.ConsecutiveGatewayFailure
	}
	return 0
}

// EndpointSubsetSelectorType
//
// x-displayName: "Endpoint Subset Selector"
// Upstream cluster may be configured to divide its endpoints into subsets based on metadata
// attached to the endpoints. Routes may then specify the metadata that a endpoint must match in
// order to be selected by the load balancer.
// List of keys that define a cluster subset. Each endpoint that has a metadata value for all of
// the keys in the definition is added to that subset. If no endpoint has all the keys, no subsets
// result from the definition. A single endpoint may appear in multiple subsets if it matches
// multiple definitions.
type EndpointSubsetSelectorType struct {
	// keys
	//
	// x-displayName: "Keys"
	// x-example: "production"
	// List of keys that define a cluster subset class.
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *EndpointSubsetSelectorType) Reset()      { *m = EndpointSubsetSelectorType{} }
func (*EndpointSubsetSelectorType) ProtoMessage() {}
func (*EndpointSubsetSelectorType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{1}
}
func (m *EndpointSubsetSelectorType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndpointSubsetSelectorType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EndpointSubsetSelectorType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndpointSubsetSelectorType.Merge(m, src)
}
func (m *EndpointSubsetSelectorType) XXX_Size() int {
	return m.Size()
}
func (m *EndpointSubsetSelectorType) XXX_DiscardUnknown() {
	xxx_messageInfo_EndpointSubsetSelectorType.DiscardUnknown(m)
}

var xxx_messageInfo_EndpointSubsetSelectorType proto.InternalMessageInfo

func (m *EndpointSubsetSelectorType) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// CircuitBreaker
//
// x-displayName: "Circuit Breaker"
// CircuitBreaker provides a mechanism for watching failures in upstream connections or requests
// and if the failures reach a certain threshold, automatically fail subsequent requests which
// allows to apply back pressure on downstream quickly.
type CircuitBreaker struct {
	// priority
	//
	// x-displayName: "Priority"
	// Priority for the CircuitBreaker which can be either DEFAULT or HIGH. This implies that
	// we can have maximum of two CircuitBreakers per cluster. The priority of the route is
	// matched with priority of CircuitBreaker to select the CircuitBreaker
	Priority schema.RoutingPriority `protobuf:"varint,1,opt,name=priority,proto3,enum=ves.io.schema.RoutingPriority" json:"priority,omitempty"`
	// connection_limit
	//
	// x-displayName: "Connection Limit"
	// x-example: "100"
	// The maximum number of connections that loadbalancer will establish to all hosts in an upstream cluster.
	// In practice this is only applicable to TCP and HTTP/1.1 clusters since HTTP/2 uses a single connection to each host.
	// Remove endpoint out of load balancing decision, if number of connections reach connection limit.
	ConnectionLimit uint32 `protobuf:"varint,2,opt,name=connection_limit,json=connectionLimit,proto3" json:"connection_limit,omitempty"`
	// pending_requests
	//
	// x-displayName: "Pending Requests"
	// x-example: "20"
	// The maximum number of requests that will be queued while waiting for a ready connection pool connection.
	// Since HTTP/2 requests are sent over a single connection, this circuit breaker only comes into play as the
	// initial connection is created, as requests will be multiplexed immediately afterwards. For HTTP/1.1, requests
	// are added to the list of pending requests whenever there aren’t enough upstream connections available to
	// immediately dispatch the request, so this circuit breaker will remain in play for the lifetime of the process.
	// Remove endpoint out of load balancing decision, if pending request reach  pending_request.
	PendingRequests uint32 `protobuf:"varint,3,opt,name=pending_requests,json=pendingRequests,proto3" json:"pending_requests,omitempty"`
	// retries
	//
	// x-displayName: "Retry Count"
	// x-example: "10"
	// The maximum number of retries that can be outstanding to all hosts in a cluster at any given time.
	// Remove endpoint out of load balancing decision, if retries for request exceed this count.
	Retries uint32 `protobuf:"varint,4,opt,name=retries,proto3" json:"retries,omitempty"`
	// max_requests
	//
	// x-displayName: "Maximum Request Count"
	// x-example: "10"
	// The maximum number of requests that can be outstanding to all hosts in a cluster at any given time.
	// In practice this is applicable to HTTP/2 clusters since HTTP/1.1 clusters are governed by the
	// maximum connections (connection_limit).
	// Remove endpoint out of load balancing decision, if requests exceed this count.
	MaxRequests uint32 `protobuf:"varint,5,opt,name=max_requests,json=maxRequests,proto3" json:"max_requests,omitempty"`
}

func (m *CircuitBreaker) Reset()      { *m = CircuitBreaker{} }
func (*CircuitBreaker) ProtoMessage() {}
func (*CircuitBreaker) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{2}
}
func (m *CircuitBreaker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CircuitBreaker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CircuitBreaker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CircuitBreaker.Merge(m, src)
}
func (m *CircuitBreaker) XXX_Size() int {
	return m.Size()
}
func (m *CircuitBreaker) XXX_DiscardUnknown() {
	xxx_messageInfo_CircuitBreaker.DiscardUnknown(m)
}

var xxx_messageInfo_CircuitBreaker proto.InternalMessageInfo

func (m *CircuitBreaker) GetPriority() schema.RoutingPriority {
	if m != nil {
		return m.Priority
	}
	return schema.DEFAULT
}

func (m *CircuitBreaker) GetConnectionLimit() uint32 {
	if m != nil {
		return m.ConnectionLimit
	}
	return 0
}

func (m *CircuitBreaker) GetPendingRequests() uint32 {
	if m != nil {
		return m.PendingRequests
	}
	return 0
}

func (m *CircuitBreaker) GetRetries() uint32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

func (m *CircuitBreaker) GetMaxRequests() uint32 {
	if m != nil {
		return m.MaxRequests
	}
	return 0
}

// Http2ProtocolOptions
//
// x-displayName: "Http2 Protocol Options"
// Http2 Protocol options for upstream connections
type Http2ProtocolOptions struct {
	// enabled
	//
	// x-displayName: "HTTP2 Enabled"
	// Enable/disable Http2 Protocol for upstream connections. It is disabled by default.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *Http2ProtocolOptions) Reset()      { *m = Http2ProtocolOptions{} }
func (*Http2ProtocolOptions) ProtoMessage() {}
func (*Http2ProtocolOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{3}
}
func (m *Http2ProtocolOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Http2ProtocolOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Http2ProtocolOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Http2ProtocolOptions.Merge(m, src)
}
func (m *Http2ProtocolOptions) XXX_Size() int {
	return m.Size()
}
func (m *Http2ProtocolOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_Http2ProtocolOptions.DiscardUnknown(m)
}

var xxx_messageInfo_Http2ProtocolOptions proto.InternalMessageInfo

func (m *Http2ProtocolOptions) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for Cluster
type GlobalSpecType struct {
	// endpoints
	//
	// x-displayName: "Endpoints"
	// List of references to all endpoint objects that belong to this cluster.
	Endpoints []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	// health_checks
	//
	// x-displayName: "Health Checks"
	// List of references to healthcheck object for this cluster.
	HealthChecks []*schema.ObjectRefType `protobuf:"bytes,2,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
	// loadbalancer_algorithm
	//
	// x-displayName: "LoadBalancer Algorithm"
	// When a connection to a endpoint in an upstream cluster is required, the loadbalancer uses
	// loadbalancer_algorithm to determine which host is selected.
	LoadbalancerAlgorithm LoadbalancerAlgorithm `protobuf:"varint,3,opt,name=loadbalancer_algorithm,json=loadbalancerAlgorithm,proto3,enum=ves.io.schema.cluster.LoadbalancerAlgorithm" json:"loadbalancer_algorithm,omitempty"`
	// circuit_breaker
	//
	// x-displayName: "Circuit Breaker"
	// CircuitBreaker provides a mechanism for watching failures in upstream connections or requests
	// and if the failures reach a certain threshold, automatically fail subsequent requests which
	// allows to apply back pressure on downstream quickly.
	CircuitBreaker *CircuitBreaker `protobuf:"bytes,4,opt,name=circuit_breaker,json=circuitBreaker,proto3" json:"circuit_breaker,omitempty"`
	// endpoint_subsets
	//
	// x-displayName: "Endpoint Subsets"
	// Cluster may be configured to divide its endpoints into subsets based on metadata
	// attached to the endpoints. Routes may then specify the metadata that a endpoint must match in
	// order to be selected by the load balancer.
	//
	// endpoint_subsets is list of subsets for this cluster. Each entry in this list has definition for a subset
	// (which is collection of keys)
	//
	// During routing, the route’s metadata match configuration is used to find a specific subset.
	// If there is a subset with the exact keys and values specified by the route, the subset is used
	// for load balancing. Otherwise, the fallback policy is used. The cluster’s subset configuration must,
	// therefore, contain a definition that has the same keys as a given route in order for subset load
	// balancing to occur.
	//
	// Example:
	//
	// RouteConfig
	//
	// routes:
	// - match:
	//   - headers: []
	//     path:
	//       path: /1.log
	//     query_params: []
	//   routeDestination:
	//     destinations:
	//     - cluster:
	//       - kind: cluster.Object
	//         uid: 00000000-0000-0000-0001-000000000005
	//     endpointSubsets:
	//       site: india
	//
	// EndpointConfig
	//
	// metadata:
	// labels:
	//   deployment: debug
	//   site: india
	// name: end-1
	// uid: end-1
	//
	// ClusterConfig
	//
	// gcSpec:
	//  defaultSubset:
	//    stage: production
	//  fallbackPolicy: DEFAULT_SUBSET
	//  endpointSubsets:
	//  - keys:
	//    - site
	//  - keys:
	//    - stage
	//    - app
	//
	// Assume the below endpoints are defined and associated with the cluster.
	//
	// Endpoint   Labels
	// --------   ------
	//
	//  ep1       stage: production, site: india
	//  ep2       stage: deployment, site: us
	//  ep3       stage: production, app: hr
	//  ep4       site: india
	//
	// The following table describes some routes and the result of their application
	// to the cluster. The subset definition for cluster is assumed to be same as given
	// above in the ClusterConfig section
	//
	// RouteMatch Criteria             Subset        Reason
	// -------------------             ------        ------
	//
	//  site: india                    ep1, ep4     Subset of endpoints selected
	//  site: us                       ep2          Subset of endpoints selected
	//  app: hr                        ep1, ep3     Fallback: No subset selector for "app" alone
	//  stage: production, app: hr     ep3          Subset of endpoints selected
	//  other: x                       ep1, ep3     Fallback: No subset selector for “other”
	//  (none)                         ep1, ep3     Fallback: No subset requested
	//
	EndpointSubsets []*EndpointSubsetSelectorType `protobuf:"bytes,5,rep,name=endpoint_subsets,json=endpointSubsets,proto3" json:"endpoint_subsets,omitempty"`
	// default_subset
	//
	// x-displayName: "Default Subset"
	// x-example: "key:value"
	// List of key-value pairs that define default subset. This subset can be referred in fallback_policy
	// which gets used when route specifies no metadata or no subset matching the metadata exists.
	DefaultSubset map[string]string `protobuf:"bytes,6,rep,name=default_subset,json=defaultSubset,proto3" json:"default_subset,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// fallback_policy
	//
	// x-displayName: "Fallback Policy"
	// If subsets are configured and a route specifies no metadata or no subset matching the metadata exists,
	// the subset load balancer initiates its fallback policy. The default policy is NO_FALLBACK, in which case
	// the request fails as if the cluster had no endpoints. Conversely, the ANY_ENDPOINT fallback policy
	// load balances across all endpoints in the cluster, without regard to endpoint metadata.
	// Finally, the DEFAULT_SUBSET causes fallback to load balance among endpoints that match a specific set of
	// metadata defined as default_set
	FallbackPolicy SubsetFallbackPolicy `protobuf:"varint,7,opt,name=fallback_policy,json=fallbackPolicy,proto3,enum=ves.io.schema.cluster.SubsetFallbackPolicy" json:"fallback_policy,omitempty"`
	// tls_parameters
	//
	// x-displayName: "TLS Parameters"
	// TLS parameters to access upstream endpoints for this cluster
	TlsParameters *schema.UpstreamTlsParamsType `protobuf:"bytes,8,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
	// connection_timeout
	//
	// x-displayName: "Connection Timeout"
	// x-example: "4000"
	// The timeout for new network connections to endpoints in the cluster.
	// This is specified in milliseconds. The default value is 2 seconds
	ConnectionTimeout uint32 `protobuf:"varint,9,opt,name=connection_timeout,json=connectionTimeout,proto3" json:"connection_timeout,omitempty"`
	// http_idle_timeout
	//
	// x-displayName: "HTTP Idle Timeout"
	// x-example: "60000"
	// The idle timeout for upstream connection pool connections. The idle timeout is defined as the
	// period in which there are no active requests. When the idle timeout is reached the connection
	// will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
	// This is specified in milliseconds. The default value is 5 minutes.
	HttpIdleTimeout uint32 `protobuf:"varint,10,opt,name=http_idle_timeout,json=httpIdleTimeout,proto3" json:"http_idle_timeout,omitempty"`
	// outlier_detection
	//
	// x-displayName: "Outlier Detection"
	// Outlier detection and ejection is the process of dynamically determining whether some number
	// of hosts in an upstream cluster are performing unlike the others and removing them from the
	// healthy load balancing set. Outlier detection is a form of passive health checking.
	OutlierDetection *OutlierDetectionType `protobuf:"bytes,12,opt,name=outlier_detection,json=outlierDetection,proto3" json:"outlier_detection,omitempty"`
	// endpoint_selection
	//
	// x-displayName: "Endpoint Selection"
	// Policy for selection of endpoints from local site or remote site or both
	EndpointSelection EndpointSelectionPolicy `protobuf:"varint,13,opt,name=endpoint_selection,json=endpointSelection,proto3,enum=ves.io.schema.cluster.EndpointSelectionPolicy" json:"endpoint_selection,omitempty"`
	// dns_lookup_family
	//
	// x-displayName: "DNS Lookup Family"
	// IP address family within which the DNS resolution is attempted. Default is AUTO mode
	DnsLookupFamily DnsLookupType `protobuf:"varint,14,opt,name=dns_lookup_family,json=dnsLookupFamily,proto3,enum=ves.io.schema.cluster.DnsLookupType" json:"dns_lookup_family,omitempty"`
	// dns_discovery_type
	//
	// x-displayName: "DNS Discovery Type"
	// Specifies how DNS resolution has to be done on members of cluster
	DnsDiscoveryType DnsDiscoveryType `protobuf:"varint,15,opt,name=dns_discovery_type,json=dnsDiscoveryType,proto3,enum=ves.io.schema.cluster.DnsDiscoveryType" json:"dns_discovery_type,omitempty"`
	// http2_options
	//
	// x-displayName: "Http2 Protocol Configuration"
	// Http2 Protocol options for upstream connections
	Http2Options *Http2ProtocolOptions `protobuf:"bytes,16,opt,name=http2_options,json=http2Options,proto3" json:"http2_options,omitempty"`
	// Panic threshold
	//
	// x-displayName: "Panic threshold"
	//
	// During loadbalancing, ADC will only consider healthy endpoints in an upstream cluster.
	// However, if the percentage of healthy endpoints in the cluster becomes too low, ADC can disregard health status
	// and loadbalance either amongst all endpoints or no endpoints. This is known as the panic threshold.
	//
	// Types that are valid to be assigned to PanicThresholdType:
	//	*GlobalSpecType_NoPanicThreshold
	//	*GlobalSpecType_PanicThreshold
	PanicThresholdType isGlobalSpecType_PanicThresholdType `protobuf_oneof:"panic_threshold_type"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{4}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_PanicThresholdType interface {
	isGlobalSpecType_PanicThresholdType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_NoPanicThreshold struct {
	NoPanicThreshold *schema.Empty `protobuf:"bytes,18,opt,name=no_panic_threshold,json=noPanicThreshold,proto3,oneof" json:"no_panic_threshold,omitempty"`
}
type GlobalSpecType_PanicThreshold struct {
	PanicThreshold uint32 `protobuf:"varint,19,opt,name=panic_threshold,json=panicThreshold,proto3,oneof" json:"panic_threshold,omitempty"`
}

func (*GlobalSpecType_NoPanicThreshold) isGlobalSpecType_PanicThresholdType() {}
func (*GlobalSpecType_PanicThreshold) isGlobalSpecType_PanicThresholdType()   {}

func (m *GlobalSpecType) GetPanicThresholdType() isGlobalSpecType_PanicThresholdType {
	if m != nil {
		return m.PanicThresholdType
	}
	return nil
}

func (m *GlobalSpecType) GetEndpoints() []*schema.ObjectRefType {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *GlobalSpecType) GetHealthChecks() []*schema.ObjectRefType {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *GlobalSpecType) GetLoadbalancerAlgorithm() LoadbalancerAlgorithm {
	if m != nil {
		return m.LoadbalancerAlgorithm
	}
	return ROUND_ROBIN
}

func (m *GlobalSpecType) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

func (m *GlobalSpecType) GetEndpointSubsets() []*EndpointSubsetSelectorType {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultSubset() map[string]string {
	if m != nil {
		return m.DefaultSubset
	}
	return nil
}

func (m *GlobalSpecType) GetFallbackPolicy() SubsetFallbackPolicy {
	if m != nil {
		return m.FallbackPolicy
	}
	return NO_FALLBACK
}

func (m *GlobalSpecType) GetTlsParameters() *schema.UpstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *GlobalSpecType) GetConnectionTimeout() uint32 {
	if m != nil {
		return m.ConnectionTimeout
	}
	return 0
}

func (m *GlobalSpecType) GetHttpIdleTimeout() uint32 {
	if m != nil {
		return m.HttpIdleTimeout
	}
	return 0
}

func (m *GlobalSpecType) GetOutlierDetection() *OutlierDetectionType {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *GlobalSpecType) GetEndpointSelection() EndpointSelectionPolicy {
	if m != nil {
		return m.EndpointSelection
	}
	return DISTRIBUTED
}

func (m *GlobalSpecType) GetDnsLookupFamily() DnsLookupType {
	if m != nil {
		return m.DnsLookupFamily
	}
	return AUTO
}

func (m *GlobalSpecType) GetDnsDiscoveryType() DnsDiscoveryType {
	if m != nil {
		return m.DnsDiscoveryType
	}
	return STRICT_DNS
}

func (m *GlobalSpecType) GetHttp2Options() *Http2ProtocolOptions {
	if m != nil {
		return m.Http2Options
	}
	return nil
}

func (m *GlobalSpecType) GetNoPanicThreshold() *schema.Empty {
	if x, ok := m.GetPanicThresholdType().(*GlobalSpecType_NoPanicThreshold); ok {
		return x.NoPanicThreshold
	}
	return nil
}

func (m *GlobalSpecType) GetPanicThreshold() uint32 {
	if x, ok := m.GetPanicThresholdType().(*GlobalSpecType_PanicThreshold); ok {
		return x.PanicThreshold
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_NoPanicThreshold)(nil),
		(*GlobalSpecType_PanicThreshold)(nil),
	}
}

// Create cluster
//
// x-displayName: "Create Cluster"
// Create cluster will create the object in the storage backend for namespace metadata.namespace
type CreateSpecType struct {
	Endpoints             []*schema.ObjectRefType       `protobuf:"bytes,1,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	HealthChecks          []*schema.ObjectRefType       `protobuf:"bytes,2,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
	LoadbalancerAlgorithm LoadbalancerAlgorithm         `protobuf:"varint,3,opt,name=loadbalancer_algorithm,json=loadbalancerAlgorithm,proto3,enum=ves.io.schema.cluster.LoadbalancerAlgorithm" json:"loadbalancer_algorithm,omitempty"`
	CircuitBreaker        *CircuitBreaker               `protobuf:"bytes,4,opt,name=circuit_breaker,json=circuitBreaker,proto3" json:"circuit_breaker,omitempty"`
	EndpointSubsets       []*EndpointSubsetSelectorType `protobuf:"bytes,5,rep,name=endpoint_subsets,json=endpointSubsets,proto3" json:"endpoint_subsets,omitempty"`
	DefaultSubset         map[string]string             `protobuf:"bytes,6,rep,name=default_subset,json=defaultSubset,proto3" json:"default_subset,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FallbackPolicy        SubsetFallbackPolicy          `protobuf:"varint,7,opt,name=fallback_policy,json=fallbackPolicy,proto3,enum=ves.io.schema.cluster.SubsetFallbackPolicy" json:"fallback_policy,omitempty"`
	TlsParameters         *schema.UpstreamTlsParamsType `protobuf:"bytes,8,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
	ConnectionTimeout     uint32                        `protobuf:"varint,9,opt,name=connection_timeout,json=connectionTimeout,proto3" json:"connection_timeout,omitempty"`
	HttpIdleTimeout       uint32                        `protobuf:"varint,10,opt,name=http_idle_timeout,json=httpIdleTimeout,proto3" json:"http_idle_timeout,omitempty"`
	OutlierDetection      *OutlierDetectionType         `protobuf:"bytes,12,opt,name=outlier_detection,json=outlierDetection,proto3" json:"outlier_detection,omitempty"`
	EndpointSelection     EndpointSelectionPolicy       `protobuf:"varint,13,opt,name=endpoint_selection,json=endpointSelection,proto3,enum=ves.io.schema.cluster.EndpointSelectionPolicy" json:"endpoint_selection,omitempty"`
	Http2Options          *Http2ProtocolOptions         `protobuf:"bytes,16,opt,name=http2_options,json=http2Options,proto3" json:"http2_options,omitempty"`
	// Types that are valid to be assigned to PanicThresholdType:
	//	*CreateSpecType_NoPanicThreshold
	//	*CreateSpecType_PanicThreshold
	PanicThresholdType isCreateSpecType_PanicThresholdType `protobuf_oneof:"panic_threshold_type"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{5}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_PanicThresholdType interface {
	isCreateSpecType_PanicThresholdType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_NoPanicThreshold struct {
	NoPanicThreshold *schema.Empty `protobuf:"bytes,18,opt,name=no_panic_threshold,json=noPanicThreshold,proto3,oneof" json:"no_panic_threshold,omitempty"`
}
type CreateSpecType_PanicThreshold struct {
	PanicThreshold uint32 `protobuf:"varint,19,opt,name=panic_threshold,json=panicThreshold,proto3,oneof" json:"panic_threshold,omitempty"`
}

func (*CreateSpecType_NoPanicThreshold) isCreateSpecType_PanicThresholdType() {}
func (*CreateSpecType_PanicThreshold) isCreateSpecType_PanicThresholdType()   {}

func (m *CreateSpecType) GetPanicThresholdType() isCreateSpecType_PanicThresholdType {
	if m != nil {
		return m.PanicThresholdType
	}
	return nil
}

func (m *CreateSpecType) GetEndpoints() []*schema.ObjectRefType {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *CreateSpecType) GetHealthChecks() []*schema.ObjectRefType {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *CreateSpecType) GetLoadbalancerAlgorithm() LoadbalancerAlgorithm {
	if m != nil {
		return m.LoadbalancerAlgorithm
	}
	return ROUND_ROBIN
}

func (m *CreateSpecType) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

func (m *CreateSpecType) GetEndpointSubsets() []*EndpointSubsetSelectorType {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

func (m *CreateSpecType) GetDefaultSubset() map[string]string {
	if m != nil {
		return m.DefaultSubset
	}
	return nil
}

func (m *CreateSpecType) GetFallbackPolicy() SubsetFallbackPolicy {
	if m != nil {
		return m.FallbackPolicy
	}
	return NO_FALLBACK
}

func (m *CreateSpecType) GetTlsParameters() *schema.UpstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *CreateSpecType) GetConnectionTimeout() uint32 {
	if m != nil {
		return m.ConnectionTimeout
	}
	return 0
}

func (m *CreateSpecType) GetHttpIdleTimeout() uint32 {
	if m != nil {
		return m.HttpIdleTimeout
	}
	return 0
}

func (m *CreateSpecType) GetOutlierDetection() *OutlierDetectionType {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *CreateSpecType) GetEndpointSelection() EndpointSelectionPolicy {
	if m != nil {
		return m.EndpointSelection
	}
	return DISTRIBUTED
}

func (m *CreateSpecType) GetHttp2Options() *Http2ProtocolOptions {
	if m != nil {
		return m.Http2Options
	}
	return nil
}

func (m *CreateSpecType) GetNoPanicThreshold() *schema.Empty {
	if x, ok := m.GetPanicThresholdType().(*CreateSpecType_NoPanicThreshold); ok {
		return x.NoPanicThreshold
	}
	return nil
}

func (m *CreateSpecType) GetPanicThreshold() uint32 {
	if x, ok := m.GetPanicThresholdType().(*CreateSpecType_PanicThreshold); ok {
		return x.PanicThreshold
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_NoPanicThreshold)(nil),
		(*CreateSpecType_PanicThreshold)(nil),
	}
}

// Replace cluster
//
// x-displayName: "Replace Cluster"
// Replacing an cluster object will update the object by replacing the existing spec with the provided one.
// For read-then-write operations a resourceVersion mismatch will occur if the object was modified between the read and write
type ReplaceSpecType struct {
	Endpoints             []*schema.ObjectRefType       `protobuf:"bytes,1,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	HealthChecks          []*schema.ObjectRefType       `protobuf:"bytes,2,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
	LoadbalancerAlgorithm LoadbalancerAlgorithm         `protobuf:"varint,3,opt,name=loadbalancer_algorithm,json=loadbalancerAlgorithm,proto3,enum=ves.io.schema.cluster.LoadbalancerAlgorithm" json:"loadbalancer_algorithm,omitempty"`
	CircuitBreaker        *CircuitBreaker               `protobuf:"bytes,4,opt,name=circuit_breaker,json=circuitBreaker,proto3" json:"circuit_breaker,omitempty"`
	EndpointSubsets       []*EndpointSubsetSelectorType `protobuf:"bytes,5,rep,name=endpoint_subsets,json=endpointSubsets,proto3" json:"endpoint_subsets,omitempty"`
	DefaultSubset         map[string]string             `protobuf:"bytes,6,rep,name=default_subset,json=defaultSubset,proto3" json:"default_subset,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FallbackPolicy        SubsetFallbackPolicy          `protobuf:"varint,7,opt,name=fallback_policy,json=fallbackPolicy,proto3,enum=ves.io.schema.cluster.SubsetFallbackPolicy" json:"fallback_policy,omitempty"`
	TlsParameters         *schema.UpstreamTlsParamsType `protobuf:"bytes,8,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
	ConnectionTimeout     uint32                        `protobuf:"varint,9,opt,name=connection_timeout,json=connectionTimeout,proto3" json:"connection_timeout,omitempty"`
	HttpIdleTimeout       uint32                        `protobuf:"varint,10,opt,name=http_idle_timeout,json=httpIdleTimeout,proto3" json:"http_idle_timeout,omitempty"`
	OutlierDetection      *OutlierDetectionType         `protobuf:"bytes,12,opt,name=outlier_detection,json=outlierDetection,proto3" json:"outlier_detection,omitempty"`
	EndpointSelection     EndpointSelectionPolicy       `protobuf:"varint,13,opt,name=endpoint_selection,json=endpointSelection,proto3,enum=ves.io.schema.cluster.EndpointSelectionPolicy" json:"endpoint_selection,omitempty"`
	Http2Options          *Http2ProtocolOptions         `protobuf:"bytes,16,opt,name=http2_options,json=http2Options,proto3" json:"http2_options,omitempty"`
	// Types that are valid to be assigned to PanicThresholdType:
	//	*ReplaceSpecType_NoPanicThreshold
	//	*ReplaceSpecType_PanicThreshold
	PanicThresholdType isReplaceSpecType_PanicThresholdType `protobuf_oneof:"panic_threshold_type"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{6}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_PanicThresholdType interface {
	isReplaceSpecType_PanicThresholdType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_NoPanicThreshold struct {
	NoPanicThreshold *schema.Empty `protobuf:"bytes,18,opt,name=no_panic_threshold,json=noPanicThreshold,proto3,oneof" json:"no_panic_threshold,omitempty"`
}
type ReplaceSpecType_PanicThreshold struct {
	PanicThreshold uint32 `protobuf:"varint,19,opt,name=panic_threshold,json=panicThreshold,proto3,oneof" json:"panic_threshold,omitempty"`
}

func (*ReplaceSpecType_NoPanicThreshold) isReplaceSpecType_PanicThresholdType() {}
func (*ReplaceSpecType_PanicThreshold) isReplaceSpecType_PanicThresholdType()   {}

func (m *ReplaceSpecType) GetPanicThresholdType() isReplaceSpecType_PanicThresholdType {
	if m != nil {
		return m.PanicThresholdType
	}
	return nil
}

func (m *ReplaceSpecType) GetEndpoints() []*schema.ObjectRefType {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *ReplaceSpecType) GetHealthChecks() []*schema.ObjectRefType {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *ReplaceSpecType) GetLoadbalancerAlgorithm() LoadbalancerAlgorithm {
	if m != nil {
		return m.LoadbalancerAlgorithm
	}
	return ROUND_ROBIN
}

func (m *ReplaceSpecType) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

func (m *ReplaceSpecType) GetEndpointSubsets() []*EndpointSubsetSelectorType {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

func (m *ReplaceSpecType) GetDefaultSubset() map[string]string {
	if m != nil {
		return m.DefaultSubset
	}
	return nil
}

func (m *ReplaceSpecType) GetFallbackPolicy() SubsetFallbackPolicy {
	if m != nil {
		return m.FallbackPolicy
	}
	return NO_FALLBACK
}

func (m *ReplaceSpecType) GetTlsParameters() *schema.UpstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *ReplaceSpecType) GetConnectionTimeout() uint32 {
	if m != nil {
		return m.ConnectionTimeout
	}
	return 0
}

func (m *ReplaceSpecType) GetHttpIdleTimeout() uint32 {
	if m != nil {
		return m.HttpIdleTimeout
	}
	return 0
}

func (m *ReplaceSpecType) GetOutlierDetection() *OutlierDetectionType {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *ReplaceSpecType) GetEndpointSelection() EndpointSelectionPolicy {
	if m != nil {
		return m.EndpointSelection
	}
	return DISTRIBUTED
}

func (m *ReplaceSpecType) GetHttp2Options() *Http2ProtocolOptions {
	if m != nil {
		return m.Http2Options
	}
	return nil
}

func (m *ReplaceSpecType) GetNoPanicThreshold() *schema.Empty {
	if x, ok := m.GetPanicThresholdType().(*ReplaceSpecType_NoPanicThreshold); ok {
		return x.NoPanicThreshold
	}
	return nil
}

func (m *ReplaceSpecType) GetPanicThreshold() uint32 {
	if x, ok := m.GetPanicThresholdType().(*ReplaceSpecType_PanicThreshold); ok {
		return x.PanicThreshold
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_NoPanicThreshold)(nil),
		(*ReplaceSpecType_PanicThreshold)(nil),
	}
}

// Get cluster
//
// x-displayName: "Get Cluster"
// Get cluster will get the object from the storage backend for namespace metadata.namespace
type GetSpecType struct {
	Endpoints             []*schema.ObjectRefType       `protobuf:"bytes,1,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	HealthChecks          []*schema.ObjectRefType       `protobuf:"bytes,2,rep,name=health_checks,json=healthChecks,proto3" json:"health_checks,omitempty"`
	LoadbalancerAlgorithm LoadbalancerAlgorithm         `protobuf:"varint,3,opt,name=loadbalancer_algorithm,json=loadbalancerAlgorithm,proto3,enum=ves.io.schema.cluster.LoadbalancerAlgorithm" json:"loadbalancer_algorithm,omitempty"`
	CircuitBreaker        *CircuitBreaker               `protobuf:"bytes,4,opt,name=circuit_breaker,json=circuitBreaker,proto3" json:"circuit_breaker,omitempty"`
	EndpointSubsets       []*EndpointSubsetSelectorType `protobuf:"bytes,5,rep,name=endpoint_subsets,json=endpointSubsets,proto3" json:"endpoint_subsets,omitempty"`
	DefaultSubset         map[string]string             `protobuf:"bytes,6,rep,name=default_subset,json=defaultSubset,proto3" json:"default_subset,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FallbackPolicy        SubsetFallbackPolicy          `protobuf:"varint,7,opt,name=fallback_policy,json=fallbackPolicy,proto3,enum=ves.io.schema.cluster.SubsetFallbackPolicy" json:"fallback_policy,omitempty"`
	TlsParameters         *schema.UpstreamTlsParamsType `protobuf:"bytes,8,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
	ConnectionTimeout     uint32                        `protobuf:"varint,9,opt,name=connection_timeout,json=connectionTimeout,proto3" json:"connection_timeout,omitempty"`
	HttpIdleTimeout       uint32                        `protobuf:"varint,10,opt,name=http_idle_timeout,json=httpIdleTimeout,proto3" json:"http_idle_timeout,omitempty"`
	OutlierDetection      *OutlierDetectionType         `protobuf:"bytes,12,opt,name=outlier_detection,json=outlierDetection,proto3" json:"outlier_detection,omitempty"`
	EndpointSelection     EndpointSelectionPolicy       `protobuf:"varint,13,opt,name=endpoint_selection,json=endpointSelection,proto3,enum=ves.io.schema.cluster.EndpointSelectionPolicy" json:"endpoint_selection,omitempty"`
	Http2Options          *Http2ProtocolOptions         `protobuf:"bytes,16,opt,name=http2_options,json=http2Options,proto3" json:"http2_options,omitempty"`
	// Types that are valid to be assigned to PanicThresholdType:
	//	*GetSpecType_NoPanicThreshold
	//	*GetSpecType_PanicThreshold
	PanicThresholdType isGetSpecType_PanicThresholdType `protobuf_oneof:"panic_threshold_type"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f4ccbbce2db2b210, []int{7}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_PanicThresholdType interface {
	isGetSpecType_PanicThresholdType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_NoPanicThreshold struct {
	NoPanicThreshold *schema.Empty `protobuf:"bytes,18,opt,name=no_panic_threshold,json=noPanicThreshold,proto3,oneof" json:"no_panic_threshold,omitempty"`
}
type GetSpecType_PanicThreshold struct {
	PanicThreshold uint32 `protobuf:"varint,19,opt,name=panic_threshold,json=panicThreshold,proto3,oneof" json:"panic_threshold,omitempty"`
}

func (*GetSpecType_NoPanicThreshold) isGetSpecType_PanicThresholdType() {}
func (*GetSpecType_PanicThreshold) isGetSpecType_PanicThresholdType()   {}

func (m *GetSpecType) GetPanicThresholdType() isGetSpecType_PanicThresholdType {
	if m != nil {
		return m.PanicThresholdType
	}
	return nil
}

func (m *GetSpecType) GetEndpoints() []*schema.ObjectRefType {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *GetSpecType) GetHealthChecks() []*schema.ObjectRefType {
	if m != nil {
		return m.HealthChecks
	}
	return nil
}

func (m *GetSpecType) GetLoadbalancerAlgorithm() LoadbalancerAlgorithm {
	if m != nil {
		return m.LoadbalancerAlgorithm
	}
	return ROUND_ROBIN
}

func (m *GetSpecType) GetCircuitBreaker() *CircuitBreaker {
	if m != nil {
		return m.CircuitBreaker
	}
	return nil
}

func (m *GetSpecType) GetEndpointSubsets() []*EndpointSubsetSelectorType {
	if m != nil {
		return m.EndpointSubsets
	}
	return nil
}

func (m *GetSpecType) GetDefaultSubset() map[string]string {
	if m != nil {
		return m.DefaultSubset
	}
	return nil
}

func (m *GetSpecType) GetFallbackPolicy() SubsetFallbackPolicy {
	if m != nil {
		return m.FallbackPolicy
	}
	return NO_FALLBACK
}

func (m *GetSpecType) GetTlsParameters() *schema.UpstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

func (m *GetSpecType) GetConnectionTimeout() uint32 {
	if m != nil {
		return m.ConnectionTimeout
	}
	return 0
}

func (m *GetSpecType) GetHttpIdleTimeout() uint32 {
	if m != nil {
		return m.HttpIdleTimeout
	}
	return 0
}

func (m *GetSpecType) GetOutlierDetection() *OutlierDetectionType {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *GetSpecType) GetEndpointSelection() EndpointSelectionPolicy {
	if m != nil {
		return m.EndpointSelection
	}
	return DISTRIBUTED
}

func (m *GetSpecType) GetHttp2Options() *Http2ProtocolOptions {
	if m != nil {
		return m.Http2Options
	}
	return nil
}

func (m *GetSpecType) GetNoPanicThreshold() *schema.Empty {
	if x, ok := m.GetPanicThresholdType().(*GetSpecType_NoPanicThreshold); ok {
		return x.NoPanicThreshold
	}
	return nil
}

func (m *GetSpecType) GetPanicThreshold() uint32 {
	if x, ok := m.GetPanicThresholdType().(*GetSpecType_PanicThreshold); ok {
		return x.PanicThreshold
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_NoPanicThreshold)(nil),
		(*GetSpecType_PanicThreshold)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.cluster.LoadbalancerAlgorithm", LoadbalancerAlgorithm_name, LoadbalancerAlgorithm_value)
	golang_proto.RegisterEnum("ves.io.schema.cluster.LoadbalancerAlgorithm", LoadbalancerAlgorithm_name, LoadbalancerAlgorithm_value)
	proto.RegisterEnum("ves.io.schema.cluster.DnsDiscoveryType", DnsDiscoveryType_name, DnsDiscoveryType_value)
	golang_proto.RegisterEnum("ves.io.schema.cluster.DnsDiscoveryType", DnsDiscoveryType_name, DnsDiscoveryType_value)
	proto.RegisterEnum("ves.io.schema.cluster.DnsLookupType", DnsLookupType_name, DnsLookupType_value)
	golang_proto.RegisterEnum("ves.io.schema.cluster.DnsLookupType", DnsLookupType_name, DnsLookupType_value)
	proto.RegisterEnum("ves.io.schema.cluster.SubsetFallbackPolicy", SubsetFallbackPolicy_name, SubsetFallbackPolicy_value)
	golang_proto.RegisterEnum("ves.io.schema.cluster.SubsetFallbackPolicy", SubsetFallbackPolicy_name, SubsetFallbackPolicy_value)
	proto.RegisterEnum("ves.io.schema.cluster.EndpointSelectionPolicy", EndpointSelectionPolicy_name, EndpointSelectionPolicy_value)
	golang_proto.RegisterEnum("ves.io.schema.cluster.EndpointSelectionPolicy", EndpointSelectionPolicy_name, EndpointSelectionPolicy_value)
	proto.RegisterType((*OutlierDetectionType)(nil), "ves.io.schema.cluster.OutlierDetectionType")
	golang_proto.RegisterType((*OutlierDetectionType)(nil), "ves.io.schema.cluster.OutlierDetectionType")
	proto.RegisterType((*EndpointSubsetSelectorType)(nil), "ves.io.schema.cluster.EndpointSubsetSelectorType")
	golang_proto.RegisterType((*EndpointSubsetSelectorType)(nil), "ves.io.schema.cluster.EndpointSubsetSelectorType")
	proto.RegisterType((*CircuitBreaker)(nil), "ves.io.schema.cluster.CircuitBreaker")
	golang_proto.RegisterType((*CircuitBreaker)(nil), "ves.io.schema.cluster.CircuitBreaker")
	proto.RegisterType((*Http2ProtocolOptions)(nil), "ves.io.schema.cluster.Http2ProtocolOptions")
	golang_proto.RegisterType((*Http2ProtocolOptions)(nil), "ves.io.schema.cluster.Http2ProtocolOptions")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cluster.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cluster.GlobalSpecType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cluster.GlobalSpecType.DefaultSubsetEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cluster.GlobalSpecType.DefaultSubsetEntry")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cluster.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cluster.CreateSpecType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cluster.CreateSpecType.DefaultSubsetEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cluster.CreateSpecType.DefaultSubsetEntry")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cluster.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cluster.ReplaceSpecType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cluster.ReplaceSpecType.DefaultSubsetEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cluster.ReplaceSpecType.DefaultSubsetEntry")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cluster.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cluster.GetSpecType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cluster.GetSpecType.DefaultSubsetEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cluster.GetSpecType.DefaultSubsetEntry")
}

func init() { proto.RegisterFile("ves.io/schema/cluster/types.proto", fileDescriptor_f4ccbbce2db2b210) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/cluster/types.proto", fileDescriptor_f4ccbbce2db2b210)
}

var fileDescriptor_f4ccbbce2db2b210 = []byte{
	// 1972 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcf, 0x6f, 0x1b, 0xc7,
	0x15, 0xe6, 0x50, 0x94, 0x4d, 0x8d, 0x44, 0x72, 0x35, 0x96, 0xec, 0xb5, 0x62, 0x10, 0x8c, 0xe0,
	0xa2, 0xb6, 0xb2, 0xa2, 0x4c, 0x4a, 0x72, 0x64, 0x01, 0x75, 0xc2, 0x15, 0xa9, 0x1f, 0x36, 0x43,
	0xd2, 0x4b, 0x2a, 0x68, 0xd2, 0xd4, 0xdb, 0xe5, 0x72, 0x48, 0x6d, 0xb5, 0xdc, 0xdd, 0xee, 0x0e,
	0x15, 0xe9, 0x10, 0xc0, 0xc8, 0xad, 0x3d, 0xb5, 0x3d, 0xf4, 0x90, 0xbf, 0xa0, 0xc8, 0xb1, 0xc7,
	0x2a, 0x28, 0x84, 0xa0, 0x2d, 0x82, 0x5e, 0xea, 0x5b, 0x8d, 0x9c, 0x62, 0xfa, 0xd2, 0x5e, 0x0a,
	0x23, 0xa7, 0xa2, 0xa7, 0x62, 0x66, 0x77, 0x25, 0x92, 0xe2, 0xa6, 0x75, 0xa5, 0x1c, 0x02, 0xe8,
	0xc6, 0xdd, 0xf7, 0xbe, 0xef, 0xed, 0xcc, 0x7b, 0xf3, 0x7d, 0x4b, 0x12, 0xbe, 0xbe, 0x87, 0x9d,
	0xb4, 0x66, 0x2e, 0x38, 0xea, 0x0e, 0x6e, 0x2b, 0x0b, 0xaa, 0xde, 0x71, 0x08, 0xb6, 0x17, 0xc8,
	0x81, 0x85, 0x9d, 0xb4, 0x65, 0x9b, 0xc4, 0x44, 0xd3, 0x6e, 0x4a, 0xda, 0x4d, 0x49, 0x7b, 0x29,
	0x33, 0xf3, 0x2d, 0x8d, 0xec, 0x74, 0xea, 0x69, 0xd5, 0x6c, 0x2f, 0xb4, 0xcc, 0x96, 0xb9, 0xc0,
	0xb2, 0xeb, 0x9d, 0x26, 0xbb, 0x62, 0x17, 0xec, 0x93, 0xcb, 0x32, 0xf3, 0x5a, 0x7f, 0x21, 0xd3,
	0x22, 0x9a, 0x69, 0x78, 0x25, 0x66, 0xae, 0xf7, 0x07, 0x7b, 0xaa, 0xcf, 0xdc, 0xe8, 0x0f, 0xed,
	0x29, 0xba, 0xd6, 0x50, 0x08, 0xf6, 0xa2, 0xa9, 0x81, 0xa8, 0x86, 0x3f, 0x94, 0xfb, 0xa8, 0x67,
	0xbf, 0x0c, 0xc3, 0xa9, 0x72, 0x87, 0xe8, 0x1a, 0xb6, 0xf3, 0x98, 0x60, 0x95, 0xc6, 0x6a, 0x07,
	0x16, 0x46, 0x6f, 0xc2, 0x84, 0x6a, 0x1a, 0x0e, 0x56, 0x3b, 0x44, 0xdb, 0xc3, 0xf2, 0xf2, 0xfe,
	0x3e, 0x0f, 0x52, 0xe0, 0x56, 0x4c, 0x8c, 0xff, 0xeb, 0x10, 0x84, 0x7e, 0xff, 0x8f, 0xa3, 0x91,
	0xd1, 0xb9, 0x11, 0xfe, 0x49, 0x54, 0x8a, 0xf7, 0xa4, 0x2d, 0xef, 0xef, 0xa3, 0x37, 0x60, 0x54,
	0x33, 0x08, 0xb6, 0xf7, 0x14, 0x9d, 0x0f, 0x33, 0x44, 0xc2, 0x47, 0x5c, 0x9a, 0x8b, 0xf0, 0x47,
	0x7f, 0xbd, 0x29, 0x1d, 0x27, 0xa0, 0x1f, 0x40, 0x54, 0x57, 0x1c, 0x2c, 0xe3, 0x9f, 0xba, 0xa5,
	0x65, 0xa2, 0xb5, 0x31, 0x3f, 0x32, 0x04, 0xf6, 0xcf, 0xb6, 0xc4, 0xd1, 0xd4, 0x82, 0x97, 0x59,
	0xd3, 0xda, 0x18, 0xbd, 0x05, 0xa7, 0xda, 0xca, 0xfe, 0x09, 0xda, 0xc2, 0xb6, 0x8a, 0x0d, 0xc2,
	0x47, 0x18, 0x41, 0xcc, 0x27, 0x88, 0xcc, 0x85, 0xf9, 0x86, 0x84, 0xda, 0xca, 0xbe, 0x8f, 0xae,
	0xb8, 0x89, 0xa8, 0x04, 0x5f, 0xeb, 0x5d, 0x65, 0x4b, 0x21, 0xf8, 0x43, 0xe5, 0x40, 0x6e, 0x2a,
	0x9a, 0xde, 0xb1, 0x31, 0x3f, 0x3a, 0x74, 0xc5, 0xd7, 0x7b, 0x20, 0x1b, 0x2e, 0x62, 0xdd, 0x05,
	0xac, 0x4e, 0x7c, 0x7d, 0x7f, 0x2c, 0x23, 0x64, 0x85, 0x45, 0x61, 0x49, 0x58, 0x9e, 0x6d, 0xc0,
	0x99, 0x82, 0xd1, 0xb0, 0x4c, 0xcd, 0x20, 0xd5, 0x4e, 0xdd, 0xc1, 0xa4, 0x8a, 0x75, 0xac, 0x12,
	0xd3, 0x66, 0x3b, 0x3c, 0x0b, 0x23, 0xbb, 0xf8, 0xc0, 0xe1, 0x41, 0x6a, 0xe4, 0xd6, 0x58, 0x4f,
	0x91, 0x5f, 0x83, 0x30, 0xc7, 0x49, 0x2c, 0xb6, 0x3a, 0xfb, 0xf9, 0x21, 0x48, 0xc2, 0x1b, 0xf0,
	0x5a, 0x51, 0x73, 0x48, 0xca, 0x6c, 0xa6, 0xe8, 0xdd, 0x54, 0xd3, 0xb4, 0x53, 0x2e, 0x21, 0x02,
	0x99, 0xd9, 0xbf, 0x85, 0x61, 0x7c, 0x4d, 0xb3, 0xd5, 0x8e, 0x46, 0x44, 0x1b, 0x2b, 0xbb, 0xd8,
	0x46, 0x6f, 0xc3, 0xa8, 0x65, 0x6b, 0xa6, 0xad, 0x91, 0x03, 0xd6, 0xb5, 0x78, 0x36, 0x99, 0xee,
	0x1f, 0x53, 0xc9, 0xec, 0x10, 0xcd, 0x68, 0x55, 0xbc, 0x2c, 0x31, 0x42, 0xcb, 0x4b, 0xc7, 0x28,
	0x24, 0x42, 0x4e, 0x35, 0x0d, 0xc3, 0xdb, 0x57, 0x5d, 0x6b, 0x6b, 0xc4, 0xeb, 0xe6, 0xb5, 0x2f,
	0x0f, 0x41, 0x24, 0x73, 0x27, 0xbb, 0xd4, 0xdb, 0x9e, 0x27, 0x4f, 0xc2, 0x52, 0xe2, 0x04, 0x50,
	0xa4, 0xf9, 0x94, 0xc3, 0xc2, 0x46, 0x43, 0x33, 0x5a, 0xb2, 0x8d, 0x7f, 0xd6, 0xc1, 0x0e, 0x71,
	0xbc, 0xd6, 0x06, 0x73, 0x78, 0x00, 0xc9, 0xcb, 0x47, 0x19, 0x78, 0xd9, 0xc6, 0xc4, 0xd6, 0xb0,
	0xe3, 0x35, 0x35, 0x10, 0xea, 0xe7, 0xa1, 0x55, 0x38, 0x41, 0x87, 0xe2, 0xb8, 0xe4, 0xe8, 0x37,
	0xe3, 0xc6, 0xdb, 0xca, 0xbe, 0x5f, 0x6e, 0xa0, 0x7f, 0x77, 0xe0, 0xd4, 0x26, 0x21, 0x56, 0xb6,
	0x42, 0x8f, 0x8a, 0x6a, 0xea, 0x65, 0xf7, 0xe8, 0x20, 0x1e, 0x5e, 0xc6, 0x86, 0x52, 0xd7, 0x71,
	0x83, 0xed, 0x6e, 0x54, 0xf2, 0x2f, 0x67, 0x7f, 0x17, 0x87, 0xf1, 0x0d, 0xdd, 0xac, 0x2b, 0x7a,
	0xd5, 0xc2, 0x2a, 0x6b, 0xf3, 0x23, 0x38, 0x86, 0xbd, 0x21, 0x70, 0x7b, 0x3d, 0x9e, 0xbd, 0x31,
	0xd0, 0x8c, 0x72, 0x9d, 0x8e, 0xa5, 0x84, 0x9b, 0x14, 0x20, 0x4e, 0x7f, 0xfa, 0x51, 0xd4, 0x47,
	0x1c, 0x0f, 0x44, 0x4a, 0x3a, 0x61, 0x41, 0x3f, 0x82, 0xb1, 0x1d, 0xac, 0xe8, 0x64, 0x47, 0x56,
	0x77, 0xb0, 0xba, 0xeb, 0xf0, 0xe1, 0xff, 0x81, 0x96, 0xff, 0xf4, 0xa3, 0x71, 0x17, 0xc5, 0x40,
	0xc7, 0xcc, 0x11, 0x69, 0xc2, 0xbd, 0xbd, 0xc6, 0xb8, 0x90, 0x06, 0xaf, 0xea, 0xa6, 0xd2, 0xa8,
	0x2b, 0xba, 0x62, 0xa8, 0xd8, 0x96, 0x15, 0xbd, 0x45, 0x47, 0x62, 0xa7, 0xcd, 0x7a, 0x17, 0xcf,
	0x0a, 0xe9, 0xa1, 0x82, 0x97, 0x2e, 0xf6, 0x80, 0x72, 0x3e, 0xc6, 0x9b, 0xab, 0x69, 0x7d, 0x58,
	0x10, 0xd5, 0x60, 0x42, 0x75, 0x07, 0x57, 0xae, 0xbb, 0x93, 0xcb, 0x9a, 0x3c, 0x9e, 0xfd, 0x5e,
	0x40, 0x8d, 0xfe, 0x31, 0x17, 0x23, 0x47, 0x87, 0x00, 0x48, 0x71, 0xb5, 0x7f, 0xf8, 0x09, 0xe4,
	0xfc, 0xad, 0x92, 0x1d, 0x76, 0x4a, 0xe8, 0x0c, 0xd0, 0x0d, 0xca, 0x04, 0xd0, 0x06, 0x1f, 0x52,
	0xf1, 0x2a, 0x2d, 0xf1, 0xf4, 0x10, 0x80, 0xbe, 0xe3, 0x99, 0x92, 0x12, 0xb8, 0x0f, 0xe3, 0xa0,
	0x8f, 0x01, 0x8c, 0x37, 0x70, 0x53, 0xe9, 0xe8, 0x7e, 0x55, 0xfe, 0x12, 0x2b, 0xba, 0x12, 0x50,
	0xb4, 0x7f, 0x4c, 0xd2, 0x79, 0x17, 0xeb, 0xd2, 0x15, 0x0c, 0x62, 0x1f, 0x88, 0xaf, 0xd3, 0xda,
	0x9f, 0x7c, 0x06, 0x22, 0x30, 0x1c, 0x02, 0xac, 0xf6, 0x27, 0xb4, 0x76, 0xf7, 0xab, 0x3f, 0x8d,
	0x5c, 0xfa, 0xc5, 0x67, 0x20, 0x1c, 0x0d, 0x49, 0xb1, 0x46, 0x2f, 0x0c, 0x3d, 0x86, 0x89, 0xa6,
	0xa2, 0xeb, 0x75, 0x45, 0xdd, 0x95, 0x2d, 0x53, 0xd7, 0xd4, 0x03, 0xfe, 0x32, 0x6b, 0xda, 0x1b,
	0x01, 0x0f, 0xe1, 0xe2, 0xd6, 0x3d, 0x4c, 0x85, 0x41, 0xc4, 0xe8, 0x91, 0xb7, 0x5e, 0x29, 0xde,
	0xec, 0x8b, 0xa0, 0x47, 0x30, 0x4e, 0x74, 0x47, 0xb6, 0x14, 0x5b, 0x69, 0x63, 0x82, 0x6d, 0x87,
	0x8f, 0xb2, 0x7e, 0xdd, 0x1c, 0xa0, 0xdf, 0xb6, 0x1c, 0x62, 0x63, 0xa5, 0x5d, 0xd3, 0x9d, 0x0a,
	0xcd, 0x75, 0xd8, 0x5e, 0x46, 0xe8, 0x3e, 0x4a, 0x31, 0xe2, 0xdd, 0x64, 0x04, 0x48, 0x84, 0xa8,
	0x47, 0x68, 0xa8, 0xfc, 0x9b, 0x1d, 0xc2, 0x8f, 0xb1, 0x33, 0x7b, 0xe5, 0xa8, 0x67, 0xe3, 0x7d,
	0xf3, 0x98, 0x3c, 0x49, 0xaf, 0xb9, 0xd9, 0xe8, 0x2d, 0x38, 0xb9, 0x43, 0x88, 0x25, 0x6b, 0x0d,
	0x1d, 0x1f, 0x53, 0xc0, 0x60, 0x8a, 0x04, 0xcd, 0xde, 0x6a, 0xe8, 0xd8, 0x27, 0x78, 0x0c, 0x27,
	0x4d, 0xd7, 0x04, 0xe5, 0x86, 0xef, 0x82, 0xfc, 0x04, 0x5b, 0x5a, 0xd0, 0xce, 0x0d, 0x33, 0x4d,
	0x6f, 0x20, 0x39, 0x73, 0x20, 0x86, 0x54, 0x88, 0x4e, 0x46, 0x92, 0x8d, 0x17, 0x2d, 0x10, 0x63,
	0xad, 0x49, 0xff, 0xb7, 0xa1, 0xf4, 0xf3, 0xbd, 0xee, 0xb8, 0x27, 0x6a, 0x12, 0x0f, 0x86, 0xd1,
	0xfb, 0x70, 0xb2, 0x61, 0x38, 0xb2, 0x6e, 0x9a, 0xbb, 0x1d, 0x4b, 0x6e, 0x2a, 0x6d, 0x4d, 0x3f,
	0xe0, 0xe3, 0xac, 0xc6, 0xcd, 0x80, 0x1a, 0x79, 0xc3, 0x29, 0xb2, 0x74, 0xf6, 0xf4, 0x27, 0x7d,
	0x4f, 0x34, 0xfc, 0xc0, 0x3a, 0xa3, 0x41, 0x32, 0x44, 0x94, 0xbb, 0xa1, 0x39, 0xaa, 0xb9, 0x87,
	0xed, 0x03, 0x99, 0xbe, 0x83, 0xf0, 0x09, 0x46, 0xfe, 0xfd, 0x60, 0xf2, 0xbc, 0x9f, 0x3f, 0xc0,
	0xcf, 0x35, 0x06, 0x62, 0xe8, 0x31, 0x8c, 0xd1, 0xa6, 0x64, 0xfd, 0xd7, 0x13, 0x9e, 0xfb, 0xc6,
	0xdd, 0x1f, 0x26, 0xcb, 0xe2, 0x04, 0xe5, 0x7f, 0xe9, 0xd7, 0x98, 0x60, 0x7c, 0xbe, 0x64, 0x3f,
	0x80, 0xc8, 0x30, 0x65, 0x4b, 0x31, 0x34, 0x55, 0x26, 0x3b, 0x36, 0x76, 0x76, 0x4c, 0xbd, 0xc1,
	0x23, 0x56, 0x64, 0x6a, 0xa0, 0x48, 0xa1, 0x6d, 0x51, 0x47, 0xa4, 0x6c, 0x9b, 0x21, 0x89, 0x33,
	0xcc, 0x0a, 0x85, 0xd5, 0x7c, 0x14, 0x5a, 0x81, 0x89, 0x41, 0xa2, 0x2b, 0xee, 0x0b, 0x07, 0x85,
	0x1c, 0xbf, 0x70, 0x6c, 0x86, 0xa4, 0xb8, 0xd5, 0x87, 0x9c, 0x79, 0x1b, 0xa2, 0xd3, 0xe7, 0x1c,
	0x71, 0x70, 0x64, 0x17, 0xbb, 0x46, 0x3d, 0x26, 0xd1, 0x8f, 0x68, 0x0a, 0x8e, 0xee, 0x29, 0x7a,
	0x07, 0x33, 0xcb, 0x1d, 0x93, 0xdc, 0x8b, 0xd5, 0xf0, 0x0a, 0x58, 0xfd, 0x0d, 0xf8, 0xfc, 0x10,
	0xfc, 0x0a, 0xc0, 0x24, 0xbc, 0x5e, 0xb6, 0xb5, 0x96, 0x66, 0xa4, 0xaa, 0xd8, 0xde, 0xc3, 0xb6,
	0x73, 0xcb, 0x9f, 0x17, 0xe7, 0x36, 0x02, 0x19, 0xb8, 0x0a, 0x53, 0x5e, 0xbc, 0x62, 0x9a, 0xfa,
	0x2d, 0x6f, 0xdf, 0x6e, 0xa7, 0x4e, 0x4e, 0x5e, 0x0a, 0x5d, 0x5d, 0x14, 0xb2, 0x42, 0x66, 0x51,
	0x58, 0x11, 0xee, 0x09, 0x99, 0x3b, 0x42, 0x66, 0x49, 0xc8, 0x2c, 0x0b, 0x99, 0xbb, 0x90, 0x87,
	0x9c, 0x27, 0xb4, 0x29, 0x4f, 0x53, 0x1d, 0x14, 0x59, 0x12, 0x32, 0x59, 0x78, 0x1d, 0x72, 0x7e,
	0x99, 0x94, 0x2f, 0x7c, 0xa3, 0xcb, 0xc2, 0x5d, 0xe1, 0x4d, 0x71, 0x1e, 0x4e, 0x0d, 0x6c, 0x0a,
	0x9b, 0x11, 0x34, 0x7d, 0x74, 0x08, 0xd0, 0x17, 0xae, 0x88, 0x4e, 0x76, 0x0f, 0xc1, 0x68, 0x66,
	0x45, 0xc8, 0xdc, 0x7b, 0x10, 0x89, 0x8e, 0x73, 0x13, 0x0f, 0x22, 0xd1, 0x49, 0x0e, 0xcd, 0xfe,
	0x11, 0xc2, 0xf8, 0x9a, 0x8d, 0x15, 0x82, 0x8f, 0x4d, 0x73, 0xe3, 0x55, 0x4d, 0x73, 0xbc, 0xc7,
	0x34, 0x7b, 0xad, 0xf2, 0xd1, 0xff, 0x63, 0x95, 0xf1, 0x7e, 0xab, 0x1c, 0x30, 0x48, 0xf5, 0x3c,
	0x0d, 0x32, 0xc8, 0x1a, 0x4b, 0x67, 0xb3, 0xc6, 0x53, 0xa6, 0xf8, 0xc1, 0x39, 0x9a, 0xe2, 0x69,
	0xf3, 0x93, 0x5f, 0xd1, 0xfb, 0xfa, 0xbb, 0x3d, 0xc4, 0xfb, 0x06, 0x8d, 0xad, 0x76, 0x1e, 0xc6,
	0x76, 0xca, 0xce, 0x1e, 0x9e, 0xc5, 0xce, 0x06, 0x8d, 0x6c, 0x3e, 0xd8, 0xc8, 0x86, 0x79, 0xd6,
	0x5c, 0xa0, 0x67, 0x9d, 0xb6, 0xa7, 0x1f, 0x9e, 0x8f, 0x3d, 0x0d, 0x31, 0xa6, 0x1f, 0x9f, 0x9f,
	0x31, 0x0d, 0xb3, 0xa4, 0xca, 0xd9, 0x55, 0x7d, 0x40, 0xc7, 0xf3, 0xaf, 0xaa, 0xe3, 0x43, 0x15,
	0xfc, 0x76, 0x80, 0x82, 0x7f, 0x2b, 0x92, 0x9d, 0xfe, 0xcb, 0xfd, 0x81, 0xef, 0x04, 0x5f, 0xdf,
	0x9f, 0x71, 0xbf, 0x64, 0xac, 0x50, 0xf9, 0x65, 0xe2, 0xbb, 0x24, 0x30, 0x19, 0x15, 0x32, 0x59,
	0xf1, 0x4e, 0x80, 0x92, 0xf2, 0x1f, 0xff, 0x1b, 0x0c, 0x8d, 0x78, 0x32, 0xfa, 0x67, 0x08, 0x13,
	0x12, 0xb6, 0x74, 0x45, 0xbd, 0xd0, 0xd1, 0xef, 0xa8, 0x8e, 0xfe, 0x24, 0x40, 0x47, 0xef, 0x05,
	0x70, 0x0f, 0xb4, 0xfb, 0x42, 0x48, 0x2f, 0x84, 0xf4, 0x42, 0x48, 0xcf, 0x2c, 0xa4, 0x7f, 0x80,
	0x70, 0x7c, 0x03, 0x93, 0x0b, 0x11, 0xfd, 0x6e, 0x8a, 0xe8, 0x07, 0x01, 0x22, 0xba, 0x1c, 0xf4,
	0x43, 0xcc, 0x49, 0xab, 0x2f, 0x04, 0xf4, 0x42, 0x40, 0x2f, 0x04, 0xf4, 0xac, 0x02, 0x3a, 0xd7,
	0x86, 0xd3, 0x43, 0xf5, 0x05, 0x25, 0xe0, 0xb8, 0x54, 0xde, 0x2e, 0xe5, 0x65, 0xa9, 0x2c, 0x6e,
	0x95, 0xb8, 0x10, 0x9a, 0x84, 0xb1, 0x62, 0x21, 0x57, 0xad, 0xc9, 0x52, 0xe1, 0xd1, 0x76, 0xa1,
	0x5a, 0xe3, 0x00, 0x8a, 0xc1, 0x31, 0x69, 0xab, 0xb4, 0x21, 0x6f, 0xe6, 0xaa, 0x9b, 0x5c, 0x18,
	0x41, 0x78, 0x49, 0xca, 0x95, 0xf2, 0xe5, 0x77, 0xb8, 0x11, 0x0a, 0x2f, 0x8a, 0x72, 0xf9, 0xdd,
	0x82, 0x24, 0x6d, 0xe5, 0x0b, 0x5c, 0x64, 0x26, 0x72, 0x74, 0x08, 0x22, 0x73, 0x8b, 0x90, 0x1b,
	0xfc, 0xad, 0x09, 0xc5, 0x21, 0xac, 0xd6, 0xa4, 0xad, 0xb5, 0x9a, 0x9c, 0x2f, 0x55, 0xb9, 0x10,
	0x83, 0x96, 0x37, 0xb6, 0xd6, 0x72, 0x45, 0x76, 0x03, 0xcc, 0x2d, 0xc2, 0x58, 0xdf, 0xaf, 0x5f,
	0x28, 0x0a, 0x23, 0xb9, 0xed, 0x5a, 0x99, 0x0b, 0xa1, 0x71, 0x78, 0xf9, 0xdd, 0x25, 0xb9, 0x5c,
	0x2a, 0xbe, 0xc7, 0x01, 0x76, 0x71, 0xd7, 0xbd, 0x08, 0xcf, 0xbd, 0x03, 0xa7, 0x86, 0x1d, 0x67,
	0xca, 0x5e, 0x2a, 0xcb, 0xeb, 0xb9, 0x62, 0x51, 0xcc, 0xad, 0x3d, 0xe4, 0x42, 0x88, 0x83, 0x13,
	0xb9, 0xd2, 0x7b, 0x72, 0xa1, 0x94, 0xaf, 0x94, 0xb7, 0x4a, 0x74, 0x59, 0x08, 0xc6, 0xf3, 0x85,
	0xf5, 0xdc, 0x76, 0xb1, 0x26, 0x57, 0xb7, 0xc5, 0x6a, 0xa1, 0xc6, 0x85, 0xe7, 0xb6, 0xe1, 0xb5,
	0x80, 0x11, 0xa6, 0x8c, 0xf9, 0x2d, 0xba, 0x02, 0x71, 0xbb, 0x56, 0xc8, 0x73, 0x21, 0xba, 0xa0,
	0x62, 0x99, 0x3e, 0xbe, 0xf7, 0x5c, 0x57, 0x60, 0xc2, 0xbd, 0xae, 0x48, 0x85, 0xf5, 0x82, 0x24,
	0x15, 0xf2, 0x5c, 0x98, 0xed, 0x47, 0x58, 0xfc, 0x39, 0x78, 0xfa, 0x3c, 0x19, 0x7a, 0xf6, 0x3c,
	0x19, 0x7a, 0xf9, 0x3c, 0x09, 0x9e, 0x74, 0x93, 0xe0, 0xb7, 0xdd, 0x24, 0xf8, 0xa2, 0x9b, 0x04,
	0x4f, 0xbb, 0x49, 0xf0, 0xac, 0x9b, 0x04, 0x5f, 0x75, 0x93, 0xe0, 0xef, 0xdd, 0x64, 0xe8, 0x65,
	0x37, 0x09, 0x7e, 0xf9, 0x22, 0x19, 0x3a, 0x7a, 0x91, 0x04, 0x4f, 0x5f, 0x24, 0x43, 0xcf, 0x5e,
	0x24, 0x43, 0xef, 0x3f, 0x6c, 0x99, 0xd6, 0x6e, 0x2b, 0xbd, 0x67, 0xea, 0x04, 0xdb, 0xb6, 0x92,
	0xee, 0x38, 0x0b, 0xec, 0x43, 0xd3, 0xb4, 0xdb, 0xf3, 0x96, 0x6d, 0xee, 0x69, 0x0d, 0x6c, 0xcf,
	0xfb, 0xe1, 0x05, 0xab, 0xde, 0x32, 0x17, 0xf0, 0x3e, 0xf1, 0xfe, 0x63, 0xec, 0xff, 0xa7, 0xb4,
	0x7e, 0x89, 0xfd, 0xcd, 0xb8, 0xf8, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01, 0x8c, 0x4c, 0x34,
	0x49, 0x1d, 0x00, 0x00,
}

func (x LoadbalancerAlgorithm) String() string {
	s, ok := LoadbalancerAlgorithm_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DnsDiscoveryType) String() string {
	s, ok := DnsDiscoveryType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DnsLookupType) String() string {
	s, ok := DnsLookupType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SubsetFallbackPolicy) String() string {
	s, ok := SubsetFallbackPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x EndpointSelectionPolicy) String() string {
	s, ok := EndpointSelectionPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *OutlierDetectionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OutlierDetectionType)
	if !ok {
		that2, ok := that.(OutlierDetectionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Consecutive_5Xx != that1.Consecutive_5Xx {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if this.BaseEjectionTime != that1.BaseEjectionTime {
		return false
	}
	if this.MaxEjectionPercent != that1.MaxEjectionPercent {
		return false
	}
	if this.ConsecutiveGatewayFailure != that1.ConsecutiveGatewayFailure {
		return false
	}
	return true
}
func (this *EndpointSubsetSelectorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EndpointSubsetSelectorType)
	if !ok {
		that2, ok := that.(EndpointSubsetSelectorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	return true
}
func (this *CircuitBreaker) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CircuitBreaker)
	if !ok {
		that2, ok := that.(CircuitBreaker)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.ConnectionLimit != that1.ConnectionLimit {
		return false
	}
	if this.PendingRequests != that1.PendingRequests {
		return false
	}
	if this.Retries != that1.Retries {
		return false
	}
	if this.MaxRequests != that1.MaxRequests {
		return false
	}
	return true
}
func (this *Http2ProtocolOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Http2ProtocolOptions)
	if !ok {
		that2, ok := that.(Http2ProtocolOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	if len(this.HealthChecks) != len(that1.HealthChecks) {
		return false
	}
	for i := range this.HealthChecks {
		if !this.HealthChecks[i].Equal(that1.HealthChecks[i]) {
			return false
		}
	}
	if this.LoadbalancerAlgorithm != that1.LoadbalancerAlgorithm {
		return false
	}
	if !this.CircuitBreaker.Equal(that1.CircuitBreaker) {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if !this.EndpointSubsets[i].Equal(that1.EndpointSubsets[i]) {
			return false
		}
	}
	if len(this.DefaultSubset) != len(that1.DefaultSubset) {
		return false
	}
	for i := range this.DefaultSubset {
		if this.DefaultSubset[i] != that1.DefaultSubset[i] {
			return false
		}
	}
	if this.FallbackPolicy != that1.FallbackPolicy {
		return false
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if this.ConnectionTimeout != that1.ConnectionTimeout {
		return false
	}
	if this.HttpIdleTimeout != that1.HttpIdleTimeout {
		return false
	}
	if !this.OutlierDetection.Equal(that1.OutlierDetection) {
		return false
	}
	if this.EndpointSelection != that1.EndpointSelection {
		return false
	}
	if this.DnsLookupFamily != that1.DnsLookupFamily {
		return false
	}
	if this.DnsDiscoveryType != that1.DnsDiscoveryType {
		return false
	}
	if !this.Http2Options.Equal(that1.Http2Options) {
		return false
	}
	if that1.PanicThresholdType == nil {
		if this.PanicThresholdType != nil {
			return false
		}
	} else if this.PanicThresholdType == nil {
		return false
	} else if !this.PanicThresholdType.Equal(that1.PanicThresholdType) {
		return false
	}
	return true
}
func (this *GlobalSpecType_NoPanicThreshold) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_NoPanicThreshold)
	if !ok {
		that2, ok := that.(GlobalSpecType_NoPanicThreshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoPanicThreshold.Equal(that1.NoPanicThreshold) {
		return false
	}
	return true
}
func (this *GlobalSpecType_PanicThreshold) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PanicThreshold)
	if !ok {
		that2, ok := that.(GlobalSpecType_PanicThreshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PanicThreshold != that1.PanicThreshold {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	if len(this.HealthChecks) != len(that1.HealthChecks) {
		return false
	}
	for i := range this.HealthChecks {
		if !this.HealthChecks[i].Equal(that1.HealthChecks[i]) {
			return false
		}
	}
	if this.LoadbalancerAlgorithm != that1.LoadbalancerAlgorithm {
		return false
	}
	if !this.CircuitBreaker.Equal(that1.CircuitBreaker) {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if !this.EndpointSubsets[i].Equal(that1.EndpointSubsets[i]) {
			return false
		}
	}
	if len(this.DefaultSubset) != len(that1.DefaultSubset) {
		return false
	}
	for i := range this.DefaultSubset {
		if this.DefaultSubset[i] != that1.DefaultSubset[i] {
			return false
		}
	}
	if this.FallbackPolicy != that1.FallbackPolicy {
		return false
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if this.ConnectionTimeout != that1.ConnectionTimeout {
		return false
	}
	if this.HttpIdleTimeout != that1.HttpIdleTimeout {
		return false
	}
	if !this.OutlierDetection.Equal(that1.OutlierDetection) {
		return false
	}
	if this.EndpointSelection != that1.EndpointSelection {
		return false
	}
	if !this.Http2Options.Equal(that1.Http2Options) {
		return false
	}
	if that1.PanicThresholdType == nil {
		if this.PanicThresholdType != nil {
			return false
		}
	} else if this.PanicThresholdType == nil {
		return false
	} else if !this.PanicThresholdType.Equal(that1.PanicThresholdType) {
		return false
	}
	return true
}
func (this *CreateSpecType_NoPanicThreshold) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_NoPanicThreshold)
	if !ok {
		that2, ok := that.(CreateSpecType_NoPanicThreshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoPanicThreshold.Equal(that1.NoPanicThreshold) {
		return false
	}
	return true
}
func (this *CreateSpecType_PanicThreshold) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_PanicThreshold)
	if !ok {
		that2, ok := that.(CreateSpecType_PanicThreshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PanicThreshold != that1.PanicThreshold {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	if len(this.HealthChecks) != len(that1.HealthChecks) {
		return false
	}
	for i := range this.HealthChecks {
		if !this.HealthChecks[i].Equal(that1.HealthChecks[i]) {
			return false
		}
	}
	if this.LoadbalancerAlgorithm != that1.LoadbalancerAlgorithm {
		return false
	}
	if !this.CircuitBreaker.Equal(that1.CircuitBreaker) {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if !this.EndpointSubsets[i].Equal(that1.EndpointSubsets[i]) {
			return false
		}
	}
	if len(this.DefaultSubset) != len(that1.DefaultSubset) {
		return false
	}
	for i := range this.DefaultSubset {
		if this.DefaultSubset[i] != that1.DefaultSubset[i] {
			return false
		}
	}
	if this.FallbackPolicy != that1.FallbackPolicy {
		return false
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if this.ConnectionTimeout != that1.ConnectionTimeout {
		return false
	}
	if this.HttpIdleTimeout != that1.HttpIdleTimeout {
		return false
	}
	if !this.OutlierDetection.Equal(that1.OutlierDetection) {
		return false
	}
	if this.EndpointSelection != that1.EndpointSelection {
		return false
	}
	if !this.Http2Options.Equal(that1.Http2Options) {
		return false
	}
	if that1.PanicThresholdType == nil {
		if this.PanicThresholdType != nil {
			return false
		}
	} else if this.PanicThresholdType == nil {
		return false
	} else if !this.PanicThresholdType.Equal(that1.PanicThresholdType) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_NoPanicThreshold) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_NoPanicThreshold)
	if !ok {
		that2, ok := that.(ReplaceSpecType_NoPanicThreshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoPanicThreshold.Equal(that1.NoPanicThreshold) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_PanicThreshold) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_PanicThreshold)
	if !ok {
		that2, ok := that.(ReplaceSpecType_PanicThreshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PanicThreshold != that1.PanicThreshold {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	if len(this.HealthChecks) != len(that1.HealthChecks) {
		return false
	}
	for i := range this.HealthChecks {
		if !this.HealthChecks[i].Equal(that1.HealthChecks[i]) {
			return false
		}
	}
	if this.LoadbalancerAlgorithm != that1.LoadbalancerAlgorithm {
		return false
	}
	if !this.CircuitBreaker.Equal(that1.CircuitBreaker) {
		return false
	}
	if len(this.EndpointSubsets) != len(that1.EndpointSubsets) {
		return false
	}
	for i := range this.EndpointSubsets {
		if !this.EndpointSubsets[i].Equal(that1.EndpointSubsets[i]) {
			return false
		}
	}
	if len(this.DefaultSubset) != len(that1.DefaultSubset) {
		return false
	}
	for i := range this.DefaultSubset {
		if this.DefaultSubset[i] != that1.DefaultSubset[i] {
			return false
		}
	}
	if this.FallbackPolicy != that1.FallbackPolicy {
		return false
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	if this.ConnectionTimeout != that1.ConnectionTimeout {
		return false
	}
	if this.HttpIdleTimeout != that1.HttpIdleTimeout {
		return false
	}
	if !this.OutlierDetection.Equal(that1.OutlierDetection) {
		return false
	}
	if this.EndpointSelection != that1.EndpointSelection {
		return false
	}
	if !this.Http2Options.Equal(that1.Http2Options) {
		return false
	}
	if that1.PanicThresholdType == nil {
		if this.PanicThresholdType != nil {
			return false
		}
	} else if this.PanicThresholdType == nil {
		return false
	} else if !this.PanicThresholdType.Equal(that1.PanicThresholdType) {
		return false
	}
	return true
}
func (this *GetSpecType_NoPanicThreshold) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_NoPanicThreshold)
	if !ok {
		that2, ok := that.(GetSpecType_NoPanicThreshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoPanicThreshold.Equal(that1.NoPanicThreshold) {
		return false
	}
	return true
}
func (this *GetSpecType_PanicThreshold) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_PanicThreshold)
	if !ok {
		that2, ok := that.(GetSpecType_PanicThreshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PanicThreshold != that1.PanicThreshold {
		return false
	}
	return true
}
func (this *OutlierDetectionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cluster.OutlierDetectionType{")
	s = append(s, "Consecutive_5Xx: "+fmt.Sprintf("%#v", this.Consecutive_5Xx)+",\n")
	s = append(s, "Interval: "+fmt.Sprintf("%#v", this.Interval)+",\n")
	s = append(s, "BaseEjectionTime: "+fmt.Sprintf("%#v", this.BaseEjectionTime)+",\n")
	s = append(s, "MaxEjectionPercent: "+fmt.Sprintf("%#v", this.MaxEjectionPercent)+",\n")
	s = append(s, "ConsecutiveGatewayFailure: "+fmt.Sprintf("%#v", this.ConsecutiveGatewayFailure)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EndpointSubsetSelectorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cluster.EndpointSubsetSelectorType{")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CircuitBreaker) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cluster.CircuitBreaker{")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "ConnectionLimit: "+fmt.Sprintf("%#v", this.ConnectionLimit)+",\n")
	s = append(s, "PendingRequests: "+fmt.Sprintf("%#v", this.PendingRequests)+",\n")
	s = append(s, "Retries: "+fmt.Sprintf("%#v", this.Retries)+",\n")
	s = append(s, "MaxRequests: "+fmt.Sprintf("%#v", this.MaxRequests)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Http2ProtocolOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cluster.Http2ProtocolOptions{")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&cluster.GlobalSpecType{")
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+fmt.Sprintf("%#v", this.Endpoints)+",\n")
	}
	if this.HealthChecks != nil {
		s = append(s, "HealthChecks: "+fmt.Sprintf("%#v", this.HealthChecks)+",\n")
	}
	s = append(s, "LoadbalancerAlgorithm: "+fmt.Sprintf("%#v", this.LoadbalancerAlgorithm)+",\n")
	if this.CircuitBreaker != nil {
		s = append(s, "CircuitBreaker: "+fmt.Sprintf("%#v", this.CircuitBreaker)+",\n")
	}
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+fmt.Sprintf("%#v", this.EndpointSubsets)+",\n")
	}
	keysForDefaultSubset := make([]string, 0, len(this.DefaultSubset))
	for k, _ := range this.DefaultSubset {
		keysForDefaultSubset = append(keysForDefaultSubset, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
	mapStringForDefaultSubset := "map[string]string{"
	for _, k := range keysForDefaultSubset {
		mapStringForDefaultSubset += fmt.Sprintf("%#v: %#v,", k, this.DefaultSubset[k])
	}
	mapStringForDefaultSubset += "}"
	if this.DefaultSubset != nil {
		s = append(s, "DefaultSubset: "+mapStringForDefaultSubset+",\n")
	}
	s = append(s, "FallbackPolicy: "+fmt.Sprintf("%#v", this.FallbackPolicy)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "ConnectionTimeout: "+fmt.Sprintf("%#v", this.ConnectionTimeout)+",\n")
	s = append(s, "HttpIdleTimeout: "+fmt.Sprintf("%#v", this.HttpIdleTimeout)+",\n")
	if this.OutlierDetection != nil {
		s = append(s, "OutlierDetection: "+fmt.Sprintf("%#v", this.OutlierDetection)+",\n")
	}
	s = append(s, "EndpointSelection: "+fmt.Sprintf("%#v", this.EndpointSelection)+",\n")
	s = append(s, "DnsLookupFamily: "+fmt.Sprintf("%#v", this.DnsLookupFamily)+",\n")
	s = append(s, "DnsDiscoveryType: "+fmt.Sprintf("%#v", this.DnsDiscoveryType)+",\n")
	if this.Http2Options != nil {
		s = append(s, "Http2Options: "+fmt.Sprintf("%#v", this.Http2Options)+",\n")
	}
	if this.PanicThresholdType != nil {
		s = append(s, "PanicThresholdType: "+fmt.Sprintf("%#v", this.PanicThresholdType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_NoPanicThreshold) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cluster.GlobalSpecType_NoPanicThreshold{` +
		`NoPanicThreshold:` + fmt.Sprintf("%#v", this.NoPanicThreshold) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_PanicThreshold) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cluster.GlobalSpecType_PanicThreshold{` +
		`PanicThreshold:` + fmt.Sprintf("%#v", this.PanicThreshold) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&cluster.CreateSpecType{")
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+fmt.Sprintf("%#v", this.Endpoints)+",\n")
	}
	if this.HealthChecks != nil {
		s = append(s, "HealthChecks: "+fmt.Sprintf("%#v", this.HealthChecks)+",\n")
	}
	s = append(s, "LoadbalancerAlgorithm: "+fmt.Sprintf("%#v", this.LoadbalancerAlgorithm)+",\n")
	if this.CircuitBreaker != nil {
		s = append(s, "CircuitBreaker: "+fmt.Sprintf("%#v", this.CircuitBreaker)+",\n")
	}
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+fmt.Sprintf("%#v", this.EndpointSubsets)+",\n")
	}
	keysForDefaultSubset := make([]string, 0, len(this.DefaultSubset))
	for k, _ := range this.DefaultSubset {
		keysForDefaultSubset = append(keysForDefaultSubset, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
	mapStringForDefaultSubset := "map[string]string{"
	for _, k := range keysForDefaultSubset {
		mapStringForDefaultSubset += fmt.Sprintf("%#v: %#v,", k, this.DefaultSubset[k])
	}
	mapStringForDefaultSubset += "}"
	if this.DefaultSubset != nil {
		s = append(s, "DefaultSubset: "+mapStringForDefaultSubset+",\n")
	}
	s = append(s, "FallbackPolicy: "+fmt.Sprintf("%#v", this.FallbackPolicy)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "ConnectionTimeout: "+fmt.Sprintf("%#v", this.ConnectionTimeout)+",\n")
	s = append(s, "HttpIdleTimeout: "+fmt.Sprintf("%#v", this.HttpIdleTimeout)+",\n")
	if this.OutlierDetection != nil {
		s = append(s, "OutlierDetection: "+fmt.Sprintf("%#v", this.OutlierDetection)+",\n")
	}
	s = append(s, "EndpointSelection: "+fmt.Sprintf("%#v", this.EndpointSelection)+",\n")
	if this.Http2Options != nil {
		s = append(s, "Http2Options: "+fmt.Sprintf("%#v", this.Http2Options)+",\n")
	}
	if this.PanicThresholdType != nil {
		s = append(s, "PanicThresholdType: "+fmt.Sprintf("%#v", this.PanicThresholdType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_NoPanicThreshold) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cluster.CreateSpecType_NoPanicThreshold{` +
		`NoPanicThreshold:` + fmt.Sprintf("%#v", this.NoPanicThreshold) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_PanicThreshold) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cluster.CreateSpecType_PanicThreshold{` +
		`PanicThreshold:` + fmt.Sprintf("%#v", this.PanicThreshold) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&cluster.ReplaceSpecType{")
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+fmt.Sprintf("%#v", this.Endpoints)+",\n")
	}
	if this.HealthChecks != nil {
		s = append(s, "HealthChecks: "+fmt.Sprintf("%#v", this.HealthChecks)+",\n")
	}
	s = append(s, "LoadbalancerAlgorithm: "+fmt.Sprintf("%#v", this.LoadbalancerAlgorithm)+",\n")
	if this.CircuitBreaker != nil {
		s = append(s, "CircuitBreaker: "+fmt.Sprintf("%#v", this.CircuitBreaker)+",\n")
	}
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+fmt.Sprintf("%#v", this.EndpointSubsets)+",\n")
	}
	keysForDefaultSubset := make([]string, 0, len(this.DefaultSubset))
	for k, _ := range this.DefaultSubset {
		keysForDefaultSubset = append(keysForDefaultSubset, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
	mapStringForDefaultSubset := "map[string]string{"
	for _, k := range keysForDefaultSubset {
		mapStringForDefaultSubset += fmt.Sprintf("%#v: %#v,", k, this.DefaultSubset[k])
	}
	mapStringForDefaultSubset += "}"
	if this.DefaultSubset != nil {
		s = append(s, "DefaultSubset: "+mapStringForDefaultSubset+",\n")
	}
	s = append(s, "FallbackPolicy: "+fmt.Sprintf("%#v", this.FallbackPolicy)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "ConnectionTimeout: "+fmt.Sprintf("%#v", this.ConnectionTimeout)+",\n")
	s = append(s, "HttpIdleTimeout: "+fmt.Sprintf("%#v", this.HttpIdleTimeout)+",\n")
	if this.OutlierDetection != nil {
		s = append(s, "OutlierDetection: "+fmt.Sprintf("%#v", this.OutlierDetection)+",\n")
	}
	s = append(s, "EndpointSelection: "+fmt.Sprintf("%#v", this.EndpointSelection)+",\n")
	if this.Http2Options != nil {
		s = append(s, "Http2Options: "+fmt.Sprintf("%#v", this.Http2Options)+",\n")
	}
	if this.PanicThresholdType != nil {
		s = append(s, "PanicThresholdType: "+fmt.Sprintf("%#v", this.PanicThresholdType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_NoPanicThreshold) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cluster.ReplaceSpecType_NoPanicThreshold{` +
		`NoPanicThreshold:` + fmt.Sprintf("%#v", this.NoPanicThreshold) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_PanicThreshold) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cluster.ReplaceSpecType_PanicThreshold{` +
		`PanicThreshold:` + fmt.Sprintf("%#v", this.PanicThreshold) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&cluster.GetSpecType{")
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+fmt.Sprintf("%#v", this.Endpoints)+",\n")
	}
	if this.HealthChecks != nil {
		s = append(s, "HealthChecks: "+fmt.Sprintf("%#v", this.HealthChecks)+",\n")
	}
	s = append(s, "LoadbalancerAlgorithm: "+fmt.Sprintf("%#v", this.LoadbalancerAlgorithm)+",\n")
	if this.CircuitBreaker != nil {
		s = append(s, "CircuitBreaker: "+fmt.Sprintf("%#v", this.CircuitBreaker)+",\n")
	}
	if this.EndpointSubsets != nil {
		s = append(s, "EndpointSubsets: "+fmt.Sprintf("%#v", this.EndpointSubsets)+",\n")
	}
	keysForDefaultSubset := make([]string, 0, len(this.DefaultSubset))
	for k, _ := range this.DefaultSubset {
		keysForDefaultSubset = append(keysForDefaultSubset, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
	mapStringForDefaultSubset := "map[string]string{"
	for _, k := range keysForDefaultSubset {
		mapStringForDefaultSubset += fmt.Sprintf("%#v: %#v,", k, this.DefaultSubset[k])
	}
	mapStringForDefaultSubset += "}"
	if this.DefaultSubset != nil {
		s = append(s, "DefaultSubset: "+mapStringForDefaultSubset+",\n")
	}
	s = append(s, "FallbackPolicy: "+fmt.Sprintf("%#v", this.FallbackPolicy)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "ConnectionTimeout: "+fmt.Sprintf("%#v", this.ConnectionTimeout)+",\n")
	s = append(s, "HttpIdleTimeout: "+fmt.Sprintf("%#v", this.HttpIdleTimeout)+",\n")
	if this.OutlierDetection != nil {
		s = append(s, "OutlierDetection: "+fmt.Sprintf("%#v", this.OutlierDetection)+",\n")
	}
	s = append(s, "EndpointSelection: "+fmt.Sprintf("%#v", this.EndpointSelection)+",\n")
	if this.Http2Options != nil {
		s = append(s, "Http2Options: "+fmt.Sprintf("%#v", this.Http2Options)+",\n")
	}
	if this.PanicThresholdType != nil {
		s = append(s, "PanicThresholdType: "+fmt.Sprintf("%#v", this.PanicThresholdType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_NoPanicThreshold) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cluster.GetSpecType_NoPanicThreshold{` +
		`NoPanicThreshold:` + fmt.Sprintf("%#v", this.NoPanicThreshold) + `}`}, ", ")
	return s
}
func (this *GetSpecType_PanicThreshold) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cluster.GetSpecType_PanicThreshold{` +
		`PanicThreshold:` + fmt.Sprintf("%#v", this.PanicThreshold) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *OutlierDetectionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutlierDetectionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutlierDetectionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConsecutiveGatewayFailure != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConsecutiveGatewayFailure))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxEjectionPercent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxEjectionPercent))
		i--
		dAtA[i] = 0x20
	}
	if m.BaseEjectionTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BaseEjectionTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Interval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x10
	}
	if m.Consecutive_5Xx != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Consecutive_5Xx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EndpointSubsetSelectorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointSubsetSelectorType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointSubsetSelectorType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CircuitBreaker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CircuitBreaker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CircuitBreaker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRequests != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequests))
		i--
		dAtA[i] = 0x28
	}
	if m.Retries != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Retries))
		i--
		dAtA[i] = 0x20
	}
	if m.PendingRequests != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PendingRequests))
		i--
		dAtA[i] = 0x18
	}
	if m.ConnectionLimit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Http2ProtocolOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Http2ProtocolOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Http2ProtocolOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PanicThresholdType != nil {
		{
			size := m.PanicThresholdType.Size()
			i -= size
			if _, err := m.PanicThresholdType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Http2Options != nil {
		{
			size, err := m.Http2Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.DnsDiscoveryType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsDiscoveryType))
		i--
		dAtA[i] = 0x78
	}
	if m.DnsLookupFamily != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsLookupFamily))
		i--
		dAtA[i] = 0x70
	}
	if m.EndpointSelection != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EndpointSelection))
		i--
		dAtA[i] = 0x68
	}
	if m.OutlierDetection != nil {
		{
			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.HttpIdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpIdleTimeout))
		i--
		dAtA[i] = 0x50
	}
	if m.ConnectionTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionTimeout))
		i--
		dAtA[i] = 0x48
	}
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.FallbackPolicy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FallbackPolicy))
		i--
		dAtA[i] = 0x38
	}
	if len(m.DefaultSubset) > 0 {
		keysForDefaultSubset := make([]string, 0, len(m.DefaultSubset))
		for k := range m.DefaultSubset {
			keysForDefaultSubset = append(keysForDefaultSubset, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
		for iNdEx := len(keysForDefaultSubset) - 1; iNdEx >= 0; iNdEx-- {
			v := m.DefaultSubset[string(keysForDefaultSubset[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForDefaultSubset[iNdEx])
			copy(dAtA[i:], keysForDefaultSubset[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForDefaultSubset[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EndpointSubsets) > 0 {
		for iNdEx := len(m.EndpointSubsets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EndpointSubsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.CircuitBreaker != nil {
		{
			size, err := m.CircuitBreaker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LoadbalancerAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LoadbalancerAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HealthChecks) > 0 {
		for iNdEx := len(m.HealthChecks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HealthChecks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Endpoints) > 0 {
		for iNdEx := len(m.Endpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Endpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_NoPanicThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_NoPanicThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoPanicThreshold != nil {
		{
			size, err := m.NoPanicThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_PanicThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_PanicThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.PanicThreshold))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PanicThresholdType != nil {
		{
			size := m.PanicThresholdType.Size()
			i -= size
			if _, err := m.PanicThresholdType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Http2Options != nil {
		{
			size, err := m.Http2Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.EndpointSelection != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EndpointSelection))
		i--
		dAtA[i] = 0x68
	}
	if m.OutlierDetection != nil {
		{
			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.HttpIdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpIdleTimeout))
		i--
		dAtA[i] = 0x50
	}
	if m.ConnectionTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionTimeout))
		i--
		dAtA[i] = 0x48
	}
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.FallbackPolicy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FallbackPolicy))
		i--
		dAtA[i] = 0x38
	}
	if len(m.DefaultSubset) > 0 {
		keysForDefaultSubset := make([]string, 0, len(m.DefaultSubset))
		for k := range m.DefaultSubset {
			keysForDefaultSubset = append(keysForDefaultSubset, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
		for iNdEx := len(keysForDefaultSubset) - 1; iNdEx >= 0; iNdEx-- {
			v := m.DefaultSubset[string(keysForDefaultSubset[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForDefaultSubset[iNdEx])
			copy(dAtA[i:], keysForDefaultSubset[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForDefaultSubset[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EndpointSubsets) > 0 {
		for iNdEx := len(m.EndpointSubsets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EndpointSubsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.CircuitBreaker != nil {
		{
			size, err := m.CircuitBreaker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LoadbalancerAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LoadbalancerAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HealthChecks) > 0 {
		for iNdEx := len(m.HealthChecks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HealthChecks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Endpoints) > 0 {
		for iNdEx := len(m.Endpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Endpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_NoPanicThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_NoPanicThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoPanicThreshold != nil {
		{
			size, err := m.NoPanicThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_PanicThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_PanicThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.PanicThreshold))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PanicThresholdType != nil {
		{
			size := m.PanicThresholdType.Size()
			i -= size
			if _, err := m.PanicThresholdType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Http2Options != nil {
		{
			size, err := m.Http2Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.EndpointSelection != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EndpointSelection))
		i--
		dAtA[i] = 0x68
	}
	if m.OutlierDetection != nil {
		{
			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.HttpIdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpIdleTimeout))
		i--
		dAtA[i] = 0x50
	}
	if m.ConnectionTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionTimeout))
		i--
		dAtA[i] = 0x48
	}
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.FallbackPolicy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FallbackPolicy))
		i--
		dAtA[i] = 0x38
	}
	if len(m.DefaultSubset) > 0 {
		keysForDefaultSubset := make([]string, 0, len(m.DefaultSubset))
		for k := range m.DefaultSubset {
			keysForDefaultSubset = append(keysForDefaultSubset, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
		for iNdEx := len(keysForDefaultSubset) - 1; iNdEx >= 0; iNdEx-- {
			v := m.DefaultSubset[string(keysForDefaultSubset[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForDefaultSubset[iNdEx])
			copy(dAtA[i:], keysForDefaultSubset[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForDefaultSubset[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EndpointSubsets) > 0 {
		for iNdEx := len(m.EndpointSubsets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EndpointSubsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.CircuitBreaker != nil {
		{
			size, err := m.CircuitBreaker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LoadbalancerAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LoadbalancerAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HealthChecks) > 0 {
		for iNdEx := len(m.HealthChecks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HealthChecks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Endpoints) > 0 {
		for iNdEx := len(m.Endpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Endpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_NoPanicThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_NoPanicThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoPanicThreshold != nil {
		{
			size, err := m.NoPanicThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_PanicThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_PanicThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.PanicThreshold))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PanicThresholdType != nil {
		{
			size := m.PanicThresholdType.Size()
			i -= size
			if _, err := m.PanicThresholdType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Http2Options != nil {
		{
			size, err := m.Http2Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.EndpointSelection != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EndpointSelection))
		i--
		dAtA[i] = 0x68
	}
	if m.OutlierDetection != nil {
		{
			size, err := m.OutlierDetection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.HttpIdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpIdleTimeout))
		i--
		dAtA[i] = 0x50
	}
	if m.ConnectionTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionTimeout))
		i--
		dAtA[i] = 0x48
	}
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.FallbackPolicy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FallbackPolicy))
		i--
		dAtA[i] = 0x38
	}
	if len(m.DefaultSubset) > 0 {
		keysForDefaultSubset := make([]string, 0, len(m.DefaultSubset))
		for k := range m.DefaultSubset {
			keysForDefaultSubset = append(keysForDefaultSubset, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
		for iNdEx := len(keysForDefaultSubset) - 1; iNdEx >= 0; iNdEx-- {
			v := m.DefaultSubset[string(keysForDefaultSubset[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForDefaultSubset[iNdEx])
			copy(dAtA[i:], keysForDefaultSubset[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForDefaultSubset[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EndpointSubsets) > 0 {
		for iNdEx := len(m.EndpointSubsets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EndpointSubsets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.CircuitBreaker != nil {
		{
			size, err := m.CircuitBreaker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.LoadbalancerAlgorithm != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LoadbalancerAlgorithm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.HealthChecks) > 0 {
		for iNdEx := len(m.HealthChecks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HealthChecks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Endpoints) > 0 {
		for iNdEx := len(m.Endpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Endpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_NoPanicThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_NoPanicThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoPanicThreshold != nil {
		{
			size, err := m.NoPanicThreshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_PanicThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_PanicThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.PanicThreshold))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OutlierDetectionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Consecutive_5Xx != 0 {
		n += 1 + sovTypes(uint64(m.Consecutive_5Xx))
	}
	if m.Interval != 0 {
		n += 1 + sovTypes(uint64(m.Interval))
	}
	if m.BaseEjectionTime != 0 {
		n += 1 + sovTypes(uint64(m.BaseEjectionTime))
	}
	if m.MaxEjectionPercent != 0 {
		n += 1 + sovTypes(uint64(m.MaxEjectionPercent))
	}
	if m.ConsecutiveGatewayFailure != 0 {
		n += 1 + sovTypes(uint64(m.ConsecutiveGatewayFailure))
	}
	return n
}

func (m *EndpointSubsetSelectorType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CircuitBreaker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if m.ConnectionLimit != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionLimit))
	}
	if m.PendingRequests != 0 {
		n += 1 + sovTypes(uint64(m.PendingRequests))
	}
	if m.Retries != 0 {
		n += 1 + sovTypes(uint64(m.Retries))
	}
	if m.MaxRequests != 0 {
		n += 1 + sovTypes(uint64(m.MaxRequests))
	}
	return n
}

func (m *Http2ProtocolOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.HealthChecks) > 0 {
		for _, e := range m.HealthChecks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.LoadbalancerAlgorithm))
	}
	if m.CircuitBreaker != nil {
		l = m.CircuitBreaker.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EndpointSubsets) > 0 {
		for _, e := range m.EndpointSubsets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DefaultSubset) > 0 {
		for k, v := range m.DefaultSubset {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.FallbackPolicy != 0 {
		n += 1 + sovTypes(uint64(m.FallbackPolicy))
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ConnectionTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionTimeout))
	}
	if m.HttpIdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.HttpIdleTimeout))
	}
	if m.OutlierDetection != nil {
		l = m.OutlierDetection.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndpointSelection != 0 {
		n += 1 + sovTypes(uint64(m.EndpointSelection))
	}
	if m.DnsLookupFamily != 0 {
		n += 1 + sovTypes(uint64(m.DnsLookupFamily))
	}
	if m.DnsDiscoveryType != 0 {
		n += 1 + sovTypes(uint64(m.DnsDiscoveryType))
	}
	if m.Http2Options != nil {
		l = m.Http2Options.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.PanicThresholdType != nil {
		n += m.PanicThresholdType.Size()
	}
	return n
}

func (m *GlobalSpecType_NoPanicThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoPanicThreshold != nil {
		l = m.NoPanicThreshold.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_PanicThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovTypes(uint64(m.PanicThreshold))
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.HealthChecks) > 0 {
		for _, e := range m.HealthChecks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.LoadbalancerAlgorithm))
	}
	if m.CircuitBreaker != nil {
		l = m.CircuitBreaker.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EndpointSubsets) > 0 {
		for _, e := range m.EndpointSubsets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DefaultSubset) > 0 {
		for k, v := range m.DefaultSubset {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.FallbackPolicy != 0 {
		n += 1 + sovTypes(uint64(m.FallbackPolicy))
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ConnectionTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionTimeout))
	}
	if m.HttpIdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.HttpIdleTimeout))
	}
	if m.OutlierDetection != nil {
		l = m.OutlierDetection.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndpointSelection != 0 {
		n += 1 + sovTypes(uint64(m.EndpointSelection))
	}
	if m.Http2Options != nil {
		l = m.Http2Options.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.PanicThresholdType != nil {
		n += m.PanicThresholdType.Size()
	}
	return n
}

func (m *CreateSpecType_NoPanicThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoPanicThreshold != nil {
		l = m.NoPanicThreshold.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_PanicThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovTypes(uint64(m.PanicThreshold))
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.HealthChecks) > 0 {
		for _, e := range m.HealthChecks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.LoadbalancerAlgorithm))
	}
	if m.CircuitBreaker != nil {
		l = m.CircuitBreaker.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EndpointSubsets) > 0 {
		for _, e := range m.EndpointSubsets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DefaultSubset) > 0 {
		for k, v := range m.DefaultSubset {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.FallbackPolicy != 0 {
		n += 1 + sovTypes(uint64(m.FallbackPolicy))
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ConnectionTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionTimeout))
	}
	if m.HttpIdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.HttpIdleTimeout))
	}
	if m.OutlierDetection != nil {
		l = m.OutlierDetection.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndpointSelection != 0 {
		n += 1 + sovTypes(uint64(m.EndpointSelection))
	}
	if m.Http2Options != nil {
		l = m.Http2Options.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.PanicThresholdType != nil {
		n += m.PanicThresholdType.Size()
	}
	return n
}

func (m *ReplaceSpecType_NoPanicThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoPanicThreshold != nil {
		l = m.NoPanicThreshold.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_PanicThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovTypes(uint64(m.PanicThreshold))
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.HealthChecks) > 0 {
		for _, e := range m.HealthChecks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerAlgorithm != 0 {
		n += 1 + sovTypes(uint64(m.LoadbalancerAlgorithm))
	}
	if m.CircuitBreaker != nil {
		l = m.CircuitBreaker.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EndpointSubsets) > 0 {
		for _, e := range m.EndpointSubsets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DefaultSubset) > 0 {
		for k, v := range m.DefaultSubset {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.FallbackPolicy != 0 {
		n += 1 + sovTypes(uint64(m.FallbackPolicy))
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ConnectionTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionTimeout))
	}
	if m.HttpIdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.HttpIdleTimeout))
	}
	if m.OutlierDetection != nil {
		l = m.OutlierDetection.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndpointSelection != 0 {
		n += 1 + sovTypes(uint64(m.EndpointSelection))
	}
	if m.Http2Options != nil {
		l = m.Http2Options.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.PanicThresholdType != nil {
		n += m.PanicThresholdType.Size()
	}
	return n
}

func (m *GetSpecType_NoPanicThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoPanicThreshold != nil {
		l = m.NoPanicThreshold.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_PanicThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovTypes(uint64(m.PanicThreshold))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *OutlierDetectionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OutlierDetectionType{`,
		`Consecutive_5Xx:` + fmt.Sprintf("%v", this.Consecutive_5Xx) + `,`,
		`Interval:` + fmt.Sprintf("%v", this.Interval) + `,`,
		`BaseEjectionTime:` + fmt.Sprintf("%v", this.BaseEjectionTime) + `,`,
		`MaxEjectionPercent:` + fmt.Sprintf("%v", this.MaxEjectionPercent) + `,`,
		`ConsecutiveGatewayFailure:` + fmt.Sprintf("%v", this.ConsecutiveGatewayFailure) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndpointSubsetSelectorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndpointSubsetSelectorType{`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CircuitBreaker) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CircuitBreaker{`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`ConnectionLimit:` + fmt.Sprintf("%v", this.ConnectionLimit) + `,`,
		`PendingRequests:` + fmt.Sprintf("%v", this.PendingRequests) + `,`,
		`Retries:` + fmt.Sprintf("%v", this.Retries) + `,`,
		`MaxRequests:` + fmt.Sprintf("%v", this.MaxRequests) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Http2ProtocolOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Http2ProtocolOptions{`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEndpoints := "[]*ObjectRefType{"
	for _, f := range this.Endpoints {
		repeatedStringForEndpoints += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForEndpoints += "}"
	repeatedStringForHealthChecks := "[]*ObjectRefType{"
	for _, f := range this.HealthChecks {
		repeatedStringForHealthChecks += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForHealthChecks += "}"
	repeatedStringForEndpointSubsets := "[]*EndpointSubsetSelectorType{"
	for _, f := range this.EndpointSubsets {
		repeatedStringForEndpointSubsets += strings.Replace(f.String(), "EndpointSubsetSelectorType", "EndpointSubsetSelectorType", 1) + ","
	}
	repeatedStringForEndpointSubsets += "}"
	keysForDefaultSubset := make([]string, 0, len(this.DefaultSubset))
	for k, _ := range this.DefaultSubset {
		keysForDefaultSubset = append(keysForDefaultSubset, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
	mapStringForDefaultSubset := "map[string]string{"
	for _, k := range keysForDefaultSubset {
		mapStringForDefaultSubset += fmt.Sprintf("%v: %v,", k, this.DefaultSubset[k])
	}
	mapStringForDefaultSubset += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Endpoints:` + repeatedStringForEndpoints + `,`,
		`HealthChecks:` + repeatedStringForHealthChecks + `,`,
		`LoadbalancerAlgorithm:` + fmt.Sprintf("%v", this.LoadbalancerAlgorithm) + `,`,
		`CircuitBreaker:` + strings.Replace(this.CircuitBreaker.String(), "CircuitBreaker", "CircuitBreaker", 1) + `,`,
		`EndpointSubsets:` + repeatedStringForEndpointSubsets + `,`,
		`DefaultSubset:` + mapStringForDefaultSubset + `,`,
		`FallbackPolicy:` + fmt.Sprintf("%v", this.FallbackPolicy) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "UpstreamTlsParamsType", "schema.UpstreamTlsParamsType", 1) + `,`,
		`ConnectionTimeout:` + fmt.Sprintf("%v", this.ConnectionTimeout) + `,`,
		`HttpIdleTimeout:` + fmt.Sprintf("%v", this.HttpIdleTimeout) + `,`,
		`OutlierDetection:` + strings.Replace(this.OutlierDetection.String(), "OutlierDetectionType", "OutlierDetectionType", 1) + `,`,
		`EndpointSelection:` + fmt.Sprintf("%v", this.EndpointSelection) + `,`,
		`DnsLookupFamily:` + fmt.Sprintf("%v", this.DnsLookupFamily) + `,`,
		`DnsDiscoveryType:` + fmt.Sprintf("%v", this.DnsDiscoveryType) + `,`,
		`Http2Options:` + strings.Replace(this.Http2Options.String(), "Http2ProtocolOptions", "Http2ProtocolOptions", 1) + `,`,
		`PanicThresholdType:` + fmt.Sprintf("%v", this.PanicThresholdType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_NoPanicThreshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_NoPanicThreshold{`,
		`NoPanicThreshold:` + strings.Replace(fmt.Sprintf("%v", this.NoPanicThreshold), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PanicThreshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PanicThreshold{`,
		`PanicThreshold:` + fmt.Sprintf("%v", this.PanicThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEndpoints := "[]*ObjectRefType{"
	for _, f := range this.Endpoints {
		repeatedStringForEndpoints += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForEndpoints += "}"
	repeatedStringForHealthChecks := "[]*ObjectRefType{"
	for _, f := range this.HealthChecks {
		repeatedStringForHealthChecks += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForHealthChecks += "}"
	repeatedStringForEndpointSubsets := "[]*EndpointSubsetSelectorType{"
	for _, f := range this.EndpointSubsets {
		repeatedStringForEndpointSubsets += strings.Replace(f.String(), "EndpointSubsetSelectorType", "EndpointSubsetSelectorType", 1) + ","
	}
	repeatedStringForEndpointSubsets += "}"
	keysForDefaultSubset := make([]string, 0, len(this.DefaultSubset))
	for k, _ := range this.DefaultSubset {
		keysForDefaultSubset = append(keysForDefaultSubset, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
	mapStringForDefaultSubset := "map[string]string{"
	for _, k := range keysForDefaultSubset {
		mapStringForDefaultSubset += fmt.Sprintf("%v: %v,", k, this.DefaultSubset[k])
	}
	mapStringForDefaultSubset += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`Endpoints:` + repeatedStringForEndpoints + `,`,
		`HealthChecks:` + repeatedStringForHealthChecks + `,`,
		`LoadbalancerAlgorithm:` + fmt.Sprintf("%v", this.LoadbalancerAlgorithm) + `,`,
		`CircuitBreaker:` + strings.Replace(this.CircuitBreaker.String(), "CircuitBreaker", "CircuitBreaker", 1) + `,`,
		`EndpointSubsets:` + repeatedStringForEndpointSubsets + `,`,
		`DefaultSubset:` + mapStringForDefaultSubset + `,`,
		`FallbackPolicy:` + fmt.Sprintf("%v", this.FallbackPolicy) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "UpstreamTlsParamsType", "schema.UpstreamTlsParamsType", 1) + `,`,
		`ConnectionTimeout:` + fmt.Sprintf("%v", this.ConnectionTimeout) + `,`,
		`HttpIdleTimeout:` + fmt.Sprintf("%v", this.HttpIdleTimeout) + `,`,
		`OutlierDetection:` + strings.Replace(this.OutlierDetection.String(), "OutlierDetectionType", "OutlierDetectionType", 1) + `,`,
		`EndpointSelection:` + fmt.Sprintf("%v", this.EndpointSelection) + `,`,
		`Http2Options:` + strings.Replace(this.Http2Options.String(), "Http2ProtocolOptions", "Http2ProtocolOptions", 1) + `,`,
		`PanicThresholdType:` + fmt.Sprintf("%v", this.PanicThresholdType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_NoPanicThreshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_NoPanicThreshold{`,
		`NoPanicThreshold:` + strings.Replace(fmt.Sprintf("%v", this.NoPanicThreshold), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_PanicThreshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_PanicThreshold{`,
		`PanicThreshold:` + fmt.Sprintf("%v", this.PanicThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEndpoints := "[]*ObjectRefType{"
	for _, f := range this.Endpoints {
		repeatedStringForEndpoints += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForEndpoints += "}"
	repeatedStringForHealthChecks := "[]*ObjectRefType{"
	for _, f := range this.HealthChecks {
		repeatedStringForHealthChecks += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForHealthChecks += "}"
	repeatedStringForEndpointSubsets := "[]*EndpointSubsetSelectorType{"
	for _, f := range this.EndpointSubsets {
		repeatedStringForEndpointSubsets += strings.Replace(f.String(), "EndpointSubsetSelectorType", "EndpointSubsetSelectorType", 1) + ","
	}
	repeatedStringForEndpointSubsets += "}"
	keysForDefaultSubset := make([]string, 0, len(this.DefaultSubset))
	for k, _ := range this.DefaultSubset {
		keysForDefaultSubset = append(keysForDefaultSubset, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
	mapStringForDefaultSubset := "map[string]string{"
	for _, k := range keysForDefaultSubset {
		mapStringForDefaultSubset += fmt.Sprintf("%v: %v,", k, this.DefaultSubset[k])
	}
	mapStringForDefaultSubset += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Endpoints:` + repeatedStringForEndpoints + `,`,
		`HealthChecks:` + repeatedStringForHealthChecks + `,`,
		`LoadbalancerAlgorithm:` + fmt.Sprintf("%v", this.LoadbalancerAlgorithm) + `,`,
		`CircuitBreaker:` + strings.Replace(this.CircuitBreaker.String(), "CircuitBreaker", "CircuitBreaker", 1) + `,`,
		`EndpointSubsets:` + repeatedStringForEndpointSubsets + `,`,
		`DefaultSubset:` + mapStringForDefaultSubset + `,`,
		`FallbackPolicy:` + fmt.Sprintf("%v", this.FallbackPolicy) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "UpstreamTlsParamsType", "schema.UpstreamTlsParamsType", 1) + `,`,
		`ConnectionTimeout:` + fmt.Sprintf("%v", this.ConnectionTimeout) + `,`,
		`HttpIdleTimeout:` + fmt.Sprintf("%v", this.HttpIdleTimeout) + `,`,
		`OutlierDetection:` + strings.Replace(this.OutlierDetection.String(), "OutlierDetectionType", "OutlierDetectionType", 1) + `,`,
		`EndpointSelection:` + fmt.Sprintf("%v", this.EndpointSelection) + `,`,
		`Http2Options:` + strings.Replace(this.Http2Options.String(), "Http2ProtocolOptions", "Http2ProtocolOptions", 1) + `,`,
		`PanicThresholdType:` + fmt.Sprintf("%v", this.PanicThresholdType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_NoPanicThreshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_NoPanicThreshold{`,
		`NoPanicThreshold:` + strings.Replace(fmt.Sprintf("%v", this.NoPanicThreshold), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_PanicThreshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_PanicThreshold{`,
		`PanicThreshold:` + fmt.Sprintf("%v", this.PanicThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEndpoints := "[]*ObjectRefType{"
	for _, f := range this.Endpoints {
		repeatedStringForEndpoints += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForEndpoints += "}"
	repeatedStringForHealthChecks := "[]*ObjectRefType{"
	for _, f := range this.HealthChecks {
		repeatedStringForHealthChecks += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForHealthChecks += "}"
	repeatedStringForEndpointSubsets := "[]*EndpointSubsetSelectorType{"
	for _, f := range this.EndpointSubsets {
		repeatedStringForEndpointSubsets += strings.Replace(f.String(), "EndpointSubsetSelectorType", "EndpointSubsetSelectorType", 1) + ","
	}
	repeatedStringForEndpointSubsets += "}"
	keysForDefaultSubset := make([]string, 0, len(this.DefaultSubset))
	for k, _ := range this.DefaultSubset {
		keysForDefaultSubset = append(keysForDefaultSubset, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDefaultSubset)
	mapStringForDefaultSubset := "map[string]string{"
	for _, k := range keysForDefaultSubset {
		mapStringForDefaultSubset += fmt.Sprintf("%v: %v,", k, this.DefaultSubset[k])
	}
	mapStringForDefaultSubset += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Endpoints:` + repeatedStringForEndpoints + `,`,
		`HealthChecks:` + repeatedStringForHealthChecks + `,`,
		`LoadbalancerAlgorithm:` + fmt.Sprintf("%v", this.LoadbalancerAlgorithm) + `,`,
		`CircuitBreaker:` + strings.Replace(this.CircuitBreaker.String(), "CircuitBreaker", "CircuitBreaker", 1) + `,`,
		`EndpointSubsets:` + repeatedStringForEndpointSubsets + `,`,
		`DefaultSubset:` + mapStringForDefaultSubset + `,`,
		`FallbackPolicy:` + fmt.Sprintf("%v", this.FallbackPolicy) + `,`,
		`TlsParameters:` + strings.Replace(fmt.Sprintf("%v", this.TlsParameters), "UpstreamTlsParamsType", "schema.UpstreamTlsParamsType", 1) + `,`,
		`ConnectionTimeout:` + fmt.Sprintf("%v", this.ConnectionTimeout) + `,`,
		`HttpIdleTimeout:` + fmt.Sprintf("%v", this.HttpIdleTimeout) + `,`,
		`OutlierDetection:` + strings.Replace(this.OutlierDetection.String(), "OutlierDetectionType", "OutlierDetectionType", 1) + `,`,
		`EndpointSelection:` + fmt.Sprintf("%v", this.EndpointSelection) + `,`,
		`Http2Options:` + strings.Replace(this.Http2Options.String(), "Http2ProtocolOptions", "Http2ProtocolOptions", 1) + `,`,
		`PanicThresholdType:` + fmt.Sprintf("%v", this.PanicThresholdType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_NoPanicThreshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_NoPanicThreshold{`,
		`NoPanicThreshold:` + strings.Replace(fmt.Sprintf("%v", this.NoPanicThreshold), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_PanicThreshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_PanicThreshold{`,
		`PanicThreshold:` + fmt.Sprintf("%v", this.PanicThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *OutlierDetectionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutlierDetectionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutlierDetectionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consecutive_5Xx", wireType)
			}
			m.Consecutive_5Xx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Consecutive_5Xx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseEjectionTime", wireType)
			}
			m.BaseEjectionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseEjectionTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEjectionPercent", wireType)
			}
			m.MaxEjectionPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEjectionPercent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveGatewayFailure", wireType)
			}
			m.ConsecutiveGatewayFailure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsecutiveGatewayFailure |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointSubsetSelectorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointSubsetSelectorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointSubsetSelectorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CircuitBreaker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CircuitBreaker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CircuitBreaker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= schema.RoutingPriority(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionLimit", wireType)
			}
			m.ConnectionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingRequests", wireType)
			}
			m.PendingRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingRequests |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequests", wireType)
			}
			m.MaxRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequests |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Http2ProtocolOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Http2ProtocolOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Http2ProtocolOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &schema.ObjectRefType{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthChecks = append(m.HealthChecks, &schema.ObjectRefType{})
			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerAlgorithm", wireType)
			}
			m.LoadbalancerAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadbalancerAlgorithm |= LoadbalancerAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreaker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreaker == nil {
				m.CircuitBreaker = &CircuitBreaker{}
			}
			if err := m.CircuitBreaker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSubsets = append(m.EndpointSubsets, &EndpointSubsetSelectorType{})
			if err := m.EndpointSubsets[len(m.EndpointSubsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSubset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultSubset == nil {
				m.DefaultSubset = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DefaultSubset[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPolicy", wireType)
			}
			m.FallbackPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FallbackPolicy |= SubsetFallbackPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &schema.UpstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionTimeout", wireType)
			}
			m.ConnectionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpIdleTimeout", wireType)
			}
			m.HttpIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpIdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutlierDetection == nil {
				m.OutlierDetection = &OutlierDetectionType{}
			}
			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSelection", wireType)
			}
			m.EndpointSelection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointSelection |= EndpointSelectionPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsLookupFamily", wireType)
			}
			m.DnsLookupFamily = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsLookupFamily |= DnsLookupType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsDiscoveryType", wireType)
			}
			m.DnsDiscoveryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsDiscoveryType |= DnsDiscoveryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http2Options == nil {
				m.Http2Options = &Http2ProtocolOptions{}
			}
			if err := m.Http2Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPanicThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PanicThresholdType = &GlobalSpecType_NoPanicThreshold{v}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PanicThreshold", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PanicThresholdType = &GlobalSpecType_PanicThreshold{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &schema.ObjectRefType{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthChecks = append(m.HealthChecks, &schema.ObjectRefType{})
			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerAlgorithm", wireType)
			}
			m.LoadbalancerAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadbalancerAlgorithm |= LoadbalancerAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreaker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreaker == nil {
				m.CircuitBreaker = &CircuitBreaker{}
			}
			if err := m.CircuitBreaker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSubsets = append(m.EndpointSubsets, &EndpointSubsetSelectorType{})
			if err := m.EndpointSubsets[len(m.EndpointSubsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSubset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultSubset == nil {
				m.DefaultSubset = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DefaultSubset[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPolicy", wireType)
			}
			m.FallbackPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FallbackPolicy |= SubsetFallbackPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &schema.UpstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionTimeout", wireType)
			}
			m.ConnectionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpIdleTimeout", wireType)
			}
			m.HttpIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpIdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutlierDetection == nil {
				m.OutlierDetection = &OutlierDetectionType{}
			}
			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSelection", wireType)
			}
			m.EndpointSelection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointSelection |= EndpointSelectionPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http2Options == nil {
				m.Http2Options = &Http2ProtocolOptions{}
			}
			if err := m.Http2Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPanicThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PanicThresholdType = &CreateSpecType_NoPanicThreshold{v}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PanicThreshold", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PanicThresholdType = &CreateSpecType_PanicThreshold{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &schema.ObjectRefType{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthChecks = append(m.HealthChecks, &schema.ObjectRefType{})
			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerAlgorithm", wireType)
			}
			m.LoadbalancerAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadbalancerAlgorithm |= LoadbalancerAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreaker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreaker == nil {
				m.CircuitBreaker = &CircuitBreaker{}
			}
			if err := m.CircuitBreaker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSubsets = append(m.EndpointSubsets, &EndpointSubsetSelectorType{})
			if err := m.EndpointSubsets[len(m.EndpointSubsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSubset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultSubset == nil {
				m.DefaultSubset = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DefaultSubset[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPolicy", wireType)
			}
			m.FallbackPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FallbackPolicy |= SubsetFallbackPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &schema.UpstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionTimeout", wireType)
			}
			m.ConnectionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpIdleTimeout", wireType)
			}
			m.HttpIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpIdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutlierDetection == nil {
				m.OutlierDetection = &OutlierDetectionType{}
			}
			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSelection", wireType)
			}
			m.EndpointSelection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointSelection |= EndpointSelectionPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http2Options == nil {
				m.Http2Options = &Http2ProtocolOptions{}
			}
			if err := m.Http2Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPanicThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PanicThresholdType = &ReplaceSpecType_NoPanicThreshold{v}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PanicThreshold", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PanicThresholdType = &ReplaceSpecType_PanicThreshold{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &schema.ObjectRefType{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthChecks = append(m.HealthChecks, &schema.ObjectRefType{})
			if err := m.HealthChecks[len(m.HealthChecks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadbalancerAlgorithm", wireType)
			}
			m.LoadbalancerAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoadbalancerAlgorithm |= LoadbalancerAlgorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreaker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircuitBreaker == nil {
				m.CircuitBreaker = &CircuitBreaker{}
			}
			if err := m.CircuitBreaker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSubsets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSubsets = append(m.EndpointSubsets, &EndpointSubsetSelectorType{})
			if err := m.EndpointSubsets[len(m.EndpointSubsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSubset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultSubset == nil {
				m.DefaultSubset = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DefaultSubset[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackPolicy", wireType)
			}
			m.FallbackPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FallbackPolicy |= SubsetFallbackPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &schema.UpstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionTimeout", wireType)
			}
			m.ConnectionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpIdleTimeout", wireType)
			}
			m.HttpIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpIdleTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutlierDetection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutlierDetection == nil {
				m.OutlierDetection = &OutlierDetectionType{}
			}
			if err := m.OutlierDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSelection", wireType)
			}
			m.EndpointSelection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndpointSelection |= EndpointSelectionPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Http2Options == nil {
				m.Http2Options = &Http2ProtocolOptions{}
			}
			if err := m.Http2Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPanicThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PanicThresholdType = &GetSpecType_NoPanicThreshold{v}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PanicThreshold", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PanicThresholdType = &GetSpecType_PanicThreshold{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
