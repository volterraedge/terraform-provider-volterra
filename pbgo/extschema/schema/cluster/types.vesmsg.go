// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package cluster

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CircuitBreaker) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CircuitBreaker) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CircuitBreaker) DeepCopy() *CircuitBreaker {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CircuitBreaker{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CircuitBreaker) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CircuitBreaker) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CircuitBreakerValidator().Validate(ctx, m, opts...)
}

type ValidateCircuitBreaker struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCircuitBreaker) ConnectionLimitValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_limit")
	}

	return validatorFn, nil
}

func (v *ValidateCircuitBreaker) PendingRequestsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pending_requests")
	}

	return validatorFn, nil
}

func (v *ValidateCircuitBreaker) RetriesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for retries")
	}

	return validatorFn, nil
}

func (v *ValidateCircuitBreaker) MaxRequestsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_requests")
	}

	return validatorFn, nil
}

func (v *ValidateCircuitBreaker) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CircuitBreaker)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CircuitBreaker got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_limit"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_limit"))
		if err := fv(ctx, m.GetConnectionLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_requests"]; exists {

		vOpts := append(opts, db.WithValidateField("max_requests"))
		if err := fv(ctx, m.GetMaxRequests(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pending_requests"]; exists {

		vOpts := append(opts, db.WithValidateField("pending_requests"))
		if err := fv(ctx, m.GetPendingRequests(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["retries"]; exists {

		vOpts := append(opts, db.WithValidateField("retries"))
		if err := fv(ctx, m.GetRetries(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCircuitBreakerValidator = func() *ValidateCircuitBreaker {
	v := &ValidateCircuitBreaker{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConnectionLimit := v.ConnectionLimitValidationRuleHandler
	rulesConnectionLimit := map[string]string{
		"ves.io.schema.rules.uint32.lte": "32768",
	}
	vFn, err = vrhConnectionLimit(rulesConnectionLimit)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CircuitBreaker.connection_limit: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_limit"] = vFn

	vrhPendingRequests := v.PendingRequestsValidationRuleHandler
	rulesPendingRequests := map[string]string{
		"ves.io.schema.rules.uint32.lte": "32768",
	}
	vFn, err = vrhPendingRequests(rulesPendingRequests)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CircuitBreaker.pending_requests: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pending_requests"] = vFn

	vrhRetries := v.RetriesValidationRuleHandler
	rulesRetries := map[string]string{
		"ves.io.schema.rules.uint32.lte": "32768",
	}
	vFn, err = vrhRetries(rulesRetries)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CircuitBreaker.retries: %s", err)
		panic(errMsg)
	}
	v.FldValidators["retries"] = vFn

	vrhMaxRequests := v.MaxRequestsValidationRuleHandler
	rulesMaxRequests := map[string]string{
		"ves.io.schema.rules.uint32.lte": "32768",
	}
	vFn, err = vrhMaxRequests(rulesMaxRequests)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CircuitBreaker.max_requests: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_requests"] = vFn

	return v
}()

func CircuitBreakerValidator() db.Validator {
	return DefaultCircuitBreakerValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.tls_parameters")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetEndpointsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetEndpointsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetHealthChecksDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHealthChecksDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsParametersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsParametersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *CreateSpecType) GetEndpointsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetEndpoints()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.endpoints[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "endpoint.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "endpoints",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetEndpointsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetEndpointsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "endpoint.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: endpoint")
	}
	for _, ref := range m.GetEndpoints() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *CreateSpecType) GetHealthChecksDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetHealthChecks()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("CreateSpecType.health_checks[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "healthcheck.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "health_checks",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetHealthChecksDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetHealthChecksDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "healthcheck.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: healthcheck")
	}
	for _, ref := range m.GetHealthChecks() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetTlsParametersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsParameters() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTlsParameters().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tls_parameters." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) PanicThresholdTypePanicThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PanicThreshold, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for panic_threshold")
	}
	return oValidatorFn_PanicThreshold, nil
}

func (v *ValidateCreateSpecType) EndpointsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoints")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoints")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoints")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoints")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) HealthChecksValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for health_checks")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for health_checks")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated health_checks")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items health_checks")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*EndpointSubsetSelectorType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := EndpointSubsetSelectorTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*EndpointSubsetSelectorType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*EndpointSubsetSelectorType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) DefaultSubsetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for default_subset")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for default_subset")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for default_subset")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map default_subset")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items default_subset")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ConnectionTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) HttpIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["circuit_breaker"]; exists {

		vOpts := append(opts, db.WithValidateField("circuit_breaker"))
		if err := fv(ctx, m.GetCircuitBreaker(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_timeout"))
		if err := fv(ctx, m.GetConnectionTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_subset"]; exists {
		vOpts := append(opts, db.WithValidateField("default_subset"))
		if err := fv(ctx, m.GetDefaultSubset(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_selection"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_selection"))
		if err := fv(ctx, m.GetEndpointSelection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoints"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoints"))
		if err := fv(ctx, m.GetEndpoints(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fallback_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("fallback_policy"))
		if err := fv(ctx, m.GetFallbackPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["health_checks"]; exists {
		vOpts := append(opts, db.WithValidateField("health_checks"))
		if err := fv(ctx, m.GetHealthChecks(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("http_idle_timeout"))
		if err := fv(ctx, m.GetHttpIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetHttpProtocolType().(type) {
	case *CreateSpecType_Http2Options:
		if fv, exists := v.FldValidators["http_protocol_type.http2_options"]; exists {
			val := m.GetHttpProtocolType().(*CreateSpecType_Http2Options).Http2Options
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http2_options"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Http1Config:
		if fv, exists := v.FldValidators["http_protocol_type.http1_config"]; exists {
			val := m.GetHttpProtocolType().(*CreateSpecType_Http1Config).Http1Config
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http1_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AutoHttpConfig:
		if fv, exists := v.FldValidators["http_protocol_type.auto_http_config"]; exists {
			val := m.GetHttpProtocolType().(*CreateSpecType_AutoHttpConfig).AutoHttpConfig
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("auto_http_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outlier_detection"]; exists {

		vOpts := append(opts, db.WithValidateField("outlier_detection"))
		if err := fv(ctx, m.GetOutlierDetection(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPanicThresholdType().(type) {
	case *CreateSpecType_NoPanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.no_panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*CreateSpecType_NoPanicThreshold).NoPanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("no_panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_PanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*CreateSpecType_PanicThreshold).PanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_parameters"))
		if err := fv(ctx, m.GetTlsParameters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPanicThresholdTypePanicThreshold := v.PanicThresholdTypePanicThresholdValidationRuleHandler
	rulesPanicThresholdTypePanicThreshold := map[string]string{
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFnMap["panic_threshold_type.panic_threshold"], err = vrhPanicThresholdTypePanicThreshold(rulesPanicThresholdTypePanicThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.panic_threshold_type_panic_threshold: %s", err)
		panic(errMsg)
	}

	v.FldValidators["panic_threshold_type.panic_threshold"] = vFnMap["panic_threshold_type.panic_threshold"]

	vrhEndpoints := v.EndpointsValidationRuleHandler
	rulesEndpoints := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhEndpoints(rulesEndpoints)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.endpoints: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoints"] = vFn

	vrhHealthChecks := v.HealthChecksValidationRuleHandler
	rulesHealthChecks := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhHealthChecks(rulesHealthChecks)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.health_checks: %s", err)
		panic(errMsg)
	}
	v.FldValidators["health_checks"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	vrhDefaultSubset := v.DefaultSubsetValidationRuleHandler
	rulesDefaultSubset := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "32",
	}
	vFn, err = vrhDefaultSubset(rulesDefaultSubset)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.default_subset: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_subset"] = vFn

	vrhConnectionTimeout := v.ConnectionTimeoutValidationRuleHandler
	rulesConnectionTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionTimeout(rulesConnectionTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.connection_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_timeout"] = vFn

	vrhHttpIdleTimeout := v.HttpIdleTimeoutValidationRuleHandler
	rulesHttpIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhHttpIdleTimeout(rulesHttpIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.http_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_idle_timeout"] = vFn

	v.FldValidators["circuit_breaker"] = CircuitBreakerValidator().Validate

	v.FldValidators["tls_parameters"] = ves_io_schema.UpstreamTlsParamsTypeValidator().Validate

	v.FldValidators["outlier_detection"] = OutlierDetectionTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *EndpointSubsetSelectorType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EndpointSubsetSelectorType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EndpointSubsetSelectorType) DeepCopy() *EndpointSubsetSelectorType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EndpointSubsetSelectorType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EndpointSubsetSelectorType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EndpointSubsetSelectorType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EndpointSubsetSelectorTypeValidator().Validate(ctx, m, opts...)
}

type ValidateEndpointSubsetSelectorType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEndpointSubsetSelectorType) KeysValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for keys")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for keys")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated keys")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items keys")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateEndpointSubsetSelectorType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EndpointSubsetSelectorType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EndpointSubsetSelectorType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["keys"]; exists {
		vOpts := append(opts, db.WithValidateField("keys"))
		if err := fv(ctx, m.GetKeys(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEndpointSubsetSelectorTypeValidator = func() *ValidateEndpointSubsetSelectorType {
	v := &ValidateEndpointSubsetSelectorType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKeys := v.KeysValidationRuleHandler
	rulesKeys := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
	}
	vFn, err = vrhKeys(rulesKeys)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EndpointSubsetSelectorType.keys: %s", err)
		panic(errMsg)
	}
	v.FldValidators["keys"] = vFn

	return v
}()

func EndpointSubsetSelectorTypeValidator() db.Validator {
	return DefaultEndpointSubsetSelectorTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.tls_parameters")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetEndpointsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetEndpointsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetHealthChecksDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHealthChecksDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsParametersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsParametersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetSpecType) GetEndpointsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetEndpoints()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.endpoints[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "endpoint.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "endpoints",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetEndpointsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetEndpointsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "endpoint.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: endpoint")
	}
	for _, ref := range m.GetEndpoints() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetHealthChecksDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetHealthChecks()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.health_checks[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "healthcheck.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "health_checks",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetHealthChecksDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetHealthChecksDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "healthcheck.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: healthcheck")
	}
	for _, ref := range m.GetHealthChecks() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetTlsParametersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsParameters() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTlsParameters().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tls_parameters." + dri.DRField
	}
	return drInfos, err

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) PanicThresholdTypePanicThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PanicThreshold, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for panic_threshold")
	}
	return oValidatorFn_PanicThreshold, nil
}

func (v *ValidateGetSpecType) EndpointsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoints")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoints")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoints")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoints")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) HealthChecksValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for health_checks")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for health_checks")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated health_checks")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items health_checks")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*EndpointSubsetSelectorType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := EndpointSubsetSelectorTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*EndpointSubsetSelectorType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*EndpointSubsetSelectorType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) DefaultSubsetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for default_subset")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for default_subset")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for default_subset")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map default_subset")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items default_subset")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConnectionTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) HttpIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["circuit_breaker"]; exists {

		vOpts := append(opts, db.WithValidateField("circuit_breaker"))
		if err := fv(ctx, m.GetCircuitBreaker(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_timeout"))
		if err := fv(ctx, m.GetConnectionTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_subset"]; exists {
		vOpts := append(opts, db.WithValidateField("default_subset"))
		if err := fv(ctx, m.GetDefaultSubset(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_selection"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_selection"))
		if err := fv(ctx, m.GetEndpointSelection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoints"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoints"))
		if err := fv(ctx, m.GetEndpoints(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fallback_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("fallback_policy"))
		if err := fv(ctx, m.GetFallbackPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["health_checks"]; exists {
		vOpts := append(opts, db.WithValidateField("health_checks"))
		if err := fv(ctx, m.GetHealthChecks(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("http_idle_timeout"))
		if err := fv(ctx, m.GetHttpIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetHttpProtocolType().(type) {
	case *GetSpecType_Http2Options:
		if fv, exists := v.FldValidators["http_protocol_type.http2_options"]; exists {
			val := m.GetHttpProtocolType().(*GetSpecType_Http2Options).Http2Options
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http2_options"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Http1Config:
		if fv, exists := v.FldValidators["http_protocol_type.http1_config"]; exists {
			val := m.GetHttpProtocolType().(*GetSpecType_Http1Config).Http1Config
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http1_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AutoHttpConfig:
		if fv, exists := v.FldValidators["http_protocol_type.auto_http_config"]; exists {
			val := m.GetHttpProtocolType().(*GetSpecType_AutoHttpConfig).AutoHttpConfig
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("auto_http_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetLbSourceIpPersistanceChoice().(type) {
	case *GetSpecType_EnableLbSourceIpPersistance:
		if fv, exists := v.FldValidators["lb_source_ip_persistance_choice.enable_lb_source_ip_persistance"]; exists {
			val := m.GetLbSourceIpPersistanceChoice().(*GetSpecType_EnableLbSourceIpPersistance).EnableLbSourceIpPersistance
			vOpts := append(opts,
				db.WithValidateField("lb_source_ip_persistance_choice"),
				db.WithValidateField("enable_lb_source_ip_persistance"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DisableLbSourceIpPersistance:
		if fv, exists := v.FldValidators["lb_source_ip_persistance_choice.disable_lb_source_ip_persistance"]; exists {
			val := m.GetLbSourceIpPersistanceChoice().(*GetSpecType_DisableLbSourceIpPersistance).DisableLbSourceIpPersistance
			vOpts := append(opts,
				db.WithValidateField("lb_source_ip_persistance_choice"),
				db.WithValidateField("disable_lb_source_ip_persistance"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outlier_detection"]; exists {

		vOpts := append(opts, db.WithValidateField("outlier_detection"))
		if err := fv(ctx, m.GetOutlierDetection(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPanicThresholdType().(type) {
	case *GetSpecType_NoPanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.no_panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*GetSpecType_NoPanicThreshold).NoPanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("no_panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_PanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*GetSpecType_PanicThreshold).PanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_parameters"))
		if err := fv(ctx, m.GetTlsParameters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPanicThresholdTypePanicThreshold := v.PanicThresholdTypePanicThresholdValidationRuleHandler
	rulesPanicThresholdTypePanicThreshold := map[string]string{
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFnMap["panic_threshold_type.panic_threshold"], err = vrhPanicThresholdTypePanicThreshold(rulesPanicThresholdTypePanicThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.panic_threshold_type_panic_threshold: %s", err)
		panic(errMsg)
	}

	v.FldValidators["panic_threshold_type.panic_threshold"] = vFnMap["panic_threshold_type.panic_threshold"]

	vrhEndpoints := v.EndpointsValidationRuleHandler
	rulesEndpoints := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhEndpoints(rulesEndpoints)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.endpoints: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoints"] = vFn

	vrhHealthChecks := v.HealthChecksValidationRuleHandler
	rulesHealthChecks := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhHealthChecks(rulesHealthChecks)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.health_checks: %s", err)
		panic(errMsg)
	}
	v.FldValidators["health_checks"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	vrhDefaultSubset := v.DefaultSubsetValidationRuleHandler
	rulesDefaultSubset := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "32",
	}
	vFn, err = vrhDefaultSubset(rulesDefaultSubset)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.default_subset: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_subset"] = vFn

	vrhConnectionTimeout := v.ConnectionTimeoutValidationRuleHandler
	rulesConnectionTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionTimeout(rulesConnectionTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.connection_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_timeout"] = vFn

	vrhHttpIdleTimeout := v.HttpIdleTimeoutValidationRuleHandler
	rulesHttpIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhHttpIdleTimeout(rulesHttpIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.http_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_idle_timeout"] = vFn

	v.FldValidators["circuit_breaker"] = CircuitBreakerValidator().Validate

	v.FldValidators["tls_parameters"] = ves_io_schema.UpstreamTlsParamsTypeValidator().Validate

	v.FldValidators["outlier_detection"] = OutlierDetectionTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.tls_parameters")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetEndpointsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetEndpointsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetHealthChecksDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHealthChecksDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsParametersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsParametersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetEndpointsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetEndpoints()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.endpoints[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "endpoint.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "endpoints",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetEndpointsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetEndpointsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "endpoint.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: endpoint")
	}
	for _, ref := range m.GetEndpoints() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetHealthChecksDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetHealthChecks()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.health_checks[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "healthcheck.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "health_checks",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetHealthChecksDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetHealthChecksDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "healthcheck.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: healthcheck")
	}
	for _, ref := range m.GetHealthChecks() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetTlsParametersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsParameters() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTlsParameters().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tls_parameters." + dri.DRField
	}
	return drInfos, err

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) PanicThresholdTypePanicThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PanicThreshold, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for panic_threshold")
	}
	return oValidatorFn_PanicThreshold, nil
}

func (v *ValidateGlobalSpecType) EndpointsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoints")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoints")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoints")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoints")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) HealthChecksValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for health_checks")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for health_checks")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated health_checks")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items health_checks")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*EndpointSubsetSelectorType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := EndpointSubsetSelectorTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*EndpointSubsetSelectorType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*EndpointSubsetSelectorType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DefaultSubsetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for default_subset")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for default_subset")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for default_subset")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map default_subset")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items default_subset")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConnectionTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) HttpIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["circuit_breaker"]; exists {

		vOpts := append(opts, db.WithValidateField("circuit_breaker"))
		if err := fv(ctx, m.GetCircuitBreaker(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_timeout"))
		if err := fv(ctx, m.GetConnectionTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_subset"]; exists {
		vOpts := append(opts, db.WithValidateField("default_subset"))
		if err := fv(ctx, m.GetDefaultSubset(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_discovery_type"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_discovery_type"))
		if err := fv(ctx, m.GetDnsDiscoveryType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_lookup_family"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_lookup_family"))
		if err := fv(ctx, m.GetDnsLookupFamily(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_selection"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_selection"))
		if err := fv(ctx, m.GetEndpointSelection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoints"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoints"))
		if err := fv(ctx, m.GetEndpoints(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fallback_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("fallback_policy"))
		if err := fv(ctx, m.GetFallbackPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["health_checks"]; exists {
		vOpts := append(opts, db.WithValidateField("health_checks"))
		if err := fv(ctx, m.GetHealthChecks(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("http_idle_timeout"))
		if err := fv(ctx, m.GetHttpIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetHttpProtocolType().(type) {
	case *GlobalSpecType_Http2Options:
		if fv, exists := v.FldValidators["http_protocol_type.http2_options"]; exists {
			val := m.GetHttpProtocolType().(*GlobalSpecType_Http2Options).Http2Options
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http2_options"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Http1Config:
		if fv, exists := v.FldValidators["http_protocol_type.http1_config"]; exists {
			val := m.GetHttpProtocolType().(*GlobalSpecType_Http1Config).Http1Config
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http1_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AutoHttpConfig:
		if fv, exists := v.FldValidators["http_protocol_type.auto_http_config"]; exists {
			val := m.GetHttpProtocolType().(*GlobalSpecType_AutoHttpConfig).AutoHttpConfig
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("auto_http_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetLbSourceIpPersistanceChoice().(type) {
	case *GlobalSpecType_EnableLbSourceIpPersistance:
		if fv, exists := v.FldValidators["lb_source_ip_persistance_choice.enable_lb_source_ip_persistance"]; exists {
			val := m.GetLbSourceIpPersistanceChoice().(*GlobalSpecType_EnableLbSourceIpPersistance).EnableLbSourceIpPersistance
			vOpts := append(opts,
				db.WithValidateField("lb_source_ip_persistance_choice"),
				db.WithValidateField("enable_lb_source_ip_persistance"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DisableLbSourceIpPersistance:
		if fv, exists := v.FldValidators["lb_source_ip_persistance_choice.disable_lb_source_ip_persistance"]; exists {
			val := m.GetLbSourceIpPersistanceChoice().(*GlobalSpecType_DisableLbSourceIpPersistance).DisableLbSourceIpPersistance
			vOpts := append(opts,
				db.WithValidateField("lb_source_ip_persistance_choice"),
				db.WithValidateField("disable_lb_source_ip_persistance"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outlier_detection"]; exists {

		vOpts := append(opts, db.WithValidateField("outlier_detection"))
		if err := fv(ctx, m.GetOutlierDetection(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPanicThresholdType().(type) {
	case *GlobalSpecType_NoPanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.no_panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*GlobalSpecType_NoPanicThreshold).NoPanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("no_panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_PanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*GlobalSpecType_PanicThreshold).PanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_parameters"))
		if err := fv(ctx, m.GetTlsParameters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPanicThresholdTypePanicThreshold := v.PanicThresholdTypePanicThresholdValidationRuleHandler
	rulesPanicThresholdTypePanicThreshold := map[string]string{
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFnMap["panic_threshold_type.panic_threshold"], err = vrhPanicThresholdTypePanicThreshold(rulesPanicThresholdTypePanicThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.panic_threshold_type_panic_threshold: %s", err)
		panic(errMsg)
	}

	v.FldValidators["panic_threshold_type.panic_threshold"] = vFnMap["panic_threshold_type.panic_threshold"]

	vrhEndpoints := v.EndpointsValidationRuleHandler
	rulesEndpoints := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhEndpoints(rulesEndpoints)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.endpoints: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoints"] = vFn

	vrhHealthChecks := v.HealthChecksValidationRuleHandler
	rulesHealthChecks := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhHealthChecks(rulesHealthChecks)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.health_checks: %s", err)
		panic(errMsg)
	}
	v.FldValidators["health_checks"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	vrhDefaultSubset := v.DefaultSubsetValidationRuleHandler
	rulesDefaultSubset := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "32",
	}
	vFn, err = vrhDefaultSubset(rulesDefaultSubset)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.default_subset: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_subset"] = vFn

	vrhConnectionTimeout := v.ConnectionTimeoutValidationRuleHandler
	rulesConnectionTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionTimeout(rulesConnectionTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.connection_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_timeout"] = vFn

	vrhHttpIdleTimeout := v.HttpIdleTimeoutValidationRuleHandler
	rulesHttpIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhHttpIdleTimeout(rulesHttpIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.http_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_idle_timeout"] = vFn

	v.FldValidators["circuit_breaker"] = CircuitBreakerValidator().Validate

	v.FldValidators["tls_parameters"] = ves_io_schema.UpstreamTlsParamsTypeValidator().Validate

	v.FldValidators["outlier_detection"] = OutlierDetectionTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Http2ProtocolOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Http2ProtocolOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Http2ProtocolOptions) DeepCopy() *Http2ProtocolOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Http2ProtocolOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Http2ProtocolOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Http2ProtocolOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Http2ProtocolOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateHttp2ProtocolOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttp2ProtocolOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Http2ProtocolOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Http2ProtocolOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("enabled"))
		if err := fv(ctx, m.GetEnabled(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttp2ProtocolOptionsValidator = func() *ValidateHttp2ProtocolOptions {
	v := &ValidateHttp2ProtocolOptions{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func Http2ProtocolOptionsValidator() db.Validator {
	return DefaultHttp2ProtocolOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *OutlierDetectionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OutlierDetectionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OutlierDetectionType) DeepCopy() *OutlierDetectionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OutlierDetectionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OutlierDetectionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OutlierDetectionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OutlierDetectionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateOutlierDetectionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOutlierDetectionType) Consecutive_5XxValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for consecutive_5xx")
	}

	return validatorFn, nil
}

func (v *ValidateOutlierDetectionType) IntervalValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interval")
	}

	return validatorFn, nil
}

func (v *ValidateOutlierDetectionType) BaseEjectionTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for base_ejection_time")
	}

	return validatorFn, nil
}

func (v *ValidateOutlierDetectionType) MaxEjectionPercentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_ejection_percent")
	}

	return validatorFn, nil
}

func (v *ValidateOutlierDetectionType) ConsecutiveGatewayFailureValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for consecutive_gateway_failure")
	}

	return validatorFn, nil
}

func (v *ValidateOutlierDetectionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OutlierDetectionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OutlierDetectionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["base_ejection_time"]; exists {

		vOpts := append(opts, db.WithValidateField("base_ejection_time"))
		if err := fv(ctx, m.GetBaseEjectionTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["consecutive_5xx"]; exists {

		vOpts := append(opts, db.WithValidateField("consecutive_5xx"))
		if err := fv(ctx, m.GetConsecutive_5Xx(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["consecutive_gateway_failure"]; exists {

		vOpts := append(opts, db.WithValidateField("consecutive_gateway_failure"))
		if err := fv(ctx, m.GetConsecutiveGatewayFailure(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interval"]; exists {

		vOpts := append(opts, db.WithValidateField("interval"))
		if err := fv(ctx, m.GetInterval(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_ejection_percent"]; exists {

		vOpts := append(opts, db.WithValidateField("max_ejection_percent"))
		if err := fv(ctx, m.GetMaxEjectionPercent(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOutlierDetectionTypeValidator = func() *ValidateOutlierDetectionType {
	v := &ValidateOutlierDetectionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConsecutive_5Xx := v.Consecutive_5XxValidationRuleHandler
	rulesConsecutive_5Xx := map[string]string{
		"ves.io.schema.rules.uint32.lte": "1024",
	}
	vFn, err = vrhConsecutive_5Xx(rulesConsecutive_5Xx)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OutlierDetectionType.consecutive_5xx: %s", err)
		panic(errMsg)
	}
	v.FldValidators["consecutive_5xx"] = vFn

	vrhInterval := v.IntervalValidationRuleHandler
	rulesInterval := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhInterval(rulesInterval)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OutlierDetectionType.interval: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interval"] = vFn

	vrhBaseEjectionTime := v.BaseEjectionTimeValidationRuleHandler
	rulesBaseEjectionTime := map[string]string{
		"ves.io.schema.rules.uint32.lte": "1800000",
	}
	vFn, err = vrhBaseEjectionTime(rulesBaseEjectionTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OutlierDetectionType.base_ejection_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["base_ejection_time"] = vFn

	vrhMaxEjectionPercent := v.MaxEjectionPercentValidationRuleHandler
	rulesMaxEjectionPercent := map[string]string{
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFn, err = vrhMaxEjectionPercent(rulesMaxEjectionPercent)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OutlierDetectionType.max_ejection_percent: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_ejection_percent"] = vFn

	vrhConsecutiveGatewayFailure := v.ConsecutiveGatewayFailureValidationRuleHandler
	rulesConsecutiveGatewayFailure := map[string]string{
		"ves.io.schema.rules.uint32.lte": "1024",
	}
	vFn, err = vrhConsecutiveGatewayFailure(rulesConsecutiveGatewayFailure)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OutlierDetectionType.consecutive_gateway_failure: %s", err)
		panic(errMsg)
	}
	v.FldValidators["consecutive_gateway_failure"] = vFn

	return v
}()

func OutlierDetectionTypeValidator() db.Validator {
	return DefaultOutlierDetectionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.tls_parameters")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetEndpointsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetEndpointsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetHealthChecksDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHealthChecksDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsParametersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsParametersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *ReplaceSpecType) GetEndpointsDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetEndpoints()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.endpoints[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "endpoint.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "endpoints",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetEndpointsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetEndpointsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "endpoint.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: endpoint")
	}
	for _, ref := range m.GetEndpoints() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *ReplaceSpecType) GetHealthChecksDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetHealthChecks()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.health_checks[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "healthcheck.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "health_checks",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetHealthChecksDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetHealthChecksDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "healthcheck.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: healthcheck")
	}
	for _, ref := range m.GetHealthChecks() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetTlsParametersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsParameters() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTlsParameters().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTlsParameters().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tls_parameters." + dri.DRField
	}
	return drInfos, err

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) PanicThresholdTypePanicThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PanicThreshold, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for panic_threshold")
	}
	return oValidatorFn_PanicThreshold, nil
}

func (v *ValidateReplaceSpecType) EndpointsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoints")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoints")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoints")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoints")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) HealthChecksValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for health_checks")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for health_checks")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated health_checks")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items health_checks")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*EndpointSubsetSelectorType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := EndpointSubsetSelectorTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*EndpointSubsetSelectorType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*EndpointSubsetSelectorType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) DefaultSubsetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for default_subset")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for default_subset")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for default_subset")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map default_subset")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items default_subset")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ConnectionTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) HttpIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["circuit_breaker"]; exists {

		vOpts := append(opts, db.WithValidateField("circuit_breaker"))
		if err := fv(ctx, m.GetCircuitBreaker(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connection_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_timeout"))
		if err := fv(ctx, m.GetConnectionTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_subset"]; exists {
		vOpts := append(opts, db.WithValidateField("default_subset"))
		if err := fv(ctx, m.GetDefaultSubset(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_selection"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_selection"))
		if err := fv(ctx, m.GetEndpointSelection(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoints"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoints"))
		if err := fv(ctx, m.GetEndpoints(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fallback_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("fallback_policy"))
		if err := fv(ctx, m.GetFallbackPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["health_checks"]; exists {
		vOpts := append(opts, db.WithValidateField("health_checks"))
		if err := fv(ctx, m.GetHealthChecks(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("http_idle_timeout"))
		if err := fv(ctx, m.GetHttpIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetHttpProtocolType().(type) {
	case *ReplaceSpecType_Http2Options:
		if fv, exists := v.FldValidators["http_protocol_type.http2_options"]; exists {
			val := m.GetHttpProtocolType().(*ReplaceSpecType_Http2Options).Http2Options
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http2_options"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Http1Config:
		if fv, exists := v.FldValidators["http_protocol_type.http1_config"]; exists {
			val := m.GetHttpProtocolType().(*ReplaceSpecType_Http1Config).Http1Config
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http1_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AutoHttpConfig:
		if fv, exists := v.FldValidators["http_protocol_type.auto_http_config"]; exists {
			val := m.GetHttpProtocolType().(*ReplaceSpecType_AutoHttpConfig).AutoHttpConfig
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("auto_http_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outlier_detection"]; exists {

		vOpts := append(opts, db.WithValidateField("outlier_detection"))
		if err := fv(ctx, m.GetOutlierDetection(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetPanicThresholdType().(type) {
	case *ReplaceSpecType_NoPanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.no_panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*ReplaceSpecType_NoPanicThreshold).NoPanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("no_panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_PanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*ReplaceSpecType_PanicThreshold).PanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_parameters"))
		if err := fv(ctx, m.GetTlsParameters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPanicThresholdTypePanicThreshold := v.PanicThresholdTypePanicThresholdValidationRuleHandler
	rulesPanicThresholdTypePanicThreshold := map[string]string{
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFnMap["panic_threshold_type.panic_threshold"], err = vrhPanicThresholdTypePanicThreshold(rulesPanicThresholdTypePanicThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.panic_threshold_type_panic_threshold: %s", err)
		panic(errMsg)
	}

	v.FldValidators["panic_threshold_type.panic_threshold"] = vFnMap["panic_threshold_type.panic_threshold"]

	vrhEndpoints := v.EndpointsValidationRuleHandler
	rulesEndpoints := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhEndpoints(rulesEndpoints)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.endpoints: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoints"] = vFn

	vrhHealthChecks := v.HealthChecksValidationRuleHandler
	rulesHealthChecks := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhHealthChecks(rulesHealthChecks)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.health_checks: %s", err)
		panic(errMsg)
	}
	v.FldValidators["health_checks"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	vrhDefaultSubset := v.DefaultSubsetValidationRuleHandler
	rulesDefaultSubset := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "32",
	}
	vFn, err = vrhDefaultSubset(rulesDefaultSubset)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.default_subset: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_subset"] = vFn

	vrhConnectionTimeout := v.ConnectionTimeoutValidationRuleHandler
	rulesConnectionTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhConnectionTimeout(rulesConnectionTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.connection_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_timeout"] = vFn

	vrhHttpIdleTimeout := v.HttpIdleTimeoutValidationRuleHandler
	rulesHttpIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhHttpIdleTimeout(rulesHttpIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.http_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_idle_timeout"] = vFn

	v.FldValidators["circuit_breaker"] = CircuitBreakerValidator().Validate

	v.FldValidators["tls_parameters"] = ves_io_schema.UpstreamTlsParamsTypeValidator().Validate

	v.FldValidators["outlier_detection"] = OutlierDetectionTypeValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetHttpProtocolTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.HttpProtocolType.(type) {
	case nil:
		o.HttpProtocolType = nil

	case *CreateSpecType_AutoHttpConfig:
		o.HttpProtocolType = &GlobalSpecType_AutoHttpConfig{AutoHttpConfig: of.AutoHttpConfig}

	case *CreateSpecType_Http1Config:
		o.HttpProtocolType = &GlobalSpecType_Http1Config{Http1Config: of.Http1Config}

	case *CreateSpecType_Http2Options:
		o.HttpProtocolType = &GlobalSpecType_Http2Options{Http2Options: of.Http2Options}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetHttpProtocolTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.HttpProtocolType.(type) {
	case nil:
		r.HttpProtocolType = nil

	case *GlobalSpecType_AutoHttpConfig:
		r.HttpProtocolType = &CreateSpecType_AutoHttpConfig{AutoHttpConfig: of.AutoHttpConfig}

	case *GlobalSpecType_Http1Config:
		r.HttpProtocolType = &CreateSpecType_Http1Config{Http1Config: of.Http1Config}

	case *GlobalSpecType_Http2Options:
		r.HttpProtocolType = &CreateSpecType_Http2Options{Http2Options: of.Http2Options}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetPanicThresholdTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PanicThresholdType.(type) {
	case nil:
		o.PanicThresholdType = nil

	case *CreateSpecType_NoPanicThreshold:
		o.PanicThresholdType = &GlobalSpecType_NoPanicThreshold{NoPanicThreshold: of.NoPanicThreshold}

	case *CreateSpecType_PanicThreshold:
		o.PanicThresholdType = &GlobalSpecType_PanicThreshold{PanicThreshold: of.PanicThreshold}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetPanicThresholdTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PanicThresholdType.(type) {
	case nil:
		r.PanicThresholdType = nil

	case *GlobalSpecType_NoPanicThreshold:
		r.PanicThresholdType = &CreateSpecType_NoPanicThreshold{NoPanicThreshold: of.NoPanicThreshold}

	case *GlobalSpecType_PanicThreshold:
		r.PanicThresholdType = &CreateSpecType_PanicThreshold{PanicThreshold: of.PanicThreshold}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.CircuitBreaker = f.GetCircuitBreaker()
	m.ConnectionTimeout = f.GetConnectionTimeout()
	m.DefaultSubset = f.GetDefaultSubset()
	m.EndpointSelection = f.GetEndpointSelection()
	m.EndpointSubsets = f.GetEndpointSubsets()
	m.Endpoints = f.GetEndpoints()
	m.FallbackPolicy = f.GetFallbackPolicy()
	m.HeaderTransformationType = f.GetHeaderTransformationType()
	m.HealthChecks = f.GetHealthChecks()
	m.HttpIdleTimeout = f.GetHttpIdleTimeout()
	m.GetHttpProtocolTypeFromGlobalSpecType(f)
	m.LoadbalancerAlgorithm = f.GetLoadbalancerAlgorithm()
	m.OutlierDetection = f.GetOutlierDetection()
	m.GetPanicThresholdTypeFromGlobalSpecType(f)
	m.TlsParameters = f.GetTlsParameters()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.CircuitBreaker = m1.CircuitBreaker
	f.ConnectionTimeout = m1.ConnectionTimeout
	f.DefaultSubset = m1.DefaultSubset
	f.EndpointSelection = m1.EndpointSelection
	f.EndpointSubsets = m1.EndpointSubsets
	f.Endpoints = m1.Endpoints
	f.FallbackPolicy = m1.FallbackPolicy
	f.HeaderTransformationType = m1.HeaderTransformationType
	f.HealthChecks = m1.HealthChecks
	f.HttpIdleTimeout = m1.HttpIdleTimeout
	m1.SetHttpProtocolTypeToGlobalSpecType(f)
	f.LoadbalancerAlgorithm = m1.LoadbalancerAlgorithm
	f.OutlierDetection = m1.OutlierDetection
	m1.SetPanicThresholdTypeToGlobalSpecType(f)
	f.TlsParameters = m1.TlsParameters
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetHttpProtocolTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.HttpProtocolType.(type) {
	case nil:
		o.HttpProtocolType = nil

	case *GetSpecType_AutoHttpConfig:
		o.HttpProtocolType = &GlobalSpecType_AutoHttpConfig{AutoHttpConfig: of.AutoHttpConfig}

	case *GetSpecType_Http1Config:
		o.HttpProtocolType = &GlobalSpecType_Http1Config{Http1Config: of.Http1Config}

	case *GetSpecType_Http2Options:
		o.HttpProtocolType = &GlobalSpecType_Http2Options{Http2Options: of.Http2Options}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetHttpProtocolTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.HttpProtocolType.(type) {
	case nil:
		r.HttpProtocolType = nil

	case *GlobalSpecType_AutoHttpConfig:
		r.HttpProtocolType = &GetSpecType_AutoHttpConfig{AutoHttpConfig: of.AutoHttpConfig}

	case *GlobalSpecType_Http1Config:
		r.HttpProtocolType = &GetSpecType_Http1Config{Http1Config: of.Http1Config}

	case *GlobalSpecType_Http2Options:
		r.HttpProtocolType = &GetSpecType_Http2Options{Http2Options: of.Http2Options}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetLbSourceIpPersistanceChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LbSourceIpPersistanceChoice.(type) {
	case nil:
		o.LbSourceIpPersistanceChoice = nil

	case *GetSpecType_DisableLbSourceIpPersistance:
		o.LbSourceIpPersistanceChoice = &GlobalSpecType_DisableLbSourceIpPersistance{DisableLbSourceIpPersistance: of.DisableLbSourceIpPersistance}

	case *GetSpecType_EnableLbSourceIpPersistance:
		o.LbSourceIpPersistanceChoice = &GlobalSpecType_EnableLbSourceIpPersistance{EnableLbSourceIpPersistance: of.EnableLbSourceIpPersistance}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetLbSourceIpPersistanceChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LbSourceIpPersistanceChoice.(type) {
	case nil:
		r.LbSourceIpPersistanceChoice = nil

	case *GlobalSpecType_DisableLbSourceIpPersistance:
		r.LbSourceIpPersistanceChoice = &GetSpecType_DisableLbSourceIpPersistance{DisableLbSourceIpPersistance: of.DisableLbSourceIpPersistance}

	case *GlobalSpecType_EnableLbSourceIpPersistance:
		r.LbSourceIpPersistanceChoice = &GetSpecType_EnableLbSourceIpPersistance{EnableLbSourceIpPersistance: of.EnableLbSourceIpPersistance}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetPanicThresholdTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PanicThresholdType.(type) {
	case nil:
		o.PanicThresholdType = nil

	case *GetSpecType_NoPanicThreshold:
		o.PanicThresholdType = &GlobalSpecType_NoPanicThreshold{NoPanicThreshold: of.NoPanicThreshold}

	case *GetSpecType_PanicThreshold:
		o.PanicThresholdType = &GlobalSpecType_PanicThreshold{PanicThreshold: of.PanicThreshold}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetPanicThresholdTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PanicThresholdType.(type) {
	case nil:
		r.PanicThresholdType = nil

	case *GlobalSpecType_NoPanicThreshold:
		r.PanicThresholdType = &GetSpecType_NoPanicThreshold{NoPanicThreshold: of.NoPanicThreshold}

	case *GlobalSpecType_PanicThreshold:
		r.PanicThresholdType = &GetSpecType_PanicThreshold{PanicThreshold: of.PanicThreshold}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.CircuitBreaker = f.GetCircuitBreaker()
	m.ConnectionTimeout = f.GetConnectionTimeout()
	m.DefaultSubset = f.GetDefaultSubset()
	m.EndpointSelection = f.GetEndpointSelection()
	m.EndpointSubsets = f.GetEndpointSubsets()
	m.Endpoints = f.GetEndpoints()
	m.FallbackPolicy = f.GetFallbackPolicy()
	m.HeaderTransformationType = f.GetHeaderTransformationType()
	m.HealthChecks = f.GetHealthChecks()
	m.HttpIdleTimeout = f.GetHttpIdleTimeout()
	m.GetHttpProtocolTypeFromGlobalSpecType(f)
	m.GetLbSourceIpPersistanceChoiceFromGlobalSpecType(f)
	m.LoadbalancerAlgorithm = f.GetLoadbalancerAlgorithm()
	m.OutlierDetection = f.GetOutlierDetection()
	m.GetPanicThresholdTypeFromGlobalSpecType(f)
	m.TlsParameters = f.GetTlsParameters()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.CircuitBreaker = m1.CircuitBreaker
	f.ConnectionTimeout = m1.ConnectionTimeout
	f.DefaultSubset = m1.DefaultSubset
	f.EndpointSelection = m1.EndpointSelection
	f.EndpointSubsets = m1.EndpointSubsets
	f.Endpoints = m1.Endpoints
	f.FallbackPolicy = m1.FallbackPolicy
	f.HeaderTransformationType = m1.HeaderTransformationType
	f.HealthChecks = m1.HealthChecks
	f.HttpIdleTimeout = m1.HttpIdleTimeout
	m1.SetHttpProtocolTypeToGlobalSpecType(f)
	m1.SetLbSourceIpPersistanceChoiceToGlobalSpecType(f)
	f.LoadbalancerAlgorithm = m1.LoadbalancerAlgorithm
	f.OutlierDetection = m1.OutlierDetection
	m1.SetPanicThresholdTypeToGlobalSpecType(f)
	f.TlsParameters = m1.TlsParameters
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetHttpProtocolTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.HttpProtocolType.(type) {
	case nil:
		o.HttpProtocolType = nil

	case *ReplaceSpecType_AutoHttpConfig:
		o.HttpProtocolType = &GlobalSpecType_AutoHttpConfig{AutoHttpConfig: of.AutoHttpConfig}

	case *ReplaceSpecType_Http1Config:
		o.HttpProtocolType = &GlobalSpecType_Http1Config{Http1Config: of.Http1Config}

	case *ReplaceSpecType_Http2Options:
		o.HttpProtocolType = &GlobalSpecType_Http2Options{Http2Options: of.Http2Options}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetHttpProtocolTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.HttpProtocolType.(type) {
	case nil:
		r.HttpProtocolType = nil

	case *GlobalSpecType_AutoHttpConfig:
		r.HttpProtocolType = &ReplaceSpecType_AutoHttpConfig{AutoHttpConfig: of.AutoHttpConfig}

	case *GlobalSpecType_Http1Config:
		r.HttpProtocolType = &ReplaceSpecType_Http1Config{Http1Config: of.Http1Config}

	case *GlobalSpecType_Http2Options:
		r.HttpProtocolType = &ReplaceSpecType_Http2Options{Http2Options: of.Http2Options}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetPanicThresholdTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PanicThresholdType.(type) {
	case nil:
		o.PanicThresholdType = nil

	case *ReplaceSpecType_NoPanicThreshold:
		o.PanicThresholdType = &GlobalSpecType_NoPanicThreshold{NoPanicThreshold: of.NoPanicThreshold}

	case *ReplaceSpecType_PanicThreshold:
		o.PanicThresholdType = &GlobalSpecType_PanicThreshold{PanicThreshold: of.PanicThreshold}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetPanicThresholdTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PanicThresholdType.(type) {
	case nil:
		r.PanicThresholdType = nil

	case *GlobalSpecType_NoPanicThreshold:
		r.PanicThresholdType = &ReplaceSpecType_NoPanicThreshold{NoPanicThreshold: of.NoPanicThreshold}

	case *GlobalSpecType_PanicThreshold:
		r.PanicThresholdType = &ReplaceSpecType_PanicThreshold{PanicThreshold: of.PanicThreshold}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.CircuitBreaker = f.GetCircuitBreaker()
	m.ConnectionTimeout = f.GetConnectionTimeout()
	m.DefaultSubset = f.GetDefaultSubset()
	m.EndpointSelection = f.GetEndpointSelection()
	m.EndpointSubsets = f.GetEndpointSubsets()
	m.Endpoints = f.GetEndpoints()
	m.FallbackPolicy = f.GetFallbackPolicy()
	m.HeaderTransformationType = f.GetHeaderTransformationType()
	m.HealthChecks = f.GetHealthChecks()
	m.HttpIdleTimeout = f.GetHttpIdleTimeout()
	m.GetHttpProtocolTypeFromGlobalSpecType(f)
	m.LoadbalancerAlgorithm = f.GetLoadbalancerAlgorithm()
	m.OutlierDetection = f.GetOutlierDetection()
	m.GetPanicThresholdTypeFromGlobalSpecType(f)
	m.TlsParameters = f.GetTlsParameters()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.CircuitBreaker = m1.CircuitBreaker
	f.ConnectionTimeout = m1.ConnectionTimeout
	f.DefaultSubset = m1.DefaultSubset
	f.EndpointSelection = m1.EndpointSelection
	f.EndpointSubsets = m1.EndpointSubsets
	f.Endpoints = m1.Endpoints
	f.FallbackPolicy = m1.FallbackPolicy
	f.HeaderTransformationType = m1.HeaderTransformationType
	f.HealthChecks = m1.HealthChecks
	f.HttpIdleTimeout = m1.HttpIdleTimeout
	m1.SetHttpProtocolTypeToGlobalSpecType(f)
	f.LoadbalancerAlgorithm = m1.LoadbalancerAlgorithm
	f.OutlierDetection = m1.OutlierDetection
	m1.SetPanicThresholdTypeToGlobalSpecType(f)
	f.TlsParameters = m1.TlsParameters
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
