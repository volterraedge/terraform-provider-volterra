// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/ai_assistant/common/types.proto

//
// Basic type definitions
//

package common

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ColumnType
//
// x-displayName: "Column Type"
// Column Type defines the data type for each column.
type ColumnType int32

const (
	// None
	//
	// x-displayName: "None"
	COLUMN_TYPE_NONE ColumnType = 0
	//string
	//
	// x-displayName: "String"
	STRING ColumnType = 1
	//integer
	//
	// x-displayName: "Integer"
	INT ColumnType = 2
	//float
	//
	// x-displayName: "Float"
	FLOAT ColumnType = 3
	//boolean
	//
	// x-displayName: "bool"
	BOOL ColumnType = 4
)

var ColumnType_name = map[int32]string{
	0: "COLUMN_TYPE_NONE",
	1: "STRING",
	2: "INT",
	3: "FLOAT",
	4: "BOOL",
}

var ColumnType_value = map[string]int32{
	"COLUMN_TYPE_NONE": 0,
	"STRING":           1,
	"INT":              2,
	"FLOAT":            3,
	"BOOL":             4,
}

func (ColumnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{0}
}

// DisplayType
//
// x-displayName: "DisplayType Type"
// Render Type defines the format to which data has to be rendered on UI.
type DisplayType int32

const (
	// None
	//
	// x-displayName: "None"
	// None type
	DISPLAY_TYPE_NONE DisplayType = 0
	//icon
	//
	// x-displayName: "Icon"
	// Value to be displayed as ICON
	ICON           DisplayType = 1
	DOT_WITH_VALUE DisplayType = 2
	// progress bar
	//
	// x-displayName: "Progress Bar"
	PROGRESS_BAR DisplayType = 3
	// date
	//
	// x-displayName: "Date"
	DATE DisplayType = 4
	// duration
	//
	// x-displayName: "Duration"
	DURATION DisplayType = 5
	// provider icon
	//
	// x-displayName: "Provider Icon"
	PROVIDER_ICON DisplayType = 6
)

var DisplayType_name = map[int32]string{
	0: "DISPLAY_TYPE_NONE",
	1: "ICON",
	2: "DOT_WITH_VALUE",
	3: "PROGRESS_BAR",
	4: "DATE",
	5: "DURATION",
	6: "PROVIDER_ICON",
}

var DisplayType_value = map[string]int32{
	"DISPLAY_TYPE_NONE": 0,
	"ICON":              1,
	"DOT_WITH_VALUE":    2,
	"PROGRESS_BAR":      3,
	"DATE":              4,
	"DURATION":          5,
	"PROVIDER_ICON":     6,
}

func (DisplayType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{1}
}

// WidgetType
//
// x-displayName: "Widget Type"
// Widget Type defines the data type for widget.
type WidgetType int32

const (
	// None
	//
	// x-displayName: "None"
	// None type
	WIDGET_TYPE_NONE WidgetType = 0
	//two_value
	//
	// x-displayName: "Two Value"
	// Two Value type widget
	TWO_VALUE WidgetType = 1
	//distribution_chart
	//
	// x-displayName: "Distribution Chart"
	// Distribution Chart type widget
	DISTRIBUTION_CHART WidgetType = 2
	//table
	//
	// x-displayName: "Table"
	// Table type widget
	TABLE WidgetType = 3
	//list
	//
	// x-displayName: "List"
	// List type widget
	LIST WidgetType = 4
	//grid
	//
	// x-displayName: "Grid"
	// Grid type widget
	GRID WidgetType = 5
	//pie
	//
	// x-displayName: "pie"
	// pie type widget
	PIE WidgetType = 6
)

var WidgetType_name = map[int32]string{
	0: "WIDGET_TYPE_NONE",
	1: "TWO_VALUE",
	2: "DISTRIBUTION_CHART",
	3: "TABLE",
	4: "LIST",
	5: "GRID",
	6: "PIE",
}

var WidgetType_value = map[string]int32{
	"WIDGET_TYPE_NONE":   0,
	"TWO_VALUE":          1,
	"DISTRIBUTION_CHART": 2,
	"TABLE":              3,
	"LIST":               4,
	"GRID":               5,
	"PIE":                6,
}

func (WidgetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{2}
}

// UnitType
//
// x-displayName: "Unit Type"
// Unit Type defines the unit for each fields.
type UnitType int32

const (
	// None
	//
	// x-displayName: "None"
	// None type
	UNIT_TYPE_NONE UnitType = 0
	//GB
	//
	// x-displayName: "GB"
	GB UnitType = 1
	// Percent
	//
	// x-displayName: "Percent"
	PERCENT UnitType = 2
	// Byte
	//
	// x-displayName: "Byte"
	BYTE UnitType = 3
)

var UnitType_name = map[int32]string{
	0: "UNIT_TYPE_NONE",
	1: "GB",
	2: "PERCENT",
	3: "BYTE",
}

var UnitType_value = map[string]int32{
	"UNIT_TYPE_NONE": 0,
	"GB":             1,
	"PERCENT":        2,
	"BYTE":           3,
}

func (UnitType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{3}
}

// FormatType
//
// x-displayName: "Format Type"
// Format Type defines the format type for each fields.
type FormatType int32

const (
	// None
	//
	// x-displayName: "None"
	// No format
	FORMAT_TYPE_NONE FormatType = 0
	// Inline
	//
	// x-displayName: "Inline"
	// Key value to be displayed in inline format
	INLINE FormatType = 1
	// Bold
	//
	// x-displayName: "Bold"
	// Value to be displayed in bold format
	BOLD FormatType = 2
	// ReverseKeyValueOrder
	//
	// x-displayName: "Reverse Key Value Order"
	// Key value to be displayed in Reverse Key Value Order format
	REVERSE_KEY_VALUE_ORDER FormatType = 3
	// Wrap
	//
	// x-displayName: "Wrap"
	// Value to be wrapped
	WRAP FormatType = 4
)

var FormatType_name = map[int32]string{
	0: "FORMAT_TYPE_NONE",
	1: "INLINE",
	2: "BOLD",
	3: "REVERSE_KEY_VALUE_ORDER",
	4: "WRAP",
}

var FormatType_value = map[string]int32{
	"FORMAT_TYPE_NONE":        0,
	"INLINE":                  1,
	"BOLD":                    2,
	"REVERSE_KEY_VALUE_ORDER": 3,
	"WRAP":                    4,
}

func (FormatType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{4}
}

// ColourType
//
// x-displayName: "Colour Type"
// Colour Type defines the colour of fields to be displayed.
type ColourType int32

const (
	// None
	//
	// x-displayName: "None"
	// No colour
	COLOUR_TYPE_NONE ColourType = 0
	// danger
	//
	// x-displayName: "Danger"
	// colour type red
	DANGER ColourType = 1
	// info
	//
	// x-displayName: "Info"
	// colour type blue
	INFO ColourType = 2
	// warning
	//
	// x-displayName: "Warning"
	// colour type orange
	WARNING ColourType = 3
	// amber
	//
	// x-displayName: "Amber"
	// colour type yellow
	AMBER ColourType = 4
	// success
	//
	// x-displayName: "Success"
	// colour type green
	SUCCESS ColourType = 5
	// malibu
	//
	// x-displayName: "Malibu"
	// colour type blue
	MALIBU ColourType = 6
)

var ColourType_name = map[int32]string{
	0: "COLOUR_TYPE_NONE",
	1: "DANGER",
	2: "INFO",
	3: "WARNING",
	4: "AMBER",
	5: "SUCCESS",
	6: "MALIBU",
}

var ColourType_value = map[string]int32{
	"COLOUR_TYPE_NONE": 0,
	"DANGER":           1,
	"INFO":             2,
	"WARNING":          3,
	"AMBER":            4,
	"SUCCESS":          5,
	"MALIBU":           6,
}

func (ColourType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{5}
}

// StatusStyle
//
// x-displayName: "Status Style"
// Status Style defines the colour of status to be displayed.
type StatusStyle int32

const (
	// Unknown
	//
	// x-displayName: "Unkown"
	// No colour
	STATUS_STYLE_UNKNOWN StatusStyle = 0
	// success
	//
	// x-displayName: "Success"
	// colour type green
	STATUS_STYLE_SUCCESS StatusStyle = 1
	// danger
	//
	// x-displayName: "Danger"
	// colour type red
	STATUS_STYLE_DANGER StatusStyle = 2
	// warning
	//
	// x-displayName: "Warning"
	// colour type yellow
	STATUS_STYLE_WARNING StatusStyle = 3
	// inactive
	//
	// x-displayName: "Inactive"
	// colour type grey
	STATUS_STYLE_INACTIVE StatusStyle = 4
	// minor
	//
	// x-displayName: "Minor"
	// colour type blue
	STATUS_STYLE_MINOR StatusStyle = 5
)

var StatusStyle_name = map[int32]string{
	0: "STATUS_STYLE_UNKNOWN",
	1: "STATUS_STYLE_SUCCESS",
	2: "STATUS_STYLE_DANGER",
	3: "STATUS_STYLE_WARNING",
	4: "STATUS_STYLE_INACTIVE",
	5: "STATUS_STYLE_MINOR",
}

var StatusStyle_value = map[string]int32{
	"STATUS_STYLE_UNKNOWN":  0,
	"STATUS_STYLE_SUCCESS":  1,
	"STATUS_STYLE_DANGER":   2,
	"STATUS_STYLE_WARNING":  3,
	"STATUS_STYLE_INACTIVE": 4,
	"STATUS_STYLE_MINOR":    5,
}

func (StatusStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{6}
}

type Display struct {
	// Display Type
	//
	// x-displayName: "Display Type"
	// x-example: "Icon"
	DisplayType DisplayType `protobuf:"varint,1,opt,name=display_type,json=displayType,proto3,enum=ves.io.schema.ai_assistant.common.DisplayType" json:"display_type,omitempty"`
	// format
	//
	// x-displayName: "formats"
	// x-example: "Bold Italic"
	Formats []FormatType `protobuf:"varint,2,rep,packed,name=formats,proto3,enum=ves.io.schema.ai_assistant.common.FormatType" json:"formats,omitempty"`
	// colour
	//
	// x-displayName: "colour"
	// x-example: "Green"
	Colour ColourType `protobuf:"varint,3,opt,name=colour,proto3,enum=ves.io.schema.ai_assistant.common.ColourType" json:"colour,omitempty"`
}

func (m *Display) Reset()      { *m = Display{} }
func (*Display) ProtoMessage() {}
func (*Display) Descriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{0}
}
func (m *Display) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Display) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Display.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Display) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Display.Merge(m, src)
}
func (m *Display) XXX_Size() int {
	return m.Size()
}
func (m *Display) XXX_DiscardUnknown() {
	xxx_messageInfo_Display.DiscardUnknown(m)
}

var xxx_messageInfo_Display proto.InternalMessageInfo

func (m *Display) GetDisplayType() DisplayType {
	if m != nil {
		return m.DisplayType
	}
	return DISPLAY_TYPE_NONE
}

func (m *Display) GetFormats() []FormatType {
	if m != nil {
		return m.Formats
	}
	return nil
}

func (m *Display) GetColour() ColourType {
	if m != nil {
		return m.Colour
	}
	return COLOUR_TYPE_NONE
}

type FieldProperties struct {
	// Name
	//
	// x-displayName: "name"
	// x-example: "provider"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName: "title"
	// x-example: "Site Name"
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// Type
	//
	// x-displayName: "type"
	// x-example: "Bool"
	DataType ColumnType `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3,enum=ves.io.schema.ai_assistant.common.ColumnType" json:"data_type,omitempty"`
	// Unit
	//
	// x-displayName: "unit"
	// x-example: "GB"
	Unit UnitType `protobuf:"varint,4,opt,name=unit,proto3,enum=ves.io.schema.ai_assistant.common.UnitType" json:"unit,omitempty"`
	// Display
	//
	// x-displayName: "display"
	// Display details for the field
	Display *Display `protobuf:"bytes,5,opt,name=display,proto3" json:"display,omitempty"`
	// Tooltip
	//
	// x-displayName: "tooltip"
	// Tooltip for the field
	Tooltip string `protobuf:"bytes,6,opt,name=tooltip,proto3" json:"tooltip,omitempty"`
}

func (m *FieldProperties) Reset()      { *m = FieldProperties{} }
func (*FieldProperties) ProtoMessage() {}
func (*FieldProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{1}
}
func (m *FieldProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldProperties.Merge(m, src)
}
func (m *FieldProperties) XXX_Size() int {
	return m.Size()
}
func (m *FieldProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldProperties.DiscardUnknown(m)
}

var xxx_messageInfo_FieldProperties proto.InternalMessageInfo

func (m *FieldProperties) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldProperties) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *FieldProperties) GetDataType() ColumnType {
	if m != nil {
		return m.DataType
	}
	return COLUMN_TYPE_NONE
}

func (m *FieldProperties) GetUnit() UnitType {
	if m != nil {
		return m.Unit
	}
	return UNIT_TYPE_NONE
}

func (m *FieldProperties) GetDisplay() *Display {
	if m != nil {
		return m.Display
	}
	return nil
}

func (m *FieldProperties) GetTooltip() string {
	if m != nil {
		return m.Tooltip
	}
	return ""
}

type CellProperties struct {
	// Status Style
	//
	// x-displayName "Status Style"
	// Colour Style for status.
	StatusStyle StatusStyle `protobuf:"varint,1,opt,name=status_style,json=statusStyle,proto3,enum=ves.io.schema.ai_assistant.common.StatusStyle" json:"status_style,omitempty"`
}

func (m *CellProperties) Reset()      { *m = CellProperties{} }
func (*CellProperties) ProtoMessage() {}
func (*CellProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_149f11e7568efebf, []int{2}
}
func (m *CellProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CellProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CellProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CellProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CellProperties.Merge(m, src)
}
func (m *CellProperties) XXX_Size() int {
	return m.Size()
}
func (m *CellProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_CellProperties.DiscardUnknown(m)
}

var xxx_messageInfo_CellProperties proto.InternalMessageInfo

func (m *CellProperties) GetStatusStyle() StatusStyle {
	if m != nil {
		return m.StatusStyle
	}
	return STATUS_STYLE_UNKNOWN
}

func init() {
	proto.RegisterEnum("ves.io.schema.ai_assistant.common.ColumnType", ColumnType_name, ColumnType_value)
	golang_proto.RegisterEnum("ves.io.schema.ai_assistant.common.ColumnType", ColumnType_name, ColumnType_value)
	proto.RegisterEnum("ves.io.schema.ai_assistant.common.DisplayType", DisplayType_name, DisplayType_value)
	golang_proto.RegisterEnum("ves.io.schema.ai_assistant.common.DisplayType", DisplayType_name, DisplayType_value)
	proto.RegisterEnum("ves.io.schema.ai_assistant.common.WidgetType", WidgetType_name, WidgetType_value)
	golang_proto.RegisterEnum("ves.io.schema.ai_assistant.common.WidgetType", WidgetType_name, WidgetType_value)
	proto.RegisterEnum("ves.io.schema.ai_assistant.common.UnitType", UnitType_name, UnitType_value)
	golang_proto.RegisterEnum("ves.io.schema.ai_assistant.common.UnitType", UnitType_name, UnitType_value)
	proto.RegisterEnum("ves.io.schema.ai_assistant.common.FormatType", FormatType_name, FormatType_value)
	golang_proto.RegisterEnum("ves.io.schema.ai_assistant.common.FormatType", FormatType_name, FormatType_value)
	proto.RegisterEnum("ves.io.schema.ai_assistant.common.ColourType", ColourType_name, ColourType_value)
	golang_proto.RegisterEnum("ves.io.schema.ai_assistant.common.ColourType", ColourType_name, ColourType_value)
	proto.RegisterEnum("ves.io.schema.ai_assistant.common.StatusStyle", StatusStyle_name, StatusStyle_value)
	golang_proto.RegisterEnum("ves.io.schema.ai_assistant.common.StatusStyle", StatusStyle_name, StatusStyle_value)
	proto.RegisterType((*Display)(nil), "ves.io.schema.ai_assistant.common.Display")
	golang_proto.RegisterType((*Display)(nil), "ves.io.schema.ai_assistant.common.Display")
	proto.RegisterType((*FieldProperties)(nil), "ves.io.schema.ai_assistant.common.FieldProperties")
	golang_proto.RegisterType((*FieldProperties)(nil), "ves.io.schema.ai_assistant.common.FieldProperties")
	proto.RegisterType((*CellProperties)(nil), "ves.io.schema.ai_assistant.common.CellProperties")
	golang_proto.RegisterType((*CellProperties)(nil), "ves.io.schema.ai_assistant.common.CellProperties")
}

func init() {
	proto.RegisterFile("ves.io/schema/ai_assistant/common/types.proto", fileDescriptor_149f11e7568efebf)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/ai_assistant/common/types.proto", fileDescriptor_149f11e7568efebf)
}

var fileDescriptor_149f11e7568efebf = []byte{
	// 933 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0xd6, 0x4a, 0xd4, 0x8f, 0x47, 0x8e, 0xbb, 0xd9, 0x3a, 0x89, 0x9a, 0x16, 0x84, 0xeb, 0x93,
	0xa1, 0xc2, 0x12, 0xe0, 0x9e, 0x8b, 0x82, 0x12, 0xd7, 0xca, 0x26, 0x34, 0xa9, 0x2c, 0x49, 0x0b,
	0xee, 0x85, 0xa0, 0x2d, 0x46, 0x21, 0x2a, 0x89, 0xaa, 0xb8, 0x32, 0xea, 0x53, 0xfb, 0x08, 0x6d,
	0x5f, 0xa2, 0x79, 0x86, 0x9e, 0x72, 0xec, 0xd1, 0xc7, 0x1c, 0x6b, 0xf9, 0xd2, 0xde, 0xf2, 0x04,
	0x45, 0xb1, 0x4b, 0x0a, 0xb6, 0x12, 0x14, 0x71, 0x6e, 0x3b, 0x9a, 0xfd, 0xbe, 0xf9, 0xe6, 0x9b,
	0xa1, 0x16, 0xf6, 0xcf, 0xa3, 0xb4, 0x15, 0x27, 0xed, 0xf4, 0xec, 0x65, 0x34, 0x09, 0xdb, 0x61,
	0x1c, 0x84, 0x69, 0x1a, 0xa7, 0x22, 0x9c, 0x8a, 0xf6, 0x59, 0x32, 0x99, 0x24, 0xd3, 0xb6, 0xb8,
	0x98, 0x45, 0x69, 0x6b, 0x36, 0x4f, 0x44, 0x42, 0xbe, 0xcc, 0xae, 0xb7, 0xb2, 0xeb, 0xad, 0xdb,
	0xd7, 0x5b, 0xd9, 0xf5, 0xc7, 0xfb, 0xa3, 0x58, 0xbc, 0x5c, 0x9c, 0xca, 0xb0, 0x3d, 0x4a, 0x46,
	0x49, 0x5b, 0x21, 0x4f, 0x17, 0x2f, 0x54, 0xa4, 0x02, 0x75, 0xca, 0x18, 0x1f, 0x7f, 0xb1, 0x2e,
	0xe0, 0x3c, 0x1c, 0xc7, 0xc3, 0x50, 0x44, 0x59, 0x76, 0xf7, 0x5f, 0x04, 0x55, 0x33, 0x4e, 0x67,
	0xe3, 0xf0, 0x82, 0x3c, 0x87, 0xcd, 0x61, 0x76, 0x0c, 0xa4, 0xa4, 0x06, 0xda, 0x41, 0x7b, 0x5b,
	0x07, 0xad, 0xd6, 0x07, 0x25, 0xb5, 0x72, 0x06, 0xef, 0x62, 0x16, 0xf1, 0xfa, 0xf0, 0x26, 0x20,
	0x2e, 0x54, 0x5f, 0x24, 0xf3, 0x49, 0x28, 0xd2, 0x46, 0x71, 0xa7, 0xb4, 0xb7, 0x75, 0xb0, 0x7f,
	0x07, 0xb6, 0x43, 0x85, 0x90, 0xf8, 0x0e, 0xfc, 0xf1, 0xcf, 0xeb, 0x52, 0xf9, 0x37, 0x54, 0x6c,
	0x20, 0xbe, 0x62, 0x22, 0x14, 0x2a, 0x67, 0xc9, 0x38, 0x59, 0xcc, 0x1b, 0x25, 0xa5, 0xf0, 0x2e,
	0x9c, 0x5d, 0x05, 0x50, 0x02, 0x73, 0xf0, 0x53, 0xad, 0xa6, 0xe1, 0xf2, 0xee, 0xab, 0x22, 0x7c,
	0x72, 0x18, 0x47, 0xe3, 0x61, 0x7f, 0x9e, 0xcc, 0xa2, 0xb9, 0x88, 0xa3, 0x94, 0x10, 0xd0, 0xa6,
	0xe1, 0x24, 0x33, 0x60, 0x83, 0xab, 0x33, 0xd9, 0x86, 0xb2, 0x88, 0xc5, 0x38, 0x6a, 0x14, 0xd5,
	0x8f, 0x59, 0x40, 0x9e, 0xc2, 0xc6, 0x30, 0x14, 0x61, 0xe6, 0xd7, 0x47, 0xa9, 0x59, 0x4c, 0xa6,
	0x4a, 0x4d, 0x4d, 0xe2, 0x95, 0x57, 0xdf, 0x82, 0xb6, 0x98, 0xc6, 0xa2, 0xa1, 0x29, 0x9a, 0xaf,
	0xee, 0x40, 0xe3, 0x4f, 0x63, 0x65, 0x13, 0x57, 0x40, 0x62, 0x42, 0x35, 0xf7, 0xbe, 0x51, 0xde,
	0x41, 0x7b, 0xf5, 0x83, 0xe6, 0xdd, 0x47, 0xc7, 0x57, 0x50, 0xd2, 0x80, 0xaa, 0x48, 0x92, 0xb1,
	0x88, 0x67, 0x8d, 0x8a, 0x6a, 0x75, 0x15, 0xee, 0x9e, 0xc1, 0x56, 0x37, 0x1a, 0x8f, 0x6f, 0x19,
	0xf5, 0x1c, 0x36, 0x53, 0x11, 0x8a, 0x45, 0x1a, 0xa4, 0xe2, 0x62, 0xfc, 0x31, 0x1b, 0xe3, 0x2a,
	0x98, 0x2b, 0x51, 0xbc, 0x9e, 0xde, 0x04, 0x4d, 0x0b, 0xe0, 0xc6, 0x1d, 0xb2, 0x0d, 0xb8, 0xeb,
	0x58, 0xfe, 0x91, 0x1d, 0x78, 0x27, 0x7d, 0x1a, 0xd8, 0x8e, 0x4d, 0x71, 0x81, 0x00, 0x54, 0x5c,
	0x8f, 0x33, 0xbb, 0x87, 0x11, 0xa9, 0x42, 0x89, 0xd9, 0x1e, 0x2e, 0x92, 0x0d, 0x28, 0x1f, 0x5a,
	0x8e, 0xe1, 0xe1, 0x12, 0xa9, 0x81, 0xd6, 0x71, 0x1c, 0x0b, 0x6b, 0xcd, 0x9f, 0xa0, 0x7e, 0x6b,
	0x37, 0xc9, 0x03, 0xb8, 0x6f, 0x32, 0xb7, 0x6f, 0x19, 0x27, 0x6b, 0x7c, 0x35, 0xd0, 0x58, 0xd7,
	0xb1, 0x31, 0x22, 0x04, 0xb6, 0x4c, 0xc7, 0x0b, 0x06, 0xcc, 0x7b, 0x12, 0x1c, 0x1b, 0x96, 0x4f,
	0x71, 0x91, 0x60, 0xd8, 0xec, 0x73, 0xa7, 0xc7, 0xa9, 0xeb, 0x06, 0x1d, 0x83, 0x67, 0xfc, 0xa6,
	0xe1, 0x51, 0xac, 0x91, 0x4d, 0xa8, 0x99, 0x3e, 0x37, 0x3c, 0xe6, 0xd8, 0xb8, 0x4c, 0xee, 0xc3,
	0xbd, 0x3e, 0x77, 0x8e, 0x99, 0x49, 0x79, 0xa0, 0x08, 0x2b, 0xcd, 0x1f, 0x00, 0x06, 0xf1, 0x70,
	0x14, 0x89, 0x55, 0x3b, 0x03, 0x66, 0xf6, 0xa8, 0xb7, 0x56, 0xfe, 0x1e, 0x6c, 0x78, 0x03, 0x27,
	0xaf, 0x87, 0xc8, 0x43, 0x20, 0x26, 0x93, 0xfd, 0x75, 0x7c, 0xc9, 0x1b, 0x74, 0x9f, 0x18, 0x3c,
	0x6f, 0xd0, 0x33, 0x3a, 0x16, 0xcd, 0x04, 0x58, 0xcc, 0xf5, 0xb0, 0x26, 0x4f, 0x3d, 0xce, 0x4c,
	0x5c, 0x96, 0x46, 0xf4, 0x19, 0xc5, 0x95, 0xe6, 0x37, 0x50, 0x5b, 0x2d, 0x86, 0xec, 0xc7, 0xb7,
	0xd9, 0x7a, 0xb9, 0x0a, 0x14, 0x7b, 0x1d, 0x8c, 0x48, 0x1d, 0xaa, 0x7d, 0xca, 0xbb, 0x54, 0xb9,
	0x27, 0x2d, 0x3b, 0xf1, 0x28, 0x2e, 0x35, 0x03, 0x80, 0x9b, 0x0f, 0x50, 0x2a, 0x3e, 0x74, 0xf8,
	0x91, 0xe1, 0xbd, 0x3b, 0x00, 0x66, 0x5b, 0xcc, 0x96, 0x72, 0x95, 0xd9, 0x96, 0x89, 0x8b, 0xe4,
	0x73, 0x78, 0xc4, 0xe9, 0x31, 0xe5, 0x2e, 0x0d, 0x9e, 0xd1, 0x93, 0xac, 0x9f, 0xc0, 0xe1, 0x26,
	0xcd, 0x3d, 0x1b, 0x70, 0xa3, 0x8f, 0xb5, 0x66, 0xac, 0x26, 0x9c, 0x7f, 0x8d, 0xf9, 0x84, 0x1d,
	0x9f, 0xbf, 0x5b, 0xc0, 0x34, 0xec, 0x1e, 0xe5, 0x59, 0x01, 0x66, 0x1f, 0x3a, 0xb8, 0x28, 0x15,
	0x0f, 0x0c, 0x6e, 0xcb, 0xc1, 0x97, 0xa4, 0x1d, 0xc6, 0x51, 0x87, 0x72, 0xac, 0xc9, 0xdf, 0x5d,
	0xbf, 0xdb, 0xa5, 0xae, 0x8b, 0xcb, 0x12, 0x7a, 0x64, 0x58, 0xac, 0xe3, 0xe3, 0x4a, 0xf3, 0x77,
	0x04, 0xf5, 0x5b, 0x9b, 0x46, 0x1a, 0xb0, 0xed, 0x7a, 0x86, 0xe7, 0xbb, 0x81, 0xeb, 0x9d, 0x58,
	0x34, 0xf0, 0xed, 0x67, 0xb6, 0x33, 0xb0, 0x71, 0xe1, 0xbd, 0xcc, 0x8a, 0x0f, 0x91, 0x47, 0xf0,
	0xe9, 0x5a, 0x26, 0xd7, 0x55, 0x7c, 0x0f, 0x72, 0x23, 0xed, 0x33, 0x78, 0xb0, 0x96, 0x61, 0xb6,
	0xd1, 0xf5, 0xd8, 0xb1, 0x5c, 0x98, 0x87, 0x40, 0xd6, 0x52, 0x47, 0xcc, 0x76, 0x38, 0x2e, 0x77,
	0x7e, 0x45, 0x97, 0x57, 0x7a, 0xe1, 0xcd, 0x95, 0x5e, 0x78, 0x7b, 0xa5, 0xa3, 0x9f, 0x97, 0x3a,
	0x7a, 0xb5, 0xd4, 0xd1, 0x9f, 0x4b, 0x1d, 0x5d, 0x2e, 0x75, 0xf4, 0xd7, 0x52, 0x47, 0x7f, 0x2f,
	0xf5, 0xc2, 0xdb, 0xa5, 0x8e, 0x7e, 0xb9, 0xd6, 0x0b, 0xaf, 0xaf, 0x75, 0x74, 0x79, 0xad, 0x17,
	0xde, 0x5c, 0xeb, 0x85, 0xef, 0x06, 0xa3, 0x64, 0xf6, 0xfd, 0xa8, 0x75, 0x9e, 0x8c, 0x45, 0x34,
	0x9f, 0x87, 0xad, 0x45, 0xda, 0x56, 0x07, 0xf9, 0x77, 0xb9, 0x3f, 0x9b, 0x27, 0xe7, 0xf1, 0x30,
	0x9a, 0xef, 0xaf, 0xd2, 0xed, 0xd9, 0xe9, 0x28, 0x69, 0x47, 0x3f, 0x8a, 0xfc, 0x3d, 0xf8, 0xff,
	0x77, 0xe9, 0xb4, 0xa2, 0x9e, 0x88, 0xaf, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xa3, 0x09, 0x57,
	0x86, 0xc3, 0x06, 0x00, 0x00,
}

func (x ColumnType) String() string {
	s, ok := ColumnType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DisplayType) String() string {
	s, ok := DisplayType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x WidgetType) String() string {
	s, ok := WidgetType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x UnitType) String() string {
	s, ok := UnitType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FormatType) String() string {
	s, ok := FormatType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ColourType) String() string {
	s, ok := ColourType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StatusStyle) String() string {
	s, ok := StatusStyle_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Display) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Display)
	if !ok {
		that2, ok := that.(Display)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DisplayType != that1.DisplayType {
		return false
	}
	if len(this.Formats) != len(that1.Formats) {
		return false
	}
	for i := range this.Formats {
		if this.Formats[i] != that1.Formats[i] {
			return false
		}
	}
	if this.Colour != that1.Colour {
		return false
	}
	return true
}
func (this *FieldProperties) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldProperties)
	if !ok {
		that2, ok := that.(FieldProperties)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.DataType != that1.DataType {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	if !this.Display.Equal(that1.Display) {
		return false
	}
	if this.Tooltip != that1.Tooltip {
		return false
	}
	return true
}
func (this *CellProperties) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CellProperties)
	if !ok {
		that2, ok := that.(CellProperties)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StatusStyle != that1.StatusStyle {
		return false
	}
	return true
}
func (this *Display) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&common.Display{")
	s = append(s, "DisplayType: "+fmt.Sprintf("%#v", this.DisplayType)+",\n")
	s = append(s, "Formats: "+fmt.Sprintf("%#v", this.Formats)+",\n")
	s = append(s, "Colour: "+fmt.Sprintf("%#v", this.Colour)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FieldProperties) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&common.FieldProperties{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "DataType: "+fmt.Sprintf("%#v", this.DataType)+",\n")
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	if this.Display != nil {
		s = append(s, "Display: "+fmt.Sprintf("%#v", this.Display)+",\n")
	}
	s = append(s, "Tooltip: "+fmt.Sprintf("%#v", this.Tooltip)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CellProperties) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&common.CellProperties{")
	s = append(s, "StatusStyle: "+fmt.Sprintf("%#v", this.StatusStyle)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Display) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Display) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Display) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Colour != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Colour))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Formats) > 0 {
		dAtA2 := make([]byte, len(m.Formats)*10)
		var j1 int
		for _, num := range m.Formats {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if m.DisplayType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DisplayType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldProperties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldProperties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tooltip) > 0 {
		i -= len(m.Tooltip)
		copy(dAtA[i:], m.Tooltip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tooltip)))
		i--
		dAtA[i] = 0x32
	}
	if m.Display != nil {
		{
			size, err := m.Display.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Unit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x20
	}
	if m.DataType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CellProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellProperties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CellProperties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StatusStyle != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StatusStyle))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Display) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisplayType != 0 {
		n += 1 + sovTypes(uint64(m.DisplayType))
	}
	if len(m.Formats) > 0 {
		l = 0
		for _, e := range m.Formats {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.Colour != 0 {
		n += 1 + sovTypes(uint64(m.Colour))
	}
	return n
}

func (m *FieldProperties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DataType != 0 {
		n += 1 + sovTypes(uint64(m.DataType))
	}
	if m.Unit != 0 {
		n += 1 + sovTypes(uint64(m.Unit))
	}
	if m.Display != nil {
		l = m.Display.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Tooltip)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CellProperties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusStyle != 0 {
		n += 1 + sovTypes(uint64(m.StatusStyle))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Display) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Display{`,
		`DisplayType:` + fmt.Sprintf("%v", this.DisplayType) + `,`,
		`Formats:` + fmt.Sprintf("%v", this.Formats) + `,`,
		`Colour:` + fmt.Sprintf("%v", this.Colour) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldProperties) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FieldProperties{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`Display:` + strings.Replace(this.Display.String(), "Display", "Display", 1) + `,`,
		`Tooltip:` + fmt.Sprintf("%v", this.Tooltip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CellProperties) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CellProperties{`,
		`StatusStyle:` + fmt.Sprintf("%v", this.StatusStyle) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Display) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Display: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Display: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayType", wireType)
			}
			m.DisplayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisplayType |= DisplayType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v FormatType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FormatType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Formats = append(m.Formats, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Formats) == 0 {
					m.Formats = make([]FormatType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FormatType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FormatType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Formats = append(m.Formats, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Formats", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Colour", wireType)
			}
			m.Colour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Colour |= ColourType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= ColumnType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= UnitType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Display == nil {
				m.Display = &Display{}
			}
			if err := m.Display.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tooltip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tooltip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusStyle", wireType)
			}
			m.StatusStyle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusStyle |= StatusStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
