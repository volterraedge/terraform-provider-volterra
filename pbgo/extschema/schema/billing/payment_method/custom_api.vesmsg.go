// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package payment_method

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreatePaymentMethodRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreatePaymentMethodRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreatePaymentMethodRequest) DeepCopy() *CreatePaymentMethodRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreatePaymentMethodRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreatePaymentMethodRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreatePaymentMethodRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreatePaymentMethodRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCreatePaymentMethodRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreatePaymentMethodRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreatePaymentMethodRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreatePaymentMethodRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["contact"]; exists {

		vOpts := append(opts, db.WithValidateField("contact"))
		if err := fv(ctx, m.GetContact(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		if err := fv(ctx, m.GetRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["token"]; exists {

		vOpts := append(opts, db.WithValidateField("token"))
		if err := fv(ctx, m.GetToken(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreatePaymentMethodRequestValidator = func() *ValidateCreatePaymentMethodRequest {
	v := &ValidateCreatePaymentMethodRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CreatePaymentMethodRequestValidator() db.Validator {
	return DefaultCreatePaymentMethodRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CreatePaymentMethodResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreatePaymentMethodResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreatePaymentMethodResponse) DeepCopy() *CreatePaymentMethodResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreatePaymentMethodResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreatePaymentMethodResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreatePaymentMethodResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreatePaymentMethodResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCreatePaymentMethodResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreatePaymentMethodResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreatePaymentMethodResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreatePaymentMethodResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreatePaymentMethodResponseValidator = func() *ValidateCreatePaymentMethodResponse {
	v := &ValidateCreatePaymentMethodResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CreatePaymentMethodResponseValidator() db.Validator {
	return DefaultCreatePaymentMethodResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *DeletePaymentMethodRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeletePaymentMethodRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeletePaymentMethodRequest) DeepCopy() *DeletePaymentMethodRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeletePaymentMethodRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeletePaymentMethodRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeletePaymentMethodRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeletePaymentMethodRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDeletePaymentMethodRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeletePaymentMethodRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeletePaymentMethodRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeletePaymentMethodRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeletePaymentMethodRequestValidator = func() *ValidateDeletePaymentMethodRequest {
	v := &ValidateDeletePaymentMethodRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeletePaymentMethodRequestValidator() db.Validator {
	return DefaultDeletePaymentMethodRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *PaymentMethodPrimaryReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PaymentMethodPrimaryReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PaymentMethodPrimaryReq) DeepCopy() *PaymentMethodPrimaryReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PaymentMethodPrimaryReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PaymentMethodPrimaryReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PaymentMethodPrimaryReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PaymentMethodPrimaryReqValidator().Validate(ctx, m, opts...)
}

type ValidatePaymentMethodPrimaryReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePaymentMethodPrimaryReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PaymentMethodPrimaryReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PaymentMethodPrimaryReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPaymentMethodPrimaryReqValidator = func() *ValidatePaymentMethodPrimaryReq {
	v := &ValidatePaymentMethodPrimaryReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PaymentMethodPrimaryReqValidator() db.Validator {
	return DefaultPaymentMethodPrimaryReqValidator
}

// augmented methods on protoc/std generated struct

func (m *PaymentMethodRoleChangeRes) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PaymentMethodRoleChangeRes) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PaymentMethodRoleChangeRes) DeepCopy() *PaymentMethodRoleChangeRes {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PaymentMethodRoleChangeRes{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PaymentMethodRoleChangeRes) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PaymentMethodRoleChangeRes) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PaymentMethodRoleChangeResValidator().Validate(ctx, m, opts...)
}

type ValidatePaymentMethodRoleChangeRes struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePaymentMethodRoleChangeRes) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PaymentMethodRoleChangeRes)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PaymentMethodRoleChangeRes got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPaymentMethodRoleChangeResValidator = func() *ValidatePaymentMethodRoleChangeRes {
	v := &ValidatePaymentMethodRoleChangeRes{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PaymentMethodRoleChangeResValidator() db.Validator {
	return DefaultPaymentMethodRoleChangeResValidator
}

// augmented methods on protoc/std generated struct

func (m *PaymentMethodRoleSwapReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PaymentMethodRoleSwapReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PaymentMethodRoleSwapReq) DeepCopy() *PaymentMethodRoleSwapReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PaymentMethodRoleSwapReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PaymentMethodRoleSwapReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PaymentMethodRoleSwapReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PaymentMethodRoleSwapReqValidator().Validate(ctx, m, opts...)
}

type ValidatePaymentMethodRoleSwapReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePaymentMethodRoleSwapReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PaymentMethodRoleSwapReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PaymentMethodRoleSwapReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPaymentMethodRoleSwapReqValidator = func() *ValidatePaymentMethodRoleSwapReq {
	v := &ValidatePaymentMethodRoleSwapReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PaymentMethodRoleSwapReqValidator() db.Validator {
	return DefaultPaymentMethodRoleSwapReqValidator
}

// augmented methods on protoc/std generated struct

func (m *PaymentMethodSecondaryReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PaymentMethodSecondaryReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PaymentMethodSecondaryReq) DeepCopy() *PaymentMethodSecondaryReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PaymentMethodSecondaryReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PaymentMethodSecondaryReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PaymentMethodSecondaryReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PaymentMethodSecondaryReqValidator().Validate(ctx, m, opts...)
}

type ValidatePaymentMethodSecondaryReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePaymentMethodSecondaryReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PaymentMethodSecondaryReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PaymentMethodSecondaryReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPaymentMethodSecondaryReqValidator = func() *ValidatePaymentMethodSecondaryReq {
	v := &ValidatePaymentMethodSecondaryReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PaymentMethodSecondaryReqValidator() db.Validator {
	return DefaultPaymentMethodSecondaryReqValidator
}
