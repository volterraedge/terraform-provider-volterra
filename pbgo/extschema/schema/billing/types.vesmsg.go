// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package billing

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *BillingFeatureData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BillingFeatureData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BillingFeatureData) DeepCopy() *BillingFeatureData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BillingFeatureData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BillingFeatureData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BillingFeatureData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BillingFeatureDataValidator().Validate(ctx, m, opts...)
}

type ValidateBillingFeatureData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBillingFeatureData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BillingFeatureData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BillingFeatureData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["duration"]; exists {

		vOpts := append(opts, db.WithValidateField("duration"))
		for idx, item := range m.GetDuration() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBillingFeatureDataValidator = func() *ValidateBillingFeatureData {
	v := &ValidateBillingFeatureData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BillingFeatureDataValidator() db.Validator {
	return DefaultBillingFeatureDataValidator
}

// augmented methods on protoc/std generated struct

func (m *BillingFeatureId) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BillingFeatureId) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BillingFeatureId) DeepCopy() *BillingFeatureId {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BillingFeatureId{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BillingFeatureId) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BillingFeatureId) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BillingFeatureIdValidator().Validate(ctx, m, opts...)
}

type ValidateBillingFeatureId struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBillingFeatureId) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BillingFeatureId)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BillingFeatureId got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["certified_hardware"]; exists {

		vOpts := append(opts, db.WithValidateField("certified_hardware"))
		if err := fv(ctx, m.GetCertifiedHardware(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certified_hardware_type"]; exists {

		vOpts := append(opts, db.WithValidateField("certified_hardware_type"))
		if err := fv(ctx, m.GetCertifiedHardwareType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["feature_type"]; exists {

		vOpts := append(opts, db.WithValidateField("feature_type"))
		if err := fv(ctx, m.GetFeatureType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_flavor"]; exists {

		vOpts := append(opts, db.WithValidateField("node_flavor"))
		if err := fv(ctx, m.GetNodeFlavor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBillingFeatureIdValidator = func() *ValidateBillingFeatureId {
	v := &ValidateBillingFeatureId{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BillingFeatureIdValidator() db.Validator {
	return DefaultBillingFeatureIdValidator
}

// augmented methods on protoc/std generated struct

func (m *BillingUsageData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BillingUsageData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BillingUsageData) DeepCopy() *BillingUsageData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BillingUsageData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BillingUsageData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BillingUsageData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BillingUsageDataValidator().Validate(ctx, m, opts...)
}

type ValidateBillingUsageData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBillingUsageData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BillingUsageData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BillingUsageData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["duration"]; exists {

		vOpts := append(opts, db.WithValidateField("duration"))
		for idx, item := range m.GetDuration() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBillingUsageDataValidator = func() *ValidateBillingUsageData {
	v := &ValidateBillingUsageData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BillingUsageDataValidator() db.Validator {
	return DefaultBillingUsageDataValidator
}

// augmented methods on protoc/std generated struct

func (m *BillingUsageId) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BillingUsageId) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BillingUsageId) DeepCopy() *BillingUsageId {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BillingUsageId{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BillingUsageId) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BillingUsageId) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BillingUsageIdValidator().Validate(ctx, m, opts...)
}

type ValidateBillingUsageId struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBillingUsageId) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BillingUsageId)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BillingUsageId got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["certified_hardware"]; exists {

		vOpts := append(opts, db.WithValidateField("certified_hardware"))
		if err := fv(ctx, m.GetCertifiedHardware(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certified_hardware_type"]; exists {

		vOpts := append(opts, db.WithValidateField("certified_hardware_type"))
		if err := fv(ctx, m.GetCertifiedHardwareType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["feature_type"]; exists {

		vOpts := append(opts, db.WithValidateField("feature_type"))
		if err := fv(ctx, m.GetFeatureType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["instance"]; exists {

		vOpts := append(opts, db.WithValidateField("instance"))
		if err := fv(ctx, m.GetInstance(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pvc_size"]; exists {

		vOpts := append(opts, db.WithValidateField("pvc_size"))
		if err := fv(ctx, m.GetPvcSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBillingUsageIdValidator = func() *ValidateBillingUsageId {
	v := &ValidateBillingUsageId{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BillingUsageIdValidator() db.Validator {
	return DefaultBillingUsageIdValidator
}

// augmented methods on protoc/std generated struct

func (m *LoadBalancerMetricData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoadBalancerMetricData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoadBalancerMetricData) DeepCopy() *LoadBalancerMetricData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoadBalancerMetricData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoadBalancerMetricData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoadBalancerMetricData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoadBalancerMetricDataValidator().Validate(ctx, m, opts...)
}

type ValidateLoadBalancerMetricData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoadBalancerMetricData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoadBalancerMetricData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoadBalancerMetricData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unit"]; exists {

		vOpts := append(opts, db.WithValidateField("unit"))
		if err := fv(ctx, m.GetUnit(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoadBalancerMetricDataValidator = func() *ValidateLoadBalancerMetricData {
	v := &ValidateLoadBalancerMetricData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LoadBalancerMetricDataValidator() db.Validator {
	return DefaultLoadBalancerMetricDataValidator
}

// augmented methods on protoc/std generated struct

func (m *MetricLabelFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MetricLabelFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MetricLabelFilter) DeepCopy() *MetricLabelFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MetricLabelFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MetricLabelFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MetricLabelFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetricLabelFilterValidator().Validate(ctx, m, opts...)
}

type ValidateMetricLabelFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMetricLabelFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MetricLabelFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MetricLabelFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label"]; exists {

		vOpts := append(opts, db.WithValidateField("label"))
		if err := fv(ctx, m.GetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetricLabelFilterValidator = func() *ValidateMetricLabelFilter {
	v := &ValidateMetricLabelFilter{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MetricLabelFilterValidator() db.Validator {
	return DefaultMetricLabelFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *MetricValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MetricValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MetricValue) DeepCopy() *MetricValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MetricValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MetricValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MetricValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MetricValueValidator().Validate(ctx, m, opts...)
}

type ValidateMetricValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMetricValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MetricValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MetricValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("timestamp"))
		if err := fv(ctx, m.GetTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMetricValueValidator = func() *ValidateMetricValue {
	v := &ValidateMetricValue{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MetricValueValidator() db.Validator {
	return DefaultMetricValueValidator
}

// augmented methods on protoc/std generated struct

func (m *SecretManagementData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecretManagementData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecretManagementData) DeepCopy() *SecretManagementData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecretManagementData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecretManagementData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecretManagementData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecretManagementDataValidator().Validate(ctx, m, opts...)
}

type ValidateSecretManagementData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecretManagementData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecretManagementData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecretManagementData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metric"]; exists {

		vOpts := append(opts, db.WithValidateField("metric"))
		for idx, item := range m.GetMetric() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecretManagementDataValidator = func() *ValidateSecretManagementData {
	v := &ValidateSecretManagementData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SecretManagementDataValidator() db.Validator {
	return DefaultSecretManagementDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SecretManagementId) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecretManagementId) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecretManagementId) DeepCopy() *SecretManagementId {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecretManagementId{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecretManagementId) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecretManagementId) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecretManagementIdValidator().Validate(ctx, m, opts...)
}

type ValidateSecretManagementId struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecretManagementId) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecretManagementId)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecretManagementId got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("api_namespace"))
		if err := fv(ctx, m.GetApiNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["api_type"]; exists {

		vOpts := append(opts, db.WithValidateField("api_type"))
		if err := fv(ctx, m.GetApiType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecretManagementIdValidator = func() *ValidateSecretManagementId {
	v := &ValidateSecretManagementId{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SecretManagementIdValidator() db.Validator {
	return DefaultSecretManagementIdValidator
}

// augmented methods on protoc/std generated struct

func (m *SecretManagementLabelFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecretManagementLabelFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecretManagementLabelFilter) DeepCopy() *SecretManagementLabelFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecretManagementLabelFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecretManagementLabelFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecretManagementLabelFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecretManagementLabelFilterValidator().Validate(ctx, m, opts...)
}

type ValidateSecretManagementLabelFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecretManagementLabelFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecretManagementLabelFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecretManagementLabelFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label"]; exists {

		vOpts := append(opts, db.WithValidateField("label"))
		if err := fv(ctx, m.GetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecretManagementLabelFilterValidator = func() *ValidateSecretManagementLabelFilter {
	v := &ValidateSecretManagementLabelFilter{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SecretManagementLabelFilterValidator() db.Validator {
	return DefaultSecretManagementLabelFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteId) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteId) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteId) DeepCopy() *SiteId {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteId{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteId) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteId) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteIdValidator().Validate(ctx, m, opts...)
}

type ValidateSiteId struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteId) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteId)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteId got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteIdValidator = func() *ValidateSiteId {
	v := &ValidateSiteId{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteIdValidator() db.Validator {
	return DefaultSiteIdValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteTrafficData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteTrafficData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteTrafficData) DeepCopy() *SiteTrafficData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteTrafficData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteTrafficData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteTrafficData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteTrafficDataValidator().Validate(ctx, m, opts...)
}

type ValidateSiteTrafficData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteTrafficData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteTrafficData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteTrafficData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bytes"]; exists {

		vOpts := append(opts, db.WithValidateField("bytes"))
		for idx, item := range m.GetBytes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dst_site"]; exists {

		vOpts := append(opts, db.WithValidateField("dst_site"))
		if err := fv(ctx, m.GetDstSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["src_site"]; exists {

		vOpts := append(opts, db.WithValidateField("src_site"))
		if err := fv(ctx, m.GetSrcSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteTrafficDataValidator = func() *ValidateSiteTrafficData {
	v := &ValidateSiteTrafficData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteTrafficDataValidator() db.Validator {
	return DefaultSiteTrafficDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteUsageCount) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteUsageCount) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteUsageCount) DeepCopy() *SiteUsageCount {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteUsageCount{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteUsageCount) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteUsageCount) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteUsageCountValidator().Validate(ctx, m, opts...)
}

type ValidateSiteUsageCount struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteUsageCount) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteUsageCount)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteUsageCount got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count_by_certified_hardware"]; exists {

		vOpts := append(opts, db.WithValidateField("count_by_certified_hardware"))
		for key, value := range m.GetCountByCertifiedHardware() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteUsageCountValidator = func() *ValidateSiteUsageCount {
	v := &ValidateSiteUsageCount{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteUsageCountValidator() db.Validator {
	return DefaultSiteUsageCountValidator
}

// augmented methods on protoc/std generated struct

func (m *SyntheticMonitorInvocationsData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SyntheticMonitorInvocationsData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SyntheticMonitorInvocationsData) DeepCopy() *SyntheticMonitorInvocationsData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SyntheticMonitorInvocationsData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SyntheticMonitorInvocationsData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SyntheticMonitorInvocationsData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SyntheticMonitorInvocationsDataValidator().Validate(ctx, m, opts...)
}

type ValidateSyntheticMonitorInvocationsData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSyntheticMonitorInvocationsData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SyntheticMonitorInvocationsData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SyntheticMonitorInvocationsData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metric"]; exists {

		vOpts := append(opts, db.WithValidateField("metric"))
		for idx, item := range m.GetMetric() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSyntheticMonitorInvocationsDataValidator = func() *ValidateSyntheticMonitorInvocationsData {
	v := &ValidateSyntheticMonitorInvocationsData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SyntheticMonitorInvocationsDataValidator() db.Validator {
	return DefaultSyntheticMonitorInvocationsDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SyntheticMonitorInvocationsId) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SyntheticMonitorInvocationsId) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SyntheticMonitorInvocationsId) DeepCopy() *SyntheticMonitorInvocationsId {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SyntheticMonitorInvocationsId{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SyntheticMonitorInvocationsId) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SyntheticMonitorInvocationsId) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SyntheticMonitorInvocationsIdValidator().Validate(ctx, m, opts...)
}

type ValidateSyntheticMonitorInvocationsId struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSyntheticMonitorInvocationsId) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SyntheticMonitorInvocationsId)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SyntheticMonitorInvocationsId got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["synthetic_monitor_type"]; exists {

		vOpts := append(opts, db.WithValidateField("synthetic_monitor_type"))
		if err := fv(ctx, m.GetSyntheticMonitorType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSyntheticMonitorInvocationsIdValidator = func() *ValidateSyntheticMonitorInvocationsId {
	v := &ValidateSyntheticMonitorInvocationsId{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SyntheticMonitorInvocationsIdValidator() db.Validator {
	return DefaultSyntheticMonitorInvocationsIdValidator
}

// augmented methods on protoc/std generated struct

func (m *UsageCountData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UsageCountData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UsageCountData) DeepCopy() *UsageCountData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UsageCountData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UsageCountData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UsageCountData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UsageCountDataValidator().Validate(ctx, m, opts...)
}

type ValidateUsageCountData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUsageCountData) CountChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for count_choice")
	}
	return validatorFn, nil
}

func (v *ValidateUsageCountData) FieldValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for field")
	}

	return validatorFn, nil
}

func (v *ValidateUsageCountData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UsageCountData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UsageCountData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count_choice"]; exists {
		val := m.GetCountChoice()
		vOpts := append(opts,
			db.WithValidateField("count_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCountChoice().(type) {
	case *UsageCountData_Count:
		if fv, exists := v.FldValidators["count_choice.count"]; exists {
			val := m.GetCountChoice().(*UsageCountData_Count).Count
			vOpts := append(opts,
				db.WithValidateField("count_choice"),
				db.WithValidateField("count"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UsageCountData_Site:
		if fv, exists := v.FldValidators["count_choice.site"]; exists {
			val := m.GetCountChoice().(*UsageCountData_Site).Site
			vOpts := append(opts,
				db.WithValidateField("count_choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["field"]; exists {

		vOpts := append(opts, db.WithValidateField("field"))
		if err := fv(ctx, m.GetField(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUsageCountDataValidator = func() *ValidateUsageCountData {
	v := &ValidateUsageCountData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCountChoice := v.CountChoiceValidationRuleHandler
	rulesCountChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCountChoice(rulesCountChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UsageCountData.count_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["count_choice"] = vFn

	vrhField := v.FieldValidationRuleHandler
	rulesField := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhField(rulesField)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UsageCountData.field: %s", err)
		panic(errMsg)
	}
	v.FldValidators["field"] = vFn

	return v
}()

func UsageCountDataValidator() db.Validator {
	return DefaultUsageCountDataValidator
}

// augmented methods on protoc/std generated struct

func (m *VolterraNWTrafficData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolterraNWTrafficData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolterraNWTrafficData) DeepCopy() *VolterraNWTrafficData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolterraNWTrafficData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolterraNWTrafficData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolterraNWTrafficData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolterraNWTrafficDataValidator().Validate(ctx, m, opts...)
}

type ValidateVolterraNWTrafficData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolterraNWTrafficData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolterraNWTrafficData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolterraNWTrafficData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metric"]; exists {

		vOpts := append(opts, db.WithValidateField("metric"))
		for idx, item := range m.GetMetric() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolterraNWTrafficDataValidator = func() *ValidateVolterraNWTrafficData {
	v := &ValidateVolterraNWTrafficData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VolterraNWTrafficDataValidator() db.Validator {
	return DefaultVolterraNWTrafficDataValidator
}

// augmented methods on protoc/std generated struct

func (m *VolterraNWTrafficId) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolterraNWTrafficId) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolterraNWTrafficId) DeepCopy() *VolterraNWTrafficId {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolterraNWTrafficId{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolterraNWTrafficId) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolterraNWTrafficId) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolterraNWTrafficIdValidator().Validate(ctx, m, opts...)
}

type ValidateVolterraNWTrafficId struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolterraNWTrafficId) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolterraNWTrafficId)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolterraNWTrafficId got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dst_site"]; exists {

		vOpts := append(opts, db.WithValidateField("dst_site"))
		if err := fv(ctx, m.GetDstSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["src_site"]; exists {

		vOpts := append(opts, db.WithValidateField("src_site"))
		if err := fv(ctx, m.GetSrcSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolterraNWTrafficIdValidator = func() *ValidateVolterraNWTrafficId {
	v := &ValidateVolterraNWTrafficId{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VolterraNWTrafficIdValidator() db.Validator {
	return DefaultVolterraNWTrafficIdValidator
}

// augmented methods on protoc/std generated struct

func (m *VolterraNWTrafficLabelFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolterraNWTrafficLabelFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolterraNWTrafficLabelFilter) DeepCopy() *VolterraNWTrafficLabelFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolterraNWTrafficLabelFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolterraNWTrafficLabelFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolterraNWTrafficLabelFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolterraNWTrafficLabelFilterValidator().Validate(ctx, m, opts...)
}

type ValidateVolterraNWTrafficLabelFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolterraNWTrafficLabelFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolterraNWTrafficLabelFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolterraNWTrafficLabelFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label"]; exists {

		vOpts := append(opts, db.WithValidateField("label"))
		if err := fv(ctx, m.GetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolterraNWTrafficLabelFilterValidator = func() *ValidateVolterraNWTrafficLabelFilter {
	v := &ValidateVolterraNWTrafficLabelFilter{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VolterraNWTrafficLabelFilterValidator() db.Validator {
	return DefaultVolterraNWTrafficLabelFilterValidator
}
