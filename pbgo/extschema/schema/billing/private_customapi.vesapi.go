// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package billing

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomPrivateAPI GRPC Client satisfying server.CustomClient
type CustomPrivateAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomPrivateAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomPrivateAPIGrpcClient) doRPCBillingFeature(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &BillingFeatureRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.BillingFeatureRequest", yamlReq)
	}
	rsp, err := c.grpcClient.BillingFeature(ctx, req, opts...)
	return rsp, err
}

func (c *CustomPrivateAPIGrpcClient) doRPCBillingUsage(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &BillingUsageRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.BillingUsageRequest", yamlReq)
	}
	rsp, err := c.grpcClient.BillingUsage(ctx, req, opts...)
	return rsp, err
}

func (c *CustomPrivateAPIGrpcClient) doRPCRELoadBalancerMetrics(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LoadBalancerMetricsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.LoadBalancerMetricsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.RELoadBalancerMetrics(ctx, req, opts...)
	return rsp, err
}

func (c *CustomPrivateAPIGrpcClient) doRPCSecretManagement(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecretManagementRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.SecretManagementRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecretManagement(ctx, req, opts...)
	return rsp, err
}

func (c *CustomPrivateAPIGrpcClient) doRPCSiteTraffic(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SiteTrafficRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.SiteTrafficRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SiteTraffic(ctx, req, opts...)
	return rsp, err
}

func (c *CustomPrivateAPIGrpcClient) doRPCSyntheticMonitorInvocations(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SyntheticMonitorInvocationsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.SyntheticMonitorInvocationsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SyntheticMonitorInvocations(ctx, req, opts...)
	return rsp, err
}

func (c *CustomPrivateAPIGrpcClient) doRPCUsageCount(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &UsageCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.UsageCountRequest", yamlReq)
	}
	rsp, err := c.grpcClient.UsageCount(ctx, req, opts...)
	return rsp, err
}

func (c *CustomPrivateAPIGrpcClient) doRPCVolterraNetworkTraffic(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &VolterraNetworkTrafficRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.VolterraNetworkTrafficRequest", yamlReq)
	}
	rsp, err := c.grpcClient.VolterraNetworkTraffic(ctx, req, opts...)
	return rsp, err
}

func (c *CustomPrivateAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomPrivateAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomPrivateAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomPrivateAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["BillingFeature"] = ccl.doRPCBillingFeature

	rpcFns["BillingUsage"] = ccl.doRPCBillingUsage

	rpcFns["RELoadBalancerMetrics"] = ccl.doRPCRELoadBalancerMetrics

	rpcFns["SecretManagement"] = ccl.doRPCSecretManagement

	rpcFns["SiteTraffic"] = ccl.doRPCSiteTraffic

	rpcFns["SyntheticMonitorInvocations"] = ccl.doRPCSyntheticMonitorInvocations

	rpcFns["UsageCount"] = ccl.doRPCUsageCount

	rpcFns["VolterraNetworkTraffic"] = ccl.doRPCVolterraNetworkTraffic

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomPrivateAPI REST Client satisfying server.CustomClient
type CustomPrivateAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomPrivateAPIRestClient) doRPCBillingFeature(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &BillingFeatureRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.BillingFeatureRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		for _, item := range req.GroupBy {
			q.Add("group_by", fmt.Sprintf("%v", item))
		}
		for _, item := range req.LabelFilter {
			q.Add("label_filter", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &BillingFeatureResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.billing.BillingFeatureResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomPrivateAPIRestClient) doRPCBillingUsage(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &BillingUsageRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.BillingUsageRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		for _, item := range req.GroupBy {
			q.Add("group_by", fmt.Sprintf("%v", item))
		}
		for _, item := range req.LabelFilter {
			q.Add("label_filter", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &BillingUsageResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.billing.BillingUsageResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomPrivateAPIRestClient) doRPCRELoadBalancerMetrics(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LoadBalancerMetricsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.LoadBalancerMetricsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		for _, item := range req.GroupBy {
			q.Add("group_by", fmt.Sprintf("%v", item))
		}
		for _, item := range req.MetricSelector {
			q.Add("metric_selector", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LoadBalancerMetricsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.billing.LoadBalancerMetricsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomPrivateAPIRestClient) doRPCSecretManagement(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecretManagementRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.SecretManagementRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		for _, item := range req.GroupBy {
			q.Add("group_by", fmt.Sprintf("%v", item))
		}
		for _, item := range req.LabelFilter {
			q.Add("label_filter", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecretManagementResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.billing.SecretManagementResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomPrivateAPIRestClient) doRPCSiteTraffic(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SiteTrafficRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.SiteTrafficRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SiteTrafficResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.billing.SiteTrafficResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomPrivateAPIRestClient) doRPCSyntheticMonitorInvocations(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SyntheticMonitorInvocationsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.SyntheticMonitorInvocationsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		for _, item := range req.GroupBy {
			q.Add("group_by", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SyntheticMonitorInvocationsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.billing.SyntheticMonitorInvocationsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomPrivateAPIRestClient) doRPCUsageCount(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &UsageCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.UsageCountRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		for _, item := range req.FieldSelector {
			q.Add("field_selector", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("time", fmt.Sprintf("%v", req.Time))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &UsageCountResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.billing.UsageCountResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomPrivateAPIRestClient) doRPCVolterraNetworkTraffic(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &VolterraNetworkTrafficRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.billing.VolterraNetworkTrafficRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		for _, item := range req.GroupBy {
			q.Add("group_by", fmt.Sprintf("%v", item))
		}
		for _, item := range req.LabelFilter {
			q.Add("label_filter", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &VolterraNetworkTrafficResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.billing.VolterraNetworkTrafficResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomPrivateAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomPrivateAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomPrivateAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["BillingFeature"] = ccl.doRPCBillingFeature

	rpcFns["BillingUsage"] = ccl.doRPCBillingUsage

	rpcFns["RELoadBalancerMetrics"] = ccl.doRPCRELoadBalancerMetrics

	rpcFns["SecretManagement"] = ccl.doRPCSecretManagement

	rpcFns["SiteTraffic"] = ccl.doRPCSiteTraffic

	rpcFns["SyntheticMonitorInvocations"] = ccl.doRPCSyntheticMonitorInvocations

	rpcFns["UsageCount"] = ccl.doRPCUsageCount

	rpcFns["VolterraNetworkTraffic"] = ccl.doRPCVolterraNetworkTraffic

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customPrivateAPIInprocClient

// INPROC Client (satisfying CustomPrivateAPIClient interface)
type customPrivateAPIInprocClient struct {
	CustomPrivateAPIServer
}

func (c *customPrivateAPIInprocClient) BillingFeature(ctx context.Context, in *BillingFeatureRequest, opts ...grpc.CallOption) (*BillingFeatureResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.billing.CustomPrivateAPI.BillingFeature")
	return c.CustomPrivateAPIServer.BillingFeature(ctx, in)
}
func (c *customPrivateAPIInprocClient) BillingUsage(ctx context.Context, in *BillingUsageRequest, opts ...grpc.CallOption) (*BillingUsageResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.billing.CustomPrivateAPI.BillingUsage")
	return c.CustomPrivateAPIServer.BillingUsage(ctx, in)
}
func (c *customPrivateAPIInprocClient) RELoadBalancerMetrics(ctx context.Context, in *LoadBalancerMetricsRequest, opts ...grpc.CallOption) (*LoadBalancerMetricsResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.billing.CustomPrivateAPI.RELoadBalancerMetrics")
	return c.CustomPrivateAPIServer.RELoadBalancerMetrics(ctx, in)
}
func (c *customPrivateAPIInprocClient) SecretManagement(ctx context.Context, in *SecretManagementRequest, opts ...grpc.CallOption) (*SecretManagementResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.billing.CustomPrivateAPI.SecretManagement")
	return c.CustomPrivateAPIServer.SecretManagement(ctx, in)
}
func (c *customPrivateAPIInprocClient) SiteTraffic(ctx context.Context, in *SiteTrafficRequest, opts ...grpc.CallOption) (*SiteTrafficResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.billing.CustomPrivateAPI.SiteTraffic")
	return c.CustomPrivateAPIServer.SiteTraffic(ctx, in)
}
func (c *customPrivateAPIInprocClient) SyntheticMonitorInvocations(ctx context.Context, in *SyntheticMonitorInvocationsRequest, opts ...grpc.CallOption) (*SyntheticMonitorInvocationsResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.billing.CustomPrivateAPI.SyntheticMonitorInvocations")
	return c.CustomPrivateAPIServer.SyntheticMonitorInvocations(ctx, in)
}
func (c *customPrivateAPIInprocClient) UsageCount(ctx context.Context, in *UsageCountRequest, opts ...grpc.CallOption) (*UsageCountResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.billing.CustomPrivateAPI.UsageCount")
	return c.CustomPrivateAPIServer.UsageCount(ctx, in)
}
func (c *customPrivateAPIInprocClient) VolterraNetworkTraffic(ctx context.Context, in *VolterraNetworkTrafficRequest, opts ...grpc.CallOption) (*VolterraNetworkTrafficResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.billing.CustomPrivateAPI.VolterraNetworkTraffic")
	return c.CustomPrivateAPIServer.VolterraNetworkTraffic(ctx, in)
}

func NewCustomPrivateAPIInprocClient(svc svcfw.Service) CustomPrivateAPIClient {
	return &customPrivateAPIInprocClient{CustomPrivateAPIServer: NewCustomPrivateAPIServer(svc)}
}

// RegisterGwCustomPrivateAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomPrivateAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomPrivateAPIHandlerClient(ctx, mux, NewCustomPrivateAPIInprocClient(s))
}

// Create customPrivateAPISrv

// SERVER (satisfying CustomPrivateAPIServer interface)
type customPrivateAPISrv struct {
	svc svcfw.Service
}

func (s *customPrivateAPISrv) BillingFeature(ctx context.Context, in *BillingFeatureRequest) (*BillingFeatureResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.billing.CustomPrivateAPI")
	cah, ok := ah.(CustomPrivateAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomPrivateAPIServer", ah)
	}

	var (
		rsp *BillingFeatureResponse
		err error
	)

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.billing.CustomPrivateAPI.BillingFeature"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.BillingFeature(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	return rsp, nil
}
func (s *customPrivateAPISrv) BillingUsage(ctx context.Context, in *BillingUsageRequest) (*BillingUsageResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.billing.CustomPrivateAPI")
	cah, ok := ah.(CustomPrivateAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomPrivateAPIServer", ah)
	}

	var (
		rsp *BillingUsageResponse
		err error
	)

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.billing.CustomPrivateAPI.BillingUsage"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.BillingUsage(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	return rsp, nil
}
func (s *customPrivateAPISrv) RELoadBalancerMetrics(ctx context.Context, in *LoadBalancerMetricsRequest) (*LoadBalancerMetricsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.billing.CustomPrivateAPI")
	cah, ok := ah.(CustomPrivateAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomPrivateAPIServer", ah)
	}

	var (
		rsp *LoadBalancerMetricsResponse
		err error
	)

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.billing.CustomPrivateAPI.RELoadBalancerMetrics"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.RELoadBalancerMetrics(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	return rsp, nil
}
func (s *customPrivateAPISrv) SecretManagement(ctx context.Context, in *SecretManagementRequest) (*SecretManagementResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.billing.CustomPrivateAPI")
	cah, ok := ah.(CustomPrivateAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomPrivateAPIServer", ah)
	}

	var (
		rsp *SecretManagementResponse
		err error
	)

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.billing.CustomPrivateAPI.SecretManagement"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecretManagement(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	return rsp, nil
}
func (s *customPrivateAPISrv) SiteTraffic(ctx context.Context, in *SiteTrafficRequest) (*SiteTrafficResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.billing.CustomPrivateAPI")
	cah, ok := ah.(CustomPrivateAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomPrivateAPIServer", ah)
	}

	var (
		rsp *SiteTrafficResponse
		err error
	)

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.billing.CustomPrivateAPI.SiteTraffic"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SiteTraffic(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	return rsp, nil
}
func (s *customPrivateAPISrv) SyntheticMonitorInvocations(ctx context.Context, in *SyntheticMonitorInvocationsRequest) (*SyntheticMonitorInvocationsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.billing.CustomPrivateAPI")
	cah, ok := ah.(CustomPrivateAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomPrivateAPIServer", ah)
	}

	var (
		rsp *SyntheticMonitorInvocationsResponse
		err error
	)

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.billing.CustomPrivateAPI.SyntheticMonitorInvocations"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SyntheticMonitorInvocations(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	return rsp, nil
}
func (s *customPrivateAPISrv) UsageCount(ctx context.Context, in *UsageCountRequest) (*UsageCountResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.billing.CustomPrivateAPI")
	cah, ok := ah.(CustomPrivateAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomPrivateAPIServer", ah)
	}

	var (
		rsp *UsageCountResponse
		err error
	)

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.billing.CustomPrivateAPI.UsageCount"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.UsageCount(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	return rsp, nil
}
func (s *customPrivateAPISrv) VolterraNetworkTraffic(ctx context.Context, in *VolterraNetworkTrafficRequest) (*VolterraNetworkTrafficResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.billing.CustomPrivateAPI")
	cah, ok := ah.(CustomPrivateAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomPrivateAPIServer", ah)
	}

	var (
		rsp *VolterraNetworkTrafficResponse
		err error
	)

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.billing.CustomPrivateAPI.VolterraNetworkTraffic"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.VolterraNetworkTraffic(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	return rsp, nil
}

func NewCustomPrivateAPIServer(svc svcfw.Service) CustomPrivateAPIServer {
	return &customPrivateAPISrv{svc: svc}
}

var CustomPrivateAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Billing",
        "description": "Billing data can be broadly categorized into two buckets.\n1. Feature type - Duration for which the feature type was enabled in the site.\n2. Feature usage - Duration for which an instance or multiple instances per feature type were active.\nBoth feature type and the usage data are adjusted based on the Billing Quanta (BQ). For example, if the\nBQ is 1 hour, then even if the feature was enabled only for 1 minute, then it will be reported as 1 hour.",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/ves.io.schema/introspect/read/namespaces/{namespace}/billing/feature": {
            "post": {
                "summary": "Billing Feature",
                "description": "Request to get the billing duration for feature type",
                "operationId": "ves.io.schema.billing.CustomPrivateAPI.BillingFeature",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/billingBillingFeatureResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"system\"\nNamespace is used to scope the fetching of billing data for the given namespace.\nAt present, only system namespace is supported.",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/billingBillingFeatureRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomPrivateAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-billing-customprivateapi-billingfeature"
                },
                "x-ves-proto-rpc": "ves.io.schema.billing.CustomPrivateAPI.BillingFeature"
            },
            "x-displayname": "Custom Private API",
            "x-ves-proto-service": "ves.io.schema.billing.CustomPrivateAPI",
            "x-ves-proto-service-type": "CUSTOM_PRIVATE"
        },
        "/ves.io.schema/introspect/read/namespaces/{namespace}/billing/re_loadbalancer_metrics": {
            "post": {
                "summary": "RE Loadbalancer metrics",
                "description": "Request to get RE Loadbalancer metrics",
                "operationId": "ves.io.schema.billing.CustomPrivateAPI.RELoadBalancerMetrics",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/billingLoadBalancerMetricsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-required\nx-example: \"system\"\nThis request is valid only system namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/billingLoadBalancerMetricsRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomPrivateAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-billing-customprivateapi-reloadbalancermetrics"
                },
                "x-ves-proto-rpc": "ves.io.schema.billing.CustomPrivateAPI.RELoadBalancerMetrics"
            },
            "x-displayname": "Custom Private API",
            "x-ves-proto-service": "ves.io.schema.billing.CustomPrivateAPI",
            "x-ves-proto-service-type": "CUSTOM_PRIVATE"
        },
        "/ves.io.schema/introspect/read/namespaces/{namespace}/billing/secret_management": {
            "post": {
                "summary": "Secret Management",
                "description": "Request to get total number of Secret management requests",
                "operationId": "ves.io.schema.billing.CustomPrivateAPI.SecretManagement",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/billingSecretManagementResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"system\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/billingSecretManagementRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomPrivateAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-billing-customprivateapi-secretmanagement"
                },
                "x-ves-proto-rpc": "ves.io.schema.billing.CustomPrivateAPI.SecretManagement"
            },
            "x-displayname": "Custom Private API",
            "x-ves-proto-service": "ves.io.schema.billing.CustomPrivateAPI",
            "x-ves-proto-service-type": "CUSTOM_PRIVATE"
        },
        "/ves.io.schema/introspect/read/namespaces/{namespace}/billing/site_traffic": {
            "post": {
                "summary": "Site Traffic",
                "description": "Request to get traffic between re to ce and ce to re",
                "operationId": "ves.io.schema.billing.CustomPrivateAPI.SiteTraffic",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/billingSiteTrafficResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"system\"\nThis request is valid only system namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/billingSiteTrafficRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomPrivateAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-billing-customprivateapi-sitetraffic"
                },
                "x-ves-proto-rpc": "ves.io.schema.billing.CustomPrivateAPI.SiteTraffic"
            },
            "x-displayname": "Custom Private API",
            "x-ves-proto-service": "ves.io.schema.billing.CustomPrivateAPI",
            "x-ves-proto-service-type": "CUSTOM_PRIVATE"
        },
        "/ves.io.schema/introspect/read/namespaces/{namespace}/billing/synthetic_monitor_invocations": {
            "post": {
                "summary": "Synthetic Monitor Invocations",
                "description": "Request to get synthetic monitoring usage",
                "operationId": "ves.io.schema.billing.CustomPrivateAPI.SyntheticMonitorInvocations",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/billingSyntheticMonitorInvocationsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"system\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/billingSyntheticMonitorInvocationsRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomPrivateAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-billing-customprivateapi-syntheticmonitorinvocations"
                },
                "x-ves-proto-rpc": "ves.io.schema.billing.CustomPrivateAPI.SyntheticMonitorInvocations"
            },
            "x-displayname": "Custom Private API",
            "x-ves-proto-service": "ves.io.schema.billing.CustomPrivateAPI",
            "x-ves-proto-service-type": "CUSTOM_PRIVATE"
        },
        "/ves.io.schema/introspect/read/namespaces/{namespace}/billing/usage": {
            "post": {
                "summary": "Billing Usage",
                "description": "Request to get the billing duration for feature usage",
                "operationId": "ves.io.schema.billing.CustomPrivateAPI.BillingUsage",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/billingBillingUsageResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"system\"\nNamespace is used to scope the fetching of billing usage data for the given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/billingBillingUsageRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomPrivateAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-billing-customprivateapi-billingusage"
                },
                "x-ves-proto-rpc": "ves.io.schema.billing.CustomPrivateAPI.BillingUsage"
            },
            "x-displayname": "Custom Private API",
            "x-ves-proto-service": "ves.io.schema.billing.CustomPrivateAPI",
            "x-ves-proto-service-type": "CUSTOM_PRIVATE"
        },
        "/ves.io.schema/introspect/read/namespaces/{namespace}/billing/usage_count": {
            "post": {
                "summary": "Usage Count",
                "description": "Request to get count of various config objects/resources for a tenant",
                "operationId": "ves.io.schema.billing.CustomPrivateAPI.UsageCount",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/billingUsageCountResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-required\nx-example: \"system\"\nNamespace is used to scope the fetching of usage data for the given namespace.\nAt present, only system namespace is supported.",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/billingUsageCountRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomPrivateAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-billing-customprivateapi-usagecount"
                },
                "x-ves-proto-rpc": "ves.io.schema.billing.CustomPrivateAPI.UsageCount"
            },
            "x-displayname": "Custom Private API",
            "x-ves-proto-service": "ves.io.schema.billing.CustomPrivateAPI",
            "x-ves-proto-service-type": "CUSTOM_PRIVATE"
        },
        "/ves.io.schema/introspect/read/namespaces/{namespace}/billing/volterra_traffic": {
            "post": {
                "summary": "Traffic to F5XC Network",
                "description": "Request to get traffic to F5XC Network for a tenant",
                "operationId": "ves.io.schema.billing.CustomPrivateAPI.VolterraNetworkTraffic",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/billingVolterraNetworkTrafficResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"system\"\nThis request is valid only system namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/billingVolterraNetworkTrafficRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomPrivateAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-billing-customprivateapi-volterranetworktraffic"
                },
                "x-ves-proto-rpc": "ves.io.schema.billing.CustomPrivateAPI.VolterraNetworkTraffic"
            },
            "x-displayname": "Custom Private API",
            "x-ves-proto-service": "ves.io.schema.billing.CustomPrivateAPI",
            "x-ves-proto-service-type": "CUSTOM_PRIVATE"
        }
    },
    "definitions": {
        "billingBillingFeatureData": {
            "type": "object",
            "description": "Billing Feature Data contains the timeseries data of the billing feature",
            "title": "BillingFeatureData",
            "x-displayname": "Billing Feature Data",
            "x-ves-proto-message": "ves.io.schema.billing.BillingFeatureData",
            "properties": {
                "duration": {
                    "type": "array",
                    "description": " Duration in seconds",
                    "title": "Duration",
                    "items": {
                        "$ref": "#/definitions/schemabillingMetricValue"
                    },
                    "x-displayname": "Duration"
                },
                "id": {
                    "description": " Billing Feature ID uniquely identifies each combination of group_by labels in the response",
                    "title": "ID",
                    "$ref": "#/definitions/billingBillingFeatureId",
                    "x-displayname": "ID"
                }
            }
        },
        "billingBillingFeatureId": {
            "type": "object",
            "description": "BillingFeatureId uniquely identifies an entry in the response for Billing Feature Request.\nBilling feature data is aggregated based on the group_by field in the request.\nTherefore, only the fields that correspond to the MetricLabel in the group_by field will have the non-empty\nvalue in the response.",
            "title": "BillingFeatureId",
            "x-displayname": "Billing Feature ID",
            "x-ves-proto-message": "ves.io.schema.billing.BillingFeatureId",
            "properties": {
                "certified_hardware": {
                    "type": "string",
                    "description": "\n\nExample: - \"igw-500x-voltmesh-optimized\"-",
                    "title": "Certified Hardware",
                    "x-displayname": "Certified Hardware",
                    "x-ves-example": "igw-500x-voltmesh-optimized"
                },
                "certified_hardware_type": {
                    "type": "string",
                    "description": "\n\nExample: - \"VOLSTMESH\"-",
                    "title": "Certified Hardware Type",
                    "x-displayname": "Certified Hardware Type",
                    "x-ves-example": "VOLSTMESH"
                },
                "feature_type": {
                    "type": "string",
                    "description": " Indicates the Feature type such as app-setting, virtual-host, etc.,\n\nExample: - \"virtual-host\"-",
                    "title": "Feature Type",
                    "x-displayname": "Feature Type",
                    "x-ves-example": "virtual-host"
                },
                "node_flavor": {
                    "type": "string",
                    "description": "\n\nExample: - \"NODE_FLAVOR_SMALL\"-",
                    "title": "Node Flavor",
                    "x-displayname": "Node Flavor",
                    "x-ves-example": "NODE_FLAVOR_SMALL"
                },
                "site": {
                    "type": "string",
                    "description": " Site which reported the billing data\n\nExample: - \"site1\"-",
                    "title": "Site",
                    "x-displayname": "Site",
                    "x-ves-example": "site1"
                },
                "site_type": {
                    "type": "string",
                    "description": " Indicates the site type\n\nExample: - \"CUSTOMER_EDGE\"-",
                    "title": "Site Type",
                    "x-displayname": "Site Type",
                    "x-ves-example": "CUSTOMER_EDGE"
                }
            }
        },
        "billingBillingFeatureRequest": {
            "type": "object",
            "description": "Request to get billing duration per feature type",
            "title": "BillingFeatureRequest",
            "x-displayname": "Billing Feature Request",
            "x-ves-proto-message": "ves.io.schema.billing.BillingFeatureRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by one or more labels listed here.\n SITE_TYPE, SITE, FEATURE_TYPE\n\n Optional: If not specified, then the billing data will be aggregated/grouped by SITE_TYPE, SITE and FEATURE_TYPE.",
                    "title": "Group by",
                    "items": {
                        "$ref": "#/definitions/billingMetricLabel"
                    },
                    "x-displayname": "Group By"
                },
                "label_filter": {
                    "type": "array",
                    "description": " List of label filter expressions of the form \"label\" Op \"value\".\n Response will only contain data that matches all the conditions specified in the label_filter.\n One or more of the following labels can be specified in the label_filter.\n SITE, FEATURE_TYPE\n\n Optional: If not specified, then the metrics will be filtered only based on the namespace in the request.",
                    "title": "Label Filter",
                    "items": {
                        "$ref": "#/definitions/billingMetricLabelFilter"
                    },
                    "x-displayname": "Label Filter"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace is used to scope the fetching of billing data for the given namespace.\n At present, only system namespace is supported.\n\nExample: - \"system\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system"
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"15m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_step: true\n",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "15m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_step": "true"
                    }
                }
            }
        },
        "billingBillingFeatureResponse": {
            "type": "object",
            "description": "Response message for the Billing Feature Request.\nResponse may contain multiple entries depending on the label_filter and group_by fields in the request.\nFor example, if the label_filter specifies SITE=site1 and group_by FEATURE_TYPE, then the response will\ncontain one entry per FEATURE_TYPE for site1 in the response. In the above example, if the label_filter is\nnot specified, then the response will contain one entry per (SITE_TYPE, SITE, FEATURE_TYPE) combination for the tenant.",
            "title": "BillingFeatureResponse",
            "x-displayname": "Billing Feature Response",
            "x-ves-proto-message": "ves.io.schema.billing.BillingFeatureResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/billingBillingFeatureData"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"30m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "step",
                    "x-displayname": "Step",
                    "x-ves-example": "30m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                }
            }
        },
        "billingBillingUsageData": {
            "type": "object",
            "description": "Billing Usage Data contains the timeseries data of the billing usage in seconds",
            "title": "BillingUsageData",
            "x-displayname": "Billing Usage Data",
            "x-ves-proto-message": "ves.io.schema.billing.BillingUsageData",
            "properties": {
                "duration": {
                    "type": "array",
                    "description": " Duration in seconds",
                    "title": "Duration",
                    "items": {
                        "$ref": "#/definitions/schemabillingMetricValue"
                    },
                    "x-displayname": "Duration"
                },
                "id": {
                    "description": " Billing Usage ID uniquely identifies each combination of group_by labels in the response",
                    "title": "ID",
                    "$ref": "#/definitions/billingBillingUsageId",
                    "x-displayname": "ID"
                }
            }
        },
        "billingBillingUsageId": {
            "type": "object",
            "description": "BillingUsageId uniquely identifies an entry in the response for Billing Usage Request.\nBilling usage data is aggregated based on the group_by field in the request.\nTherefore, only the fields that correspond to the MetricLabel in the group_by field will have the non-empty\nvalue in the response.",
            "title": "BillingUsageId",
            "x-displayname": "Billing Usage ID",
            "x-ves-proto-message": "ves.io.schema.billing.BillingUsageId",
            "properties": {
                "certified_hardware": {
                    "type": "string",
                    "description": "\n\nExample: - \"igw-500x-voltmesh-optimized\"-",
                    "title": "Certified Hardware",
                    "x-displayname": "Certified Hardware",
                    "x-ves-example": "igw-500x-voltmesh-optimized"
                },
                "certified_hardware_type": {
                    "type": "string",
                    "description": "\n\nExample: - \"VOLSTMESH\"-",
                    "title": "Certified Hardware Type",
                    "x-displayname": "Certified Hardware Type",
                    "x-ves-example": "VOLSTMESH"
                },
                "feature_type": {
                    "type": "string",
                    "description": " Indicates the Feature type such as app-setting, virtual-host, etc.,\n\nExample: - \"virtual-host\"-",
                    "title": "Feature Type",
                    "x-displayname": "Feature Type",
                    "x-ves-example": "virtual-host"
                },
                "instance": {
                    "type": "string",
                    "description": " Instance id of the feature\n\nExample: - \"vhost1\"-",
                    "title": "Instance",
                    "x-displayname": "Instance",
                    "x-ves-example": "vhost1"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace in which the feature instance was enabled\n\nExample: - \"ns1\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "pvc_size": {
                    "type": "string",
                    "description": " PVC Size in bytes\n Applicable only for BillingFeatureType VIRTUAL_K8S_PVC_STORAGE\n\nExample: - \"10485760\"-",
                    "title": "PVC Size",
                    "x-displayname": "PVC Size",
                    "x-ves-example": "10485760"
                },
                "site": {
                    "type": "string",
                    "description": " Site which reported the billing metric",
                    "title": "Site",
                    "x-displayname": "Site"
                },
                "site_type": {
                    "type": "string",
                    "description": " Indicates the site type\n\nExample: - \"CUSTOMER_EDGE\"-",
                    "title": "Site Type",
                    "x-displayname": "Site Type",
                    "x-ves-example": "CUSTOMER_EDGE"
                }
            }
        },
        "billingBillingUsageRequest": {
            "type": "object",
            "description": "Request to get billing duration for feature usage",
            "title": "BillingUsageRequest",
            "x-displayname": "Billing Usage Request",
            "x-ves-proto-message": "ves.io.schema.billing.BillingUsageRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by one or more labels listed here.\n NAMESPACE, SITE_TYPE, SITE, FEATURE_TYPE, INSTANCE\n\n Optional: If not specified, then the billing data will be aggregated/grouped by NAMESPACE, SITE_TYPE, SITE, FEATURE_TYPE, INSTANCE.",
                    "title": "Group by",
                    "items": {
                        "$ref": "#/definitions/billingMetricLabel"
                    },
                    "x-displayname": "Group By"
                },
                "label_filter": {
                    "type": "array",
                    "description": " List of label filter expressions of the form \"label\" Op \"value\".\n Response will only contain data that matches all the conditions specified in the label_filter.\n One or more of the following labels can be specified in the label_filter.\n SITE, FEATURE_TYPE, INSTANCE\n\n Optional: If not specified, then the metrics will be filtered only based on the namespace in the request.",
                    "title": "Label Filter",
                    "items": {
                        "$ref": "#/definitions/billingMetricLabelFilter"
                    },
                    "x-displayname": "Label Filter"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace is used to scope the fetching of billing usage data for the given namespace\n\nExample: - \"system\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system"
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"15m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_step: true\n",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "15m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_step": "true"
                    }
                }
            }
        },
        "billingBillingUsageResponse": {
            "type": "object",
            "description": "Response message for the Billing Usage Request.\nResponse may contain multiple entries depending on the label_filter and group_by fields in the request.\nFor example, if the label_filter specifies SITE=site1 and group_by FEATURE_TYPE, then the response will\ncontain one entry per FEATURE_TYPE for site1 in the response. In the above example, if the label_filter is\nnot specified, then the response will contain one entry per (SITE, FEATURE_TYPE) combination for the tenant.",
            "title": "BillingUsageResponse",
            "x-displayname": "Billing Usage Response",
            "x-ves-proto-message": "ves.io.schema.billing.BillingUsageResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/billingBillingUsageData"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"30m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "step",
                    "x-displayname": "Step",
                    "x-ves-example": "30m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                }
            }
        },
        "billingLoadBalancerMetricData": {
            "type": "object",
            "description": "LoadBalancer Metrics Data contains the metrics type and the metrics data",
            "title": "LoadBalancerMetricsData",
            "x-displayname": "LoadBalancer Metrics Data",
            "x-ves-proto-message": "ves.io.schema.billing.LoadBalancerMetricData",
            "properties": {
                "data": {
                    "type": "array",
                    "description": " Metric Data",
                    "title": "Data",
                    "items": {
                        "$ref": "#/definitions/schemaMetricTypeData"
                    },
                    "x-displayname": "Data"
                },
                "type": {
                    "type": "string",
                    "description": " Metric Type",
                    "title": "Type",
                    "x-displayname": "Type"
                },
                "unit": {
                    "description": " Unit for the metric value",
                    "title": "Unit",
                    "$ref": "#/definitions/schemaUnitType",
                    "x-displayname": "Unit"
                }
            }
        },
        "billingLoadBalancerMetricsRequest": {
            "type": "object",
            "description": "Request to get Loadbalancer Metrics",
            "title": "LoadBalancerMetricsRequest",
            "x-displayname": "LoadBalancer Metrics Request",
            "x-ves-proto-message": "ves.io.schema.billing.LoadBalancerMetricsRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981"
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by none or more labels\n\n Optional: If not specified, then the billing data will be aggregated without any label.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 5\n  ves.io.schema.rules.repeated.unique: true\n  ves.io.schema.rules.string.in: [\\\"site\\\"]\n",
                    "title": "Group by",
                    "maxItems": 5,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Group By",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "5",
                        "ves.io.schema.rules.repeated.unique": "true",
                        "ves.io.schema.rules.string.in": "[\\\"site\\\"]"
                    }
                },
                "metric_selector": {
                    "type": "array",
                    "description": " List of metrics to be returned in the response\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 5\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n  ves.io.schema.rules.string.in: [\\\"good_requests\\\"]\n",
                    "title": "Metric Selector",
                    "minItems": 1,
                    "maxItems": 5,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Metric Selector",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "5",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true",
                        "ves.io.schema.rules.string.in": "[\\\"good_requests\\\"]"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " This request is valid only system namespace\n\nExample: - \"system\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981"
                }
            }
        },
        "billingLoadBalancerMetricsResponse": {
            "type": "object",
            "description": "Response message for LoadBalancer Metrics Request\nResponse may contain multiple entries depending on the group_by fields in the request.",
            "title": "LoadBalancerMetricsResponse",
            "x-displayname": "LoadBalancer Metrics Response",
            "x-ves-proto-message": "ves.io.schema.billing.LoadBalancerMetricsResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/billingLoadBalancerMetricData"
                    }
                }
            }
        },
        "billingMetricLabel": {
            "type": "string",
            "description": "Labels in the billing metrics.\n\nBilling metrics can be sliced and diced based on one or more labels listed below.\n\nInvalid Label/Not specified\nNamespace in which the feature instance was enabled\nApplicable only for Billing Usage Metric\nSite which reported the billing metric\nFeature type can be Virtual-Host, WAF, etc.,\nInstance id of the feature\nApplicable only for Billing Usage Metric\nSite Type is either \"REGIONAL_EDGE\" or \"CUSTOMER_EDGE\"\nCertified Hardware indicates the type/vendor/model of the node\nx-example: \"VOLTMESH\"\nCertified Hardware Type indicates the hardware type\nx-example: \"NODE_FLAVOR_SMALL\"\nNode Flavor Type\nx-example: \"10485760\"\nPVC Storage in bytes\nValid only for Billing Usage metric for BillingFeatureType VIRTUAL_K8S_PVC_STORAGE",
            "enum": [
                "INVALID_LABEL",
                "NAMESPACE",
                "SITE",
                "FEATURE_TYPE",
                "INSTANCE",
                "SITE_TYPE",
                "CERTIFIED_HARDWARE",
                "CERTIFIED_HARDWARE_TYPE",
                "NODE_FLAVOR",
                "PVC_SIZE"
            ],
            "default": "INVALID_LABEL",
            "x-displayname": "Billing Metric Labels",
            "x-ves-proto-enum": "ves.io.schema.billing.MetricLabel"
        },
        "billingMetricLabelFilter": {
            "type": "object",
            "description": "Label based filtering of Billing metrics.\n\nBilling metrics are tagged with labels mentioned in MetricLabel.\nMetric label filter can be specified to query specific metrics based on label match",
            "x-displayname": "Billing Metric Label Filter",
            "x-ves-proto-message": "ves.io.schema.billing.MetricLabelFilter",
            "properties": {
                "label": {
                    "description": " Label name which is one out of the labels defined in MetricLabel enum.",
                    "title": "Label",
                    "$ref": "#/definitions/billingMetricLabel",
                    "x-displayname": "Label"
                },
                "op": {
                    "description": " Operator to evaluate the label in this filter",
                    "title": "Operator",
                    "$ref": "#/definitions/schemabillingMetricLabelOp",
                    "x-displayname": "Operator"
                },
                "value": {
                    "type": "string",
                    "description": " Value to be compared with\n\nExample: - \"site-1\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "site-1"
                }
            }
        },
        "billingSecretManagementData": {
            "type": "object",
            "description": "Contains the count of secret management requests for a unique combination of group_by label values in the response",
            "title": "Secret Management Data",
            "x-displayname": "Secret Management Data",
            "x-ves-proto-message": "ves.io.schema.billing.SecretManagementData",
            "properties": {
                "id": {
                    "description": " ID identifies unique combination of group_by label values in the response",
                    "title": "ID",
                    "$ref": "#/definitions/billingSecretManagementId",
                    "x-displayname": "ID"
                },
                "metric": {
                    "type": "array",
                    "description": " x-unit: \"Count\"",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/schemabillingMetricValue"
                    },
                    "x-displayname": "Metric"
                }
            }
        },
        "billingSecretManagementId": {
            "type": "object",
            "description": "SecretManagementId uniquely identifies an entry in the response for Secret Management Request.\nSecret Management API calls are aggregated based on the labels in the group_by field in the request.\nTherefore, only the fields that correspond to the label in the group_by field will have non-empty\nvalue in the response.",
            "title": "Secret Management ID",
            "x-displayname": "Secret Management ID",
            "x-ves-proto-message": "ves.io.schema.billing.SecretManagementId",
            "properties": {
                "api_namespace": {
                    "type": "string",
                    "description": "\n\nExample: - \"ns1\"-",
                    "title": "API Namespace",
                    "x-displayname": "API Namespace",
                    "x-ves-example": "ns1"
                },
                "api_type": {
                    "type": "string",
                    "description": "\n\nExample: - \"secrets/blindfold\"-",
                    "title": "API Type",
                    "x-displayname": "API Type",
                    "x-ves-example": "secrets/blindfold"
                }
            }
        },
        "billingSecretManagementLabel": {
            "type": "string",
            "description": "One or more of these labels may be specified in the label_filter or group_by to\nslice and dice the secret management API calls.\n",
            "title": "Secret Management Label",
            "enum": [
                "API_TYPE",
                "API_NAMESPACE"
            ],
            "default": "API_TYPE",
            "x-displayname": "Secret Management Label",
            "x-ves-proto-enum": "ves.io.schema.billing.SecretManagementLabel"
        },
        "billingSecretManagementLabelFilter": {
            "type": "object",
            "description": "One or more label filter can be specified to fetch the timeseries that matches the label filter",
            "title": "Secret Management Label Filter",
            "x-displayname": "Secret Management Label Filter",
            "x-ves-proto-message": "ves.io.schema.billing.SecretManagementLabelFilter",
            "properties": {
                "label": {
                    "description": " Label in Secret Management Metric",
                    "title": "Label",
                    "$ref": "#/definitions/billingSecretManagementLabel",
                    "x-displayname": "Label"
                },
                "op": {
                    "description": " Operator to evaluate the label in this filter",
                    "title": "Operator",
                    "$ref": "#/definitions/schemabillingMetricLabelOp",
                    "x-displayname": "Operator"
                },
                "value": {
                    "type": "string",
                    "description": " Value to be compared with\n\nExample: - \"site-1\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "site-1"
                }
            }
        },
        "billingSecretManagementRequest": {
            "type": "object",
            "description": "Request to get total number of secret management requests",
            "title": "Secret Management Request",
            "x-displayname": "Secret Management Request",
            "x-ves-proto-message": "ves.io.schema.billing.SecretManagementRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by none or more labels listed here.\n API_TYPE\n\n Optional: If not specified, then the billing data will be aggregated across all labels.",
                    "title": "Group by",
                    "items": {
                        "$ref": "#/definitions/billingSecretManagementLabel"
                    },
                    "x-displayname": "Group By"
                },
                "label_filter": {
                    "type": "array",
                    "description": " List of label filter expressions of the form \"label\" Op \"value\".\n Response will only contain data that matches all the conditions specified in the label_filter.\n one or more of the following labels can be specified in the label_filter.\n API_TYPE\n\n Optional: If not specified, then the metrics will be aggregated across all labels for the tenant.",
                    "title": "Label Filter",
                    "items": {
                        "$ref": "#/definitions/billingSecretManagementLabelFilter"
                    },
                    "x-displayname": "Label Filter"
                },
                "namespace": {
                    "type": "string",
                    "description": "\n\nExample: - \"system\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system"
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"15m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_step: true\n",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "15m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_step": "true"
                    }
                }
            }
        },
        "billingSecretManagementResponse": {
            "type": "object",
            "description": "Response message for Secret Management Request.\nResponse may contain one or more entries depending on the label_filter and the group_by fields in the request.",
            "title": "Secret Management Response",
            "x-displayname": "Secret Management Response",
            "x-ves-proto-message": "ves.io.schema.billing.SecretManagementResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/billingSecretManagementData"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"30m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "step",
                    "x-displayname": "Step",
                    "x-ves-example": "30m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                }
            }
        },
        "billingSiteId": {
            "type": "object",
            "description": "SiteId uniquely identifies the site.",
            "title": "SiteId",
            "x-displayname": "SiteId",
            "x-ves-proto-message": "ves.io.schema.billing.SiteId",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " Name of the site\n\nExample: - \"ce01\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "ce01"
                },
                "type": {
                    "description": " Site type indicates whether the site is CUSTOMER_EDGE or REGIONAL_EDGE",
                    "title": "Site type",
                    "$ref": "#/definitions/siteSiteType",
                    "x-displayname": "Site Type"
                }
            }
        },
        "billingSiteTrafficData": {
            "type": "object",
            "description": "Contains the \"to and fro\" traffic in bytes for a unique combination src_site and dst_site",
            "title": "SiteTrafficData",
            "x-displayname": "Site Network Traffic Data",
            "x-ves-proto-message": "ves.io.schema.billing.SiteTrafficData",
            "properties": {
                "bytes": {
                    "type": "array",
                    "description": " metric value in bytes",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/ioschemaMetricValue"
                    },
                    "x-displayname": "Metric"
                },
                "dst_site": {
                    "description": " Identifier for the destination site",
                    "title": "Destination ID",
                    "$ref": "#/definitions/billingSiteId",
                    "x-displayname": "Destination Site"
                },
                "src_site": {
                    "description": " Identifier for the source site",
                    "title": "Source ID",
                    "$ref": "#/definitions/billingSiteId",
                    "x-displayname": "Source Site"
                }
            }
        },
        "billingSiteTrafficRequest": {
            "type": "object",
            "description": "Request to get traffic between RE to CE and CE to RE",
            "title": "SiteTrafficRequest",
            "x-displayname": "Site Traffic",
            "x-ves-proto-message": "ves.io.schema.billing.SiteTrafficRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " This request is valid only system namespace\n\nExample: - \"system\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system"
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                }
            }
        },
        "billingSiteTrafficResponse": {
            "type": "object",
            "description": "Response message for site traffic.\nThere should only one entry per SRC_SITE, DST_SITE.\nSRC_SITE can be CE or RE and vice-versa.",
            "title": "SiteTrafficResponse",
            "x-displayname": "Site Traffic Response",
            "x-ves-proto-message": "ves.io.schema.billing.SiteTrafficResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/billingSiteTrafficData"
                    }
                }
            }
        },
        "billingSiteUsageCount": {
            "type": "object",
            "description": "Detailed usage count for sites",
            "title": "Site Usage Count",
            "x-displayname": "Site Usage Count",
            "x-ves-proto-message": "ves.io.schema.billing.SiteUsageCount",
            "properties": {
                "count_by_certified_hardware": {
                    "type": "object",
                    "description": " Aggregated count for sites grouped by Certified Hardware",
                    "title": "Count Per Certified Hardware",
                    "x-displayname": "Count Per Certified Hardware"
                }
            }
        },
        "billingSyntheticMonitorInvocationsData": {
            "type": "object",
            "description": "Contains the usage of Synthetic Monitor Invocations for a unique combination of group_by label values in the response",
            "title": "Synthetic Monitor Invocations Data",
            "x-displayname": "Synthetic Monitor Invocations Data",
            "x-ves-proto-message": "ves.io.schema.billing.SyntheticMonitorInvocationsData",
            "properties": {
                "id": {
                    "description": " ID identifies unique combination of group_by label values in the response",
                    "title": "ID",
                    "$ref": "#/definitions/billingSyntheticMonitorInvocationsId",
                    "x-displayname": "ID"
                },
                "metric": {
                    "type": "array",
                    "description": " x-unit: \"Count\"",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/schemabillingMetricValue"
                    },
                    "x-displayname": "Metric"
                }
            }
        },
        "billingSyntheticMonitorInvocationsId": {
            "type": "object",
            "description": "SyntheticMonitorInvocationsId uniquely identifies an entry in the response for Synthetic Monitor Invocations Request.\nSynthetic Monitor Invocations API calls are aggregated based on the labels in the group_by field in the request.",
            "title": "Synthetic Monitor Invocations Id",
            "x-displayname": "Synthetic Monitor Invocations Id",
            "x-ves-proto-message": "ves.io.schema.billing.SyntheticMonitorInvocationsId",
            "properties": {
                "synthetic_monitor_type": {
                    "type": "string",
                    "description": "\n\nExample: - \"dns\"-",
                    "title": "SYNTHETIC MONITOR TYPE",
                    "x-displayname": "SYNTHETIC MONITOR TYPE",
                    "x-ves-example": "dns"
                }
            }
        },
        "billingSyntheticMonitorInvocationsLabel": {
            "type": "string",
            "description": "One or more of these labels may be specified in the group_by.\n",
            "title": "Synthetic Monitor Invocations Label",
            "enum": [
                "SYNTHETIC_MONITOR_TYPE"
            ],
            "default": "SYNTHETIC_MONITOR_TYPE",
            "x-displayname": "Synthetic Monitor Invocations Label",
            "x-ves-proto-enum": "ves.io.schema.billing.SyntheticMonitorInvocationsLabel"
        },
        "billingSyntheticMonitorInvocationsRequest": {
            "type": "object",
            "description": "Request to get synthetic monitoring usage",
            "title": "Synthetic Monitor Invocations Request",
            "x-displayname": "Synthetic Monitor Invocations Request",
            "x-ves-proto-message": "ves.io.schema.billing.SyntheticMonitorInvocationsRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by none or more labels listed here.\n SYNTHETIC_MONITOR_TYPE\n\n Optional: If not specified, then the billing data will be aggregated across all labels.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Group by",
                    "items": {
                        "$ref": "#/definitions/billingSyntheticMonitorInvocationsLabel"
                    },
                    "x-displayname": "Group By",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": "\n\nExample: - \"system\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system"
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"15m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_step: true\n",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "15m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_step": "true"
                    }
                }
            }
        },
        "billingSyntheticMonitorInvocationsResponse": {
            "type": "object",
            "description": "Response message for Synthetic Monitor Invocations Request.\nResponse may contain one or more entries depending on the group_by fields in the request.",
            "title": "Synthetic Monitor Invocations Response",
            "x-displayname": "Synthetic Monitor Invocations Response",
            "x-ves-proto-message": "ves.io.schema.billing.SyntheticMonitorInvocationsResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/billingSyntheticMonitorInvocationsData"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"30m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "step",
                    "x-displayname": "Step",
                    "x-ves-example": "30m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                }
            }
        },
        "billingUsageCountData": {
            "type": "object",
            "description": "Usage Count for a field specified in the request",
            "title": "Usage Count Data",
            "x-displayname": "Usage Count Data",
            "x-ves-oneof-field-count_choice": "[\"count\",\"site\"]",
            "x-ves-proto-message": "ves.io.schema.billing.UsageCountData",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "Exclusive with [site]\n Usage count",
                    "title": "Count",
                    "format": "uint64",
                    "x-displayname": "Count"
                },
                "field": {
                    "type": "string",
                    "description": " Field name\n\nExample: - \"site\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Field",
                    "x-displayname": "Field",
                    "x-ves-example": "site",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "site": {
                    "description": "Exclusive with [count]\n Usage count for the sites",
                    "title": "Sites",
                    "$ref": "#/definitions/billingSiteUsageCount",
                    "x-displayname": "Sites"
                }
            }
        },
        "billingUsageCountRequest": {
            "type": "object",
            "description": "Request to get count of various config objects/resources for a tenant",
            "title": "Usage Count Request",
            "x-displayname": "Usage Count Request",
            "x-ves-proto-message": "ves.io.schema.billing.UsageCountRequest",
            "properties": {
                "field_selector": {
                    "type": "array",
                    "description": " List of objects/resources for which usage is requested.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n  ves.io.schema.rules.string.in: [\\\"app_setting\\\",\\\"dns_domain\\\",\\\"dns_load_balancer\\\",\\\"dns_load_balancer.health_check\\\",\\\"fast_acl\\\",\\\"http_loadbalancer\\\",\\\"http_loadbalancer.public\\\",\\\"http_loadbalancer.public.app_firewall\\\",\\\"k8s_cluster\\\",\\\"public_ip\\\",\\\"site\\\",\\\"tcp_loadbalancer\\\",\\\"tcp_loadbalancer.public\\\",\\\"token\\\",\\\"virtual_host\\\",\\\"virtual_k8s\\\",\\\"waf\\\",\\\"udp_loadbalancer\\\",\\\"udp_loadbalancer.public\\\"]\n",
                    "title": "Field Selector",
                    "minItems": 1,
                    "maxItems": 32,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Field Selector",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true",
                        "ves.io.schema.rules.string.in": "[\\\"app_setting\\\",\\\"dns_domain\\\",\\\"dns_load_balancer\\\",\\\"dns_load_balancer.health_check\\\",\\\"fast_acl\\\",\\\"http_loadbalancer\\\",\\\"http_loadbalancer.public\\\",\\\"http_loadbalancer.public.app_firewall\\\",\\\"k8s_cluster\\\",\\\"public_ip\\\",\\\"site\\\",\\\"tcp_loadbalancer\\\",\\\"tcp_loadbalancer.public\\\",\\\"token\\\",\\\"virtual_host\\\",\\\"virtual_k8s\\\",\\\"waf\\\",\\\"udp_loadbalancer\\\",\\\"udp_loadbalancer.public\\\"]"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace is used to scope the fetching of usage data for the given namespace.\n At present, only system namespace is supported.\n\nExample: - \"system\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "time": {
                    "type": "string",
                    "description": " Timestamp at which the snapshot of the usage should be fetched.\n\n Optional: If not specified, then the timestamp will be evaluated to current time,",
                    "title": "Time",
                    "format": "date-time",
                    "x-displayname": "Time"
                }
            }
        },
        "billingUsageCountResponse": {
            "type": "object",
            "description": "Response for Usage Count Request",
            "title": "Usage Count Response",
            "x-displayname": "Usage Count Response",
            "x-ves-proto-message": "ves.io.schema.billing.UsageCountResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "description": " Usage count for fields specified in the request",
                    "title": "Data",
                    "items": {
                        "$ref": "#/definitions/billingUsageCountData"
                    },
                    "x-displayname": "Data"
                }
            }
        },
        "billingVolterraNWTrafficData": {
            "type": "object",
            "description": "Contains the traffic to the F5XC Network in bytes for a unique combination of group_by label values in the response",
            "title": "VolterraNWTrafficData",
            "x-displayname": "F5XC Network Traffic Data",
            "x-ves-proto-message": "ves.io.schema.billing.VolterraNWTrafficData",
            "properties": {
                "id": {
                    "description": " ID identifies unique combination of group_by label values in the response",
                    "title": "ID",
                    "$ref": "#/definitions/billingVolterraNWTrafficId",
                    "x-displayname": "ID"
                },
                "metric": {
                    "type": "array",
                    "description": " metric value in bytes",
                    "title": "Metric",
                    "items": {
                        "$ref": "#/definitions/schemabillingMetricValue"
                    },
                    "x-displayname": "Metric"
                }
            }
        },
        "billingVolterraNWTrafficId": {
            "type": "object",
            "description": "VolterraNWTrafficId uniquely identifies an entry in the response for F5XC Network Traffic Request.\nTraffic data is aggregated based on the labels in the group_by field in the request.\nTherefore, only the fields that correspond to the label in the group_by field will have non-empty\nvalue in the response.",
            "title": "VolterraNWTrafficId",
            "x-displayname": "F5XC Network Traffic ID",
            "x-ves-proto-message": "ves.io.schema.billing.VolterraNWTrafficId",
            "properties": {
                "dst_site": {
                    "type": "string",
                    "description": "\n\nExample: - \"re01\"-",
                    "title": "Destination Site",
                    "x-displayname": "Destination Site",
                    "x-ves-example": "re01"
                },
                "src_site": {
                    "type": "string",
                    "description": "\n\nExample: - \"ce01\"-",
                    "title": "Source Site",
                    "x-displayname": "Source Site",
                    "x-ves-example": "ce01"
                }
            }
        },
        "billingVolterraNWTrafficLabel": {
            "type": "string",
            "description": "One or more of these labels may be specified in the label_filter or group_by to\nslice and dice the traffic to the F5XC Network.\n",
            "title": "VolterraNWTrafficLabel",
            "enum": [
                "SRC_SITE",
                "DST_SITE"
            ],
            "default": "SRC_SITE",
            "x-displayname": "F5XC Traffic Metric Labels",
            "x-ves-proto-enum": "ves.io.schema.billing.VolterraNWTrafficLabel"
        },
        "billingVolterraNWTrafficLabelFilter": {
            "type": "object",
            "description": "One or more label filter can be specified to fetch the timeseries that matches the label filter",
            "title": "VolterraNWTrafficLabelFilter",
            "x-displayname": "F5XC Network Traffic Label Filter",
            "x-ves-proto-message": "ves.io.schema.billing.VolterraNWTrafficLabelFilter",
            "properties": {
                "label": {
                    "description": " Label in F5XC Network Traffic metric",
                    "title": "Label",
                    "$ref": "#/definitions/billingVolterraNWTrafficLabel",
                    "x-displayname": "Label"
                },
                "op": {
                    "description": " Operator to evaluate the label in this filter",
                    "title": "Operator",
                    "$ref": "#/definitions/schemabillingMetricLabelOp",
                    "x-displayname": "Operator"
                },
                "value": {
                    "type": "string",
                    "description": " Value to be compared with\n\nExample: - \"site-1\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "site-1"
                }
            }
        },
        "billingVolterraNetworkTrafficRequest": {
            "type": "object",
            "description": "Request to get traffic to F5XC Network (REGIONAL_SITEs) for a tenant",
            "title": "VolterraNetworkTrafficRequest",
            "x-displayname": "Traffic to F5XC Network",
            "x-ves-proto-message": "ves.io.schema.billing.VolterraNetworkTrafficRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by none or more labels listed here.\n SRC_SITE, DST_SITE\n\n Optional: If not specified, then the billing data will be aggregated across all SRC_SITE and DST_SITE.",
                    "title": "Group by",
                    "items": {
                        "$ref": "#/definitions/billingVolterraNWTrafficLabel"
                    },
                    "x-displayname": "Group By"
                },
                "label_filter": {
                    "type": "array",
                    "description": " List of label filter expressions of the form \"label\" Op \"value\".\n Response will only contain data that matches all the conditions specified in the label_filter.\n one or more of the following labels can be specified in the label_filter.\n SRC_SITE, DST_SITE\n\n Optional: If not specified, then the metrics will be aggregated across all SRC_SITE and DST_SITE for the tenant.",
                    "title": "Label Filter",
                    "items": {
                        "$ref": "#/definitions/billingVolterraNWTrafficLabelFilter"
                    },
                    "x-displayname": "Label Filter"
                },
                "namespace": {
                    "type": "string",
                    "description": " This request is valid only system namespace\n\nExample: - \"system\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system"
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"15m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_step: true\n",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "15m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_step": "true"
                    }
                }
            }
        },
        "billingVolterraNetworkTrafficResponse": {
            "type": "object",
            "description": "Response message for traffic to F5XC Network.\nResponse may contain one or more entries depending on the label_filter and the group_by fields in the request.\nFor example, if the label_filter specifies SRC_SITE=site1 and group_by DST_SITE, then the response will\ncontain one entry per DST_SITE for traffic from site1 in the response. In the above example, if the label_filter is\nnot specified and the group_by(SRC_SITE, DST_SITE), then the response will contain one entry per (SRC_SITE, DST_SITE)\ncombination for the tenant.",
            "title": "VolterraNetworkTrafficResponse",
            "x-displayname": "F5XC Network Traffic Response",
            "x-ves-proto-message": "ves.io.schema.billing.VolterraNetworkTrafficResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/billingVolterraNWTrafficData"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"30m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "step",
                    "x-displayname": "Step",
                    "x-ves-example": "30m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                }
            }
        },
        "ioschemaMetricValue": {
            "type": "object",
            "description": "Metric data contains timestamp and the value.",
            "title": "Metric Value",
            "x-displayname": "Metric Value",
            "x-ves-proto-message": "ves.io.schema.MetricValue",
            "properties": {
                "timestamp": {
                    "type": "number",
                    "description": " timestamp\n\nExample: - \"1570007981\"-",
                    "title": "Timestamp",
                    "format": "double",
                    "x-displayname": "Timestamp",
                    "x-ves-example": "1570007981"
                },
                "trend_value": {
                    "description": " trend value for the metric\n\nExample: - \"100.000000\"-",
                    "title": "Trend value",
                    "$ref": "#/definitions/schemaTrendValue",
                    "x-displayname": "Trend Value",
                    "x-ves-example": "100.000000"
                },
                "value": {
                    "type": "string",
                    "description": "\n\nExample: - \"15\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "15"
                }
            }
        },
        "schemaMetricTypeData": {
            "type": "object",
            "description": "Metric Type Data contains key that uniquely identifies individual entity and its corresponding metric values.",
            "title": "Metric Type Data",
            "x-displayname": "Metric Type Data",
            "x-ves-proto-message": "ves.io.schema.MetricTypeData",
            "properties": {
                "labels": {
                    "type": "object",
                    "description": " Labels contains the name/value pair that uniquely identifies an entity whose metric is being reported.\n If the Labels is empty, then the metric value is aggregated across all labels.",
                    "title": "Labels",
                    "x-displayname": "Labels"
                },
                "values": {
                    "type": "array",
                    "description": " List of metric values. May contain more than one value if timeseries data is requested.",
                    "title": "Value",
                    "items": {
                        "$ref": "#/definitions/ioschemaMetricValue"
                    },
                    "x-displayname": "Value"
                }
            }
        },
        "schemaTrendSentiment": {
            "type": "string",
            "description": "trend sentiment\n\nIndicates trend sentiment is positive\nIndicates trend sentiment is negative.",
            "title": "Trend Sentiment",
            "enum": [
                "TREND_SENTIMENT_NONE",
                "TREND_SENTIMENT_POSITIVE",
                "TREND_SENTIMENT_NEGATIVE"
            ],
            "default": "TREND_SENTIMENT_NONE",
            "x-displayname": "Trend Sentiment",
            "x-ves-proto-enum": "ves.io.schema.TrendSentiment"
        },
        "schemaTrendValue": {
            "type": "object",
            "description": "Trend value contains trend value, trend sentiment and trend calculation description and window size.",
            "title": "Trend Value",
            "x-displayname": "Trend Value",
            "x-ves-proto-message": "ves.io.schema.TrendValue",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " description of the method used to calculate trend.\n\nExample: - \"Trend was calculated by comparing the avg of window size intervals of end-start Time and last window time interval\"-",
                    "title": "Description",
                    "x-displayname": "Description",
                    "x-ves-example": "Trend was calculated by comparing the avg of window size intervals of end-start Time and last window time interval"
                },
                "previous_value": {
                    "type": "string",
                    "description": "\n\nExample: - \"200.00\"-",
                    "title": "Previous Value",
                    "x-displayname": "Previous Value",
                    "x-ves-example": "200.00"
                },
                "sentiment": {
                    "description": "\n\nExample: - \"Positive\"-",
                    "title": "Sentiment",
                    "$ref": "#/definitions/schemaTrendSentiment",
                    "x-displayname": "Sentiment",
                    "x-ves-example": "Positive"
                },
                "value": {
                    "type": "string",
                    "description": "\n\nExample: - \"-15\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "-15"
                }
            }
        },
        "schemaUnitType": {
            "type": "string",
            "description": "UnitType is enumeration of units for scalar fields",
            "title": "UnitType",
            "enum": [
                "UNIT_MILLISECONDS",
                "UNIT_SECONDS",
                "UNIT_MINUTES",
                "UNIT_HOURS",
                "UNIT_DAYS",
                "UNIT_BYTES",
                "UNIT_KBYTES",
                "UNIT_MBYTES",
                "UNIT_GBYTES",
                "UNIT_TBYTES",
                "UNIT_KIBIBYTES",
                "UNIT_MIBIBYTES",
                "UNIT_GIBIBYTES",
                "UNIT_TEBIBYTES",
                "UNIT_BITS_PER_SECOND",
                "UNIT_BYTES_PER_SECOND",
                "UNIT_KBITS_PER_SECOND",
                "UNIT_KBYTES_PER_SECOND",
                "UNIT_MBITS_PER_SECOND",
                "UNIT_MBYTES_PER_SECOND",
                "UNIT_CONNECTIONS_PER_SECOND",
                "UNIT_ERRORS_PER_SECOND",
                "UNIT_PACKETS_PER_SECOND",
                "UNIT_REQUESTS_PER_SECOND",
                "UNIT_PACKETS",
                "UNIT_PERCENTAGE",
                "UNIT_COUNT"
            ],
            "default": "UNIT_MILLISECONDS",
            "x-displayname": "Unit",
            "x-ves-proto-enum": "ves.io.schema.UnitType"
        },
        "schemabillingMetricLabelOp": {
            "type": "string",
            "description": "The operator to use when querying Billing metrics with labels.\nQuery can choose to either select a label if it matches a given value or\nif it done not match a given value. this is done by choosing the eq or neq operator\nin MetricLabelFilter\n\nInvalid Operator/Not specified\nEqual to\nNot Equal to\nRegex Match",
            "title": "Billing Metric Label Operator",
            "enum": [
                "INVALID_OP",
                "EQ",
                "NEQ",
                "REGEX"
            ],
            "default": "INVALID_OP",
            "x-displayname": "Billing Metric Label Operator",
            "x-ves-proto-enum": "ves.io.schema.billing.MetricLabelOp"
        },
        "schemabillingMetricValue": {
            "type": "object",
            "description": "Value returned for a Billing Metrics query",
            "title": "Metric Value",
            "x-displayname": "Metric Value",
            "x-ves-proto-message": "ves.io.schema.billing.MetricValue",
            "properties": {
                "timestamp": {
                    "type": "number",
                    "description": " timestamp\n\nExample: - \"1570007981\"-",
                    "title": "Timestamp",
                    "format": "double",
                    "x-displayname": "Timestamp",
                    "x-ves-example": "1570007981"
                },
                "value": {
                    "type": "string",
                    "description": " value\n\nExample: - \"15\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "15"
                }
            }
        },
        "siteSiteType": {
            "type": "string",
            "description": "Site Type which can either RE or CE\n\nInvalid type of site\nRegional Edge site\nCustomer Edge site",
            "title": "SiteType",
            "enum": [
                "INVALID",
                "REGIONAL_EDGE",
                "CUSTOMER_EDGE",
                "NGINX_ONE"
            ],
            "default": "INVALID",
            "x-displayname": "Site Type",
            "x-ves-proto-enum": "ves.io.schema.site.SiteType"
        }
    },
    "x-displayname": "Billing",
    "x-ves-proto-file": "ves.io/schema/billing/private_customapi.proto"
}`
