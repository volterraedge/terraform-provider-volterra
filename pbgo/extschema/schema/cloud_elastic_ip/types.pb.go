// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/cloud_elastic_ip/types.proto

package cloud_elastic_ip

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for Cloud Elastic IP
type GlobalSpecType struct {
	// site reference
	//
	// x-displayName: "Site Reference"
	// x-required
	// Site to which this cloud elastic ip object is attached
	SiteRef []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=site_ref,json=siteRef,proto3" json:"site_ref,omitempty"`
	// count
	//
	// x-displayName: "Elastic IP Count Per Node"
	// x-example: "3"
	// number of Elastic Ips / Public Ips associated with this object per Node
	Count uint32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// finalizer_timestamp
	//
	// x-displayName: "Finalizer Timestamp"
	// Finalizer Timestamp is set to current_time when User deletes the cloud elastic ip object from the console.
	// UI keeps polling finalizer_timestamp. When (current_time - finalizer_timestamp) > 30 minutes, user is allowed to Retry/Force-Delete the Cloud Elastic IP object.
	FinalizerTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=finalizer_timestamp,json=finalizerTimestamp,proto3" json:"finalizer_timestamp,omitempty"`
	// force_delete
	//
	// x-displayName: "Force Delete"
	// This flag is set when User deletes cloud elastic ip object from the console and the underlying AWS TGW site is in FAILED state.
	// UI enables FORCE DELETE action on the console if force_delete flag is set to TRUE
	ForceDelete bool `protobuf:"varint,4,opt,name=force_delete,json=forceDelete,proto3" json:"force_delete,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b5f3eeb451f438a, []int{0}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetSiteRef() []*schema.ObjectRefType {
	if m != nil {
		return m.SiteRef
	}
	return nil
}

func (m *GlobalSpecType) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GlobalSpecType) GetFinalizerTimestamp() *types.Timestamp {
	if m != nil {
		return m.FinalizerTimestamp
	}
	return nil
}

func (m *GlobalSpecType) GetForceDelete() bool {
	if m != nil {
		return m.ForceDelete
	}
	return false
}

// Create Cloud Elastic IP
//
// x-displayName: "Create Cloud Elastic IP"
// Create Cloud Elastic IP creates Cloud Elastic IP object
// Object is attached to a site
type CreateSpecType struct {
	SiteRef []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=site_ref,json=siteRef,proto3" json:"site_ref,omitempty"`
	Count   uint32                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b5f3eeb451f438a, []int{1}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetSiteRef() []*schema.ObjectRefType {
	if m != nil {
		return m.SiteRef
	}
	return nil
}

func (m *CreateSpecType) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Replace Cloud Elastic IP
//
// x-displayName: "Replace Cloud Elastic IP"
// Replace cloud elastic ip will replace cloud elastic ip object with new object
type ReplaceSpecType struct {
	SiteRef []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=site_ref,json=siteRef,proto3" json:"site_ref,omitempty"`
	Count   uint32                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b5f3eeb451f438a, []int{2}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetSiteRef() []*schema.ObjectRefType {
	if m != nil {
		return m.SiteRef
	}
	return nil
}

func (m *ReplaceSpecType) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Get cloud elastic ip
//
// x-displayName: "Get Cloud Elastic IP"
// Get cloud elastic ip will get the object from the storage backend for namespace metadata.namespace
type GetSpecType struct {
	SiteRef            []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=site_ref,json=siteRef,proto3" json:"site_ref,omitempty"`
	Count              uint32                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	FinalizerTimestamp *types.Timestamp        `protobuf:"bytes,3,opt,name=finalizer_timestamp,json=finalizerTimestamp,proto3" json:"finalizer_timestamp,omitempty"`
	ForceDelete        bool                    `protobuf:"varint,4,opt,name=force_delete,json=forceDelete,proto3" json:"force_delete,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b5f3eeb451f438a, []int{3}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetSiteRef() []*schema.ObjectRefType {
	if m != nil {
		return m.SiteRef
	}
	return nil
}

func (m *GetSpecType) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GetSpecType) GetFinalizerTimestamp() *types.Timestamp {
	if m != nil {
		return m.FinalizerTimestamp
	}
	return nil
}

func (m *GetSpecType) GetForceDelete() bool {
	if m != nil {
		return m.ForceDelete
	}
	return false
}

// Delete cloud elastic ip
//
// x-displayName: "Delete Cloud Elastic IP"
// Get cloud elastic ip will get the object from the storage backend for namespace metadata.namespace
type DeleteSpecType struct {
	SiteRef []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=site_ref,json=siteRef,proto3" json:"site_ref,omitempty"`
	Count   uint32                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *DeleteSpecType) Reset()      { *m = DeleteSpecType{} }
func (*DeleteSpecType) ProtoMessage() {}
func (*DeleteSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b5f3eeb451f438a, []int{4}
}
func (m *DeleteSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeleteSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSpecType.Merge(m, src)
}
func (m *DeleteSpecType) XXX_Size() int {
	return m.Size()
}
func (m *DeleteSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSpecType proto.InternalMessageInfo

func (m *DeleteSpecType) GetSiteRef() []*schema.ObjectRefType {
	if m != nil {
		return m.SiteRef
	}
	return nil
}

func (m *DeleteSpecType) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Elastic IP Status
//
// x-displayName: "Elastic IP Status "
// Includes deployment info
type ElasticIPStatusType struct {
	// node name
	//
	// x-displayName: "VER Node Name"
	// x-example: "master-0"
	// VER node name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Elastic IP infos
	//
	// x-displayName: "Elastic IP infos"
	// Elastic IP infos
	ElacticIpInfos []*ElasticIPInfoType `protobuf:"bytes,2,rep,name=elactic_ip_infos,json=elacticIpInfos,proto3" json:"elactic_ip_infos,omitempty"`
}

func (m *ElasticIPStatusType) Reset()      { *m = ElasticIPStatusType{} }
func (*ElasticIPStatusType) ProtoMessage() {}
func (*ElasticIPStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b5f3eeb451f438a, []int{5}
}
func (m *ElasticIPStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElasticIPStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ElasticIPStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElasticIPStatusType.Merge(m, src)
}
func (m *ElasticIPStatusType) XXX_Size() int {
	return m.Size()
}
func (m *ElasticIPStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_ElasticIPStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_ElasticIPStatusType proto.InternalMessageInfo

func (m *ElasticIPStatusType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ElasticIPStatusType) GetElacticIpInfos() []*ElasticIPInfoType {
	if m != nil {
		return m.ElacticIpInfos
	}
	return nil
}

// Elastic IP Info type
//
// x-displayName: "Elastic IP Status"
// Includes deployment info
type ElasticIPInfoType struct {
	// Elastic IP resource ID
	//
	// x-displayName: "Elastic IP resource ID"
	// Elastic IP resource ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Provider
	//
	// x-displayName: "Provider"
	// AWS or Azure
	Provider string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	// Private IPv4 address
	//
	// x-displayName: "Private IPv4 address"
	// IPv4 address
	PrivateIpAddress string `protobuf:"bytes,3,opt,name=private_ip_address,json=privateIpAddress,proto3" json:"private_ip_address,omitempty"`
	// Public IPv4 address
	//
	// x-displayName: "Public IPv4 address"
	// Public IPv4 address
	PublicIpAddress string `protobuf:"bytes,4,opt,name=public_ip_address,json=publicIpAddress,proto3" json:"public_ip_address,omitempty"`
}

func (m *ElasticIPInfoType) Reset()      { *m = ElasticIPInfoType{} }
func (*ElasticIPInfoType) ProtoMessage() {}
func (*ElasticIPInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_8b5f3eeb451f438a, []int{6}
}
func (m *ElasticIPInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElasticIPInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ElasticIPInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElasticIPInfoType.Merge(m, src)
}
func (m *ElasticIPInfoType) XXX_Size() int {
	return m.Size()
}
func (m *ElasticIPInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_ElasticIPInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_ElasticIPInfoType proto.InternalMessageInfo

func (m *ElasticIPInfoType) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ElasticIPInfoType) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *ElasticIPInfoType) GetPrivateIpAddress() string {
	if m != nil {
		return m.PrivateIpAddress
	}
	return ""
}

func (m *ElasticIPInfoType) GetPublicIpAddress() string {
	if m != nil {
		return m.PublicIpAddress
	}
	return ""
}

func init() {
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_elastic_ip.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_elastic_ip.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_elastic_ip.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_elastic_ip.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_elastic_ip.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_elastic_ip.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_elastic_ip.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_elastic_ip.GetSpecType")
	proto.RegisterType((*DeleteSpecType)(nil), "ves.io.schema.cloud_elastic_ip.DeleteSpecType")
	golang_proto.RegisterType((*DeleteSpecType)(nil), "ves.io.schema.cloud_elastic_ip.DeleteSpecType")
	proto.RegisterType((*ElasticIPStatusType)(nil), "ves.io.schema.cloud_elastic_ip.ElasticIPStatusType")
	golang_proto.RegisterType((*ElasticIPStatusType)(nil), "ves.io.schema.cloud_elastic_ip.ElasticIPStatusType")
	proto.RegisterType((*ElasticIPInfoType)(nil), "ves.io.schema.cloud_elastic_ip.ElasticIPInfoType")
	golang_proto.RegisterType((*ElasticIPInfoType)(nil), "ves.io.schema.cloud_elastic_ip.ElasticIPInfoType")
}

func init() {
	proto.RegisterFile("ves.io/schema/cloud_elastic_ip/types.proto", fileDescriptor_8b5f3eeb451f438a)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/cloud_elastic_ip/types.proto", fileDescriptor_8b5f3eeb451f438a)
}

var fileDescriptor_8b5f3eeb451f438a = []byte{
	// 691 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x95, 0x3f, 0x6f, 0xd3, 0x40,
	0x18, 0xc6, 0x73, 0x69, 0xda, 0x26, 0x17, 0x48, 0x1b, 0x57, 0x48, 0x26, 0x54, 0xd7, 0x34, 0x53,
	0x14, 0x51, 0x5b, 0x94, 0x8d, 0x01, 0x89, 0x00, 0xaa, 0x02, 0x12, 0x20, 0x37, 0x13, 0x0c, 0xd1,
	0xc5, 0x7e, 0xed, 0x1e, 0x38, 0xb9, 0x93, 0x7d, 0x09, 0x14, 0xa9, 0x52, 0x17, 0x98, 0x4b, 0x37,
	0xbe, 0x01, 0xe2, 0x23, 0x00, 0x43, 0x47, 0xc4, 0xd4, 0x31, 0x23, 0x75, 0x96, 0xb2, 0xf5, 0x0b,
	0x20, 0x21, 0xff, 0x49, 0x4a, 0x4a, 0x40, 0x82, 0x85, 0x6e, 0x77, 0xf7, 0xfc, 0xee, 0xfc, 0xdc,
	0x73, 0xaf, 0x5e, 0xe3, 0x5a, 0x1f, 0x7c, 0x8d, 0x71, 0xdd, 0x37, 0xb7, 0xa0, 0x43, 0x75, 0xd3,
	0xe5, 0x3d, 0xab, 0x05, 0x2e, 0xf5, 0x25, 0x33, 0x5b, 0x4c, 0xe8, 0x72, 0x5b, 0x80, 0xaf, 0x09,
	0x8f, 0x4b, 0xae, 0x90, 0x98, 0xd5, 0x62, 0x56, 0x3b, 0xcb, 0x96, 0xd6, 0x1c, 0x26, 0xb7, 0x7a,
	0x6d, 0xcd, 0xe4, 0x1d, 0xdd, 0xe1, 0x0e, 0xd7, 0xa3, 0x6d, 0xed, 0x9e, 0x1d, 0xcd, 0xa2, 0x49,
	0x34, 0x8a, 0x8f, 0x2b, 0xad, 0x38, 0x9c, 0x3b, 0x2e, 0x9c, 0x52, 0x92, 0x75, 0xc0, 0x97, 0xb4,
	0x23, 0x12, 0xe0, 0xca, 0xa4, 0x37, 0x2e, 0x24, 0xe3, 0xdd, 0xc4, 0x4c, 0xe9, 0xf2, 0xa4, 0xf8,
	0x93, 0xcf, 0xd2, 0xf2, 0xa4, 0xd4, 0xa7, 0x2e, 0xb3, 0xa8, 0x84, 0x44, 0x2d, 0x9f, 0x51, 0x19,
	0x3c, 0x6f, 0x4d, 0x1c, 0x5d, 0x79, 0x95, 0xc6, 0x85, 0x0d, 0x97, 0xb7, 0xa9, 0xbb, 0x29, 0xc0,
	0x6c, 0x6e, 0x0b, 0x50, 0x1e, 0xe0, 0xac, 0xcf, 0x24, 0xb4, 0x3c, 0xb0, 0x55, 0x54, 0x9e, 0xa9,
	0xe6, 0xd7, 0x97, 0xb5, 0xc9, 0x34, 0x1e, 0xb6, 0x9f, 0x82, 0x29, 0x0d, 0xb0, 0x43, 0xbe, 0x7e,
	0xe9, 0xfd, 0x4e, 0x26, 0xdc, 0xb0, 0xfb, 0x09, 0xa1, 0x0f, 0xdf, 0x0e, 0x66, 0x66, 0xf7, 0x51,
	0x7a, 0x11, 0x19, 0xf3, 0xe1, 0x9a, 0x01, 0xb6, 0xb2, 0x8a, 0x67, 0x4d, 0xde, 0xeb, 0x4a, 0x35,
	0x5d, 0x46, 0xd5, 0x8b, 0xf5, 0x7c, 0xc8, 0xcc, 0xd5, 0x32, 0x6a, 0xb6, 0x8a, 0x8c, 0x58, 0x51,
	0x9a, 0x78, 0xc9, 0x66, 0x5d, 0xea, 0xb2, 0x97, 0xe0, 0xb5, 0xc6, 0xd1, 0xa8, 0x33, 0x65, 0x54,
	0xcd, 0xaf, 0x97, 0xb4, 0x38, 0x3c, 0x6d, 0x14, 0x9e, 0xd6, 0x1c, 0x11, 0xf5, 0xf9, 0xc1, 0x0e,
	0x3a, 0xfe, 0x88, 0x90, 0xa1, 0x8c, 0xf7, 0x8f, 0x45, 0xa5, 0x86, 0x2f, 0xd8, 0xdc, 0x33, 0xa1,
	0x65, 0x81, 0x0b, 0x12, 0xd4, 0x4c, 0x19, 0x55, 0xb3, 0xa7, 0x5b, 0xf2, 0x91, 0x78, 0x27, 0xd2,
	0x2a, 0x7b, 0x08, 0x17, 0x6e, 0x7b, 0x40, 0x25, 0x8c, 0x73, 0xb8, 0xf7, 0x97, 0x39, 0x14, 0x93,
	0x1c, 0xa6, 0x65, 0xb0, 0x32, 0x99, 0x41, 0x2e, 0x64, 0x32, 0xb5, 0xb4, 0x9a, 0x4d, 0x12, 0xb8,
	0x51, 0xfc, 0x72, 0xf3, 0xcc, 0x3b, 0x54, 0xde, 0x20, 0xbc, 0x60, 0x80, 0x70, 0xa9, 0x79, 0x7e,
	0x3c, 0x7d, 0x47, 0x38, 0xbf, 0x01, 0xf2, 0xbf, 0xf8, 0x51, 0xee, 0xff, 0x63, 0x95, 0x4c, 0x2d,
	0x8e, 0xd5, 0x69, 0xc5, 0x31, 0x51, 0x13, 0xd3, 0xee, 0x1f, 0x96, 0x49, 0xac, 0x9e, 0x9b, 0x27,
	0x79, 0x8d, 0xf0, 0xd2, 0xdd, 0xb8, 0x31, 0x35, 0x1e, 0x6d, 0x4a, 0x2a, 0x7b, 0x7e, 0xe4, 0x4b,
	0xc1, 0x99, 0x2e, 0xed, 0x80, 0x8a, 0xca, 0xa8, 0x9a, 0x33, 0xa2, 0xb1, 0xf2, 0x04, 0x2f, 0x82,
	0x4b, 0xcd, 0xb8, 0x87, 0xb5, 0x58, 0xd7, 0xe6, 0xbe, 0x9a, 0x8e, 0x3c, 0x5f, 0xd3, 0xfe, 0xdc,
	0xf0, 0xb4, 0xf1, 0x27, 0x1a, 0x5d, 0x9b, 0x87, 0x1f, 0x30, 0x0a, 0xc9, 0x51, 0x0d, 0x11, 0x2e,
	0xf9, 0x95, 0xb7, 0x08, 0x17, 0x7f, 0xa1, 0x94, 0x02, 0x4e, 0x33, 0x2b, 0x31, 0x91, 0x66, 0x96,
	0x52, 0xc2, 0x59, 0xe1, 0xf1, 0x3e, 0xb3, 0xc0, 0x8b, 0x6e, 0x99, 0x33, 0xc6, 0x73, 0xe5, 0x2a,
	0x56, 0x84, 0xc7, 0xfa, 0x54, 0x42, 0x68, 0x8f, 0x5a, 0x96, 0x07, 0xbe, 0x1f, 0xbd, 0x6f, 0xce,
	0x58, 0x4c, 0x94, 0x86, 0xb8, 0x15, 0xaf, 0x2b, 0x35, 0x5c, 0x14, 0xbd, 0xb6, 0x1b, 0xdf, 0x65,
	0x04, 0x67, 0x22, 0x78, 0x21, 0x16, 0xc6, 0x6c, 0x7d, 0x1f, 0x1d, 0x1e, 0x91, 0xd4, 0xe0, 0x88,
	0xa4, 0x4e, 0x8e, 0x08, 0xda, 0x0d, 0x08, 0x7a, 0x17, 0x10, 0xf4, 0x39, 0x20, 0xe8, 0x30, 0x20,
	0x68, 0x10, 0x10, 0xf4, 0x35, 0x20, 0xe8, 0x38, 0x20, 0xa9, 0x93, 0x80, 0xa0, 0xbd, 0x21, 0x49,
	0x1d, 0x0c, 0x09, 0x3a, 0x1c, 0x92, 0xd4, 0x60, 0x48, 0x52, 0x8f, 0x9b, 0x0e, 0x17, 0xcf, 0x1c,
	0xad, 0xcf, 0x5d, 0x09, 0x9e, 0x47, 0xb5, 0x9e, 0xaf, 0x47, 0x03, 0x9b, 0x7b, 0x9d, 0xb5, 0x91,
	0xfd, 0xb5, 0x91, 0xac, 0x8b, 0xb6, 0xc3, 0x75, 0x78, 0x21, 0x93, 0xb6, 0xfb, 0x9b, 0xff, 0x4d,
	0x7b, 0x2e, 0x2a, 0xd5, 0xeb, 0x3f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xac, 0xf0, 0xc1, 0x15, 0x98,
	0x06, 0x00, 0x00,
}

func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SiteRef) != len(that1.SiteRef) {
		return false
	}
	for i := range this.SiteRef {
		if !this.SiteRef[i].Equal(that1.SiteRef[i]) {
			return false
		}
	}
	if this.Count != that1.Count {
		return false
	}
	if !this.FinalizerTimestamp.Equal(that1.FinalizerTimestamp) {
		return false
	}
	if this.ForceDelete != that1.ForceDelete {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SiteRef) != len(that1.SiteRef) {
		return false
	}
	for i := range this.SiteRef {
		if !this.SiteRef[i].Equal(that1.SiteRef[i]) {
			return false
		}
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SiteRef) != len(that1.SiteRef) {
		return false
	}
	for i := range this.SiteRef {
		if !this.SiteRef[i].Equal(that1.SiteRef[i]) {
			return false
		}
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SiteRef) != len(that1.SiteRef) {
		return false
	}
	for i := range this.SiteRef {
		if !this.SiteRef[i].Equal(that1.SiteRef[i]) {
			return false
		}
	}
	if this.Count != that1.Count {
		return false
	}
	if !this.FinalizerTimestamp.Equal(that1.FinalizerTimestamp) {
		return false
	}
	if this.ForceDelete != that1.ForceDelete {
		return false
	}
	return true
}
func (this *DeleteSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteSpecType)
	if !ok {
		that2, ok := that.(DeleteSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SiteRef) != len(that1.SiteRef) {
		return false
	}
	for i := range this.SiteRef {
		if !this.SiteRef[i].Equal(that1.SiteRef[i]) {
			return false
		}
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *ElasticIPStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElasticIPStatusType)
	if !ok {
		that2, ok := that.(ElasticIPStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.ElacticIpInfos) != len(that1.ElacticIpInfos) {
		return false
	}
	for i := range this.ElacticIpInfos {
		if !this.ElacticIpInfos[i].Equal(that1.ElacticIpInfos[i]) {
			return false
		}
	}
	return true
}
func (this *ElasticIPInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElasticIPInfoType)
	if !ok {
		that2, ok := that.(ElasticIPInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if this.PrivateIpAddress != that1.PrivateIpAddress {
		return false
	}
	if this.PublicIpAddress != that1.PublicIpAddress {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_elastic_ip.GlobalSpecType{")
	if this.SiteRef != nil {
		s = append(s, "SiteRef: "+fmt.Sprintf("%#v", this.SiteRef)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	if this.FinalizerTimestamp != nil {
		s = append(s, "FinalizerTimestamp: "+fmt.Sprintf("%#v", this.FinalizerTimestamp)+",\n")
	}
	s = append(s, "ForceDelete: "+fmt.Sprintf("%#v", this.ForceDelete)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_elastic_ip.CreateSpecType{")
	if this.SiteRef != nil {
		s = append(s, "SiteRef: "+fmt.Sprintf("%#v", this.SiteRef)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_elastic_ip.ReplaceSpecType{")
	if this.SiteRef != nil {
		s = append(s, "SiteRef: "+fmt.Sprintf("%#v", this.SiteRef)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_elastic_ip.GetSpecType{")
	if this.SiteRef != nil {
		s = append(s, "SiteRef: "+fmt.Sprintf("%#v", this.SiteRef)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	if this.FinalizerTimestamp != nil {
		s = append(s, "FinalizerTimestamp: "+fmt.Sprintf("%#v", this.FinalizerTimestamp)+",\n")
	}
	s = append(s, "ForceDelete: "+fmt.Sprintf("%#v", this.ForceDelete)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_elastic_ip.DeleteSpecType{")
	if this.SiteRef != nil {
		s = append(s, "SiteRef: "+fmt.Sprintf("%#v", this.SiteRef)+",\n")
	}
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ElasticIPStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_elastic_ip.ElasticIPStatusType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ElacticIpInfos != nil {
		s = append(s, "ElacticIpInfos: "+fmt.Sprintf("%#v", this.ElacticIpInfos)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ElasticIPInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_elastic_ip.ElasticIPInfoType{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	s = append(s, "PrivateIpAddress: "+fmt.Sprintf("%#v", this.PrivateIpAddress)+",\n")
	s = append(s, "PublicIpAddress: "+fmt.Sprintf("%#v", this.PublicIpAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForceDelete {
		i--
		if m.ForceDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.FinalizerTimestamp != nil {
		{
			size, err := m.FinalizerTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SiteRef) > 0 {
		for iNdEx := len(m.SiteRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SiteRef) > 0 {
		for iNdEx := len(m.SiteRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SiteRef) > 0 {
		for iNdEx := len(m.SiteRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForceDelete {
		i--
		if m.ForceDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.FinalizerTimestamp != nil {
		{
			size, err := m.FinalizerTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SiteRef) > 0 {
		for iNdEx := len(m.SiteRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SiteRef) > 0 {
		for iNdEx := len(m.SiteRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ElasticIPStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElasticIPStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElasticIPStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ElacticIpInfos) > 0 {
		for iNdEx := len(m.ElacticIpInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ElacticIpInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ElasticIPInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElasticIPInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElasticIPInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicIpAddress) > 0 {
		i -= len(m.PublicIpAddress)
		copy(dAtA[i:], m.PublicIpAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicIpAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PrivateIpAddress) > 0 {
		i -= len(m.PrivateIpAddress)
		copy(dAtA[i:], m.PrivateIpAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateIpAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SiteRef) > 0 {
		for _, e := range m.SiteRef {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovTypes(uint64(m.Count))
	}
	if m.FinalizerTimestamp != nil {
		l = m.FinalizerTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ForceDelete {
		n += 2
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SiteRef) > 0 {
		for _, e := range m.SiteRef {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovTypes(uint64(m.Count))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SiteRef) > 0 {
		for _, e := range m.SiteRef {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovTypes(uint64(m.Count))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SiteRef) > 0 {
		for _, e := range m.SiteRef {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovTypes(uint64(m.Count))
	}
	if m.FinalizerTimestamp != nil {
		l = m.FinalizerTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ForceDelete {
		n += 2
	}
	return n
}

func (m *DeleteSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SiteRef) > 0 {
		for _, e := range m.SiteRef {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovTypes(uint64(m.Count))
	}
	return n
}

func (m *ElasticIPStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ElacticIpInfos) > 0 {
		for _, e := range m.ElacticIpInfos {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ElasticIPInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateIpAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicIpAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteRef := "[]*ObjectRefType{"
	for _, f := range this.SiteRef {
		repeatedStringForSiteRef += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSiteRef += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`SiteRef:` + repeatedStringForSiteRef + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`FinalizerTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.FinalizerTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ForceDelete:` + fmt.Sprintf("%v", this.ForceDelete) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteRef := "[]*ObjectRefType{"
	for _, f := range this.SiteRef {
		repeatedStringForSiteRef += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSiteRef += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`SiteRef:` + repeatedStringForSiteRef + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteRef := "[]*ObjectRefType{"
	for _, f := range this.SiteRef {
		repeatedStringForSiteRef += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSiteRef += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`SiteRef:` + repeatedStringForSiteRef + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteRef := "[]*ObjectRefType{"
	for _, f := range this.SiteRef {
		repeatedStringForSiteRef += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSiteRef += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`SiteRef:` + repeatedStringForSiteRef + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`FinalizerTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.FinalizerTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ForceDelete:` + fmt.Sprintf("%v", this.ForceDelete) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteRef := "[]*ObjectRefType{"
	for _, f := range this.SiteRef {
		repeatedStringForSiteRef += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSiteRef += "}"
	s := strings.Join([]string{`&DeleteSpecType{`,
		`SiteRef:` + repeatedStringForSiteRef + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ElasticIPStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForElacticIpInfos := "[]*ElasticIPInfoType{"
	for _, f := range this.ElacticIpInfos {
		repeatedStringForElacticIpInfos += strings.Replace(f.String(), "ElasticIPInfoType", "ElasticIPInfoType", 1) + ","
	}
	repeatedStringForElacticIpInfos += "}"
	s := strings.Join([]string{`&ElasticIPStatusType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ElacticIpInfos:` + repeatedStringForElacticIpInfos + `,`,
		`}`,
	}, "")
	return s
}
func (this *ElasticIPInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ElasticIPInfoType{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`PrivateIpAddress:` + fmt.Sprintf("%v", this.PrivateIpAddress) + `,`,
		`PublicIpAddress:` + fmt.Sprintf("%v", this.PublicIpAddress) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteRef = append(m.SiteRef, &schema.ObjectRefType{})
			if err := m.SiteRef[len(m.SiteRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizerTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalizerTimestamp == nil {
				m.FinalizerTimestamp = &types.Timestamp{}
			}
			if err := m.FinalizerTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceDelete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteRef = append(m.SiteRef, &schema.ObjectRefType{})
			if err := m.SiteRef[len(m.SiteRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteRef = append(m.SiteRef, &schema.ObjectRefType{})
			if err := m.SiteRef[len(m.SiteRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteRef = append(m.SiteRef, &schema.ObjectRefType{})
			if err := m.SiteRef[len(m.SiteRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizerTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalizerTimestamp == nil {
				m.FinalizerTimestamp = &types.Timestamp{}
			}
			if err := m.FinalizerTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceDelete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteRef = append(m.SiteRef, &schema.ObjectRefType{})
			if err := m.SiteRef[len(m.SiteRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElasticIPStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElasticIPStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElasticIPStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElacticIpInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElacticIpInfos = append(m.ElacticIpInfos, &ElasticIPInfoType{})
			if err := m.ElacticIpInfos[len(m.ElacticIpInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElasticIPInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElasticIPInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElasticIPInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
