//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//

package crudapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	google_protobuf "github.com/gogo/protobuf/types"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	multierror "github.com/hashicorp/go-multierror"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"

	ves_io_schema "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema"
	object "gopkg.volterra.us/terraform-provider-volterra/pbgo/extschema/schema/service_policy_rule"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// augment methods on Object<Oper>Req from api.pb.go

// EntryConverter
func (r *ObjectCreateReq) FromEntry(e db.Entry) {
	r.FromObject(e)
}

func (r *ObjectCreateReq) ToEntry(e db.Entry) {
	r.ToObject(e)
}

// create setters in object from request for oneof fields

// EntryConverter
func (r *ObjectReplaceReq) FromEntry(e db.Entry) {
	r.FromObject(e)
}

func (r *ObjectReplaceReq) ToEntry(e db.Entry) {
	r.ToObject(e)
}

// create setters in object from request for oneof fields

// create setters in response from object for oneof fields

// create setters in response from object for oneof fields

// create setters in response from object for oneof fields

// CLIENT side
func NewObjectCreateReq(e db.Entry) (*ObjectCreateReq, error) {
	r := &ObjectCreateReq{}
	if e == nil {
		return r, nil
	}
	r.FromObject(e)
	return r, nil
}

func NewObjectReplaceReq(e db.Entry) (*ObjectReplaceReq, error) {
	r := &ObjectReplaceReq{}
	if e == nil {
		return r, nil
	}
	r.FromObject(e)
	uid, err := e.Key()
	if err != nil {
		// See if uid can be got from Metadata.Uid
		obj := e.(*object.DBObject)
		uid = obj.GetMetadata().GetUid()

	}
	r.ObjectUid = uid
	return r, nil
}

func NewObjectGetReq(uid string, opts ...server.CRUDCallOpt) *ObjectGetReq {
	ccOpts := server.NewCRUDCallOpts()
	for _, o := range opts {
		o(ccOpts)
	}

	req := &ObjectGetReq{ObjectUid: uid, AllBackrefs: ccOpts.AllBR, BackrefTypes: ccOpts.TypesBR}
	req.IncludeReferredId = ccOpts.IncludeReferredID
	return req
}

func NewObjectListReq(opts ...server.CRUDCallOpt) *ObjectListReq {
	return &ObjectListReq{}
}

func NewObjectDeleteReq(uid string) *ObjectDeleteReq {
	return &ObjectDeleteReq{ObjectUid: uid}
}

// GRPC Client
type crudAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient APIClient
}

func (c *crudAPIGrpcClient) Create(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) (db.Entry, error) {
	req, err := NewObjectCreateReq(e)
	if err != nil {
		return nil, errors.Wrap(err, "Creating new create request")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := c.grpcClient.Create(ctx, req, cco.GrpcCallOpts...)
	if rsp != nil {
		if cco.OutCallResponse != nil {
			cco.OutCallResponse.ProtoMsg = rsp
		}
		o := object.NewDBObject(nil)
		rsp.ToObject(o)
		return o, err
	}
	return nil, err
}

func (c *crudAPIGrpcClient) Replace(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) error {
	req, err := NewObjectReplaceReq(e)
	if err != nil {
		return errors.Wrap(err, "Creating new replace request")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)
	req.ResourceVersion = cco.ResourceVersion

	rsp, err := c.grpcClient.Replace(ctx, req, cco.GrpcCallOpts...)
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err
}

func (c *crudAPIGrpcClient) GetRaw(ctx context.Context, key string, opts ...server.CRUDCallOpt) (*ObjectGetRsp, error) {
	req := NewObjectGetReq(key, opts...)

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := c.grpcClient.Get(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Getting from grpcClient")
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rsp.ResourceVersion
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func (c *crudAPIGrpcClient) Get(ctx context.Context, key string, opts ...server.CRUDCallOpt) (db.Entry, error) {
	rsp, err := c.GetRaw(ctx, key, opts...)
	if rsp != nil {
		o := object.NewDBObject(nil)
		rsp.ToObject(o)
		return o, err
	}
	return nil, err
}

func (c *crudAPIGrpcClient) GetDetail(ctx context.Context, key string, nef db.NewEntryFunc, opts ...server.CRUDCallOpt) (*server.GetResponse, error) {
	var merr *multierror.Error
	gRsp, err := c.GetRaw(ctx, key, opts...)
	if err != nil {
		merr = multierror.Append(merr, err)
	}
	if gRsp == nil {
		return nil, errors.ErrOrNil(merr)
	}
	respDetail := server.GetResponse{}
	respDetail.Entry = object.NewDBObject(nil)
	gRsp.ToObject(respDetail.Entry)
	respDetail.BackRefs, err = gRsp.GetBackrefs(nef)
	if err != nil {
		merr = multierror.Append(merr, err)
	}
	return &respDetail, errors.ErrOrNil(merr)
}

func (c *crudAPIGrpcClient) ListIDs(ctx context.Context, opts ...server.CRUDCallOpt) ([]string, error) {
	idSet := []string{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return idSet, err
	}
	for _, li := range listRsp.GetItems() {
		idSet = append(idSet, li.GetObjectUid())
	}
	return idSet, err
}

func (c *crudAPIGrpcClient) ListItems(ctx context.Context, opts ...server.CRUDCallOpt) ([]server.ListItem, error) {
	sliSet := []server.ListItem{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return sliSet, err
	}
	for _, li := range listRsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err
}

func (c *crudAPIGrpcClient) List(ctx context.Context, opts ...server.CRUDCallOpt) (*ObjectListRsp, error) {
	req := NewObjectListReq()
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)
	req.TenantFilter = cco.TenantFilter
	req.NamespaceFilter = cco.NamespaceFilter
	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		req.LabelFilter = cco.LabelFilter[0]
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}
	req.ReportFields = cco.ReportFields

	req.IncludeReferredId = cco.IncludeReferredID
	if cco.OutResourceVersion != nil {
		req.ResourceVersion = true
	}
	rsp, err := c.grpcClient.List(ctx, req, cco.GrpcCallOpts...)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rsp.GetMetadata().GetResourceVersion()
	}
	return rsp, err
}

func (c *crudAPIGrpcClient) ListStream(ctx context.Context, opts ...server.CRUDCallOpt) (server.ListStreamRsp, error) {
	req := NewObjectListReq()
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)
	req.TenantFilter = cco.TenantFilter
	req.NamespaceFilter = cco.NamespaceFilter
	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		req.LabelFilter = cco.LabelFilter[0]
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}
	req.ReportFields = cco.ReportFields

	req.IncludeReferredId = cco.IncludeReferredID
	stream, err := c.grpcClient.ListStream(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Listing with grpc client")
	}
	lc := &crudAPIGrpcListStreamClient{stream}
	return lc, nil
}

func (c *crudAPIGrpcClient) Delete(ctx context.Context, key string, opts ...server.CRUDCallOpt) error {
	req := NewObjectDeleteReq(key)

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := c.grpcClient.Delete(ctx, req, cco.GrpcCallOpts...)
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err
}

func NewCRUDAPIGrpcClient(cc *grpc.ClientConn) server.CRUDClient {
	ccl := &crudAPIGrpcClient{cc, NewAPIClient(cc)}
	return ccl
}

type crudAPIGrpcListStreamClient struct {
	stream API_ListStreamClient
}

func (lc *crudAPIGrpcListStreamClient) RecvIDs() ([]string, error) {
	idSet := []string{}
	rsp, err := lc.stream.Recv()
	if rsp == nil {
		return idSet, err
	}
	for _, li := range rsp.GetItems() {
		idSet = append(idSet, li.GetObjectUid())
	}
	return idSet, err
}

func (lc *crudAPIGrpcListStreamClient) RecvItems() ([]server.ListItem, error) {
	sliSet := []server.ListItem{}
	rsp, err := lc.stream.Recv()
	if rsp == nil {
		return sliSet, err
	}
	for _, li := range rsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err
}

// REST Client
type crudAPIRestClient struct {
	baseURL string
	client  http.Client
}

func (c *crudAPIRestClient) Create(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) (db.Entry, error) {
	req, err := NewObjectCreateReq(e)
	if err != nil {
		return nil, errors.Wrap(err, "Creating new create request")
	}

	// convert ves.io.examplesvc.objectone.crudapi to ves.io.examplesvc.objectone
	sl := strings.Split("ves.io.schema.service_policy_rule.crudapi", ".")
	t := strings.Join(sl[:len(sl)-1], ".")
	url := fmt.Sprintf("%s/%s/Objects", c.baseURL, t)
	jsn, err := req.ToJSON()
	if err != nil {
		return nil, errors.Wrap(err, "RestClient Create")
	}

	hReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
	if err != nil {
		return nil, err
	}
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	client.AddHdrsToReq(cco.Headers, hReq)
	hReq.Header.Set("Content-Type", "application/json")

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err)
	}
	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient create")
	}

	rspo := &ObjectCreateRsp{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return nil, errors.Wrap(err, "Converting json to response protobuf message")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}
	o := object.NewDBObject(nil)
	rspo.ToObject(o)
	return o, nil
}

func (c *crudAPIRestClient) Replace(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) error {
	rReq, err := NewObjectReplaceReq(e)
	if err != nil {
		return errors.Wrap(err, "Creating new replace request")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if e != nil && cco.ReplaceJSONReq != "" {
		return fmt.Errorf("Both entry and WithReplaceJSONRequest() specified")
	}
	if e == nil && cco.ReplaceJSONReq == "" {
		return fmt.Errorf("Neither entry nor WithReplaceJSONRequest() specified")
	}

	var jsn, objUID string
	if e != nil {
		rReq.ResourceVersion = cco.ResourceVersion
		jsn, err = rReq.ToJSON()
		if err != nil {
			return errors.Wrap(err, "RestClient Replace")
		}
		objUID = rReq.ObjectUid
	} else {
		jsn = cco.ReplaceJSONReq
		reqMap := make(map[string]interface{})
		if err := json.Unmarshal([]byte(jsn), &reqMap); err != nil {
			return errors.Wrapf(err, "Unmarshaling ReplaceJSONReq")
		}
		md, ok := reqMap["metadata"].(map[string]interface{})
		if !ok {
			return fmt.Errorf("ReplaceJSONReq does not have 'metadata'")
		}
		if val, ok := md["uid"].(string); ok {
			objUID = val
		}
	}

	// convert ves.io.examplesvc.objectone.crudapi to ves.io.examplesvc.objectone
	sl := strings.Split("ves.io.schema.service_policy_rule.crudapi", ".")
	t := strings.Join(sl[:len(sl)-1], ".")
	url := fmt.Sprintf("%s/%s/Object/%s", c.baseURL, t, objUID)

	hReq, err := http.NewRequest(http.MethodPut, url, bytes.NewBuffer([]byte(jsn)))
	if err != nil {
		return errors.Wrap(err, "RestClient replace")
	}
	client.AddHdrsToReq(cco.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return errors.Wrap(err, "RestClient replace")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return fmt.Errorf("Unsuccessful PUT at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return errors.Wrap(err, "RestClient replace")
	}

	rspo := &ObjectReplaceRsp{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return errors.Wrap(err, "Converting json to response protobuf message")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}
	return nil
}

func (c *crudAPIRestClient) GetRaw(ctx context.Context, key string, opts ...server.CRUDCallOpt) (*ObjectGetRsp, error) {
	req := NewObjectGetReq(key, opts...)

	// convert ves.io.examplesvc.objectone.crudapi to ves.io.examplesvc.objectone
	sl := strings.Split("ves.io.schema.service_policy_rule.crudapi", ".")
	t := strings.Join(sl[:len(sl)-1], ".")
	url := fmt.Sprintf("%s/%s/Object/%s", c.baseURL, t, req.ObjectUid)

	hReq, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	client.AddHdrsToReq(cco.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient Get")
	}
	defer rsp.Body.Close()
	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful GET at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err)
	}
	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient Get")
	}

	rspo := &ObjectGetRsp{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return nil, errors.Wrap(err, "Converting json to response protobuf message")
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rspo.ResourceVersion
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}
	return rspo, nil
}

func (c *crudAPIRestClient) Get(ctx context.Context, key string, opts ...server.CRUDCallOpt) (db.Entry, error) {
	gRsp, err := c.GetRaw(ctx, key, opts...)
	if gRsp != nil {
		o := object.NewDBObject(nil)
		gRsp.ToObject(o)
		return o, err
	}
	return nil, err
}

func (c *crudAPIRestClient) GetDetail(ctx context.Context, key string, nef db.NewEntryFunc, opts ...server.CRUDCallOpt) (*server.GetResponse, error) {
	var merr *multierror.Error
	gRsp, err := c.GetRaw(ctx, key, opts...)
	respDetail := server.GetResponse{}
	if err != nil {
		merr = multierror.Append(merr, err)
	}
	if gRsp != nil {
		respDetail.Entry = object.NewDBObject(nil)
		gRsp.ToObject(respDetail.Entry)
		respDetail.BackRefs, err = gRsp.GetBackrefs(nef)
		if err != nil {
			merr = multierror.Append(merr, err)
		}
		return &respDetail, errors.ErrOrNil(merr)
	}

	return nil, errors.ErrOrNil(merr)
}

func (c *crudAPIRestClient) ListIDs(ctx context.Context, opts ...server.CRUDCallOpt) ([]string, error) {
	idSet := []string{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return idSet, err
	}
	for _, li := range listRsp.GetItems() {
		idSet = append(idSet, li.GetObjectUid())
	}
	return idSet, err
}

func (c *crudAPIRestClient) ListItems(ctx context.Context, opts ...server.CRUDCallOpt) ([]server.ListItem, error) {
	sliSet := []server.ListItem{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return sliSet, err
	}
	for _, li := range listRsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err
}

func (c *crudAPIRestClient) List(ctx context.Context, opts ...server.CRUDCallOpt) (*ObjectListRsp, error) {
	// convert ves.io.examplesvc.objectone.crudapi to ves.io.examplesvc.objectone
	sl := strings.Split("ves.io.schema.service_policy_rule.crudapi", ".")
	t := strings.Join(sl[:len(sl)-1], ".")
	url := fmt.Sprintf("%s/%s/Objects", c.baseURL, t)

	hReq, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	client.AddHdrsToReq(cco.Headers, hReq)

	q := hReq.URL.Query()
	for _, fVal := range cco.TenantFilter {
		q.Add("tenant_filter", fVal)
	}
	for _, fVal := range cco.NamespaceFilter {
		q.Add("namespace_filter", fVal)
	}
	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		q.Add("label_filter", cco.LabelFilter[0])
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}

	for _, fName := range cco.ReportFields {
		q.Add("report_fields", fName)
	}

	if cco.IncludeReferredID {
		q.Add("include_referred_id", "true")
	}

	if cco.OutResourceVersion != nil {
		q.Add("resource_version", "true")
	}
	hReq.URL.RawQuery += q.Encode()
	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()
	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful List at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err)
	}
	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient List")
	}

	rspo := &ObjectListRsp{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return nil, errors.Wrap(err, "Converting json to response protobuf message")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rspo.GetMetadata().GetResourceVersion()
	}
	return rspo, nil
}

func (c *crudAPIRestClient) ListStream(ctx context.Context, opts ...server.CRUDCallOpt) (server.ListStreamRsp, error) {
	return nil, fmt.Errorf("Not implemented")
}

func (c *crudAPIRestClient) Delete(ctx context.Context, key string, opts ...server.CRUDCallOpt) error {
	dReq := NewObjectDeleteReq(key)

	// convert ves.io.examplesvc.objectone.crudapi to ves.io.examplesvc.objectone
	sl := strings.Split("ves.io.schema.service_policy_rule.crudapi", ".")
	t := strings.Join(sl[:len(sl)-1], ".")
	url := fmt.Sprintf("%s/%s/Object/%s", c.baseURL, t, dReq.ObjectUid)

	hReq, err := http.NewRequest(http.MethodDelete, url, nil)
	if err != nil {
		return errors.Wrap(err, "RestClient delete")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	client.AddHdrsToReq(cco.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return err
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return fmt.Errorf("Unsuccessful DELETE at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return errors.Wrap(err, "RestClient delete")
	}

	rspo := &ObjectDeleteRsp{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return errors.Wrap(err, "Converting json to response protobuf message")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}
	return nil
}

func NewCRUDAPIRestClient(baseURL string, cl http.Client) server.CRUDClient {
	crcl := &crudAPIRestClient{baseURL, cl}
	return crcl
}

// INPROC Client (satisfying APIClient interface)
type APIInprocClient struct {
	crudCl *crudAPIInprocClient
}

func (c *APIInprocClient) Create(ctx context.Context, req *ObjectCreateReq, opts ...grpc.CallOption) (*ObjectCreateRsp, error) {
	ah := c.crudCl.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return nil, fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	return oah.Create(ctx, req)
}

func (c *APIInprocClient) Replace(ctx context.Context, req *ObjectReplaceReq, opts ...grpc.CallOption) (*ObjectReplaceRsp, error) {
	ah := c.crudCl.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return nil, fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	return oah.Replace(ctx, req)
}

func (c *APIInprocClient) Get(ctx context.Context, req *ObjectGetReq, opts ...grpc.CallOption) (*ObjectGetRsp, error) {
	ah := c.crudCl.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return nil, fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	return oah.Get(ctx, req)
}

func (c *APIInprocClient) List(ctx context.Context, req *ObjectListReq, opts ...grpc.CallOption) (*ObjectListRsp, error) {
	ah := c.crudCl.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return nil, fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	return oah.List(ctx, req)
}

func (c *APIInprocClient) ListStream(ctx context.Context, req *ObjectListReq, opts ...grpc.CallOption) (API_ListStreamClient, error) {
	return nil, fmt.Errorf("ListStream Not implemented")
}

func (c *APIInprocClient) Delete(ctx context.Context, req *ObjectDeleteReq, opts ...grpc.CallOption) (*ObjectDeleteRsp, error) {
	ah := c.crudCl.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return nil, fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	return oah.Delete(ctx, req)
}

func NewAPIInprocClient(svc svcfw.Service) APIClient {
	crudCl := newCRUDAPIInprocClient(svc)
	return &APIInprocClient{crudCl}
}

// INPROC CRUD Client (satisfying server.CRUDClient interface)
type crudAPIInprocClient struct {
	svc svcfw.Service
}

func (c *crudAPIInprocClient) Create(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) (db.Entry, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return nil, fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req, err := NewObjectCreateReq(e)
	if err != nil {
		return nil, errors.Wrap(err, "Creating new create request")
	}

	rsp, err := oah.Create(ctx, req)
	if rsp != nil {
		if cco.OutCallResponse != nil {
			cco.OutCallResponse.ProtoMsg = rsp
		}
		o := object.NewDBObject(nil)
		rsp.ToObject(o)
		return o, err
	}
	return nil, err
}

func (c *crudAPIInprocClient) Replace(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) error {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	req, err := NewObjectReplaceReq(e)
	if err != nil {
		return errors.Wrap(err, "Creating new replace request")
	}
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	req.ResourceVersion = cco.ResourceVersion

	rsp, err := oah.Replace(ctx, req)
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err
}

func (c *crudAPIInprocClient) GetRaw(ctx context.Context, key string, opts ...server.CRUDCallOpt) (*ObjectGetRsp, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return nil, fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	req := NewObjectGetReq(key, opts...)
	rsp, err := oah.Get(ctx, req)
	if err != nil {
		return nil, err
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rsp.ResourceVersion
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func (c *crudAPIInprocClient) Get(ctx context.Context, key string, opts ...server.CRUDCallOpt) (db.Entry, error) {
	rsp, err := c.GetRaw(ctx, key, opts...)
	if rsp != nil {
		o := object.NewDBObject(nil)
		rsp.ToObject(o)
		return o, err
	}
	return nil, err
}

func (c *crudAPIInprocClient) GetDetail(ctx context.Context, key string, nef db.NewEntryFunc, opts ...server.CRUDCallOpt) (*server.GetResponse, error) {
	var merr *multierror.Error
	gRsp, err := c.GetRaw(ctx, key, opts...)
	respDetail := server.GetResponse{}
	if err != nil {
		merr = multierror.Append(merr, err)
	}
	if gRsp != nil {
		respDetail.Entry = object.NewDBObject(nil)
		gRsp.ToObject(respDetail.Entry)
		respDetail.BackRefs, err = gRsp.GetBackrefs(nef)
		if err != nil {
			merr = multierror.Append(merr, err)
		}
		return &respDetail, errors.ErrOrNil(merr)
	}

	return nil, errors.ErrOrNil(merr)
}

func (c *crudAPIInprocClient) ListIDs(ctx context.Context, opts ...server.CRUDCallOpt) ([]string, error) {
	idSet := []string{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return idSet, err
	}
	for _, li := range listRsp.GetItems() {
		idSet = append(idSet, li.GetObjectUid())
	}
	return idSet, err
}

func (c *crudAPIInprocClient) ListItems(ctx context.Context, opts ...server.CRUDCallOpt) ([]server.ListItem, error) {
	sliSet := []server.ListItem{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return sliSet, err
	}
	for _, li := range listRsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err
}

func (c *crudAPIInprocClient) List(ctx context.Context, opts ...server.CRUDCallOpt) (*ObjectListRsp, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return nil, fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req := NewObjectListReq()
	req.TenantFilter = cco.TenantFilter
	req.NamespaceFilter = cco.NamespaceFilter
	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		req.LabelFilter = cco.LabelFilter[0]
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}

	if cco.OutResourceVersion != nil {
		req.ResourceVersion = true
	}
	rsp, err := oah.List(ctx, req)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rsp.GetMetadata().GetResourceVersion()
	}
	return rsp, err
}

func (c *crudAPIInprocClient) ListStream(ctx context.Context, opts ...server.CRUDCallOpt) (server.ListStreamRsp, error) {
	return nil, fmt.Errorf("Not implemented")
}

func (c *crudAPIInprocClient) Delete(ctx context.Context, key string, opts ...server.CRUDCallOpt) error {
	ah := c.svc.GetAPIHandler("ves.io.schema.service_policy_rule.crudapi.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		return fmt.Errorf("No CRUD Server for ves.io.schema.service_policy_rule.crudapi")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req := NewObjectDeleteReq(key)
	rsp, err := oah.Delete(ctx, req)
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err
}

func newCRUDAPIInprocClient(svc svcfw.Service) *crudAPIInprocClient {
	crcl := &crudAPIInprocClient{svc: svc}
	return crcl
}

func NewCRUDAPIInprocClient(svc svcfw.Service) server.CRUDClient {
	return newCRUDAPIInprocClient(svc)
}

// SERVER side
type APISrv struct {
	oType   string
	tblName string
	sf      svcfw.Service

	opts *server.CrudServerOpts
	// derived from opts
	apiWrapper *server.DBAPIWrapper
}

func (s *APISrv) validateTransport(ctx context.Context) error {
	if s.sf.IsTransportNotSupported("ves.io.schema.service_policy_rule.crudapi.API", server.TransportFromContext(ctx)) {
		userMsg := fmt.Sprintf("ves.io.schema.service_policy_rule.crudapi.API not allowed in transport '%s'", server.TransportFromContext(ctx))
		err := svcfw.NewPermissionDeniedError(userMsg, fmt.Errorf(userMsg))
		return server.GRPCStatusFromError(err).Err()
	}
	return nil
}

func (s *APISrv) Create(ctx context.Context, req *ObjectCreateReq) (*ObjectCreateRsp, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy_rule.crudapi.API.Create"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				return nil, errors.Wrap(err, "Validating private create request")
			}
		}
	}
	obj := object.NewDBObject(nil)
	req.ToObject(obj)
	obj.SystemMetadata = &ves_io_schema.SystemObjectMetaType{}

	rsrcReq := &server.ResourceCreateRequest{Entry: obj}
	rsrcRsp, err := s.opts.RsrcHandler.CreateFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		return nil, server.GRPCStatusFromError(errors.Wrap(err, "Create")).Err()
	}
	rsp, err := NewObjectCreateRsp(rsrcRsp.Entry)
	if err != nil {
		return nil, status.Error(codes.ResourceExhausted, errors.Wrap(err, "Create with NewObjectCreateRsp").Error())
	}
	return rsp, nil
}

func (s *APISrv) Replace(ctx context.Context, req *ObjectReplaceReq) (*ObjectReplaceRsp, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if req.Spec == nil {
		return nil, fmt.Errorf("Nil spec in Replace Request")
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy_rule.crudapi.API.Replace"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				return nil, errors.Wrap(err, "Validating private create request")
			}
		}
	}
	rsrcReq := &server.ResourceReplaceRequest{RequestMsg: req}
	rsrcRsp, err := s.opts.RsrcHandler.ReplaceFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		return nil, server.GRPCStatusFromError(errors.Wrap(err, "Replace")).Err()
	}
	rsp, err := NewObjectReplaceRsp(rsrcRsp.Entry)
	if err != nil {
		return nil, status.Error(codes.ResourceExhausted, errors.Wrap(err, "Replace with NewObjectReplaceRsp").Error())
	}
	return rsp, nil

}

func (s *APISrv) Get(ctx context.Context, req *ObjectGetReq) (*ObjectGetRsp, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy_rule.crudapi.API.Get"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				return nil, errors.Wrap(err, "Validating private create request")
			}
		}
	}
	key := req.ToUid()
	rsrcReq := &server.ResourceGetRequest{IsPublic: false, UID: key, AllBackRefs: req.AllBackrefs, BackRefTypes: req.BackrefTypes}
	rsrcReq.OmitReferredID = !req.IncludeReferredId
	rsrcRsp, err := s.opts.RsrcHandler.GetFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		return nil, server.GRPCStatusFromError(errors.Wrap(err, "Get")).Err()
	}
	rsp, err := NewObjectGetRsp(req, rsrcRsp)
	if err != nil {
		return nil, status.Error(codes.ResourceExhausted, errors.Wrap(err, "Get with NewObjectGetRsp").Error())
	}
	return rsp, nil
}

func (s *APISrv) List(ctx context.Context, req *ObjectListReq) (*ObjectListRsp, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy_rule.crudapi.API.List"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				return nil, errors.Wrap(err, "Validating private create request")
			}
		}
	}
	var merr *multierror.Error
	rsrcReq := &server.ResourceListRequest{
		TenantFilter:       req.TenantFilter,
		NamespaceFilter:    req.NamespaceFilter,
		LabelFilter:        req.LabelFilter,
		RspStreamed:        false,
		GetResourceVersion: req.ResourceVersion,
		OmitReferredID:     !req.IncludeReferredId,
	}
	rsrcRsp, err := s.opts.RsrcHandler.ListFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		merr = multierror.Append(merr, errors.Wrap(err, "List"))
	}
	rsp, err := NewObjectListRsp(req, rsrcRsp.Items)
	if err != nil {
		merr = multierror.Append(merr, err)
	}
	rsp.Metadata.ResourceVersion = rsrcRsp.ResourceVersion
	return rsp, errors.ErrOrNil(merr)
}

func (s *APISrv) ListStream(req *ObjectListReq, stream API_ListStreamServer) error {
	var merr *multierror.Error
	rsrcReq := &server.ResourceListRequest{
		TenantFilter:    req.TenantFilter,
		NamespaceFilter: req.NamespaceFilter,
		LabelFilter:     req.LabelFilter,
		RspStreamed:     true,
	}
	rsrcRsp, err := s.opts.RsrcHandler.ListFn(stream.Context(), rsrcReq, s.apiWrapper)
	if err != nil {
		merr = multierror.Append(merr, errors.Wrap(err, "ListStream"))
	}
	streamSvr := &crudAPIListStreamServer{stream}
	for item := range rsrcRsp.ItemsCh {
		if err := streamSvr.SendResource(req, item); err != nil {
			merr = multierror.Append(merr, errors.Wrap(err, "Stream-Send"))
			continue
		}
	}
	return errors.ErrOrNil(merr)
}

func (s *APISrv) Delete(ctx context.Context, req *ObjectDeleteReq) (*ObjectDeleteRsp, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.service_policy_rule.crudapi.API.Delete"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				return nil, errors.Wrap(err, "Validating private create request")
			}
		}
	}
	key := req.ToUid()
	rsrcReq := &server.ResourceDeleteRequest{Key: key}
	_, err := s.opts.RsrcHandler.DeleteFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		return nil, server.GRPCStatusFromError(errors.Wrap(err, "Delete")).Err()
	}
	return &ObjectDeleteRsp{}, nil
}

// Assert that APISrv implements both the generated gRPC APIServer interface and the
// stdlib CRUDServer interface
var (
	_ APIServer = &APISrv{}
)

func NewCRUDAPIServer(oType string, tblName string, sf svcfw.Service, opts ...server.CRUDServerOpt) (server.APIHandler, string) {
	// convert ves.io.examplesvc.objectone.Object to
	//         ves.io.examplesvc.objectone.crudapi.API
	sl := strings.Split(oType, ".")
	csOpts := server.NewCRUDServerOpts()
	for _, o := range opts {
		o(csOpts)
	}
	wrapper := server.NewDBAPIWrapper(csOpts.APIWrapperOpts...)
	s := &APISrv{
		oType:      oType,
		tblName:    tblName,
		sf:         sf,
		opts:       csOpts,
		apiWrapper: wrapper,
	}
	return s, fmt.Sprintf("%s.crudapi.API", strings.Join(sl[:len(sl)-1], "."))
}

// implements both stdlib.server.ListStreamServer and API_ListStreamServer
type crudAPIListStreamServer struct {
	stream API_ListStreamServer
}

func (lc *crudAPIListStreamServer) Context() context.Context {
	return lc.stream.Context()
}

func (lc *crudAPIListStreamServer) SendResource(r *ObjectListReq, item *server.ResourceListResponseItem) error {
	lRsp, err := NewObjectListRsp(r, []*server.ResourceListResponseItem{item})
	if err != nil {
		return errors.Wrap(err, "SendResource with NewObjectListRsp")
	}
	if err := lc.Send(lRsp); err != nil {
		return errors.Wrap(err, "ListStreamServer.SendResource()")
	}
	return nil
}

func (lc *crudAPIListStreamServer) Send(o *ObjectListRsp) error {
	if err := lc.stream.Send(o); err != nil {
		return errors.Wrap(err, "ListStreamServer.Send()")
	}
	return nil
}

// Implement GetReq interface
func (r *ObjectGetReq) ToUid() string {
	return r.ObjectUid
}

func (r *ObjectGetReq) GetBackrefParam() (bool, []string) {
	return r.AllBackrefs, r.BackrefTypes
}

// Implement DeleteReq interface
func (r *ObjectDeleteReq) ToUid() string {
	return r.ObjectUid
}

func (r *ObjectCreateRsp) Key() string {
	return r.ObjectUid
}

func (r *ObjectGetRsp) GetBackrefs(ef db.NewEntryFunc) ([]db.Entry, error) {
	brEnts := []db.Entry{}
	bRefs := r.GetEntBackrefs()
	for _, br := range bRefs {
		// convert schema.ves.io/ves.io.examplesvc.objectone.Object to ves.io.examplesvc.objectone.Object
		sl := strings.Split(br.TypeUrl, "/")
		ot := sl[len(sl)-1]
		ent, err := ef(ot, db.OpWithSerializedBytes(br.Value))
		if err != nil {
			return nil, errors.Wrap(err, "NewEntry")
		}
		brEnts = append(brEnts, ent)
	}

	return brEnts, nil
}

// Implement server.ListItem interface on ObjectListRspItem
func (l *ObjectListRspItem) GetObjUid() string {
	return l.ObjectUid
}

// Implement server.SROListItem interface on ObjectListRspItem
func (l *ObjectListRspItem) GetObjTenant() string {
	return l.Tenant
}

func (l *ObjectListRspItem) GetObjNamespace() string {
	return l.Namespace
}

func (l *ObjectListRspItem) GetObjName() string {
	return l.Name
}

func (l *ObjectListRspItem) GetObjLabels() map[string]string {
	return l.Labels
}

// New<oper>Rsp, New<oper>RspFromJSON
func NewObjectCreateRsp(e db.Entry) (*ObjectCreateRsp, error) {
	rspo := &ObjectCreateRsp{}
	switch e.(type) {
	case nil:
		return rspo, nil
	}
	o, ok := e.(*object.DBObject)
	if !ok {
		return nil, fmt.Errorf("Entry not of type *object.DBObject in NewObjectCreateRsp")
	}
	key, err := e.Key()
	if err != nil {
		return nil, errors.Wrap(err, "CreateRsp getting Key()")
	}
	rspo.ObjectUid = key
	rspo.FromObject(o)
	return rspo, nil
}

func NewObjectReplaceRsp(e db.Entry) (*ObjectReplaceRsp, error) {
	rspo := &ObjectReplaceRsp{}
	switch e.(type) {
	case nil:
		return rspo, nil
	}
	o, ok := e.(*object.DBObject)
	if !ok {
		return nil, fmt.Errorf("Entry not of type *object.DBObject in NewObjectReplaceRsp")
	}
	rspo.FromObject(o)
	return rspo, nil
}

func NewObjectGetRsp(r *ObjectGetReq, rsrcRsp *server.ResourceGetResponse) (*ObjectGetRsp, error) {
	rspo := &ObjectGetRsp{}
	e := rsrcRsp.Entry
	brEntries := rsrcRsp.BackRefs
	if e == nil {
		return rspo, nil
	}
	o, ok := e.(*object.DBObject)
	if !ok {
		return nil, fmt.Errorf("entry not of type *object.DBObject in NewObjectGetRsp")
	}
	rspo.ResourceVersion = rsrcRsp.ResourceVersion
	rspo.FromObject(o)
	// Backref
	getBackrefsFunc := func() ([]*google_protobuf.Any, error) {
		var merr *multierror.Error
		var entBackrefs []*google_protobuf.Any
		for _, brEnt := range brEntries {
			brSer, err := brEnt.MarshalBytes()
			if err != nil {
				merr = multierror.Append(merr, err)
				continue
			}
			entBackrefs = append(entBackrefs, &google_protobuf.Any{TypeUrl: "schema.ves.io/" + brEnt.Type(), Value: brSer})
		}
		return entBackrefs, errors.ErrOrNil(merr)
	}
	entBackrefs, err := getBackrefsFunc()
	if err != nil {
		return nil, err
	}
	rspo.EntBackrefs = entBackrefs
	d, err := o.GetDB()
	if err != nil {
		return nil, errors.Wrap(err, "GetRsp")
	}
	statusObjs, err := object.FindObjectStatus(context.Background(), d, o.GetObjUid())
	if err != nil {
		return nil, errors.Wrap(err, "GetRsp")
	}
	rspo.Status = statusObjs
	return rspo, nil
}

func NewObjectListRsp(req *ObjectListReq, rsrcRspItems []*server.ResourceListResponseItem) (*ObjectListRsp, error) {
	if req == nil {
		return nil, fmt.Errorf("Nil ObjectListReq")
	}
	var errs error
	o := &ObjectListRsp{}
	o.Metadata = &ves_io_schema.ListMetaType{}
	o.Uids = []string{}
	o.Items = []*ObjectListRspItem{}
	for _, rsrcItem := range rsrcRspItems {
		if rsrcItem == nil {
			errs = multierror.Append(errs, fmt.Errorf("ResourceListResponseItem is nil"))
			continue
		}
		e := rsrcItem.Entry
		dbObj, ok := e.(*object.DBObject)
		if !ok {
			errs = multierror.Append(errs, fmt.Errorf("Expected %T, got %T: %v", &object.DBObject{}, e, e))
			continue
		}
		key, err := dbObj.Key()
		if err != nil {
			errs = multierror.Append(errs, errors.WithMessagef(err, "Key() %v FAILED", dbObj))
			continue
		}

		tenant := dbObj.GetSystemMetadata().GetTenant()
		namespace := dbObj.GetMetadata().GetNamespace()
		name := dbObj.GetMetadata().GetName()
		labels := dbObj.GetMetadata().GetLabels()

		// TODO: DEPRECATE setting to o.Uids
		o.Uids = append(o.Uids, key)

		item := &ObjectListRspItem{
			ObjectUid: key,
			Tenant:    tenant,
			Namespace: namespace,
			Name:      name,
			Labels:    labels,
		}
		if len(req.ReportFields) > 0 {
			item.FromObject(e)
		}
		o.Items = append(o.Items, item)
	}
	return o, errs
}

func NewObjectDeleteRsp(ec ErrorCode) (*ObjectDeleteRsp, error) {
	return &ObjectDeleteRsp{Err: ec}, nil
}

func RegisterGwAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterAPIHandlerClient(ctx, mux, NewAPIInprocClient(s))
}

var APISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "ves.io/schema/service_policy_rule/crudapi/api.proto",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": null,
    "paths": {
        "/ves.io.schema.service_policy_rule/Object/{object_uid}": {
            "get": {
                "operationId": "ves.io.schema.service_policy_rule.crudapi.API.Get",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/crudapiObjectGetRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "object_uid",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "all_backrefs",
                        "in": "query",
                        "required": false,
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "backref_types",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "name": "include_referred_id",
                        "description": "in case of ref-by-name whether to report referred's uid.",
                        "in": "query",
                        "required": false,
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-service_policy_rule-crudapi-API-Get"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy_rule.crudapi.API.Get"
            },
            "delete": {
                "operationId": "ves.io.schema.service_policy_rule.crudapi.API.Delete",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/crudapiObjectDeleteRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "object_uid",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-service_policy_rule-crudapi-API-Delete"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy_rule.crudapi.API.Delete"
            },
            "put": {
                "operationId": "ves.io.schema.service_policy_rule.crudapi.API.Replace",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/crudapiObjectReplaceRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "object_uid",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/crudapiObjectReplaceReq"
                        }
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-service_policy_rule-crudapi-API-Replace"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy_rule.crudapi.API.Replace"
            },
            "x-displayname": "",
            "x-ves-object-kind": "service_policy_rule",
            "x-ves-object-type": "ves.io.schema.service_policy_rule.Object",
            "x-ves-proto-service": "ves.io.schema.service_policy_rule.crudapi.API",
            "x-ves-proto-service-type": "AUTO_CRUD"
        },
        "/ves.io.schema.service_policy_rule/Objects": {
            "get": {
                "operationId": "ves.io.schema.service_policy_rule.crudapi.API.List",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/crudapiObjectListRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "tenant_filter",
                        "description": "Filters executed on server-side - all types of filters ANDed\nTenants to scope the listing of objects - if empty all tenants considered.",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "name": "namespace_filter",
                        "description": "Namespaces to scope the listing of objects - if empty all namespaces considered.",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "name": "label_filter",
                        "description": "k8s style label selector expression.",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "report_fields",
                        "description": "TODO: currently even if one specified implementation will return all fields.",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "name": "resource_version",
                        "description": "Get the resource_version associated with the list.",
                        "in": "query",
                        "required": false,
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "include_referred_id",
                        "description": "in case of ref-by-name whether to report referred's uid.",
                        "in": "query",
                        "required": false,
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-service_policy_rule-crudapi-API-List"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy_rule.crudapi.API.List"
            },
            "post": {
                "operationId": "ves.io.schema.service_policy_rule.crudapi.API.Create",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/crudapiObjectCreateRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/crudapiObjectCreateReq"
                        }
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-service_policy_rule-crudapi-API-Create"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy_rule.crudapi.API.Create"
            },
            "x-displayname": "",
            "x-ves-object-kind": "service_policy_rule",
            "x-ves-object-type": "ves.io.schema.service_policy_rule.Object",
            "x-ves-proto-service": "ves.io.schema.service_policy_rule.crudapi.API",
            "x-ves-proto-service-type": "AUTO_CRUD"
        },
        "/ves.io.schema.service_policy_rule/Objects/stream": {
            "get": {
                "operationId": "ves.io.schema.service_policy_rule.crudapi.API.ListStream",
                "responses": {
                    "200": {
                        "description": "(streaming responses)",
                        "schema": {
                            "$ref": "#/definitions/crudapiObjectListRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "tenant_filter",
                        "description": "Filters executed on server-side - all types of filters ANDed\nTenants to scope the listing of objects - if empty all tenants considered.",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "name": "namespace_filter",
                        "description": "Namespaces to scope the listing of objects - if empty all namespaces considered.",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "name": "label_filter",
                        "description": "k8s style label selector expression.",
                        "in": "query",
                        "required": false,
                        "type": "string"
                    },
                    {
                        "name": "report_fields",
                        "description": "TODO: currently even if one specified implementation will return all fields.",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "name": "resource_version",
                        "description": "Get the resource_version associated with the list.",
                        "in": "query",
                        "required": false,
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "include_referred_id",
                        "description": "in case of ref-by-name whether to report referred's uid.",
                        "in": "query",
                        "required": false,
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-service_policy_rule-crudapi-API-ListStream"
                },
                "x-ves-proto-rpc": "ves.io.schema.service_policy_rule.crudapi.API.ListStream"
            },
            "x-displayname": "",
            "x-ves-object-kind": "service_policy_rule",
            "x-ves-object-type": "ves.io.schema.service_policy_rule.Object",
            "x-ves-proto-service": "ves.io.schema.service_policy_rule.crudapi.API",
            "x-ves-proto-service-type": "AUTO_CRUD"
        }
    },
    "definitions": {
        "crudapiErrorCode": {
            "type": "string",
            "enum": [
                "EOK",
                "ENOTFOUND",
                "EEXISTS",
                "EUNKNOWN"
            ],
            "default": "EOK",
            "x-displayname": "",
            "x-ves-proto-enum": "ves.io.schema.service_policy_rule.crudapi.ErrorCode"
        },
        "crudapiObjectCreateReq": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.crudapi.ObjectCreateReq",
            "properties": {
                "metadata": {
                    "$ref": "#/definitions/schemaObjectMetaType"
                },
                "spec": {
                    "$ref": "#/definitions/service_policy_ruleSpecType"
                },
                "system_metadata": {
                    "$ref": "#/definitions/schemaSystemObjectMetaType"
                }
            }
        },
        "crudapiObjectCreateRsp": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.crudapi.ObjectCreateRsp",
            "properties": {
                "err": {
                    "$ref": "#/definitions/crudapiErrorCode"
                },
                "metadata": {
                    "$ref": "#/definitions/schemaObjectMetaType"
                },
                "object_uid": {
                    "type": "string"
                },
                "spec": {
                    "$ref": "#/definitions/service_policy_ruleSpecType"
                },
                "system_metadata": {
                    "$ref": "#/definitions/schemaSystemObjectMetaType"
                }
            }
        },
        "crudapiObjectDeleteRsp": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.crudapi.ObjectDeleteRsp",
            "properties": {
                "err": {
                    "$ref": "#/definitions/crudapiErrorCode"
                }
            }
        },
        "crudapiObjectGetRsp": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.crudapi.ObjectGetRsp",
            "properties": {
                "ent_backrefs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/protobufAny"
                    }
                },
                "err": {
                    "$ref": "#/definitions/crudapiErrorCode"
                },
                "metadata": {
                    "$ref": "#/definitions/schemaObjectMetaType"
                },
                "resource_version": {
                    "type": "string"
                },
                "spec": {
                    "$ref": "#/definitions/service_policy_ruleSpecType"
                },
                "status": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/service_policy_ruleStatusObject"
                    }
                },
                "system_metadata": {
                    "$ref": "#/definitions/schemaSystemObjectMetaType"
                }
            }
        },
        "crudapiObjectListRsp": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.crudapi.ObjectListRsp",
            "properties": {
                "err": {
                    "$ref": "#/definitions/crudapiErrorCode"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/crudapiObjectListRspItem"
                    }
                },
                "metadata": {
                    "$ref": "#/definitions/schemaListMetaType"
                },
                "uids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "crudapiObjectListRspItem": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.crudapi.ObjectListRspItem",
            "properties": {
                "labels": {
                    "type": "object"
                },
                "metadata": {
                    "title": "If ObjectListReq has any specified report_fields, it will appear in below fields",
                    "$ref": "#/definitions/schemaObjectMetaType"
                },
                "name": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                },
                "object_uid": {
                    "type": "string"
                },
                "spec": {
                    "$ref": "#/definitions/service_policy_ruleSpecType"
                },
                "status": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/service_policy_ruleStatusObject"
                    }
                },
                "system_metadata": {
                    "$ref": "#/definitions/schemaSystemObjectMetaType"
                },
                "tenant": {
                    "type": "string"
                }
            }
        },
        "crudapiObjectReplaceReq": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.crudapi.ObjectReplaceReq",
            "properties": {
                "metadata": {
                    "$ref": "#/definitions/schemaObjectMetaType"
                },
                "object_uid": {
                    "type": "string"
                },
                "resource_version": {
                    "type": "string"
                },
                "spec": {
                    "$ref": "#/definitions/service_policy_ruleSpecType"
                }
            }
        },
        "crudapiObjectReplaceRsp": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.crudapi.ObjectReplaceRsp",
            "properties": {
                "err": {
                    "$ref": "#/definitions/crudapiErrorCode"
                },
                "metadata": {
                    "$ref": "#/definitions/schemaObjectMetaType"
                },
                "spec": {
                    "$ref": "#/definitions/service_policy_ruleSpecType"
                },
                "system_metadata": {
                    "$ref": "#/definitions/schemaSystemObjectMetaType"
                }
            }
        },
        "malicious_user_mitigationMaliciousUserMitigationAction": {
            "type": "object",
            "description": "Supported actions that can be taken to mitigate malicious activity from a user",
            "title": "MaliciousUserMitigationAction",
            "x-displayname": "Malicious User Mitigation Action",
            "x-ves-oneof-field-mitigation_action": "[\"alert_only\",\"block_temporarily\",\"captcha_challenge\",\"javascript_challenge\",\"none\"]",
            "x-ves-proto-message": "ves.io.schema.malicious_user_mitigation.MaliciousUserMitigationAction",
            "properties": {
                "alert_only": {
                    "description": "Exclusive with [block_temporarily captcha_challenge javascript_challenge none]\nx-displayName: \"Alert Only\"\nGenerate alert while not taking any invasive actions",
                    "title": "Alert Only",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "block_temporarily": {
                    "description": "Exclusive with [alert_only captcha_challenge javascript_challenge none]\nx-displayName: \"Block Temporarily\"\nBlock user temporarily. The blocking duration is determined by user activity.\nSettings for temporary blocking are derived from the virtual host that the request is sent to\nIf temporary blocking is not configured for the virtual host, a software default configuration is used",
                    "title": "Block User Temporarily",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "captcha_challenge": {
                    "description": "Exclusive with [alert_only block_temporarily javascript_challenge none]\nx-displayName: \"Captcha Challenge\"\nSend a Captcha Challenge\nSettings for Captcha Challenge are derived from the virtual host that the request is sent to\nIf Captcha Challenge is not configured for the virtual host, a software default configuration is used",
                    "title": "Captcha Challenge",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "javascript_challenge": {
                    "description": "Exclusive with [alert_only block_temporarily captcha_challenge none]\nx-displayName: \"Javascript Challenge\"\nSend a Javascript Challenge. \nSettings for Javascript Challenge are derived from the virtual host that the request is sent to\nIf Javascript Challenge is not configured for the virtual host, a software default configuration is used",
                    "title": "Javascript Challenge",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "none": {
                    "description": "Exclusive with [alert_only block_temporarily captcha_challenge javascript_challenge]\nx-displayName: \"No Action\"\nNo mitigation actions",
                    "title": "None",
                    "$ref": "#/definitions/schemaEmpty"
                }
            }
        },
        "malicious_user_mitigationMaliciousUserMitigationRule": {
            "type": "object",
            "description": "Specifies the mitigation action that will be taken for users detected to be at the specified threat level",
            "title": "MaliciousUserMitigationRule",
            "x-displayname": "Malicious User Mitigation Rule",
            "x-ves-proto-message": "ves.io.schema.malicious_user_mitigation.MaliciousUserMitigationRule",
            "properties": {
                "mitigation_action": {
                    "description": " The action to be taken at the specified threat level\nRequired: YES",
                    "title": "mitigation action",
                    "$ref": "#/definitions/malicious_user_mitigationMaliciousUserMitigationAction",
                    "x-displayname": "Mitigation Action",
                    "x-ves-required": "true"
                },
                "threat_level": {
                    "description": " The threat level at which mitigation actions will be taken\nRequired: YES",
                    "title": "threat level",
                    "$ref": "#/definitions/malicious_user_mitigationMaliciousUserThreatLevel",
                    "x-displayname": "Threat Level",
                    "x-ves-required": "true"
                }
            }
        },
        "malicious_user_mitigationMaliciousUserMitigationType": {
            "type": "object",
            "description": "Malicious user mitigation type specifies the malicious user mitigation rules that define the actions to be taken for users mapped to different threat levels.\nA threat level is calculated for every user identified using config specified in user_identification by analyzing their activity and reputation.",
            "title": "MaliciousUserMitigationType",
            "x-displayname": "Malicious User Mitigation Type",
            "x-ves-proto-message": "ves.io.schema.malicious_user_mitigation.MaliciousUserMitigationType",
            "properties": {
                "rules": {
                    "type": "array",
                    "description": " Malicious user mitigation rules specify the actions to be taken for users mapped to different threat levels.\n A threat level is calculated for every user identified using config specified in user_identification by analyzing their activity and reputation.\nRequired: YES",
                    "title": "malicious user mitigation rules",
                    "items": {
                        "$ref": "#/definitions/malicious_user_mitigationMaliciousUserMitigationRule"
                    },
                    "x-displayname": "Malicious User Mitigation Rules",
                    "x-ves-required": "true"
                }
            }
        },
        "malicious_user_mitigationMaliciousUserThreatLevel": {
            "type": "object",
            "description": "Threat level estimated for each user based on the user's activity and reputation",
            "title": "MaliciousUserThreatLevel",
            "x-displayname": "Malicious User Threat Level",
            "x-ves-oneof-field-threat_level": "[\"high\",\"low\",\"medium\"]",
            "x-ves-proto-message": "ves.io.schema.malicious_user_mitigation.MaliciousUserThreatLevel",
            "properties": {
                "high": {
                    "description": "Exclusive with [low medium]\nx-displayName: \"Threat Level High\"\nUser estimated to be high threat",
                    "title": "High",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "low": {
                    "description": "Exclusive with [high medium]\nx-displayName: \"Threat Level Low\"\nUser estimated to be low threat",
                    "title": "Low",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "medium": {
                    "description": "Exclusive with [high low]\nx-displayName: \"Threat Level Medium\"\nUser estimated to be medium threat",
                    "title": "Medium",
                    "$ref": "#/definitions/schemaEmpty"
                }
            }
        },
        "policyArgMatcherType": {
            "type": "object",
            "description": "A argument matcher specifies the name of a single argument in the body and the criteria to match it.\nA argument matcher can check for one of the following:\n* Presence or absence of the argument\n* At least one of the values for the argument in the request satisfies the MatcherType item",
            "title": "ArgMatcherType",
            "x-displayname": "Argument Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\",\"presence\"]",
            "x-ves-proto-message": "ves.io.schema.policy.ArgMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item presence]\nx-displayName: \"Not Present\"\nCheck that the argument is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item presence]\nx-displayName: \"Present\"\nCheck that the argument is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert Match of the expression defined",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present presence]\nx-displayName: \"Match Values\"\nCriteria for matching the values for the Arg. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "name": {
                    "type": "string",
                    "description": " x-example: \"phones[_]\"\n x-example: \"cars.make.toyota.models[1]\"\n x-example: \"cars.make.honda.models[_]\"\n x-example: \"cars.make[_].models[_]\"\n A case-sensitive JSON path in the HTTP request body.\n\nExample: - \"name\"-\nRequired: YES",
                    "title": "name",
                    "x-displayname": "Argument Name",
                    "x-ves-example": "name",
                    "x-ves-required": "true"
                },
                "presence": {
                    "type": "boolean",
                    "description": "Exclusive with [check_not_present check_present item]\nx-displayName: \"Present Or Absent\"\nCheck if the arg is present or absent.",
                    "title": "presence",
                    "format": "boolean"
                }
            }
        },
        "policyAsnMatchList": {
            "type": "object",
            "description": "An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy.",
            "title": "Asn Match List",
            "x-displayname": "ASN Match List",
            "x-ves-proto-message": "ves.io.schema.policy.AsnMatchList",
            "properties": {
                "as_numbers": {
                    "type": "array",
                    "description": " An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy.\n\nExample: - \"[713, 7932, 847325, 4683, 15269, 1000001]\"-\nRequired: YES",
                    "title": "as numbers",
                    "items": {
                        "type": "integer",
                        "format": "int64"
                    },
                    "x-displayname": "AS Numbers",
                    "x-ves-example": "[713, 7932, 847325, 4683, 15269, 1000001]",
                    "x-ves-required": "true"
                }
            }
        },
        "policyAsnMatcherType": {
            "type": "object",
            "description": "Match any AS number contained in the list of bgp_asn_sets.",
            "title": "asn matcher type",
            "x-displayname": "ASN Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.AsnMatcherType",
            "properties": {
                "asn_sets": {
                    "type": "array",
                    "description": " A list of references to bgp_asn_set objects.\nRequired: YES",
                    "title": "asn_sets",
                    "items": {
                        "$ref": "#/definitions/schemaObjectRefType"
                    },
                    "x-displayname": "BGP ASN Sets",
                    "x-ves-required": "true"
                }
            }
        },
        "policyCookieMatcherType": {
            "type": "object",
            "description": "A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each\ncookie in the request.\nA cookie matcher can check for one of the following:\n* Presence or absence of the cookie\n* At least one of the values for the cookie in the request satisfies the MatcherType item",
            "title": "CookieMatcherType",
            "x-displayname": "Cookie Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\",\"presence\"]",
            "x-ves-proto-message": "ves.io.schema.policy.CookieMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item presence]\nx-displayName: \"Not Present\"\nCheck that the cookie is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item presence]\nx-displayName: \"Present\"\nCheck that the cookie is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert Match of the expression defined",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present presence]\nx-displayName: \"Match Values\"\nCriteria for matching the values for the cookie. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "name": {
                    "type": "string",
                    "description": " A case-sensitive cookie name.\n\nExample: - \"Session\"-\nRequired: YES",
                    "title": "name",
                    "x-displayname": "Cookie Name",
                    "x-ves-example": "Session",
                    "x-ves-required": "true"
                },
                "presence": {
                    "type": "boolean",
                    "description": "Exclusive with [check_not_present check_present item]\nx-displayName: \"Present Or Absent\"\nCheck if the cookie is present or absent.",
                    "title": "presence",
                    "format": "boolean"
                }
            }
        },
        "policyHttpMethodMatcherType": {
            "type": "object",
            "description": "A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list.\nThe result of the match based on the method list is inverted if invert_matcher is true.",
            "title": "HttpMethodMatcherType",
            "x-displayname": "HTTP Method Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.HttpMethodMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Method Matcher"
                },
                "methods": {
                    "type": "array",
                    "description": " List of methods values to match against.\n\nExample: - \"['GET', 'POST', 'DELETE']\"-",
                    "title": "methods",
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "Method List",
                    "x-ves-example": "['GET', 'POST', 'DELETE']"
                }
            }
        },
        "policyIpMatcherType": {
            "type": "object",
            "description": "Match any ip prefix contained in the list of ip_prefix_sets.\nThe result of the match is inverted if invert_matcher is true.",
            "title": "ip matcher type",
            "x-displayname": "IP Prefix Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.IpMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert IP Matcher"
                },
                "prefix_sets": {
                    "type": "array",
                    "description": " A list of references to ip_prefix_set objects.\nRequired: YES",
                    "title": "prefix_sets",
                    "items": {
                        "$ref": "#/definitions/schemaObjectRefType"
                    },
                    "x-displayname": "IP Prefix Sets",
                    "x-ves-required": "true"
                }
            }
        },
        "policyKnownTlsFingerprintClass": {
            "type": "string",
            "description": "Specifies known TLS fingerprint classes\n\n - TLS_FINGERPRINT_NONE: TLS_FINGERPRINT_NONE\n\nNo TLS fingerprint\n - ANY_MALICIOUS_FINGERPRINT: ANY_MALICIOUS_FINGERPRINT\n\nTLS fingerprints known to be associated with malicious clients\n - ADWARE: ADWARE\n\nTLS fingerprints known to be associated with adware\n - ADWIND: ADWIND\n\nTLS fingerprints known to be associated with adwind\n - DRIDEX: DRIDEX\n\nTLS fingerprints known to be associated with dridex\n - GOOTKIT: GOOTKIT\n\nTLS fingerprints known to be associated with gootkit\n - GOZI: GOZI\n\nTLS fingerprints known to be associated with gozi\n - JBIFROST: JBIFROST\n\nTLS fingerprints known to be associated with jbifrost\n - QUAKBOT: QUAKBOT\n\nTLS fingerprints known to be associated with quakbot\n - RANSOMWARE: RANSOMWARE\n\nTLS fingerprints known to be associated with ransomware\n - TROLDESH: TROLDESH\n\nTLS fingerprints known to be associated with troldesh\n - TOFSEE: TOFSEE\n\nTLS fingerprints known to be associated with tofsee\n - TORRENTLOCKER: TORRENTLOCKER\n\nTLS fingerprints known to be associated with torrentlocker\n - TRICKBOT: TRICKBOT\n\nTLS fingerprints known to be associated with trickbot",
            "title": "TLS known fingerprint class",
            "enum": [
                "TLS_FINGERPRINT_NONE",
                "ANY_MALICIOUS_FINGERPRINT",
                "ADWARE",
                "ADWIND",
                "DRIDEX",
                "GOOTKIT",
                "GOZI",
                "JBIFROST",
                "QUAKBOT",
                "RANSOMWARE",
                "TROLDESH",
                "TOFSEE",
                "TORRENTLOCKER",
                "TRICKBOT"
            ],
            "default": "TLS_FINGERPRINT_NONE",
            "x-displayname": "TLS known fingerprint class",
            "x-ves-proto-enum": "ves.io.schema.policy.KnownTlsFingerprintClass"
        },
        "policyL4DestMatcherType": {
            "type": "object",
            "description": "A L4 Destination matcher specifies a list of L4 Destinations as match criteria. The match is considered successful if the destination IP and port match any\nof the L4 Destinations.\nThe result of the match is inverted if invert_matcher is true.",
            "title": "l4 dest matcher type",
            "x-displayname": "L4 Destination Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.L4DestMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert L4 Destination Matcher"
                },
                "l4_dests": {
                    "type": "array",
                    "description": " A list of L4 destinations used as match criteria. The match is considered successful if the destination IP and path match any of the L4 destinations.\nRequired: YES",
                    "title": "prefixes",
                    "items": {
                        "$ref": "#/definitions/schemaL4DestType"
                    },
                    "x-displayname": "L4 Destinations",
                    "x-ves-required": "true"
                }
            }
        },
        "policyMatcherType": {
            "type": "object",
            "description": "A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of exact values and a list of regular expressions.",
            "title": "MatcherType",
            "x-displayname": "Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.MatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact values to match the input against.\n\nExample: - \"['new york', 'london', 'sydney', 'tokyo', 'cairo']\"-",
                    "title": "exact values",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['new york', 'london', 'sydney', 'tokyo', 'cairo']"
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input against.\n\nExample: - \"['^new .*$', 'san f.*', '.* del .*']\"-",
                    "title": "regex values",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^new .*$', 'san f.*', '.* del .*']"
                },
                "transformers": {
                    "type": "array",
                    "description": " An ordered list of transformers (starting from index 0) to be applied to the path before matching. \n\nExample: - \"[BASE64_DECODE, LOWER_CASE]-",
                    "title": "transformers",
                    "items": {
                        "$ref": "#/definitions/policyTransformer"
                    },
                    "x-displayname": "Transformers"
                }
            }
        },
        "policyPortMatcherType": {
            "type": "object",
            "description": "A port matcher specifies a list of port ranges as match criteria. The match is considered successful if the input port falls within any of the port ranges.\nThe result of the match is inverted if invert_matcher is true.",
            "title": "port matcher type",
            "x-displayname": "Port Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.PortMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Port Matcher"
                },
                "ports": {
                    "type": "array",
                    "description": " A list of strings, each of which is a single port value or a tuple of start and end port values separated by \"-\". The start and end values are considered\n to be part of the range.\n\nExample: - \"8000-8191\"-\nRequired: YES",
                    "title": "port ranges",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Port Ranges",
                    "x-ves-example": "8000-8191",
                    "x-ves-required": "true"
                }
            }
        },
        "policyPrefixMatchList": {
            "type": "object",
            "description": "List of IPv4 Prefix strings to match against.",
            "title": "Prefix Match List",
            "x-displayname": "IP Prefix Match List",
            "x-ves-proto-message": "ves.io.schema.policy.PrefixMatchList",
            "properties": {
                "invert_match": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Match Result"
                },
                "ip_prefixes": {
                    "type": "array",
                    "description": " List of IPv4 prefix strings.\n\nExample: - \"192.168.20.0/24\"-\nRequired: YES",
                    "title": "ip prefixes",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IP Prefix List",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-required": "true"
                }
            }
        },
        "policyRoleMatcherType": {
            "type": "object",
            "description": "A role matcher specifies a single value for matching an input list of roles. The match is considered successful if the specified value is present in the input\nlist.",
            "title": "RoleMatcherType",
            "x-displayname": "Role Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.RoleMatcherType",
            "properties": {
                "match": {
                    "type": "string",
                    "description": " x-example: \"ves-io-uam-role\"\n x-example: \"custom-role-security-czar'\"\n Value of the expected role.\n\nExample: - \"ves-io-monitor-role\"-\nRequired: YES",
                    "title": "match",
                    "x-displayname": "Role",
                    "x-ves-example": "ves-io-monitor-role",
                    "x-ves-required": "true"
                }
            }
        },
        "policyRuleAction": {
            "type": "string",
            "description": "The rule action determines the disposition of the input request API. If a policy matches a rule with an ALLOW action, the processing of the request proceeds\nforward. If it matches a rule with a DENY action, the processing of the request is terminated and an appropriate message/code returned to the originator. If\nit matches a rule with a NEXT_POLICY_SET action, evaluation of the current policy set terminates and evaluation of the next policy set in the chain begins.\n\n - DENY: DENY\n\nDeny the request.\n - ALLOW: ALLOW\n\nAllow the request to proceed.\n - NEXT_POLICY_SET: NEXT_POLICY_SET\n\nTerminate evaluation of the current policy set and begin evaluating the next policy set in the chain. Note that the evaluation of any remaining policies\nin the current policy set is skipped.\n - NEXT_POLICY: NEXT_POLICY\n\nTerminate evaluation of the current policy and begin evaluating the next policy in the policy set. Note that the evaluation of any remaining rules in the\ncurrent policy is skipped.",
            "title": "Rule Action",
            "enum": [
                "DENY",
                "ALLOW",
                "NEXT_POLICY_SET",
                "NEXT_POLICY"
            ],
            "default": "DENY",
            "x-displayname": "Rule Action",
            "x-ves-proto-enum": "ves.io.schema.policy.RuleAction"
        },
        "policyStringMatcherType": {
            "type": "object",
            "description": "A matcher specifies a list of values for matching an input string. The match is considered successful if the input value is present in the list. The result of\nthe match is inverted if invert_matcher is true.",
            "title": "StringMatcherType",
            "x-displayname": "String Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.StringMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert String Matcher"
                },
                "match": {
                    "type": "array",
                    "description": " A list of exact values to match the input against.\n\nExample: - \"['new york', 'london', 'sydney', 'tokyo', 'cairo']\"-\nRequired: YES",
                    "title": "match",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['new york', 'london', 'sydney', 'tokyo', 'cairo']",
                    "x-ves-required": "true"
                }
            }
        },
        "policyTlsFingerprintMatcherType": {
            "type": "object",
            "description": "A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known\nclasses of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input\nfingerprint is not one of the excluded values.",
            "title": "TlsFingerprintMatcherType",
            "x-displayname": "TLS Fingerprint Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.TlsFingerprintMatcherType",
            "properties": {
                "classes": {
                    "type": "array",
                    "description": " A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ADWARE', 'TRICKBOT']-",
                    "title": "classes",
                    "items": {
                        "$ref": "#/definitions/policyKnownTlsFingerprintClass"
                    },
                    "x-displayname": "TLS fingerprint classes"
                },
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']-",
                    "title": "exact values",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values"
                },
                "excluded_values": {
                    "type": "array",
                    "description": " A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one\n or more known TLS fingerprint classes in the enclosing matcher.\n\nExample: - \"['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']-",
                    "title": "excluded values",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Excluded Values"
                }
            }
        },
        "policyTransformer": {
            "type": "string",
            "description": "Transformers to be applied on the part of the request before matching.\n\n - TRANSFORMER_NONE: transformer none\n\nNo transformers enabled\n - LOWER_CASE: lower case\n\nConvert string to lower case\n - UPPER_CASE: upper case\n\nConvert string to upper case\n - BASE64_DECODE: base64 decode\n\nDecode string assuming base64 encoding\n - NORMALIZE_PATH: normalize path\n\nNormalize URL path so that /a/b/../c will be transformed to /a/c\n - REMOVE_WHITESPACE: remove whitespace\n\nRemove whitespaces\n - URL_DECODE: URL decode\n\nDecode string assuming URL encoding as per rfc1738\n - TRIM_LEFT: trim left\n\nRemove whitespace from the left side of the input string\n - TRIM_RIGHT: trim right\n\nRemove whitespace from the right side of the input string\n - TRIM: trim\n\nRemove whitespace from the both sides of the input string",
            "title": "Transformer",
            "enum": [
                "TRANSFORMER_NONE",
                "LOWER_CASE",
                "UPPER_CASE",
                "BASE64_DECODE",
                "NORMALIZE_PATH",
                "REMOVE_WHITESPACE",
                "URL_DECODE",
                "TRIM_LEFT",
                "TRIM_RIGHT",
                "TRIM"
            ],
            "default": "TRANSFORMER_NONE",
            "x-displayname": "Transformer",
            "x-ves-proto-enum": "ves.io.schema.policy.Transformer"
        },
        "policyURLItem": {
            "type": "object",
            "description": "A URL item specifies exact or regular expression match criteria for the domain and path.",
            "title": "url item",
            "x-displayname": "URL Item",
            "x-ves-displayorder": "1,4",
            "x-ves-oneof-field-domain_choice": "[\"domain_regex\",\"domain_value\"]",
            "x-ves-oneof-field-path_choice": "[\"path_prefix\",\"path_regex\",\"path_value\"]",
            "x-ves-proto-message": "ves.io.schema.policy.URLItem",
            "properties": {
                "domain_regex": {
                    "type": "string",
                    "description": "Exclusive with [domain_value]\nx-displayName: \"Domain Regex\"\nx-example: \"*.mybloggingwebsite.org\"\nA regular expression to match the domain against.",
                    "title": "domain regex"
                },
                "domain_value": {
                    "type": "string",
                    "description": "Exclusive with [domain_regex]\nx-displayName: \"Domain Value\"\nx-example: \"www.mybloggingwebsite.org\"\nAn exact value to match the domain against.",
                    "title": "domain value"
                },
                "path_prefix": {
                    "type": "string",
                    "description": "Exclusive with [path_regex path_value]\nx-displayName: \"Path Prefix\"\nx-example: \"/api/web/namespaces/project179/users/\"\nAn prefix value to match the path against.",
                    "title": "path prefix"
                },
                "path_regex": {
                    "type": "string",
                    "description": "Exclusive with [path_prefix path_value]\nx-displayName: \"Path Regex\"\nx-example: \"^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$\"\nA regular expression to match the path against.",
                    "title": "path regex"
                },
                "path_value": {
                    "type": "string",
                    "description": "Exclusive with [path_prefix path_regex]\nx-displayName: \"Path Value\"\nx-example: \"/api/web/namespaces/project179/users/user1\"\nAn exact value to match the path against.",
                    "title": "path value"
                }
            }
        },
        "policyURLMatcherType": {
            "type": "object",
            "description": "A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the input domain and path match any of the URL items.\nThe result of the match is inverted if invert_matcher is true.",
            "title": "url matcher type",
            "x-displayname": "URL Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.URLMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert URL Matcher"
                },
                "url_items": {
                    "type": "array",
                    "description": " A list of URL items used as match criteria. The match is considered successful if the domain and path match any of the URL items.\nRequired: YES",
                    "title": "url items",
                    "items": {
                        "$ref": "#/definitions/policyURLItem"
                    },
                    "x-displayname": "URL Items",
                    "x-ves-required": "true"
                }
            }
        },
        "policyWafAction": {
            "type": "object",
            "description": "Modify App Firewall behavior for a matching request. The modification could either be to entirely skip firewall processing or to customize the firewall rules\nto be applied as defined by App Firewall Rule Control settings.",
            "title": "App Firewall Action",
            "x-displayname": "App Firewall Action",
            "x-ves-oneof-field-action_type": "[\"none\",\"waf_inline_rule_control\",\"waf_rule_control\",\"waf_skip_processing\"]",
            "x-ves-proto-message": "ves.io.schema.policy.WafAction",
            "properties": {
                "none": {
                    "description": "Exclusive with [waf_inline_rule_control waf_rule_control waf_skip_processing]\nx-displayName: \"Do not modify App Firewall Processing\"\nPerform normal App Firewall processing for this request",
                    "title": "Normal App Firewall Processing",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "waf_inline_rule_control": {
                    "description": "Exclusive with [none waf_rule_control waf_skip_processing]\nx-displayName: \"App Firewall Rule Control with inline Rule IDs\"\nApp Firewall rule changes to be applied for this request",
                    "title": "App Firewall Rule Control with inline Rule IDs",
                    "$ref": "#/definitions/policyWafInlineRuleControl"
                },
                "waf_rule_control": {
                    "description": "Exclusive with [none waf_inline_rule_control waf_skip_processing]\nx-displayName: \"App Firewall Rule Control\"\nApp Firewall rule changes to be applied for this request",
                    "title": "App Firewall Rule Control",
                    "$ref": "#/definitions/policyWafRuleControl"
                },
                "waf_skip_processing": {
                    "description": "Exclusive with [none waf_inline_rule_control waf_rule_control]\nx-displayName: \"Skip App Firewall Processing\"\nSkip all App Firewall processing for this request",
                    "title": "Skip App Firewall Processing",
                    "$ref": "#/definitions/schemaEmpty"
                }
            }
        },
        "policyWafInlineRuleControl": {
            "type": "object",
            "description": "App Firewall rule changes to be applied for this request",
            "title": "App Firewall Rule Control with inline Rule IDs",
            "x-displayname": "App Firewall Rule Control with inline Rule IDs",
            "x-ves-proto-message": "ves.io.schema.policy.WafInlineRuleControl",
            "properties": {
                "exclude_rule_ids": {
                    "type": "array",
                    "description": " App Firewall Rule IDs to be excluded for this request",
                    "title": "Exclude Rule IDs",
                    "items": {
                        "$ref": "#/definitions/waf_rule_listWafRuleID"
                    },
                    "x-displayname": "Exclude App Firewall Rule IDs"
                }
            }
        },
        "policyWafRuleControl": {
            "type": "object",
            "description": "App Firewall rule changes to be applied for this request",
            "title": "App Firewall Rule Control",
            "x-displayname": "App Firewall Rule Control",
            "x-ves-proto-message": "ves.io.schema.policy.WafRuleControl",
            "properties": {
                "exclude_rule_ids": {
                    "type": "array",
                    "description": " App Firewall Rule List specifying the rule IDs to be excluded for this request",
                    "title": "Exclude Rule IDs",
                    "items": {
                        "$ref": "#/definitions/schemaObjectRefType"
                    },
                    "x-displayname": "Exclude App Firewall Rule List"
                }
            }
        },
        "protobufAny": {
            "type": "object",
            "description": "-Any- contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an -Any- value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field -@type- which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n-value- which holds the custom JSON in addition to the -@type-\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
            "properties": {
                "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n-path/google.protobuf.Duration-). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme -http-, -https-, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, -https- is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than -http-, -https- (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                }
            }
        },
        "schemaConditionType": {
            "type": "object",
            "description": "Conditions are used in the object status to describe the current state of the\nobject, e.g. Ready, Succeeded, etc.",
            "title": "ConditionType",
            "x-displayname": "Status Condition",
            "x-ves-proto-message": "ves.io.schema.ConditionType",
            "properties": {
                "hostname": {
                    "type": "string",
                    "description": " Hostname of the instance of the site that sent the status",
                    "title": "hostname",
                    "x-displayname": "Hostname"
                },
                "last_update_time": {
                    "type": "string",
                    "description": " Last time the condition was updated",
                    "title": "last_update_time",
                    "format": "date-time",
                    "x-displayname": "Last Updated"
                },
                "reason": {
                    "type": "string",
                    "description": " x-reason: \"Insufficient memory in data plane\"\n A human readable string explaining the reason for reaching this condition\n\nExample: - \"value\"-",
                    "title": "reason",
                    "x-displayname": "Reason",
                    "x-ves-example": "value"
                },
                "service_name": {
                    "type": "string",
                    "description": " Name of the service that sent the status",
                    "title": "service name",
                    "x-displayname": "Service Name"
                },
                "status": {
                    "type": "string",
                    "description": " Status of the condition\n \"Success\" Validtion has succeded. Requested operation was successful.\n \"Failed\"  Validation has failed. \n \"Incomplete\" Validation of configuration has failed due to missing configuration.\n \"Installed\" Validation has passed and configuration has been installed in data path or K8s\n \"Down\" Configuration is operationally down. e.g. down interface\n \"Disabled\" Configuration is administratively disabled i.e. ObjectMetaType.Disable = true.\n \"NotApplicable\" Configuration is not applicable e.g. tenant service_policy_set(s) in system namespace are not applicable on REs\n\nExample: - \"Failed\"-",
                    "title": "status",
                    "x-displayname": "Status",
                    "x-ves-example": "Failed"
                },
                "type": {
                    "type": "string",
                    "description": " Type of the condition\n \"Validation\" represents validation user given configuration object\n \"Operational\" represents operational status of a given configuration object\n\nExample: - \"Operational\"-",
                    "title": "type",
                    "x-displayname": "Type",
                    "x-ves-example": "Operational"
                }
            }
        },
        "schemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "schemaHttpMethod": {
            "type": "string",
            "description": "Specifies the HTTP method used to acess a resource.\n\nAny HTTP Method\nGET method\nHEAD method\nPOST method\nPUT method\nDELETE method\nCONNECT method\nOPTIONS method\nTRACE method\nPATCH method",
            "title": "HttpMethod",
            "enum": [
                "ANY",
                "GET",
                "HEAD",
                "POST",
                "PUT",
                "DELETE",
                "CONNECT",
                "OPTIONS",
                "TRACE",
                "PATCH"
            ],
            "default": "ANY",
            "x-displayname": "HTTP Method",
            "x-ves-proto-enum": "ves.io.schema.HttpMethod"
        },
        "schemaInitializerType": {
            "type": "object",
            "description": "Initializer is information about an initializer that has not yet completed.",
            "title": "InitializerType",
            "x-displayname": "Initializer",
            "x-ves-proto-message": "ves.io.schema.InitializerType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " name of the service that is responsible for initializing this object.",
                    "title": "name",
                    "x-displayname": "Name"
                }
            }
        },
        "schemaInitializersType": {
            "type": "object",
            "description": "Initializers tracks the progress of initialization of a configuration object",
            "title": "InitializersType",
            "x-displayname": "Initializers",
            "x-ves-proto-message": "ves.io.schema.InitializersType",
            "properties": {
                "pending": {
                    "type": "array",
                    "description": " Pending is a list of initializers that must execute in order before this object is initialized.\n When the last pending initializer is removed, and no failing result is set, the initializers\n struct will be set to nil and the object is considered as initialized and visible to all\n clients.",
                    "title": "pending",
                    "items": {
                        "$ref": "#/definitions/schemaInitializerType"
                    },
                    "x-displayname": "Pending"
                },
                "result": {
                    "description": " If result is set with the Failure field, the object will be persisted to storage and then deleted,\n ensuring that other clients can observe the deletion.",
                    "title": "result",
                    "$ref": "#/definitions/schemaStatusType",
                    "x-displayname": "Result"
                }
            }
        },
        "schemaL4DestType": {
            "type": "object",
            "description": "L4 Destination consisting of IPv4 Prefixes and TCP Port Range",
            "title": "L4 Dest Type",
            "x-displayname": "L4 Destination",
            "x-ves-proto-message": "ves.io.schema.L4DestType",
            "properties": {
                "port_ranges": {
                    "type": "string",
                    "description": " A string containing a comma separated list of port ranges.\n Each port range consists of a single port or two ports separated by \"-\".\n\nExample: - \"80,443,8080-8191,9080\"-",
                    "title": "port_ranges",
                    "x-displayname": "Port Ranges",
                    "x-ves-example": "80,443,8080-8191,9080"
                },
                "prefixes": {
                    "type": "array",
                    "description": " Destination IPv4 prefixes.\nRequired: YES",
                    "title": "prefixes",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Prefixes",
                    "x-ves-required": "true"
                }
            }
        },
        "schemaLabelMatcherType": {
            "type": "object",
            "description": "A label matcher specifies a list of label keys whose values need to match for\nsource/client and destination/server. Note that the actual label values are not\nspecified and do not matter. This allows an ability to scope grouping by the \nlabel key name.",
            "title": "LabelMatcherType",
            "x-displayname": "Label Matcher",
            "x-ves-proto-message": "ves.io.schema.LabelMatcherType",
            "properties": {
                "keys": {
                    "type": "array",
                    "description": " The list of label key names that have to match\n\nExample: - \"['environment', 'location', 'deployment']\"-",
                    "title": "keys",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Keys",
                    "x-ves-example": "['environment', 'location', 'deployment']"
                }
            }
        },
        "schemaLabelSelectorType": {
            "type": "object",
            "description": "This type can be used to establish a 'selector reference' from one object(called selector) to \na set of other objects(called selectees) based on the value of expresssions. \nA label selector is a label query over a set of resources. An empty label selector matches all objects. \nA null label selector matches no objects. Label selector is immutable.\nexpressions is a list of strings of label selection expression. \nEach string has \",\" seperated values which are \"AND\" and all strings are logically \"OR\".\nBNF for expression string\n\u003cselector-syntax\u003e         ::= \u003crequirement\u003e | \u003crequirement\u003e \",\" \u003cselector-syntax\u003e\n\u003crequirement\u003e             ::= [!] KEY [ \u003cset-based-restriction\u003e | \u003cexact-match-restriction\u003e ]\n\u003cset-based-restriction\u003e   ::= \"\" | \u003cinclusion-exclusion\u003e \u003cvalue-set\u003e\n\u003cinclusion-exclusion\u003e     ::= \u003cinclusion\u003e | \u003cexclusion\u003e\n\u003cexclusion\u003e               ::= \"notin\"\n\u003cinclusion\u003e               ::= \"in\"\n\u003cvalue-set\u003e               ::= \"(\" \u003cvalues\u003e \")\"\n\u003cvalues\u003e                  ::= VALUE | VALUE \",\" \u003cvalues\u003e\n\u003cexact-match-restriction\u003e ::= [\"=\"|\"==\"|\"!=\"] VALUE",
            "title": "LabelSelectorType",
            "x-displayname": "Label Selector",
            "x-ves-proto-message": "ves.io.schema.LabelSelectorType",
            "properties": {
                "expressions": {
                    "type": "array",
                    "description": " expressions contains the kubernetes style label expression for selections.\n\nExample: - \"region in (us-west1, us-west2),tier in (staging)\"-\nRequired: YES",
                    "title": "expressions",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Selector Expression",
                    "x-ves-example": "region in (us-west1, us-west2),tier in (staging)",
                    "x-ves-required": "true"
                }
            }
        },
        "schemaListMetaType": {
            "type": "object",
            "description": "ListMetaType is metadata that all lists must have.",
            "title": "ListMetaType",
            "x-displayname": "List Metadata",
            "x-ves-proto-message": "ves.io.schema.ListMetaType",
            "properties": {
                "resource_version": {
                    "type": "string",
                    "description": " An opaque value that represents the revision of the store at the time the list API is\n performed. It can be used in subsequent watch API to receive all changes after the list\n API, or in a replace API to make the replace conditional on the object still being at\n that revision\n\nExample: - \"181255\"-",
                    "title": "resource_version",
                    "x-displayname": "Resource Version",
                    "x-ves-example": "181255"
                }
            }
        },
        "schemaObjectMetaType": {
            "type": "object",
            "description": "ObjectMetaType is metadata(common attributes) of an object that all configuration objects will have.\nThe information in this type can be specified by user during create and replace APIs.",
            "title": "ObjectMetaType",
            "x-displayname": "Metadata",
            "x-ves-proto-message": "ves.io.schema.ObjectMetaType",
            "properties": {
                "annotations": {
                    "type": "object",
                    "description": " Annotations is an unstructured key value map stored with a resource that may be\n set by external tools to store and retrieve arbitrary metadata. They are not\n queryable and should be preserved when modifying objects.\n\nExample: - \"value\"-",
                    "title": "annotations",
                    "x-displayname": "Annotations",
                    "x-ves-example": "value"
                },
                "description": {
                    "type": "string",
                    "description": " Human readable description for the object\n\nExample: - \"Virtual Host for acmecorp website\"-",
                    "title": "description",
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website"
                },
                "disable": {
                    "type": "boolean",
                    "description": " A value of true will administratively disable the object\n\nExample: - \"true\"-",
                    "title": "disable",
                    "format": "boolean",
                    "x-displayname": "Disable",
                    "x-ves-example": "true"
                },
                "labels": {
                    "type": "object",
                    "description": " Map of string keys and values that can be used to organize and categorize\n (scope and select) objects as chosen by the user. Values specified here will be used\n by selector expression\n\nExample: - \"value\"-",
                    "title": "labels",
                    "x-displayname": "Labels",
                    "x-ves-example": "value"
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of configuration object. It has to be unique within the namespace.\n It can only be specified during create API and cannot be changed during replace API.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\nRequired: YES",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true"
                },
                "namespace": {
                    "type": "string",
                    "description": " This defines the workspace within which each the configuration object is to be created. \n Must be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"\n\nExample: - \"staging\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "staging"
                },
                "uid": {
                    "type": "string",
                    "description": " uid is the unique in time and space value for this object. Object create will fail if \n provided by the client and the value exists in the system. Typically generated by the\n server on successful creation of an object and is not allowed to change once populated.\n Shadowed by SystemObjectMeta's uid field.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "schemaObjectRefType": {
            "type": "object",
            "description": "This type establishes a 'direct reference' from one object(the referrer) to another(the referred). \nSuch a reference is in form of tenant/namespace/name for public API and Uid for private API\nThis type of reference is called direct because the relation is explicit and concrete (as opposed\nto selector reference which builds a group based on labels of selectee objects)",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.ObjectRefType",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then kind will hold the referred object's kind (e.g. \"route\")\n\nExample: - \"virtual_site\"-",
                    "title": "kind",
                    "x-displayname": "Kind",
                    "x-ves-example": "virtual_site"
                },
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contactus-route\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contactus-route"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then uid will hold the referred object's(e.g. route's) uid.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "schemaStatusMetaType": {
            "type": "object",
            "description": "StatusMetaType is metadata that all status must have.",
            "title": "StatusMetaType",
            "x-displayname": "Metadata",
            "x-ves-proto-message": "ves.io.schema.StatusMetaType",
            "properties": {
                "creation_timestamp": {
                    "type": "string",
                    "description": " creation_timestamp is when the status object was created. It is used to find/tie-break\n for latest status object from same origin",
                    "title": "creation_timestamp",
                    "format": "date-time",
                    "x-displayname": "Creation Timestamp"
                },
                "creator_class": {
                    "type": "string",
                    "description": " Class of creator which created this StatusObject. This will be service's DNS FQDN.\n This will be set by the system based on client certificate information.\n\nExample: - \"ver.re1.int.ves.io\"-",
                    "title": "creator_class",
                    "x-displayname": "Creator Class",
                    "x-ves-example": "ver.re1.int.ves.io"
                },
                "creator_id": {
                    "type": "string",
                    "description": " ID of creator which created this StatusObject. This will be a concrete identifier for service (e.g.\n identifying the environment also). This will be set by the system based on client certificate\n information\n\nExample: - \"ver-instance-1\"-",
                    "title": "creator_id",
                    "x-displayname": "Creator ID",
                    "x-ves-example": "ver-instance-1"
                },
                "publish": {
                    "description": " Decides wether this status object will be propagated to user.",
                    "title": "publish",
                    "$ref": "#/definitions/schemaStatusPublishType",
                    "x-displayname": "Publish"
                },
                "status_id": {
                    "type": "string",
                    "description": " status_id is a field used by the generator to distinguish (if necessary) between two status \n objects for the same config object from the same site and same service and potentially same\n daemon(creator-id)",
                    "title": "status_id",
                    "x-displayname": "Status ID"
                },
                "uid": {
                    "type": "string",
                    "description": " uid is the unique in time and space value for a StatusObject.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "schemaStatusPublishType": {
            "type": "string",
            "description": "StatusPublishType is all possible publish operations on a StatusObject\n\n - STATUS_DO_NOT_PUBLISH: Do not propagate this status to user. This could be because status is only informational\n - STATUS_PUBLISH: Propagate this status up to user as it might be actionable",
            "title": "StatusPublishType",
            "enum": [
                "STATUS_DO_NOT_PUBLISH",
                "STATUS_PUBLISH"
            ],
            "default": "STATUS_DO_NOT_PUBLISH",
            "x-displayname": "Publish",
            "x-ves-proto-enum": "ves.io.schema.StatusPublishType"
        },
        "schemaStatusType": {
            "type": "object",
            "description": "Status is a return value for calls that don't return other objects.",
            "title": "StatusType",
            "x-displayname": "Status",
            "x-ves-proto-message": "ves.io.schema.StatusType",
            "properties": {
                "code": {
                    "type": "integer",
                    "description": " Suggested HTTP return code for this status, 0 if not set.\n\nExample: - \"0\"-",
                    "title": "code",
                    "format": "int32",
                    "x-displayname": "Code",
                    "x-ves-example": "0"
                },
                "reason": {
                    "type": "string",
                    "description": " A human-readable description of why this operation is in the\n \"Failure\" status. If this value is empty there\n is no information available.\n\nExample: - \"value\"-",
                    "title": "reason",
                    "x-displayname": "Reason",
                    "x-ves-example": "value"
                },
                "status": {
                    "type": "string",
                    "description": " Status of the operation.\n One of: \"Success\" or \"Failure\".\n\nExample: - \"value\"-",
                    "title": "status",
                    "x-displayname": "Status",
                    "x-ves-example": "value"
                }
            }
        },
        "schemaSystemObjectMetaType": {
            "type": "object",
            "description": "SystemObjectMetaType is metadata generated or populated by the system for all persisted objects and\ncannot be updated directly by users.",
            "title": "SystemObjectMetaType",
            "x-displayname": "System Metadata",
            "x-ves-proto-message": "ves.io.schema.SystemObjectMetaType",
            "properties": {
                "creation_timestamp": {
                    "type": "string",
                    "description": " CreationTimestamp is a timestamp representing the server time when this object was\n created. It is not guaranteed to be set in happens-before order across separate operations.\n Clients may not set this value. It is represented in RFC3339 form and is in UTC.",
                    "title": "creation_timestamp",
                    "format": "date-time",
                    "x-displayname": "Creation Timestamp"
                },
                "creator_class": {
                    "type": "string",
                    "description": " A value identifying the class of the user or service which created this configuration object.\n\nExample: - \"value\"-",
                    "title": "creator_class",
                    "x-displayname": "Creator Class",
                    "x-ves-example": "value"
                },
                "creator_cookie": {
                    "type": "string",
                    "description": " This can used by the creator of the object for later audit for e.g. by storing the\n version identifying information of the object so at future it can be determined if\n version present at remote end is current or stale.\n\nExample: - \"value\"-",
                    "title": "creator_cookie",
                    "x-displayname": "Creator Cookie",
                    "x-ves-example": "value"
                },
                "creator_id": {
                    "type": "string",
                    "description": " A value identifying the exact user or service that created this configuration object\n\nExample: - \"value\"-",
                    "title": "creator_id",
                    "x-displayname": "Creator ID",
                    "x-ves-example": "value"
                },
                "deletion_timestamp": {
                    "type": "string",
                    "description": " DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This\n field is set by the server when a graceful deletion is requested by the user, and is not\n directly settable by a client. The resource is expected to be deleted (no longer visible\n from resource lists, and not reachable by name) after the time in this field, once the\n finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.\n Once the deletionTimestamp is set, this value may not be unset or be set further into the\n future, although it may be shortened or the resource may be deleted prior to this time.\n For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react\n by sending a graceful termination signal to the containers in the pod. After that 30 seconds,\n the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,\n remove the pod from the API. In the presence of network partitions, this object may still\n exist after this timestamp, until an administrator or automated process can determine the\n resource is fully terminated.\n If not set, graceful deletion of the object has not been requested.\n \n Populated by the system when a graceful deletion is requested.\n Read-only.",
                    "title": "deletion_timestamp",
                    "format": "date-time",
                    "x-displayname": "Deletion Timestamp"
                },
                "finalizers": {
                    "type": "array",
                    "description": " Must be empty before the object is deleted from the registry. Each entry\n is an identifier for the responsible component that will remove the entry\n from the list. If the deletionTimestamp of the object is non-nil, entries\n in this list can only be removed.\n\nExample: - \"value\"-",
                    "title": "finalizers",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Finalizers",
                    "x-ves-example": "value"
                },
                "initializers": {
                    "description": " An initializer is a controller which enforces some system invariant at object creation time.\n This field is a list of initializers that have not yet acted on this object. If nil or empty,\n this object has been completely initialized. Otherwise, the object is considered uninitialized\n and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to\n observe uninitialized objects.\n \n When an object is created, the system will populate this list with the current set of initializers.\n Only privileged users may set or modify this list. Once it is empty, it may not be modified further\n by any user.",
                    "title": "initializers",
                    "$ref": "#/definitions/schemaInitializersType",
                    "x-displayname": "Initializers"
                },
                "modification_timestamp": {
                    "type": "string",
                    "description": " ModificationTimestamp is a timestamp representing the server time when this object was\n last modified.",
                    "title": "modification_timestamp",
                    "format": "date-time",
                    "x-displayname": "Modification Timestamp"
                },
                "namespace": {
                    "type": "array",
                    "description": " The namespace this object belongs to. This is populated by the service based on the\n metadata.namespace field when an object is created.",
                    "title": "namespace",
                    "items": {
                        "$ref": "#/definitions/schemaObjectRefType"
                    },
                    "x-displayname": "Namespace Reference"
                },
                "object_index": {
                    "type": "integer",
                    "description": " Unique index for the object. Some objects need a unique integer index to be allocated\n for each object type. This field will be populated for all objects that need it and will\n be zero otherwise.\n\nExample: - \"0\"-",
                    "title": "object_index",
                    "format": "int64",
                    "x-displayname": "Object Index",
                    "x-ves-example": "0"
                },
                "owner_view": {
                    "description": " Reference to the view object that owns this object.\n If there is no view owner, this field will be nil.\n If not nil, this object can only be edited/deleted through the view",
                    "title": "owner_view",
                    "$ref": "#/definitions/schemaViewRefType",
                    "x-displayname": "Owner View"
                },
                "tenant": {
                    "type": "string",
                    "description": " Tenant to which this configuration object belongs to. The value for this is found from\n presented credentials.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "trace_info": {
                    "type": "string",
                    "description": " trace_info holds information(\u003ctrace-id\u003e:\u003cspan-id\u003e:\u003cparent-span-id\u003e) of the request doing\n the object modification. This can be used on the watch side to create subsequent spans.\n This information can be used to co-relate activities across services (modulo state compression)\n for a synchronous API.\n\nExample: - \"value\"-",
                    "title": "trace_info",
                    "x-displayname": "Trace Info",
                    "x-ves-example": "value"
                },
                "uid": {
                    "type": "string",
                    "description": " uid is the unique in time and space value for this object. It is generated by\n the server on successful creation of an object and is not allowed to change on Replace\n API. The value of is taken from uid field of ObjectMetaType, if provided.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "schemaViewRefType": {
            "type": "object",
            "description": "ViewRefType represents a reference to a view",
            "title": "ViewRefType",
            "x-displayname": "View Reference",
            "x-ves-proto-message": "ves.io.schema.ViewRefType",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": " Kind of the view object\n\nExample: - \"http_proxy\"-",
                    "title": "kind",
                    "x-displayname": "Kind",
                    "x-ves-example": "http_proxy"
                },
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contactus-route\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contactus-route"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "uid": {
                    "type": "string",
                    "description": " UID of the view object\n\nExample: - \"f3744323-1adf-4aaa-a5dc-0707c1d1bd82\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "f3744323-1adf-4aaa-a5dc-0707c1d1bd82"
                }
            }
        },
        "schemapolicyHeaderMatcherType": {
            "type": "object",
            "description": "A header matcher specifies the name of a single HTTP header and the criteria for the input request to match it. The input has a list of actual values for each\nheader name in the original HTTP request.\nA header matcher can check for one of the following:\n* Presence or absence of the header in the input\n* At least one of the values for the header in the input satisfies the MatcherType item",
            "title": "HeaderMatcherType",
            "x-displayname": "Header Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\",\"presence\"]",
            "x-ves-proto-message": "ves.io.schema.policy.HeaderMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item presence]\nx-displayName: \"Not Present\"\nCheck that the header is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item presence]\nx-displayName: \"Present\"\nCheck that the header is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Header Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present presence]\nx-displayName: \"Match Values\"\nCriteria for matching the values for the header. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "name": {
                    "type": "string",
                    "description": " A case-insensitive HTTP header name.\n\nExample: - \"Accept-Encoding\"-\nRequired: YES",
                    "title": "name",
                    "x-displayname": "Header Name",
                    "x-ves-example": "Accept-Encoding",
                    "x-ves-required": "true"
                },
                "presence": {
                    "type": "boolean",
                    "description": "Exclusive with [check_not_present check_present item]\nx-displayName: \"Present Or Absent\"\nCheck if the header is present or absent.",
                    "title": "presence",
                    "format": "boolean"
                }
            }
        },
        "schemapolicyPathMatcherType": {
            "type": "object",
            "description": "A path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.",
            "title": "PathMatcherType",
            "x-displayname": "Path Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.PathMatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact path values to match the input HTTP path against.\n\nExample: - \"['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']\"-",
                    "title": "exact values",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']"
                },
                "prefix_values": {
                    "type": "array",
                    "description": " A list of path prefix values to match the input HTTP path against.\n\nExample: - \"['/api/web/namespaces/project179/users/', '/api/config/namespaces/', '/api/data/namespaces/']\"-",
                    "title": "prefix values",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Prefix Values",
                    "x-ves-example": "['/api/web/namespaces/project179/users/', '/api/config/namespaces/', '/api/data/namespaces/']"
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input HTTP path against.\n\nExample: - \"['^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$', '/api/data/namespaces/proj404/virtual_hosts/([a-z]([-a-z0-9]*[a-z0-9])?)$']\"-",
                    "title": "regex values",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$', '/api/data/namespaces/proj404/virtual_hosts/([a-z]([-a-z0-9]*[a-z0-9])?)$']"
                },
                "transformers": {
                    "type": "array",
                    "description": " An ordered list of transformers (starting from index 0) to be applied to the path before matching. \n\nExample: - \"[BASE64_DECODE, LOWER_CASE]-",
                    "title": "transformers",
                    "items": {
                        "$ref": "#/definitions/policyTransformer"
                    },
                    "x-displayname": "Transformers"
                }
            }
        },
        "schemapolicyQueryParameterMatcherType": {
            "type": "object",
            "description": "A query parameter matcher specifies the name of a single query parameter and the criteria for the input request to match it. The input has a list of actual\nvalues for each query parameter name in the original HTTP request.\nA query parameter matcher can check for one of the following:\n* Presence or absence of the query parameter in the input\n* At least one of the values for the query parameter in the input satisfies the MatcherType item",
            "title": "QueryParameterMatcherType",
            "x-displayname": "Query Parameter Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\",\"presence\"]",
            "x-ves-proto-message": "ves.io.schema.policy.QueryParameterMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item presence]\nx-displayName: \"Not Present\"\nCheck that the query parameter is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item presence]\nx-displayName: \"Present\"\nCheck that the query parameter is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Query Parameter Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present presence]\nx-displayName: \"Match Values\"\nCriteria for matching the values for the given query parameter. The match is successful if any of the values for the query parameter satisfies the\ncriteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "key": {
                    "type": "string",
                    "description": " A case-sensitive HTTP query parameter name.\n\nExample: - \"sourceid\"-\nRequired: YES",
                    "title": "key",
                    "x-displayname": "Query Parameter Name",
                    "x-ves-example": "sourceid",
                    "x-ves-required": "true"
                },
                "presence": {
                    "type": "boolean",
                    "description": "Exclusive with [check_not_present check_present item]\nx-displayName: \"Present Or Absent\"\nCheck if the query parameter is present or absent.",
                    "title": "presence",
                    "format": "boolean"
                }
            }
        },
        "schemaservice_policy_ruleGlobalSpecType": {
            "type": "object",
            "description": "Shape of service_policy_rule in the storage backend.",
            "title": "GlobalSpecType",
            "x-displayname": "Specification",
            "x-ves-oneof-field-asn_choice": "[\"any_asn\",\"asn_list\",\"asn_matcher\"]",
            "x-ves-oneof-field-client_choice": "[\"any_client\",\"client_name\",\"client_name_matcher\",\"client_selector\"]",
            "x-ves-oneof-field-dst_asn_choice": "[\"any_dst_asn\",\"dst_asn_list\",\"dst_asn_matcher\"]",
            "x-ves-oneof-field-dst_ip_choice": "[\"any_dst_ip\",\"dst_ip_matcher\",\"dst_ip_prefix_list\"]",
            "x-ves-oneof-field-ip_choice": "[\"any_ip\",\"ip_matcher\",\"ip_prefix_list\"]",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.GlobalSpecType",
            "properties": {
                "action": {
                    "description": " Action to be enforced if the input request matches the rule.\nRequired: YES",
                    "title": "action",
                    "$ref": "#/definitions/policyRuleAction",
                    "x-displayname": "Action",
                    "x-ves-required": "true"
                },
                "any_asn": {
                    "description": "Exclusive with [asn_list asn_matcher]\nx-displayName: \"Any Source ASN\"\nAny origin ASN.",
                    "title": "any asn",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "any_client": {
                    "description": "Exclusive with [client_name client_name_matcher client_selector]\nx-displayName: \"Any Client\"\nAny Client",
                    "title": "any ip",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "any_dst_asn": {
                    "description": "Exclusive with [dst_asn_list dst_asn_matcher]\nx-displayName: \"Any Destination ASN\"\nAny origin ASN.",
                    "title": "any dst asn",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "any_dst_ip": {
                    "description": "Exclusive with [dst_ip_matcher dst_ip_prefix_list]\nx-displayName: \"Any Destination IP\"\nAny Destination IP",
                    "title": "any dst ip",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "any_ip": {
                    "description": "Exclusive with [ip_matcher ip_prefix_list]\nx-displayName: \"Any Source IP\"\nAny Source IP",
                    "title": "any ip",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "api_group_matcher": {
                    "description": " The list of expected API group names to which the request API belongs. The actual list of API group names for the request API is determined from the api\n group and api group element configuration objects using the HTTP method and the HTTP path as inputs.\n The predicate evaluates to true if any of the actual API group names for the request is equal to any of the values in the api group matcher.",
                    "title": "api group matcher",
                    "$ref": "#/definitions/policyStringMatcherType",
                    "x-displayname": "API Group Matcher"
                },
                "arg_matchers": {
                    "type": "array",
                    "description": " A list of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances\n of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name.\n Note that all specified arg matcher predicates must evaluate to true.",
                    "title": "arg matchers",
                    "items": {
                        "$ref": "#/definitions/policyArgMatcherType"
                    },
                    "x-displayname": "Argument Matchers"
                },
                "asn_list": {
                    "description": "Exclusive with [any_asn asn_matcher]\nx-displayName: \"ASN List\"\nList of 4-byte ASN values.\nThe predicate evaluates to true if the origin ASN is present in the ASN list.",
                    "title": "asn list",
                    "$ref": "#/definitions/policyAsnMatchList"
                },
                "asn_matcher": {
                    "description": "Exclusive with [any_asn asn_list]\nx-displayName: \"BGP ASN Sets\"\nList of references to BGP ASN Set objects.\nThe predicate evaluates to true if the origin ASN is present in one of the BGP ASN Set objects.",
                    "title": "asn matcher",
                    "$ref": "#/definitions/policyAsnMatcherType"
                },
                "body_matcher": {
                    "description": " Predicate for matching the request body string. The criteria for matching the request body is described in MatcherType.\n The actual request body value is extracted from the request API as a string.",
                    "title": "request body matcher",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Request Body Matcher"
                },
                "client_name": {
                    "type": "string",
                    "description": "Exclusive with [any_client client_name_matcher client_selector]\nx-displayName: \"Client Name\"\nx-example: \"backend.production.customer.volterra.us\"\nThe expected name of the client invoking the request API.\nThe predicate evaluates to true if any of the actual names is the same as the expected client name.",
                    "title": "client name"
                },
                "client_name_matcher": {
                    "description": "Exclusive with [any_client client_name client_selector]\nx-displayName: \"Group of Clients by Name\"\nA list of exact values and/or regular expressions for the expected name of the client.\nThis is a generalized version of the client name predicate that allows the same rule to be applicable to a set of clients rather than a single client.\nThe predicate evaluates to true if any of the client's actual names match any of the exact values or regular expressions in the client name matcher.",
                    "title": "client name matcher",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "client_role": {
                    "description": " The expected role(s) of the client invoking the request API. The actual roles for the client are derived from the user and namespace information in the\n API request.\n The predicate evaluates to true if any of the client's roles match the value(s) specified in client role.",
                    "title": "client role",
                    "$ref": "#/definitions/policyRoleMatcherType",
                    "x-displayname": "Client Role"
                },
                "client_selector": {
                    "description": "Exclusive with [any_client client_name client_name_matcher]\nx-displayName: \"Group of Clients by Label Selector\"\nA label selector that describes the expected set of clients. The labels associated with the client making the API request are used to evaluate the label\nexpressions in the selector. These labels can be derived from the client TLS certificate or from the volterra internal control plane.\nThis is a more flexible and powerful version of the client name matcher predicate that allows a given rule to be applicable to a set of clients based on the\nclient labels rather than being limited to relying on patterns in the client name.\nThe predicate evaluates to true if the expressions in the label selector are true for the client labels.",
                    "title": "client selector",
                    "$ref": "#/definitions/schemaLabelSelectorType"
                },
                "cookie_matchers": {
                    "type": "array",
                    "description": " A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances\n of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.\n Note that all specified cookie matcher predicates must evaluate to true.",
                    "title": "cookie matchers",
                    "items": {
                        "$ref": "#/definitions/policyCookieMatcherType"
                    },
                    "x-displayname": "Cookie Matchers"
                },
                "domain_matcher": {
                    "description": " A list of exact values and/or regular expressions for the expected name of the domain. The actual value of domain is the host component\n from the URL. The predicate evaluates to true if the domain value matches any of the exact values or regular expressions in the domain\n matcher.",
                    "title": "domain matcher",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Domain Matcher"
                },
                "dst_asn_list": {
                    "description": "Exclusive with [any_dst_asn dst_asn_matcher]\nx-displayName: \"Destination ASN List\"\nList of 4-byte ASN values.\nThe predicate evaluates to true if the destination ASN is present in the ASN list.",
                    "title": "dst asn list",
                    "$ref": "#/definitions/policyAsnMatchList"
                },
                "dst_asn_matcher": {
                    "description": "Exclusive with [any_dst_asn dst_asn_list]\nx-displayName: \"Destination BGP ASN Sets\"\nList of references to BGP ASN Set objects.\nThe predicate evaluates to true if the destination ASN is present in one of the BGP ASN Set objects.",
                    "title": "dst asn matcher",
                    "$ref": "#/definitions/policyAsnMatcherType"
                },
                "dst_ip_matcher": {
                    "description": "Exclusive with [any_dst_ip dst_ip_prefix_list]\nx-displayName: \"Destination IP Prefix Sets\"\nList of references to IP Prefix Set objects.\nThe predicate evaluates to true if the client IPv4 Address is covered by one or more of the IPv4 Prefixes in the IP Prefix Sets.",
                    "title": "ip matcher",
                    "$ref": "#/definitions/policyIpMatcherType"
                },
                "dst_ip_prefix_list": {
                    "description": "Exclusive with [any_dst_ip dst_ip_matcher]\nx-displayName: \"Destination IPv4 Prefix List\"\nList of IPv4 Prefixes values.\nThe predicate evaluates to true if the destination address is covered by one or more of the IPv4 Prefixes from the list.",
                    "title": "ip prefix list",
                    "$ref": "#/definitions/policyPrefixMatchList"
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": " The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\n the configuration but is not applied anymore.\n\nExample: - \"2019-12-31:44:34.171543432Z\"-",
                    "title": "expiration timestamp",
                    "format": "date-time",
                    "x-displayname": "Expiration Timestamp",
                    "x-ves-example": "2019-12-31:44:34.171543432Z"
                },
                "forwarding_class": {
                    "type": "array",
                    "description": " Ordered list of forwarding class to use for traffic that match the enclosing rule\n Action valid only when the policy is used PBR",
                    "title": "Forwarding Classes",
                    "items": {
                        "$ref": "#/definitions/schemaObjectRefType"
                    },
                    "x-displayname": "Forwarding Classes"
                },
                "headers": {
                    "type": "array",
                    "description": " A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType\n instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.\n Note that all specified header predicates must evaluate to true.",
                    "title": "headers",
                    "items": {
                        "$ref": "#/definitions/schemapolicyHeaderMatcherType"
                    },
                    "x-displayname": "HTTP Headers"
                },
                "http_method": {
                    "description": " The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.\n The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.",
                    "title": "method",
                    "$ref": "#/definitions/policyHttpMethodMatcherType",
                    "x-displayname": "HTTP Method"
                },
                "ip_matcher": {
                    "description": "Exclusive with [any_ip ip_prefix_list]\nx-displayName: \"IP Prefix Sets\"\nList of references to IP Prefix Set objects.\nThe predicate evaluates to true if the client IPv4 Address is covered by one or more of the IPv4 Prefixes in the IP Prefix Sets.",
                    "title": "ip matcher",
                    "$ref": "#/definitions/policyIpMatcherType"
                },
                "ip_prefix_list": {
                    "description": "Exclusive with [any_ip ip_matcher]\nx-displayName: \"IPv4 Prefix List\"\nList of IPv4 Prefixes values.\nThe predicate evaluates to true if the client IPv4 Address is covered by one or more of the IPv4 Prefixes from the list.",
                    "title": "ip prefix list",
                    "$ref": "#/definitions/policyPrefixMatchList"
                },
                "l4_dest_matcher": {
                    "description": " A L4 Destination matcher specifies a list of IPv4 prefixes and a TCP port range as match criteria. The match is considered successful if the destination\n IP matches one of the prefixes and the destination port belongs to the port range.",
                    "title": "l4 dest matcher",
                    "$ref": "#/definitions/policyL4DestMatcherType",
                    "x-displayname": "L4 Destination Matcher"
                },
                "label_matcher": {
                    "description": " A list of label keys that identify the label values that need to be the same for the client and server. Note that the actual label values are not specified\n here, just the label keys. This predicate facilitates reuse of rules and policies across multiple dimensions such as deployment, environment, and location.\n The predicate evaluates to true if the values of the client and server labels for all the keys specified in the label matcher are equal. The values of any\n other labels do not matter.\n\nExample: - \"label_matcher.keys = ['environment', 'location', 'deployment']\"-",
                    "title": "label matcher",
                    "$ref": "#/definitions/schemaLabelMatcherType",
                    "x-displayname": "Label Matcher",
                    "x-ves-example": "label_matcher.keys = ['environment', 'location', 'deployment']"
                },
                "malicious_user_mitigation": {
                    "description": " When user behavior analyses is enabled, all requests in the application namespace are subjected to user-activity based threat level checks and the specified\n actions are taken for mitigation at different threat levels.",
                    "title": "malicious user mitigation",
                    "$ref": "#/definitions/malicious_user_mitigationMaliciousUserMitigationType",
                    "x-displayname": "Malicious User Mitigation"
                },
                "malicious_user_mitigation_bypass": {
                    "description": " When user behavior analyses is enabled, all requests in the application namespace\n are subjected to user behavior analyses and mitigation actions are taken as configured in MaliciousUserMitigationRule.\n If required, the behavior checks can be disabled for certain requests by configuring\n the appropriate match conditions in the enclosing policy rule and setting malicious user mitigation bypass flag.",
                    "title": "malicious user mitigation bypass",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Malicious User Mitigation Bypass"
                },
                "path": {
                    "description": " A list of exact values, prefixes and regular expressions for the expected value of the HTTP path. The actual value of the HTTP path is the unescaped path\n value extracted from the HTTP URL Resource, excluding any query and fragment information.\n The predicate evaluates to true if the actual path value matches any of the exact or prefix values or regular expressions in the path matcher.",
                    "title": "path",
                    "$ref": "#/definitions/schemapolicyPathMatcherType",
                    "x-displayname": "HTTP Path"
                },
                "port_matcher": {
                    "description": " The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.",
                    "title": "port matcher",
                    "$ref": "#/definitions/policyPortMatcherType",
                    "x-displayname": "Port Matcher"
                },
                "query_params": {
                    "type": "array",
                    "description": " A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances\n of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.\n Note that all specified query parameter predicates must evaluate to true.",
                    "title": "query params",
                    "items": {
                        "$ref": "#/definitions/schemapolicyQueryParameterMatcherType"
                    },
                    "x-displayname": "HTTP Query Parameters"
                },
                "rate_limiter": {
                    "type": "array",
                    "description": " A reference to rate_limiter object.\n Requests matching this the enclosing rule are subjected to the specified rate_limiter.",
                    "title": "rate_limiter",
                    "items": {
                        "$ref": "#/definitions/schemaObjectRefType"
                    },
                    "x-displayname": "Rate Limiter"
                },
                "scheme": {
                    "type": "array",
                    "description": " The scheme in the request.\n\nExample: - \"HTTPS\"-",
                    "title": "scheme",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Scheme",
                    "x-ves-example": "HTTPS"
                },
                "server_selector": {
                    "description": " A label selector that describes the expected set of servers.\n The predicate evaluates to true if the expressions in the label selector are true for the server labels.",
                    "title": "server selector",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Group of Servers by Label Selector"
                },
                "tls_fingerprint_matcher": {
                    "description": " TLS JA3 fingerprints to be matched.\n The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.",
                    "title": "TLS JA3 fingerprint matcher",
                    "$ref": "#/definitions/policyTlsFingerprintMatcherType",
                    "x-displayname": "TLS Fingerprint Matcher"
                },
                "url_matcher": {
                    "description": " A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the domain and path match any of the URL items.",
                    "title": "url matcher",
                    "$ref": "#/definitions/policyURLMatcherType",
                    "x-displayname": "URL Matcher"
                },
                "virtual_host_matcher": {
                    "description": " A list of exact values and/or regular expressions for the expected name of the virtual_host. The name of the virtual_host is is part of the context in\n which a service_policy_set is evaluated. The predicate evaluates to true if the virtual_host name matches any of the exact values or regular expressions\n in the virtual_host matcher.\n Hidden because this will be used only in system generated rate limiting service_policy_sets.",
                    "title": "virtual_host matcher",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Virtual Host Matcher"
                },
                "waf_action": {
                    "description": " App Firewall action to be enforced if the input request matches the rule.\nRequired: YES",
                    "title": "App Firewall Action",
                    "$ref": "#/definitions/policyWafAction",
                    "x-displayname": "App Firewall Action",
                    "x-ves-required": "true"
                }
            }
        },
        "service_policy_ruleSpecType": {
            "type": "object",
            "description": "Shape of the service policy rule specification",
            "title": "Specification for service policy rule",
            "x-displayname": "Specification",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.SpecType",
            "properties": {
                "gc_spec": {
                    "title": "gc_spec",
                    "$ref": "#/definitions/schemaservice_policy_ruleGlobalSpecType",
                    "x-displayname": "GC Spec"
                }
            }
        },
        "service_policy_ruleStatusObject": {
            "type": "object",
            "description": "Most recently observed status of object",
            "title": "Status for service policy rule",
            "x-displayname": "Status",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.StatusObject",
            "properties": {
                "conditions": {
                    "type": "array",
                    "description": " Conditions reported by various component of the system",
                    "title": "conditions",
                    "items": {
                        "$ref": "#/definitions/schemaConditionType"
                    },
                    "x-displayname": "Conditions"
                },
                "metadata": {
                    "description": " Standard status's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaStatusMetaType",
                    "x-displayname": "Metadata"
                },
                "object_refs": {
                    "type": "array",
                    "description": " Object reference",
                    "title": "object_refs",
                    "items": {
                        "$ref": "#/definitions/schemaObjectRefType"
                    },
                    "x-displayname": "Config Object"
                }
            }
        },
        "waf_rule_listWafRuleID": {
            "type": "string",
            "description": "Supported WAF rule IDs\n\n - WAF_RULE_ALL: x-displayName: Skip All Rules (internal use only)\nUsed internally to instruct the modsec code in envoy to skip all rules\n - WAF_RULE_910000: x-displayName: 910000\nRequest from Known Malicious Client (Based on previous traffic violations).\n - WAF_RULE_910100: x-displayName: 910100\nClient IP is from a HIGH Risk Country Location.\n - WAF_RULE_910150: x-displayName: 910150\nHTTP Blacklist match for search engine IP\n - WAF_RULE_910160: x-displayName: 910160\nHTTP Blacklist match for spammer IP\n - WAF_RULE_910170: x-displayName: 910170\nHTTP Blacklist match for suspicious IP\n - WAF_RULE_910180: x-displayName: 910180\nHTTP Blacklist match for harvester IP\n - WAF_RULE_911100: x-displayName: 911100\nMethod is not allowed by policy\n - WAF_RULE_912120: x-displayName: 912120\nDenial of Service (DoS) attack identified from %{tx.real_ip} (%{tx.dos_block_counter} hits since last alert)\n - WAF_RULE_913100: x-displayName: 913100\nFound User-Agent associated with security scanner\n - WAF_RULE_913101: x-displayName: 913101\nFound User-Agent associated with scripting/generic HTTP client\n - WAF_RULE_913102: x-displayName: 913102\nFound User-Agent associated with web crawler/bot\n - WAF_RULE_913110: x-displayName: 913110\nFound request header associated with security scanner\n - WAF_RULE_913120: x-displayName: 913120\nFound request filename/argument associated with security scanner\n - WAF_RULE_920100: x-displayName: 920100\nInvalid HTTP Request Line\n - WAF_RULE_920120: x-displayName: 920120\nAttempted multipart/form-data bypass\n - WAF_RULE_920121: x-displayName: 920121\nAttempted multipart/form-data bypass\n - WAF_RULE_920130: x-displayName: 920130\nFailed to parse request body.\n - WAF_RULE_920140: x-displayName: 920140\nMultipart request body failed strict validation:PE %{REQBODY_PROCESSOR_ERROR},BQ %{MULTIPART_BOUNDARY_QUOTED},BW %{MULTIPART_BOUNDARY_WHITESPACE},DB %{MULTIPART_DATA_BEFORE},DA %{MULTIPART_DATA_AFTER},HF %{MULTIPART_HEADER_FOLDING},LF %{MULTIPART_LF_LINE},SM %{MULTIPART_MISSING_SEMICOLON},IQ %{MULTIPART_INVALID_QUOTING},IH %{MULTIPART_INVALID_HEADER_FOLDING},FLE %{MULTIPART_FILE_LIMIT_EXCEEDED}\n - WAF_RULE_920160: x-displayName: 920160\nContent-Length HTTP header is not numeric.\n - WAF_RULE_920170: x-displayName: 920170\nGET or HEAD Request with Body Content.\n - WAF_RULE_920171: x-displayName: 920171\nGET or HEAD Request with Transfer-Encoding.\n - WAF_RULE_920180: x-displayName: 920180\nPOST without Content-Length or Transfer-Encoding headers.\n - WAF_RULE_920190: x-displayName: 920190\nRange: Invalid Last Byte Value.\n - WAF_RULE_920200: x-displayName: 920200\nRange: Too many fields (6 or more)\n - WAF_RULE_920201: x-displayName: 920201\nRange: Too many fields for pdf request (63 or more)\n - WAF_RULE_920202: x-displayName: 920202\nRange: Too many fields for pdf request (6 or more)\n - WAF_RULE_920210: x-displayName: 920210\nMultiple/Conflicting Connection Header Data Found.\n - WAF_RULE_920220: x-displayName: 920220\nURL Encoding Abuse Attack Attempt\n - WAF_RULE_920230: x-displayName: 920230\nMultiple URL Encoding Detected\n - WAF_RULE_920240: x-displayName: 920240\nURL Encoding Abuse Attack Attempt\n - WAF_RULE_920250: x-displayName: 920250\nUTF8 Encoding Abuse Attack Attempt\n - WAF_RULE_920260: x-displayName: 920260\nUnicode Full/Half Width Abuse Attack Attempt\n - WAF_RULE_920270: x-displayName: 920270\nInvalid character in request (null character)\n - WAF_RULE_920271: x-displayName: 920271\nInvalid character in request (non printable characters)\n - WAF_RULE_920272: x-displayName: 920272\nInvalid character in request (outside of printable chars below ascii 127)\n - WAF_RULE_920273: x-displayName: 920273\nInvalid character in request (outside of very strict set)\n - WAF_RULE_920274: x-displayName: 920274\nInvalid character in request headers (outside of very strict set)\n - WAF_RULE_920341: x-displayName: 920341\nRequest Containing Content Requires Content-Type header\n - WAF_RULE_920350: x-displayName: 920350\nHost header is a numeric IP address\n - WAF_RULE_920360: x-displayName: 920360\nArgument name too long\n - WAF_RULE_920370: x-displayName: 920370\nArgument value too long\n - WAF_RULE_920380: x-displayName: 920380\nToo many arguments in request\n - WAF_RULE_920390: x-displayName: 920390\nTotal arguments size exceeded\n - WAF_RULE_920400: x-displayName: 920400\nUploaded file size too large\n - WAF_RULE_920410: x-displayName: 920410\nTotal uploaded files size too large\n - WAF_RULE_920420: x-displayName: 920420\nRequest content type is not allowed by policy\n - WAF_RULE_920430: x-displayName: 920430\nHTTP protocol version is not allowed by policy\n - WAF_RULE_920440: x-displayName: 920440\nURL file extension is restricted by policy\n - WAF_RULE_920450: x-displayName: 920450\nHTTP header is restricted by policy (%{MATCHED_VAR})\n - WAF_RULE_920460: x-displayName: 920460\nAbnormal character escapes in request\n - WAF_RULE_920470: x-displayName: 920470\nIllegal Content-Type header\n - WAF_RULE_920480: x-displayName: 920480\nRequest content type charset is not allowed by policy\n - WAF_RULE_921110: x-displayName: 921110\nHTTP Request Smuggling Attack\n - WAF_RULE_921120: x-displayName: 921120\nHTTP Response Splitting Attack\n - WAF_RULE_921130: x-displayName: 921130\nHTTP Response Splitting Attack\n - WAF_RULE_921140: x-displayName: 921140\nHTTP Header Injection Attack via headers\n - WAF_RULE_921150: x-displayName: 921150\nHTTP Header Injection Attack via payload (CR/LF detected)\n - WAF_RULE_921151: x-displayName: 921151\nHTTP Header Injection Attack via payload (CR/LF detected)\n - WAF_RULE_921160: x-displayName: 921160\nHTTP Header Injection Attack via payload (CR/LF and header-name detected)\n - WAF_RULE_930100: x-displayName: 930100\nPath Traversal Attack (/../)\n - WAF_RULE_930110: x-displayName: 930110\nPath Traversal Attack (/../)\n - WAF_RULE_930120: x-displayName: 930120\nOS File Access Attempt\n - WAF_RULE_930130: x-displayName: 930130\nRestricted File Access Attempt\n - WAF_RULE_931100: x-displayName: 931100\nPossible Remote File Inclusion (RFI) Attack: URL Parameter using IP Address\n - WAF_RULE_931110: x-displayName: 931110\nPossible Remote File Inclusion (RFI) Attack: Common RFI Vulnerable Parameter Name used w/URL Payload\n - WAF_RULE_931120: x-displayName: 931120\nPossible Remote File Inclusion (RFI) Attack: URL Payload Used w/Trailing Question Mark Character (?)\n - WAF_RULE_931130: x-displayName: 931130\nPossible Remote File Inclusion (RFI) Attack: Off-Domain Reference/Link\n - WAF_RULE_932100: x-displayName: 932100\nRemote Command Execution: Unix Command Injection\n - WAF_RULE_932105: x-displayName: 932105\nRemote Command Execution: Unix Command Injection\n - WAF_RULE_932106: x-displayName: 932106\nRemote Command Execution: Unix Command Injection\n - WAF_RULE_932110: x-displayName: 932110\nRemote Command Execution: Windows Command Injection\n - WAF_RULE_932115: x-displayName: 932115\nRemote Command Execution: Windows Command Injection\n - WAF_RULE_932120: x-displayName: 932120\nRemote Command Execution: Windows PowerShell Command Found\n - WAF_RULE_932130: x-displayName: 932130\nRemote Command Execution: Unix Shell Expression Found\n - WAF_RULE_932140: x-displayName: 932140\nRemote Command Execution: Windows FOR/IF Command Found\n - WAF_RULE_932150: x-displayName: 932150\nRemote Command Execution: Direct Unix Command Execution\n - WAF_RULE_932160: x-displayName: 932160\nRemote Command Execution: Unix Shell Code Found\n - WAF_RULE_932170: x-displayName: 932170\nRemote Command Execution: Shellshock (CVE-2014-6271)\n - WAF_RULE_932171: x-displayName: 932171\nRemote Command Execution: Shellshock (CVE-2014-6271)\n - WAF_RULE_932180: x-displayName: 932180\nRestricted File Upload Attempt\n - WAF_RULE_932190: x-displayName: 932190\nRemote Command Execution: Wildcard bypass technique attempt\n - WAF_RULE_933100: x-displayName: 933100\nPHP Injection Attack: PHP Open Tag Found\n - WAF_RULE_933110: x-displayName: 933110\nPHP Injection Attack: PHP Script File Upload Found\n - WAF_RULE_933111: x-displayName: 933111\nPHP Injection Attack: PHP Script File Upload Found\n - WAF_RULE_933120: x-displayName: 933120\nPHP Injection Attack: Configuration Directive Found\n - WAF_RULE_933130: x-displayName: 933130\nPHP Injection Attack: Variables Found\n - WAF_RULE_933131: x-displayName: 933131\nPHP Injection Attack: Variables Found\n - WAF_RULE_933140: x-displayName: 933140\nPHP Injection Attack: I/O Stream Found\n - WAF_RULE_933150: x-displayName: 933150\nPHP Injection Attack: High-Risk PHP Function Name Found\n - WAF_RULE_933151: x-displayName: 933151\nPHP Injection Attack: Medium-Risk PHP Function Name Found\n - WAF_RULE_933160: x-displayName: 933160\nPHP Injection Attack: High-Risk PHP Function Call Found\n - WAF_RULE_933161: x-displayName: 933161\nPHP Injection Attack: Low-Value PHP Function Call Found\n - WAF_RULE_933170: x-displayName: 933170\nPHP Injection Attack: Serialized Object Injection\n - WAF_RULE_933180: x-displayName: 933180\nPHP Injection Attack: Variable Function Call Found\n - WAF_RULE_933190: x-displayName: 933190\nPHP Injection Attack: PHP Closing Tag Found\n - WAF_RULE_941100: x-displayName: 941100\nXSS Attack Detected via libinjection\n - WAF_RULE_941101: x-displayName: 941101\nXSS Attack Detected via libinjection\n - WAF_RULE_941110: x-displayName: 941110\nXSS Filter - Category 1: Script Tag Vector\n - WAF_RULE_941120: x-displayName: 941120\nXSS Filter - Category 2: Event Handler Vector\n - WAF_RULE_941130: x-displayName: 941130\nXSS Filter - Category 3: Attribute Vector\n - WAF_RULE_941140: x-displayName: 941140\nXSS Filter - Category 4: Javascript URI Vector\n - WAF_RULE_941150: x-displayName: 941150\nXSS Filter - Category 5: Disallowed HTML Attributes\n - WAF_RULE_941160: x-displayName: 941160\nNoScript XSS InjectionChecker: HTML Injection\n - WAF_RULE_941170: x-displayName: 941170\nNoScript XSS InjectionChecker: Attribute Injection\n - WAF_RULE_941180: x-displayName: 941180\nNode-Validator Blacklist Keywords\n - WAF_RULE_941190: x-displayName: 941190\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941200: x-displayName: 941200\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941210: x-displayName: 941210\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941220: x-displayName: 941220\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941230: x-displayName: 941230\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941240: x-displayName: 941240\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941250: x-displayName: 941250\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941260: x-displayName: 941260\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941270: x-displayName: 941270\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941280: x-displayName: 941280\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941290: x-displayName: 941290\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941300: x-displayName: 941300\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941310: x-displayName: 941310\nUS-ASCII Malformed Encoding XSS Filter - Attack Detected.\n - WAF_RULE_941320: x-displayName: 941320\nPossible XSS Attack Detected - HTML Tag Handler\n - WAF_RULE_941330: x-displayName: 941330\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941340: x-displayName: 941340\nIE XSS Filters - Attack Detected.\n - WAF_RULE_941350: x-displayName: 941350\nUTF-7 Encoding IE XSS - Attack Detected.\n - WAF_RULE_942100: x-displayName: 942100\nSQL Injection Attack Detected via libinjection\n - WAF_RULE_942110: x-displayName: 942110\nSQL Injection Attack: Common Injection Testing Detected\n - WAF_RULE_942120: x-displayName: 942120\nSQL Injection Attack: SQL Operator Detected\n - WAF_RULE_942130: x-displayName: 942130\nSQL Injection Attack: SQL Tautology Detected.\n - WAF_RULE_942140: x-displayName: 942140\nSQL Injection Attack: Common DB Names Detected\n - WAF_RULE_942150: x-displayName: 942150\nSQL Injection Attack\n - WAF_RULE_942160: x-displayName: 942160\nDetects blind sqli tests using sleep() or benchmark().\n - WAF_RULE_942170: x-displayName: 942170\nDetects SQL benchmark and sleep injection attempts including conditional queries\n - WAF_RULE_942180: x-displayName: 942180\nDetects basic SQL authentication bypass attempts 1/3\n - WAF_RULE_942190: x-displayName: 942190\nDetects MSSQL code execution and information gathering attempts\n - WAF_RULE_942200: x-displayName: 942200\nDetects MySQL comment-/space-obfuscated injections and backtick termination\n - WAF_RULE_942210: x-displayName: 942210\nDetects chained SQL injection attempts 1/2\n - WAF_RULE_942220: x-displayName: 942220\nLooking for integer overflow attacks, these are taken from skipfish, except 3.0.00738585072007e-308 is the \\\n - WAF_RULE_942230: x-displayName: 942230\nDetects conditional SQL injection attempts\n - WAF_RULE_942240: x-displayName: 942240\nDetects MySQL charset switch and MSSQL DoS attempts\n - WAF_RULE_942250: x-displayName: 942250\nDetects MATCH AGAINST, MERGE and EXECUTE IMMEDIATE injections\n - WAF_RULE_942251: x-displayName: 942251\nDetects HAVING injections\n - WAF_RULE_942260: x-displayName: 942260\nDetects basic SQL authentication bypass attempts 2/3\n - WAF_RULE_942270: x-displayName: 942270\nLooking for basic sql injection. Common attack string for mysql, oracle and others.\n - WAF_RULE_942280: x-displayName: 942280\nDetects Postgres pg_sleep injection, waitfor delay attacks and database shutdown attempts\n - WAF_RULE_942290: x-displayName: 942290\nFinds basic MongoDB SQL injection attempts\n - WAF_RULE_942300: x-displayName: 942300\nDetects MySQL comments, conditions and ch(a)r injections\n - WAF_RULE_942310: x-displayName: 942310\nDetects chained SQL injection attempts 2/2\n - WAF_RULE_942320: x-displayName: 942320\nDetects MySQL and PostgreSQL stored procedure/function injections\n - WAF_RULE_942330: x-displayName: 942330\nDetects classic SQL injection probings 1/3\n - WAF_RULE_942340: x-displayName: 942340\nDetects basic SQL authentication bypass attempts 3/3\n - WAF_RULE_942350: x-displayName: 942350\nDetects MySQL UDF injection and other data/structure manipulation attempts\n - WAF_RULE_942360: x-displayName: 942360\nDetects concatenated basic SQL injection and SQLLFI attempts\n - WAF_RULE_942361: x-displayName: 942361\nDetects basic SQL injection based on keyword alter or union\n - WAF_RULE_942370: x-displayName: 942370\nDetects classic SQL injection probings 2/3\n - WAF_RULE_942380: x-displayName: 942380\nSQL Injection Attack\n - WAF_RULE_942390: x-displayName: 942390\nSQL Injection Attack\n - WAF_RULE_942400: x-displayName: 942400\nSQL Injection Attack\n - WAF_RULE_942410: x-displayName: 942410\nSQL Injection Attack\n - WAF_RULE_942420: x-displayName: 942420\nRestricted SQL Character Anomaly Detection (cookies): # of special characters exceeded (8)\n - WAF_RULE_942421: x-displayName: 942421\nRestricted SQL Character Anomaly Detection (cookies): # of special characters exceeded (3)\n - WAF_RULE_942430: x-displayName: 942430\nRestricted SQL Character Anomaly Detection (args): # of special characters exceeded (12)\n - WAF_RULE_942431: x-displayName: 942431\nRestricted SQL Character Anomaly Detection (args): # of special characters exceeded (6)\n - WAF_RULE_942432: x-displayName: 942432\nRestricted SQL Character Anomaly Detection (args): # of special characters exceeded (2)\n - WAF_RULE_942440: x-displayName: 942440\nSQL Comment Sequence Detected.\n - WAF_RULE_942450: x-displayName: 942450\nSQL Hex Encoding Identified\n - WAF_RULE_942460: x-displayName: 942460\nMeta-Character Anomaly Detection Alert - Repetitive Non-Word Characters\n - WAF_RULE_942470: x-displayName: 942470\nSQL Injection Attack\n - WAF_RULE_942480: x-displayName: 942480\nSQL Injection Attack\n - WAF_RULE_942490: x-displayName: 942490\nDetects classic SQL injection probings 3/3\n - WAF_RULE_943100: x-displayName: 943100\nPossible Session Fixation Attack: Setting Cookie Values in HTML\n - WAF_RULE_943110: x-displayName: 943110\nPossible Session Fixation Attack: SessionID Parameter Name with Off-Domain Referer\n - WAF_RULE_943120: x-displayName: 943120\nPossible Session Fixation Attack: SessionID Parameter Name with No Referer\n - WAF_RULE_944100: x-displayName: 944100\nRemote Command Execution: Suspicious Java class detected\n - WAF_RULE_944110: x-displayName: 944110\nRemote Command Execution: Java process spawn (CVE-2017-9805)\n - WAF_RULE_944120: x-displayName: 944120\nRemote Command Execution: Java serialization (CVE-2015-5842)\n - WAF_RULE_944130: x-displayName: 944130\nSuspicious Java class detected\n - WAF_RULE_944200: x-displayName: 944200\nMagic bytes Detected, probable java serialization in use\n - WAF_RULE_944210: x-displayName: 944210\nMagic bytes Detected Base64 Encoded, probable java serialization in use\n - WAF_RULE_944240: x-displayName: 944240\nRemote Command Execution: Java serialization (CVE-2015-5842)\n - WAF_RULE_944250: x-displayName: 944250\nRemote Command Execution: Suspicious Java method detected\n - WAF_RULE_944300: x-displayName: 944300\nBase64 encoded string matched suspicious keyword\n - WAF_RULE_950100: x-displayName: 950100\nThe Application Returned a 500-Level Status Code\n - WAF_RULE_950130: x-displayName: 950130\nDirectory Listing\n - WAF_RULE_951110: x-displayName: 951110\nMicrosoft Access SQL Information Leakage\n - WAF_RULE_951120: x-displayName: 951120\nOracle SQL Information Leakage\n - WAF_RULE_951130: x-displayName: 951130\nDB2 SQL Information Leakage\n - WAF_RULE_951140: x-displayName: 951140\nEMC SQL Information Leakage\n - WAF_RULE_951150: x-displayName: 951150\nfirebird SQL Information Leakage\n - WAF_RULE_951160: x-displayName: 951160\nFrontbase SQL Information Leakage\n - WAF_RULE_951170: x-displayName: 951170\nhsqldb SQL Information Leakage\n - WAF_RULE_951180: x-displayName: 951180\ninformix SQL Information Leakage\n - WAF_RULE_951190: x-displayName: 951190\ningres SQL Information Leakage\n - WAF_RULE_951200: x-displayName: 951200\ninterbase SQL Information Leakage\n - WAF_RULE_951210: x-displayName: 951210\nmaxDB SQL Information Leakage\n - WAF_RULE_951220: x-displayName: 951220\nmssql SQL Information Leakage\n - WAF_RULE_951230: x-displayName: 951230\nmysql SQL Information Leakage\n - WAF_RULE_951240: x-displayName: 951240\npostgres SQL Information Leakage\n - WAF_RULE_951250: x-displayName: 951250\nsqlite SQL Information Leakage\n - WAF_RULE_951260: x-displayName: 951260\nSybase SQL Information Leakage\n - WAF_RULE_952100: x-displayName: 952100\nJava Source Code Leakage\n - WAF_RULE_952110: x-displayName: 952110\nJava Errors\n - WAF_RULE_953100: x-displayName: 953100\nPHP Information Leakage\n - WAF_RULE_953110: x-displayName: 953110\nPHP source code leakage\n - WAF_RULE_953120: x-displayName: 953120\nPHP source code leakage\n - WAF_RULE_954100: x-displayName: 954100\nDisclosure of IIS install location\n - WAF_RULE_954110: x-displayName: 954110\nApplication Availability Error\n - WAF_RULE_954120: x-displayName: 954120\nIIS Information Leakage\n - WAF_RULE_954130: x-displayName: 954130\nIIS Information Leakage\n - WAF_RULE_4295001: x-displayName: 4295001\nEnable Drupal specific CRS exclusions\n - WAF_RULE_4295002: x-displayName: 4295002\nEnable Wordpress specific CRS exclusions\n - WAF_RULE_4295003: x-displayName: 4295003\nEnable Cpanel specific CRS exclusions\n - WAF_RULE_4295004: x-displayName: 4295004\nEnable Dokuwiki specific CRS exclusions\n - WAF_RULE_4295005: x-displayName: 4295005\nEnable Nextcloud specific CRS exclusions\n - WAF_RULE_4295006: x-displayName: 4295006\nEnable Xenforo specific CRS exclusions",
            "title": "WAF Rule ID",
            "enum": [
                "WAF_RULE_ALL",
                "WAF_RULE_910000",
                "WAF_RULE_910100",
                "WAF_RULE_910150",
                "WAF_RULE_910160",
                "WAF_RULE_910170",
                "WAF_RULE_910180",
                "WAF_RULE_911100",
                "WAF_RULE_912120",
                "WAF_RULE_913100",
                "WAF_RULE_913101",
                "WAF_RULE_913102",
                "WAF_RULE_913110",
                "WAF_RULE_913120",
                "WAF_RULE_920100",
                "WAF_RULE_920120",
                "WAF_RULE_920121",
                "WAF_RULE_920130",
                "WAF_RULE_920140",
                "WAF_RULE_920160",
                "WAF_RULE_920170",
                "WAF_RULE_920171",
                "WAF_RULE_920180",
                "WAF_RULE_920190",
                "WAF_RULE_920200",
                "WAF_RULE_920201",
                "WAF_RULE_920202",
                "WAF_RULE_920210",
                "WAF_RULE_920220",
                "WAF_RULE_920230",
                "WAF_RULE_920240",
                "WAF_RULE_920250",
                "WAF_RULE_920260",
                "WAF_RULE_920270",
                "WAF_RULE_920271",
                "WAF_RULE_920272",
                "WAF_RULE_920273",
                "WAF_RULE_920274",
                "WAF_RULE_920341",
                "WAF_RULE_920350",
                "WAF_RULE_920360",
                "WAF_RULE_920370",
                "WAF_RULE_920380",
                "WAF_RULE_920390",
                "WAF_RULE_920400",
                "WAF_RULE_920410",
                "WAF_RULE_920420",
                "WAF_RULE_920430",
                "WAF_RULE_920440",
                "WAF_RULE_920450",
                "WAF_RULE_920460",
                "WAF_RULE_920470",
                "WAF_RULE_920480",
                "WAF_RULE_921110",
                "WAF_RULE_921120",
                "WAF_RULE_921130",
                "WAF_RULE_921140",
                "WAF_RULE_921150",
                "WAF_RULE_921151",
                "WAF_RULE_921160",
                "WAF_RULE_930100",
                "WAF_RULE_930110",
                "WAF_RULE_930120",
                "WAF_RULE_930130",
                "WAF_RULE_931100",
                "WAF_RULE_931110",
                "WAF_RULE_931120",
                "WAF_RULE_931130",
                "WAF_RULE_932100",
                "WAF_RULE_932105",
                "WAF_RULE_932106",
                "WAF_RULE_932110",
                "WAF_RULE_932115",
                "WAF_RULE_932120",
                "WAF_RULE_932130",
                "WAF_RULE_932140",
                "WAF_RULE_932150",
                "WAF_RULE_932160",
                "WAF_RULE_932170",
                "WAF_RULE_932171",
                "WAF_RULE_932180",
                "WAF_RULE_932190",
                "WAF_RULE_933100",
                "WAF_RULE_933110",
                "WAF_RULE_933111",
                "WAF_RULE_933120",
                "WAF_RULE_933130",
                "WAF_RULE_933131",
                "WAF_RULE_933140",
                "WAF_RULE_933150",
                "WAF_RULE_933151",
                "WAF_RULE_933160",
                "WAF_RULE_933161",
                "WAF_RULE_933170",
                "WAF_RULE_933180",
                "WAF_RULE_933190",
                "WAF_RULE_941100",
                "WAF_RULE_941101",
                "WAF_RULE_941110",
                "WAF_RULE_941120",
                "WAF_RULE_941130",
                "WAF_RULE_941140",
                "WAF_RULE_941150",
                "WAF_RULE_941160",
                "WAF_RULE_941170",
                "WAF_RULE_941180",
                "WAF_RULE_941190",
                "WAF_RULE_941200",
                "WAF_RULE_941210",
                "WAF_RULE_941220",
                "WAF_RULE_941230",
                "WAF_RULE_941240",
                "WAF_RULE_941250",
                "WAF_RULE_941260",
                "WAF_RULE_941270",
                "WAF_RULE_941280",
                "WAF_RULE_941290",
                "WAF_RULE_941300",
                "WAF_RULE_941310",
                "WAF_RULE_941320",
                "WAF_RULE_941330",
                "WAF_RULE_941340",
                "WAF_RULE_941350",
                "WAF_RULE_942100",
                "WAF_RULE_942110",
                "WAF_RULE_942120",
                "WAF_RULE_942130",
                "WAF_RULE_942140",
                "WAF_RULE_942150",
                "WAF_RULE_942160",
                "WAF_RULE_942170",
                "WAF_RULE_942180",
                "WAF_RULE_942190",
                "WAF_RULE_942200",
                "WAF_RULE_942210",
                "WAF_RULE_942220",
                "WAF_RULE_942230",
                "WAF_RULE_942240",
                "WAF_RULE_942250",
                "WAF_RULE_942251",
                "WAF_RULE_942260",
                "WAF_RULE_942270",
                "WAF_RULE_942280",
                "WAF_RULE_942290",
                "WAF_RULE_942300",
                "WAF_RULE_942310",
                "WAF_RULE_942320",
                "WAF_RULE_942330",
                "WAF_RULE_942340",
                "WAF_RULE_942350",
                "WAF_RULE_942360",
                "WAF_RULE_942361",
                "WAF_RULE_942370",
                "WAF_RULE_942380",
                "WAF_RULE_942390",
                "WAF_RULE_942400",
                "WAF_RULE_942410",
                "WAF_RULE_942420",
                "WAF_RULE_942421",
                "WAF_RULE_942430",
                "WAF_RULE_942431",
                "WAF_RULE_942432",
                "WAF_RULE_942440",
                "WAF_RULE_942450",
                "WAF_RULE_942460",
                "WAF_RULE_942470",
                "WAF_RULE_942480",
                "WAF_RULE_942490",
                "WAF_RULE_943100",
                "WAF_RULE_943110",
                "WAF_RULE_943120",
                "WAF_RULE_944100",
                "WAF_RULE_944110",
                "WAF_RULE_944120",
                "WAF_RULE_944130",
                "WAF_RULE_944200",
                "WAF_RULE_944210",
                "WAF_RULE_944240",
                "WAF_RULE_944250",
                "WAF_RULE_944300",
                "WAF_RULE_950100",
                "WAF_RULE_950130",
                "WAF_RULE_951110",
                "WAF_RULE_951120",
                "WAF_RULE_951130",
                "WAF_RULE_951140",
                "WAF_RULE_951150",
                "WAF_RULE_951160",
                "WAF_RULE_951170",
                "WAF_RULE_951180",
                "WAF_RULE_951190",
                "WAF_RULE_951200",
                "WAF_RULE_951210",
                "WAF_RULE_951220",
                "WAF_RULE_951230",
                "WAF_RULE_951240",
                "WAF_RULE_951250",
                "WAF_RULE_951260",
                "WAF_RULE_952100",
                "WAF_RULE_952110",
                "WAF_RULE_953100",
                "WAF_RULE_953110",
                "WAF_RULE_953120",
                "WAF_RULE_954100",
                "WAF_RULE_954110",
                "WAF_RULE_954120",
                "WAF_RULE_954130",
                "WAF_RULE_4295001",
                "WAF_RULE_4295002",
                "WAF_RULE_4295003",
                "WAF_RULE_4295004",
                "WAF_RULE_4295005",
                "WAF_RULE_4295006"
            ],
            "default": "WAF_RULE_ALL",
            "x-displayname": "WAF Rule ID",
            "x-ves-proto-enum": "ves.io.schema.waf_rule_list.WafRuleID"
        }
    },
    "x-displayname": "",
    "x-ves-proto-file": "ves.io/schema/service_policy_rule/crudapi/api.proto"
}`
