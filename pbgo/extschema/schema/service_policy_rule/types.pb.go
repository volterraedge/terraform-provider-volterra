// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/service_policy_rule/types.proto

package service_policy_rule

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GlobalSpecType
//
// x-displayName: "Specification"
// Shape of service_policy_rule in the storage backend.
type GlobalSpecType struct {
	// action
	//
	// x-displayName: "Action"
	// x-required
	// Action to be enforced if the input request matches the rule.
	Action policy.RuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// client choice
	//
	// x-displayName: "Client Selection"
	// x-required
	// Select clients for which the rule the will be applied. The actual names of the client are extracted from its TLS certificate.
	//
	// Types that are valid to be assigned to ClientChoice:
	//	*GlobalSpecType_AnyClient
	//	*GlobalSpecType_ClientName
	//	*GlobalSpecType_ClientSelector
	//	*GlobalSpecType_ClientNameMatcher
	ClientChoice isGlobalSpecType_ClientChoice `protobuf_oneof:"client_choice"`
	// client role
	//
	// x-displayName: "Client Role"
	// The expected role(s) of the client invoking the request API. The actual roles for the client are derived from the user and namespace information in the
	// API request.
	// The predicate evaluates to true if any of the client's roles match the value(s) specified in client role.
	ClientRole *policy.RoleMatcherType `protobuf:"bytes,9,opt,name=client_role,json=clientRole,proto3" json:"client_role,omitempty"`
	// server selector
	//
	// x-displayName: "Group of Servers by Label Selector"
	// A label selector that describes the expected set of servers.
	// The predicate evaluates to true if the expressions in the label selector are true for the server labels.
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,45,opt,name=server_selector,json=serverSelector,proto3" json:"server_selector,omitempty"`
	// label matcher
	//
	// x-displayName: "Label Matcher"
	// x-example: "['environment', 'location', 'deployment']"
	// A list of label keys that identify the label values that need to be the same for the client and server. Note that the actual label values are not specified
	// here, just the label keys. This predicate facilitates reuse of rules and policies across multiple dimensions such as deployment, environment, and location.
	// The predicate evaluates to true if the values of the client and server labels for all the keys specified in the label matcher are equal. The values of any
	// other labels do not matter.
	LabelMatcher *schema.LabelMatcherType `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	// path
	//
	// x-displayName: "HTTP Path"
	// A list of exact values, prefixes and regular expressions for the expected value of the HTTP path. The actual value of the HTTP path is the unescaped path
	// value extracted from the HTTP URL Resource, excluding any query and fragment information.
	// The predicate evaluates to true if the actual path value matches any of the exact or prefix values or regular expressions in the path matcher.
	Path *policy.PathMatcherType `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	// headers
	//
	// x-displayName: "HTTP Headers"
	// A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType
	// instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.
	// Note that all specified header predicates must evaluate to true.
	Headers []*policy.HeaderMatcherType `protobuf:"bytes,6,rep,name=headers,proto3" json:"headers,omitempty"`
	// query params
	//
	// x-displayName: "HTTP Query Parameters"
	// A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances
	// of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.
	// Note that all specified query parameter predicates must evaluate to true.
	QueryParams []*policy.QueryParameterMatcherType `protobuf:"bytes,7,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	// method
	//
	// x-displayName: "HTTP Method"
	// The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.
	// The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.
	HttpMethod *policy.HttpMethodMatcherType `protobuf:"bytes,8,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	// ip choice
	//
	// x-displayName: "Source IPv4 Match"
	// x-required
	// Match source IPv4 address of the request
	//
	// Types that are valid to be assigned to IpChoice:
	//	*GlobalSpecType_AnyIp
	//	*GlobalSpecType_IpPrefixList
	//	*GlobalSpecType_IpMatcher
	IpChoice isGlobalSpecType_IpChoice `protobuf_oneof:"ip_choice"`
	// dst ip choice
	//
	// x-displayName: "Destination IPv4 Match"
	// Match destination IPv4 address of the request
	//
	// Types that are valid to be assigned to DstIpChoice:
	//	*GlobalSpecType_AnyDstIp
	//	*GlobalSpecType_DstIpPrefixList
	//	*GlobalSpecType_DstIpMatcher
	DstIpChoice isGlobalSpecType_DstIpChoice `protobuf_oneof:"dst_ip_choice"`
	// asn choice
	//
	// x-displayName: "Source ASN Match"
	// x-required
	// Match the 4-byte origin Autonomous System Number for the source IPv4 address of the request. The origin ASN for the request is obtained by performing
	// a lookup for the source IPv4 Address in a GeoIP DB.
	//
	// Types that are valid to be assigned to AsnChoice:
	//	*GlobalSpecType_AnyAsn
	//	*GlobalSpecType_AsnList
	//	*GlobalSpecType_AsnMatcher
	AsnChoice isGlobalSpecType_AsnChoice `protobuf_oneof:"asn_choice"`
	// asn choice
	//
	// x-displayName: "Destination ASN Match"
	// Match the 4-byte origin Autonomous System Number for the destination ASN. The destination ASN is obtained by performing a lookup for the destination IPv4
	// Address in a GeoIP DB.
	//
	// Types that are valid to be assigned to DstAsnChoice:
	//	*GlobalSpecType_AnyDstAsn
	//	*GlobalSpecType_DstAsnList
	//	*GlobalSpecType_DstAsnMatcher
	DstAsnChoice isGlobalSpecType_DstAsnChoice `protobuf_oneof:"dst_asn_choice"`
	// api group matcher
	//
	// x-displayName: "API Group Matcher"
	// The list of expected API group names to which the request API belongs. The actual list of API group names for the request API is determined from the api
	// group and api group element configuration objects using the HTTP method and the HTTP path as inputs.
	// The predicate evaluates to true if any of the actual API group names for the request is equal to any of the values in the api group matcher.
	ApiGroupMatcher *policy.StringMatcherType `protobuf:"bytes,14,opt,name=api_group_matcher,json=apiGroupMatcher,proto3" json:"api_group_matcher,omitempty"`
	// port matcher
	//
	// x-displayName: "Port Matcher"
	// The list of port ranges to which the destination port should belong. In case of an HTTP Connect, the port is extracted from the desired destination.
	PortMatcher *policy.PortMatcherType `protobuf:"bytes,15,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	// expiration timestamp
	//
	// x-displayName: "Expiration Timestamp"
	// x-example: "2019-12-31:44:34.171543432Z"
	// The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in
	// the configuration but is not applied anymore.
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,16,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// request body matcher
	//
	// x-displayName: "Request Body Matcher"
	// Predicate for matching the request body string. The criteria for matching the request body is described in MatcherType.
	// The actual request body value is extracted from the request API as a string.
	BodyMatcher *policy.MatcherType `protobuf:"bytes,21,opt,name=body_matcher,json=bodyMatcher,proto3" json:"body_matcher,omitempty"`
	// arg matchers
	//
	// x-displayName: "Argument Matchers"
	// A list of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances
	// of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name.
	// Note that all specified arg matcher predicates must evaluate to true.
	ArgMatchers []*policy.ArgMatcherType `protobuf:"bytes,18,rep,name=arg_matchers,json=argMatchers,proto3" json:"arg_matchers,omitempty"`
	// cookie matchers
	//
	// x-displayName: "Cookie Matchers"
	// A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances
	// of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.
	// Note that all specified cookie matcher predicates must evaluate to true.
	CookieMatchers []*policy.CookieMatcherType `protobuf:"bytes,19,rep,name=cookie_matchers,json=cookieMatchers,proto3" json:"cookie_matchers,omitempty"`
	// App Firewall Action
	//
	// x-displayName: "App Firewall Action"
	// x-required
	// App Firewall action to be enforced if the input request matches the rule.
	WafAction *policy.WafAction `protobuf:"bytes,20,opt,name=waf_action,json=wafAction,proto3" json:"waf_action,omitempty"`
	// domain matcher
	//
	// x-displayName: "Domain Matcher"
	// A list of exact values and/or regular expressions for the expected name of the domain. The actual value of domain is the host component
	// from the URL. The predicate evaluates to true if the domain value matches any of the exact values or regular expressions in the domain
	// matcher.
	DomainMatcher *policy.MatcherType `protobuf:"bytes,22,opt,name=domain_matcher,json=domainMatcher,proto3" json:"domain_matcher,omitempty"`
	// rate_limiter
	//
	// x-displayName: "Rate Limiter"
	// A reference to rate_limiter object.
	// Requests matching this the enclosing rule are subjected to the specified rate_limiter.
	RateLimiter []*schema.ObjectRefType `protobuf:"bytes,23,rep,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty"`
	// virtual_host matcher
	//
	// x-displayName: "Virtual Host Matcher"
	// A list of exact values and/or regular expressions for the expected name of the virtual_host. The name of the virtual_host is is part of the context in
	// which a service_policy_set is evaluated. The predicate evaluates to true if the virtual_host name matches any of the exact values or regular expressions
	// in the virtual_host matcher.
	// Hidden because this will be used only in system generated rate limiting service_policy_sets.
	VirtualHostMatcher *policy.MatcherType `protobuf:"bytes,24,opt,name=virtual_host_matcher,json=virtualHostMatcher,proto3" json:"virtual_host_matcher,omitempty"`
	// TLS JA3 fingerprint matcher
	//
	// x-displayName: "TLS Fingerprint Matcher"
	// TLS JA3 fingerprints to be matched.
	// The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.
	TlsFingerprintMatcher *policy.TlsFingerprintMatcherType `protobuf:"bytes,25,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher,proto3" json:"tls_fingerprint_matcher,omitempty"`
	// Forwarding Classes
	//
	// x-displayName: "Forwarding Classes"
	// Ordered list of forwarding class to use for traffic that match the enclosing rule
	// Action valid only when the policy is used PBR
	ForwardingClass []*schema.ObjectRefType `protobuf:"bytes,26,rep,name=forwarding_class,json=forwardingClass,proto3" json:"forwarding_class,omitempty"`
	// malicious user mitigation bypass
	//
	// x-displayName: "Malicious User Mitigation Bypass"
	// When user behavior analyses is enabled, all requests in the application namespace
	// are subjected to user behavior analyses and mitigation actions are taken as configured in MaliciousUserMitigationRule.
	// If required, the behavior checks can be disabled for certain requests by configuring
	// the appropriate match conditions in the enclosing policy rule and setting malicious user mitigation bypass flag.
	MaliciousUserMitigationBypass *schema.Empty `protobuf:"bytes,28,opt,name=malicious_user_mitigation_bypass,json=maliciousUserMitigationBypass,proto3" json:"malicious_user_mitigation_bypass,omitempty"`
	// scheme
	//
	// x-displayName: "Scheme"
	// x-example: "HTTPS"
	// The scheme in the request.
	Scheme []string `protobuf:"bytes,38,rep,name=scheme,proto3" json:"scheme,omitempty"`
	// url matcher
	//
	// x-displayName: "URL Matcher"
	// A URL matcher specifies a list of URL items as match criteria. The match is considered successful if the domain and path match any of the URL items.
	UrlMatcher *policy.URLMatcherType `protobuf:"bytes,39,opt,name=url_matcher,json=urlMatcher,proto3" json:"url_matcher,omitempty"`
	// l4 dest matcher
	//
	// x-displayName: "L4 Destination Matcher"
	// A L4 Destination matcher specifies a list of IPv4 prefixes and a TCP port range as match criteria. The match is considered successful if the destination
	// IP matches one of the prefixes and the destination port belongs to the port range.
	L4DestMatcher *policy.L4DestMatcherType `protobuf:"bytes,44,opt,name=l4_dest_matcher,json=l4DestMatcher,proto3" json:"l4_dest_matcher,omitempty"`
	// Challenge Action
	//
	// x-displayName: "Select Challenge Action Type"
	// x-required
	// Select challenge action, enable javascript/captcha challenge or disable challenge
	ChallengeAction policy.ChallengeAction `protobuf:"varint,54,opt,name=challenge_action,json=challengeAction,proto3,enum=ves.io.schema.policy.ChallengeAction" json:"challenge_action,omitempty"`
	// goto_policy
	//
	// x-displayName: "Goto Policy"
	// A reference to a service_policy object.
	// Target of the GOTO_POLICY action.
	// The target policy must be part of the current policy set and must be after the current policy in the policy set.
	GotoPolicy []*schema.ObjectRefType `protobuf:"bytes,55,rep,name=goto_policy,json=gotoPolicy,proto3" json:"goto_policy,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_771e54eb594e8c4b, []int{0}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_ClientChoice interface {
	isGlobalSpecType_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_IpChoice interface {
	isGlobalSpecType_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_DstIpChoice interface {
	isGlobalSpecType_DstIpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_AsnChoice interface {
	isGlobalSpecType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_DstAsnChoice interface {
	isGlobalSpecType_DstAsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AnyClient struct {
	AnyClient *schema.Empty `protobuf:"bytes,37,opt,name=any_client,json=anyClient,proto3,oneof" json:"any_client,omitempty"`
}
type GlobalSpecType_ClientName struct {
	ClientName string `protobuf:"bytes,2,opt,name=client_name,json=clientName,proto3,oneof" json:"client_name,omitempty"`
}
type GlobalSpecType_ClientSelector struct {
	ClientSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=client_selector,json=clientSelector,proto3,oneof" json:"client_selector,omitempty"`
}
type GlobalSpecType_ClientNameMatcher struct {
	ClientNameMatcher *policy.MatcherType `protobuf:"bytes,10,opt,name=client_name_matcher,json=clientNameMatcher,proto3,oneof" json:"client_name_matcher,omitempty"`
}
type GlobalSpecType_AnyIp struct {
	AnyIp *schema.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,proto3,oneof" json:"any_ip,omitempty"`
}
type GlobalSpecType_IpPrefixList struct {
	IpPrefixList *policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,proto3,oneof" json:"ip_prefix_list,omitempty"`
}
type GlobalSpecType_IpMatcher struct {
	IpMatcher *policy.IpMatcherType `protobuf:"bytes,12,opt,name=ip_matcher,json=ipMatcher,proto3,oneof" json:"ip_matcher,omitempty"`
}
type GlobalSpecType_AnyDstIp struct {
	AnyDstIp *schema.Empty `protobuf:"bytes,41,opt,name=any_dst_ip,json=anyDstIp,proto3,oneof" json:"any_dst_ip,omitempty"`
}
type GlobalSpecType_DstIpPrefixList struct {
	DstIpPrefixList *policy.PrefixMatchList `protobuf:"bytes,42,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,proto3,oneof" json:"dst_ip_prefix_list,omitempty"`
}
type GlobalSpecType_DstIpMatcher struct {
	DstIpMatcher *policy.IpMatcherType `protobuf:"bytes,43,opt,name=dst_ip_matcher,json=dstIpMatcher,proto3,oneof" json:"dst_ip_matcher,omitempty"`
}
type GlobalSpecType_AnyAsn struct {
	AnyAsn *schema.Empty `protobuf:"bytes,34,opt,name=any_asn,json=anyAsn,proto3,oneof" json:"any_asn,omitempty"`
}
type GlobalSpecType_AsnList struct {
	AsnList *policy.AsnMatchList `protobuf:"bytes,35,opt,name=asn_list,json=asnList,proto3,oneof" json:"asn_list,omitempty"`
}
type GlobalSpecType_AsnMatcher struct {
	AsnMatcher *policy.AsnMatcherType `protobuf:"bytes,13,opt,name=asn_matcher,json=asnMatcher,proto3,oneof" json:"asn_matcher,omitempty"`
}
type GlobalSpecType_AnyDstAsn struct {
	AnyDstAsn *schema.Empty `protobuf:"bytes,51,opt,name=any_dst_asn,json=anyDstAsn,proto3,oneof" json:"any_dst_asn,omitempty"`
}
type GlobalSpecType_DstAsnList struct {
	DstAsnList *policy.AsnMatchList `protobuf:"bytes,52,opt,name=dst_asn_list,json=dstAsnList,proto3,oneof" json:"dst_asn_list,omitempty"`
}
type GlobalSpecType_DstAsnMatcher struct {
	DstAsnMatcher *policy.AsnMatcherType `protobuf:"bytes,53,opt,name=dst_asn_matcher,json=dstAsnMatcher,proto3,oneof" json:"dst_asn_matcher,omitempty"`
}

func (*GlobalSpecType_AnyClient) isGlobalSpecType_ClientChoice()         {}
func (*GlobalSpecType_ClientName) isGlobalSpecType_ClientChoice()        {}
func (*GlobalSpecType_ClientSelector) isGlobalSpecType_ClientChoice()    {}
func (*GlobalSpecType_ClientNameMatcher) isGlobalSpecType_ClientChoice() {}
func (*GlobalSpecType_AnyIp) isGlobalSpecType_IpChoice()                 {}
func (*GlobalSpecType_IpPrefixList) isGlobalSpecType_IpChoice()          {}
func (*GlobalSpecType_IpMatcher) isGlobalSpecType_IpChoice()             {}
func (*GlobalSpecType_AnyDstIp) isGlobalSpecType_DstIpChoice()           {}
func (*GlobalSpecType_DstIpPrefixList) isGlobalSpecType_DstIpChoice()    {}
func (*GlobalSpecType_DstIpMatcher) isGlobalSpecType_DstIpChoice()       {}
func (*GlobalSpecType_AnyAsn) isGlobalSpecType_AsnChoice()               {}
func (*GlobalSpecType_AsnList) isGlobalSpecType_AsnChoice()              {}
func (*GlobalSpecType_AsnMatcher) isGlobalSpecType_AsnChoice()           {}
func (*GlobalSpecType_AnyDstAsn) isGlobalSpecType_DstAsnChoice()         {}
func (*GlobalSpecType_DstAsnList) isGlobalSpecType_DstAsnChoice()        {}
func (*GlobalSpecType_DstAsnMatcher) isGlobalSpecType_DstAsnChoice()     {}

func (m *GlobalSpecType) GetClientChoice() isGlobalSpecType_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}
func (m *GlobalSpecType) GetIpChoice() isGlobalSpecType_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *GlobalSpecType) GetDstIpChoice() isGlobalSpecType_DstIpChoice {
	if m != nil {
		return m.DstIpChoice
	}
	return nil
}
func (m *GlobalSpecType) GetAsnChoice() isGlobalSpecType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *GlobalSpecType) GetDstAsnChoice() isGlobalSpecType_DstAsnChoice {
	if m != nil {
		return m.DstAsnChoice
	}
	return nil
}

func (m *GlobalSpecType) GetAction() policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return policy.DENY
}

func (m *GlobalSpecType) GetAnyClient() *schema.Empty {
	if x, ok := m.GetClientChoice().(*GlobalSpecType_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *GlobalSpecType) GetClientName() string {
	if x, ok := m.GetClientChoice().(*GlobalSpecType_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *GlobalSpecType) GetClientSelector() *schema.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*GlobalSpecType_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *GlobalSpecType) GetClientNameMatcher() *policy.MatcherType {
	if x, ok := m.GetClientChoice().(*GlobalSpecType_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetClientRole() *policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *GlobalSpecType) GetServerSelector() *schema.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *GlobalSpecType) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetPath() *policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *GlobalSpecType) GetHeaders() []*policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GlobalSpecType) GetQueryParams() []*policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *GlobalSpecType) GetHttpMethod() *policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *GlobalSpecType) GetAnyIp() *schema.Empty {
	if x, ok := m.GetIpChoice().(*GlobalSpecType_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *GlobalSpecType) GetIpPrefixList() *policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*GlobalSpecType_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *GlobalSpecType) GetIpMatcher() *policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*GlobalSpecType_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetAnyDstIp() *schema.Empty {
	if x, ok := m.GetDstIpChoice().(*GlobalSpecType_AnyDstIp); ok {
		return x.AnyDstIp
	}
	return nil
}

func (m *GlobalSpecType) GetDstIpPrefixList() *policy.PrefixMatchList {
	if x, ok := m.GetDstIpChoice().(*GlobalSpecType_DstIpPrefixList); ok {
		return x.DstIpPrefixList
	}
	return nil
}

func (m *GlobalSpecType) GetDstIpMatcher() *policy.IpMatcherType {
	if x, ok := m.GetDstIpChoice().(*GlobalSpecType_DstIpMatcher); ok {
		return x.DstIpMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetAnyAsn() *schema.Empty {
	if x, ok := m.GetAsnChoice().(*GlobalSpecType_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *GlobalSpecType) GetAsnList() *policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*GlobalSpecType_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *GlobalSpecType) GetAsnMatcher() *policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*GlobalSpecType_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetAnyDstAsn() *schema.Empty {
	if x, ok := m.GetDstAsnChoice().(*GlobalSpecType_AnyDstAsn); ok {
		return x.AnyDstAsn
	}
	return nil
}

func (m *GlobalSpecType) GetDstAsnList() *policy.AsnMatchList {
	if x, ok := m.GetDstAsnChoice().(*GlobalSpecType_DstAsnList); ok {
		return x.DstAsnList
	}
	return nil
}

func (m *GlobalSpecType) GetDstAsnMatcher() *policy.AsnMatcherType {
	if x, ok := m.GetDstAsnChoice().(*GlobalSpecType_DstAsnMatcher); ok {
		return x.DstAsnMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetApiGroupMatcher() *policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *GlobalSpecType) GetBodyMatcher() *policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetArgMatchers() []*policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *GlobalSpecType) GetCookieMatchers() []*policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *GlobalSpecType) GetWafAction() *policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *GlobalSpecType) GetDomainMatcher() *policy.MatcherType {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetRateLimiter() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *GlobalSpecType) GetVirtualHostMatcher() *policy.MatcherType {
	if m != nil {
		return m.VirtualHostMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetTlsFingerprintMatcher() *policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetForwardingClass() []*schema.ObjectRefType {
	if m != nil {
		return m.ForwardingClass
	}
	return nil
}

func (m *GlobalSpecType) GetMaliciousUserMitigationBypass() *schema.Empty {
	if m != nil {
		return m.MaliciousUserMitigationBypass
	}
	return nil
}

func (m *GlobalSpecType) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *GlobalSpecType) GetUrlMatcher() *policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetL4DestMatcher() *policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetChallengeAction() policy.ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return policy.DEFAULT_CHALLENGE
}

func (m *GlobalSpecType) GetGotoPolicy() []*schema.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_AnyClient)(nil),
		(*GlobalSpecType_ClientName)(nil),
		(*GlobalSpecType_ClientSelector)(nil),
		(*GlobalSpecType_ClientNameMatcher)(nil),
		(*GlobalSpecType_AnyIp)(nil),
		(*GlobalSpecType_IpPrefixList)(nil),
		(*GlobalSpecType_IpMatcher)(nil),
		(*GlobalSpecType_AnyDstIp)(nil),
		(*GlobalSpecType_DstIpPrefixList)(nil),
		(*GlobalSpecType_DstIpMatcher)(nil),
		(*GlobalSpecType_AnyAsn)(nil),
		(*GlobalSpecType_AsnList)(nil),
		(*GlobalSpecType_AsnMatcher)(nil),
		(*GlobalSpecType_AnyDstAsn)(nil),
		(*GlobalSpecType_DstAsnList)(nil),
		(*GlobalSpecType_DstAsnMatcher)(nil),
	}
}

// Create service policy rule
//
// x-displayName: "Create Service Policy Rule"
// Create service_policy_rule creates a new object in the storage backend for metadata.namespace.
type CreateSpecType struct {
	Action policy.RuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// Types that are valid to be assigned to ClientChoice:
	//	*CreateSpecType_AnyClient
	//	*CreateSpecType_ClientName
	//	*CreateSpecType_ClientSelector
	//	*CreateSpecType_ClientNameMatcher
	ClientChoice   isCreateSpecType_ClientChoice       `protobuf_oneof:"client_choice"`
	ClientRole     *policy.RoleMatcherType             `protobuf:"bytes,9,opt,name=client_role,json=clientRole,proto3" json:"client_role,omitempty"`
	ServerSelector *schema.LabelSelectorType           `protobuf:"bytes,45,opt,name=server_selector,json=serverSelector,proto3" json:"server_selector,omitempty"`
	LabelMatcher   *schema.LabelMatcherType            `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	Path           *policy.PathMatcherType             `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	Headers        []*policy.HeaderMatcherType         `protobuf:"bytes,6,rep,name=headers,proto3" json:"headers,omitempty"`
	QueryParams    []*policy.QueryParameterMatcherType `protobuf:"bytes,7,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	HttpMethod     *policy.HttpMethodMatcherType       `protobuf:"bytes,8,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	// Types that are valid to be assigned to IpChoice:
	//	*CreateSpecType_AnyIp
	//	*CreateSpecType_IpPrefixList
	//	*CreateSpecType_IpMatcher
	IpChoice isCreateSpecType_IpChoice `protobuf_oneof:"ip_choice"`
	// Types that are valid to be assigned to DstIpChoice:
	//	*CreateSpecType_AnyDstIp
	//	*CreateSpecType_DstIpPrefixList
	//	*CreateSpecType_DstIpMatcher
	DstIpChoice isCreateSpecType_DstIpChoice `protobuf_oneof:"dst_ip_choice"`
	// Types that are valid to be assigned to AsnChoice:
	//	*CreateSpecType_AnyAsn
	//	*CreateSpecType_AsnList
	//	*CreateSpecType_AsnMatcher
	AsnChoice isCreateSpecType_AsnChoice `protobuf_oneof:"asn_choice"`
	// Types that are valid to be assigned to DstAsnChoice:
	//	*CreateSpecType_AnyDstAsn
	//	*CreateSpecType_DstAsnList
	//	*CreateSpecType_DstAsnMatcher
	DstAsnChoice                  isCreateSpecType_DstAsnChoice     `protobuf_oneof:"dst_asn_choice"`
	ApiGroupMatcher               *policy.StringMatcherType         `protobuf:"bytes,14,opt,name=api_group_matcher,json=apiGroupMatcher,proto3" json:"api_group_matcher,omitempty"`
	PortMatcher                   *policy.PortMatcherType           `protobuf:"bytes,15,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	ExpirationTimestamp           *types.Timestamp                  `protobuf:"bytes,16,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	BodyMatcher                   *policy.MatcherType               `protobuf:"bytes,21,opt,name=body_matcher,json=bodyMatcher,proto3" json:"body_matcher,omitempty"`
	ArgMatchers                   []*policy.ArgMatcherType          `protobuf:"bytes,18,rep,name=arg_matchers,json=argMatchers,proto3" json:"arg_matchers,omitempty"`
	CookieMatchers                []*policy.CookieMatcherType       `protobuf:"bytes,19,rep,name=cookie_matchers,json=cookieMatchers,proto3" json:"cookie_matchers,omitempty"`
	WafAction                     *policy.WafAction                 `protobuf:"bytes,20,opt,name=waf_action,json=wafAction,proto3" json:"waf_action,omitempty"`
	DomainMatcher                 *policy.MatcherTypeBasic          `protobuf:"bytes,22,opt,name=domain_matcher,json=domainMatcher,proto3" json:"domain_matcher,omitempty"`
	RateLimiter                   []*schema.ObjectRefType           `protobuf:"bytes,23,rep,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty"`
	VirtualHostMatcher            *policy.MatcherTypeBasic          `protobuf:"bytes,24,opt,name=virtual_host_matcher,json=virtualHostMatcher,proto3" json:"virtual_host_matcher,omitempty"`
	TlsFingerprintMatcher         *policy.TlsFingerprintMatcherType `protobuf:"bytes,25,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher,proto3" json:"tls_fingerprint_matcher,omitempty"`
	MaliciousUserMitigationBypass *schema.Empty                     `protobuf:"bytes,28,opt,name=malicious_user_mitigation_bypass,json=maliciousUserMitigationBypass,proto3" json:"malicious_user_mitigation_bypass,omitempty"`
	Scheme                        []string                          `protobuf:"bytes,38,rep,name=scheme,proto3" json:"scheme,omitempty"`
	UrlMatcher                    *policy.URLMatcherType            `protobuf:"bytes,39,opt,name=url_matcher,json=urlMatcher,proto3" json:"url_matcher,omitempty"`
	L4DestMatcher                 *policy.L4DestMatcherType         `protobuf:"bytes,44,opt,name=l4_dest_matcher,json=l4DestMatcher,proto3" json:"l4_dest_matcher,omitempty"`
	ChallengeAction               policy.ChallengeAction            `protobuf:"varint,54,opt,name=challenge_action,json=challengeAction,proto3,enum=ves.io.schema.policy.ChallengeAction" json:"challenge_action,omitempty"`
	GotoPolicy                    []*schema.ObjectRefType           `protobuf:"bytes,55,rep,name=goto_policy,json=gotoPolicy,proto3" json:"goto_policy,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_771e54eb594e8c4b, []int{1}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_ClientChoice interface {
	isCreateSpecType_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_IpChoice interface {
	isCreateSpecType_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_DstIpChoice interface {
	isCreateSpecType_DstIpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_AsnChoice interface {
	isCreateSpecType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_DstAsnChoice interface {
	isCreateSpecType_DstAsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AnyClient struct {
	AnyClient *schema.Empty `protobuf:"bytes,37,opt,name=any_client,json=anyClient,proto3,oneof" json:"any_client,omitempty"`
}
type CreateSpecType_ClientName struct {
	ClientName string `protobuf:"bytes,2,opt,name=client_name,json=clientName,proto3,oneof" json:"client_name,omitempty"`
}
type CreateSpecType_ClientSelector struct {
	ClientSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=client_selector,json=clientSelector,proto3,oneof" json:"client_selector,omitempty"`
}
type CreateSpecType_ClientNameMatcher struct {
	ClientNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,10,opt,name=client_name_matcher,json=clientNameMatcher,proto3,oneof" json:"client_name_matcher,omitempty"`
}
type CreateSpecType_AnyIp struct {
	AnyIp *schema.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,proto3,oneof" json:"any_ip,omitempty"`
}
type CreateSpecType_IpPrefixList struct {
	IpPrefixList *policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,proto3,oneof" json:"ip_prefix_list,omitempty"`
}
type CreateSpecType_IpMatcher struct {
	IpMatcher *policy.IpMatcherType `protobuf:"bytes,12,opt,name=ip_matcher,json=ipMatcher,proto3,oneof" json:"ip_matcher,omitempty"`
}
type CreateSpecType_AnyDstIp struct {
	AnyDstIp *schema.Empty `protobuf:"bytes,41,opt,name=any_dst_ip,json=anyDstIp,proto3,oneof" json:"any_dst_ip,omitempty"`
}
type CreateSpecType_DstIpPrefixList struct {
	DstIpPrefixList *policy.PrefixMatchList `protobuf:"bytes,42,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,proto3,oneof" json:"dst_ip_prefix_list,omitempty"`
}
type CreateSpecType_DstIpMatcher struct {
	DstIpMatcher *policy.IpMatcherType `protobuf:"bytes,43,opt,name=dst_ip_matcher,json=dstIpMatcher,proto3,oneof" json:"dst_ip_matcher,omitempty"`
}
type CreateSpecType_AnyAsn struct {
	AnyAsn *schema.Empty `protobuf:"bytes,34,opt,name=any_asn,json=anyAsn,proto3,oneof" json:"any_asn,omitempty"`
}
type CreateSpecType_AsnList struct {
	AsnList *policy.AsnMatchList `protobuf:"bytes,35,opt,name=asn_list,json=asnList,proto3,oneof" json:"asn_list,omitempty"`
}
type CreateSpecType_AsnMatcher struct {
	AsnMatcher *policy.AsnMatcherType `protobuf:"bytes,13,opt,name=asn_matcher,json=asnMatcher,proto3,oneof" json:"asn_matcher,omitempty"`
}
type CreateSpecType_AnyDstAsn struct {
	AnyDstAsn *schema.Empty `protobuf:"bytes,51,opt,name=any_dst_asn,json=anyDstAsn,proto3,oneof" json:"any_dst_asn,omitempty"`
}
type CreateSpecType_DstAsnList struct {
	DstAsnList *policy.AsnMatchList `protobuf:"bytes,52,opt,name=dst_asn_list,json=dstAsnList,proto3,oneof" json:"dst_asn_list,omitempty"`
}
type CreateSpecType_DstAsnMatcher struct {
	DstAsnMatcher *policy.AsnMatcherType `protobuf:"bytes,53,opt,name=dst_asn_matcher,json=dstAsnMatcher,proto3,oneof" json:"dst_asn_matcher,omitempty"`
}

func (*CreateSpecType_AnyClient) isCreateSpecType_ClientChoice()         {}
func (*CreateSpecType_ClientName) isCreateSpecType_ClientChoice()        {}
func (*CreateSpecType_ClientSelector) isCreateSpecType_ClientChoice()    {}
func (*CreateSpecType_ClientNameMatcher) isCreateSpecType_ClientChoice() {}
func (*CreateSpecType_AnyIp) isCreateSpecType_IpChoice()                 {}
func (*CreateSpecType_IpPrefixList) isCreateSpecType_IpChoice()          {}
func (*CreateSpecType_IpMatcher) isCreateSpecType_IpChoice()             {}
func (*CreateSpecType_AnyDstIp) isCreateSpecType_DstIpChoice()           {}
func (*CreateSpecType_DstIpPrefixList) isCreateSpecType_DstIpChoice()    {}
func (*CreateSpecType_DstIpMatcher) isCreateSpecType_DstIpChoice()       {}
func (*CreateSpecType_AnyAsn) isCreateSpecType_AsnChoice()               {}
func (*CreateSpecType_AsnList) isCreateSpecType_AsnChoice()              {}
func (*CreateSpecType_AsnMatcher) isCreateSpecType_AsnChoice()           {}
func (*CreateSpecType_AnyDstAsn) isCreateSpecType_DstAsnChoice()         {}
func (*CreateSpecType_DstAsnList) isCreateSpecType_DstAsnChoice()        {}
func (*CreateSpecType_DstAsnMatcher) isCreateSpecType_DstAsnChoice()     {}

func (m *CreateSpecType) GetClientChoice() isCreateSpecType_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}
func (m *CreateSpecType) GetIpChoice() isCreateSpecType_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *CreateSpecType) GetDstIpChoice() isCreateSpecType_DstIpChoice {
	if m != nil {
		return m.DstIpChoice
	}
	return nil
}
func (m *CreateSpecType) GetAsnChoice() isCreateSpecType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *CreateSpecType) GetDstAsnChoice() isCreateSpecType_DstAsnChoice {
	if m != nil {
		return m.DstAsnChoice
	}
	return nil
}

func (m *CreateSpecType) GetAction() policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return policy.DENY
}

func (m *CreateSpecType) GetAnyClient() *schema.Empty {
	if x, ok := m.GetClientChoice().(*CreateSpecType_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *CreateSpecType) GetClientName() string {
	if x, ok := m.GetClientChoice().(*CreateSpecType_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *CreateSpecType) GetClientSelector() *schema.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*CreateSpecType_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *CreateSpecType) GetClientNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetClientChoice().(*CreateSpecType_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *CreateSpecType) GetClientRole() *policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *CreateSpecType) GetServerSelector() *schema.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *CreateSpecType) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *CreateSpecType) GetPath() *policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *CreateSpecType) GetHeaders() []*policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *CreateSpecType) GetQueryParams() []*policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *CreateSpecType) GetHttpMethod() *policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *CreateSpecType) GetAnyIp() *schema.Empty {
	if x, ok := m.GetIpChoice().(*CreateSpecType_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *CreateSpecType) GetIpPrefixList() *policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*CreateSpecType_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *CreateSpecType) GetIpMatcher() *policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*CreateSpecType_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAnyDstIp() *schema.Empty {
	if x, ok := m.GetDstIpChoice().(*CreateSpecType_AnyDstIp); ok {
		return x.AnyDstIp
	}
	return nil
}

func (m *CreateSpecType) GetDstIpPrefixList() *policy.PrefixMatchList {
	if x, ok := m.GetDstIpChoice().(*CreateSpecType_DstIpPrefixList); ok {
		return x.DstIpPrefixList
	}
	return nil
}

func (m *CreateSpecType) GetDstIpMatcher() *policy.IpMatcherType {
	if x, ok := m.GetDstIpChoice().(*CreateSpecType_DstIpMatcher); ok {
		return x.DstIpMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAnyAsn() *schema.Empty {
	if x, ok := m.GetAsnChoice().(*CreateSpecType_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *CreateSpecType) GetAsnList() *policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*CreateSpecType_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *CreateSpecType) GetAsnMatcher() *policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*CreateSpecType_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *CreateSpecType) GetAnyDstAsn() *schema.Empty {
	if x, ok := m.GetDstAsnChoice().(*CreateSpecType_AnyDstAsn); ok {
		return x.AnyDstAsn
	}
	return nil
}

func (m *CreateSpecType) GetDstAsnList() *policy.AsnMatchList {
	if x, ok := m.GetDstAsnChoice().(*CreateSpecType_DstAsnList); ok {
		return x.DstAsnList
	}
	return nil
}

func (m *CreateSpecType) GetDstAsnMatcher() *policy.AsnMatcherType {
	if x, ok := m.GetDstAsnChoice().(*CreateSpecType_DstAsnMatcher); ok {
		return x.DstAsnMatcher
	}
	return nil
}

func (m *CreateSpecType) GetApiGroupMatcher() *policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *CreateSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *CreateSpecType) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *CreateSpecType) GetBodyMatcher() *policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *CreateSpecType) GetArgMatchers() []*policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *CreateSpecType) GetCookieMatchers() []*policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *CreateSpecType) GetWafAction() *policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *CreateSpecType) GetDomainMatcher() *policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *CreateSpecType) GetRateLimiter() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *CreateSpecType) GetVirtualHostMatcher() *policy.MatcherTypeBasic {
	if m != nil {
		return m.VirtualHostMatcher
	}
	return nil
}

func (m *CreateSpecType) GetTlsFingerprintMatcher() *policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *CreateSpecType) GetMaliciousUserMitigationBypass() *schema.Empty {
	if m != nil {
		return m.MaliciousUserMitigationBypass
	}
	return nil
}

func (m *CreateSpecType) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *CreateSpecType) GetUrlMatcher() *policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *CreateSpecType) GetL4DestMatcher() *policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *CreateSpecType) GetChallengeAction() policy.ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return policy.DEFAULT_CHALLENGE
}

func (m *CreateSpecType) GetGotoPolicy() []*schema.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_AnyClient)(nil),
		(*CreateSpecType_ClientName)(nil),
		(*CreateSpecType_ClientSelector)(nil),
		(*CreateSpecType_ClientNameMatcher)(nil),
		(*CreateSpecType_AnyIp)(nil),
		(*CreateSpecType_IpPrefixList)(nil),
		(*CreateSpecType_IpMatcher)(nil),
		(*CreateSpecType_AnyDstIp)(nil),
		(*CreateSpecType_DstIpPrefixList)(nil),
		(*CreateSpecType_DstIpMatcher)(nil),
		(*CreateSpecType_AnyAsn)(nil),
		(*CreateSpecType_AsnList)(nil),
		(*CreateSpecType_AsnMatcher)(nil),
		(*CreateSpecType_AnyDstAsn)(nil),
		(*CreateSpecType_DstAsnList)(nil),
		(*CreateSpecType_DstAsnMatcher)(nil),
	}
}

// Replace service policy rule
//
// x-displayName: "Replace Service Policy Rule"
// Replace service_policy_rule replaces an existing object in the storage backend for metadata.namespace.
type ReplaceSpecType struct {
	Action policy.RuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// Types that are valid to be assigned to ClientChoice:
	//	*ReplaceSpecType_AnyClient
	//	*ReplaceSpecType_ClientName
	//	*ReplaceSpecType_ClientSelector
	//	*ReplaceSpecType_ClientNameMatcher
	ClientChoice   isReplaceSpecType_ClientChoice      `protobuf_oneof:"client_choice"`
	ClientRole     *policy.RoleMatcherType             `protobuf:"bytes,9,opt,name=client_role,json=clientRole,proto3" json:"client_role,omitempty"`
	ServerSelector *schema.LabelSelectorType           `protobuf:"bytes,45,opt,name=server_selector,json=serverSelector,proto3" json:"server_selector,omitempty"`
	LabelMatcher   *schema.LabelMatcherType            `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	Path           *policy.PathMatcherType             `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	Headers        []*policy.HeaderMatcherType         `protobuf:"bytes,6,rep,name=headers,proto3" json:"headers,omitempty"`
	QueryParams    []*policy.QueryParameterMatcherType `protobuf:"bytes,7,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	HttpMethod     *policy.HttpMethodMatcherType       `protobuf:"bytes,8,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	// Types that are valid to be assigned to IpChoice:
	//	*ReplaceSpecType_AnyIp
	//	*ReplaceSpecType_IpPrefixList
	//	*ReplaceSpecType_IpMatcher
	IpChoice isReplaceSpecType_IpChoice `protobuf_oneof:"ip_choice"`
	// Types that are valid to be assigned to DstIpChoice:
	//	*ReplaceSpecType_AnyDstIp
	//	*ReplaceSpecType_DstIpPrefixList
	//	*ReplaceSpecType_DstIpMatcher
	DstIpChoice isReplaceSpecType_DstIpChoice `protobuf_oneof:"dst_ip_choice"`
	// Types that are valid to be assigned to AsnChoice:
	//	*ReplaceSpecType_AnyAsn
	//	*ReplaceSpecType_AsnList
	//	*ReplaceSpecType_AsnMatcher
	AsnChoice isReplaceSpecType_AsnChoice `protobuf_oneof:"asn_choice"`
	// Types that are valid to be assigned to DstAsnChoice:
	//	*ReplaceSpecType_AnyDstAsn
	//	*ReplaceSpecType_DstAsnList
	//	*ReplaceSpecType_DstAsnMatcher
	DstAsnChoice                  isReplaceSpecType_DstAsnChoice    `protobuf_oneof:"dst_asn_choice"`
	ApiGroupMatcher               *policy.StringMatcherType         `protobuf:"bytes,14,opt,name=api_group_matcher,json=apiGroupMatcher,proto3" json:"api_group_matcher,omitempty"`
	PortMatcher                   *policy.PortMatcherType           `protobuf:"bytes,15,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	ExpirationTimestamp           *types.Timestamp                  `protobuf:"bytes,16,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	BodyMatcher                   *policy.MatcherType               `protobuf:"bytes,21,opt,name=body_matcher,json=bodyMatcher,proto3" json:"body_matcher,omitempty"`
	ArgMatchers                   []*policy.ArgMatcherType          `protobuf:"bytes,18,rep,name=arg_matchers,json=argMatchers,proto3" json:"arg_matchers,omitempty"`
	CookieMatchers                []*policy.CookieMatcherType       `protobuf:"bytes,19,rep,name=cookie_matchers,json=cookieMatchers,proto3" json:"cookie_matchers,omitempty"`
	WafAction                     *policy.WafAction                 `protobuf:"bytes,20,opt,name=waf_action,json=wafAction,proto3" json:"waf_action,omitempty"`
	DomainMatcher                 *policy.MatcherTypeBasic          `protobuf:"bytes,22,opt,name=domain_matcher,json=domainMatcher,proto3" json:"domain_matcher,omitempty"`
	RateLimiter                   []*schema.ObjectRefType           `protobuf:"bytes,23,rep,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty"`
	VirtualHostMatcher            *policy.MatcherTypeBasic          `protobuf:"bytes,24,opt,name=virtual_host_matcher,json=virtualHostMatcher,proto3" json:"virtual_host_matcher,omitempty"`
	TlsFingerprintMatcher         *policy.TlsFingerprintMatcherType `protobuf:"bytes,25,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher,proto3" json:"tls_fingerprint_matcher,omitempty"`
	MaliciousUserMitigationBypass *schema.Empty                     `protobuf:"bytes,28,opt,name=malicious_user_mitigation_bypass,json=maliciousUserMitigationBypass,proto3" json:"malicious_user_mitigation_bypass,omitempty"`
	Scheme                        []string                          `protobuf:"bytes,38,rep,name=scheme,proto3" json:"scheme,omitempty"`
	UrlMatcher                    *policy.URLMatcherType            `protobuf:"bytes,39,opt,name=url_matcher,json=urlMatcher,proto3" json:"url_matcher,omitempty"`
	L4DestMatcher                 *policy.L4DestMatcherType         `protobuf:"bytes,44,opt,name=l4_dest_matcher,json=l4DestMatcher,proto3" json:"l4_dest_matcher,omitempty"`
	ChallengeAction               policy.ChallengeAction            `protobuf:"varint,54,opt,name=challenge_action,json=challengeAction,proto3,enum=ves.io.schema.policy.ChallengeAction" json:"challenge_action,omitempty"`
	GotoPolicy                    []*schema.ObjectRefType           `protobuf:"bytes,55,rep,name=goto_policy,json=gotoPolicy,proto3" json:"goto_policy,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_771e54eb594e8c4b, []int{2}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_ClientChoice interface {
	isReplaceSpecType_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_IpChoice interface {
	isReplaceSpecType_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_DstIpChoice interface {
	isReplaceSpecType_DstIpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_AsnChoice interface {
	isReplaceSpecType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_DstAsnChoice interface {
	isReplaceSpecType_DstAsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AnyClient struct {
	AnyClient *schema.Empty `protobuf:"bytes,37,opt,name=any_client,json=anyClient,proto3,oneof" json:"any_client,omitempty"`
}
type ReplaceSpecType_ClientName struct {
	ClientName string `protobuf:"bytes,2,opt,name=client_name,json=clientName,proto3,oneof" json:"client_name,omitempty"`
}
type ReplaceSpecType_ClientSelector struct {
	ClientSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=client_selector,json=clientSelector,proto3,oneof" json:"client_selector,omitempty"`
}
type ReplaceSpecType_ClientNameMatcher struct {
	ClientNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,10,opt,name=client_name_matcher,json=clientNameMatcher,proto3,oneof" json:"client_name_matcher,omitempty"`
}
type ReplaceSpecType_AnyIp struct {
	AnyIp *schema.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,proto3,oneof" json:"any_ip,omitempty"`
}
type ReplaceSpecType_IpPrefixList struct {
	IpPrefixList *policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,proto3,oneof" json:"ip_prefix_list,omitempty"`
}
type ReplaceSpecType_IpMatcher struct {
	IpMatcher *policy.IpMatcherType `protobuf:"bytes,12,opt,name=ip_matcher,json=ipMatcher,proto3,oneof" json:"ip_matcher,omitempty"`
}
type ReplaceSpecType_AnyDstIp struct {
	AnyDstIp *schema.Empty `protobuf:"bytes,41,opt,name=any_dst_ip,json=anyDstIp,proto3,oneof" json:"any_dst_ip,omitempty"`
}
type ReplaceSpecType_DstIpPrefixList struct {
	DstIpPrefixList *policy.PrefixMatchList `protobuf:"bytes,42,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,proto3,oneof" json:"dst_ip_prefix_list,omitempty"`
}
type ReplaceSpecType_DstIpMatcher struct {
	DstIpMatcher *policy.IpMatcherType `protobuf:"bytes,43,opt,name=dst_ip_matcher,json=dstIpMatcher,proto3,oneof" json:"dst_ip_matcher,omitempty"`
}
type ReplaceSpecType_AnyAsn struct {
	AnyAsn *schema.Empty `protobuf:"bytes,34,opt,name=any_asn,json=anyAsn,proto3,oneof" json:"any_asn,omitempty"`
}
type ReplaceSpecType_AsnList struct {
	AsnList *policy.AsnMatchList `protobuf:"bytes,35,opt,name=asn_list,json=asnList,proto3,oneof" json:"asn_list,omitempty"`
}
type ReplaceSpecType_AsnMatcher struct {
	AsnMatcher *policy.AsnMatcherType `protobuf:"bytes,13,opt,name=asn_matcher,json=asnMatcher,proto3,oneof" json:"asn_matcher,omitempty"`
}
type ReplaceSpecType_AnyDstAsn struct {
	AnyDstAsn *schema.Empty `protobuf:"bytes,51,opt,name=any_dst_asn,json=anyDstAsn,proto3,oneof" json:"any_dst_asn,omitempty"`
}
type ReplaceSpecType_DstAsnList struct {
	DstAsnList *policy.AsnMatchList `protobuf:"bytes,52,opt,name=dst_asn_list,json=dstAsnList,proto3,oneof" json:"dst_asn_list,omitempty"`
}
type ReplaceSpecType_DstAsnMatcher struct {
	DstAsnMatcher *policy.AsnMatcherType `protobuf:"bytes,53,opt,name=dst_asn_matcher,json=dstAsnMatcher,proto3,oneof" json:"dst_asn_matcher,omitempty"`
}

func (*ReplaceSpecType_AnyClient) isReplaceSpecType_ClientChoice()         {}
func (*ReplaceSpecType_ClientName) isReplaceSpecType_ClientChoice()        {}
func (*ReplaceSpecType_ClientSelector) isReplaceSpecType_ClientChoice()    {}
func (*ReplaceSpecType_ClientNameMatcher) isReplaceSpecType_ClientChoice() {}
func (*ReplaceSpecType_AnyIp) isReplaceSpecType_IpChoice()                 {}
func (*ReplaceSpecType_IpPrefixList) isReplaceSpecType_IpChoice()          {}
func (*ReplaceSpecType_IpMatcher) isReplaceSpecType_IpChoice()             {}
func (*ReplaceSpecType_AnyDstIp) isReplaceSpecType_DstIpChoice()           {}
func (*ReplaceSpecType_DstIpPrefixList) isReplaceSpecType_DstIpChoice()    {}
func (*ReplaceSpecType_DstIpMatcher) isReplaceSpecType_DstIpChoice()       {}
func (*ReplaceSpecType_AnyAsn) isReplaceSpecType_AsnChoice()               {}
func (*ReplaceSpecType_AsnList) isReplaceSpecType_AsnChoice()              {}
func (*ReplaceSpecType_AsnMatcher) isReplaceSpecType_AsnChoice()           {}
func (*ReplaceSpecType_AnyDstAsn) isReplaceSpecType_DstAsnChoice()         {}
func (*ReplaceSpecType_DstAsnList) isReplaceSpecType_DstAsnChoice()        {}
func (*ReplaceSpecType_DstAsnMatcher) isReplaceSpecType_DstAsnChoice()     {}

func (m *ReplaceSpecType) GetClientChoice() isReplaceSpecType_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetIpChoice() isReplaceSpecType_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetDstIpChoice() isReplaceSpecType_DstIpChoice {
	if m != nil {
		return m.DstIpChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetAsnChoice() isReplaceSpecType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *ReplaceSpecType) GetDstAsnChoice() isReplaceSpecType_DstAsnChoice {
	if m != nil {
		return m.DstAsnChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetAction() policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return policy.DENY
}

func (m *ReplaceSpecType) GetAnyClient() *schema.Empty {
	if x, ok := m.GetClientChoice().(*ReplaceSpecType_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *ReplaceSpecType) GetClientName() string {
	if x, ok := m.GetClientChoice().(*ReplaceSpecType_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *ReplaceSpecType) GetClientSelector() *schema.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*ReplaceSpecType_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetClientNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetClientChoice().(*ReplaceSpecType_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetClientRole() *policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *ReplaceSpecType) GetServerSelector() *schema.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetPath() *policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *ReplaceSpecType) GetHeaders() []*policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *ReplaceSpecType) GetQueryParams() []*policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *ReplaceSpecType) GetHttpMethod() *policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *ReplaceSpecType) GetAnyIp() *schema.Empty {
	if x, ok := m.GetIpChoice().(*ReplaceSpecType_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *ReplaceSpecType) GetIpPrefixList() *policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*ReplaceSpecType_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *ReplaceSpecType) GetIpMatcher() *policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*ReplaceSpecType_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAnyDstIp() *schema.Empty {
	if x, ok := m.GetDstIpChoice().(*ReplaceSpecType_AnyDstIp); ok {
		return x.AnyDstIp
	}
	return nil
}

func (m *ReplaceSpecType) GetDstIpPrefixList() *policy.PrefixMatchList {
	if x, ok := m.GetDstIpChoice().(*ReplaceSpecType_DstIpPrefixList); ok {
		return x.DstIpPrefixList
	}
	return nil
}

func (m *ReplaceSpecType) GetDstIpMatcher() *policy.IpMatcherType {
	if x, ok := m.GetDstIpChoice().(*ReplaceSpecType_DstIpMatcher); ok {
		return x.DstIpMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAnyAsn() *schema.Empty {
	if x, ok := m.GetAsnChoice().(*ReplaceSpecType_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *ReplaceSpecType) GetAsnList() *policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*ReplaceSpecType_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *ReplaceSpecType) GetAsnMatcher() *policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*ReplaceSpecType_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetAnyDstAsn() *schema.Empty {
	if x, ok := m.GetDstAsnChoice().(*ReplaceSpecType_AnyDstAsn); ok {
		return x.AnyDstAsn
	}
	return nil
}

func (m *ReplaceSpecType) GetDstAsnList() *policy.AsnMatchList {
	if x, ok := m.GetDstAsnChoice().(*ReplaceSpecType_DstAsnList); ok {
		return x.DstAsnList
	}
	return nil
}

func (m *ReplaceSpecType) GetDstAsnMatcher() *policy.AsnMatcherType {
	if x, ok := m.GetDstAsnChoice().(*ReplaceSpecType_DstAsnMatcher); ok {
		return x.DstAsnMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetApiGroupMatcher() *policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *ReplaceSpecType) GetBodyMatcher() *policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetArgMatchers() []*policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *ReplaceSpecType) GetCookieMatchers() []*policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *ReplaceSpecType) GetWafAction() *policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *ReplaceSpecType) GetDomainMatcher() *policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetRateLimiter() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *ReplaceSpecType) GetVirtualHostMatcher() *policy.MatcherTypeBasic {
	if m != nil {
		return m.VirtualHostMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetTlsFingerprintMatcher() *policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetMaliciousUserMitigationBypass() *schema.Empty {
	if m != nil {
		return m.MaliciousUserMitigationBypass
	}
	return nil
}

func (m *ReplaceSpecType) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *ReplaceSpecType) GetUrlMatcher() *policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetL4DestMatcher() *policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetChallengeAction() policy.ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return policy.DEFAULT_CHALLENGE
}

func (m *ReplaceSpecType) GetGotoPolicy() []*schema.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_AnyClient)(nil),
		(*ReplaceSpecType_ClientName)(nil),
		(*ReplaceSpecType_ClientSelector)(nil),
		(*ReplaceSpecType_ClientNameMatcher)(nil),
		(*ReplaceSpecType_AnyIp)(nil),
		(*ReplaceSpecType_IpPrefixList)(nil),
		(*ReplaceSpecType_IpMatcher)(nil),
		(*ReplaceSpecType_AnyDstIp)(nil),
		(*ReplaceSpecType_DstIpPrefixList)(nil),
		(*ReplaceSpecType_DstIpMatcher)(nil),
		(*ReplaceSpecType_AnyAsn)(nil),
		(*ReplaceSpecType_AsnList)(nil),
		(*ReplaceSpecType_AsnMatcher)(nil),
		(*ReplaceSpecType_AnyDstAsn)(nil),
		(*ReplaceSpecType_DstAsnList)(nil),
		(*ReplaceSpecType_DstAsnMatcher)(nil),
	}
}

// Get service policy rule
//
// x-displayName: "Get Service Policy Rule"
// Get service_policy_rule reads a given object from storage backend for metadata.namespace.
type GetSpecType struct {
	Action policy.RuleAction `protobuf:"varint,1,opt,name=action,proto3,enum=ves.io.schema.policy.RuleAction" json:"action,omitempty"`
	// Types that are valid to be assigned to ClientChoice:
	//	*GetSpecType_AnyClient
	//	*GetSpecType_ClientName
	//	*GetSpecType_ClientSelector
	//	*GetSpecType_ClientNameMatcher
	ClientChoice   isGetSpecType_ClientChoice          `protobuf_oneof:"client_choice"`
	ClientRole     *policy.RoleMatcherType             `protobuf:"bytes,9,opt,name=client_role,json=clientRole,proto3" json:"client_role,omitempty"`
	ServerSelector *schema.LabelSelectorType           `protobuf:"bytes,45,opt,name=server_selector,json=serverSelector,proto3" json:"server_selector,omitempty"`
	LabelMatcher   *schema.LabelMatcherType            `protobuf:"bytes,4,opt,name=label_matcher,json=labelMatcher,proto3" json:"label_matcher,omitempty"`
	Path           *policy.PathMatcherType             `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	Headers        []*policy.HeaderMatcherType         `protobuf:"bytes,6,rep,name=headers,proto3" json:"headers,omitempty"`
	QueryParams    []*policy.QueryParameterMatcherType `protobuf:"bytes,7,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	HttpMethod     *policy.HttpMethodMatcherType       `protobuf:"bytes,8,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	// Types that are valid to be assigned to IpChoice:
	//	*GetSpecType_AnyIp
	//	*GetSpecType_IpPrefixList
	//	*GetSpecType_IpMatcher
	IpChoice isGetSpecType_IpChoice `protobuf_oneof:"ip_choice"`
	// Types that are valid to be assigned to DstIpChoice:
	//	*GetSpecType_AnyDstIp
	//	*GetSpecType_DstIpPrefixList
	//	*GetSpecType_DstIpMatcher
	DstIpChoice isGetSpecType_DstIpChoice `protobuf_oneof:"dst_ip_choice"`
	// Types that are valid to be assigned to AsnChoice:
	//	*GetSpecType_AnyAsn
	//	*GetSpecType_AsnList
	//	*GetSpecType_AsnMatcher
	AsnChoice isGetSpecType_AsnChoice `protobuf_oneof:"asn_choice"`
	// Types that are valid to be assigned to DstAsnChoice:
	//	*GetSpecType_AnyDstAsn
	//	*GetSpecType_DstAsnList
	//	*GetSpecType_DstAsnMatcher
	DstAsnChoice                  isGetSpecType_DstAsnChoice        `protobuf_oneof:"dst_asn_choice"`
	ApiGroupMatcher               *policy.StringMatcherType         `protobuf:"bytes,14,opt,name=api_group_matcher,json=apiGroupMatcher,proto3" json:"api_group_matcher,omitempty"`
	PortMatcher                   *policy.PortMatcherType           `protobuf:"bytes,15,opt,name=port_matcher,json=portMatcher,proto3" json:"port_matcher,omitempty"`
	ExpirationTimestamp           *types.Timestamp                  `protobuf:"bytes,16,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	BodyMatcher                   *policy.MatcherType               `protobuf:"bytes,21,opt,name=body_matcher,json=bodyMatcher,proto3" json:"body_matcher,omitempty"`
	ArgMatchers                   []*policy.ArgMatcherType          `protobuf:"bytes,18,rep,name=arg_matchers,json=argMatchers,proto3" json:"arg_matchers,omitempty"`
	CookieMatchers                []*policy.CookieMatcherType       `protobuf:"bytes,19,rep,name=cookie_matchers,json=cookieMatchers,proto3" json:"cookie_matchers,omitempty"`
	WafAction                     *policy.WafAction                 `protobuf:"bytes,20,opt,name=waf_action,json=wafAction,proto3" json:"waf_action,omitempty"`
	DomainMatcher                 *policy.MatcherTypeBasic          `protobuf:"bytes,22,opt,name=domain_matcher,json=domainMatcher,proto3" json:"domain_matcher,omitempty"`
	RateLimiter                   []*schema.ObjectRefType           `protobuf:"bytes,23,rep,name=rate_limiter,json=rateLimiter,proto3" json:"rate_limiter,omitempty"`
	VirtualHostMatcher            *policy.MatcherTypeBasic          `protobuf:"bytes,24,opt,name=virtual_host_matcher,json=virtualHostMatcher,proto3" json:"virtual_host_matcher,omitempty"`
	TlsFingerprintMatcher         *policy.TlsFingerprintMatcherType `protobuf:"bytes,25,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher,proto3" json:"tls_fingerprint_matcher,omitempty"`
	MaliciousUserMitigationBypass *schema.Empty                     `protobuf:"bytes,28,opt,name=malicious_user_mitigation_bypass,json=maliciousUserMitigationBypass,proto3" json:"malicious_user_mitigation_bypass,omitempty"`
	Scheme                        []string                          `protobuf:"bytes,38,rep,name=scheme,proto3" json:"scheme,omitempty"`
	UrlMatcher                    *policy.URLMatcherType            `protobuf:"bytes,39,opt,name=url_matcher,json=urlMatcher,proto3" json:"url_matcher,omitempty"`
	L4DestMatcher                 *policy.L4DestMatcherType         `protobuf:"bytes,44,opt,name=l4_dest_matcher,json=l4DestMatcher,proto3" json:"l4_dest_matcher,omitempty"`
	ChallengeAction               policy.ChallengeAction            `protobuf:"varint,54,opt,name=challenge_action,json=challengeAction,proto3,enum=ves.io.schema.policy.ChallengeAction" json:"challenge_action,omitempty"`
	GotoPolicy                    []*schema.ObjectRefType           `protobuf:"bytes,55,rep,name=goto_policy,json=gotoPolicy,proto3" json:"goto_policy,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_771e54eb594e8c4b, []int{3}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_ClientChoice interface {
	isGetSpecType_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_IpChoice interface {
	isGetSpecType_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_DstIpChoice interface {
	isGetSpecType_DstIpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_AsnChoice interface {
	isGetSpecType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_DstAsnChoice interface {
	isGetSpecType_DstAsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AnyClient struct {
	AnyClient *schema.Empty `protobuf:"bytes,37,opt,name=any_client,json=anyClient,proto3,oneof" json:"any_client,omitempty"`
}
type GetSpecType_ClientName struct {
	ClientName string `protobuf:"bytes,2,opt,name=client_name,json=clientName,proto3,oneof" json:"client_name,omitempty"`
}
type GetSpecType_ClientSelector struct {
	ClientSelector *schema.LabelSelectorType `protobuf:"bytes,3,opt,name=client_selector,json=clientSelector,proto3,oneof" json:"client_selector,omitempty"`
}
type GetSpecType_ClientNameMatcher struct {
	ClientNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,10,opt,name=client_name_matcher,json=clientNameMatcher,proto3,oneof" json:"client_name_matcher,omitempty"`
}
type GetSpecType_AnyIp struct {
	AnyIp *schema.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,proto3,oneof" json:"any_ip,omitempty"`
}
type GetSpecType_IpPrefixList struct {
	IpPrefixList *policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,proto3,oneof" json:"ip_prefix_list,omitempty"`
}
type GetSpecType_IpMatcher struct {
	IpMatcher *policy.IpMatcherType `protobuf:"bytes,12,opt,name=ip_matcher,json=ipMatcher,proto3,oneof" json:"ip_matcher,omitempty"`
}
type GetSpecType_AnyDstIp struct {
	AnyDstIp *schema.Empty `protobuf:"bytes,41,opt,name=any_dst_ip,json=anyDstIp,proto3,oneof" json:"any_dst_ip,omitempty"`
}
type GetSpecType_DstIpPrefixList struct {
	DstIpPrefixList *policy.PrefixMatchList `protobuf:"bytes,42,opt,name=dst_ip_prefix_list,json=dstIpPrefixList,proto3,oneof" json:"dst_ip_prefix_list,omitempty"`
}
type GetSpecType_DstIpMatcher struct {
	DstIpMatcher *policy.IpMatcherType `protobuf:"bytes,43,opt,name=dst_ip_matcher,json=dstIpMatcher,proto3,oneof" json:"dst_ip_matcher,omitempty"`
}
type GetSpecType_AnyAsn struct {
	AnyAsn *schema.Empty `protobuf:"bytes,34,opt,name=any_asn,json=anyAsn,proto3,oneof" json:"any_asn,omitempty"`
}
type GetSpecType_AsnList struct {
	AsnList *policy.AsnMatchList `protobuf:"bytes,35,opt,name=asn_list,json=asnList,proto3,oneof" json:"asn_list,omitempty"`
}
type GetSpecType_AsnMatcher struct {
	AsnMatcher *policy.AsnMatcherType `protobuf:"bytes,13,opt,name=asn_matcher,json=asnMatcher,proto3,oneof" json:"asn_matcher,omitempty"`
}
type GetSpecType_AnyDstAsn struct {
	AnyDstAsn *schema.Empty `protobuf:"bytes,51,opt,name=any_dst_asn,json=anyDstAsn,proto3,oneof" json:"any_dst_asn,omitempty"`
}
type GetSpecType_DstAsnList struct {
	DstAsnList *policy.AsnMatchList `protobuf:"bytes,52,opt,name=dst_asn_list,json=dstAsnList,proto3,oneof" json:"dst_asn_list,omitempty"`
}
type GetSpecType_DstAsnMatcher struct {
	DstAsnMatcher *policy.AsnMatcherType `protobuf:"bytes,53,opt,name=dst_asn_matcher,json=dstAsnMatcher,proto3,oneof" json:"dst_asn_matcher,omitempty"`
}

func (*GetSpecType_AnyClient) isGetSpecType_ClientChoice()         {}
func (*GetSpecType_ClientName) isGetSpecType_ClientChoice()        {}
func (*GetSpecType_ClientSelector) isGetSpecType_ClientChoice()    {}
func (*GetSpecType_ClientNameMatcher) isGetSpecType_ClientChoice() {}
func (*GetSpecType_AnyIp) isGetSpecType_IpChoice()                 {}
func (*GetSpecType_IpPrefixList) isGetSpecType_IpChoice()          {}
func (*GetSpecType_IpMatcher) isGetSpecType_IpChoice()             {}
func (*GetSpecType_AnyDstIp) isGetSpecType_DstIpChoice()           {}
func (*GetSpecType_DstIpPrefixList) isGetSpecType_DstIpChoice()    {}
func (*GetSpecType_DstIpMatcher) isGetSpecType_DstIpChoice()       {}
func (*GetSpecType_AnyAsn) isGetSpecType_AsnChoice()               {}
func (*GetSpecType_AsnList) isGetSpecType_AsnChoice()              {}
func (*GetSpecType_AsnMatcher) isGetSpecType_AsnChoice()           {}
func (*GetSpecType_AnyDstAsn) isGetSpecType_DstAsnChoice()         {}
func (*GetSpecType_DstAsnList) isGetSpecType_DstAsnChoice()        {}
func (*GetSpecType_DstAsnMatcher) isGetSpecType_DstAsnChoice()     {}

func (m *GetSpecType) GetClientChoice() isGetSpecType_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}
func (m *GetSpecType) GetIpChoice() isGetSpecType_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *GetSpecType) GetDstIpChoice() isGetSpecType_DstIpChoice {
	if m != nil {
		return m.DstIpChoice
	}
	return nil
}
func (m *GetSpecType) GetAsnChoice() isGetSpecType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *GetSpecType) GetDstAsnChoice() isGetSpecType_DstAsnChoice {
	if m != nil {
		return m.DstAsnChoice
	}
	return nil
}

func (m *GetSpecType) GetAction() policy.RuleAction {
	if m != nil {
		return m.Action
	}
	return policy.DENY
}

func (m *GetSpecType) GetAnyClient() *schema.Empty {
	if x, ok := m.GetClientChoice().(*GetSpecType_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *GetSpecType) GetClientName() string {
	if x, ok := m.GetClientChoice().(*GetSpecType_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *GetSpecType) GetClientSelector() *schema.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*GetSpecType_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *GetSpecType) GetClientNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetClientChoice().(*GetSpecType_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *GetSpecType) GetClientRole() *policy.RoleMatcherType {
	if m != nil {
		return m.ClientRole
	}
	return nil
}

func (m *GetSpecType) GetServerSelector() *schema.LabelSelectorType {
	if m != nil {
		return m.ServerSelector
	}
	return nil
}

func (m *GetSpecType) GetLabelMatcher() *schema.LabelMatcherType {
	if m != nil {
		return m.LabelMatcher
	}
	return nil
}

func (m *GetSpecType) GetPath() *policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *GetSpecType) GetHeaders() []*policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GetSpecType) GetQueryParams() []*policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *GetSpecType) GetHttpMethod() *policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *GetSpecType) GetAnyIp() *schema.Empty {
	if x, ok := m.GetIpChoice().(*GetSpecType_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *GetSpecType) GetIpPrefixList() *policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*GetSpecType_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *GetSpecType) GetIpMatcher() *policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*GetSpecType_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *GetSpecType) GetAnyDstIp() *schema.Empty {
	if x, ok := m.GetDstIpChoice().(*GetSpecType_AnyDstIp); ok {
		return x.AnyDstIp
	}
	return nil
}

func (m *GetSpecType) GetDstIpPrefixList() *policy.PrefixMatchList {
	if x, ok := m.GetDstIpChoice().(*GetSpecType_DstIpPrefixList); ok {
		return x.DstIpPrefixList
	}
	return nil
}

func (m *GetSpecType) GetDstIpMatcher() *policy.IpMatcherType {
	if x, ok := m.GetDstIpChoice().(*GetSpecType_DstIpMatcher); ok {
		return x.DstIpMatcher
	}
	return nil
}

func (m *GetSpecType) GetAnyAsn() *schema.Empty {
	if x, ok := m.GetAsnChoice().(*GetSpecType_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *GetSpecType) GetAsnList() *policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*GetSpecType_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *GetSpecType) GetAsnMatcher() *policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*GetSpecType_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *GetSpecType) GetAnyDstAsn() *schema.Empty {
	if x, ok := m.GetDstAsnChoice().(*GetSpecType_AnyDstAsn); ok {
		return x.AnyDstAsn
	}
	return nil
}

func (m *GetSpecType) GetDstAsnList() *policy.AsnMatchList {
	if x, ok := m.GetDstAsnChoice().(*GetSpecType_DstAsnList); ok {
		return x.DstAsnList
	}
	return nil
}

func (m *GetSpecType) GetDstAsnMatcher() *policy.AsnMatcherType {
	if x, ok := m.GetDstAsnChoice().(*GetSpecType_DstAsnMatcher); ok {
		return x.DstAsnMatcher
	}
	return nil
}

func (m *GetSpecType) GetApiGroupMatcher() *policy.StringMatcherType {
	if m != nil {
		return m.ApiGroupMatcher
	}
	return nil
}

func (m *GetSpecType) GetPortMatcher() *policy.PortMatcherType {
	if m != nil {
		return m.PortMatcher
	}
	return nil
}

func (m *GetSpecType) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

func (m *GetSpecType) GetBodyMatcher() *policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *GetSpecType) GetArgMatchers() []*policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *GetSpecType) GetCookieMatchers() []*policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *GetSpecType) GetWafAction() *policy.WafAction {
	if m != nil {
		return m.WafAction
	}
	return nil
}

func (m *GetSpecType) GetDomainMatcher() *policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *GetSpecType) GetRateLimiter() []*schema.ObjectRefType {
	if m != nil {
		return m.RateLimiter
	}
	return nil
}

func (m *GetSpecType) GetVirtualHostMatcher() *policy.MatcherTypeBasic {
	if m != nil {
		return m.VirtualHostMatcher
	}
	return nil
}

func (m *GetSpecType) GetTlsFingerprintMatcher() *policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *GetSpecType) GetMaliciousUserMitigationBypass() *schema.Empty {
	if m != nil {
		return m.MaliciousUserMitigationBypass
	}
	return nil
}

func (m *GetSpecType) GetScheme() []string {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *GetSpecType) GetUrlMatcher() *policy.URLMatcherType {
	if m != nil {
		return m.UrlMatcher
	}
	return nil
}

func (m *GetSpecType) GetL4DestMatcher() *policy.L4DestMatcherType {
	if m != nil {
		return m.L4DestMatcher
	}
	return nil
}

func (m *GetSpecType) GetChallengeAction() policy.ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return policy.DEFAULT_CHALLENGE
}

func (m *GetSpecType) GetGotoPolicy() []*schema.ObjectRefType {
	if m != nil {
		return m.GotoPolicy
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_AnyClient)(nil),
		(*GetSpecType_ClientName)(nil),
		(*GetSpecType_ClientSelector)(nil),
		(*GetSpecType_ClientNameMatcher)(nil),
		(*GetSpecType_AnyIp)(nil),
		(*GetSpecType_IpPrefixList)(nil),
		(*GetSpecType_IpMatcher)(nil),
		(*GetSpecType_AnyDstIp)(nil),
		(*GetSpecType_DstIpPrefixList)(nil),
		(*GetSpecType_DstIpMatcher)(nil),
		(*GetSpecType_AnyAsn)(nil),
		(*GetSpecType_AsnList)(nil),
		(*GetSpecType_AsnMatcher)(nil),
		(*GetSpecType_AnyDstAsn)(nil),
		(*GetSpecType_DstAsnList)(nil),
		(*GetSpecType_DstAsnMatcher)(nil),
	}
}

// Challenge Rule Spec
//
// x-displayName: "Challenge Rule Specification"
// A Challenge Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from
// or derived from an L7 request API. A request API is considered to match the rule if all predicates in the rule evaluate to true for that request. Any
// predicates that are not specified in a rule are implicitly considered to be true. If a request API matches a challenge rule, the configured challenge is
// enforced.
type ChallengeRuleSpec struct {
	// Select Action Type
	//
	// x-displayName: "Select Challenge Action Type"
	// x-required
	// Select challenge action, enable or disable challenge
	// When enabled, the challenge type selected in PolicyBasedChallenge
	// will be launched when match conditions in this challenge rule are met
	// When the challenge type selected in PolicyBasedChallenge is always enable JS/Captcha challenge,
	// the challenge can be disabled for certain requests which match the predicates defined in this rule
	// by setting the action to disable_challenge
	//
	// Types that are valid to be assigned to ChallengeAction:
	//	*ChallengeRuleSpec_DisableChallenge
	//	*ChallengeRuleSpec_EnableJavascriptChallenge
	//	*ChallengeRuleSpec_EnableCaptchaChallenge
	ChallengeAction isChallengeRuleSpec_ChallengeAction `protobuf_oneof:"challenge_action"`
	// Types that are valid to be assigned to IpChoice:
	//	*ChallengeRuleSpec_AnyIp
	//	*ChallengeRuleSpec_IpPrefixList
	//	*ChallengeRuleSpec_IpMatcher
	IpChoice isChallengeRuleSpec_IpChoice `protobuf_oneof:"ip_choice"`
	// Types that are valid to be assigned to AsnChoice:
	//	*ChallengeRuleSpec_AnyAsn
	//	*ChallengeRuleSpec_AsnList
	//	*ChallengeRuleSpec_AsnMatcher
	AsnChoice             isChallengeRuleSpec_AsnChoice       `protobuf_oneof:"asn_choice"`
	DomainMatcher         *policy.MatcherTypeBasic            `protobuf:"bytes,5,opt,name=domain_matcher,json=domainMatcher,proto3" json:"domain_matcher,omitempty"`
	Path                  *policy.PathMatcherType             `protobuf:"bytes,6,opt,name=path,proto3" json:"path,omitempty"`
	Headers               []*policy.HeaderMatcherType         `protobuf:"bytes,7,rep,name=headers,proto3" json:"headers,omitempty"`
	HttpMethod            *policy.HttpMethodMatcherType       `protobuf:"bytes,8,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	TlsFingerprintMatcher *policy.TlsFingerprintMatcherType   `protobuf:"bytes,10,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher,proto3" json:"tls_fingerprint_matcher,omitempty"`
	QueryParams           []*policy.QueryParameterMatcherType `protobuf:"bytes,11,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	BodyMatcher           *policy.MatcherType                 `protobuf:"bytes,12,opt,name=body_matcher,json=bodyMatcher,proto3" json:"body_matcher,omitempty"`
	ArgMatchers           []*policy.ArgMatcherType            `protobuf:"bytes,13,rep,name=arg_matchers,json=argMatchers,proto3" json:"arg_matchers,omitempty"`
	CookieMatchers        []*policy.CookieMatcherType         `protobuf:"bytes,14,rep,name=cookie_matchers,json=cookieMatchers,proto3" json:"cookie_matchers,omitempty"`
	// Types that are valid to be assigned to ClientChoice:
	//	*ChallengeRuleSpec_AnyClient
	//	*ChallengeRuleSpec_ClientName
	//	*ChallengeRuleSpec_ClientSelector
	//	*ChallengeRuleSpec_ClientNameMatcher
	ClientChoice        isChallengeRuleSpec_ClientChoice `protobuf_oneof:"client_choice"`
	ExpirationTimestamp *types.Timestamp                 `protobuf:"bytes,20,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
}

func (m *ChallengeRuleSpec) Reset()      { *m = ChallengeRuleSpec{} }
func (*ChallengeRuleSpec) ProtoMessage() {}
func (*ChallengeRuleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_771e54eb594e8c4b, []int{4}
}
func (m *ChallengeRuleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeRuleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChallengeRuleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeRuleSpec.Merge(m, src)
}
func (m *ChallengeRuleSpec) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeRuleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeRuleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeRuleSpec proto.InternalMessageInfo

type isChallengeRuleSpec_ChallengeAction interface {
	isChallengeRuleSpec_ChallengeAction()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isChallengeRuleSpec_IpChoice interface {
	isChallengeRuleSpec_IpChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isChallengeRuleSpec_AsnChoice interface {
	isChallengeRuleSpec_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isChallengeRuleSpec_ClientChoice interface {
	isChallengeRuleSpec_ClientChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ChallengeRuleSpec_DisableChallenge struct {
	DisableChallenge *schema.Empty `protobuf:"bytes,2,opt,name=disable_challenge,json=disableChallenge,proto3,oneof" json:"disable_challenge,omitempty"`
}
type ChallengeRuleSpec_EnableJavascriptChallenge struct {
	EnableJavascriptChallenge *schema.Empty `protobuf:"bytes,3,opt,name=enable_javascript_challenge,json=enableJavascriptChallenge,proto3,oneof" json:"enable_javascript_challenge,omitempty"`
}
type ChallengeRuleSpec_EnableCaptchaChallenge struct {
	EnableCaptchaChallenge *schema.Empty `protobuf:"bytes,4,opt,name=enable_captcha_challenge,json=enableCaptchaChallenge,proto3,oneof" json:"enable_captcha_challenge,omitempty"`
}
type ChallengeRuleSpec_AnyIp struct {
	AnyIp *schema.Empty `protobuf:"bytes,31,opt,name=any_ip,json=anyIp,proto3,oneof" json:"any_ip,omitempty"`
}
type ChallengeRuleSpec_IpPrefixList struct {
	IpPrefixList *policy.PrefixMatchList `protobuf:"bytes,32,opt,name=ip_prefix_list,json=ipPrefixList,proto3,oneof" json:"ip_prefix_list,omitempty"`
}
type ChallengeRuleSpec_IpMatcher struct {
	IpMatcher *policy.IpMatcherType `protobuf:"bytes,33,opt,name=ip_matcher,json=ipMatcher,proto3,oneof" json:"ip_matcher,omitempty"`
}
type ChallengeRuleSpec_AnyAsn struct {
	AnyAsn *schema.Empty `protobuf:"bytes,41,opt,name=any_asn,json=anyAsn,proto3,oneof" json:"any_asn,omitempty"`
}
type ChallengeRuleSpec_AsnList struct {
	AsnList *policy.AsnMatchList `protobuf:"bytes,42,opt,name=asn_list,json=asnList,proto3,oneof" json:"asn_list,omitempty"`
}
type ChallengeRuleSpec_AsnMatcher struct {
	AsnMatcher *policy.AsnMatcherType `protobuf:"bytes,43,opt,name=asn_matcher,json=asnMatcher,proto3,oneof" json:"asn_matcher,omitempty"`
}
type ChallengeRuleSpec_AnyClient struct {
	AnyClient *schema.Empty `protobuf:"bytes,16,opt,name=any_client,json=anyClient,proto3,oneof" json:"any_client,omitempty"`
}
type ChallengeRuleSpec_ClientName struct {
	ClientName string `protobuf:"bytes,17,opt,name=client_name,json=clientName,proto3,oneof" json:"client_name,omitempty"`
}
type ChallengeRuleSpec_ClientSelector struct {
	ClientSelector *schema.LabelSelectorType `protobuf:"bytes,18,opt,name=client_selector,json=clientSelector,proto3,oneof" json:"client_selector,omitempty"`
}
type ChallengeRuleSpec_ClientNameMatcher struct {
	ClientNameMatcher *policy.MatcherType `protobuf:"bytes,19,opt,name=client_name_matcher,json=clientNameMatcher,proto3,oneof" json:"client_name_matcher,omitempty"`
}

func (*ChallengeRuleSpec_DisableChallenge) isChallengeRuleSpec_ChallengeAction()          {}
func (*ChallengeRuleSpec_EnableJavascriptChallenge) isChallengeRuleSpec_ChallengeAction() {}
func (*ChallengeRuleSpec_EnableCaptchaChallenge) isChallengeRuleSpec_ChallengeAction()    {}
func (*ChallengeRuleSpec_AnyIp) isChallengeRuleSpec_IpChoice()                            {}
func (*ChallengeRuleSpec_IpPrefixList) isChallengeRuleSpec_IpChoice()                     {}
func (*ChallengeRuleSpec_IpMatcher) isChallengeRuleSpec_IpChoice()                        {}
func (*ChallengeRuleSpec_AnyAsn) isChallengeRuleSpec_AsnChoice()                          {}
func (*ChallengeRuleSpec_AsnList) isChallengeRuleSpec_AsnChoice()                         {}
func (*ChallengeRuleSpec_AsnMatcher) isChallengeRuleSpec_AsnChoice()                      {}
func (*ChallengeRuleSpec_AnyClient) isChallengeRuleSpec_ClientChoice()                    {}
func (*ChallengeRuleSpec_ClientName) isChallengeRuleSpec_ClientChoice()                   {}
func (*ChallengeRuleSpec_ClientSelector) isChallengeRuleSpec_ClientChoice()               {}
func (*ChallengeRuleSpec_ClientNameMatcher) isChallengeRuleSpec_ClientChoice()            {}

func (m *ChallengeRuleSpec) GetChallengeAction() isChallengeRuleSpec_ChallengeAction {
	if m != nil {
		return m.ChallengeAction
	}
	return nil
}
func (m *ChallengeRuleSpec) GetIpChoice() isChallengeRuleSpec_IpChoice {
	if m != nil {
		return m.IpChoice
	}
	return nil
}
func (m *ChallengeRuleSpec) GetAsnChoice() isChallengeRuleSpec_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}
func (m *ChallengeRuleSpec) GetClientChoice() isChallengeRuleSpec_ClientChoice {
	if m != nil {
		return m.ClientChoice
	}
	return nil
}

func (m *ChallengeRuleSpec) GetDisableChallenge() *schema.Empty {
	if x, ok := m.GetChallengeAction().(*ChallengeRuleSpec_DisableChallenge); ok {
		return x.DisableChallenge
	}
	return nil
}

func (m *ChallengeRuleSpec) GetEnableJavascriptChallenge() *schema.Empty {
	if x, ok := m.GetChallengeAction().(*ChallengeRuleSpec_EnableJavascriptChallenge); ok {
		return x.EnableJavascriptChallenge
	}
	return nil
}

func (m *ChallengeRuleSpec) GetEnableCaptchaChallenge() *schema.Empty {
	if x, ok := m.GetChallengeAction().(*ChallengeRuleSpec_EnableCaptchaChallenge); ok {
		return x.EnableCaptchaChallenge
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAnyIp() *schema.Empty {
	if x, ok := m.GetIpChoice().(*ChallengeRuleSpec_AnyIp); ok {
		return x.AnyIp
	}
	return nil
}

func (m *ChallengeRuleSpec) GetIpPrefixList() *policy.PrefixMatchList {
	if x, ok := m.GetIpChoice().(*ChallengeRuleSpec_IpPrefixList); ok {
		return x.IpPrefixList
	}
	return nil
}

func (m *ChallengeRuleSpec) GetIpMatcher() *policy.IpMatcherType {
	if x, ok := m.GetIpChoice().(*ChallengeRuleSpec_IpMatcher); ok {
		return x.IpMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAnyAsn() *schema.Empty {
	if x, ok := m.GetAsnChoice().(*ChallengeRuleSpec_AnyAsn); ok {
		return x.AnyAsn
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAsnList() *policy.AsnMatchList {
	if x, ok := m.GetAsnChoice().(*ChallengeRuleSpec_AsnList); ok {
		return x.AsnList
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAsnMatcher() *policy.AsnMatcherType {
	if x, ok := m.GetAsnChoice().(*ChallengeRuleSpec_AsnMatcher); ok {
		return x.AsnMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetDomainMatcher() *policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetPath() *policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *ChallengeRuleSpec) GetHeaders() []*policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *ChallengeRuleSpec) GetHttpMethod() *policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *ChallengeRuleSpec) GetTlsFingerprintMatcher() *policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetQueryParams() []*policy.QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *ChallengeRuleSpec) GetBodyMatcher() *policy.MatcherType {
	if m != nil {
		return m.BodyMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetArgMatchers() []*policy.ArgMatcherType {
	if m != nil {
		return m.ArgMatchers
	}
	return nil
}

func (m *ChallengeRuleSpec) GetCookieMatchers() []*policy.CookieMatcherType {
	if m != nil {
		return m.CookieMatchers
	}
	return nil
}

func (m *ChallengeRuleSpec) GetAnyClient() *schema.Empty {
	if x, ok := m.GetClientChoice().(*ChallengeRuleSpec_AnyClient); ok {
		return x.AnyClient
	}
	return nil
}

func (m *ChallengeRuleSpec) GetClientName() string {
	if x, ok := m.GetClientChoice().(*ChallengeRuleSpec_ClientName); ok {
		return x.ClientName
	}
	return ""
}

func (m *ChallengeRuleSpec) GetClientSelector() *schema.LabelSelectorType {
	if x, ok := m.GetClientChoice().(*ChallengeRuleSpec_ClientSelector); ok {
		return x.ClientSelector
	}
	return nil
}

func (m *ChallengeRuleSpec) GetClientNameMatcher() *policy.MatcherType {
	if x, ok := m.GetClientChoice().(*ChallengeRuleSpec_ClientNameMatcher); ok {
		return x.ClientNameMatcher
	}
	return nil
}

func (m *ChallengeRuleSpec) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ChallengeRuleSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ChallengeRuleSpec_DisableChallenge)(nil),
		(*ChallengeRuleSpec_EnableJavascriptChallenge)(nil),
		(*ChallengeRuleSpec_EnableCaptchaChallenge)(nil),
		(*ChallengeRuleSpec_AnyIp)(nil),
		(*ChallengeRuleSpec_IpPrefixList)(nil),
		(*ChallengeRuleSpec_IpMatcher)(nil),
		(*ChallengeRuleSpec_AnyAsn)(nil),
		(*ChallengeRuleSpec_AsnList)(nil),
		(*ChallengeRuleSpec_AsnMatcher)(nil),
		(*ChallengeRuleSpec_AnyClient)(nil),
		(*ChallengeRuleSpec_ClientName)(nil),
		(*ChallengeRuleSpec_ClientSelector)(nil),
		(*ChallengeRuleSpec_ClientNameMatcher)(nil),
	}
}

// Rate Limiter Rule Spec
//
// x-displayName: "Rate Limiter Rule Specification"
// Shape of Rate Limiter Rule
type RateLimiterRuleSpec struct {
	// action choice
	//
	// x-displayName: "Action"
	// x-required
	// Specify action for the rule.
	//
	// Types that are valid to be assigned to ActionChoice:
	//	*RateLimiterRuleSpec_BypassRateLimiter
	//	*RateLimiterRuleSpec_ApplyRateLimiter
	//	*RateLimiterRuleSpec_CustomRateLimiter
	ActionChoice  isRateLimiterRuleSpec_ActionChoice `protobuf_oneof:"action_choice"`
	HttpMethod    *policy.HttpMethodMatcherType      `protobuf:"bytes,6,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	DomainMatcher *policy.MatcherTypeBasic           `protobuf:"bytes,10,opt,name=domain_matcher,json=domainMatcher,proto3" json:"domain_matcher,omitempty"`
	Path          *policy.PathMatcherType            `protobuf:"bytes,8,opt,name=path,proto3" json:"path,omitempty"`
	Headers       []*policy.HeaderMatcherType        `protobuf:"bytes,9,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (m *RateLimiterRuleSpec) Reset()      { *m = RateLimiterRuleSpec{} }
func (*RateLimiterRuleSpec) ProtoMessage() {}
func (*RateLimiterRuleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_771e54eb594e8c4b, []int{5}
}
func (m *RateLimiterRuleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimiterRuleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RateLimiterRuleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimiterRuleSpec.Merge(m, src)
}
func (m *RateLimiterRuleSpec) XXX_Size() int {
	return m.Size()
}
func (m *RateLimiterRuleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimiterRuleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimiterRuleSpec proto.InternalMessageInfo

type isRateLimiterRuleSpec_ActionChoice interface {
	isRateLimiterRuleSpec_ActionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RateLimiterRuleSpec_BypassRateLimiter struct {
	BypassRateLimiter *schema.Empty `protobuf:"bytes,3,opt,name=bypass_rate_limiter,json=bypassRateLimiter,proto3,oneof" json:"bypass_rate_limiter,omitempty"`
}
type RateLimiterRuleSpec_ApplyRateLimiter struct {
	ApplyRateLimiter *schema.Empty `protobuf:"bytes,4,opt,name=apply_rate_limiter,json=applyRateLimiter,proto3,oneof" json:"apply_rate_limiter,omitempty"`
}
type RateLimiterRuleSpec_CustomRateLimiter struct {
	CustomRateLimiter *views.ObjectRefType `protobuf:"bytes,5,opt,name=custom_rate_limiter,json=customRateLimiter,proto3,oneof" json:"custom_rate_limiter,omitempty"`
}

func (*RateLimiterRuleSpec_BypassRateLimiter) isRateLimiterRuleSpec_ActionChoice() {}
func (*RateLimiterRuleSpec_ApplyRateLimiter) isRateLimiterRuleSpec_ActionChoice()  {}
func (*RateLimiterRuleSpec_CustomRateLimiter) isRateLimiterRuleSpec_ActionChoice() {}

func (m *RateLimiterRuleSpec) GetActionChoice() isRateLimiterRuleSpec_ActionChoice {
	if m != nil {
		return m.ActionChoice
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetBypassRateLimiter() *schema.Empty {
	if x, ok := m.GetActionChoice().(*RateLimiterRuleSpec_BypassRateLimiter); ok {
		return x.BypassRateLimiter
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetApplyRateLimiter() *schema.Empty {
	if x, ok := m.GetActionChoice().(*RateLimiterRuleSpec_ApplyRateLimiter); ok {
		return x.ApplyRateLimiter
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetCustomRateLimiter() *views.ObjectRefType {
	if x, ok := m.GetActionChoice().(*RateLimiterRuleSpec_CustomRateLimiter); ok {
		return x.CustomRateLimiter
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetHttpMethod() *policy.HttpMethodMatcherType {
	if m != nil {
		return m.HttpMethod
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetDomainMatcher() *policy.MatcherTypeBasic {
	if m != nil {
		return m.DomainMatcher
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetPath() *policy.PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *RateLimiterRuleSpec) GetHeaders() []*policy.HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RateLimiterRuleSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RateLimiterRuleSpec_BypassRateLimiter)(nil),
		(*RateLimiterRuleSpec_ApplyRateLimiter)(nil),
		(*RateLimiterRuleSpec_CustomRateLimiter)(nil),
	}
}

func init() {
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy_rule.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.service_policy_rule.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy_rule.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.service_policy_rule.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy_rule.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.service_policy_rule.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy_rule.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.service_policy_rule.GetSpecType")
	proto.RegisterType((*ChallengeRuleSpec)(nil), "ves.io.schema.service_policy_rule.ChallengeRuleSpec")
	golang_proto.RegisterType((*ChallengeRuleSpec)(nil), "ves.io.schema.service_policy_rule.ChallengeRuleSpec")
	proto.RegisterType((*RateLimiterRuleSpec)(nil), "ves.io.schema.service_policy_rule.RateLimiterRuleSpec")
	golang_proto.RegisterType((*RateLimiterRuleSpec)(nil), "ves.io.schema.service_policy_rule.RateLimiterRuleSpec")
}

func init() {
	proto.RegisterFile("ves.io/schema/service_policy_rule/types.proto", fileDescriptor_771e54eb594e8c4b)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/service_policy_rule/types.proto", fileDescriptor_771e54eb594e8c4b)
}

var fileDescriptor_771e54eb594e8c4b = []byte{
	// 2800 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x9c, 0xcf, 0x6f, 0xdb, 0x46,
	0xda, 0xc7, 0x3d, 0x92, 0x6c, 0xcb, 0x23, 0x59, 0xa2, 0x69, 0x27, 0x65, 0x5c, 0x57, 0x51, 0xd4,
	0x38, 0x75, 0x1b, 0x5a, 0xb6, 0x7e, 0xd8, 0x49, 0xfb, 0xa2, 0xed, 0x1b, 0xd9, 0x4d, 0x14, 0xd5,
	0x4e, 0x5c, 0xda, 0x6d, 0xd2, 0xbe, 0xed, 0xab, 0x1d, 0x53, 0x63, 0x89, 0x2d, 0x25, 0x32, 0x24,
	0xe5, 0xd4, 0x58, 0x04, 0x5b, 0xe4, 0xb0, 0xe7, 0x45, 0x81, 0xbd, 0xf4, 0x2f, 0x58, 0x14, 0x58,
	0x2c, 0xb0, 0xc0, 0xee, 0x61, 0xd5, 0x83, 0x51, 0x60, 0x81, 0x62, 0x4f, 0x39, 0x06, 0x8b, 0x3d,
	0xb4, 0xce, 0xa5, 0x7b, 0xeb, 0x39, 0xa7, 0x05, 0x87, 0x3f, 0x44, 0x4a, 0x94, 0x2a, 0x4b, 0x5e,
	0x60, 0xb1, 0xe0, 0x29, 0x22, 0xe7, 0x79, 0xbe, 0x33, 0xcf, 0x70, 0x38, 0xf3, 0x7c, 0x98, 0x19,
	0xc3, 0xe5, 0x43, 0xac, 0xa6, 0x05, 0x69, 0x45, 0xe5, 0x6b, 0xb8, 0x8e, 0x56, 0x54, 0xac, 0x1c,
	0x0a, 0x3c, 0x2e, 0xcb, 0x92, 0x28, 0xf0, 0x47, 0x65, 0xa5, 0x29, 0xe2, 0x15, 0xed, 0x48, 0xc6,
	0x6a, 0x5a, 0x56, 0x24, 0x4d, 0xa2, 0x2f, 0x19, 0xe6, 0x69, 0xc3, 0x3c, 0xed, 0x61, 0x3e, 0xbf,
	0x5c, 0x15, 0xb4, 0x5a, 0x73, 0x3f, 0xcd, 0x4b, 0xf5, 0x95, 0xaa, 0x54, 0x95, 0x56, 0x88, 0xe7,
	0x7e, 0xf3, 0x80, 0x5c, 0x91, 0x0b, 0xf2, 0xcb, 0x50, 0x9c, 0xbf, 0x58, 0x95, 0xa4, 0xaa, 0x88,
	0xdb, 0x56, 0x9a, 0x50, 0xc7, 0xaa, 0x86, 0xea, 0xb2, 0x69, 0xf0, 0xa2, 0xbb, 0x85, 0x92, 0xac,
	0x09, 0x52, 0xc3, 0x6c, 0xcf, 0x7c, 0xd2, 0x5d, 0x68, 0xb4, 0xc3, 0xd9, 0xe2, 0xf9, 0x0b, 0x6e,
	0x0b, 0x67, 0xd1, 0x82, 0xbb, 0xe8, 0x10, 0x89, 0x42, 0x05, 0x69, 0xd8, 0x5b, 0xfa, 0x50, 0xc0,
	0x0f, 0xcb, 0xee, 0xca, 0x2f, 0x76, 0x5b, 0xa8, 0xce, 0x0a, 0x52, 0x7f, 0x48, 0xc0, 0xd8, 0x2d,
	0x51, 0xda, 0x47, 0xe2, 0xae, 0x8c, 0xf9, 0xbd, 0x23, 0x19, 0xd3, 0x05, 0x38, 0x81, 0x78, 0x5d,
	0x84, 0x01, 0x49, 0xb0, 0x14, 0xcb, 0x26, 0xd3, 0xee, 0x1e, 0x35, 0x22, 0x48, 0x73, 0x4d, 0x11,
	0xdf, 0x20, 0x76, 0x85, 0xf0, 0xdf, 0x5b, 0x20, 0xb4, 0xf9, 0xce, 0x9d, 0x0f, 0x39, 0xd3, 0x93,
	0x5e, 0x83, 0x10, 0x35, 0x8e, 0xca, 0xbc, 0x28, 0xe0, 0x86, 0xc6, 0x2c, 0x26, 0xc1, 0x52, 0x24,
	0x3b, 0xd7, 0xa1, 0xf3, 0x4e, 0x5d, 0xd6, 0x8e, 0x8a, 0x63, 0xdc, 0x14, 0x6a, 0x1c, 0x6d, 0x10,
	0x43, 0x7a, 0x19, 0x46, 0x0c, 0x97, 0x72, 0x03, 0xd5, 0x31, 0x13, 0x48, 0x82, 0xa5, 0xa9, 0x02,
	0xfc, 0xcb, 0x3f, 0x8f, 0x83, 0xe3, 0x4a, 0x70, 0xe9, 0x8b, 0x40, 0x71, 0x8c, 0x83, 0x86, 0xc1,
	0x1d, 0x54, 0xc7, 0xf4, 0x07, 0x30, 0x6e, 0x9a, 0xab, 0x58, 0xc4, 0xbc, 0x26, 0x29, 0x4c, 0x90,
	0x54, 0xd5, 0xd9, 0xe4, 0x2d, 0xb4, 0x8f, 0xc5, 0x5d, 0xd3, 0x46, 0x0f, 0xb2, 0x30, 0xf5, 0xd5,
	0x37, 0x60, 0x1c, 0x06, 0x41, 0x20, 0x58, 0x1c, 0xe3, 0x62, 0x86, 0x8a, 0x65, 0x40, 0xef, 0xc2,
	0x59, 0x47, 0x33, 0xca, 0x75, 0xa4, 0xf1, 0x35, 0xac, 0x30, 0x90, 0x68, 0x5f, 0xf2, 0xee, 0x8e,
	0x6d, 0xc3, 0x48, 0x17, 0x2f, 0x8e, 0x71, 0x33, 0xed, 0x56, 0x9a, 0x05, 0xf4, 0x5d, 0x3b, 0x36,
	0x45, 0x12, 0x31, 0x33, 0x45, 0xc4, 0x16, 0x7b, 0xf4, 0xad, 0x24, 0x62, 0x87, 0x60, 0x61, 0xf2,
	0xe9, 0x23, 0xf0, 0x63, 0x0b, 0x00, 0x2b, 0x7a, 0xbd, 0x9c, 0xfe, 0x08, 0xc6, 0xf5, 0xc1, 0x8d,
	0x95, 0x76, 0xf4, 0xcb, 0x03, 0x46, 0x1f, 0x37, 0xf5, 0xbe, 0xfa, 0x06, 0x84, 0x60, 0x00, 0x04,
	0xb8, 0x98, 0xa1, 0xe4, 0xe8, 0x81, 0x69, 0x51, 0xf7, 0xb2, 0x63, 0x0f, 0x11, 0xe5, 0x8b, 0x5e,
	0xca, 0xce, 0x86, 0x4e, 0xff, 0x64, 0xa8, 0x1a, 0x5d, 0xcb, 0x45, 0x45, 0x87, 0x01, 0xfd, 0x3a,
	0x0c, 0xc9, 0x48, 0xab, 0x31, 0xe3, 0xfd, 0x42, 0xdf, 0x41, 0x5a, 0xcd, 0xa1, 0xc8, 0x11, 0x17,
	0x7a, 0x1b, 0x4e, 0xd6, 0x30, 0xaa, 0x60, 0x45, 0x65, 0x26, 0x92, 0xc1, 0xa5, 0x48, 0xf6, 0x15,
	0x6f, 0xef, 0x22, 0x31, 0x72, 0xb6, 0xc8, 0x18, 0x3d, 0x5f, 0x82, 0x00, 0x45, 0x71, 0x96, 0x06,
	0xfd, 0xff, 0x30, 0xfa, 0xa0, 0x89, 0x95, 0xa3, 0xb2, 0x8c, 0x14, 0x54, 0x57, 0x99, 0x49, 0xa2,
	0xb9, 0xe2, 0xad, 0xf9, 0x9e, 0x6e, 0xb9, 0xa3, 0x1b, 0x62, 0xad, 0xb7, 0x76, 0xe4, 0x81, 0x6d,
	0xa6, 0xd2, 0x5b, 0x30, 0x52, 0xd3, 0x34, 0xb9, 0x5c, 0xc7, 0x5a, 0x4d, 0xaa, 0x30, 0x61, 0x12,
	0xf0, 0xd5, 0x1e, 0x4d, 0xd6, 0x34, 0x79, 0x9b, 0xd8, 0x39, 0xc3, 0x86, 0x35, 0xfb, 0x36, 0xbd,
	0x0c, 0x27, 0xf4, 0x97, 0x49, 0x90, 0x99, 0x8b, 0x7d, 0x5e, 0x24, 0xc0, 0x8d, 0xa3, 0xc6, 0xd1,
	0x6d, 0x99, 0xde, 0x86, 0x31, 0x41, 0x2e, 0xcb, 0x0a, 0x3e, 0x10, 0x3e, 0x2f, 0x8b, 0x82, 0xaa,
	0x31, 0xc9, 0xbe, 0x1d, 0x4e, 0x0c, 0x49, 0xdd, 0x5b, 0x82, 0xaa, 0x15, 0x01, 0x17, 0x15, 0x64,
	0xe3, 0xa6, 0x7e, 0x4d, 0x6f, 0x42, 0x28, 0xc8, 0xf6, 0x38, 0x88, 0x12, 0xa9, 0x97, 0xbd, 0xa5,
	0x6e, 0xcb, 0xce, 0xb7, 0x00, 0x70, 0x53, 0x82, 0x75, 0x83, 0x7e, 0xd3, 0x98, 0x10, 0x2a, 0xaa,
	0xa6, 0xc7, 0xf1, 0x6a, 0xef, 0x38, 0xec, 0xb1, 0x5e, 0x0c, 0x70, 0x61, 0xd4, 0x38, 0xda, 0x54,
	0xb5, 0xdb, 0x32, 0xfd, 0x09, 0xa4, 0x0d, 0x57, 0x57, 0x5c, 0xaf, 0x9d, 0x22, 0x2e, 0xa7, 0x6e,
	0xbc, 0xa2, 0x8b, 0x3a, 0x62, 0xdc, 0x83, 0x31, 0x53, 0xde, 0x8a, 0xf3, 0xea, 0xc0, 0x71, 0x3a,
	0x85, 0xa3, 0x44, 0xd8, 0x8a, 0x79, 0x05, 0x4e, 0xea, 0x31, 0x23, 0xb5, 0xc1, 0xa4, 0xfa, 0x3c,
	0xb8, 0x20, 0xa7, 0x3f, 0xde, 0x1b, 0x6a, 0x83, 0x7e, 0x1b, 0x86, 0x91, 0xda, 0x30, 0x62, 0x7b,
	0x99, 0x78, 0xa4, 0xbc, 0x1b, 0x70, 0x43, 0x6d, 0xb4, 0x1f, 0x58, 0x90, 0x9b, 0x44, 0x6a, 0x83,
	0xc4, 0x71, 0x0b, 0x46, 0x74, 0x01, 0x2b, 0x88, 0x69, 0xa2, 0x71, 0xb9, 0xbf, 0x86, 0xf9, 0xb4,
	0x82, 0x1c, 0x44, 0xf6, 0x1d, 0xfa, 0x6d, 0x18, 0xb1, 0x1e, 0x97, 0xde, 0xfc, 0xdc, 0x20, 0xcf,
	0x2b, 0x44, 0x66, 0xf2, 0x4d, 0x55, 0xd3, 0x43, 0xb9, 0x0b, 0xa3, 0xa6, 0xb3, 0x11, 0x4e, 0x7e,
	0xd0, 0x70, 0x9c, 0x7a, 0xb0, 0x42, 0xc4, 0x48, 0x68, 0xf7, 0x60, 0xdc, 0x12, 0xb4, 0xc2, 0x5b,
	0x1b, 0x3c, 0x3c, 0xa7, 0xea, 0xb4, 0xa1, 0x6a, 0x85, 0xfa, 0x31, 0x9c, 0x41, 0xb2, 0x50, 0xae,
	0x2a, 0x52, 0xb3, 0xfd, 0xf8, 0x63, 0x44, 0xba, 0xc7, 0x24, 0xb3, 0xab, 0x29, 0x42, 0xa3, 0xea,
	0x39, 0x3f, 0xc7, 0x91, 0x2c, 0xdc, 0xd2, 0x95, 0x2c, 0xf5, 0xf7, 0x60, 0x54, 0x96, 0x14, 0xcd,
	0x16, 0x8e, 0xf7, 0x1d, 0xb2, 0x92, 0xa2, 0x79, 0xca, 0x46, 0xe4, 0x76, 0x09, 0xbd, 0x0b, 0xe7,
	0xf0, 0xe7, 0xb2, 0xa0, 0x20, 0x7d, 0xa5, 0x2d, 0xdb, 0xb9, 0x08, 0x43, 0x11, 0xe9, 0xf9, 0xb4,
	0x91, 0xad, 0xa4, 0xad, 0x6c, 0x25, 0xbd, 0x67, 0x59, 0x14, 0x42, 0xc7, 0xba, 0xd8, 0x6c, 0xdb,
	0xdb, 0x2e, 0xa2, 0x4b, 0x30, 0xba, 0x2f, 0x55, 0x8e, 0xec, 0x76, 0x9e, 0x1b, 0x70, 0xad, 0x33,
	0x35, 0x23, 0xba, 0xb3, 0xd5, 0xc0, 0x7b, 0x30, 0x8a, 0x94, 0xaa, 0x25, 0xa5, 0x32, 0x34, 0x99,
	0x5d, 0x7b, 0x3d, 0x27, 0xc5, 0xd5, 0x93, 0x31, 0x5d, 0xce, 0x39, 0xad, 0x22, 0xbb, 0x5c, 0xa5,
	0x7f, 0x01, 0xe3, 0xbc, 0x24, 0x7d, 0x26, 0xe0, 0xb6, 0xf6, 0x6c, 0xbf, 0xd5, 0x60, 0x83, 0x18,
	0xf7, 0x93, 0x8f, 0xf1, 0x4e, 0x13, 0x95, 0x2e, 0x42, 0xf8, 0x10, 0x1d, 0x94, 0xcd, 0xfc, 0x67,
	0xce, 0x73, 0xd1, 0x33, 0xc5, 0xef, 0xa1, 0x03, 0x2b, 0xfd, 0xd1, 0x45, 0xf5, 0x85, 0x8f, 0x9b,
	0x7a, 0x68, 0xdd, 0xa4, 0x8b, 0x30, 0x56, 0x91, 0xea, 0x48, 0x68, 0x0f, 0xd7, 0xf3, 0x03, 0x76,
	0x29, 0x37, 0x6d, 0x38, 0x5a, 0xdd, 0x89, 0x60, 0x54, 0x41, 0x1a, 0x2e, 0x8b, 0x42, 0x5d, 0xd0,
	0xb0, 0xc2, 0xbc, 0x40, 0x42, 0x5e, 0xe8, 0xd0, 0xb9, 0xbb, 0xff, 0x29, 0xe6, 0x35, 0x0e, 0x1f,
	0x90, 0x38, 0x93, 0x5f, 0x3f, 0x72, 0x39, 0x99, 0x03, 0xc9, 0x8e, 0x3c, 0xc0, 0x45, 0xf4, 0xe2,
	0x2d, 0xa3, 0x94, 0xfe, 0x18, 0xce, 0x1d, 0x0a, 0x8a, 0xd6, 0x44, 0x62, 0xb9, 0x26, 0xa9, 0xed,
	0xd1, 0xca, 0x0c, 0x3a, 0x0a, 0xec, 0x91, 0x4a, 0x9b, 0x3a, 0x45, 0x49, 0xb5, 0x07, 0xec, 0xaf,
	0x01, 0x7c, 0x41, 0x13, 0xd5, 0xf2, 0x81, 0xd0, 0xa8, 0x62, 0x45, 0x56, 0x84, 0x46, 0xbb, 0x86,
	0x0b, 0xa4, 0x86, 0x1e, 0x2b, 0xef, 0x9e, 0xa8, 0xde, 0x6c, 0xfb, 0x38, 0xeb, 0x7b, 0x49, 0xef,
	0xf2, 0x27, 0x2d, 0x00, 0x4e, 0xbe, 0xff, 0x6b, 0x90, 0xfa, 0xea, 0x1b, 0x10, 0x55, 0x6b, 0x48,
	0xc1, 0x15, 0x36, 0xd9, 0x54, 0xb1, 0xc2, 0x9d, 0xd3, 0xbc, 0x3c, 0xe9, 0x3a, 0xa4, 0x0e, 0x24,
	0xe5, 0x21, 0x52, 0x2a, 0x42, 0xa3, 0x5a, 0xe6, 0x45, 0xa4, 0xaa, 0xcc, 0xfc, 0x00, 0xbd, 0x79,
	0xf9, 0xeb, 0x47, 0x5d, 0x8e, 0x9d, 0x3d, 0x1a, 0xe4, 0xe2, 0x6d, 0x93, 0x0d, 0xdd, 0x82, 0x3e,
	0x80, 0xc9, 0x3a, 0x12, 0x05, 0x5e, 0x90, 0x9a, 0x6a, 0x59, 0x6f, 0x57, 0xb9, 0x2e, 0x68, 0x42,
	0xd5, 0x78, 0x6f, 0xf7, 0x8f, 0x64, 0xbd, 0xfa, 0x85, 0x01, 0x66, 0x56, 0xee, 0x25, 0x5b, 0xe6,
	0x7d, 0x15, 0x2b, 0xdb, 0xb6, 0x48, 0x81, 0x68, 0xd0, 0x55, 0x38, 0x41, 0xfc, 0x30, 0x73, 0x25,
	0x19, 0x5c, 0x9a, 0x2a, 0xdc, 0x75, 0xb4, 0x6d, 0xe5, 0x4b, 0xc0, 0xa6, 0x5e, 0x53, 0x96, 0xb8,
	0x2b, 0xff, 0x97, 0xba, 0x71, 0xe7, 0xc3, 0x14, 0x9b, 0x4c, 0x15, 0xf7, 0xf6, 0x76, 0xac, 0x7f,
	0x77, 0xf5, 0x1f, 0x7b, 0x1b, 0xe4, 0x7a, 0x6f, 0x6b, 0x37, 0xf5, 0x89, 0x1d, 0x4f, 0xc8, 0xfa,
	0xc5, 0x00, 0xce, 0x94, 0xa7, 0xef, 0xc0, 0x48, 0x53, 0x69, 0xe7, 0x84, 0xaf, 0xf4, 0x9b, 0x7f,
	0xdf, 0xe7, 0xb6, 0xbc, 0x33, 0xd8, 0xa6, 0x62, 0x27, 0x84, 0xf7, 0x61, 0x5c, 0xcc, 0x97, 0x2b,
	0xd8, 0x31, 0xe2, 0xd8, 0x7e, 0x13, 0xef, 0x56, 0x7e, 0x13, 0xab, 0xde, 0x33, 0xe4, 0xb4, 0xe8,
	0x2c, 0xa3, 0x3f, 0x84, 0x14, 0x5f, 0x43, 0xa2, 0x88, 0x1b, 0x55, 0x6c, 0xbd, 0xcd, 0xeb, 0x84,
	0x66, 0x7a, 0x4c, 0xbd, 0x1b, 0x96, 0xb5, 0xf9, 0x4e, 0xb7, 0x67, 0x74, 0xde, 0x5d, 0x42, 0x23,
	0x18, 0xa9, 0x4a, 0x9a, 0x64, 0x02, 0x25, 0x73, 0x6d, 0x80, 0xf1, 0x93, 0xfa, 0xfa, 0x51, 0xcc,
	0xcd, 0xa1, 0x9d, 0xa3, 0x07, 0x70, 0x50, 0x17, 0xdd, 0x21, 0x85, 0x6f, 0xfc, 0xea, 0xdb, 0x16,
	0xf8, 0x25, 0x8c, 0xc3, 0x09, 0xb3, 0xca, 0xf1, 0x0c, 0x9b, 0xcc, 0xae, 0xc2, 0x0b, 0x70, 0xd2,
	0xe0, 0x24, 0x95, 0x8e, 0xe5, 0xd6, 0xd9, 0x64, 0x6e, 0x95, 0x4d, 0xe6, 0x72, 0x6c, 0x32, 0xbb,
	0x06, 0xa7, 0xe1, 0xe4, 0x2e, 0xc9, 0xe0, 0x55, 0x3a, 0x90, 0xcd, 0xc2, 0x2b, 0x70, 0x9a, 0xc3,
	0x0f, 0x9a, 0x58, 0xd5, 0x92, 0xa4, 0x47, 0xe8, 0x73, 0xd7, 0xd9, 0xe4, 0x1a, 0x9b, 0xbc, 0xc6,
	0x26, 0xd7, 0xd9, 0x64, 0xe6, 0x75, 0x36, 0x73, 0x9d, 0x4d, 0x66, 0x33, 0xf0, 0x3c, 0x8c, 0xdd,
	0xa8, 0x1c, 0xa2, 0x06, 0x8f, 0x2b, 0xa6, 0x61, 0x28, 0xcf, 0x66, 0xd6, 0x0b, 0x57, 0xe0, 0xb4,
	0xc9, 0x2a, 0x7c, 0x4d, 0x12, 0x78, 0x4c, 0x9f, 0x3b, 0x6e, 0x81, 0xc5, 0x27, 0x2d, 0x70, 0xf9,
	0xa4, 0x05, 0xa6, 0x72, 0xd7, 0xd8, 0x2c, 0x9b, 0x59, 0x65, 0x73, 0x85, 0x45, 0x38, 0x25, 0xc8,
	0x96, 0x0d, 0x73, 0xdc, 0x02, 0x17, 0xbf, 0x33, 0xde, 0xcb, 0xc4, 0x49, 0x0b, 0x84, 0x73, 0x19,
	0x36, 0x97, 0x65, 0x33, 0xd9, 0xc2, 0x32, 0x9c, 0x36, 0xd3, 0x2b, 0xd3, 0x74, 0xe1, 0xb8, 0x05,
	0x5e, 0x35, 0x4d, 0x97, 0x74, 0xd3, 0x7c, 0x86, 0xcd, 0x67, 0xd9, 0x7c, 0x4e, 0x9f, 0x45, 0x0b,
	0xeb, 0x50, 0x4f, 0x45, 0x2c, 0xdb, 0xa5, 0xe3, 0x16, 0x48, 0x99, 0xb6, 0x97, 0x88, 0x6c, 0x9e,
	0xcd, 0xad, 0xb1, 0x99, 0xdc, 0xe3, 0x8e, 0xb7, 0xbe, 0x90, 0x36, 0xb2, 0x38, 0x87, 0xaf, 0x5e,
	0x4f, 0xce, 0xf4, 0xcd, 0xea, 0xbe, 0x6b, 0x19, 0x76, 0x2d, 0xcb, 0xae, 0x91, 0x7a, 0x4a, 0xa1,
	0xf0, 0x65, 0x6a, 0xb1, 0x14, 0x0a, 0x47, 0xa8, 0x68, 0x29, 0x14, 0x4e, 0x50, 0x17, 0x4b, 0xa1,
	0xf0, 0x12, 0xf5, 0x6a, 0x29, 0x14, 0xbe, 0x44, 0xa5, 0x4a, 0xa1, 0x70, 0x96, 0xca, 0x95, 0x42,
	0xe1, 0x19, 0x8a, 0x2e, 0x85, 0xc2, 0x2f, 0x52, 0x0b, 0xa5, 0x50, 0xf8, 0x25, 0x2a, 0x91, 0xfa,
	0x13, 0x03, 0x63, 0x1b, 0x0a, 0x46, 0x1a, 0xb6, 0x89, 0xf9, 0xfa, 0x69, 0x89, 0x79, 0x54, 0x4e,
	0xbe, 0xe4, 0xc1, 0xc9, 0x1d, 0x6c, 0xfc, 0xee, 0xd0, 0x6c, 0xec, 0x01, 0xc4, 0xf7, 0xfb, 0x01,
	0xf1, 0x95, 0x9f, 0x5f, 0x1e, 0x90, 0x2a, 0xf0, 0xde, 0x54, 0x7c, 0x73, 0x78, 0x2a, 0x76, 0xc1,
	0xf0, 0xed, 0xa1, 0x61, 0xb8, 0x8b, 0x7d, 0x37, 0x87, 0x63, 0xdf, 0xb3, 0x83, 0xdd, 0x1b, 0xc3,
	0xc2, 0x6e, 0x1b, 0x70, 0xb9, 0x33, 0x01, 0x5c, 0x1f, 0x6a, 0xfb, 0x43, 0x6d, 0x7e, 0x50, 0xa8,
	0x75, 0xb1, 0xec, 0xde, 0xc8, 0x2c, 0xeb, 0x85, 0xb0, 0xef, 0x8e, 0x80, 0xb0, 0xff, 0x4d, 0xe4,
	0xba, 0x3e, 0x30, 0xb9, 0xba, 0x81, 0xf5, 0xe6, 0xb0, 0xc0, 0xda, 0xc1, 0xa9, 0x77, 0x46, 0xe2,
	0xd4, 0x6e, 0x3c, 0xdd, 0x1d, 0x1d, 0x4f, 0xbb, 0xa9, 0xb4, 0x38, 0x02, 0x95, 0xba, 0x61, 0x74,
	0x7b, 0x58, 0x18, 0xf5, 0xc6, 0xd0, 0xcd, 0x21, 0x31, 0xd4, 0x0d, 0xa0, 0xb7, 0x86, 0x07, 0x50,
	0x37, 0x70, 0xee, 0x8c, 0x0a, 0x9c, 0x5d, 0x80, 0xf9, 0xd6, 0x10, 0x80, 0xe9, 0xc4, 0xca, 0xed,
	0x1e, 0x58, 0x39, 0xe0, 0x22, 0xdc, 0xc9, 0x96, 0x6f, 0x9f, 0x9e, 0x2d, 0xdd, 0xe4, 0x78, 0xbf,
	0x2f, 0x39, 0x0e, 0xda, 0x2a, 0x2f, 0x6a, 0xac, 0x9e, 0x35, 0x34, 0xf6, 0xa2, 0xc2, 0x4f, 0x46,
	0xc3, 0xb4, 0x9f, 0xa3, 0xb3, 0xf3, 0x6e, 0x3a, 0xb3, 0x61, 0xea, 0x9d, 0xa1, 0x61, 0xca, 0xc5,
	0x50, 0x77, 0x47, 0x65, 0xa8, 0x4e, 0x74, 0xda, 0x19, 0x11, 0x9d, 0xba, 0x89, 0xe9, 0xcd, 0x53,
	0x13, 0x93, 0x8b, 0x86, 0x66, 0xfe, 0xf6, 0x56, 0xc7, 0x7f, 0x51, 0x15, 0x52, 0x9d, 0x7c, 0x32,
	0xf3, 0xf8, 0x39, 0x70, 0xdf, 0x2a, 0xcc, 0x3b, 0xd9, 0x64, 0xfa, 0xf1, 0x73, 0xd0, 0xbe, 0xd4,
	0xfd, 0xdd, 0x40, 0x42, 0xfc, 0x5d, 0xb7, 0x0a, 0x0b, 0x2e, 0x0a, 0x89, 0x3d, 0x7e, 0x0e, 0x1c,
	0xd7, 0x85, 0xcb, 0x5d, 0xac, 0x41, 0x3f, 0x7e, 0x0e, 0x3a, 0xee, 0xd9, 0x6c, 0x31, 0x43, 0xd1,
	0xa9, 0x3f, 0x33, 0x30, 0xce, 0x61, 0x59, 0x44, 0xbc, 0x0f, 0x0e, 0x3e, 0x38, 0xf8, 0xe0, 0xe0,
	0x83, 0x83, 0x0f, 0x0e, 0x3e, 0x38, 0xf8, 0xe0, 0xe0, 0x83, 0x83, 0x0f, 0x0e, 0x3e, 0x38, 0xf8,
	0xe0, 0xe0, 0x83, 0x43, 0x0f, 0x70, 0xf8, 0x23, 0x03, 0x23, 0xb7, 0xb0, 0xe6, 0x43, 0x83, 0x0f,
	0x0d, 0x3e, 0x34, 0xf8, 0xd0, 0xe0, 0x43, 0x83, 0x0f, 0x0d, 0x3e, 0x34, 0xf8, 0xd0, 0xe0, 0x43,
	0x83, 0x0f, 0x0d, 0x3e, 0x34, 0xf8, 0xd0, 0xe0, 0x0d, 0x0d, 0xff, 0xa0, 0xe0, 0x8c, 0xdd, 0x55,
	0x3a, 0x0a, 0xe8, 0xd1, 0xd0, 0x1b, 0x70, 0xa6, 0x22, 0xa8, 0x68, 0x5f, 0xc4, 0x65, 0xbb, 0xdb,
	0x48, 0x3e, 0xdf, 0x9b, 0x03, 0x28, 0xd3, 0xc1, 0x16, 0xa3, 0x3f, 0x80, 0x2f, 0xe2, 0x06, 0xd1,
	0xf8, 0x14, 0x1d, 0x22, 0x95, 0x57, 0x04, 0x59, 0x73, 0xc8, 0x05, 0xfb, 0xca, 0x5d, 0x30, 0x5c,
	0x4b, 0xb6, 0x67, 0x5b, 0x77, 0x07, 0x32, 0xa6, 0x2e, 0x8f, 0x64, 0x8d, 0xaf, 0x21, 0x87, 0x68,
	0xa8, 0xaf, 0xe8, 0x79, 0xc3, 0x6f, 0xc3, 0x70, 0x6b, 0x2b, 0xfe, 0x27, 0x65, 0x7d, 0x97, 0x86,
	0xcc, 0xfa, 0x1c, 0xc9, 0x51, 0xff, 0x94, 0xcf, 0x2b, 0x39, 0x7a, 0x6d, 0xe0, 0xb4, 0x22, 0xd0,
	0x33, 0x39, 0xba, 0x7a, 0x8a, 0x7c, 0x22, 0xe0, 0x4a, 0x8e, 0xba, 0x57, 0x8f, 0xf1, 0x51, 0x56,
	0x0f, 0x8b, 0x71, 0x26, 0x46, 0x3a, 0x3e, 0x34, 0x79, 0x06, 0xc7, 0x87, 0xce, 0x96, 0x4d, 0x1e,
	0xf4, 0x5e, 0x7a, 0xe0, 0x70, 0xbb, 0xa3, 0xc3, 0xd6, 0xee, 0xe8, 0x5e, 0x8b, 0x50, 0xe7, 0xf9,
	0xa7, 0xc8, 0x19, 0x9f, 0x7f, 0xea, 0x3c, 0x4d, 0x10, 0x3d, 0xc3, 0xd3, 0x04, 0xd3, 0xff, 0xc6,
	0xd3, 0x04, 0xb1, 0xb3, 0x3d, 0x4d, 0xf0, 0x3f, 0xae, 0xef, 0x2d, 0x54, 0x9f, 0xad, 0xde, 0x24,
	0xee, 0x62, 0xd0, 0xf9, 0xd5, 0x25, 0xef, 0xfe, 0xea, 0x32, 0x43, 0xce, 0x42, 0xce, 0x38, 0x37,
	0x0e, 0x1b, 0x47, 0x22, 0x83, 0xae, 0x0f, 0x31, 0xf7, 0xbb, 0x3f, 0xc4, 0xd0, 0x03, 0x1e, 0x0a,
	0x8c, 0x1c, 0x1b, 0x67, 0xf7, 0x82, 0x10, 0xe8, 0xaa, 0x9d, 0x5f, 0x65, 0x3e, 0xf6, 0xfe, 0x2a,
	0x33, 0x7b, 0xda, 0x23, 0x02, 0xc5, 0xa0, 0xd7, 0x97, 0x99, 0x5e, 0x99, 0xfd, 0xdc, 0x50, 0x99,
	0xfd, 0x1b, 0x87, 0x5d, 0xab, 0xf8, 0xb7, 0x2d, 0x80, 0x60, 0xc4, 0xde, 0x52, 0x0d, 0x32, 0xf0,
	0x7c, 0x7b, 0x3b, 0x75, 0x24, 0xb7, 0xca, 0xe6, 0x57, 0xd9, 0xcc, 0x1a, 0x9b, 0x59, 0x85, 0x97,
	0x3b, 0x37, 0x4f, 0xcf, 0xae, 0xb1, 0xeb, 0xec, 0x35, 0xf6, 0x3a, 0x9b, 0xc9, 0xb0, 0x99, 0x2c,
	0x9b, 0xc9, 0xb1, 0x99, 0x3c, 0x9c, 0xeb, 0xda, 0x3a, 0x1d, 0xc8, 0xae, 0x16, 0x16, 0xbb, 0xd3,
	0x19, 0x7a, 0xe6, 0xb8, 0x05, 0x02, 0xe4, 0xac, 0x42, 0x0b, 0x8c, 0x67, 0xd9, 0x1c, 0x9b, 0x2f,
	0x64, 0x9d, 0xd9, 0xc2, 0xa2, 0xf7, 0xbe, 0xe9, 0x5c, 0xce, 0x9d, 0x45, 0xe4, 0x5d, 0x19, 0xc2,
	0x95, 0x5e, 0x3b, 0xa8, 0x3b, 0x32, 0x87, 0x6b, 0x9d, 0xb9, 0x8b, 0xee, 0x48, 0x99, 0x8e, 0x71,
	0xbd, 0x45, 0x99, 0x75, 0x36, 0x73, 0xbd, 0x2b, 0xa1, 0x29, 0x85, 0xc2, 0x80, 0x0a, 0x74, 0x6c,
	0x8b, 0x9e, 0xa2, 0x60, 0x29, 0x14, 0x8e, 0x53, 0x54, 0xea, 0xf7, 0xe3, 0x70, 0x96, 0x6b, 0x27,
	0xe6, 0x76, 0x82, 0x71, 0x13, 0xce, 0x1a, 0x39, 0x6c, 0xd9, 0x95, 0xe8, 0xf7, 0xcf, 0x09, 0x66,
	0x0c, 0x17, 0x87, 0x1e, 0xbd, 0x09, 0x69, 0x24, 0xcb, 0xe2, 0x91, 0x5b, 0xa6, 0x7f, 0x16, 0x40,
	0x11, 0x0f, 0xa7, 0x0a, 0x86, 0xb3, 0x7c, 0x53, 0xd5, 0xa4, 0xba, 0x5b, 0x66, 0xdc, 0x73, 0x55,
	0x24, 0x67, 0xa3, 0x3b, 0x36, 0xee, 0xc7, 0x3b, 0x8e, 0xd1, 0x90, 0xaf, 0x8a, 0x44, 0xd1, 0x59,
	0x4d, 0xc7, 0x72, 0x30, 0x31, 0xda, 0x72, 0xd0, 0xbd, 0x6a, 0xc2, 0xb3, 0x58, 0x35, 0xc3, 0xa7,
	0x5f, 0x35, 0xef, 0xb5, 0x57, 0xcd, 0xa9, 0xd3, 0xad, 0x9a, 0x73, 0x9e, 0xc7, 0x48, 0x2c, 0xb5,
	0x37, 0xfe, 0xd7, 0xeb, 0xed, 0xbc, 0xea, 0x7c, 0x3b, 0xb3, 0x70, 0x01, 0x52, 0x44, 0x31, 0xb9,
	0xa3, 0xe0, 0x8a, 0xc0, 0x23, 0x0d, 0xab, 0x74, 0x78, 0x9d, 0xcd, 0xac, 0xb2, 0xd7, 0xd9, 0xd7,
	0xf5, 0x94, 0xda, 0x78, 0xbb, 0xec, 0x94, 0xfa, 0xb8, 0x05, 0x82, 0x4f, 0x5a, 0x20, 0xa0, 0x0f,
	0xe9, 0x1c, 0x9b, 0x67, 0xd7, 0x4a, 0xa1, 0x70, 0x80, 0x0a, 0x96, 0x42, 0xe1, 0x49, 0x2a, 0x5c,
	0xf8, 0x2d, 0x78, 0xf2, 0x43, 0x62, 0xec, 0xe9, 0x0f, 0x89, 0xb1, 0x9f, 0x7e, 0x48, 0x80, 0x2f,
	0x4e, 0x12, 0xe0, 0x77, 0x27, 0x09, 0xf0, 0xdd, 0x49, 0x02, 0x3c, 0x39, 0x49, 0x80, 0xa7, 0x27,
	0x09, 0xf0, 0xfd, 0x49, 0x02, 0xfc, 0x78, 0x92, 0x18, 0xfb, 0xe9, 0x24, 0x01, 0x7e, 0xf3, 0x2c,
	0x31, 0x76, 0xfc, 0x2c, 0x01, 0x9e, 0x3c, 0x4b, 0x8c, 0x3d, 0x7d, 0x96, 0x18, 0xfb, 0xe8, 0x5e,
	0x55, 0x92, 0x3f, 0xab, 0xa6, 0x0f, 0x25, 0x51, 0xc3, 0x8a, 0x82, 0xd2, 0x4d, 0x75, 0x85, 0xfc,
	0x38, 0x90, 0x94, 0xfa, 0xb2, 0xac, 0x48, 0x87, 0x42, 0x05, 0x2b, 0xcb, 0x56, 0xf1, 0x8a, 0xbc,
	0x5f, 0x95, 0x56, 0xf0, 0xe7, 0x9a, 0xf5, 0x17, 0x0b, 0x7a, 0xfe, 0xe1, 0x82, 0xfd, 0x09, 0x32,
	0xa1, 0xe5, 0xfe, 0x15, 0x00, 0x00, 0xff, 0xff, 0xf3, 0xd5, 0xe8, 0xc8, 0xe4, 0x40, 0x00, 0x00,
}

func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.DstIpChoice == nil {
		if this.DstIpChoice != nil {
			return false
		}
	} else if this.DstIpChoice == nil {
		return false
	} else if !this.DstIpChoice.Equal(that1.DstIpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if that1.DstAsnChoice == nil {
		if this.DstAsnChoice != nil {
			return false
		}
	} else if this.DstAsnChoice == nil {
		return false
	} else if !this.DstAsnChoice.Equal(that1.DstAsnChoice) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if !this.VirtualHostMatcher.Equal(that1.VirtualHostMatcher) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if len(this.ForwardingClass) != len(that1.ForwardingClass) {
		return false
	}
	for i := range this.ForwardingClass {
		if !this.ForwardingClass[i].Equal(that1.ForwardingClass[i]) {
			return false
		}
	}
	if !this.MaliciousUserMitigationBypass.Equal(that1.MaliciousUserMitigationBypass) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if this.ChallengeAction != that1.ChallengeAction {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyClient)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ClientName)
	if !ok {
		that2, ok := that.(GlobalSpecType_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *GlobalSpecType_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ClientSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ClientNameMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyIp)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IpPrefixList)
	if !ok {
		that2, ok := that.(GlobalSpecType_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IpMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AnyDstIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyDstIp)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyDstIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstIp.Equal(that1.AnyDstIp) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DstIpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DstIpPrefixList)
	if !ok {
		that2, ok := that.(GlobalSpecType_DstIpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DstIpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DstIpMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_DstIpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpMatcher.Equal(that1.DstIpMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyAsn)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AsnList)
	if !ok {
		that2, ok := that.(GlobalSpecType_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AsnMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AnyDstAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyDstAsn)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyDstAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstAsn.Equal(that1.AnyDstAsn) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DstAsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DstAsnList)
	if !ok {
		that2, ok := that.(GlobalSpecType_DstAsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnList.Equal(that1.DstAsnList) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DstAsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DstAsnMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_DstAsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnMatcher.Equal(that1.DstAsnMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.DstIpChoice == nil {
		if this.DstIpChoice != nil {
			return false
		}
	} else if this.DstIpChoice == nil {
		return false
	} else if !this.DstIpChoice.Equal(that1.DstIpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if that1.DstAsnChoice == nil {
		if this.DstAsnChoice != nil {
			return false
		}
	} else if this.DstAsnChoice == nil {
		return false
	} else if !this.DstAsnChoice.Equal(that1.DstAsnChoice) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if !this.VirtualHostMatcher.Equal(that1.VirtualHostMatcher) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if !this.MaliciousUserMitigationBypass.Equal(that1.MaliciousUserMitigationBypass) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if this.ChallengeAction != that1.ChallengeAction {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyClient)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *CreateSpecType_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ClientName)
	if !ok {
		that2, ok := that.(CreateSpecType_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *CreateSpecType_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ClientSelector)
	if !ok {
		that2, ok := that.(CreateSpecType_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *CreateSpecType_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ClientNameMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyIp)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *CreateSpecType_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IpPrefixList)
	if !ok {
		that2, ok := that.(CreateSpecType_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *CreateSpecType_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IpMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyDstIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyDstIp)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyDstIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstIp.Equal(that1.AnyDstIp) {
		return false
	}
	return true
}
func (this *CreateSpecType_DstIpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DstIpPrefixList)
	if !ok {
		that2, ok := that.(CreateSpecType_DstIpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DstIpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DstIpMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_DstIpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpMatcher.Equal(that1.DstIpMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyAsn)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *CreateSpecType_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AsnList)
	if !ok {
		that2, ok := that.(CreateSpecType_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *CreateSpecType_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AsnMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_AnyDstAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyDstAsn)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyDstAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstAsn.Equal(that1.AnyDstAsn) {
		return false
	}
	return true
}
func (this *CreateSpecType_DstAsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DstAsnList)
	if !ok {
		that2, ok := that.(CreateSpecType_DstAsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnList.Equal(that1.DstAsnList) {
		return false
	}
	return true
}
func (this *CreateSpecType_DstAsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DstAsnMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_DstAsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnMatcher.Equal(that1.DstAsnMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.DstIpChoice == nil {
		if this.DstIpChoice != nil {
			return false
		}
	} else if this.DstIpChoice == nil {
		return false
	} else if !this.DstIpChoice.Equal(that1.DstIpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if that1.DstAsnChoice == nil {
		if this.DstAsnChoice != nil {
			return false
		}
	} else if this.DstAsnChoice == nil {
		return false
	} else if !this.DstAsnChoice.Equal(that1.DstAsnChoice) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if !this.VirtualHostMatcher.Equal(that1.VirtualHostMatcher) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if !this.MaliciousUserMitigationBypass.Equal(that1.MaliciousUserMitigationBypass) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if this.ChallengeAction != that1.ChallengeAction {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyClient)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ClientName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ClientSelector)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ClientNameMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyIp)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IpPrefixList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IpMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyDstIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyDstIp)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyDstIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstIp.Equal(that1.AnyDstIp) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DstIpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DstIpPrefixList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DstIpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DstIpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DstIpMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DstIpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpMatcher.Equal(that1.DstIpMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyAsn)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AsnList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AsnMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AnyDstAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyDstAsn)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyDstAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstAsn.Equal(that1.AnyDstAsn) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DstAsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DstAsnList)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DstAsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnList.Equal(that1.DstAsnList) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DstAsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DstAsnMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DstAsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnMatcher.Equal(that1.DstAsnMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ClientRole.Equal(that1.ClientRole) {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	if !this.LabelMatcher.Equal(that1.LabelMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.DstIpChoice == nil {
		if this.DstIpChoice != nil {
			return false
		}
	} else if this.DstIpChoice == nil {
		return false
	} else if !this.DstIpChoice.Equal(that1.DstIpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if that1.DstAsnChoice == nil {
		if this.DstAsnChoice != nil {
			return false
		}
	} else if this.DstAsnChoice == nil {
		return false
	} else if !this.DstAsnChoice.Equal(that1.DstAsnChoice) {
		return false
	}
	if !this.ApiGroupMatcher.Equal(that1.ApiGroupMatcher) {
		return false
	}
	if !this.PortMatcher.Equal(that1.PortMatcher) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if !this.WafAction.Equal(that1.WafAction) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if len(this.RateLimiter) != len(that1.RateLimiter) {
		return false
	}
	for i := range this.RateLimiter {
		if !this.RateLimiter[i].Equal(that1.RateLimiter[i]) {
			return false
		}
	}
	if !this.VirtualHostMatcher.Equal(that1.VirtualHostMatcher) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if !this.MaliciousUserMitigationBypass.Equal(that1.MaliciousUserMitigationBypass) {
		return false
	}
	if len(this.Scheme) != len(that1.Scheme) {
		return false
	}
	for i := range this.Scheme {
		if this.Scheme[i] != that1.Scheme[i] {
			return false
		}
	}
	if !this.UrlMatcher.Equal(that1.UrlMatcher) {
		return false
	}
	if !this.L4DestMatcher.Equal(that1.L4DestMatcher) {
		return false
	}
	if this.ChallengeAction != that1.ChallengeAction {
		return false
	}
	if len(this.GotoPolicy) != len(that1.GotoPolicy) {
		return false
	}
	for i := range this.GotoPolicy {
		if !this.GotoPolicy[i].Equal(that1.GotoPolicy[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyClient)
	if !ok {
		that2, ok := that.(GetSpecType_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *GetSpecType_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ClientName)
	if !ok {
		that2, ok := that.(GetSpecType_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *GetSpecType_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ClientSelector)
	if !ok {
		that2, ok := that.(GetSpecType_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *GetSpecType_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ClientNameMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyIp)
	if !ok {
		that2, ok := that.(GetSpecType_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *GetSpecType_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IpPrefixList)
	if !ok {
		that2, ok := that.(GetSpecType_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *GetSpecType_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IpMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AnyDstIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyDstIp)
	if !ok {
		that2, ok := that.(GetSpecType_AnyDstIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstIp.Equal(that1.AnyDstIp) {
		return false
	}
	return true
}
func (this *GetSpecType_DstIpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DstIpPrefixList)
	if !ok {
		that2, ok := that.(GetSpecType_DstIpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpPrefixList.Equal(that1.DstIpPrefixList) {
		return false
	}
	return true
}
func (this *GetSpecType_DstIpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DstIpMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_DstIpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstIpMatcher.Equal(that1.DstIpMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyAsn)
	if !ok {
		that2, ok := that.(GetSpecType_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *GetSpecType_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AsnList)
	if !ok {
		that2, ok := that.(GetSpecType_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *GetSpecType_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AsnMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_AnyDstAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyDstAsn)
	if !ok {
		that2, ok := that.(GetSpecType_AnyDstAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyDstAsn.Equal(that1.AnyDstAsn) {
		return false
	}
	return true
}
func (this *GetSpecType_DstAsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DstAsnList)
	if !ok {
		that2, ok := that.(GetSpecType_DstAsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnList.Equal(that1.DstAsnList) {
		return false
	}
	return true
}
func (this *GetSpecType_DstAsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DstAsnMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_DstAsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DstAsnMatcher.Equal(that1.DstAsnMatcher) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ChallengeAction == nil {
		if this.ChallengeAction != nil {
			return false
		}
	} else if this.ChallengeAction == nil {
		return false
	} else if !this.ChallengeAction.Equal(that1.ChallengeAction) {
		return false
	}
	if that1.IpChoice == nil {
		if this.IpChoice != nil {
			return false
		}
	} else if this.IpChoice == nil {
		return false
	} else if !this.IpChoice.Equal(that1.IpChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if !this.BodyMatcher.Equal(that1.BodyMatcher) {
		return false
	}
	if len(this.ArgMatchers) != len(that1.ArgMatchers) {
		return false
	}
	for i := range this.ArgMatchers {
		if !this.ArgMatchers[i].Equal(that1.ArgMatchers[i]) {
			return false
		}
	}
	if len(this.CookieMatchers) != len(that1.CookieMatchers) {
		return false
	}
	for i := range this.CookieMatchers {
		if !this.CookieMatchers[i].Equal(that1.CookieMatchers[i]) {
			return false
		}
	}
	if that1.ClientChoice == nil {
		if this.ClientChoice != nil {
			return false
		}
	} else if this.ClientChoice == nil {
		return false
	} else if !this.ClientChoice.Equal(that1.ClientChoice) {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_DisableChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_DisableChallenge)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_DisableChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableChallenge.Equal(that1.DisableChallenge) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_EnableJavascriptChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_EnableJavascriptChallenge)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_EnableJavascriptChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableJavascriptChallenge.Equal(that1.EnableJavascriptChallenge) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_EnableCaptchaChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_EnableCaptchaChallenge)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_EnableCaptchaChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableCaptchaChallenge.Equal(that1.EnableCaptchaChallenge) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AnyIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AnyIp)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AnyIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIp.Equal(that1.AnyIp) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_IpPrefixList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_IpPrefixList)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_IpPrefixList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_IpMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_IpMatcher)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_IpMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpMatcher.Equal(that1.IpMatcher) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AnyAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AnyAsn)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AnyAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyAsn.Equal(that1.AnyAsn) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AsnList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AsnList)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AsnList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AsnMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AsnMatcher)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AsnMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AsnMatcher.Equal(that1.AsnMatcher) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_AnyClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_AnyClient)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_AnyClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyClient.Equal(that1.AnyClient) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_ClientName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_ClientName)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_ClientName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientName != that1.ClientName {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_ClientSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_ClientSelector)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_ClientSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientSelector.Equal(that1.ClientSelector) {
		return false
	}
	return true
}
func (this *ChallengeRuleSpec_ClientNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeRuleSpec_ClientNameMatcher)
	if !ok {
		that2, ok := that.(ChallengeRuleSpec_ClientNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientNameMatcher.Equal(that1.ClientNameMatcher) {
		return false
	}
	return true
}
func (this *RateLimiterRuleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimiterRuleSpec)
	if !ok {
		that2, ok := that.(RateLimiterRuleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionChoice == nil {
		if this.ActionChoice != nil {
			return false
		}
	} else if this.ActionChoice == nil {
		return false
	} else if !this.ActionChoice.Equal(that1.ActionChoice) {
		return false
	}
	if !this.HttpMethod.Equal(that1.HttpMethod) {
		return false
	}
	if !this.DomainMatcher.Equal(that1.DomainMatcher) {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	return true
}
func (this *RateLimiterRuleSpec_BypassRateLimiter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimiterRuleSpec_BypassRateLimiter)
	if !ok {
		that2, ok := that.(RateLimiterRuleSpec_BypassRateLimiter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BypassRateLimiter.Equal(that1.BypassRateLimiter) {
		return false
	}
	return true
}
func (this *RateLimiterRuleSpec_ApplyRateLimiter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimiterRuleSpec_ApplyRateLimiter)
	if !ok {
		that2, ok := that.(RateLimiterRuleSpec_ApplyRateLimiter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ApplyRateLimiter.Equal(that1.ApplyRateLimiter) {
		return false
	}
	return true
}
func (this *RateLimiterRuleSpec_CustomRateLimiter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimiterRuleSpec_CustomRateLimiter)
	if !ok {
		that2, ok := that.(RateLimiterRuleSpec_CustomRateLimiter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomRateLimiter.Equal(that1.CustomRateLimiter) {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 46)
	s = append(s, "&service_policy_rule.GlobalSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.DstIpChoice != nil {
		s = append(s, "DstIpChoice: "+fmt.Sprintf("%#v", this.DstIpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DstAsnChoice != nil {
		s = append(s, "DstAsnChoice: "+fmt.Sprintf("%#v", this.DstAsnChoice)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.VirtualHostMatcher != nil {
		s = append(s, "VirtualHostMatcher: "+fmt.Sprintf("%#v", this.VirtualHostMatcher)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.ForwardingClass != nil {
		s = append(s, "ForwardingClass: "+fmt.Sprintf("%#v", this.ForwardingClass)+",\n")
	}
	if this.MaliciousUserMitigationBypass != nil {
		s = append(s, "MaliciousUserMitigationBypass: "+fmt.Sprintf("%#v", this.MaliciousUserMitigationBypass)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AnyDstIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyDstIp{` +
		`AnyDstIp:` + fmt.Sprintf("%#v", this.AnyDstIp) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DstIpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_DstIpPrefixList{` +
		`DstIpPrefixList:` + fmt.Sprintf("%#v", this.DstIpPrefixList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DstIpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_DstIpMatcher{` +
		`DstIpMatcher:` + fmt.Sprintf("%#v", this.DstIpMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AnyDstAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_AnyDstAsn{` +
		`AnyDstAsn:` + fmt.Sprintf("%#v", this.AnyDstAsn) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DstAsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_DstAsnList{` +
		`DstAsnList:` + fmt.Sprintf("%#v", this.DstAsnList) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DstAsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GlobalSpecType_DstAsnMatcher{` +
		`DstAsnMatcher:` + fmt.Sprintf("%#v", this.DstAsnMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 45)
	s = append(s, "&service_policy_rule.CreateSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.DstIpChoice != nil {
		s = append(s, "DstIpChoice: "+fmt.Sprintf("%#v", this.DstIpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DstAsnChoice != nil {
		s = append(s, "DstAsnChoice: "+fmt.Sprintf("%#v", this.DstAsnChoice)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.VirtualHostMatcher != nil {
		s = append(s, "VirtualHostMatcher: "+fmt.Sprintf("%#v", this.VirtualHostMatcher)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.MaliciousUserMitigationBypass != nil {
		s = append(s, "MaliciousUserMitigationBypass: "+fmt.Sprintf("%#v", this.MaliciousUserMitigationBypass)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AnyDstIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyDstIp{` +
		`AnyDstIp:` + fmt.Sprintf("%#v", this.AnyDstIp) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DstIpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_DstIpPrefixList{` +
		`DstIpPrefixList:` + fmt.Sprintf("%#v", this.DstIpPrefixList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DstIpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_DstIpMatcher{` +
		`DstIpMatcher:` + fmt.Sprintf("%#v", this.DstIpMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AnyDstAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_AnyDstAsn{` +
		`AnyDstAsn:` + fmt.Sprintf("%#v", this.AnyDstAsn) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DstAsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_DstAsnList{` +
		`DstAsnList:` + fmt.Sprintf("%#v", this.DstAsnList) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DstAsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.CreateSpecType_DstAsnMatcher{` +
		`DstAsnMatcher:` + fmt.Sprintf("%#v", this.DstAsnMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 45)
	s = append(s, "&service_policy_rule.ReplaceSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.DstIpChoice != nil {
		s = append(s, "DstIpChoice: "+fmt.Sprintf("%#v", this.DstIpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DstAsnChoice != nil {
		s = append(s, "DstAsnChoice: "+fmt.Sprintf("%#v", this.DstAsnChoice)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.VirtualHostMatcher != nil {
		s = append(s, "VirtualHostMatcher: "+fmt.Sprintf("%#v", this.VirtualHostMatcher)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.MaliciousUserMitigationBypass != nil {
		s = append(s, "MaliciousUserMitigationBypass: "+fmt.Sprintf("%#v", this.MaliciousUserMitigationBypass)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AnyDstIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyDstIp{` +
		`AnyDstIp:` + fmt.Sprintf("%#v", this.AnyDstIp) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DstIpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_DstIpPrefixList{` +
		`DstIpPrefixList:` + fmt.Sprintf("%#v", this.DstIpPrefixList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DstIpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_DstIpMatcher{` +
		`DstIpMatcher:` + fmt.Sprintf("%#v", this.DstIpMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AnyDstAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_AnyDstAsn{` +
		`AnyDstAsn:` + fmt.Sprintf("%#v", this.AnyDstAsn) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DstAsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_DstAsnList{` +
		`DstAsnList:` + fmt.Sprintf("%#v", this.DstAsnList) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DstAsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ReplaceSpecType_DstAsnMatcher{` +
		`DstAsnMatcher:` + fmt.Sprintf("%#v", this.DstAsnMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 45)
	s = append(s, "&service_policy_rule.GetSpecType{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ClientRole != nil {
		s = append(s, "ClientRole: "+fmt.Sprintf("%#v", this.ClientRole)+",\n")
	}
	if this.ServerSelector != nil {
		s = append(s, "ServerSelector: "+fmt.Sprintf("%#v", this.ServerSelector)+",\n")
	}
	if this.LabelMatcher != nil {
		s = append(s, "LabelMatcher: "+fmt.Sprintf("%#v", this.LabelMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.DstIpChoice != nil {
		s = append(s, "DstIpChoice: "+fmt.Sprintf("%#v", this.DstIpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DstAsnChoice != nil {
		s = append(s, "DstAsnChoice: "+fmt.Sprintf("%#v", this.DstAsnChoice)+",\n")
	}
	if this.ApiGroupMatcher != nil {
		s = append(s, "ApiGroupMatcher: "+fmt.Sprintf("%#v", this.ApiGroupMatcher)+",\n")
	}
	if this.PortMatcher != nil {
		s = append(s, "PortMatcher: "+fmt.Sprintf("%#v", this.PortMatcher)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.WafAction != nil {
		s = append(s, "WafAction: "+fmt.Sprintf("%#v", this.WafAction)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.RateLimiter != nil {
		s = append(s, "RateLimiter: "+fmt.Sprintf("%#v", this.RateLimiter)+",\n")
	}
	if this.VirtualHostMatcher != nil {
		s = append(s, "VirtualHostMatcher: "+fmt.Sprintf("%#v", this.VirtualHostMatcher)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.MaliciousUserMitigationBypass != nil {
		s = append(s, "MaliciousUserMitigationBypass: "+fmt.Sprintf("%#v", this.MaliciousUserMitigationBypass)+",\n")
	}
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	if this.UrlMatcher != nil {
		s = append(s, "UrlMatcher: "+fmt.Sprintf("%#v", this.UrlMatcher)+",\n")
	}
	if this.L4DestMatcher != nil {
		s = append(s, "L4DestMatcher: "+fmt.Sprintf("%#v", this.L4DestMatcher)+",\n")
	}
	s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	if this.GotoPolicy != nil {
		s = append(s, "GotoPolicy: "+fmt.Sprintf("%#v", this.GotoPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AnyDstIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyDstIp{` +
		`AnyDstIp:` + fmt.Sprintf("%#v", this.AnyDstIp) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DstIpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_DstIpPrefixList{` +
		`DstIpPrefixList:` + fmt.Sprintf("%#v", this.DstIpPrefixList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DstIpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_DstIpMatcher{` +
		`DstIpMatcher:` + fmt.Sprintf("%#v", this.DstIpMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AnyDstAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_AnyDstAsn{` +
		`AnyDstAsn:` + fmt.Sprintf("%#v", this.AnyDstAsn) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DstAsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_DstAsnList{` +
		`DstAsnList:` + fmt.Sprintf("%#v", this.DstAsnList) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DstAsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.GetSpecType_DstAsnMatcher{` +
		`DstAsnMatcher:` + fmt.Sprintf("%#v", this.DstAsnMatcher) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 27)
	s = append(s, "&service_policy_rule.ChallengeRuleSpec{")
	if this.ChallengeAction != nil {
		s = append(s, "ChallengeAction: "+fmt.Sprintf("%#v", this.ChallengeAction)+",\n")
	}
	if this.IpChoice != nil {
		s = append(s, "IpChoice: "+fmt.Sprintf("%#v", this.IpChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	if this.BodyMatcher != nil {
		s = append(s, "BodyMatcher: "+fmt.Sprintf("%#v", this.BodyMatcher)+",\n")
	}
	if this.ArgMatchers != nil {
		s = append(s, "ArgMatchers: "+fmt.Sprintf("%#v", this.ArgMatchers)+",\n")
	}
	if this.CookieMatchers != nil {
		s = append(s, "CookieMatchers: "+fmt.Sprintf("%#v", this.CookieMatchers)+",\n")
	}
	if this.ClientChoice != nil {
		s = append(s, "ClientChoice: "+fmt.Sprintf("%#v", this.ClientChoice)+",\n")
	}
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChallengeRuleSpec_DisableChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_DisableChallenge{` +
		`DisableChallenge:` + fmt.Sprintf("%#v", this.DisableChallenge) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_EnableJavascriptChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_EnableJavascriptChallenge{` +
		`EnableJavascriptChallenge:` + fmt.Sprintf("%#v", this.EnableJavascriptChallenge) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_EnableCaptchaChallenge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_EnableCaptchaChallenge{` +
		`EnableCaptchaChallenge:` + fmt.Sprintf("%#v", this.EnableCaptchaChallenge) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AnyIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AnyIp{` +
		`AnyIp:` + fmt.Sprintf("%#v", this.AnyIp) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_IpPrefixList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_IpPrefixList{` +
		`IpPrefixList:` + fmt.Sprintf("%#v", this.IpPrefixList) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_IpMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_IpMatcher{` +
		`IpMatcher:` + fmt.Sprintf("%#v", this.IpMatcher) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AnyAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AnyAsn{` +
		`AnyAsn:` + fmt.Sprintf("%#v", this.AnyAsn) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AsnList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AsnList{` +
		`AsnList:` + fmt.Sprintf("%#v", this.AsnList) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AsnMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AsnMatcher{` +
		`AsnMatcher:` + fmt.Sprintf("%#v", this.AsnMatcher) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_AnyClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_AnyClient{` +
		`AnyClient:` + fmt.Sprintf("%#v", this.AnyClient) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_ClientName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_ClientName{` +
		`ClientName:` + fmt.Sprintf("%#v", this.ClientName) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_ClientSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_ClientSelector{` +
		`ClientSelector:` + fmt.Sprintf("%#v", this.ClientSelector) + `}`}, ", ")
	return s
}
func (this *ChallengeRuleSpec_ClientNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.ChallengeRuleSpec_ClientNameMatcher{` +
		`ClientNameMatcher:` + fmt.Sprintf("%#v", this.ClientNameMatcher) + `}`}, ", ")
	return s
}
func (this *RateLimiterRuleSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&service_policy_rule.RateLimiterRuleSpec{")
	if this.ActionChoice != nil {
		s = append(s, "ActionChoice: "+fmt.Sprintf("%#v", this.ActionChoice)+",\n")
	}
	if this.HttpMethod != nil {
		s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	}
	if this.DomainMatcher != nil {
		s = append(s, "DomainMatcher: "+fmt.Sprintf("%#v", this.DomainMatcher)+",\n")
	}
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RateLimiterRuleSpec_BypassRateLimiter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.RateLimiterRuleSpec_BypassRateLimiter{` +
		`BypassRateLimiter:` + fmt.Sprintf("%#v", this.BypassRateLimiter) + `}`}, ", ")
	return s
}
func (this *RateLimiterRuleSpec_ApplyRateLimiter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.RateLimiterRuleSpec_ApplyRateLimiter{` +
		`ApplyRateLimiter:` + fmt.Sprintf("%#v", this.ApplyRateLimiter) + `}`}, ", ")
	return s
}
func (this *RateLimiterRuleSpec_CustomRateLimiter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service_policy_rule.RateLimiterRuleSpec_CustomRateLimiter{` +
		`CustomRateLimiter:` + fmt.Sprintf("%#v", this.CustomRateLimiter) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GotoPolicy) > 0 {
		for iNdEx := len(m.GotoPolicy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GotoPolicy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if m.ChallengeAction != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeAction))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.DstAsnChoice != nil {
		{
			size := m.DstAsnChoice.Size()
			i -= size
			if _, err := m.DstAsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.L4DestMatcher != nil {
		{
			size, err := m.L4DestMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.DstIpChoice != nil {
		{
			size := m.DstIpChoice.Size()
			i -= size
			if _, err := m.DstIpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UrlMatcher != nil {
		{
			size, err := m.UrlMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.Scheme) > 0 {
		for iNdEx := len(m.Scheme) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scheme[iNdEx])
			copy(dAtA[i:], m.Scheme[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Scheme[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.ClientChoice != nil {
		{
			size := m.ClientChoice.Size()
			i -= size
			if _, err := m.ClientChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AsnChoice != nil {
		{
			size := m.AsnChoice.Size()
			i -= size
			if _, err := m.AsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IpChoice != nil {
		{
			size := m.IpChoice.Size()
			i -= size
			if _, err := m.IpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MaliciousUserMitigationBypass != nil {
		{
			size, err := m.MaliciousUserMitigationBypass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.ForwardingClass) > 0 {
		for iNdEx := len(m.ForwardingClass) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForwardingClass[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.TlsFingerprintMatcher != nil {
		{
			size, err := m.TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.VirtualHostMatcher != nil {
		{
			size, err := m.VirtualHostMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.RateLimiter) > 0 {
		for iNdEx := len(m.RateLimiter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.DomainMatcher != nil {
		{
			size, err := m.DomainMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.BodyMatcher != nil {
		{
			size, err := m.BodyMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.WafAction != nil {
		{
			size, err := m.WafAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.CookieMatchers) > 0 {
		for iNdEx := len(m.CookieMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.ArgMatchers) > 0 {
		for iNdEx := len(m.ArgMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArgMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ApiGroupMatcher != nil {
		{
			size, err := m.ApiGroupMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ClientRole != nil {
		{
			size, err := m.ClientRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.HttpMethod != nil {
		{
			size, err := m.HttpMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_ClientName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ClientName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClientName)
	copy(dAtA[i:], m.ClientName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ClientSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientSelector != nil {
		{
			size, err := m.ClientSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ClientNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientNameMatcher != nil {
		{
			size, err := m.ClientNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_IpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpMatcher != nil {
		{
			size, err := m.IpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnMatcher != nil {
		{
			size, err := m.AsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AnyIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyIp != nil {
		{
			size, err := m.AnyIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_IpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixList != nil {
		{
			size, err := m.IpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AnyAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyAsn != nil {
		{
			size, err := m.AnyAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AnyClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyClient != nil {
		{
			size, err := m.AnyClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AnyDstIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AnyDstIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDstIp != nil {
		{
			size, err := m.AnyDstIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DstIpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DstIpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIpPrefixList != nil {
		{
			size, err := m.DstIpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DstIpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DstIpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIpMatcher != nil {
		{
			size, err := m.DstIpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AnyDstAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AnyDstAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDstAsn != nil {
		{
			size, err := m.AnyDstAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DstAsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DstAsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstAsnList != nil {
		{
			size, err := m.DstAsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DstAsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DstAsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstAsnMatcher != nil {
		{
			size, err := m.DstAsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GotoPolicy) > 0 {
		for iNdEx := len(m.GotoPolicy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GotoPolicy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if m.ChallengeAction != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeAction))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.DstAsnChoice != nil {
		{
			size := m.DstAsnChoice.Size()
			i -= size
			if _, err := m.DstAsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.L4DestMatcher != nil {
		{
			size, err := m.L4DestMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.DstIpChoice != nil {
		{
			size := m.DstIpChoice.Size()
			i -= size
			if _, err := m.DstIpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UrlMatcher != nil {
		{
			size, err := m.UrlMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.Scheme) > 0 {
		for iNdEx := len(m.Scheme) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scheme[iNdEx])
			copy(dAtA[i:], m.Scheme[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Scheme[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.ClientChoice != nil {
		{
			size := m.ClientChoice.Size()
			i -= size
			if _, err := m.ClientChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AsnChoice != nil {
		{
			size := m.AsnChoice.Size()
			i -= size
			if _, err := m.AsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IpChoice != nil {
		{
			size := m.IpChoice.Size()
			i -= size
			if _, err := m.IpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MaliciousUserMitigationBypass != nil {
		{
			size, err := m.MaliciousUserMitigationBypass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.TlsFingerprintMatcher != nil {
		{
			size, err := m.TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.VirtualHostMatcher != nil {
		{
			size, err := m.VirtualHostMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.RateLimiter) > 0 {
		for iNdEx := len(m.RateLimiter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.DomainMatcher != nil {
		{
			size, err := m.DomainMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.BodyMatcher != nil {
		{
			size, err := m.BodyMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.WafAction != nil {
		{
			size, err := m.WafAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.CookieMatchers) > 0 {
		for iNdEx := len(m.CookieMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.ArgMatchers) > 0 {
		for iNdEx := len(m.ArgMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArgMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ApiGroupMatcher != nil {
		{
			size, err := m.ApiGroupMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ClientRole != nil {
		{
			size, err := m.ClientRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.HttpMethod != nil {
		{
			size, err := m.HttpMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_ClientName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ClientName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClientName)
	copy(dAtA[i:], m.ClientName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ClientSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientSelector != nil {
		{
			size, err := m.ClientSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ClientNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientNameMatcher != nil {
		{
			size, err := m.ClientNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_IpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpMatcher != nil {
		{
			size, err := m.IpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnMatcher != nil {
		{
			size, err := m.AsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AnyIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyIp != nil {
		{
			size, err := m.AnyIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_IpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixList != nil {
		{
			size, err := m.IpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AnyAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyAsn != nil {
		{
			size, err := m.AnyAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AnyClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyClient != nil {
		{
			size, err := m.AnyClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AnyDstIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AnyDstIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDstIp != nil {
		{
			size, err := m.AnyDstIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DstIpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DstIpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIpPrefixList != nil {
		{
			size, err := m.DstIpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DstIpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DstIpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIpMatcher != nil {
		{
			size, err := m.DstIpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AnyDstAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AnyDstAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDstAsn != nil {
		{
			size, err := m.AnyDstAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DstAsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DstAsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstAsnList != nil {
		{
			size, err := m.DstAsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DstAsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DstAsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstAsnMatcher != nil {
		{
			size, err := m.DstAsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GotoPolicy) > 0 {
		for iNdEx := len(m.GotoPolicy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GotoPolicy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if m.ChallengeAction != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeAction))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.DstAsnChoice != nil {
		{
			size := m.DstAsnChoice.Size()
			i -= size
			if _, err := m.DstAsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.L4DestMatcher != nil {
		{
			size, err := m.L4DestMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.DstIpChoice != nil {
		{
			size := m.DstIpChoice.Size()
			i -= size
			if _, err := m.DstIpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UrlMatcher != nil {
		{
			size, err := m.UrlMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.Scheme) > 0 {
		for iNdEx := len(m.Scheme) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scheme[iNdEx])
			copy(dAtA[i:], m.Scheme[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Scheme[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.ClientChoice != nil {
		{
			size := m.ClientChoice.Size()
			i -= size
			if _, err := m.ClientChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AsnChoice != nil {
		{
			size := m.AsnChoice.Size()
			i -= size
			if _, err := m.AsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IpChoice != nil {
		{
			size := m.IpChoice.Size()
			i -= size
			if _, err := m.IpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MaliciousUserMitigationBypass != nil {
		{
			size, err := m.MaliciousUserMitigationBypass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.TlsFingerprintMatcher != nil {
		{
			size, err := m.TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.VirtualHostMatcher != nil {
		{
			size, err := m.VirtualHostMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.RateLimiter) > 0 {
		for iNdEx := len(m.RateLimiter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.DomainMatcher != nil {
		{
			size, err := m.DomainMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.BodyMatcher != nil {
		{
			size, err := m.BodyMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.WafAction != nil {
		{
			size, err := m.WafAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.CookieMatchers) > 0 {
		for iNdEx := len(m.CookieMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.ArgMatchers) > 0 {
		for iNdEx := len(m.ArgMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArgMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ApiGroupMatcher != nil {
		{
			size, err := m.ApiGroupMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ClientRole != nil {
		{
			size, err := m.ClientRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.HttpMethod != nil {
		{
			size, err := m.HttpMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_ClientName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ClientName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClientName)
	copy(dAtA[i:], m.ClientName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ClientSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientSelector != nil {
		{
			size, err := m.ClientSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ClientNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientNameMatcher != nil {
		{
			size, err := m.ClientNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_IpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpMatcher != nil {
		{
			size, err := m.IpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnMatcher != nil {
		{
			size, err := m.AsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AnyIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyIp != nil {
		{
			size, err := m.AnyIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_IpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixList != nil {
		{
			size, err := m.IpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AnyAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyAsn != nil {
		{
			size, err := m.AnyAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AnyClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyClient != nil {
		{
			size, err := m.AnyClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AnyDstIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AnyDstIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDstIp != nil {
		{
			size, err := m.AnyDstIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DstIpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DstIpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIpPrefixList != nil {
		{
			size, err := m.DstIpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DstIpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DstIpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIpMatcher != nil {
		{
			size, err := m.DstIpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AnyDstAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AnyDstAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDstAsn != nil {
		{
			size, err := m.AnyDstAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DstAsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DstAsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstAsnList != nil {
		{
			size, err := m.DstAsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DstAsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DstAsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstAsnMatcher != nil {
		{
			size, err := m.DstAsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GotoPolicy) > 0 {
		for iNdEx := len(m.GotoPolicy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GotoPolicy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if m.ChallengeAction != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeAction))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.DstAsnChoice != nil {
		{
			size := m.DstAsnChoice.Size()
			i -= size
			if _, err := m.DstAsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.L4DestMatcher != nil {
		{
			size, err := m.L4DestMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.DstIpChoice != nil {
		{
			size := m.DstIpChoice.Size()
			i -= size
			if _, err := m.DstIpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UrlMatcher != nil {
		{
			size, err := m.UrlMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.Scheme) > 0 {
		for iNdEx := len(m.Scheme) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scheme[iNdEx])
			copy(dAtA[i:], m.Scheme[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Scheme[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.ClientChoice != nil {
		{
			size := m.ClientChoice.Size()
			i -= size
			if _, err := m.ClientChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AsnChoice != nil {
		{
			size := m.AsnChoice.Size()
			i -= size
			if _, err := m.AsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IpChoice != nil {
		{
			size := m.IpChoice.Size()
			i -= size
			if _, err := m.IpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MaliciousUserMitigationBypass != nil {
		{
			size, err := m.MaliciousUserMitigationBypass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.TlsFingerprintMatcher != nil {
		{
			size, err := m.TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.VirtualHostMatcher != nil {
		{
			size, err := m.VirtualHostMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.RateLimiter) > 0 {
		for iNdEx := len(m.RateLimiter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimiter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.DomainMatcher != nil {
		{
			size, err := m.DomainMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.BodyMatcher != nil {
		{
			size, err := m.BodyMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.WafAction != nil {
		{
			size, err := m.WafAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.CookieMatchers) > 0 {
		for iNdEx := len(m.CookieMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.ArgMatchers) > 0 {
		for iNdEx := len(m.ArgMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArgMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.PortMatcher != nil {
		{
			size, err := m.PortMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ApiGroupMatcher != nil {
		{
			size, err := m.ApiGroupMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ClientRole != nil {
		{
			size, err := m.ClientRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.HttpMethod != nil {
		{
			size, err := m.HttpMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LabelMatcher != nil {
		{
			size, err := m.LabelMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_ClientName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ClientName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClientName)
	copy(dAtA[i:], m.ClientName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ClientSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientSelector != nil {
		{
			size, err := m.ClientSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ClientNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientNameMatcher != nil {
		{
			size, err := m.ClientNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_IpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpMatcher != nil {
		{
			size, err := m.IpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnMatcher != nil {
		{
			size, err := m.AsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AnyIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyIp != nil {
		{
			size, err := m.AnyIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_IpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixList != nil {
		{
			size, err := m.IpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AnyAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyAsn != nil {
		{
			size, err := m.AnyAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AnyClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyClient != nil {
		{
			size, err := m.AnyClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AnyDstIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AnyDstIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDstIp != nil {
		{
			size, err := m.AnyDstIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DstIpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DstIpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIpPrefixList != nil {
		{
			size, err := m.DstIpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DstIpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DstIpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstIpMatcher != nil {
		{
			size, err := m.DstIpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AnyDstAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AnyDstAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyDstAsn != nil {
		{
			size, err := m.AnyDstAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DstAsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DstAsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstAsnList != nil {
		{
			size, err := m.DstAsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DstAsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DstAsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DstAsnMatcher != nil {
		{
			size, err := m.DstAsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AsnChoice != nil {
		{
			size := m.AsnChoice.Size()
			i -= size
			if _, err := m.AsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IpChoice != nil {
		{
			size := m.IpChoice.Size()
			i -= size
			if _, err := m.IpChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.ClientChoice != nil {
		{
			size := m.ClientChoice.Size()
			i -= size
			if _, err := m.ClientChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.CookieMatchers) > 0 {
		for iNdEx := len(m.CookieMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.ArgMatchers) > 0 {
		for iNdEx := len(m.ArgMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ArgMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.BodyMatcher != nil {
		{
			size, err := m.BodyMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.TlsFingerprintMatcher != nil {
		{
			size, err := m.TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.HttpMethod != nil {
		{
			size, err := m.HttpMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DomainMatcher != nil {
		{
			size, err := m.DomainMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ChallengeAction != nil {
		{
			size := m.ChallengeAction.Size()
			i -= size
			if _, err := m.ChallengeAction.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeRuleSpec_DisableChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_DisableChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableChallenge != nil {
		{
			size, err := m.DisableChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_EnableJavascriptChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_EnableJavascriptChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableJavascriptChallenge != nil {
		{
			size, err := m.EnableJavascriptChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_EnableCaptchaChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_EnableCaptchaChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableCaptchaChallenge != nil {
		{
			size, err := m.EnableCaptchaChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_AnyClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_AnyClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyClient != nil {
		{
			size, err := m.AnyClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_ClientName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_ClientName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClientName)
	copy(dAtA[i:], m.ClientName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientName)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_ClientSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_ClientSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientSelector != nil {
		{
			size, err := m.ClientSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_ClientNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_ClientNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClientNameMatcher != nil {
		{
			size, err := m.ClientNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_AnyIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_AnyIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyIp != nil {
		{
			size, err := m.AnyIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_IpPrefixList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_IpPrefixList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpPrefixList != nil {
		{
			size, err := m.IpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_IpMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_IpMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpMatcher != nil {
		{
			size, err := m.IpMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_AnyAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_AnyAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyAsn != nil {
		{
			size, err := m.AnyAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_AsnList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_AsnList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ChallengeRuleSpec_AsnMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeRuleSpec_AsnMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AsnMatcher != nil {
		{
			size, err := m.AsnMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *RateLimiterRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimiterRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimiterRuleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DomainMatcher != nil {
		{
			size, err := m.DomainMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.HttpMethod != nil {
		{
			size, err := m.HttpMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ActionChoice != nil {
		{
			size := m.ActionChoice.Size()
			i -= size
			if _, err := m.ActionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RateLimiterRuleSpec_BypassRateLimiter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimiterRuleSpec_BypassRateLimiter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BypassRateLimiter != nil {
		{
			size, err := m.BypassRateLimiter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RateLimiterRuleSpec_ApplyRateLimiter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimiterRuleSpec_ApplyRateLimiter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ApplyRateLimiter != nil {
		{
			size, err := m.ApplyRateLimiter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RateLimiterRuleSpec_CustomRateLimiter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimiterRuleSpec_CustomRateLimiter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomRateLimiter != nil {
		{
			size, err := m.CustomRateLimiter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.VirtualHostMatcher != nil {
		l = m.VirtualHostMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ForwardingClass) > 0 {
		for _, e := range m.ForwardingClass {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.MaliciousUserMitigationBypass != nil {
		l = m.MaliciousUserMitigationBypass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstIpChoice != nil {
		n += m.DstIpChoice.Size()
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnChoice != nil {
		n += m.DstAsnChoice.Size()
	}
	if m.ChallengeAction != 0 {
		n += 2 + sovTypes(uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType_ClientName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ClientSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ClientNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyDstIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDstIp != nil {
		l = m.AnyDstIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DstIpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DstIpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIpMatcher != nil {
		l = m.DstIpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AnyDstAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDstAsn != nil {
		l = m.AnyDstAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DstAsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstAsnList != nil {
		l = m.DstAsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DstAsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstAsnMatcher != nil {
		l = m.DstAsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.VirtualHostMatcher != nil {
		l = m.VirtualHostMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.MaliciousUserMitigationBypass != nil {
		l = m.MaliciousUserMitigationBypass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstIpChoice != nil {
		n += m.DstIpChoice.Size()
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnChoice != nil {
		n += m.DstAsnChoice.Size()
	}
	if m.ChallengeAction != 0 {
		n += 2 + sovTypes(uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType_ClientName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_ClientSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ClientNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyDstIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDstIp != nil {
		l = m.AnyDstIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DstIpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DstIpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIpMatcher != nil {
		l = m.DstIpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AnyDstAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDstAsn != nil {
		l = m.AnyDstAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DstAsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstAsnList != nil {
		l = m.DstAsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DstAsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstAsnMatcher != nil {
		l = m.DstAsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.VirtualHostMatcher != nil {
		l = m.VirtualHostMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.MaliciousUserMitigationBypass != nil {
		l = m.MaliciousUserMitigationBypass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstIpChoice != nil {
		n += m.DstIpChoice.Size()
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnChoice != nil {
		n += m.DstAsnChoice.Size()
	}
	if m.ChallengeAction != 0 {
		n += 2 + sovTypes(uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType_ClientName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_ClientSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ClientNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyDstIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDstIp != nil {
		l = m.AnyDstIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DstIpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DstIpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIpMatcher != nil {
		l = m.DstIpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AnyDstAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDstAsn != nil {
		l = m.AnyDstAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DstAsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstAsnList != nil {
		l = m.DstAsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DstAsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstAsnMatcher != nil {
		l = m.DstAsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.LabelMatcher != nil {
		l = m.LabelMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientRole != nil {
		l = m.ClientRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	if m.ApiGroupMatcher != nil {
		l = m.ApiGroupMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PortMatcher != nil {
		l = m.PortMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WafAction != nil {
		l = m.WafAction.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.RateLimiter) > 0 {
		for _, e := range m.RateLimiter {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.VirtualHostMatcher != nil {
		l = m.VirtualHostMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.MaliciousUserMitigationBypass != nil {
		l = m.MaliciousUserMitigationBypass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.Scheme) > 0 {
		for _, s := range m.Scheme {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UrlMatcher != nil {
		l = m.UrlMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstIpChoice != nil {
		n += m.DstIpChoice.Size()
	}
	if m.L4DestMatcher != nil {
		l = m.L4DestMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DstAsnChoice != nil {
		n += m.DstAsnChoice.Size()
	}
	if m.ChallengeAction != 0 {
		n += 2 + sovTypes(uint64(m.ChallengeAction))
	}
	if len(m.GotoPolicy) > 0 {
		for _, e := range m.GotoPolicy {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_ClientName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_ClientSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ClientNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyDstIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDstIp != nil {
		l = m.AnyDstIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DstIpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIpPrefixList != nil {
		l = m.DstIpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DstIpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstIpMatcher != nil {
		l = m.DstIpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AnyDstAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyDstAsn != nil {
		l = m.AnyDstAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DstAsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstAsnList != nil {
		l = m.DstAsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DstAsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstAsnMatcher != nil {
		l = m.DstAsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChallengeAction != nil {
		n += m.ChallengeAction.Size()
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.BodyMatcher != nil {
		l = m.BodyMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ArgMatchers) > 0 {
		for _, e := range m.ArgMatchers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatchers) > 0 {
		for _, e := range m.CookieMatchers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ClientChoice != nil {
		n += m.ClientChoice.Size()
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IpChoice != nil {
		n += m.IpChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	return n
}

func (m *ChallengeRuleSpec_DisableChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableChallenge != nil {
		l = m.DisableChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_EnableJavascriptChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableJavascriptChallenge != nil {
		l = m.EnableJavascriptChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_EnableCaptchaChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableCaptchaChallenge != nil {
		l = m.EnableCaptchaChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AnyClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyClient != nil {
		l = m.AnyClient.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_ClientName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientName)
	n += 2 + l + sovTypes(uint64(l))
	return n
}
func (m *ChallengeRuleSpec_ClientSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientSelector != nil {
		l = m.ClientSelector.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_ClientNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientNameMatcher != nil {
		l = m.ClientNameMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AnyIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyIp != nil {
		l = m.AnyIp.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_IpPrefixList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_IpMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpMatcher != nil {
		l = m.IpMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AnyAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyAsn != nil {
		l = m.AnyAsn.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AsnList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ChallengeRuleSpec_AsnMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsnMatcher != nil {
		l = m.AsnMatcher.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RateLimiterRuleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionChoice != nil {
		n += m.ActionChoice.Size()
	}
	if m.HttpMethod != nil {
		l = m.HttpMethod.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DomainMatcher != nil {
		l = m.DomainMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RateLimiterRuleSpec_BypassRateLimiter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BypassRateLimiter != nil {
		l = m.BypassRateLimiter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RateLimiterRuleSpec_ApplyRateLimiter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApplyRateLimiter != nil {
		l = m.ApplyRateLimiter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RateLimiterRuleSpec_CustomRateLimiter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomRateLimiter != nil {
		l = m.CustomRateLimiter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(fmt.Sprintf("%v", f), "HeaderMatcherType", "policy.HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForQueryParams := "[]*QueryParameterMatcherType{"
	for _, f := range this.QueryParams {
		repeatedStringForQueryParams += strings.Replace(fmt.Sprintf("%v", f), "QueryParameterMatcherType", "policy.QueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParams += "}"
	repeatedStringForArgMatchers := "[]*ArgMatcherType{"
	for _, f := range this.ArgMatchers {
		repeatedStringForArgMatchers += strings.Replace(fmt.Sprintf("%v", f), "ArgMatcherType", "policy.ArgMatcherType", 1) + ","
	}
	repeatedStringForArgMatchers += "}"
	repeatedStringForCookieMatchers := "[]*CookieMatcherType{"
	for _, f := range this.CookieMatchers {
		repeatedStringForCookieMatchers += strings.Replace(fmt.Sprintf("%v", f), "CookieMatcherType", "policy.CookieMatcherType", 1) + ","
	}
	repeatedStringForCookieMatchers += "}"
	repeatedStringForRateLimiter := "[]*ObjectRefType{"
	for _, f := range this.RateLimiter {
		repeatedStringForRateLimiter += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiter += "}"
	repeatedStringForForwardingClass := "[]*ObjectRefType{"
	for _, f := range this.ForwardingClass {
		repeatedStringForForwardingClass += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForForwardingClass += "}"
	repeatedStringForGotoPolicy := "[]*ObjectRefType{"
	for _, f := range this.GotoPolicy {
		repeatedStringForGotoPolicy += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForGotoPolicy += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "policy.PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`QueryParams:` + repeatedStringForQueryParams + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "policy.HttpMethodMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "policy.RoleMatcherType", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "policy.StringMatcherType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ArgMatchers:` + repeatedStringForArgMatchers + `,`,
		`CookieMatchers:` + repeatedStringForCookieMatchers + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "policy.WafAction", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`RateLimiter:` + repeatedStringForRateLimiter + `,`,
		`VirtualHostMatcher:` + strings.Replace(fmt.Sprintf("%v", this.VirtualHostMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "policy.TlsFingerprintMatcherType", 1) + `,`,
		`ForwardingClass:` + repeatedStringForForwardingClass + `,`,
		`MaliciousUserMitigationBypass:` + strings.Replace(fmt.Sprintf("%v", this.MaliciousUserMitigationBypass), "Empty", "schema.Empty", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "policy.URLMatcherType", 1) + `,`,
		`DstIpChoice:` + fmt.Sprintf("%v", this.DstIpChoice) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "policy.L4DestMatcherType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`DstAsnChoice:` + fmt.Sprintf("%v", this.DstAsnChoice) + `,`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`GotoPolicy:` + repeatedStringForGotoPolicy + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyDstIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyDstIp{`,
		`AnyDstIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DstIpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DstIpPrefixList{`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DstIpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DstIpMatcher{`,
		`DstIpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstIpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyDstAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyDstAsn{`,
		`AnyDstAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DstAsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DstAsnList{`,
		`DstAsnList:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DstAsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DstAsnMatcher{`,
		`DstAsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(fmt.Sprintf("%v", f), "HeaderMatcherType", "policy.HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForQueryParams := "[]*QueryParameterMatcherType{"
	for _, f := range this.QueryParams {
		repeatedStringForQueryParams += strings.Replace(fmt.Sprintf("%v", f), "QueryParameterMatcherType", "policy.QueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParams += "}"
	repeatedStringForArgMatchers := "[]*ArgMatcherType{"
	for _, f := range this.ArgMatchers {
		repeatedStringForArgMatchers += strings.Replace(fmt.Sprintf("%v", f), "ArgMatcherType", "policy.ArgMatcherType", 1) + ","
	}
	repeatedStringForArgMatchers += "}"
	repeatedStringForCookieMatchers := "[]*CookieMatcherType{"
	for _, f := range this.CookieMatchers {
		repeatedStringForCookieMatchers += strings.Replace(fmt.Sprintf("%v", f), "CookieMatcherType", "policy.CookieMatcherType", 1) + ","
	}
	repeatedStringForCookieMatchers += "}"
	repeatedStringForRateLimiter := "[]*ObjectRefType{"
	for _, f := range this.RateLimiter {
		repeatedStringForRateLimiter += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiter += "}"
	repeatedStringForGotoPolicy := "[]*ObjectRefType{"
	for _, f := range this.GotoPolicy {
		repeatedStringForGotoPolicy += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForGotoPolicy += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "policy.PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`QueryParams:` + repeatedStringForQueryParams + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "policy.HttpMethodMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "policy.RoleMatcherType", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "policy.StringMatcherType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ArgMatchers:` + repeatedStringForArgMatchers + `,`,
		`CookieMatchers:` + repeatedStringForCookieMatchers + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "policy.WafAction", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`RateLimiter:` + repeatedStringForRateLimiter + `,`,
		`VirtualHostMatcher:` + strings.Replace(fmt.Sprintf("%v", this.VirtualHostMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "policy.TlsFingerprintMatcherType", 1) + `,`,
		`MaliciousUserMitigationBypass:` + strings.Replace(fmt.Sprintf("%v", this.MaliciousUserMitigationBypass), "Empty", "schema.Empty", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "policy.URLMatcherType", 1) + `,`,
		`DstIpChoice:` + fmt.Sprintf("%v", this.DstIpChoice) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "policy.L4DestMatcherType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`DstAsnChoice:` + fmt.Sprintf("%v", this.DstAsnChoice) + `,`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`GotoPolicy:` + repeatedStringForGotoPolicy + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyDstIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyDstIp{`,
		`AnyDstIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DstIpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DstIpPrefixList{`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DstIpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DstIpMatcher{`,
		`DstIpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstIpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyDstAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyDstAsn{`,
		`AnyDstAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DstAsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DstAsnList{`,
		`DstAsnList:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DstAsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DstAsnMatcher{`,
		`DstAsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(fmt.Sprintf("%v", f), "HeaderMatcherType", "policy.HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForQueryParams := "[]*QueryParameterMatcherType{"
	for _, f := range this.QueryParams {
		repeatedStringForQueryParams += strings.Replace(fmt.Sprintf("%v", f), "QueryParameterMatcherType", "policy.QueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParams += "}"
	repeatedStringForArgMatchers := "[]*ArgMatcherType{"
	for _, f := range this.ArgMatchers {
		repeatedStringForArgMatchers += strings.Replace(fmt.Sprintf("%v", f), "ArgMatcherType", "policy.ArgMatcherType", 1) + ","
	}
	repeatedStringForArgMatchers += "}"
	repeatedStringForCookieMatchers := "[]*CookieMatcherType{"
	for _, f := range this.CookieMatchers {
		repeatedStringForCookieMatchers += strings.Replace(fmt.Sprintf("%v", f), "CookieMatcherType", "policy.CookieMatcherType", 1) + ","
	}
	repeatedStringForCookieMatchers += "}"
	repeatedStringForRateLimiter := "[]*ObjectRefType{"
	for _, f := range this.RateLimiter {
		repeatedStringForRateLimiter += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiter += "}"
	repeatedStringForGotoPolicy := "[]*ObjectRefType{"
	for _, f := range this.GotoPolicy {
		repeatedStringForGotoPolicy += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForGotoPolicy += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "policy.PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`QueryParams:` + repeatedStringForQueryParams + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "policy.HttpMethodMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "policy.RoleMatcherType", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "policy.StringMatcherType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ArgMatchers:` + repeatedStringForArgMatchers + `,`,
		`CookieMatchers:` + repeatedStringForCookieMatchers + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "policy.WafAction", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`RateLimiter:` + repeatedStringForRateLimiter + `,`,
		`VirtualHostMatcher:` + strings.Replace(fmt.Sprintf("%v", this.VirtualHostMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "policy.TlsFingerprintMatcherType", 1) + `,`,
		`MaliciousUserMitigationBypass:` + strings.Replace(fmt.Sprintf("%v", this.MaliciousUserMitigationBypass), "Empty", "schema.Empty", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "policy.URLMatcherType", 1) + `,`,
		`DstIpChoice:` + fmt.Sprintf("%v", this.DstIpChoice) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "policy.L4DestMatcherType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`DstAsnChoice:` + fmt.Sprintf("%v", this.DstAsnChoice) + `,`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`GotoPolicy:` + repeatedStringForGotoPolicy + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyDstIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyDstIp{`,
		`AnyDstIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DstIpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DstIpPrefixList{`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DstIpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DstIpMatcher{`,
		`DstIpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstIpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyDstAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyDstAsn{`,
		`AnyDstAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DstAsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DstAsnList{`,
		`DstAsnList:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DstAsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DstAsnMatcher{`,
		`DstAsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(fmt.Sprintf("%v", f), "HeaderMatcherType", "policy.HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForQueryParams := "[]*QueryParameterMatcherType{"
	for _, f := range this.QueryParams {
		repeatedStringForQueryParams += strings.Replace(fmt.Sprintf("%v", f), "QueryParameterMatcherType", "policy.QueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParams += "}"
	repeatedStringForArgMatchers := "[]*ArgMatcherType{"
	for _, f := range this.ArgMatchers {
		repeatedStringForArgMatchers += strings.Replace(fmt.Sprintf("%v", f), "ArgMatcherType", "policy.ArgMatcherType", 1) + ","
	}
	repeatedStringForArgMatchers += "}"
	repeatedStringForCookieMatchers := "[]*CookieMatcherType{"
	for _, f := range this.CookieMatchers {
		repeatedStringForCookieMatchers += strings.Replace(fmt.Sprintf("%v", f), "CookieMatcherType", "policy.CookieMatcherType", 1) + ","
	}
	repeatedStringForCookieMatchers += "}"
	repeatedStringForRateLimiter := "[]*ObjectRefType{"
	for _, f := range this.RateLimiter {
		repeatedStringForRateLimiter += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForRateLimiter += "}"
	repeatedStringForGotoPolicy := "[]*ObjectRefType{"
	for _, f := range this.GotoPolicy {
		repeatedStringForGotoPolicy += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForGotoPolicy += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`LabelMatcher:` + strings.Replace(fmt.Sprintf("%v", this.LabelMatcher), "LabelMatcherType", "schema.LabelMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "policy.PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`QueryParams:` + repeatedStringForQueryParams + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "policy.HttpMethodMatcherType", 1) + `,`,
		`ClientRole:` + strings.Replace(fmt.Sprintf("%v", this.ClientRole), "RoleMatcherType", "policy.RoleMatcherType", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`ApiGroupMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ApiGroupMatcher), "StringMatcherType", "policy.StringMatcherType", 1) + `,`,
		`PortMatcher:` + strings.Replace(fmt.Sprintf("%v", this.PortMatcher), "PortMatcherType", "policy.PortMatcherType", 1) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ArgMatchers:` + repeatedStringForArgMatchers + `,`,
		`CookieMatchers:` + repeatedStringForCookieMatchers + `,`,
		`WafAction:` + strings.Replace(fmt.Sprintf("%v", this.WafAction), "WafAction", "policy.WafAction", 1) + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`RateLimiter:` + repeatedStringForRateLimiter + `,`,
		`VirtualHostMatcher:` + strings.Replace(fmt.Sprintf("%v", this.VirtualHostMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "policy.TlsFingerprintMatcherType", 1) + `,`,
		`MaliciousUserMitigationBypass:` + strings.Replace(fmt.Sprintf("%v", this.MaliciousUserMitigationBypass), "Empty", "schema.Empty", 1) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`UrlMatcher:` + strings.Replace(fmt.Sprintf("%v", this.UrlMatcher), "URLMatcherType", "policy.URLMatcherType", 1) + `,`,
		`DstIpChoice:` + fmt.Sprintf("%v", this.DstIpChoice) + `,`,
		`L4DestMatcher:` + strings.Replace(fmt.Sprintf("%v", this.L4DestMatcher), "L4DestMatcherType", "policy.L4DestMatcherType", 1) + `,`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`DstAsnChoice:` + fmt.Sprintf("%v", this.DstAsnChoice) + `,`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`GotoPolicy:` + repeatedStringForGotoPolicy + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyDstIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyDstIp{`,
		`AnyDstIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DstIpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DstIpPrefixList{`,
		`DstIpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.DstIpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DstIpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DstIpMatcher{`,
		`DstIpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstIpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyDstAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyDstAsn{`,
		`AnyDstAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyDstAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DstAsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DstAsnList{`,
		`DstAsnList:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DstAsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DstAsnMatcher{`,
		`DstAsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DstAsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(fmt.Sprintf("%v", f), "HeaderMatcherType", "policy.HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForQueryParams := "[]*QueryParameterMatcherType{"
	for _, f := range this.QueryParams {
		repeatedStringForQueryParams += strings.Replace(fmt.Sprintf("%v", f), "QueryParameterMatcherType", "policy.QueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParams += "}"
	repeatedStringForArgMatchers := "[]*ArgMatcherType{"
	for _, f := range this.ArgMatchers {
		repeatedStringForArgMatchers += strings.Replace(fmt.Sprintf("%v", f), "ArgMatcherType", "policy.ArgMatcherType", 1) + ","
	}
	repeatedStringForArgMatchers += "}"
	repeatedStringForCookieMatchers := "[]*CookieMatcherType{"
	for _, f := range this.CookieMatchers {
		repeatedStringForCookieMatchers += strings.Replace(fmt.Sprintf("%v", f), "CookieMatcherType", "policy.CookieMatcherType", 1) + ","
	}
	repeatedStringForCookieMatchers += "}"
	s := strings.Join([]string{`&ChallengeRuleSpec{`,
		`ChallengeAction:` + fmt.Sprintf("%v", this.ChallengeAction) + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "policy.PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "policy.HttpMethodMatcherType", 1) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "policy.TlsFingerprintMatcherType", 1) + `,`,
		`QueryParams:` + repeatedStringForQueryParams + `,`,
		`BodyMatcher:` + strings.Replace(fmt.Sprintf("%v", this.BodyMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`ArgMatchers:` + repeatedStringForArgMatchers + `,`,
		`CookieMatchers:` + repeatedStringForCookieMatchers + `,`,
		`ClientChoice:` + fmt.Sprintf("%v", this.ClientChoice) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`IpChoice:` + fmt.Sprintf("%v", this.IpChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_DisableChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_DisableChallenge{`,
		`DisableChallenge:` + strings.Replace(fmt.Sprintf("%v", this.DisableChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_EnableJavascriptChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_EnableJavascriptChallenge{`,
		`EnableJavascriptChallenge:` + strings.Replace(fmt.Sprintf("%v", this.EnableJavascriptChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_EnableCaptchaChallenge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_EnableCaptchaChallenge{`,
		`EnableCaptchaChallenge:` + strings.Replace(fmt.Sprintf("%v", this.EnableCaptchaChallenge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AnyClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AnyClient{`,
		`AnyClient:` + strings.Replace(fmt.Sprintf("%v", this.AnyClient), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_ClientName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_ClientName{`,
		`ClientName:` + fmt.Sprintf("%v", this.ClientName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_ClientSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_ClientSelector{`,
		`ClientSelector:` + strings.Replace(fmt.Sprintf("%v", this.ClientSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_ClientNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_ClientNameMatcher{`,
		`ClientNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ClientNameMatcher), "MatcherType", "policy.MatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AnyIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AnyIp{`,
		`AnyIp:` + strings.Replace(fmt.Sprintf("%v", this.AnyIp), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_IpPrefixList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_IpPrefixList{`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_IpMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_IpMatcher{`,
		`IpMatcher:` + strings.Replace(fmt.Sprintf("%v", this.IpMatcher), "IpMatcherType", "policy.IpMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AnyAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AnyAsn{`,
		`AnyAsn:` + strings.Replace(fmt.Sprintf("%v", this.AnyAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AsnList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AsnList{`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChallengeRuleSpec_AsnMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChallengeRuleSpec_AsnMatcher{`,
		`AsnMatcher:` + strings.Replace(fmt.Sprintf("%v", this.AsnMatcher), "AsnMatcherType", "policy.AsnMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimiterRuleSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(fmt.Sprintf("%v", f), "HeaderMatcherType", "policy.HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	s := strings.Join([]string{`&RateLimiterRuleSpec{`,
		`ActionChoice:` + fmt.Sprintf("%v", this.ActionChoice) + `,`,
		`HttpMethod:` + strings.Replace(fmt.Sprintf("%v", this.HttpMethod), "HttpMethodMatcherType", "policy.HttpMethodMatcherType", 1) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "PathMatcherType", "policy.PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`DomainMatcher:` + strings.Replace(fmt.Sprintf("%v", this.DomainMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimiterRuleSpec_BypassRateLimiter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimiterRuleSpec_BypassRateLimiter{`,
		`BypassRateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.BypassRateLimiter), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimiterRuleSpec_ApplyRateLimiter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimiterRuleSpec_ApplyRateLimiter{`,
		`ApplyRateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.ApplyRateLimiter), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimiterRuleSpec_CustomRateLimiter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimiterRuleSpec_CustomRateLimiter{`,
		`CustomRateLimiter:` + strings.Replace(fmt.Sprintf("%v", this.CustomRateLimiter), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= policy.RuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &GlobalSpecType_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GlobalSpecType_ClientSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GlobalSpecType_ClientNameMatcher{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GlobalSpecType_IpMatcher{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GlobalSpecType_AsnMatcher{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &policy.MatcherType{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &schema.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHostMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualHostMatcher == nil {
				m.VirtualHostMatcher = &policy.MatcherType{}
			}
			if err := m.VirtualHostMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardingClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardingClass = append(m.ForwardingClass, &schema.ObjectRefType{})
			if err := m.ForwardingClass[len(m.ForwardingClass)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigationBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaliciousUserMitigationBypass == nil {
				m.MaliciousUserMitigationBypass = &schema.Empty{}
			}
			if err := m.MaliciousUserMitigationBypass.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GlobalSpecType_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GlobalSpecType_IpPrefixList{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GlobalSpecType_AnyAsn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GlobalSpecType_AsnList{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GlobalSpecType_AnyClient{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GlobalSpecType_AnyDstIp{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GlobalSpecType_DstIpPrefixList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GlobalSpecType_DstIpMatcher{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &schema.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GlobalSpecType_AnyDstAsn{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GlobalSpecType_DstAsnList{v}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GlobalSpecType_DstAsnMatcher{v}
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAction", wireType)
			}
			m.ChallengeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAction |= policy.ChallengeAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &schema.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= policy.RuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &CreateSpecType_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &CreateSpecType_ClientSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &CreateSpecType_ClientNameMatcher{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &CreateSpecType_IpMatcher{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &CreateSpecType_AsnMatcher{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &schema.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHostMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualHostMatcher == nil {
				m.VirtualHostMatcher = &policy.MatcherTypeBasic{}
			}
			if err := m.VirtualHostMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigationBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaliciousUserMitigationBypass == nil {
				m.MaliciousUserMitigationBypass = &schema.Empty{}
			}
			if err := m.MaliciousUserMitigationBypass.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &CreateSpecType_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &CreateSpecType_IpPrefixList{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &CreateSpecType_AnyAsn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &CreateSpecType_AsnList{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &CreateSpecType_AnyClient{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &CreateSpecType_AnyDstIp{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &CreateSpecType_DstIpPrefixList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &CreateSpecType_DstIpMatcher{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &schema.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &CreateSpecType_AnyDstAsn{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &CreateSpecType_DstAsnList{v}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &CreateSpecType_DstAsnMatcher{v}
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAction", wireType)
			}
			m.ChallengeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAction |= policy.ChallengeAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &schema.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= policy.RuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &ReplaceSpecType_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ReplaceSpecType_ClientSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ReplaceSpecType_ClientNameMatcher{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ReplaceSpecType_IpMatcher{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ReplaceSpecType_AsnMatcher{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &schema.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHostMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualHostMatcher == nil {
				m.VirtualHostMatcher = &policy.MatcherTypeBasic{}
			}
			if err := m.VirtualHostMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigationBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaliciousUserMitigationBypass == nil {
				m.MaliciousUserMitigationBypass = &schema.Empty{}
			}
			if err := m.MaliciousUserMitigationBypass.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ReplaceSpecType_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ReplaceSpecType_IpPrefixList{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ReplaceSpecType_AnyAsn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ReplaceSpecType_AsnList{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ReplaceSpecType_AnyClient{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &ReplaceSpecType_AnyDstIp{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &ReplaceSpecType_DstIpPrefixList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &ReplaceSpecType_DstIpMatcher{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &schema.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &ReplaceSpecType_AnyDstAsn{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &ReplaceSpecType_DstAsnList{v}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &ReplaceSpecType_DstAsnMatcher{v}
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAction", wireType)
			}
			m.ChallengeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAction |= policy.ChallengeAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &schema.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= policy.RuleAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &GetSpecType_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GetSpecType_ClientSelector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LabelMatcher == nil {
				m.LabelMatcher = &schema.LabelMatcherType{}
			}
			if err := m.LabelMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRole == nil {
				m.ClientRole = &policy.RoleMatcherType{}
			}
			if err := m.ClientRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GetSpecType_ClientNameMatcher{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GetSpecType_IpMatcher{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GetSpecType_AsnMatcher{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroupMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiGroupMatcher == nil {
				m.ApiGroupMatcher = &policy.StringMatcherType{}
			}
			if err := m.ApiGroupMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortMatcher == nil {
				m.PortMatcher = &policy.PortMatcherType{}
			}
			if err := m.PortMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WafAction == nil {
				m.WafAction = &policy.WafAction{}
			}
			if err := m.WafAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimiter = append(m.RateLimiter, &schema.ObjectRefType{})
			if err := m.RateLimiter[len(m.RateLimiter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHostMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualHostMatcher == nil {
				m.VirtualHostMatcher = &policy.MatcherTypeBasic{}
			}
			if err := m.VirtualHostMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaliciousUserMitigationBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaliciousUserMitigationBypass == nil {
				m.MaliciousUserMitigationBypass = &schema.Empty{}
			}
			if err := m.MaliciousUserMitigationBypass.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GetSpecType_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &GetSpecType_IpPrefixList{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GetSpecType_AnyAsn{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &GetSpecType_AsnList{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &GetSpecType_AnyClient{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = append(m.Scheme, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UrlMatcher == nil {
				m.UrlMatcher = &policy.URLMatcherType{}
			}
			if err := m.UrlMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GetSpecType_AnyDstIp{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GetSpecType_DstIpPrefixList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstIpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstIpChoice = &GetSpecType_DstIpMatcher{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4DestMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L4DestMatcher == nil {
				m.L4DestMatcher = &policy.L4DestMatcherType{}
			}
			if err := m.L4DestMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSelector == nil {
				m.ServerSelector = &schema.LabelSelectorType{}
			}
			if err := m.ServerSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyDstAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GetSpecType_AnyDstAsn{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GetSpecType_DstAsnList{v}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DstAsnChoice = &GetSpecType_DstAsnMatcher{v}
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeAction", wireType)
			}
			m.ChallengeAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeAction |= policy.ChallengeAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GotoPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GotoPolicy = append(m.GotoPolicy, &schema.ObjectRefType{})
			if err := m.GotoPolicy[len(m.GotoPolicy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeAction = &ChallengeRuleSpec_DisableChallenge{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableJavascriptChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeAction = &ChallengeRuleSpec_EnableJavascriptChallenge{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCaptchaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChallengeAction = &ChallengeRuleSpec_EnableCaptchaChallenge{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &policy.QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyMatcher == nil {
				m.BodyMatcher = &policy.MatcherType{}
			}
			if err := m.BodyMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArgMatchers = append(m.ArgMatchers, &policy.ArgMatcherType{})
			if err := m.ArgMatchers[len(m.ArgMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatchers = append(m.CookieMatchers, &policy.CookieMatcherType{})
			if err := m.CookieMatchers[len(m.CookieMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ChallengeRuleSpec_AnyClient{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChoice = &ChallengeRuleSpec_ClientName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ChallengeRuleSpec_ClientSelector{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClientChoice = &ChallengeRuleSpec_ClientNameMatcher{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ChallengeRuleSpec_AnyIp{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ChallengeRuleSpec_IpPrefixList{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.IpMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpChoice = &ChallengeRuleSpec_IpMatcher{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ChallengeRuleSpec_AnyAsn{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ChallengeRuleSpec_AsnList{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.AsnMatcherType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &ChallengeRuleSpec_AsnMatcher{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimiterRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimiterRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimiterRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BypassRateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &RateLimiterRuleSpec_BypassRateLimiter{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyRateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &RateLimiterRuleSpec_ApplyRateLimiter{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomRateLimiter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &RateLimiterRuleSpec_CustomRateLimiter{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpMethod == nil {
				m.HttpMethod = &policy.HttpMethodMatcherType{}
			}
			if err := m.HttpMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &policy.PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &policy.HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatcher == nil {
				m.DomainMatcher = &policy.MatcherTypeBasic{}
			}
			if err := m.DomainMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
