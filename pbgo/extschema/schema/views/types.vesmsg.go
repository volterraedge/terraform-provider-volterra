// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package views

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AcceleratedNetworkingType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AcceleratedNetworkingType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AcceleratedNetworkingType) DeepCopy() *AcceleratedNetworkingType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AcceleratedNetworkingType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AcceleratedNetworkingType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AcceleratedNetworkingType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AcceleratedNetworkingTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAcceleratedNetworkingType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAcceleratedNetworkingType) AcceleratedNetworkingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for accelerated_networking")
	}
	return validatorFn, nil
}

func (v *ValidateAcceleratedNetworkingType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AcceleratedNetworkingType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AcceleratedNetworkingType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["accelerated_networking"]; exists {
		val := m.GetAcceleratedNetworking()
		vOpts := append(opts,
			db.WithValidateField("accelerated_networking"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAcceleratedNetworking().(type) {
	case *AcceleratedNetworkingType_Disable:
		if fv, exists := v.FldValidators["accelerated_networking.disable"]; exists {
			val := m.GetAcceleratedNetworking().(*AcceleratedNetworkingType_Disable).Disable
			vOpts := append(opts,
				db.WithValidateField("accelerated_networking"),
				db.WithValidateField("disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AcceleratedNetworkingType_Enable:
		if fv, exists := v.FldValidators["accelerated_networking.enable"]; exists {
			val := m.GetAcceleratedNetworking().(*AcceleratedNetworkingType_Enable).Enable
			vOpts := append(opts,
				db.WithValidateField("accelerated_networking"),
				db.WithValidateField("enable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAcceleratedNetworkingTypeValidator = func() *ValidateAcceleratedNetworkingType {
	v := &ValidateAcceleratedNetworkingType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAcceleratedNetworking := v.AcceleratedNetworkingValidationRuleHandler
	rulesAcceleratedNetworking := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAcceleratedNetworking(rulesAcceleratedNetworking)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AcceleratedNetworkingType.accelerated_networking: %s", err)
		panic(errMsg)
	}
	v.FldValidators["accelerated_networking"] = vFn

	return v
}()

func AcceleratedNetworkingTypeValidator() db.Validator {
	return DefaultAcceleratedNetworkingTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertiseCustom) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseCustom) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AdvertiseCustom) DeepCopy() *AdvertiseCustom {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseCustom{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseCustom) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseCustom) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseCustomValidator().Validate(ctx, m, opts...)
}

func (m *AdvertiseCustom) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseWhereDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertiseCustom) GetAdvertiseWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseWhere() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAdvertiseWhere() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseWhere() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("advertise_where[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateAdvertiseCustom struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseCustom) AdvertiseWhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for advertise_where")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*WhereType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := WhereTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for advertise_where")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*WhereType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*WhereType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated advertise_where")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items advertise_where")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseCustom) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseCustom)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseCustom got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_where"]; exists {
		vOpts := append(opts, db.WithValidateField("advertise_where"))
		if err := fv(ctx, m.GetAdvertiseWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseCustomValidator = func() *ValidateAdvertiseCustom {
	v := &ValidateAdvertiseCustom{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseWhere := v.AdvertiseWhereValidationRuleHandler
	rulesAdvertiseWhere := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAdvertiseWhere(rulesAdvertiseWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseCustom.advertise_where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_where"] = vFn

	return v
}()

func AdvertiseCustomValidator() db.Validator {
	return DefaultAdvertiseCustomValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertisePublic) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertisePublic) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AdvertisePublic) DeepCopy() *AdvertisePublic {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertisePublic{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertisePublic) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertisePublic) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertisePublicValidator().Validate(ctx, m, opts...)
}

func (m *AdvertisePublic) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPublicIpDRefInfo()

}

func (m *AdvertisePublic) GetPublicIpDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetPublicIp()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("public_ip.Object")
	dri := db.DRefInfo{
		RefdType:   "public_ip.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "public_ip",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetPublicIpDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *AdvertisePublic) GetPublicIpDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "public_ip.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: public_ip")
	}

	vref := m.GetPublicIp()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "public_ip.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateAdvertisePublic struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertisePublic) PublicIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for public_ip")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertisePublic) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertisePublic)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertisePublic got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["public_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("public_ip"))
		if err := fv(ctx, m.GetPublicIp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertisePublicValidator = func() *ValidateAdvertisePublic {
	v := &ValidateAdvertisePublic{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPublicIp := v.PublicIpValidationRuleHandler
	rulesPublicIp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPublicIp(rulesPublicIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertisePublic.public_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ip"] = vFn

	return v
}()

func AdvertisePublicValidator() db.Validator {
	return DefaultAdvertisePublicValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertiseSiteVsite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseSiteVsite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AdvertiseSiteVsite) DeepCopy() *AdvertiseSiteVsite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseSiteVsite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseSiteVsite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseSiteVsite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseSiteVsiteValidator().Validate(ctx, m, opts...)
}

func (m *AdvertiseSiteVsite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseWhereDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertiseSiteVsite) GetAdvertiseWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseWhere() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAdvertiseWhere() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseWhere() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("advertise_where[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateAdvertiseSiteVsite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseSiteVsite) AdvertiseWhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for advertise_where")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*WhereTypeSiteVsite, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := WhereTypeSiteVsiteValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for advertise_where")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*WhereTypeSiteVsite)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*WhereTypeSiteVsite, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated advertise_where")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items advertise_where")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseSiteVsite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseSiteVsite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseSiteVsite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_where"]; exists {
		vOpts := append(opts, db.WithValidateField("advertise_where"))
		if err := fv(ctx, m.GetAdvertiseWhere(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseSiteVsiteValidator = func() *ValidateAdvertiseSiteVsite {
	v := &ValidateAdvertiseSiteVsite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseWhere := v.AdvertiseWhereValidationRuleHandler
	rulesAdvertiseWhere := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAdvertiseWhere(rulesAdvertiseWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseSiteVsite.advertise_where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_where"] = vFn

	return v
}()

func AdvertiseSiteVsiteValidator() db.Validator {
	return DefaultAdvertiseSiteVsiteValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiEndpointWithSchema) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiEndpointWithSchema) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiEndpointWithSchema) DeepCopy() *ApiEndpointWithSchema {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiEndpointWithSchema{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiEndpointWithSchema) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiEndpointWithSchema) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiEndpointWithSchemaValidator().Validate(ctx, m, opts...)
}

type ValidateApiEndpointWithSchema struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiEndpointWithSchema) ApiOperationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for api_operation")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ApiOperationValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateApiEndpointWithSchema) SchemaJsonValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for schema_json")
	}

	return validatorFn, nil
}

func (v *ValidateApiEndpointWithSchema) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiEndpointWithSchema)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiEndpointWithSchema got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_operation"]; exists {

		vOpts := append(opts, db.WithValidateField("api_operation"))
		if err := fv(ctx, m.GetApiOperation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["schema_json"]; exists {

		vOpts := append(opts, db.WithValidateField("schema_json"))
		if err := fv(ctx, m.GetSchemaJson(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiEndpointWithSchemaValidator = func() *ValidateApiEndpointWithSchema {
	v := &ValidateApiEndpointWithSchema{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiOperation := v.ApiOperationValidationRuleHandler
	rulesApiOperation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhApiOperation(rulesApiOperation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiEndpointWithSchema.api_operation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_operation"] = vFn

	vrhSchemaJson := v.SchemaJsonValidationRuleHandler
	rulesSchemaJson := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "20000",
	}
	vFn, err = vrhSchemaJson(rulesSchemaJson)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiEndpointWithSchema.schema_json: %s", err)
		panic(errMsg)
	}
	v.FldValidators["schema_json"] = vFn

	return v
}()

func ApiEndpointWithSchemaValidator() db.Validator {
	return DefaultApiEndpointWithSchemaValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiOperation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiOperation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiOperation) DeepCopy() *ApiOperation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiOperation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiOperation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiOperation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiOperationValidator().Validate(ctx, m, opts...)
}

type ValidateApiOperation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiOperation) MethodValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpMethod)
		return int32(i)
	}
	// ves_io_schema.HttpMethod_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.HttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for method")
	}

	return validatorFn, nil
}

func (v *ValidateApiOperation) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path")
	}

	return validatorFn, nil
}

func (v *ValidateApiOperation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiOperation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiOperation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["method"]; exists {

		vOpts := append(opts, db.WithValidateField("method"))
		if err := fv(ctx, m.GetMethod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiOperationValidator = func() *ValidateApiOperation {
	v := &ValidateApiOperation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMethod := v.MethodValidationRuleHandler
	rulesMethod := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.not_in":       "0",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhMethod(rulesMethod)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiOperation.method: %s", err)
		panic(errMsg)
	}
	v.FldValidators["method"] = vFn

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required":           "true",
		"ves.io.schema.rules.string.max_bytes":           "1024",
		"ves.io.schema.rules.string.min_bytes":           "1",
		"ves.io.schema.rules.string.templated_http_path": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiOperation.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	return v
}()

func ApiOperationValidator() db.Validator {
	return DefaultApiOperationValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomCiphers) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomCiphers) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomCiphers) DeepCopy() *CustomCiphers {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomCiphers{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomCiphers) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomCiphers) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomCiphersValidator().Validate(ctx, m, opts...)
}

type ValidateCustomCiphers struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomCiphers) CipherSuitesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for cipher_suites")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cipher_suites")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cipher_suites")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cipher_suites")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCustomCiphers) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomCiphers)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomCiphers got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cipher_suites"]; exists {
		vOpts := append(opts, db.WithValidateField("cipher_suites"))
		if err := fv(ctx, m.GetCipherSuites(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_version"]; exists {

		vOpts := append(opts, db.WithValidateField("max_version"))
		if err := fv(ctx, m.GetMaxVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_version"]; exists {

		vOpts := append(opts, db.WithValidateField("min_version"))
		if err := fv(ctx, m.GetMinVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomCiphersValidator = func() *ValidateCustomCiphers {
	v := &ValidateCustomCiphers{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCipherSuites := v.CipherSuitesValidationRuleHandler
	rulesCipherSuites := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.repeated.items.string.in": "[\"TLS_AES_128_GCM_SHA256\",\"TLS_AES_256_GCM_SHA384\",\"TLS_CHACHA20_POLY1305_SHA256\",\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\",\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\",\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\",\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\",\"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\",\"TLS_RSA_WITH_AES_128_CBC_SHA\",\"TLS_RSA_WITH_AES_128_GCM_SHA256\",\"TLS_RSA_WITH_AES_256_CBC_SHA\",\"TLS_RSA_WITH_AES_256_GCM_SHA384\"]",
		"ves.io.schema.rules.repeated.unique":          "true",
	}
	vFn, err = vrhCipherSuites(rulesCipherSuites)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomCiphers.cipher_suites: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cipher_suites"] = vFn

	return v
}()

func CustomCiphersValidator() db.Validator {
	return DefaultCustomCiphersValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomDNS) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomDNS) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomDNS) DeepCopy() *CustomDNS {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomDNS{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomDNS) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomDNS) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomDNSValidator().Validate(ctx, m, opts...)
}

type ValidateCustomDNS struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomDNS) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateCustomDNS) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateCustomDNS) InsideNameserverV6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver_v6")
	}

	return validatorFn, nil
}

func (v *ValidateCustomDNS) OutsideNameserverV6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver_v6")
	}

	return validatorFn, nil
}

func (v *ValidateCustomDNS) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomDNS)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomDNS got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver_v6"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver_v6"))
		if err := fv(ctx, m.GetInsideNameserverV6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver_v6"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver_v6"))
		if err := fv(ctx, m.GetOutsideNameserverV6(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomDNSValidator = func() *ValidateCustomDNS {
	v := &ValidateCustomDNS{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomDNS.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomDNS.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhInsideNameserverV6 := v.InsideNameserverV6ValidationRuleHandler
	rulesInsideNameserverV6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhInsideNameserverV6(rulesInsideNameserverV6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomDNS.inside_nameserver_v6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver_v6"] = vFn

	vrhOutsideNameserverV6 := v.OutsideNameserverV6ValidationRuleHandler
	rulesOutsideNameserverV6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhOutsideNameserverV6(rulesOutsideNameserverV6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomDNS.outside_nameserver_v6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver_v6"] = vFn

	return v
}()

func CustomDNSValidator() db.Validator {
	return DefaultCustomDNSValidator
}

// augmented methods on protoc/std generated struct

func (m *DownstreamTLSCertsParams) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DownstreamTLSCertsParams) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DownstreamTLSCertsParams) DeepCopy() *DownstreamTLSCertsParams {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DownstreamTLSCertsParams{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DownstreamTLSCertsParams) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DownstreamTLSCertsParams) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DownstreamTLSCertsParamsValidator().Validate(ctx, m, opts...)
}

func (m *DownstreamTLSCertsParams) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetCertificatesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCertificatesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetMtlsChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetMtlsChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *DownstreamTLSCertsParams) GetCertificatesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetCertificates()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("DownstreamTLSCertsParams.certificates[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("certificate.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "certificate.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "certificates",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetCertificatesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DownstreamTLSCertsParams) GetCertificatesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "certificate.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: certificate")
	}
	for i, vref := range m.GetCertificates() {
		if vref == nil {
			return nil, fmt.Errorf("DownstreamTLSCertsParams.certificates[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "certificate.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *DownstreamTLSCertsParams) GetMtlsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetMtlsChoice() == nil {
		return nil, nil
	}
	switch m.GetMtlsChoice().(type) {
	case *DownstreamTLSCertsParams_NoMtls:

		return nil, nil

	case *DownstreamTLSCertsParams_UseMtls:

		drInfos, err := m.GetUseMtls().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetUseMtls().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "use_mtls." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateDownstreamTLSCertsParams struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDownstreamTLSCertsParams) MtlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDownstreamTLSCertsParams) CertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDownstreamTLSCertsParams) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DownstreamTLSCertsParams)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DownstreamTLSCertsParams got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("certificates"))
		if err := fv(ctx, m.GetCertificates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mtls_choice"]; exists {
		val := m.GetMtlsChoice()
		vOpts := append(opts,
			db.WithValidateField("mtls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMtlsChoice().(type) {
	case *DownstreamTLSCertsParams_NoMtls:
		if fv, exists := v.FldValidators["mtls_choice.no_mtls"]; exists {
			val := m.GetMtlsChoice().(*DownstreamTLSCertsParams_NoMtls).NoMtls
			vOpts := append(opts,
				db.WithValidateField("mtls_choice"),
				db.WithValidateField("no_mtls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DownstreamTLSCertsParams_UseMtls:
		if fv, exists := v.FldValidators["mtls_choice.use_mtls"]; exists {
			val := m.GetMtlsChoice().(*DownstreamTLSCertsParams_UseMtls).UseMtls
			vOpts := append(opts,
				db.WithValidateField("mtls_choice"),
				db.WithValidateField("use_mtls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_config"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_config"))
		if err := fv(ctx, m.GetTlsConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDownstreamTLSCertsParamsValidator = func() *ValidateDownstreamTLSCertsParams {
	v := &ValidateDownstreamTLSCertsParams{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMtlsChoice := v.MtlsChoiceValidationRuleHandler
	rulesMtlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMtlsChoice(rulesMtlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DownstreamTLSCertsParams.mtls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtls_choice"] = vFn

	vrhCertificates := v.CertificatesValidationRuleHandler
	rulesCertificates := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCertificates(rulesCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DownstreamTLSCertsParams.certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["certificates"] = vFn

	v.FldValidators["mtls_choice.use_mtls"] = DownstreamTlsValidationContextValidator().Validate

	v.FldValidators["tls_config"] = TlsConfigValidator().Validate

	return v
}()

func DownstreamTLSCertsParamsValidator() db.Validator {
	return DefaultDownstreamTLSCertsParamsValidator
}

// augmented methods on protoc/std generated struct

func (m *DownstreamTlsParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DownstreamTlsParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *DownstreamTlsParamsType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetTlsCertificates() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting DownstreamTlsParamsType.tls_certificates idx %v", idx)
		}
	}

	return nil
}

func (m *DownstreamTlsParamsType) DeepCopy() *DownstreamTlsParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DownstreamTlsParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DownstreamTlsParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DownstreamTlsParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DownstreamTlsParamsTypeValidator().Validate(ctx, m, opts...)
}

func (m *DownstreamTlsParamsType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetMtlsChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *DownstreamTlsParamsType) GetMtlsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetMtlsChoice() == nil {
		return nil, nil
	}
	switch m.GetMtlsChoice().(type) {
	case *DownstreamTlsParamsType_NoMtls:

		return nil, nil

	case *DownstreamTlsParamsType_UseMtls:

		drInfos, err := m.GetUseMtls().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetUseMtls().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "use_mtls." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateDownstreamTlsParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDownstreamTlsParamsType) MtlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDownstreamTlsParamsType) TlsCertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for tls_certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.TlsCertificateType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.TlsCertificateTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tls_certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.TlsCertificateType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.TlsCertificateType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tls_certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tls_certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDownstreamTlsParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DownstreamTlsParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DownstreamTlsParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mtls_choice"]; exists {
		val := m.GetMtlsChoice()
		vOpts := append(opts,
			db.WithValidateField("mtls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMtlsChoice().(type) {
	case *DownstreamTlsParamsType_NoMtls:
		if fv, exists := v.FldValidators["mtls_choice.no_mtls"]; exists {
			val := m.GetMtlsChoice().(*DownstreamTlsParamsType_NoMtls).NoMtls
			vOpts := append(opts,
				db.WithValidateField("mtls_choice"),
				db.WithValidateField("no_mtls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DownstreamTlsParamsType_UseMtls:
		if fv, exists := v.FldValidators["mtls_choice.use_mtls"]; exists {
			val := m.GetMtlsChoice().(*DownstreamTlsParamsType_UseMtls).UseMtls
			vOpts := append(opts,
				db.WithValidateField("mtls_choice"),
				db.WithValidateField("use_mtls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("tls_certificates"))
		if err := fv(ctx, m.GetTlsCertificates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_config"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_config"))
		if err := fv(ctx, m.GetTlsConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDownstreamTlsParamsTypeValidator = func() *ValidateDownstreamTlsParamsType {
	v := &ValidateDownstreamTlsParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMtlsChoice := v.MtlsChoiceValidationRuleHandler
	rulesMtlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMtlsChoice(rulesMtlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DownstreamTlsParamsType.mtls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtls_choice"] = vFn

	vrhTlsCertificates := v.TlsCertificatesValidationRuleHandler
	rulesTlsCertificates := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhTlsCertificates(rulesTlsCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DownstreamTlsParamsType.tls_certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_certificates"] = vFn

	v.FldValidators["mtls_choice.use_mtls"] = DownstreamTlsValidationContextValidator().Validate

	v.FldValidators["tls_config"] = TlsConfigValidator().Validate

	return v
}()

func DownstreamTlsParamsTypeValidator() db.Validator {
	return DefaultDownstreamTlsParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DownstreamTlsValidationContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DownstreamTlsValidationContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DownstreamTlsValidationContext) DeepCopy() *DownstreamTlsValidationContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DownstreamTlsValidationContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DownstreamTlsValidationContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DownstreamTlsValidationContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DownstreamTlsValidationContextValidator().Validate(ctx, m, opts...)
}

func (m *DownstreamTlsValidationContext) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetCrlChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCrlChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTrustedCaChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTrustedCaChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *DownstreamTlsValidationContext) GetCrlChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetCrlChoice().(type) {
	case *DownstreamTlsValidationContext_NoCrl:

		return nil, nil

	case *DownstreamTlsValidationContext_Crl:

		vref := m.GetCrl()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("crl.Object")
		dri := db.DRefInfo{
			RefdType:   "crl.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "crl",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetCrlChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DownstreamTlsValidationContext) GetCrlChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetCrlChoice().(type) {
	case *DownstreamTlsValidationContext_NoCrl:

	case *DownstreamTlsValidationContext_Crl:
		refdType, err := d.TypeForEntryKind("", "", "crl.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: crl")
		}

		vref := m.GetCrl()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "crl.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *DownstreamTlsValidationContext) GetTrustedCaChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetTrustedCaChoice().(type) {
	case *DownstreamTlsValidationContext_TrustedCa:

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("trusted_ca_list.Object")
		dri := db.DRefInfo{
			RefdType:   "trusted_ca_list.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "trusted_ca",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetTrustedCaChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DownstreamTlsValidationContext) GetTrustedCaChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetTrustedCaChoice().(type) {
	case *DownstreamTlsValidationContext_TrustedCa:
		refdType, err := d.TypeForEntryKind("", "", "trusted_ca_list.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: trusted_ca_list")
		}

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "trusted_ca_list.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateDownstreamTlsValidationContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDownstreamTlsValidationContext) TrustedCaChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDownstreamTlsValidationContext) TrustedCaChoiceTrustedCaUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_TrustedCaUrl, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_url")
	}
	return oValidatorFn_TrustedCaUrl, nil
}

func (v *ValidateDownstreamTlsValidationContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DownstreamTlsValidationContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DownstreamTlsValidationContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_certificate_optional"]; exists {

		vOpts := append(opts, db.WithValidateField("client_certificate_optional"))
		if err := fv(ctx, m.GetClientCertificateOptional(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetCrlChoice().(type) {
	case *DownstreamTlsValidationContext_NoCrl:
		if fv, exists := v.FldValidators["crl_choice.no_crl"]; exists {
			val := m.GetCrlChoice().(*DownstreamTlsValidationContext_NoCrl).NoCrl
			vOpts := append(opts,
				db.WithValidateField("crl_choice"),
				db.WithValidateField("no_crl"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DownstreamTlsValidationContext_Crl:
		if fv, exists := v.FldValidators["crl_choice.crl"]; exists {
			val := m.GetCrlChoice().(*DownstreamTlsValidationContext_Crl).Crl
			vOpts := append(opts,
				db.WithValidateField("crl_choice"),
				db.WithValidateField("crl"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["trusted_ca_choice"]; exists {
		val := m.GetTrustedCaChoice()
		vOpts := append(opts,
			db.WithValidateField("trusted_ca_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTrustedCaChoice().(type) {
	case *DownstreamTlsValidationContext_TrustedCaUrl:
		if fv, exists := v.FldValidators["trusted_ca_choice.trusted_ca_url"]; exists {
			val := m.GetTrustedCaChoice().(*DownstreamTlsValidationContext_TrustedCaUrl).TrustedCaUrl
			vOpts := append(opts,
				db.WithValidateField("trusted_ca_choice"),
				db.WithValidateField("trusted_ca_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DownstreamTlsValidationContext_TrustedCa:
		if fv, exists := v.FldValidators["trusted_ca_choice.trusted_ca"]; exists {
			val := m.GetTrustedCaChoice().(*DownstreamTlsValidationContext_TrustedCa).TrustedCa
			vOpts := append(opts,
				db.WithValidateField("trusted_ca_choice"),
				db.WithValidateField("trusted_ca"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetXfccHeader().(type) {
	case *DownstreamTlsValidationContext_XfccDisabled:
		if fv, exists := v.FldValidators["xfcc_header.xfcc_disabled"]; exists {
			val := m.GetXfccHeader().(*DownstreamTlsValidationContext_XfccDisabled).XfccDisabled
			vOpts := append(opts,
				db.WithValidateField("xfcc_header"),
				db.WithValidateField("xfcc_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DownstreamTlsValidationContext_XfccOptions:
		if fv, exists := v.FldValidators["xfcc_header.xfcc_options"]; exists {
			val := m.GetXfccHeader().(*DownstreamTlsValidationContext_XfccOptions).XfccOptions
			vOpts := append(opts,
				db.WithValidateField("xfcc_header"),
				db.WithValidateField("xfcc_options"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDownstreamTlsValidationContextValidator = func() *ValidateDownstreamTlsValidationContext {
	v := &ValidateDownstreamTlsValidationContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTrustedCaChoice := v.TrustedCaChoiceValidationRuleHandler
	rulesTrustedCaChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTrustedCaChoice(rulesTrustedCaChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DownstreamTlsValidationContext.trusted_ca_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_choice"] = vFn

	vrhTrustedCaChoiceTrustedCaUrl := v.TrustedCaChoiceTrustedCaUrlValidationRuleHandler
	rulesTrustedCaChoiceTrustedCaUrl := map[string]string{
		"ves.io.schema.rules.string.max_bytes":      "131072",
		"ves.io.schema.rules.string.min_bytes":      "1",
		"ves.io.schema.rules.string.truststore_url": "true",
	}
	vFnMap["trusted_ca_choice.trusted_ca_url"], err = vrhTrustedCaChoiceTrustedCaUrl(rulesTrustedCaChoiceTrustedCaUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DownstreamTlsValidationContext.trusted_ca_choice_trusted_ca_url: %s", err)
		panic(errMsg)
	}

	v.FldValidators["trusted_ca_choice.trusted_ca_url"] = vFnMap["trusted_ca_choice.trusted_ca_url"]

	v.FldValidators["crl_choice.crl"] = ObjectRefTypeValidator().Validate

	v.FldValidators["trusted_ca_choice.trusted_ca"] = ObjectRefTypeValidator().Validate

	v.FldValidators["xfcc_header.xfcc_options"] = XfccHeaderKeysValidator().Validate

	return v
}()

func DownstreamTlsValidationContextValidator() db.Validator {
	return DefaultDownstreamTlsValidationContextValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalConnectorType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalConnectorType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalConnectorType) DeepCopy() *GlobalConnectorType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalConnectorType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalConnectorType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalConnectorType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalConnectorTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalConnectorType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetGlobalVnDRefInfo()

}

func (m *GlobalConnectorType) GetGlobalVnDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetGlobalVn()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_network.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_network.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "global_vn",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetGlobalVnDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalConnectorType) GetGlobalVnDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}

	vref := m.GetGlobalVn()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_network.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateGlobalConnectorType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalConnectorType) GlobalVnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for global_vn")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalConnectorType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalConnectorType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalConnectorType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["global_vn"]; exists {

		vOpts := append(opts, db.WithValidateField("global_vn"))
		if err := fv(ctx, m.GetGlobalVn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalConnectorTypeValidator = func() *ValidateGlobalConnectorType {
	v := &ValidateGlobalConnectorType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhGlobalVn := v.GlobalVnValidationRuleHandler
	rulesGlobalVn := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhGlobalVn(rulesGlobalVn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalConnectorType.global_vn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["global_vn"] = vFn

	return v
}()

func GlobalConnectorTypeValidator() db.Validator {
	return DefaultGlobalConnectorTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InternetVIPInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternetVIPInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternetVIPInfo) DeepCopy() *InternetVIPInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternetVIPInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternetVIPInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternetVIPInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternetVIPInfoValidator().Validate(ctx, m, opts...)
}

type ValidateInternetVIPInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternetVIPInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternetVIPInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternetVIPInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site_name"]; exists {

		vOpts := append(opts, db.WithValidateField("site_name"))
		if err := fv(ctx, m.GetSiteName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_network_type"))
		if err := fv(ctx, m.GetSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternetVIPInfoValidator = func() *ValidateInternetVIPInfo {
	v := &ValidateInternetVIPInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InternetVIPInfoValidator() db.Validator {
	return DefaultInternetVIPInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *InternetVIPListenerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternetVIPListenerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternetVIPListenerStatusType) DeepCopy() *InternetVIPListenerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternetVIPListenerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternetVIPListenerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternetVIPListenerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternetVIPListenerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateInternetVIPListenerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternetVIPListenerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternetVIPListenerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternetVIPListenerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["arn"]; exists {

		vOpts := append(opts, db.WithValidateField("arn"))
		if err := fv(ctx, m.GetArn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol"))
		if err := fv(ctx, m.GetProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternetVIPListenerStatusTypeValidator = func() *ValidateInternetVIPListenerStatusType {
	v := &ValidateInternetVIPListenerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InternetVIPListenerStatusTypeValidator() db.Validator {
	return DefaultInternetVIPListenerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InternetVIPStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternetVIPStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternetVIPStatus) DeepCopy() *InternetVIPStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternetVIPStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternetVIPStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternetVIPStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternetVIPStatusValidator().Validate(ctx, m, opts...)
}

type ValidateInternetVIPStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternetVIPStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternetVIPStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternetVIPStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["arn"]; exists {

		vOpts := append(opts, db.WithValidateField("arn"))
		if err := fv(ctx, m.GetArn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nlb_cname"]; exists {

		vOpts := append(opts, db.WithValidateField("nlb_cname"))
		if err := fv(ctx, m.GetNlbCname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nlb_status"]; exists {

		vOpts := append(opts, db.WithValidateField("nlb_status"))
		if err := fv(ctx, m.GetNlbStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["target_group_status"]; exists {

		vOpts := append(opts, db.WithValidateField("target_group_status"))
		for idx, item := range m.GetTargetGroupStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternetVIPStatusValidator = func() *ValidateInternetVIPStatus {
	v := &ValidateInternetVIPStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InternetVIPStatusValidator() db.Validator {
	return DefaultInternetVIPStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *InternetVIPTargetGroupStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InternetVIPTargetGroupStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InternetVIPTargetGroupStatusType) DeepCopy() *InternetVIPTargetGroupStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InternetVIPTargetGroupStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InternetVIPTargetGroupStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InternetVIPTargetGroupStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InternetVIPTargetGroupStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateInternetVIPTargetGroupStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInternetVIPTargetGroupStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InternetVIPTargetGroupStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InternetVIPTargetGroupStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["arn"]; exists {

		vOpts := append(opts, db.WithValidateField("arn"))
		if err := fv(ctx, m.GetArn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["listener_status"]; exists {

		vOpts := append(opts, db.WithValidateField("listener_status"))
		for idx, item := range m.GetListenerStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol"))
		if err := fv(ctx, m.GetProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInternetVIPTargetGroupStatusTypeValidator = func() *ValidateInternetVIPTargetGroupStatusType {
	v := &ValidateInternetVIPTargetGroupStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InternetVIPTargetGroupStatusTypeValidator() db.Validator {
	return DefaultInternetVIPTargetGroupStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *KubernetesUpgradeDrain) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *KubernetesUpgradeDrain) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *KubernetesUpgradeDrain) DeepCopy() *KubernetesUpgradeDrain {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &KubernetesUpgradeDrain{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *KubernetesUpgradeDrain) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *KubernetesUpgradeDrain) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return KubernetesUpgradeDrainValidator().Validate(ctx, m, opts...)
}

type ValidateKubernetesUpgradeDrain struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateKubernetesUpgradeDrain) KubernetesUpgradeDrainEnableChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for kubernetes_upgrade_drain_enable_choice")
	}
	return validatorFn, nil
}

func (v *ValidateKubernetesUpgradeDrain) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*KubernetesUpgradeDrain)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *KubernetesUpgradeDrain got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["kubernetes_upgrade_drain_enable_choice"]; exists {
		val := m.GetKubernetesUpgradeDrainEnableChoice()
		vOpts := append(opts,
			db.WithValidateField("kubernetes_upgrade_drain_enable_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetKubernetesUpgradeDrainEnableChoice().(type) {
	case *KubernetesUpgradeDrain_EnableUpgradeDrain:
		if fv, exists := v.FldValidators["kubernetes_upgrade_drain_enable_choice.enable_upgrade_drain"]; exists {
			val := m.GetKubernetesUpgradeDrainEnableChoice().(*KubernetesUpgradeDrain_EnableUpgradeDrain).EnableUpgradeDrain
			vOpts := append(opts,
				db.WithValidateField("kubernetes_upgrade_drain_enable_choice"),
				db.WithValidateField("enable_upgrade_drain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *KubernetesUpgradeDrain_DisableUpgradeDrain:
		if fv, exists := v.FldValidators["kubernetes_upgrade_drain_enable_choice.disable_upgrade_drain"]; exists {
			val := m.GetKubernetesUpgradeDrainEnableChoice().(*KubernetesUpgradeDrain_DisableUpgradeDrain).DisableUpgradeDrain
			vOpts := append(opts,
				db.WithValidateField("kubernetes_upgrade_drain_enable_choice"),
				db.WithValidateField("disable_upgrade_drain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultKubernetesUpgradeDrainValidator = func() *ValidateKubernetesUpgradeDrain {
	v := &ValidateKubernetesUpgradeDrain{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKubernetesUpgradeDrainEnableChoice := v.KubernetesUpgradeDrainEnableChoiceValidationRuleHandler
	rulesKubernetesUpgradeDrainEnableChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhKubernetesUpgradeDrainEnableChoice(rulesKubernetesUpgradeDrainEnableChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for KubernetesUpgradeDrain.kubernetes_upgrade_drain_enable_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["kubernetes_upgrade_drain_enable_choice"] = vFn

	v.FldValidators["kubernetes_upgrade_drain_enable_choice.enable_upgrade_drain"] = KubernetesUpgradeDrainConfigValidator().Validate

	return v
}()

func KubernetesUpgradeDrainValidator() db.Validator {
	return DefaultKubernetesUpgradeDrainValidator
}

// augmented methods on protoc/std generated struct

func (m *KubernetesUpgradeDrainConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *KubernetesUpgradeDrainConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *KubernetesUpgradeDrainConfig) DeepCopy() *KubernetesUpgradeDrainConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &KubernetesUpgradeDrainConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *KubernetesUpgradeDrainConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *KubernetesUpgradeDrainConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return KubernetesUpgradeDrainConfigValidator().Validate(ctx, m, opts...)
}

type ValidateKubernetesUpgradeDrainConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateKubernetesUpgradeDrainConfig) DrainMaxUnavailableChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for drain_max_unavailable_choice")
	}
	return validatorFn, nil
}

func (v *ValidateKubernetesUpgradeDrainConfig) DrainMaxUnavailableChoiceDrainMaxUnavailableNodeCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DrainMaxUnavailableNodeCount, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for drain_max_unavailable_node_count")
	}
	return oValidatorFn_DrainMaxUnavailableNodeCount, nil
}
func (v *ValidateKubernetesUpgradeDrainConfig) DrainMaxUnavailableChoiceDrainMaxUnavailableNodePercentageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DrainMaxUnavailableNodePercentage, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for drain_max_unavailable_node_percentage")
	}
	return oValidatorFn_DrainMaxUnavailableNodePercentage, nil
}

func (v *ValidateKubernetesUpgradeDrainConfig) VegaUpgradeModeToggleChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vega_upgrade_mode_toggle_choice")
	}
	return validatorFn, nil
}

func (v *ValidateKubernetesUpgradeDrainConfig) DrainNodeTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for drain_node_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateKubernetesUpgradeDrainConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*KubernetesUpgradeDrainConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *KubernetesUpgradeDrainConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["drain_max_unavailable_choice"]; exists {
		val := m.GetDrainMaxUnavailableChoice()
		vOpts := append(opts,
			db.WithValidateField("drain_max_unavailable_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDrainMaxUnavailableChoice().(type) {
	case *KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount:
		if fv, exists := v.FldValidators["drain_max_unavailable_choice.drain_max_unavailable_node_count"]; exists {
			val := m.GetDrainMaxUnavailableChoice().(*KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodeCount).DrainMaxUnavailableNodeCount
			vOpts := append(opts,
				db.WithValidateField("drain_max_unavailable_choice"),
				db.WithValidateField("drain_max_unavailable_node_count"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodePercentage:
		if fv, exists := v.FldValidators["drain_max_unavailable_choice.drain_max_unavailable_node_percentage"]; exists {
			val := m.GetDrainMaxUnavailableChoice().(*KubernetesUpgradeDrainConfig_DrainMaxUnavailableNodePercentage).DrainMaxUnavailableNodePercentage
			vOpts := append(opts,
				db.WithValidateField("drain_max_unavailable_choice"),
				db.WithValidateField("drain_max_unavailable_node_percentage"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["drain_node_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("drain_node_timeout"))
		if err := fv(ctx, m.GetDrainNodeTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vega_upgrade_mode_toggle_choice"]; exists {
		val := m.GetVegaUpgradeModeToggleChoice()
		vOpts := append(opts,
			db.WithValidateField("vega_upgrade_mode_toggle_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVegaUpgradeModeToggleChoice().(type) {
	case *KubernetesUpgradeDrainConfig_DisableVegaUpgradeMode:
		if fv, exists := v.FldValidators["vega_upgrade_mode_toggle_choice.disable_vega_upgrade_mode"]; exists {
			val := m.GetVegaUpgradeModeToggleChoice().(*KubernetesUpgradeDrainConfig_DisableVegaUpgradeMode).DisableVegaUpgradeMode
			vOpts := append(opts,
				db.WithValidateField("vega_upgrade_mode_toggle_choice"),
				db.WithValidateField("disable_vega_upgrade_mode"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *KubernetesUpgradeDrainConfig_EnableVegaUpgradeMode:
		if fv, exists := v.FldValidators["vega_upgrade_mode_toggle_choice.enable_vega_upgrade_mode"]; exists {
			val := m.GetVegaUpgradeModeToggleChoice().(*KubernetesUpgradeDrainConfig_EnableVegaUpgradeMode).EnableVegaUpgradeMode
			vOpts := append(opts,
				db.WithValidateField("vega_upgrade_mode_toggle_choice"),
				db.WithValidateField("enable_vega_upgrade_mode"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultKubernetesUpgradeDrainConfigValidator = func() *ValidateKubernetesUpgradeDrainConfig {
	v := &ValidateKubernetesUpgradeDrainConfig{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDrainMaxUnavailableChoice := v.DrainMaxUnavailableChoiceValidationRuleHandler
	rulesDrainMaxUnavailableChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDrainMaxUnavailableChoice(rulesDrainMaxUnavailableChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for KubernetesUpgradeDrainConfig.drain_max_unavailable_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["drain_max_unavailable_choice"] = vFn

	vrhDrainMaxUnavailableChoiceDrainMaxUnavailableNodeCount := v.DrainMaxUnavailableChoiceDrainMaxUnavailableNodeCountValidationRuleHandler
	rulesDrainMaxUnavailableChoiceDrainMaxUnavailableNodeCount := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "5000",
	}
	vFnMap["drain_max_unavailable_choice.drain_max_unavailable_node_count"], err = vrhDrainMaxUnavailableChoiceDrainMaxUnavailableNodeCount(rulesDrainMaxUnavailableChoiceDrainMaxUnavailableNodeCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field KubernetesUpgradeDrainConfig.drain_max_unavailable_choice_drain_max_unavailable_node_count: %s", err)
		panic(errMsg)
	}
	vrhDrainMaxUnavailableChoiceDrainMaxUnavailableNodePercentage := v.DrainMaxUnavailableChoiceDrainMaxUnavailableNodePercentageValidationRuleHandler
	rulesDrainMaxUnavailableChoiceDrainMaxUnavailableNodePercentage := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFnMap["drain_max_unavailable_choice.drain_max_unavailable_node_percentage"], err = vrhDrainMaxUnavailableChoiceDrainMaxUnavailableNodePercentage(rulesDrainMaxUnavailableChoiceDrainMaxUnavailableNodePercentage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field KubernetesUpgradeDrainConfig.drain_max_unavailable_choice_drain_max_unavailable_node_percentage: %s", err)
		panic(errMsg)
	}

	v.FldValidators["drain_max_unavailable_choice.drain_max_unavailable_node_count"] = vFnMap["drain_max_unavailable_choice.drain_max_unavailable_node_count"]
	v.FldValidators["drain_max_unavailable_choice.drain_max_unavailable_node_percentage"] = vFnMap["drain_max_unavailable_choice.drain_max_unavailable_node_percentage"]

	vrhVegaUpgradeModeToggleChoice := v.VegaUpgradeModeToggleChoiceValidationRuleHandler
	rulesVegaUpgradeModeToggleChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVegaUpgradeModeToggleChoice(rulesVegaUpgradeModeToggleChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for KubernetesUpgradeDrainConfig.vega_upgrade_mode_toggle_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vega_upgrade_mode_toggle_choice"] = vFn

	vrhDrainNodeTimeout := v.DrainNodeTimeoutValidationRuleHandler
	rulesDrainNodeTimeout := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "900",
	}
	vFn, err = vrhDrainNodeTimeout(rulesDrainNodeTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for KubernetesUpgradeDrainConfig.drain_node_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["drain_node_timeout"] = vFn

	return v
}()

func KubernetesUpgradeDrainConfigValidator() db.Validator {
	return DefaultKubernetesUpgradeDrainConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *L3PerformanceEnhancementType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *L3PerformanceEnhancementType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *L3PerformanceEnhancementType) DeepCopy() *L3PerformanceEnhancementType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &L3PerformanceEnhancementType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *L3PerformanceEnhancementType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *L3PerformanceEnhancementType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return L3PerformanceEnhancementTypeValidator().Validate(ctx, m, opts...)
}

type ValidateL3PerformanceEnhancementType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateL3PerformanceEnhancementType) PerfModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for perf_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateL3PerformanceEnhancementType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*L3PerformanceEnhancementType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *L3PerformanceEnhancementType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["perf_mode_choice"]; exists {
		val := m.GetPerfModeChoice()
		vOpts := append(opts,
			db.WithValidateField("perf_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPerfModeChoice().(type) {
	case *L3PerformanceEnhancementType_NoJumbo:
		if fv, exists := v.FldValidators["perf_mode_choice.no_jumbo"]; exists {
			val := m.GetPerfModeChoice().(*L3PerformanceEnhancementType_NoJumbo).NoJumbo
			vOpts := append(opts,
				db.WithValidateField("perf_mode_choice"),
				db.WithValidateField("no_jumbo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *L3PerformanceEnhancementType_Jumbo:
		if fv, exists := v.FldValidators["perf_mode_choice.jumbo"]; exists {
			val := m.GetPerfModeChoice().(*L3PerformanceEnhancementType_Jumbo).Jumbo
			vOpts := append(opts,
				db.WithValidateField("perf_mode_choice"),
				db.WithValidateField("jumbo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultL3PerformanceEnhancementTypeValidator = func() *ValidateL3PerformanceEnhancementType {
	v := &ValidateL3PerformanceEnhancementType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPerfModeChoice := v.PerfModeChoiceValidationRuleHandler
	rulesPerfModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPerfModeChoice(rulesPerfModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for L3PerformanceEnhancementType.perf_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["perf_mode_choice"] = vFn

	return v
}()

func L3PerformanceEnhancementTypeValidator() db.Validator {
	return DefaultL3PerformanceEnhancementTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LinkRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LinkRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LinkRefType) DeepCopy() *LinkRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LinkRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LinkRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LinkRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LinkRefTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLinkRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLinkRefType) HrefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for href")
	}

	return validatorFn, nil
}

func (v *ValidateLinkRefType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateLinkRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LinkRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LinkRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["href"]; exists {

		vOpts := append(opts, db.WithValidateField("href"))
		if err := fv(ctx, m.GetHref(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLinkRefTypeValidator = func() *ValidateLinkRefType {
	v := &ValidateLinkRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHref := v.HrefValidationRuleHandler
	rulesHref := map[string]string{
		"ves.io.schema.rules.string.max_len": "512",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhHref(rulesHref)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LinkRefType.href: %s", err)
		panic(errMsg)
	}
	v.FldValidators["href"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LinkRefType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func LinkRefTypeValidator() db.Validator {
	return DefaultLinkRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MasterNode) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MasterNode) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MasterNode) DeepCopy() *MasterNode {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MasterNode{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MasterNode) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MasterNode) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MasterNodeValidator().Validate(ctx, m, opts...)
}

type ValidateMasterNode struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMasterNode) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateMasterNode) PublicIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for public_ip")
	}

	return validatorFn, nil
}

func (v *ValidateMasterNode) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MasterNode)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MasterNode got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("public_ip"))
		if err := fv(ctx, m.GetPublicIp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMasterNodeValidator = func() *ValidateMasterNode {
	v := &ValidateMasterNode{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MasterNode.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhPublicIp := v.PublicIpValidationRuleHandler
	rulesPublicIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhPublicIp(rulesPublicIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MasterNode.public_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ip"] = vFn

	return v
}()

func MasterNodeValidator() db.Validator {
	return DefaultMasterNodeValidator
}

// augmented methods on protoc/std generated struct

func (m *ObjectRefType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ObjectRefType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ObjectRefType) DeepCopy() *ObjectRefType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ObjectRefType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ObjectRefType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ObjectRefType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ObjectRefTypeValidator().Validate(ctx, m, opts...)
}

// SetName sets the field
func (m *ObjectRefType) SetName(in string) {
	m.Name = in
}

// SetNamespace sets the field
func (m *ObjectRefType) SetNamespace(in string) {
	m.Namespace = in
}

// SetTenant sets the field
func (m *ObjectRefType) SetTenant(in string) {
	m.Tenant = in
}

type ValidateObjectRefType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateObjectRefType) TenantValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tenant")
	}

	return validatorFn, nil
}

func (v *ValidateObjectRefType) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateObjectRefType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateObjectRefType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ObjectRefType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ObjectRefType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultObjectRefTypeValidator = func() *ValidateObjectRefType {
	v := &ValidateObjectRefType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTenant := v.TenantValidationRuleHandler
	rulesTenant := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
	}
	vFn, err = vrhTenant(rulesTenant)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectRefType.tenant: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tenant"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectRefType.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "128",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ObjectRefType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func ObjectRefTypeValidator() db.Validator {
	return DefaultObjectRefTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OperatingSystemType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OperatingSystemType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OperatingSystemType) DeepCopy() *OperatingSystemType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OperatingSystemType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OperatingSystemType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OperatingSystemType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OperatingSystemTypeValidator().Validate(ctx, m, opts...)
}

type ValidateOperatingSystemType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOperatingSystemType) OperatingSystemVersionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOperatingSystemType) OperatingSystemVersionChoiceOperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_OperatingSystemVersion, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}
	return oValidatorFn_OperatingSystemVersion, nil
}

func (v *ValidateOperatingSystemType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OperatingSystemType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OperatingSystemType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["operating_system_version_choice"]; exists {
		val := m.GetOperatingSystemVersionChoice()
		vOpts := append(opts,
			db.WithValidateField("operating_system_version_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOperatingSystemVersionChoice().(type) {
	case *OperatingSystemType_DefaultOsVersion:
		if fv, exists := v.FldValidators["operating_system_version_choice.default_os_version"]; exists {
			val := m.GetOperatingSystemVersionChoice().(*OperatingSystemType_DefaultOsVersion).DefaultOsVersion
			vOpts := append(opts,
				db.WithValidateField("operating_system_version_choice"),
				db.WithValidateField("default_os_version"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OperatingSystemType_OperatingSystemVersion:
		if fv, exists := v.FldValidators["operating_system_version_choice.operating_system_version"]; exists {
			val := m.GetOperatingSystemVersionChoice().(*OperatingSystemType_OperatingSystemVersion).OperatingSystemVersion
			vOpts := append(opts,
				db.WithValidateField("operating_system_version_choice"),
				db.WithValidateField("operating_system_version"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOperatingSystemTypeValidator = func() *ValidateOperatingSystemType {
	v := &ValidateOperatingSystemType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOperatingSystemVersionChoice := v.OperatingSystemVersionChoiceValidationRuleHandler
	rulesOperatingSystemVersionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhOperatingSystemVersionChoice(rulesOperatingSystemVersionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OperatingSystemType.operating_system_version_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version_choice"] = vFn

	vrhOperatingSystemVersionChoiceOperatingSystemVersion := v.OperatingSystemVersionChoiceOperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersionChoiceOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "20",
	}
	vFnMap["operating_system_version_choice.operating_system_version"], err = vrhOperatingSystemVersionChoiceOperatingSystemVersion(rulesOperatingSystemVersionChoiceOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OperatingSystemType.operating_system_version_choice_operating_system_version: %s", err)
		panic(errMsg)
	}

	v.FldValidators["operating_system_version_choice.operating_system_version"] = vFnMap["operating_system_version_choice.operating_system_version"]

	return v
}()

func OperatingSystemTypeValidator() db.Validator {
	return DefaultOperatingSystemTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginPoolListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginPoolListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginPoolListType) DeepCopy() *OriginPoolListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginPoolListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginPoolListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginPoolListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginPoolListTypeValidator().Validate(ctx, m, opts...)
}

func (m *OriginPoolListType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPoolsDRefInfo()

}

// GetDRefInfo for the field's type
func (m *OriginPoolListType) GetPoolsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetPools() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetPools() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPools() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("pools[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateOriginPoolListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginPoolListType) PoolsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for pools")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*OriginPoolWithWeight, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := OriginPoolWithWeightValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for pools")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OriginPoolWithWeight)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OriginPoolWithWeight, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated pools")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items pools")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginPoolListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginPoolListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["pools"]; exists {
		vOpts := append(opts, db.WithValidateField("pools"))
		if err := fv(ctx, m.GetPools(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginPoolListTypeValidator = func() *ValidateOriginPoolListType {
	v := &ValidateOriginPoolListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPools := v.PoolsValidationRuleHandler
	rulesPools := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhPools(rulesPools)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolListType.pools: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pools"] = vFn

	return v
}()

func OriginPoolListTypeValidator() db.Validator {
	return DefaultOriginPoolListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginPoolWithWeight) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginPoolWithWeight) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginPoolWithWeight) DeepCopy() *OriginPoolWithWeight {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginPoolWithWeight{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginPoolWithWeight) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginPoolWithWeight) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginPoolWithWeightValidator().Validate(ctx, m, opts...)
}

func (m *OriginPoolWithWeight) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPoolChoiceDRefInfo()

}

func (m *OriginPoolWithWeight) GetPoolChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetPoolChoice().(type) {
	case *OriginPoolWithWeight_Pool:

		vref := m.GetPool()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("origin_pool.Object")
		dri := db.DRefInfo{
			RefdType:   "origin_pool.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "pool",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *OriginPoolWithWeight_Cluster:

		vref := m.GetCluster()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("cluster.Object")
		dri := db.DRefInfo{
			RefdType:   "cluster.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "cluster",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetPoolChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *OriginPoolWithWeight) GetPoolChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetPoolChoice().(type) {
	case *OriginPoolWithWeight_Pool:
		refdType, err := d.TypeForEntryKind("", "", "origin_pool.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: origin_pool")
		}

		vref := m.GetPool()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "origin_pool.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *OriginPoolWithWeight_Cluster:
		refdType, err := d.TypeForEntryKind("", "", "cluster.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: cluster")
		}

		vref := m.GetCluster()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "cluster.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateOriginPoolWithWeight struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginPoolWithWeight) PoolChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pool_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginPoolWithWeight) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for endpoint_subsets")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolWithWeight) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolWithWeight) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginPoolWithWeight)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginPoolWithWeight got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_choice"]; exists {
		val := m.GetPoolChoice()
		vOpts := append(opts,
			db.WithValidateField("pool_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPoolChoice().(type) {
	case *OriginPoolWithWeight_Pool:
		if fv, exists := v.FldValidators["pool_choice.pool"]; exists {
			val := m.GetPoolChoice().(*OriginPoolWithWeight_Pool).Pool
			vOpts := append(opts,
				db.WithValidateField("pool_choice"),
				db.WithValidateField("pool"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolWithWeight_Cluster:
		if fv, exists := v.FldValidators["pool_choice.cluster"]; exists {
			val := m.GetPoolChoice().(*OriginPoolWithWeight_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("pool_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["weight"]; exists {

		vOpts := append(opts, db.WithValidateField("weight"))
		if err := fv(ctx, m.GetWeight(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginPoolWithWeightValidator = func() *ValidateOriginPoolWithWeight {
	v := &ValidateOriginPoolWithWeight{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPoolChoice := v.PoolChoiceValidationRuleHandler
	rulesPoolChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPoolChoice(rulesPoolChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolWithWeight.pool_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pool_choice"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "16",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolWithWeight.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.lte": "32",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolWithWeight.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	v.FldValidators["pool_choice.pool"] = ObjectRefTypeValidator().Validate
	v.FldValidators["pool_choice.cluster"] = ObjectRefTypeValidator().Validate

	return v
}()

func OriginPoolWithWeightValidator() db.Validator {
	return DefaultOriginPoolWithWeightValidator
}

// augmented methods on protoc/std generated struct

func (m *PerformanceEnhancementModeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PerformanceEnhancementModeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PerformanceEnhancementModeType) DeepCopy() *PerformanceEnhancementModeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PerformanceEnhancementModeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PerformanceEnhancementModeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PerformanceEnhancementModeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PerformanceEnhancementModeTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePerformanceEnhancementModeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePerformanceEnhancementModeType) PerfModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for perf_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePerformanceEnhancementModeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PerformanceEnhancementModeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PerformanceEnhancementModeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["perf_mode_choice"]; exists {
		val := m.GetPerfModeChoice()
		vOpts := append(opts,
			db.WithValidateField("perf_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPerfModeChoice().(type) {
	case *PerformanceEnhancementModeType_PerfModeL7Enhanced:
		if fv, exists := v.FldValidators["perf_mode_choice.perf_mode_l7_enhanced"]; exists {
			val := m.GetPerfModeChoice().(*PerformanceEnhancementModeType_PerfModeL7Enhanced).PerfModeL7Enhanced
			vOpts := append(opts,
				db.WithValidateField("perf_mode_choice"),
				db.WithValidateField("perf_mode_l7_enhanced"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PerformanceEnhancementModeType_PerfModeL3Enhanced:
		if fv, exists := v.FldValidators["perf_mode_choice.perf_mode_l3_enhanced"]; exists {
			val := m.GetPerfModeChoice().(*PerformanceEnhancementModeType_PerfModeL3Enhanced).PerfModeL3Enhanced
			vOpts := append(opts,
				db.WithValidateField("perf_mode_choice"),
				db.WithValidateField("perf_mode_l3_enhanced"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPerformanceEnhancementModeTypeValidator = func() *ValidatePerformanceEnhancementModeType {
	v := &ValidatePerformanceEnhancementModeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPerfModeChoice := v.PerfModeChoiceValidationRuleHandler
	rulesPerfModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPerfModeChoice(rulesPerfModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PerformanceEnhancementModeType.perf_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["perf_mode_choice"] = vFn

	v.FldValidators["perf_mode_choice.perf_mode_l3_enhanced"] = L3PerformanceEnhancementTypeValidator().Validate

	return v
}()

func PerformanceEnhancementModeTypeValidator() db.Validator {
	return DefaultPerformanceEnhancementModeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PrefixStringListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PrefixStringListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PrefixStringListType) DeepCopy() *PrefixStringListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PrefixStringListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PrefixStringListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PrefixStringListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PrefixStringListTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePrefixStringListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePrefixStringListType) PrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePrefixStringListType) Ipv6PrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ipv6_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ipv6_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ipv6_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ipv6_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePrefixStringListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PrefixStringListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PrefixStringListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ipv6_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("ipv6_prefixes"))
		if err := fv(ctx, m.GetIpv6Prefixes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("prefixes"))
		if err := fv(ctx, m.GetPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPrefixStringListTypeValidator = func() *ValidatePrefixStringListType {
	v := &ValidatePrefixStringListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixes := v.PrefixesValidationRuleHandler
	rulesPrefixes := map[string]string{
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "128",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhPrefixes(rulesPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PrefixStringListType.prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefixes"] = vFn

	vrhIpv6Prefixes := v.Ipv6PrefixesValidationRuleHandler
	rulesIpv6Prefixes := map[string]string{
		"ves.io.schema.rules.repeated.items.string.ipv6_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "128",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhIpv6Prefixes(rulesIpv6Prefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PrefixStringListType.ipv6_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6_prefixes"] = vFn

	return v
}()

func PrefixStringListTypeValidator() db.Validator {
	return DefaultPrefixStringListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RegionalEdgeSelection) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RegionalEdgeSelection) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RegionalEdgeSelection) DeepCopy() *RegionalEdgeSelection {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RegionalEdgeSelection{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RegionalEdgeSelection) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RegionalEdgeSelection) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RegionalEdgeSelectionValidator().Validate(ctx, m, opts...)
}

type ValidateRegionalEdgeSelection struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRegionalEdgeSelection) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RegionalEdgeSelection)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RegionalEdgeSelection got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetReSelectionChoice().(type) {
	case *RegionalEdgeSelection_GeoProximity:
		if fv, exists := v.FldValidators["re_selection_choice.geo_proximity"]; exists {
			val := m.GetReSelectionChoice().(*RegionalEdgeSelection_GeoProximity).GeoProximity
			vOpts := append(opts,
				db.WithValidateField("re_selection_choice"),
				db.WithValidateField("geo_proximity"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RegionalEdgeSelection_SpecificGeography:
		if fv, exists := v.FldValidators["re_selection_choice.specific_geography"]; exists {
			val := m.GetReSelectionChoice().(*RegionalEdgeSelection_SpecificGeography).SpecificGeography
			vOpts := append(opts,
				db.WithValidateField("re_selection_choice"),
				db.WithValidateField("specific_geography"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RegionalEdgeSelection_SpecificRe:
		if fv, exists := v.FldValidators["re_selection_choice.specific_re"]; exists {
			val := m.GetReSelectionChoice().(*RegionalEdgeSelection_SpecificRe).SpecificRe
			vOpts := append(opts,
				db.WithValidateField("re_selection_choice"),
				db.WithValidateField("specific_re"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRegionalEdgeSelectionValidator = func() *ValidateRegionalEdgeSelection {
	v := &ValidateRegionalEdgeSelection{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["re_selection_choice.specific_re"] = SpecificREValidator().Validate

	return v
}()

func RegionalEdgeSelectionValidator() db.Validator {
	return DefaultRegionalEdgeSelectionValidator
}

// augmented methods on protoc/std generated struct

func (m *SegmentRefList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SegmentRefList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SegmentRefList) DeepCopy() *SegmentRefList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SegmentRefList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SegmentRefList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SegmentRefList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SegmentRefListValidator().Validate(ctx, m, opts...)
}

func (m *SegmentRefList) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSegmentsDRefInfo()

}

func (m *SegmentRefList) GetSegmentsDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetSegments()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("SegmentRefList.segments[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("segment.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "segment.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "segments",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetSegmentsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SegmentRefList) GetSegmentsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "segment.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: segment")
	}
	for i, vref := range m.GetSegments() {
		if vref == nil {
			return nil, fmt.Errorf("SegmentRefList.segments[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "segment.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSegmentRefList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSegmentRefList) SegmentsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for segments")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for segments")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated segments")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items segments")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSegmentRefList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SegmentRefList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SegmentRefList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["segments"]; exists {
		vOpts := append(opts, db.WithValidateField("segments"))
		if err := fv(ctx, m.GetSegments(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSegmentRefListValidator = func() *ValidateSegmentRefList {
	v := &ValidateSegmentRefList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSegments := v.SegmentsValidationRuleHandler
	rulesSegments := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSegments(rulesSegments)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SegmentRefList.segments: %s", err)
		panic(errMsg)
	}
	v.FldValidators["segments"] = vFn

	return v
}()

func SegmentRefListValidator() db.Validator {
	return DefaultSegmentRefListValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteLocator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteLocator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteLocator) DeepCopy() *SiteLocator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteLocator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteLocator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteLocator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteLocatorValidator().Validate(ctx, m, opts...)
}

func (m *SiteLocator) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

func (m *SiteLocator) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetChoice().(type) {
	case *SiteLocator_Site:

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("site.Object")
		dri := db.DRefInfo{
			RefdType:   "site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *SiteLocator_VirtualSite:

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_site.Object")
		dri := db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "virtual_site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteLocator) GetChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetChoice().(type) {
	case *SiteLocator_Site:
		refdType, err := d.TypeForEntryKind("", "", "site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: site")
		}

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *SiteLocator_VirtualSite:
		refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
		}

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateSiteLocator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteLocator) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateSiteLocator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteLocator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteLocator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *SiteLocator_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*SiteLocator_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteLocator_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*SiteLocator_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteLocatorValidator = func() *ValidateSiteLocator {
	v := &ValidateSiteLocator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteLocator.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.site"] = ObjectRefTypeValidator().Validate
	v.FldValidators["choice.virtual_site"] = ObjectRefTypeValidator().Validate

	return v
}()

func SiteLocatorValidator() db.Validator {
	return DefaultSiteLocatorValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteReferenceListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteReferenceListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteReferenceListType) DeepCopy() *SiteReferenceListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteReferenceListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteReferenceListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteReferenceListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteReferenceListTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteReferenceListType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRefsDRefInfo()

}

func (m *SiteReferenceListType) GetRefsDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetRefs()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("SiteReferenceListType.refs[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("site.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "refs",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetRefsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteReferenceListType) GetRefsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for i, vref := range m.GetRefs() {
		if vref == nil {
			return nil, fmt.Errorf("SiteReferenceListType.refs[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateSiteReferenceListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteReferenceListType) RefsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for refs")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for refs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated refs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items refs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSiteReferenceListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteReferenceListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteReferenceListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["refs"]; exists {
		vOpts := append(opts, db.WithValidateField("refs"))
		if err := fv(ctx, m.GetRefs(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteReferenceListTypeValidator = func() *ValidateSiteReferenceListType {
	v := &ValidateSiteReferenceListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRefs := v.RefsValidationRuleHandler
	rulesRefs := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
	}
	vFn, err = vrhRefs(rulesRefs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteReferenceListType.refs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["refs"] = vFn

	return v
}()

func SiteReferenceListTypeValidator() db.Validator {
	return DefaultSiteReferenceListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteRegionLocator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteRegionLocator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteRegionLocator) DeepCopy() *SiteRegionLocator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteRegionLocator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteRegionLocator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteRegionLocator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteRegionLocatorValidator().Validate(ctx, m, opts...)
}

func (m *SiteRegionLocator) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

func (m *SiteRegionLocator) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetChoice().(type) {
	case *SiteRegionLocator_Site:

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("site.Object")
		dri := db.DRefInfo{
			RefdType:   "site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *SiteRegionLocator_CloudReRegion:

		vref := m.GetCloudReRegion()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("cloud_region.Object")
		dri := db.DRefInfo{
			RefdType:   "cloud_region.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "cloud_re_region",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *SiteRegionLocator_VirtualSite:

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_site.Object")
		dri := db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "virtual_site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteRegionLocator) GetChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetChoice().(type) {
	case *SiteRegionLocator_Site:
		refdType, err := d.TypeForEntryKind("", "", "site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: site")
		}

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *SiteRegionLocator_CloudReRegion:
		refdType, err := d.TypeForEntryKind("", "", "cloud_region.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: cloud_region")
		}

		vref := m.GetCloudReRegion()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "cloud_region.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *SiteRegionLocator_VirtualSite:
		refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
		}

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateSiteRegionLocator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteRegionLocator) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateSiteRegionLocator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteRegionLocator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteRegionLocator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *SiteRegionLocator_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*SiteRegionLocator_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteRegionLocator_CloudReRegion:
		if fv, exists := v.FldValidators["choice.cloud_re_region"]; exists {
			val := m.GetChoice().(*SiteRegionLocator_CloudReRegion).CloudReRegion
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("cloud_re_region"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteRegionLocator_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*SiteRegionLocator_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteRegionLocatorValidator = func() *ValidateSiteRegionLocator {
	v := &ValidateSiteRegionLocator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteRegionLocator.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.site"] = ObjectRefTypeValidator().Validate
	v.FldValidators["choice.cloud_re_region"] = ObjectRefTypeValidator().Validate
	v.FldValidators["choice.virtual_site"] = ObjectRefTypeValidator().Validate

	return v
}()

func SiteRegionLocatorValidator() db.Validator {
	return DefaultSiteRegionLocatorValidator
}

// augmented methods on protoc/std generated struct

func (m *SpecificRE) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SpecificRE) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SpecificRE) DeepCopy() *SpecificRE {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SpecificRE{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SpecificRE) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SpecificRE) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SpecificREValidator().Validate(ctx, m, opts...)
}

type ValidateSpecificRE struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSpecificRE) PrimaryReValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_re")
	}

	return validatorFn, nil
}

func (v *ValidateSpecificRE) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SpecificRE)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SpecificRE got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["backup_re"]; exists {

		vOpts := append(opts, db.WithValidateField("backup_re"))
		if err := fv(ctx, m.GetBackupRe(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["primary_re"]; exists {

		vOpts := append(opts, db.WithValidateField("primary_re"))
		if err := fv(ctx, m.GetPrimaryRe(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSpecificREValidator = func() *ValidateSpecificRE {
	v := &ValidateSpecificRE{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrimaryRe := v.PrimaryReValidationRuleHandler
	rulesPrimaryRe := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFn, err = vrhPrimaryRe(rulesPrimaryRe)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SpecificRE.primary_re: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_re"] = vFn

	return v
}()

func SpecificREValidator() db.Validator {
	return DefaultSpecificREValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TlsConfig) DeepCopy() *TlsConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsConfigValidator().Validate(ctx, m, opts...)
}

type ValidateTlsConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsConfig) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateTlsConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *TlsConfig_DefaultSecurity:
		if fv, exists := v.FldValidators["choice.default_security"]; exists {
			val := m.GetChoice().(*TlsConfig_DefaultSecurity).DefaultSecurity
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("default_security"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsConfig_MediumSecurity:
		if fv, exists := v.FldValidators["choice.medium_security"]; exists {
			val := m.GetChoice().(*TlsConfig_MediumSecurity).MediumSecurity
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("medium_security"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsConfig_LowSecurity:
		if fv, exists := v.FldValidators["choice.low_security"]; exists {
			val := m.GetChoice().(*TlsConfig_LowSecurity).LowSecurity
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("low_security"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TlsConfig_CustomSecurity:
		if fv, exists := v.FldValidators["choice.custom_security"]; exists {
			val := m.GetChoice().(*TlsConfig_CustomSecurity).CustomSecurity
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("custom_security"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsConfigValidator = func() *ValidateTlsConfig {
	v := &ValidateTlsConfig{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsConfig.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.custom_security"] = CustomCiphersValidator().Validate

	return v
}()

func TlsConfigValidator() db.Validator {
	return DefaultTlsConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *VolterraSoftwareType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolterraSoftwareType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolterraSoftwareType) DeepCopy() *VolterraSoftwareType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolterraSoftwareType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolterraSoftwareType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolterraSoftwareType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolterraSoftwareTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVolterraSoftwareType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolterraSoftwareType) VolterraSwVersionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_sw_version_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVolterraSoftwareType) VolterraSwVersionChoiceVolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VolterraSoftwareVersion, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}
	return oValidatorFn_VolterraSoftwareVersion, nil
}

func (v *ValidateVolterraSoftwareType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolterraSoftwareType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolterraSoftwareType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["volterra_sw_version_choice"]; exists {
		val := m.GetVolterraSwVersionChoice()
		vOpts := append(opts,
			db.WithValidateField("volterra_sw_version_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVolterraSwVersionChoice().(type) {
	case *VolterraSoftwareType_DefaultSwVersion:
		if fv, exists := v.FldValidators["volterra_sw_version_choice.default_sw_version"]; exists {
			val := m.GetVolterraSwVersionChoice().(*VolterraSoftwareType_DefaultSwVersion).DefaultSwVersion
			vOpts := append(opts,
				db.WithValidateField("volterra_sw_version_choice"),
				db.WithValidateField("default_sw_version"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VolterraSoftwareType_VolterraSoftwareVersion:
		if fv, exists := v.FldValidators["volterra_sw_version_choice.volterra_software_version"]; exists {
			val := m.GetVolterraSwVersionChoice().(*VolterraSoftwareType_VolterraSoftwareVersion).VolterraSoftwareVersion
			vOpts := append(opts,
				db.WithValidateField("volterra_sw_version_choice"),
				db.WithValidateField("volterra_software_version"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolterraSoftwareTypeValidator = func() *ValidateVolterraSoftwareType {
	v := &ValidateVolterraSoftwareType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVolterraSwVersionChoice := v.VolterraSwVersionChoiceValidationRuleHandler
	rulesVolterraSwVersionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVolterraSwVersionChoice(rulesVolterraSwVersionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VolterraSoftwareType.volterra_sw_version_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_sw_version_choice"] = vFn

	vrhVolterraSwVersionChoiceVolterraSoftwareVersion := v.VolterraSwVersionChoiceVolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSwVersionChoiceVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "20",
	}
	vFnMap["volterra_sw_version_choice.volterra_software_version"], err = vrhVolterraSwVersionChoiceVolterraSoftwareVersion(rulesVolterraSwVersionChoiceVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field VolterraSoftwareType.volterra_sw_version_choice_volterra_software_version: %s", err)
		panic(errMsg)
	}

	v.FldValidators["volterra_sw_version_choice.volterra_software_version"] = vFnMap["volterra_sw_version_choice.volterra_software_version"]

	return v
}()

func VolterraSoftwareTypeValidator() db.Validator {
	return DefaultVolterraSoftwareTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereCloudEdgeSegment) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereCloudEdgeSegment) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereCloudEdgeSegment) DeepCopy() *WhereCloudEdgeSegment {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereCloudEdgeSegment{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereCloudEdgeSegment) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereCloudEdgeSegment) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereCloudEdgeSegmentValidator().Validate(ctx, m, opts...)
}

func (m *WhereCloudEdgeSegment) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetCloudEdgeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetCloudEdgeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSegmentDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSegmentDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *WhereCloudEdgeSegment) GetCloudEdgeDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetCloudEdge()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("cloud_region.Object")
	dri := db.DRefInfo{
		RefdType:   "cloud_region.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "cloud_edge",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetCloudEdgeDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereCloudEdgeSegment) GetCloudEdgeDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "cloud_region.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: cloud_region")
	}

	vref := m.GetCloudEdge()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "cloud_region.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

func (m *WhereCloudEdgeSegment) GetSegmentDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetSegment()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("segment.Object")
	dri := db.DRefInfo{
		RefdType:   "segment.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "segment",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetSegmentDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereCloudEdgeSegment) GetSegmentDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "segment.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: segment")
	}

	vref := m.GetSegment()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "segment.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereCloudEdgeSegment struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereCloudEdgeSegment) SegmentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for segment")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereCloudEdgeSegment) CloudEdgeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for cloud_edge")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereCloudEdgeSegment) IpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}

	return validatorFn, nil
}

func (v *ValidateWhereCloudEdgeSegment) Ipv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}

	return validatorFn, nil
}

func (v *ValidateWhereCloudEdgeSegment) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereCloudEdgeSegment)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereCloudEdgeSegment got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloud_edge"]; exists {

		vOpts := append(opts, db.WithValidateField("cloud_edge"))
		if err := fv(ctx, m.GetCloudEdge(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6"))
		if err := fv(ctx, m.GetIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["segment"]; exists {

		vOpts := append(opts, db.WithValidateField("segment"))
		if err := fv(ctx, m.GetSegment(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereCloudEdgeSegmentValidator = func() *ValidateWhereCloudEdgeSegment {
	v := &ValidateWhereCloudEdgeSegment{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSegment := v.SegmentValidationRuleHandler
	rulesSegment := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSegment(rulesSegment)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereCloudEdgeSegment.segment: %s", err)
		panic(errMsg)
	}
	v.FldValidators["segment"] = vFn

	vrhCloudEdge := v.CloudEdgeValidationRuleHandler
	rulesCloudEdge := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCloudEdge(rulesCloudEdge)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereCloudEdgeSegment.cloud_edge: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cloud_edge"] = vFn

	vrhIp := v.IpValidationRuleHandler
	rulesIp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
	}
	vFn, err = vrhIp(rulesIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereCloudEdgeSegment.ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip"] = vFn

	vrhIpv6 := v.Ipv6ValidationRuleHandler
	rulesIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhIpv6(rulesIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereCloudEdgeSegment.ipv6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6"] = vFn

	return v
}()

func WhereCloudEdgeSegmentValidator() db.Validator {
	return DefaultWhereCloudEdgeSegmentValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereSegment) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereSegment) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereSegment) DeepCopy() *WhereSegment {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereSegment{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereSegment) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereSegment) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereSegmentValidator().Validate(ctx, m, opts...)
}

func (m *WhereSegment) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSegmentDRefInfo()

}

func (m *WhereSegment) GetSegmentDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetSegment()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("segment.Object")
	dri := db.DRefInfo{
		RefdType:   "segment.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "segment",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetSegmentDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereSegment) GetSegmentDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "segment.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: segment")
	}

	vref := m.GetSegment()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "segment.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereSegment struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereSegment) SegmentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for segment")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereSegment) Ipv4VipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv4_vip")
	}

	return validatorFn, nil
}

func (v *ValidateWhereSegment) Ipv6VipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6_vip")
	}

	return validatorFn, nil
}

func (v *ValidateWhereSegment) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereSegment)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereSegment got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ipv4_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv4_vip"))
		if err := fv(ctx, m.GetIpv4Vip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6_vip"))
		if err := fv(ctx, m.GetIpv6Vip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["segment"]; exists {

		vOpts := append(opts, db.WithValidateField("segment"))
		if err := fv(ctx, m.GetSegment(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereSegmentValidator = func() *ValidateWhereSegment {
	v := &ValidateWhereSegment{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSegment := v.SegmentValidationRuleHandler
	rulesSegment := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSegment(rulesSegment)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSegment.segment: %s", err)
		panic(errMsg)
	}
	v.FldValidators["segment"] = vFn

	vrhIpv4Vip := v.Ipv4VipValidationRuleHandler
	rulesIpv4Vip := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
	}
	vFn, err = vrhIpv4Vip(rulesIpv4Vip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSegment.ipv4_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv4_vip"] = vFn

	vrhIpv6Vip := v.Ipv6VipValidationRuleHandler
	rulesIpv6Vip := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhIpv6Vip(rulesIpv6Vip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSegment.ipv6_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6_vip"] = vFn

	return v
}()

func WhereSegmentValidator() db.Validator {
	return DefaultWhereSegmentValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereSite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereSite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereSite) DeepCopy() *WhereSite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereSite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereSite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereSite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereSiteValidator().Validate(ctx, m, opts...)
}

func (m *WhereSite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteDRefInfo()

}

func (m *WhereSite) GetSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("site.Object")
	dri := db.DRefInfo{
		RefdType:   "site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereSite) GetSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}

	vref := m.GetSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereSite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereSite) NetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteNetwork)
		return int32(i)
	}
	// SiteNetwork_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteNetwork_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network")
	}

	return validatorFn, nil
}

func (v *ValidateWhereSite) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereSite) IpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}

	return validatorFn, nil
}

func (v *ValidateWhereSite) Ipv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}

	return validatorFn, nil
}

func (v *ValidateWhereSite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereSite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereSite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6"))
		if err := fv(ctx, m.GetIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		if err := fv(ctx, m.GetNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereSiteValidator = func() *ValidateWhereSite {
	v := &ValidateWhereSite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetwork := v.NetworkValidationRuleHandler
	rulesNetwork := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetwork(rulesNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSite.network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network"] = vFn

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSite.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	vrhIp := v.IpValidationRuleHandler
	rulesIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhIp(rulesIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSite.ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip"] = vFn

	vrhIpv6 := v.Ipv6ValidationRuleHandler
	rulesIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhIpv6(rulesIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSite.ipv6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6"] = vFn

	return v
}()

func WhereSiteValidator() db.Validator {
	return DefaultWhereSiteValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereSiteSegment) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereSiteSegment) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereSiteSegment) DeepCopy() *WhereSiteSegment {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereSiteSegment{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereSiteSegment) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereSiteSegment) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereSiteSegmentValidator().Validate(ctx, m, opts...)
}

func (m *WhereSiteSegment) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetSegmentDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSegmentDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSiteDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSiteDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *WhereSiteSegment) GetSegmentDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetSegment()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("segment.Object")
	dri := db.DRefInfo{
		RefdType:   "segment.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "segment",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetSegmentDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereSiteSegment) GetSegmentDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "segment.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: segment")
	}

	vref := m.GetSegment()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "segment.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

func (m *WhereSiteSegment) GetSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("site.Object")
	dri := db.DRefInfo{
		RefdType:   "site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereSiteSegment) GetSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}

	vref := m.GetSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereSiteSegment struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereSiteSegment) SegmentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for segment")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereSiteSegment) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereSiteSegment) IpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}

	return validatorFn, nil
}

func (v *ValidateWhereSiteSegment) Ipv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}

	return validatorFn, nil
}

func (v *ValidateWhereSiteSegment) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereSiteSegment)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereSiteSegment got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6"))
		if err := fv(ctx, m.GetIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["segment"]; exists {

		vOpts := append(opts, db.WithValidateField("segment"))
		if err := fv(ctx, m.GetSegment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereSiteSegmentValidator = func() *ValidateWhereSiteSegment {
	v := &ValidateWhereSiteSegment{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSegment := v.SegmentValidationRuleHandler
	rulesSegment := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSegment(rulesSegment)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSiteSegment.segment: %s", err)
		panic(errMsg)
	}
	v.FldValidators["segment"] = vFn

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSiteSegment.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	vrhIp := v.IpValidationRuleHandler
	rulesIp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
	}
	vFn, err = vrhIp(rulesIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSiteSegment.ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip"] = vFn

	vrhIpv6 := v.Ipv6ValidationRuleHandler
	rulesIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhIpv6(rulesIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereSiteSegment.ipv6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6"] = vFn

	return v
}()

func WhereSiteSegmentValidator() db.Validator {
	return DefaultWhereSiteSegmentValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereType) DeepCopy() *WhereType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereTypeValidator().Validate(ctx, m, opts...)
}

func (m *WhereType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *WhereType) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetChoice() == nil {
		return nil, nil
	}
	switch m.GetChoice().(type) {
	case *WhereType_Site:

		drInfos, err := m.GetSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site." + dri.DRField
		}
		return drInfos, err

	case *WhereType_VirtualSite:

		drInfos, err := m.GetVirtualSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site." + dri.DRField
		}
		return drInfos, err

	case *WhereType_Vk8SService:

		drInfos, err := m.GetVk8SService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVk8SService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vk8s_service." + dri.DRField
		}
		return drInfos, err

	case *WhereType_VirtualNetwork:

		drInfos, err := m.GetVirtualNetwork().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualNetwork().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_network." + dri.DRField
		}
		return drInfos, err

	case *WhereType_SiteSegment:

		drInfos, err := m.GetSiteSegment().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSiteSegment().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site_segment." + dri.DRField
		}
		return drInfos, err

	case *WhereType_VirtualSiteSegment:

		drInfos, err := m.GetVirtualSiteSegment().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSiteSegment().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site_segment." + dri.DRField
		}
		return drInfos, err

	case *WhereType_Segment:

		drInfos, err := m.GetSegment().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSegment().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "segment." + dri.DRField
		}
		return drInfos, err

	case *WhereType_CloudEdgeSegment:

		drInfos, err := m.GetCloudEdgeSegment().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCloudEdgeSegment().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "cloud_edge_segment." + dri.DRField
		}
		return drInfos, err

	case *WhereType_VirtualSiteWithVip:

		drInfos, err := m.GetVirtualSiteWithVip().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSiteWithVip().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site_with_vip." + dri.DRField
		}
		return drInfos, err

	case *WhereType_AdvertiseOnPublic:

		drInfos, err := m.GetAdvertiseOnPublic().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseOnPublic().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_on_public." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateWhereType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateWhereType) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateWhereType) PortChoicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}
func (v *ValidateWhereType) PortChoicePortRangesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PortRanges, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_ranges")
	}
	return oValidatorFn_PortRanges, nil
}

func (v *ValidateWhereType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *WhereType_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*WhereType_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*WhereType_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_Vk8SService:
		if fv, exists := v.FldValidators["choice.vk8s_service"]; exists {
			val := m.GetChoice().(*WhereType_Vk8SService).Vk8SService
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("vk8s_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_VirtualNetwork:
		if fv, exists := v.FldValidators["choice.virtual_network"]; exists {
			val := m.GetChoice().(*WhereType_VirtualNetwork).VirtualNetwork
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_SiteSegment:
		if fv, exists := v.FldValidators["choice.site_segment"]; exists {
			val := m.GetChoice().(*WhereType_SiteSegment).SiteSegment
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site_segment"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_VirtualSiteSegment:
		if fv, exists := v.FldValidators["choice.virtual_site_segment"]; exists {
			val := m.GetChoice().(*WhereType_VirtualSiteSegment).VirtualSiteSegment
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site_segment"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_Segment:
		if fv, exists := v.FldValidators["choice.segment"]; exists {
			val := m.GetChoice().(*WhereType_Segment).Segment
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("segment"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_CloudEdgeSegment:
		if fv, exists := v.FldValidators["choice.cloud_edge_segment"]; exists {
			val := m.GetChoice().(*WhereType_CloudEdgeSegment).CloudEdgeSegment
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("cloud_edge_segment"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_VirtualSiteWithVip:
		if fv, exists := v.FldValidators["choice.virtual_site_with_vip"]; exists {
			val := m.GetChoice().(*WhereType_VirtualSiteWithVip).VirtualSiteWithVip
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site_with_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_AdvertiseOnPublic:
		if fv, exists := v.FldValidators["choice.advertise_on_public"]; exists {
			val := m.GetChoice().(*WhereType_AdvertiseOnPublic).AdvertiseOnPublic
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("advertise_on_public"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *WhereType_UseDefaultPort:
		if fv, exists := v.FldValidators["port_choice.use_default_port"]; exists {
			val := m.GetPortChoice().(*WhereType_UseDefaultPort).UseDefaultPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("use_default_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_Port:
		if fv, exists := v.FldValidators["port_choice.port"]; exists {
			val := m.GetPortChoice().(*WhereType_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereType_PortRanges:
		if fv, exists := v.FldValidators["port_choice.port_ranges"]; exists {
			val := m.GetPortChoice().(*WhereType_PortRanges).PortRanges
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port_ranges"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereTypeValidator = func() *ValidateWhereType {
	v := &ValidateWhereType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereType.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoicePort := v.PortChoicePortValidationRuleHandler
	rulesPortChoicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.port"], err = vrhPortChoicePort(rulesPortChoicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WhereType.port_choice_port: %s", err)
		panic(errMsg)
	}
	vrhPortChoicePortRanges := v.PortChoicePortRangesValidationRuleHandler
	rulesPortChoicePortRanges := map[string]string{
		"ves.io.schema.rules.string.max_len":                "512",
		"ves.io.schema.rules.string.max_ports":              "64",
		"ves.io.schema.rules.string.min_len":                "1",
		"ves.io.schema.rules.string.unique_port_range_list": "true",
	}
	vFnMap["port_choice.port_ranges"], err = vrhPortChoicePortRanges(rulesPortChoicePortRanges)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WhereType.port_choice_port_ranges: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.port"] = vFnMap["port_choice.port"]
	v.FldValidators["port_choice.port_ranges"] = vFnMap["port_choice.port_ranges"]

	v.FldValidators["choice.site"] = WhereSiteValidator().Validate
	v.FldValidators["choice.virtual_site"] = WhereVirtualSiteValidator().Validate
	v.FldValidators["choice.vk8s_service"] = WhereVK8SServiceValidator().Validate
	v.FldValidators["choice.virtual_network"] = WhereVirtualNetworkValidator().Validate
	v.FldValidators["choice.site_segment"] = WhereSiteSegmentValidator().Validate
	v.FldValidators["choice.virtual_site_segment"] = WhereVirtualSiteSegmentValidator().Validate
	v.FldValidators["choice.segment"] = WhereSegmentValidator().Validate
	v.FldValidators["choice.cloud_edge_segment"] = WhereCloudEdgeSegmentValidator().Validate
	v.FldValidators["choice.virtual_site_with_vip"] = WhereVirtualSiteSpecifiedVIPValidator().Validate
	v.FldValidators["choice.advertise_on_public"] = AdvertisePublicValidator().Validate

	return v
}()

func WhereTypeValidator() db.Validator {
	return DefaultWhereTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereTypeSiteVsite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereTypeSiteVsite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereTypeSiteVsite) DeepCopy() *WhereTypeSiteVsite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereTypeSiteVsite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereTypeSiteVsite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereTypeSiteVsite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereTypeSiteVsiteValidator().Validate(ctx, m, opts...)
}

func (m *WhereTypeSiteVsite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *WhereTypeSiteVsite) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetChoice() == nil {
		return nil, nil
	}
	switch m.GetChoice().(type) {
	case *WhereTypeSiteVsite_Site:

		drInfos, err := m.GetSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site." + dri.DRField
		}
		return drInfos, err

	case *WhereTypeSiteVsite_VirtualSite:

		drInfos, err := m.GetVirtualSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateWhereTypeSiteVsite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereTypeSiteVsite) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateWhereTypeSiteVsite) PortChoicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}

func (v *ValidateWhereTypeSiteVsite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereTypeSiteVsite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereTypeSiteVsite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *WhereTypeSiteVsite_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*WhereTypeSiteVsite_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereTypeSiteVsite_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*WhereTypeSiteVsite_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetPortChoice().(type) {
	case *WhereTypeSiteVsite_UseDefaultPort:
		if fv, exists := v.FldValidators["port_choice.use_default_port"]; exists {
			val := m.GetPortChoice().(*WhereTypeSiteVsite_UseDefaultPort).UseDefaultPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("use_default_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereTypeSiteVsite_Port:
		if fv, exists := v.FldValidators["port_choice.port"]; exists {
			val := m.GetPortChoice().(*WhereTypeSiteVsite_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereTypeSiteVsiteValidator = func() *ValidateWhereTypeSiteVsite {
	v := &ValidateWhereTypeSiteVsite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereTypeSiteVsite.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhPortChoicePort := v.PortChoicePortValidationRuleHandler
	rulesPortChoicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.port"], err = vrhPortChoicePort(rulesPortChoicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WhereTypeSiteVsite.port_choice_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.port"] = vFnMap["port_choice.port"]

	v.FldValidators["choice.site"] = WhereSiteValidator().Validate
	v.FldValidators["choice.virtual_site"] = WhereVirtualSiteValidator().Validate

	return v
}()

func WhereTypeSiteVsiteValidator() db.Validator {
	return DefaultWhereTypeSiteVsiteValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereVK8SService) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereVK8SService) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereVK8SService) DeepCopy() *WhereVK8SService {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereVK8SService{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereVK8SService) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereVK8SService) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereVK8SServiceValidator().Validate(ctx, m, opts...)
}

func (m *WhereVK8SService) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

func (m *WhereVK8SService) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetChoice().(type) {
	case *WhereVK8SService_Site:

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("site.Object")
		dri := db.DRefInfo{
			RefdType:   "site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *WhereVK8SService_VirtualSite:

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_site.Object")
		dri := db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "virtual_site",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVK8SService) GetChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetChoice().(type) {
	case *WhereVK8SService_Site:
		refdType, err := d.TypeForEntryKind("", "", "site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: site")
		}

		vref := m.GetSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *WhereVK8SService_VirtualSite:
		refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
		}

		vref := m.GetVirtualSite()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateWhereVK8SService struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereVK8SService) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateWhereVK8SService) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereVK8SService)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereVK8SService got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *WhereVK8SService_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*WhereVK8SService_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereVK8SService_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*WhereVK8SService_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereVK8SServiceValidator = func() *ValidateWhereVK8SService {
	v := &ValidateWhereVK8SService{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVK8SService.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.site"] = ObjectRefTypeValidator().Validate
	v.FldValidators["choice.virtual_site"] = ObjectRefTypeValidator().Validate

	return v
}()

func WhereVK8SServiceValidator() db.Validator {
	return DefaultWhereVK8SServiceValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereVirtualNetwork) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereVirtualNetwork) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereVirtualNetwork) DeepCopy() *WhereVirtualNetwork {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereVirtualNetwork{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereVirtualNetwork) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereVirtualNetwork) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereVirtualNetworkValidator().Validate(ctx, m, opts...)
}

func (m *WhereVirtualNetwork) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualNetworkDRefInfo()

}

func (m *WhereVirtualNetwork) GetVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualNetwork()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_network.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_network.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_network",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVirtualNetwork) GetVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}

	vref := m.GetVirtualNetwork()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_network.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereVirtualNetwork struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereVirtualNetwork) V6VipChoiceSpecificV6VipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SpecificV6Vip, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for specific_v6_vip")
	}
	return oValidatorFn_SpecificV6Vip, nil
}

func (v *ValidateWhereVirtualNetwork) VipChoiceSpecificVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SpecificVip, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for specific_vip")
	}
	return oValidatorFn_SpecificVip, nil
}

func (v *ValidateWhereVirtualNetwork) VirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for virtual_network")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualNetwork) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereVirtualNetwork)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereVirtualNetwork got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetV6VipChoice().(type) {
	case *WhereVirtualNetwork_DefaultV6Vip:
		if fv, exists := v.FldValidators["v6_vip_choice.default_v6_vip"]; exists {
			val := m.GetV6VipChoice().(*WhereVirtualNetwork_DefaultV6Vip).DefaultV6Vip
			vOpts := append(opts,
				db.WithValidateField("v6_vip_choice"),
				db.WithValidateField("default_v6_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereVirtualNetwork_SpecificV6Vip:
		if fv, exists := v.FldValidators["v6_vip_choice.specific_v6_vip"]; exists {
			val := m.GetV6VipChoice().(*WhereVirtualNetwork_SpecificV6Vip).SpecificV6Vip
			vOpts := append(opts,
				db.WithValidateField("v6_vip_choice"),
				db.WithValidateField("specific_v6_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetVipChoice().(type) {
	case *WhereVirtualNetwork_DefaultVip:
		if fv, exists := v.FldValidators["vip_choice.default_vip"]; exists {
			val := m.GetVipChoice().(*WhereVirtualNetwork_DefaultVip).DefaultVip
			vOpts := append(opts,
				db.WithValidateField("vip_choice"),
				db.WithValidateField("default_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WhereVirtualNetwork_SpecificVip:
		if fv, exists := v.FldValidators["vip_choice.specific_vip"]; exists {
			val := m.GetVipChoice().(*WhereVirtualNetwork_SpecificVip).SpecificVip
			vOpts := append(opts,
				db.WithValidateField("vip_choice"),
				db.WithValidateField("specific_vip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["virtual_network"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_network"))
		if err := fv(ctx, m.GetVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereVirtualNetworkValidator = func() *ValidateWhereVirtualNetwork {
	v := &ValidateWhereVirtualNetwork{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhV6VipChoiceSpecificV6Vip := v.V6VipChoiceSpecificV6VipValidationRuleHandler
	rulesV6VipChoiceSpecificV6Vip := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFnMap["v6_vip_choice.specific_v6_vip"], err = vrhV6VipChoiceSpecificV6Vip(rulesV6VipChoiceSpecificV6Vip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WhereVirtualNetwork.v6_vip_choice_specific_v6_vip: %s", err)
		panic(errMsg)
	}

	v.FldValidators["v6_vip_choice.specific_v6_vip"] = vFnMap["v6_vip_choice.specific_v6_vip"]

	vrhVipChoiceSpecificVip := v.VipChoiceSpecificVipValidationRuleHandler
	rulesVipChoiceSpecificVip := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["vip_choice.specific_vip"], err = vrhVipChoiceSpecificVip(rulesVipChoiceSpecificVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field WhereVirtualNetwork.vip_choice_specific_vip: %s", err)
		panic(errMsg)
	}

	v.FldValidators["vip_choice.specific_vip"] = vFnMap["vip_choice.specific_vip"]

	vrhVirtualNetwork := v.VirtualNetworkValidationRuleHandler
	rulesVirtualNetwork := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVirtualNetwork(rulesVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualNetwork.virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_network"] = vFn

	return v
}()

func WhereVirtualNetworkValidator() db.Validator {
	return DefaultWhereVirtualNetworkValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereVirtualSite) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereVirtualSite) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereVirtualSite) DeepCopy() *WhereVirtualSite {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereVirtualSite{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereVirtualSite) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereVirtualSite) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereVirtualSiteValidator().Validate(ctx, m, opts...)
}

func (m *WhereVirtualSite) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualSiteDRefInfo()

}

func (m *WhereVirtualSite) GetVirtualSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_site.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVirtualSite) GetVirtualSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
	}

	vref := m.GetVirtualSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereVirtualSite struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereVirtualSite) NetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteNetwork)
		return int32(i)
	}
	// SiteNetwork_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteNetwork_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network")
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSite) VirtualSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for virtual_site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSite) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereVirtualSite)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereVirtualSite got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		if err := fv(ctx, m.GetNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_site"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_site"))
		if err := fv(ctx, m.GetVirtualSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereVirtualSiteValidator = func() *ValidateWhereVirtualSite {
	v := &ValidateWhereVirtualSite{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetwork := v.NetworkValidationRuleHandler
	rulesNetwork := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetwork(rulesNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSite.network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network"] = vFn

	vrhVirtualSite := v.VirtualSiteValidationRuleHandler
	rulesVirtualSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVirtualSite(rulesVirtualSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSite.virtual_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_site"] = vFn

	return v
}()

func WhereVirtualSiteValidator() db.Validator {
	return DefaultWhereVirtualSiteValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereVirtualSiteSegment) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereVirtualSiteSegment) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereVirtualSiteSegment) DeepCopy() *WhereVirtualSiteSegment {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereVirtualSiteSegment{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereVirtualSiteSegment) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereVirtualSiteSegment) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereVirtualSiteSegmentValidator().Validate(ctx, m, opts...)
}

func (m *WhereVirtualSiteSegment) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetSegmentDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSegmentDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVirtualSiteDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVirtualSiteDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *WhereVirtualSiteSegment) GetSegmentDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetSegment()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("segment.Object")
	dri := db.DRefInfo{
		RefdType:   "segment.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "segment",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetSegmentDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVirtualSiteSegment) GetSegmentDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "segment.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: segment")
	}

	vref := m.GetSegment()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "segment.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

func (m *WhereVirtualSiteSegment) GetVirtualSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_site.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVirtualSiteSegment) GetVirtualSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
	}

	vref := m.GetVirtualSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereVirtualSiteSegment struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereVirtualSiteSegment) SegmentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for segment")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSiteSegment) VirtualSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for virtual_site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSiteSegment) IpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSiteSegment) Ipv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSiteSegment) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereVirtualSiteSegment)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereVirtualSiteSegment got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6"))
		if err := fv(ctx, m.GetIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["segment"]; exists {

		vOpts := append(opts, db.WithValidateField("segment"))
		if err := fv(ctx, m.GetSegment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_site"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_site"))
		if err := fv(ctx, m.GetVirtualSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereVirtualSiteSegmentValidator = func() *ValidateWhereVirtualSiteSegment {
	v := &ValidateWhereVirtualSiteSegment{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSegment := v.SegmentValidationRuleHandler
	rulesSegment := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSegment(rulesSegment)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSiteSegment.segment: %s", err)
		panic(errMsg)
	}
	v.FldValidators["segment"] = vFn

	vrhVirtualSite := v.VirtualSiteValidationRuleHandler
	rulesVirtualSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVirtualSite(rulesVirtualSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSiteSegment.virtual_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_site"] = vFn

	vrhIp := v.IpValidationRuleHandler
	rulesIp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
	}
	vFn, err = vrhIp(rulesIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSiteSegment.ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip"] = vFn

	vrhIpv6 := v.Ipv6ValidationRuleHandler
	rulesIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhIpv6(rulesIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSiteSegment.ipv6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6"] = vFn

	return v
}()

func WhereVirtualSiteSegmentValidator() db.Validator {
	return DefaultWhereVirtualSiteSegmentValidator
}

// augmented methods on protoc/std generated struct

func (m *WhereVirtualSiteSpecifiedVIP) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WhereVirtualSiteSpecifiedVIP) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WhereVirtualSiteSpecifiedVIP) DeepCopy() *WhereVirtualSiteSpecifiedVIP {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WhereVirtualSiteSpecifiedVIP{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WhereVirtualSiteSpecifiedVIP) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WhereVirtualSiteSpecifiedVIP) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WhereVirtualSiteSpecifiedVIPValidator().Validate(ctx, m, opts...)
}

func (m *WhereVirtualSiteSpecifiedVIP) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualSiteDRefInfo()

}

func (m *WhereVirtualSiteSpecifiedVIP) GetVirtualSiteDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualSite()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_site.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_site.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_site",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WhereVirtualSiteSpecifiedVIP) GetVirtualSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
	}

	vref := m.GetVirtualSite()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_site.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateWhereVirtualSiteSpecifiedVIP struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWhereVirtualSiteSpecifiedVIP) NetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteNetworkSpecifiedVIP)
		return int32(i)
	}
	// SiteNetworkSpecifiedVIP_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteNetworkSpecifiedVIP_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network")
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSiteSpecifiedVIP) VirtualSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for virtual_site")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSiteSpecifiedVIP) IpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSiteSpecifiedVIP) Ipv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}

	return validatorFn, nil
}

func (v *ValidateWhereVirtualSiteSpecifiedVIP) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WhereVirtualSiteSpecifiedVIP)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WhereVirtualSiteSpecifiedVIP got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6"))
		if err := fv(ctx, m.GetIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		if err := fv(ctx, m.GetNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_site"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_site"))
		if err := fv(ctx, m.GetVirtualSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWhereVirtualSiteSpecifiedVIPValidator = func() *ValidateWhereVirtualSiteSpecifiedVIP {
	v := &ValidateWhereVirtualSiteSpecifiedVIP{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetwork := v.NetworkValidationRuleHandler
	rulesNetwork := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetwork(rulesNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSiteSpecifiedVIP.network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network"] = vFn

	vrhVirtualSite := v.VirtualSiteValidationRuleHandler
	rulesVirtualSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVirtualSite(rulesVirtualSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSiteSpecifiedVIP.virtual_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_site"] = vFn

	vrhIp := v.IpValidationRuleHandler
	rulesIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhIp(rulesIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSiteSpecifiedVIP.ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip"] = vFn

	vrhIpv6 := v.Ipv6ValidationRuleHandler
	rulesIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhIpv6(rulesIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WhereVirtualSiteSpecifiedVIP.ipv6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6"] = vFn

	return v
}()

func WhereVirtualSiteSpecifiedVIPValidator() db.Validator {
	return DefaultWhereVirtualSiteSpecifiedVIPValidator
}

// augmented methods on protoc/std generated struct

func (m *XfccHeaderKeys) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *XfccHeaderKeys) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *XfccHeaderKeys) DeepCopy() *XfccHeaderKeys {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &XfccHeaderKeys{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *XfccHeaderKeys) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *XfccHeaderKeys) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return XfccHeaderKeysValidator().Validate(ctx, m, opts...)
}

type ValidateXfccHeaderKeys struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateXfccHeaderKeys) XfccHeaderElementsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.XfccElement)
		return int32(i)
	}
	// ves_io_schema.XfccElement_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.XfccElement_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for xfcc_header_elements")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.XfccElement, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for xfcc_header_elements")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.XfccElement)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.XfccElement, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated xfcc_header_elements")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items xfcc_header_elements")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateXfccHeaderKeys) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*XfccHeaderKeys)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *XfccHeaderKeys got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["xfcc_header_elements"]; exists {
		vOpts := append(opts, db.WithValidateField("xfcc_header_elements"))
		if err := fv(ctx, m.GetXfccHeaderElements(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultXfccHeaderKeysValidator = func() *ValidateXfccHeaderKeys {
	v := &ValidateXfccHeaderKeys{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhXfccHeaderElements := v.XfccHeaderElementsValidationRuleHandler
	rulesXfccHeaderElements := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.not_in":       "[0]",
	}
	vFn, err = vrhXfccHeaderElements(rulesXfccHeaderElements)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for XfccHeaderKeys.xfcc_header_elements: %s", err)
		panic(errMsg)
	}
	v.FldValidators["xfcc_header_elements"] = vFn

	return v
}()

func XfccHeaderKeysValidator() db.Validator {
	return DefaultXfccHeaderKeysValidator
}
