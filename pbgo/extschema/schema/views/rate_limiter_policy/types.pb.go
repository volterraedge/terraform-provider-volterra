// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/rate_limiter_policy/types.proto

package rate_limiter_policy

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	service_policy_rule "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy_rule"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Rate Limiter Rule
//
// x-displayName: "Rate Limiter Rule"
// Shape of Rate Limiter Rule
type RateLimiterRule struct {
	// metadata
	//
	// x-displayName: "Metadata"
	// x-required
	// Common attributes for the rule including name and description.
	Metadata *schema.MessageMetaType `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// spec
	//
	// x-displayName: "Rule Specification"
	// x-required
	// Specification for the rule including match preicates and actions.
	Spec *service_policy_rule.RateLimiterRuleSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
}

func (m *RateLimiterRule) Reset()      { *m = RateLimiterRule{} }
func (*RateLimiterRule) ProtoMessage() {}
func (*RateLimiterRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab32b0e3712b8490, []int{0}
}
func (m *RateLimiterRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimiterRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RateLimiterRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimiterRule.Merge(m, src)
}
func (m *RateLimiterRule) XXX_Size() int {
	return m.Size()
}
func (m *RateLimiterRule) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimiterRule.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimiterRule proto.InternalMessageInfo

func (m *RateLimiterRule) GetMetadata() *schema.MessageMetaType {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *RateLimiterRule) GetSpec() *service_policy_rule.RateLimiterRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Shape of the Rate Limiter Policy specification
type GlobalSpecType struct {
	// server choice
	//
	// x-displayName: "Server Selection"
	// Select servers for which the policy the will be applied.
	//
	// Types that are valid to be assigned to ServerChoice:
	//	*GlobalSpecType_AnyServer
	//	*GlobalSpecType_ServerName
	//	*GlobalSpecType_ServerNameMatcher
	//	*GlobalSpecType_ServerSelector
	ServerChoice isGlobalSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	// rules
	//
	// x-displayName: "Rules"
	// A list of RateLimiterRules that are evaluated sequentially till a matching rule is identified.
	Rules []*RateLimiterRule `protobuf:"bytes,6,rep,name=rules,proto3" json:"rules,omitempty"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal,proto3" json:"view_internal,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab32b0e3712b8490, []int{1}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_ServerChoice interface {
	isGlobalSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,2,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type GlobalSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,3,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type GlobalSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,4,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type GlobalSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,5,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}

func (*GlobalSpecType_AnyServer) isGlobalSpecType_ServerChoice()         {}
func (*GlobalSpecType_ServerName) isGlobalSpecType_ServerChoice()        {}
func (*GlobalSpecType_ServerNameMatcher) isGlobalSpecType_ServerChoice() {}
func (*GlobalSpecType_ServerSelector) isGlobalSpecType_ServerChoice()    {}

func (m *GlobalSpecType) GetServerChoice() isGlobalSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}

func (m *GlobalSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *GlobalSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GlobalSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *GlobalSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*GlobalSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *GlobalSpecType) GetRules() []*RateLimiterRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_AnyServer)(nil),
		(*GlobalSpecType_ServerName)(nil),
		(*GlobalSpecType_ServerNameMatcher)(nil),
		(*GlobalSpecType_ServerSelector)(nil),
	}
}

// CreateSpecType
//
// x-displayName: "Create Specification"
// Shape of the Rate Limiter Policy Create specification
type CreateSpecType struct {
	// Types that are valid to be assigned to ServerChoice:
	//	*CreateSpecType_AnyServer
	//	*CreateSpecType_ServerName
	//	*CreateSpecType_ServerNameMatcher
	//	*CreateSpecType_ServerSelector
	ServerChoice isCreateSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	Rules        []*RateLimiterRule            `protobuf:"bytes,6,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab32b0e3712b8490, []int{2}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_ServerChoice interface {
	isCreateSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,2,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type CreateSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,3,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type CreateSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,4,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type CreateSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,5,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}

func (*CreateSpecType_AnyServer) isCreateSpecType_ServerChoice()         {}
func (*CreateSpecType_ServerName) isCreateSpecType_ServerChoice()        {}
func (*CreateSpecType_ServerNameMatcher) isCreateSpecType_ServerChoice() {}
func (*CreateSpecType_ServerSelector) isCreateSpecType_ServerChoice()    {}

func (m *CreateSpecType) GetServerChoice() isCreateSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}

func (m *CreateSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*CreateSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *CreateSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *CreateSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *CreateSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*CreateSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *CreateSpecType) GetRules() []*RateLimiterRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_AnyServer)(nil),
		(*CreateSpecType_ServerName)(nil),
		(*CreateSpecType_ServerNameMatcher)(nil),
		(*CreateSpecType_ServerSelector)(nil),
	}
}

// ReplaceSpecType
//
// x-displayName: "Replace Specification"
// Shape of the Rate Limiter Policy Replace specification
type ReplaceSpecType struct {
	// Types that are valid to be assigned to ServerChoice:
	//	*ReplaceSpecType_AnyServer
	//	*ReplaceSpecType_ServerName
	//	*ReplaceSpecType_ServerNameMatcher
	//	*ReplaceSpecType_ServerSelector
	ServerChoice isReplaceSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	Rules        []*RateLimiterRule             `protobuf:"bytes,6,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab32b0e3712b8490, []int{3}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_ServerChoice interface {
	isReplaceSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,2,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type ReplaceSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,3,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type ReplaceSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,4,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type ReplaceSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,5,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}

func (*ReplaceSpecType_AnyServer) isReplaceSpecType_ServerChoice()         {}
func (*ReplaceSpecType_ServerName) isReplaceSpecType_ServerChoice()        {}
func (*ReplaceSpecType_ServerNameMatcher) isReplaceSpecType_ServerChoice() {}
func (*ReplaceSpecType_ServerSelector) isReplaceSpecType_ServerChoice()    {}

func (m *ReplaceSpecType) GetServerChoice() isReplaceSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *ReplaceSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *ReplaceSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *ReplaceSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*ReplaceSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *ReplaceSpecType) GetRules() []*RateLimiterRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_AnyServer)(nil),
		(*ReplaceSpecType_ServerName)(nil),
		(*ReplaceSpecType_ServerNameMatcher)(nil),
		(*ReplaceSpecType_ServerSelector)(nil),
	}
}

// GetSpecType
//
// x-displayName: "Get Specification"
// Shape of the Rate Limiter Policy Get specification
type GetSpecType struct {
	// Types that are valid to be assigned to ServerChoice:
	//	*GetSpecType_AnyServer
	//	*GetSpecType_ServerName
	//	*GetSpecType_ServerNameMatcher
	//	*GetSpecType_ServerSelector
	ServerChoice isGetSpecType_ServerChoice `protobuf_oneof:"server_choice"`
	Rules        []*RateLimiterRule         `protobuf:"bytes,6,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab32b0e3712b8490, []int{4}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_ServerChoice interface {
	isGetSpecType_ServerChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AnyServer struct {
	AnyServer *schema.Empty `protobuf:"bytes,2,opt,name=any_server,json=anyServer,proto3,oneof" json:"any_server,omitempty"`
}
type GetSpecType_ServerName struct {
	ServerName string `protobuf:"bytes,3,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type GetSpecType_ServerNameMatcher struct {
	ServerNameMatcher *policy.MatcherTypeBasic `protobuf:"bytes,4,opt,name=server_name_matcher,json=serverNameMatcher,proto3,oneof" json:"server_name_matcher,omitempty"`
}
type GetSpecType_ServerSelector struct {
	ServerSelector *schema.LabelSelectorType `protobuf:"bytes,5,opt,name=server_selector,json=serverSelector,proto3,oneof" json:"server_selector,omitempty"`
}

func (*GetSpecType_AnyServer) isGetSpecType_ServerChoice()         {}
func (*GetSpecType_ServerName) isGetSpecType_ServerChoice()        {}
func (*GetSpecType_ServerNameMatcher) isGetSpecType_ServerChoice() {}
func (*GetSpecType_ServerSelector) isGetSpecType_ServerChoice()    {}

func (m *GetSpecType) GetServerChoice() isGetSpecType_ServerChoice {
	if m != nil {
		return m.ServerChoice
	}
	return nil
}

func (m *GetSpecType) GetAnyServer() *schema.Empty {
	if x, ok := m.GetServerChoice().(*GetSpecType_AnyServer); ok {
		return x.AnyServer
	}
	return nil
}

func (m *GetSpecType) GetServerName() string {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *GetSpecType) GetServerNameMatcher() *policy.MatcherTypeBasic {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerNameMatcher); ok {
		return x.ServerNameMatcher
	}
	return nil
}

func (m *GetSpecType) GetServerSelector() *schema.LabelSelectorType {
	if x, ok := m.GetServerChoice().(*GetSpecType_ServerSelector); ok {
		return x.ServerSelector
	}
	return nil
}

func (m *GetSpecType) GetRules() []*RateLimiterRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_AnyServer)(nil),
		(*GetSpecType_ServerName)(nil),
		(*GetSpecType_ServerNameMatcher)(nil),
		(*GetSpecType_ServerSelector)(nil),
	}
}

// Rate Limiter Policy List
//
// x-displayName: "Rate Limiter Policy List"
// List of rate limiter policies to be applied.
type PolicyList struct {
	// Rate Limiter Policies
	//
	// x-displayName: "Rate Limiter Policies"
	// x-required
	// Ordered list of rate limiter policies.
	Policies []*views.ObjectRefType `protobuf:"bytes,1,rep,name=policies,proto3" json:"policies,omitempty"`
}

func (m *PolicyList) Reset()      { *m = PolicyList{} }
func (*PolicyList) ProtoMessage() {}
func (*PolicyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab32b0e3712b8490, []int{5}
}
func (m *PolicyList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyList.Merge(m, src)
}
func (m *PolicyList) XXX_Size() int {
	return m.Size()
}
func (m *PolicyList) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyList.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyList proto.InternalMessageInfo

func (m *PolicyList) GetPolicies() []*views.ObjectRefType {
	if m != nil {
		return m.Policies
	}
	return nil
}

func init() {
	proto.RegisterType((*RateLimiterRule)(nil), "ves.io.schema.views.rate_limiter_policy.RateLimiterRule")
	golang_proto.RegisterType((*RateLimiterRule)(nil), "ves.io.schema.views.rate_limiter_policy.RateLimiterRule")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.rate_limiter_policy.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.rate_limiter_policy.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.rate_limiter_policy.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.rate_limiter_policy.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.rate_limiter_policy.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.rate_limiter_policy.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.rate_limiter_policy.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.rate_limiter_policy.GetSpecType")
	proto.RegisterType((*PolicyList)(nil), "ves.io.schema.views.rate_limiter_policy.PolicyList")
	golang_proto.RegisterType((*PolicyList)(nil), "ves.io.schema.views.rate_limiter_policy.PolicyList")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/rate_limiter_policy/types.proto", fileDescriptor_ab32b0e3712b8490)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/rate_limiter_policy/types.proto", fileDescriptor_ab32b0e3712b8490)
}

var fileDescriptor_ab32b0e3712b8490 = []byte{
	// 1050 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0x78, 0xed, 0xa4, 0x7d, 0x4e, 0x1a, 0x77, 0x53, 0x35, 0xc6, 0x45, 0xcb, 0xe2, 0x56,
	0xe0, 0x56, 0xc9, 0x3a, 0x4a, 0x68, 0x84, 0x72, 0x40, 0x74, 0x01, 0xd5, 0x40, 0x52, 0xa2, 0x4d,
	0x0e, 0x08, 0x09, 0xcc, 0x78, 0xfd, 0x62, 0x2f, 0xec, 0x7a, 0x57, 0x3b, 0x63, 0x13, 0x1f, 0x2a,
	0x45, 0x70, 0xe3, 0x84, 0x82, 0x90, 0x40, 0xfc, 0x01, 0xd4, 0x3b, 0x17, 0xcc, 0x21, 0x42, 0x42,
	0x42, 0x3d, 0xe5, 0x98, 0x63, 0xe3, 0x5c, 0xc2, 0x2d, 0x67, 0x4e, 0x68, 0x66, 0xd7, 0x4d, 0xd6,
	0x18, 0x51, 0x09, 0x0e, 0x45, 0xea, 0xc9, 0xde, 0x37, 0xdf, 0xf7, 0xbd, 0x37, 0xef, 0x7d, 0x33,
	0x1a, 0x58, 0xee, 0x22, 0x33, 0x1c, 0xbf, 0xc2, 0xec, 0x16, 0x7a, 0xb4, 0xd2, 0x75, 0xf0, 0x33,
	0x56, 0x09, 0x29, 0xc7, 0x9a, 0xeb, 0x78, 0x0e, 0xc7, 0xb0, 0x16, 0xf8, 0xae, 0x63, 0xf7, 0x2a,
	0xbc, 0x17, 0x20, 0x33, 0x82, 0xd0, 0xe7, 0xbe, 0xfa, 0x72, 0x44, 0x32, 0x22, 0x92, 0x21, 0x49,
	0xc6, 0x18, 0x52, 0x71, 0xa1, 0xe9, 0xf0, 0x56, 0xa7, 0x6e, 0xd8, 0xbe, 0x57, 0x69, 0xfa, 0x4d,
	0xbf, 0x22, 0xf9, 0xf5, 0xce, 0xb6, 0xfc, 0x92, 0x1f, 0xf2, 0x5f, 0xa4, 0x5b, 0xbc, 0x96, 0x2c,
	0xc6, 0x0f, 0xb8, 0xe3, 0xb7, 0xe3, 0xa4, 0x45, 0x3d, 0xb9, 0xf8, 0xd7, 0xb2, 0x8a, 0x0b, 0x49,
	0x04, 0xc3, 0xb0, 0xeb, 0xd8, 0x18, 0xd7, 0x52, 0x0b, 0x3b, 0x2e, 0x26, 0xe0, 0xcf, 0x25, 0xe1,
	0xe7, 0x97, 0x9e, 0x1f, 0xe9, 0x0a, 0x75, 0x9d, 0x06, 0xe5, 0x38, 0xbe, 0x12, 0xb1, 0xfd, 0x5a,
	0xb2, 0xd6, 0x17, 0xc6, 0x75, 0xf5, 0x5c, 0x82, 0xd2, 0x97, 0x59, 0x98, 0xb1, 0x28, 0xc7, 0xb5,
	0xa8, 0x5f, 0x56, 0xc7, 0x45, 0x75, 0x15, 0x2e, 0x78, 0xc8, 0x69, 0x83, 0x72, 0x5a, 0x20, 0x3a,
	0x29, 0xe7, 0x96, 0x34, 0x23, 0xd9, 0xe8, 0x75, 0x64, 0x8c, 0x36, 0x71, 0x1d, 0x39, 0xdd, 0xea,
	0x05, 0x68, 0x3d, 0xc6, 0xab, 0x1b, 0x90, 0x61, 0x01, 0xda, 0x85, 0xb4, 0xe4, 0xad, 0x8c, 0xf0,
	0xc6, 0x74, 0xc2, 0x18, 0xc9, 0xbe, 0x19, 0xa0, 0x6d, 0x66, 0x0e, 0xfa, 0x84, 0x58, 0x52, 0x69,
	0xf5, 0x44, 0x79, 0xd8, 0x27, 0xc7, 0x0a, 0xcc, 0x41, 0xe6, 0x1e, 0xf5, 0xb0, 0x38, 0x03, 0xd3,
	0xc3, 0x6c, 0x46, 0x9b, 0x7a, 0x08, 0x5f, 0x13, 0xc8, 0x09, 0xa6, 0x7e, 0xc7, 0x16, 0x5b, 0xbf,
	0xf5, 0x05, 0x81, 0x5d, 0x02, 0x37, 0xa1, 0x20, 0xe8, 0x46, 0xbd, 0x17, 0x50, 0xc6, 0x6a, 0xe7,
	0x4d, 0xb1, 0x34, 0x6d, 0xca, 0xa0, 0x2e, 0xd3, 0x32, 0x30, 0x60, 0x4e, 0x42, 0x69, 0x10, 0xb8,
	0xbd, 0x24, 0x72, 0xf6, 0x8e, 0x88, 0xe9, 0xd5, 0xad, 0xad, 0x0d, 0x7d, 0xcd, 0x14, 0x04, 0xce,
	0xe0, 0x7a, 0x2c, 0x6d, 0x77, 0x18, 0xf7, 0xbd, 0x04, 0x41, 0x9d, 0x2c, 0x66, 0x25, 0x05, 0x6e,
	0xc2, 0xe4, 0x3a, 0xf2, 0x96, 0xdf, 0x60, 0xa6, 0x16, 0xe3, 0x5b, 0x9c, 0x07, 0x35, 0x4f, 0x06,
	0x8d, 0xe8, 0x87, 0xe5, 0x95, 0x45, 0x02, 0x25, 0xc8, 0x6c, 0x50, 0xde, 0x32, 0x8b, 0x70, 0x55,
	0xe2, 0x02, 0xca, 0x5b, 0x06, 0xee, 0x50, 0x9b, 0xd7, 0xba, 0xd4, 0xed, 0x20, 0xcb, 0x2b, 0x70,
	0x0b, 0x72, 0x02, 0xa3, 0x6f, 0x84, 0xb8, 0xed, 0xec, 0x98, 0xd7, 0xe2, 0x92, 0x25, 0x34, 0x90,
	0xb1, 0x33, 0x6c, 0x19, 0x40, 0x62, 0x2d, 0x6c, 0xe2, 0x4e, 0x52, 0x35, 0x14, 0xa1, 0x33, 0xe4,
	0x22, 0x4c, 0xbc, 0xe9, 0x7b, 0xd4, 0x69, 0xe7, 0x89, 0x79, 0x03, 0x74, 0x89, 0x6b, 0xc8, 0x40,
	0xcd, 0xa3, 0xdc, 0x6e, 0x61, 0x38, 0x5a, 0xc7, 0x0a, 0x4c, 0x45, 0x8c, 0x48, 0xfd, 0xef, 0x79,
	0x23, 0x99, 0xae, 0xc3, 0x64, 0x15, 0x69, 0x03, 0x43, 0x96, 0x27, 0xe6, 0x55, 0x98, 0x8a, 0x1a,
	0x12, 0x47, 0x94, 0x52, 0x46, 0x4c, 0xb2, 0xf4, 0x63, 0x06, 0x2e, 0xdd, 0x75, 0xfd, 0x3a, 0x75,
	0x85, 0x0b, 0x84, 0xb3, 0xd4, 0xdb, 0x00, 0xb4, 0xdd, 0xab, 0x09, 0xe3, 0x60, 0x18, 0xbb, 0xea,
	0xca, 0x88, 0xab, 0xde, 0xf2, 0x02, 0xde, 0xab, 0xa6, 0xac, 0x8b, 0xb4, 0xdd, 0xdb, 0x94, 0x40,
	0x75, 0x01, 0x72, 0x11, 0xa5, 0x26, 0x84, 0x0b, 0x8a, 0x4e, 0xca, 0x17, 0x4d, 0xf8, 0xe9, 0xf7,
	0x7d, 0x25, 0x1b, 0x2a, 0xe5, 0xdd, 0x74, 0x35, 0x65, 0x41, 0x04, 0x10, 0x9e, 0x52, 0xdf, 0x87,
	0xd9, 0x73, 0xf0, 0xe1, 0x1e, 0x0a, 0x19, 0x99, 0xee, 0xa5, 0x91, 0x74, 0x91, 0x79, 0x8d, 0xf5,
	0x08, 0x24, 0xaa, 0x34, 0x29, 0x73, 0xec, 0x6a, 0xca, 0xba, 0x7c, 0x26, 0x19, 0xaf, 0xaa, 0xef,
	0xc2, 0x4c, 0xac, 0xcc, 0xd0, 0x45, 0x9b, 0xfb, 0x61, 0x21, 0x2b, 0x55, 0xf5, 0x11, 0xd5, 0x35,
	0x5a, 0x47, 0x77, 0x33, 0xc6, 0x08, 0xd1, 0x6a, 0xca, 0xba, 0x14, 0x51, 0x87, 0x51, 0x95, 0x43,
	0x56, 0x1c, 0x19, 0x56, 0x98, 0xd0, 0x95, 0x72, 0x6e, 0xe9, 0x55, 0xe3, 0x09, 0xaf, 0xbf, 0xd1,
	0x33, 0x66, 0xde, 0x10, 0xe7, 0x4b, 0x74, 0x63, 0x62, 0x8f, 0x28, 0xf9, 0xdd, 0xb4, 0x6c, 0xcc,
	0x1e, 0x49, 0x2f, 0x92, 0xc1, 0xa3, 0x5f, 0x95, 0x89, 0xbd, 0x9f, 0x49, 0x3a, 0x4f, 0xac, 0x28,
	0x99, 0xfa, 0x11, 0x4c, 0xcb, 0x9b, 0xc5, 0x69, 0x73, 0x0c, 0xdb, 0xd4, 0x2d, 0x9c, 0x4c, 0xca,
	0x1d, 0x94, 0xc6, 0xa6, 0x7f, 0xaf, 0xfe, 0x09, 0xda, 0xdc, 0xc2, 0x6d, 0xd9, 0x98, 0x2b, 0x0f,
	0xee, 0x27, 0xc9, 0x27, 0xe2, 0x60, 0x4f, 0x89, 0xd0, 0xdb, 0x71, 0x64, 0x35, 0xff, 0x4b, 0x9f,
	0x4c, 0x01, 0x40, 0xd6, 0x92, 0xe9, 0xc8, 0x8a, 0x59, 0x86, 0xe9, 0xb8, 0x69, 0x76, 0xcb, 0x77,
	0x6c, 0x54, 0xe7, 0xf6, 0xfb, 0x24, 0x2d, 0x6a, 0x1e, 0xf4, 0xc9, 0xe4, 0xd2, 0xfc, 0xf2, 0xfc,
	0x2b, 0xf3, 0xb7, 0x4f, 0xfb, 0x84, 0xbc, 0x93, 0xb9, 0x40, 0xf2, 0xe9, 0xd2, 0xb7, 0x0a, 0x5c,
	0x7a, 0x23, 0x44, 0xca, 0xf1, 0xdf, 0xfa, 0xe6, 0xc5, 0x31, 0xbe, 0xf9, 0x7f, 0x7a, 0xe5, 0xde,
	0x7f, 0xe4, 0x95, 0xd8, 0x05, 0xab, 0x97, 0x1f, 0xbe, 0x36, 0x72, 0x36, 0xcd, 0xd2, 0xe8, 0x98,
	0x2e, 0x7f, 0xfe, 0x07, 0x49, 0x86, 0x4a, 0xdf, 0x29, 0x30, 0x63, 0x61, 0xe0, 0x52, 0xfb, 0xd9,
	0x6c, 0x9e, 0xb6, 0xd9, 0x7c, 0xa3, 0x40, 0xee, 0x2e, 0xf2, 0x67, 0x73, 0x79, 0xca, 0xe6, 0xd2,
	0x06, 0xd8, 0x90, 0xba, 0x6b, 0x0e, 0xe3, 0xea, 0xc7, 0x70, 0x41, 0x66, 0x71, 0x90, 0x15, 0x88,
	0xac, 0xeb, 0x49, 0x2e, 0x5e, 0xfd, 0xc1, 0xfd, 0xd9, 0x31, 0x95, 0x0e, 0x2f, 0xfa, 0xfc, 0xeb,
	0xd6, 0x63, 0x55, 0xf3, 0x7b, 0x72, 0x70, 0xa4, 0xa5, 0x0e, 0x8f, 0xb4, 0xd4, 0xe9, 0x91, 0x46,
	0x76, 0x07, 0x1a, 0xf9, 0x61, 0xa0, 0x91, 0xdf, 0x06, 0x1a, 0x39, 0x18, 0x68, 0xe4, 0x70, 0xa0,
	0x91, 0x47, 0x03, 0x8d, 0x9c, 0x0c, 0xb4, 0xd4, 0xe9, 0x40, 0x23, 0x5f, 0x1d, 0x6b, 0xa9, 0xfd,
	0x63, 0x8d, 0x1c, 0x1c, 0x6b, 0xa9, 0xc3, 0x63, 0x2d, 0xf5, 0xc1, 0x87, 0x4d, 0x3f, 0xf8, 0xb4,
	0x69, 0x74, 0x7d, 0x97, 0x63, 0x18, 0x52, 0xa3, 0xc3, 0x2a, 0xf2, 0xcf, 0xb6, 0x1f, 0x7a, 0x0b,
	0x41, 0xe8, 0x77, 0x9d, 0x06, 0x86, 0x0b, 0xc3, 0xe5, 0x4a, 0x50, 0x6f, 0xfa, 0x15, 0xdc, 0xe1,
	0xc3, 0xc7, 0xf1, 0x3f, 0xbc, 0xf7, 0xeb, 0x13, 0xf2, 0xa1, 0xba, 0xfc, 0x67, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x5d, 0x55, 0x4f, 0xd0, 0x21, 0x0c, 0x00, 0x00,
}

func (this *RateLimiterRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimiterRule)
	if !ok {
		that2, ok := that.(RateLimiterRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AnyServer)
	if !ok {
		that2, ok := that.(GlobalSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerName)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(GlobalSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AnyServer)
	if !ok {
		that2, ok := that.(CreateSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerName)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *CreateSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(CreateSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AnyServer)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerName)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ServerChoice == nil {
		if this.ServerChoice != nil {
			return false
		}
	} else if this.ServerChoice == nil {
		return false
	} else if !this.ServerChoice.Equal(that1.ServerChoice) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *GetSpecType_AnyServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AnyServer)
	if !ok {
		that2, ok := that.(GetSpecType_AnyServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyServer.Equal(that1.AnyServer) {
		return false
	}
	return true
}
func (this *GetSpecType_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerName)
	if !ok {
		that2, ok := that.(GetSpecType_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *GetSpecType_ServerNameMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerNameMatcher)
	if !ok {
		that2, ok := that.(GetSpecType_ServerNameMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerNameMatcher.Equal(that1.ServerNameMatcher) {
		return false
	}
	return true
}
func (this *GetSpecType_ServerSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ServerSelector)
	if !ok {
		that2, ok := that.(GetSpecType_ServerSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerSelector.Equal(that1.ServerSelector) {
		return false
	}
	return true
}
func (this *PolicyList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyList)
	if !ok {
		that2, ok := that.(PolicyList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Policies) != len(that1.Policies) {
		return false
	}
	for i := range this.Policies {
		if !this.Policies[i].Equal(that1.Policies[i]) {
			return false
		}
	}
	return true
}
func (this *RateLimiterRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&rate_limiter_policy.RateLimiterRule{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.Spec != nil {
		s = append(s, "Spec: "+fmt.Sprintf("%#v", this.Spec)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&rate_limiter_policy.GlobalSpecType{")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.GlobalSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.GlobalSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.GlobalSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.GlobalSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rate_limiter_policy.CreateSpecType{")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.CreateSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.CreateSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.CreateSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.CreateSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rate_limiter_policy.ReplaceSpecType{")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.ReplaceSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.ReplaceSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.ReplaceSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.ReplaceSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rate_limiter_policy.GetSpecType{")
	if this.ServerChoice != nil {
		s = append(s, "ServerChoice: "+fmt.Sprintf("%#v", this.ServerChoice)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AnyServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.GetSpecType_AnyServer{` +
		`AnyServer:` + fmt.Sprintf("%#v", this.AnyServer) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.GetSpecType_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerNameMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.GetSpecType_ServerNameMatcher{` +
		`ServerNameMatcher:` + fmt.Sprintf("%#v", this.ServerNameMatcher) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ServerSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&rate_limiter_policy.GetSpecType_ServerSelector{` +
		`ServerSelector:` + fmt.Sprintf("%#v", this.ServerSelector) + `}`}, ", ")
	return s
}
func (this *PolicyList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rate_limiter_policy.PolicyList{")
	if this.Policies != nil {
		s = append(s, "Policies: "+fmt.Sprintf("%#v", this.Policies)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *RateLimiterRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimiterRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimiterRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ViewInternal != nil {
		{
			size, err := m.ViewInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ServerChoice != nil {
		{
			size := m.ServerChoice.Size()
			i -= size
			if _, err := m.ServerChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_AnyServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AnyServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyServer != nil {
		{
			size, err := m.AnyServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ServerNameMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerNameMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerNameMatcher != nil {
		{
			size, err := m.ServerNameMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ServerSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ServerSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServerSelector != nil {
		{
			size, err := m.ServerSelector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Policies) > 0 {
		for iNdEx := len(m.Policies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Policies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RateLimiterRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GlobalSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerChoice != nil {
		n += m.ServerChoice.Size()
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_AnyServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyServer != nil {
		l = m.AnyServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType_ServerNameMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerNameMatcher != nil {
		l = m.ServerNameMatcher.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ServerSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerSelector != nil {
		l = m.ServerSelector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PolicyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RateLimiterRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimiterRule{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MessageMetaType", "schema.MessageMetaType", 1) + `,`,
		`Spec:` + strings.Replace(fmt.Sprintf("%v", this.Spec), "RateLimiterRuleSpec", "service_policy_rule.RateLimiterRuleSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*RateLimiterRule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "RateLimiterRule", "RateLimiterRule", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + repeatedStringForRules + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*RateLimiterRule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "RateLimiterRule", "RateLimiterRule", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&CreateSpecType{`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*RateLimiterRule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "RateLimiterRule", "RateLimiterRule", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*RateLimiterRule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "RateLimiterRule", "RateLimiterRule", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`ServerChoice:` + fmt.Sprintf("%v", this.ServerChoice) + `,`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AnyServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AnyServer{`,
		`AnyServer:` + strings.Replace(fmt.Sprintf("%v", this.AnyServer), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerNameMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerNameMatcher{`,
		`ServerNameMatcher:` + strings.Replace(fmt.Sprintf("%v", this.ServerNameMatcher), "MatcherTypeBasic", "policy.MatcherTypeBasic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ServerSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ServerSelector{`,
		`ServerSelector:` + strings.Replace(fmt.Sprintf("%v", this.ServerSelector), "LabelSelectorType", "schema.LabelSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicyList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPolicies := "[]*ObjectRefType{"
	for _, f := range this.Policies {
		repeatedStringForPolicies += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForPolicies += "}"
	s := strings.Join([]string{`&PolicyList{`,
		`Policies:` + repeatedStringForPolicies + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *RateLimiterRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimiterRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimiterRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &schema.MessageMetaType{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &service_policy_rule.RateLimiterRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_AnyServer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &GlobalSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GlobalSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &RateLimiterRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_AnyServer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &CreateSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &CreateSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &RateLimiterRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_AnyServer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &ReplaceSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &ReplaceSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &RateLimiterRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_AnyServer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerChoice = &GetSpecType_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.MatcherTypeBasic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_ServerNameMatcher{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.LabelSelectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerChoice = &GetSpecType_ServerSelector{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &RateLimiterRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &views.ObjectRefType{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
