// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package workload

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_http_loadbalancer "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/http_loadbalancer"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AdvertiseCustomType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseCustomType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AdvertiseCustomType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetPorts() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting AdvertiseCustomType.ports idx %v", idx)
		}
	}

	return nil
}

func (m *AdvertiseCustomType) DeepCopy() *AdvertiseCustomType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseCustomType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseCustomType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseCustomType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseCustomTypeValidator().Validate(ctx, m, opts...)
}

func (m *AdvertiseCustomType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertiseWhereDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertiseWhereDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetPortsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetPortsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *AdvertiseCustomType) GetAdvertiseWhereDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseWhere() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetAdvertiseWhere() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseWhere() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("advertise_where[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *AdvertiseCustomType) GetPortsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetPorts() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetPorts() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPorts() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("ports[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateAdvertiseCustomType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseCustomType) PortsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ports")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AdvertisePortType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AdvertisePortTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ports")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AdvertisePortType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AdvertisePortType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ports")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ports")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseCustomType) AdvertiseWhereValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for advertise_where")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AdvertiseWhereType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AdvertiseWhereTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for advertise_where")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AdvertiseWhereType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AdvertiseWhereType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated advertise_where")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items advertise_where")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseCustomType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseCustomType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseCustomType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_where"]; exists {
		vOpts := append(opts, db.WithValidateField("advertise_where"))
		if err := fv(ctx, m.GetAdvertiseWhere(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ports"]; exists {
		vOpts := append(opts, db.WithValidateField("ports"))
		if err := fv(ctx, m.GetPorts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseCustomTypeValidator = func() *ValidateAdvertiseCustomType {
	v := &ValidateAdvertiseCustomType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPorts := v.PortsValidationRuleHandler
	rulesPorts := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhPorts(rulesPorts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseCustomType.ports: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ports"] = vFn

	vrhAdvertiseWhere := v.AdvertiseWhereValidationRuleHandler
	rulesAdvertiseWhere := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAdvertiseWhere(rulesAdvertiseWhere)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseCustomType.advertise_where: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_where"] = vFn

	return v
}()

func AdvertiseCustomTypeValidator() db.Validator {
	return DefaultAdvertiseCustomTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertiseInClusterType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseInClusterType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AdvertiseInClusterType) DeepCopy() *AdvertiseInClusterType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseInClusterType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseInClusterType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseInClusterType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseInClusterTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAdvertiseInClusterType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseInClusterType) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAdvertiseInClusterType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseInClusterType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseInClusterType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *AdvertiseInClusterType_Port:
		if fv, exists := v.FldValidators["port_choice.port"]; exists {
			val := m.GetPortChoice().(*AdvertiseInClusterType_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AdvertiseInClusterType_MultiPorts:
		if fv, exists := v.FldValidators["port_choice.multi_ports"]; exists {
			val := m.GetPortChoice().(*AdvertiseInClusterType_MultiPorts).MultiPorts
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("multi_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseInClusterTypeValidator = func() *ValidateAdvertiseInClusterType {
	v := &ValidateAdvertiseInClusterType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseInClusterType.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	v.FldValidators["port_choice.port"] = SinglePortTypeValidator().Validate
	v.FldValidators["port_choice.multi_ports"] = MultiPortTypeValidator().Validate

	return v
}()

func AdvertiseInClusterTypeValidator() db.Validator {
	return DefaultAdvertiseInClusterTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertiseMultiPortType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseMultiPortType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AdvertiseMultiPortType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetPorts() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting AdvertiseMultiPortType.ports idx %v", idx)
		}
	}

	return nil
}

func (m *AdvertiseMultiPortType) DeepCopy() *AdvertiseMultiPortType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseMultiPortType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseMultiPortType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseMultiPortType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseMultiPortTypeValidator().Validate(ctx, m, opts...)
}

func (m *AdvertiseMultiPortType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPortsDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertiseMultiPortType) GetPortsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetPorts() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetPorts() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPorts() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("ports[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateAdvertiseMultiPortType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseMultiPortType) PortsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ports")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AdvertisePortType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AdvertisePortTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ports")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AdvertisePortType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AdvertisePortType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ports")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ports")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseMultiPortType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseMultiPortType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseMultiPortType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ports"]; exists {
		vOpts := append(opts, db.WithValidateField("ports"))
		if err := fv(ctx, m.GetPorts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseMultiPortTypeValidator = func() *ValidateAdvertiseMultiPortType {
	v := &ValidateAdvertiseMultiPortType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPorts := v.PortsValidationRuleHandler
	rulesPorts := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhPorts(rulesPorts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseMultiPortType.ports: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ports"] = vFn

	return v
}()

func AdvertiseMultiPortTypeValidator() db.Validator {
	return DefaultAdvertiseMultiPortTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertiseOptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseOptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AdvertiseOptionsType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdvertiseOnPublic().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AdvertiseOptionsType.advertise_on_public")
	}

	if err := m.GetAdvertiseCustom().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AdvertiseOptionsType.advertise_custom")
	}

	return nil
}

func (m *AdvertiseOptionsType) DeepCopy() *AdvertiseOptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseOptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseOptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseOptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseOptionsTypeValidator().Validate(ctx, m, opts...)
}

func (m *AdvertiseOptionsType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertiseOptionsType) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *AdvertiseOptionsType_AdvertiseInCluster:

		return nil, nil

	case *AdvertiseOptionsType_AdvertiseOnPublic:

		drInfos, err := m.GetAdvertiseOnPublic().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseOnPublic().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_on_public." + dri.DRField
		}
		return drInfos, err

	case *AdvertiseOptionsType_AdvertiseCustom:

		drInfos, err := m.GetAdvertiseCustom().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAdvertiseCustom().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "advertise_custom." + dri.DRField
		}
		return drInfos, err

	case *AdvertiseOptionsType_DoNotAdvertise:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateAdvertiseOptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseOptionsType) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAdvertiseOptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseOptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseOptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *AdvertiseOptionsType_AdvertiseInCluster:
		if fv, exists := v.FldValidators["advertise_choice.advertise_in_cluster"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertiseOptionsType_AdvertiseInCluster).AdvertiseInCluster
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_in_cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AdvertiseOptionsType_AdvertiseOnPublic:
		if fv, exists := v.FldValidators["advertise_choice.advertise_on_public"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertiseOptionsType_AdvertiseOnPublic).AdvertiseOnPublic
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_on_public"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AdvertiseOptionsType_AdvertiseCustom:
		if fv, exists := v.FldValidators["advertise_choice.advertise_custom"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertiseOptionsType_AdvertiseCustom).AdvertiseCustom
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("advertise_custom"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AdvertiseOptionsType_DoNotAdvertise:
		if fv, exists := v.FldValidators["advertise_choice.do_not_advertise"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertiseOptionsType_DoNotAdvertise).DoNotAdvertise
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("do_not_advertise"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseOptionsTypeValidator = func() *ValidateAdvertiseOptionsType {
	v := &ValidateAdvertiseOptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseOptionsType.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	v.FldValidators["advertise_choice.advertise_in_cluster"] = AdvertiseInClusterTypeValidator().Validate
	v.FldValidators["advertise_choice.advertise_on_public"] = AdvertisePublicTypeValidator().Validate
	v.FldValidators["advertise_choice.advertise_custom"] = AdvertiseCustomTypeValidator().Validate

	return v
}()

func AdvertiseOptionsTypeValidator() db.Validator {
	return DefaultAdvertiseOptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertisePortType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertisePortType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AdvertisePortType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetHttpLoadbalancer().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AdvertisePortType.http_loadbalancer")
	}

	return nil
}

func (m *AdvertisePortType) DeepCopy() *AdvertisePortType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertisePortType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertisePortType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertisePortType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertisePortTypeValidator().Validate(ctx, m, opts...)
}

func (m *AdvertisePortType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertisePortType) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *AdvertisePortType_HttpLoadbalancer:

		drInfos, err := m.GetHttpLoadbalancer().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttpLoadbalancer().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "http_loadbalancer." + dri.DRField
		}
		return drInfos, err

	case *AdvertisePortType_TcpLoadbalancer:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateAdvertisePortType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertisePortType) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAdvertisePortType) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for port")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := PortTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertisePortType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertisePortType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertisePortType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *AdvertisePortType_HttpLoadbalancer:
		if fv, exists := v.FldValidators["advertise_choice.http_loadbalancer"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertisePortType_HttpLoadbalancer).HttpLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("http_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AdvertisePortType_TcpLoadbalancer:
		if fv, exists := v.FldValidators["advertise_choice.tcp_loadbalancer"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertisePortType_TcpLoadbalancer).TcpLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("tcp_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertisePortTypeValidator = func() *ValidateAdvertisePortType {
	v := &ValidateAdvertisePortType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertisePortType.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertisePortType.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	v.FldValidators["advertise_choice.http_loadbalancer"] = HTTPLoadBalancerTypeValidator().Validate
	v.FldValidators["advertise_choice.tcp_loadbalancer"] = TCPLoadBalancerTypeValidator().Validate

	return v
}()

func AdvertisePortTypeValidator() db.Validator {
	return DefaultAdvertisePortTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertisePublicType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertisePublicType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AdvertisePublicType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPort().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AdvertisePublicType.port")
	}

	if err := m.GetMultiPorts().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AdvertisePublicType.multi_ports")
	}

	return nil
}

func (m *AdvertisePublicType) DeepCopy() *AdvertisePublicType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertisePublicType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertisePublicType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertisePublicType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertisePublicTypeValidator().Validate(ctx, m, opts...)
}

func (m *AdvertisePublicType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertisePublicType) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *AdvertisePublicType_Port:

		drInfos, err := m.GetPort().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPort().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "port." + dri.DRField
		}
		return drInfos, err

	case *AdvertisePublicType_MultiPorts:

		drInfos, err := m.GetMultiPorts().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetMultiPorts().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "multi_ports." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateAdvertisePublicType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertisePublicType) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAdvertisePublicType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertisePublicType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertisePublicType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *AdvertisePublicType_Port:
		if fv, exists := v.FldValidators["advertise_choice.port"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertisePublicType_Port).Port
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AdvertisePublicType_MultiPorts:
		if fv, exists := v.FldValidators["advertise_choice.multi_ports"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertisePublicType_MultiPorts).MultiPorts
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("multi_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertisePublicTypeValidator = func() *ValidateAdvertisePublicType {
	v := &ValidateAdvertisePublicType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertisePublicType.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	v.FldValidators["advertise_choice.port"] = AdvertiseSinglePortTypeValidator().Validate
	v.FldValidators["advertise_choice.multi_ports"] = AdvertiseMultiPortTypeValidator().Validate

	return v
}()

func AdvertisePublicTypeValidator() db.Validator {
	return DefaultAdvertisePublicTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertiseSimpleServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseSimpleServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AdvertiseSimpleServiceType) DeepCopy() *AdvertiseSimpleServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseSimpleServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseSimpleServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseSimpleServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseSimpleServiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAdvertiseSimpleServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseSimpleServiceType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseSimpleServiceType) ServicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_port")
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseSimpleServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseSimpleServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseSimpleServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_port"]; exists {

		vOpts := append(opts, db.WithValidateField("service_port"))
		if err := fv(ctx, m.GetServicePort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseSimpleServiceTypeValidator = func() *ValidateAdvertiseSimpleServiceType {
	v := &ValidateAdvertiseSimpleServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.max_len":   "256",
		"ves.io.schema.rules.repeated.items.string.min_len":   "1",
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.min_items":              "1",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseSimpleServiceType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhServicePort := v.ServicePortValidationRuleHandler
	rulesServicePort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1024",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhServicePort(rulesServicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseSimpleServiceType.service_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_port"] = vFn

	return v
}()

func AdvertiseSimpleServiceTypeValidator() db.Validator {
	return DefaultAdvertiseSimpleServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertiseSinglePortType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseSinglePortType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AdvertiseSinglePortType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetHttpLoadbalancer().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AdvertiseSinglePortType.http_loadbalancer")
	}

	return nil
}

func (m *AdvertiseSinglePortType) DeepCopy() *AdvertiseSinglePortType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseSinglePortType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseSinglePortType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseSinglePortType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseSinglePortTypeValidator().Validate(ctx, m, opts...)
}

func (m *AdvertiseSinglePortType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAdvertiseChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertiseSinglePortType) GetAdvertiseChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseChoice() == nil {
		return nil, nil
	}
	switch m.GetAdvertiseChoice().(type) {
	case *AdvertiseSinglePortType_HttpLoadbalancer:

		drInfos, err := m.GetHttpLoadbalancer().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttpLoadbalancer().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "http_loadbalancer." + dri.DRField
		}
		return drInfos, err

	case *AdvertiseSinglePortType_TcpLoadbalancer:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateAdvertiseSinglePortType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseSinglePortType) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAdvertiseSinglePortType) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for port")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := SinglePortTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAdvertiseSinglePortType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseSinglePortType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseSinglePortType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *AdvertiseSinglePortType_HttpLoadbalancer:
		if fv, exists := v.FldValidators["advertise_choice.http_loadbalancer"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertiseSinglePortType_HttpLoadbalancer).HttpLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("http_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AdvertiseSinglePortType_TcpLoadbalancer:
		if fv, exists := v.FldValidators["advertise_choice.tcp_loadbalancer"]; exists {
			val := m.GetAdvertiseChoice().(*AdvertiseSinglePortType_TcpLoadbalancer).TcpLoadbalancer
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("tcp_loadbalancer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseSinglePortTypeValidator = func() *ValidateAdvertiseSinglePortType {
	v := &ValidateAdvertiseSinglePortType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseSinglePortType.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseSinglePortType.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	v.FldValidators["advertise_choice.http_loadbalancer"] = HTTPLoadBalancerTypeValidator().Validate
	v.FldValidators["advertise_choice.tcp_loadbalancer"] = TCPLoadBalancerTypeValidator().Validate

	return v
}()

func AdvertiseSinglePortTypeValidator() db.Validator {
	return DefaultAdvertiseSinglePortTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AdvertiseWhereType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvertiseWhereType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AdvertiseWhereType) DeepCopy() *AdvertiseWhereType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvertiseWhereType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvertiseWhereType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvertiseWhereType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvertiseWhereTypeValidator().Validate(ctx, m, opts...)
}

func (m *AdvertiseWhereType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AdvertiseWhereType) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetChoice() == nil {
		return nil, nil
	}
	switch m.GetChoice().(type) {
	case *AdvertiseWhereType_Site:

		drInfos, err := m.GetSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site." + dri.DRField
		}
		return drInfos, err

	case *AdvertiseWhereType_VirtualSite:

		drInfos, err := m.GetVirtualSite().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVirtualSite().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "virtual_site." + dri.DRField
		}
		return drInfos, err

	case *AdvertiseWhereType_Vk8SService:

		drInfos, err := m.GetVk8SService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVk8SService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vk8s_service." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateAdvertiseWhereType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvertiseWhereType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAdvertiseWhereType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvertiseWhereType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvertiseWhereType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AdvertiseWhereType_Site:
		if fv, exists := v.FldValidators["choice.site"]; exists {
			val := m.GetChoice().(*AdvertiseWhereType_Site).Site
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AdvertiseWhereType_VirtualSite:
		if fv, exists := v.FldValidators["choice.virtual_site"]; exists {
			val := m.GetChoice().(*AdvertiseWhereType_VirtualSite).VirtualSite
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("virtual_site"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AdvertiseWhereType_Vk8SService:
		if fv, exists := v.FldValidators["choice.vk8s_service"]; exists {
			val := m.GetChoice().(*AdvertiseWhereType_Vk8SService).Vk8SService
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("vk8s_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvertiseWhereTypeValidator = func() *ValidateAdvertiseWhereType {
	v := &ValidateAdvertiseWhereType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AdvertiseWhereType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.site"] = ves_io_schema_views.WhereSiteValidator().Validate
	v.FldValidators["choice.virtual_site"] = ves_io_schema_views.WhereVirtualSiteValidator().Validate
	v.FldValidators["choice.vk8s_service"] = ves_io_schema_views.WhereVK8SServiceValidator().Validate

	return v
}()

func AdvertiseWhereTypeValidator() db.Validator {
	return DefaultAdvertiseWhereTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ConfigurationFileType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConfigurationFileType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConfigurationFileType) DeepCopy() *ConfigurationFileType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConfigurationFileType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConfigurationFileType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConfigurationFileType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConfigurationFileTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConfigurationFileType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConfigurationFileType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateConfigurationFileType) DataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for data")
	}

	return validatorFn, nil
}

func (v *ValidateConfigurationFileType) VolumeNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volume_name")
	}

	return validatorFn, nil
}

func (v *ValidateConfigurationFileType) MountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for mount")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := VolumeMountTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateConfigurationFileType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConfigurationFileType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConfigurationFileType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		if err := fv(ctx, m.GetData(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mount"]; exists {

		vOpts := append(opts, db.WithValidateField("mount"))
		if err := fv(ctx, m.GetMount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volume_name"]; exists {

		vOpts := append(opts, db.WithValidateField("volume_name"))
		if err := fv(ctx, m.GetVolumeName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConfigurationFileTypeValidator = func() *ValidateConfigurationFileType {
	v := &ValidateConfigurationFileType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConfigurationFileType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhData := v.DataValidationRuleHandler
	rulesData := map[string]string{
		"ves.io.schema.rules.string.max_len": "16384",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhData(rulesData)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConfigurationFileType.data: %s", err)
		panic(errMsg)
	}
	v.FldValidators["data"] = vFn

	vrhVolumeName := v.VolumeNameValidationRuleHandler
	rulesVolumeName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhVolumeName(rulesVolumeName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConfigurationFileType.volume_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volume_name"] = vFn

	vrhMount := v.MountValidationRuleHandler
	rulesMount := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMount(rulesMount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConfigurationFileType.mount: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mount"] = vFn

	return v
}()

func ConfigurationFileTypeValidator() db.Validator {
	return DefaultConfigurationFileTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ConfigurationParameterType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConfigurationParameterType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConfigurationParameterType) DeepCopy() *ConfigurationParameterType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConfigurationParameterType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConfigurationParameterType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConfigurationParameterType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConfigurationParameterTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConfigurationParameterType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConfigurationParameterType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateConfigurationParameterType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConfigurationParameterType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConfigurationParameterType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *ConfigurationParameterType_File:
		if fv, exists := v.FldValidators["choice.file"]; exists {
			val := m.GetChoice().(*ConfigurationParameterType_File).File
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("file"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ConfigurationParameterType_EnvVar:
		if fv, exists := v.FldValidators["choice.env_var"]; exists {
			val := m.GetChoice().(*ConfigurationParameterType_EnvVar).EnvVar
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("env_var"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConfigurationParameterTypeValidator = func() *ValidateConfigurationParameterType {
	v := &ValidateConfigurationParameterType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConfigurationParameterType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.file"] = ConfigurationFileTypeValidator().Validate
	v.FldValidators["choice.env_var"] = EnvironmentVariableTypeValidator().Validate

	return v
}()

func ConfigurationParameterTypeValidator() db.Validator {
	return DefaultConfigurationParameterTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ConfigurationParametersType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConfigurationParametersType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConfigurationParametersType) DeepCopy() *ConfigurationParametersType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConfigurationParametersType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConfigurationParametersType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConfigurationParametersType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConfigurationParametersTypeValidator().Validate(ctx, m, opts...)
}

type ValidateConfigurationParametersType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConfigurationParametersType) ParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for parameters")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ConfigurationParameterType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ConfigurationParameterTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for parameters")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ConfigurationParameterType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ConfigurationParameterType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated parameters")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items parameters")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateConfigurationParametersType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConfigurationParametersType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConfigurationParametersType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["parameters"]; exists {
		vOpts := append(opts, db.WithValidateField("parameters"))
		if err := fv(ctx, m.GetParameters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConfigurationParametersTypeValidator = func() *ValidateConfigurationParametersType {
	v := &ValidateConfigurationParametersType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhParameters := v.ParametersValidationRuleHandler
	rulesParameters := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhParameters(rulesParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ConfigurationParametersType.parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["parameters"] = vFn

	return v
}()

func ConfigurationParametersTypeValidator() db.Validator {
	return DefaultConfigurationParametersTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ContainerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ContainerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ContainerType) DeepCopy() *ContainerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ContainerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ContainerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ContainerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ContainerTypeValidator().Validate(ctx, m, opts...)
}

func (m *ContainerType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetFlavorChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetFlavorChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetImageDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetImageDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *ContainerType) GetFlavorChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetFlavorChoice().(type) {
	case *ContainerType_CustomFlavor:

		vref := m.GetCustomFlavor()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("workload_flavor.Object")
		dri := db.DRefInfo{
			RefdType:   "workload_flavor.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "custom_flavor",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *ContainerType_DefaultFlavor:

		return nil, nil

	default:
		return nil, nil
	}
}

// GetFlavorChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ContainerType) GetFlavorChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetFlavorChoice().(type) {
	case *ContainerType_CustomFlavor:
		refdType, err := d.TypeForEntryKind("", "", "workload_flavor.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: workload_flavor")
		}

		vref := m.GetCustomFlavor()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "workload_flavor.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *ContainerType_DefaultFlavor:

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ContainerType) GetImageDRefInfo() ([]db.DRefInfo, error) {
	if m.GetImage() == nil {
		return nil, nil
	}

	drInfos, err := m.GetImage().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetImage().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "image." + dri.DRField
	}
	return drInfos, err

}

type ValidateContainerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateContainerType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateContainerType) ImageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for image")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ImageTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateContainerType) CommandValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for command")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for command")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated command")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items command")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateContainerType) ArgsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for args")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for args")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated args")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items args")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateContainerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ContainerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ContainerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["args"]; exists {
		vOpts := append(opts, db.WithValidateField("args"))
		if err := fv(ctx, m.GetArgs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["command"]; exists {
		vOpts := append(opts, db.WithValidateField("command"))
		if err := fv(ctx, m.GetCommand(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetFlavorChoice().(type) {
	case *ContainerType_Flavor:
		if fv, exists := v.FldValidators["flavor_choice.flavor"]; exists {
			val := m.GetFlavorChoice().(*ContainerType_Flavor).Flavor
			vOpts := append(opts,
				db.WithValidateField("flavor_choice"),
				db.WithValidateField("flavor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ContainerType_CustomFlavor:
		if fv, exists := v.FldValidators["flavor_choice.custom_flavor"]; exists {
			val := m.GetFlavorChoice().(*ContainerType_CustomFlavor).CustomFlavor
			vOpts := append(opts,
				db.WithValidateField("flavor_choice"),
				db.WithValidateField("custom_flavor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ContainerType_DefaultFlavor:
		if fv, exists := v.FldValidators["flavor_choice.default_flavor"]; exists {
			val := m.GetFlavorChoice().(*ContainerType_DefaultFlavor).DefaultFlavor
			vOpts := append(opts,
				db.WithValidateField("flavor_choice"),
				db.WithValidateField("default_flavor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["image"]; exists {

		vOpts := append(opts, db.WithValidateField("image"))
		if err := fv(ctx, m.GetImage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["init_container"]; exists {

		vOpts := append(opts, db.WithValidateField("init_container"))
		if err := fv(ctx, m.GetInitContainer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["liveness_check"]; exists {

		vOpts := append(opts, db.WithValidateField("liveness_check"))
		if err := fv(ctx, m.GetLivenessCheck(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["readiness_check"]; exists {

		vOpts := append(opts, db.WithValidateField("readiness_check"))
		if err := fv(ctx, m.GetReadinessCheck(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultContainerTypeValidator = func() *ValidateContainerType {
	v := &ValidateContainerType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContainerType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhImage := v.ImageValidationRuleHandler
	rulesImage := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhImage(rulesImage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContainerType.image: %s", err)
		panic(errMsg)
	}
	v.FldValidators["image"] = vFn

	vrhCommand := v.CommandValidationRuleHandler
	rulesCommand := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
	}
	vFn, err = vrhCommand(rulesCommand)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContainerType.command: %s", err)
		panic(errMsg)
	}
	v.FldValidators["command"] = vFn

	vrhArgs := v.ArgsValidationRuleHandler
	rulesArgs := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
	}
	vFn, err = vrhArgs(rulesArgs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ContainerType.args: %s", err)
		panic(errMsg)
	}
	v.FldValidators["args"] = vFn

	v.FldValidators["flavor_choice.custom_flavor"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["liveness_check"] = HealthCheckTypeValidator().Validate

	v.FldValidators["readiness_check"] = HealthCheckTypeValidator().Validate

	return v
}()

func ContainerTypeValidator() db.Validator {
	return DefaultContainerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.service")
	}

	if err := m.GetStatefulService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.stateful_service")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWorkloadChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetWorkloadChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWorkloadChoice() == nil {
		return nil, nil
	}
	switch m.GetWorkloadChoice().(type) {
	case *CreateSpecType_SimpleService:

		drInfos, err := m.GetSimpleService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSimpleService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "simple_service." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Service:

		drInfos, err := m.GetService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "service." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_StatefulService:

		drInfos, err := m.GetStatefulService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStatefulService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "stateful_service." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Job:

		drInfos, err := m.GetJob().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetJob().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "job." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) WorkloadChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for workload_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["workload_choice"]; exists {
		val := m.GetWorkloadChoice()
		vOpts := append(opts,
			db.WithValidateField("workload_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWorkloadChoice().(type) {
	case *CreateSpecType_SimpleService:
		if fv, exists := v.FldValidators["workload_choice.simple_service"]; exists {
			val := m.GetWorkloadChoice().(*CreateSpecType_SimpleService).SimpleService
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("simple_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Service:
		if fv, exists := v.FldValidators["workload_choice.service"]; exists {
			val := m.GetWorkloadChoice().(*CreateSpecType_Service).Service
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_StatefulService:
		if fv, exists := v.FldValidators["workload_choice.stateful_service"]; exists {
			val := m.GetWorkloadChoice().(*CreateSpecType_StatefulService).StatefulService
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("stateful_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Job:
		if fv, exists := v.FldValidators["workload_choice.job"]; exists {
			val := m.GetWorkloadChoice().(*CreateSpecType_Job).Job
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("job"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhWorkloadChoice := v.WorkloadChoiceValidationRuleHandler
	rulesWorkloadChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWorkloadChoice(rulesWorkloadChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.workload_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["workload_choice"] = vFn

	v.FldValidators["workload_choice.simple_service"] = SimpleServiceTypeValidator().Validate
	v.FldValidators["workload_choice.service"] = ServiceTypeValidator().Validate
	v.FldValidators["workload_choice.stateful_service"] = StatefulServiceTypeValidator().Validate
	v.FldValidators["workload_choice.job"] = JobTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeployCESiteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeployCESiteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeployCESiteType) DeepCopy() *DeployCESiteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeployCESiteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeployCESiteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeployCESiteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeployCESiteTypeValidator().Validate(ctx, m, opts...)
}

func (m *DeployCESiteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteDRefInfo()

}

func (m *DeployCESiteType) GetSiteDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetSite()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("DeployCESiteType.site[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("site.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "site",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DeployCESiteType) GetSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for i, vref := range m.GetSite() {
		if vref == nil {
			return nil, fmt.Errorf("DeployCESiteType.site[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateDeployCESiteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeployCESiteType) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for site")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for site")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated site")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items site")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDeployCESiteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeployCESiteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeployCESiteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site"]; exists {
		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeployCESiteTypeValidator = func() *ValidateDeployCESiteType {
	v := &ValidateDeployCESiteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeployCESiteType.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	return v
}()

func DeployCESiteTypeValidator() db.Validator {
	return DefaultDeployCESiteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeployCEVirtualSiteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeployCEVirtualSiteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeployCEVirtualSiteType) DeepCopy() *DeployCEVirtualSiteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeployCEVirtualSiteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeployCEVirtualSiteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeployCEVirtualSiteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeployCEVirtualSiteTypeValidator().Validate(ctx, m, opts...)
}

func (m *DeployCEVirtualSiteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualSiteDRefInfo()

}

func (m *DeployCEVirtualSiteType) GetVirtualSiteDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetVirtualSite()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("DeployCEVirtualSiteType.virtual_site[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_site.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "virtual_site",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetVirtualSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DeployCEVirtualSiteType) GetVirtualSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
	}
	for i, vref := range m.GetVirtualSite() {
		if vref == nil {
			return nil, fmt.Errorf("DeployCEVirtualSiteType.virtual_site[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateDeployCEVirtualSiteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeployCEVirtualSiteType) VirtualSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for virtual_site")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for virtual_site")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated virtual_site")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items virtual_site")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDeployCEVirtualSiteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeployCEVirtualSiteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeployCEVirtualSiteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["virtual_site"]; exists {
		vOpts := append(opts, db.WithValidateField("virtual_site"))
		if err := fv(ctx, m.GetVirtualSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeployCEVirtualSiteTypeValidator = func() *ValidateDeployCEVirtualSiteType {
	v := &ValidateDeployCEVirtualSiteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVirtualSite := v.VirtualSiteValidationRuleHandler
	rulesVirtualSite := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhVirtualSite(rulesVirtualSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeployCEVirtualSiteType.virtual_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_site"] = vFn

	return v
}()

func DeployCEVirtualSiteTypeValidator() db.Validator {
	return DefaultDeployCEVirtualSiteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeployOptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeployOptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeployOptionsType) DeepCopy() *DeployOptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeployOptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeployOptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeployOptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeployOptionsTypeValidator().Validate(ctx, m, opts...)
}

func (m *DeployOptionsType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetDeployChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *DeployOptionsType) GetDeployChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDeployChoice() == nil {
		return nil, nil
	}
	switch m.GetDeployChoice().(type) {
	case *DeployOptionsType_AllRes:

		return nil, nil

	case *DeployOptionsType_DeployReVirtualSites:

		drInfos, err := m.GetDeployReVirtualSites().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDeployReVirtualSites().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "deploy_re_virtual_sites." + dri.DRField
		}
		return drInfos, err

	case *DeployOptionsType_DeployCeVirtualSites:

		drInfos, err := m.GetDeployCeVirtualSites().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDeployCeVirtualSites().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "deploy_ce_virtual_sites." + dri.DRField
		}
		return drInfos, err

	case *DeployOptionsType_DeployCeSites:

		drInfos, err := m.GetDeployCeSites().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDeployCeSites().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "deploy_ce_sites." + dri.DRField
		}
		return drInfos, err

	case *DeployOptionsType_DefaultVirtualSites:

		return nil, nil

	case *DeployOptionsType_DeployReSites:

		drInfos, err := m.GetDeployReSites().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDeployReSites().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "deploy_re_sites." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateDeployOptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeployOptionsType) DeployChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for deploy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDeployOptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeployOptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeployOptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["deploy_choice"]; exists {
		val := m.GetDeployChoice()
		vOpts := append(opts,
			db.WithValidateField("deploy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDeployChoice().(type) {
	case *DeployOptionsType_AllRes:
		if fv, exists := v.FldValidators["deploy_choice.all_res"]; exists {
			val := m.GetDeployChoice().(*DeployOptionsType_AllRes).AllRes
			vOpts := append(opts,
				db.WithValidateField("deploy_choice"),
				db.WithValidateField("all_res"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DeployOptionsType_DeployReVirtualSites:
		if fv, exists := v.FldValidators["deploy_choice.deploy_re_virtual_sites"]; exists {
			val := m.GetDeployChoice().(*DeployOptionsType_DeployReVirtualSites).DeployReVirtualSites
			vOpts := append(opts,
				db.WithValidateField("deploy_choice"),
				db.WithValidateField("deploy_re_virtual_sites"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DeployOptionsType_DeployCeVirtualSites:
		if fv, exists := v.FldValidators["deploy_choice.deploy_ce_virtual_sites"]; exists {
			val := m.GetDeployChoice().(*DeployOptionsType_DeployCeVirtualSites).DeployCeVirtualSites
			vOpts := append(opts,
				db.WithValidateField("deploy_choice"),
				db.WithValidateField("deploy_ce_virtual_sites"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DeployOptionsType_DeployCeSites:
		if fv, exists := v.FldValidators["deploy_choice.deploy_ce_sites"]; exists {
			val := m.GetDeployChoice().(*DeployOptionsType_DeployCeSites).DeployCeSites
			vOpts := append(opts,
				db.WithValidateField("deploy_choice"),
				db.WithValidateField("deploy_ce_sites"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DeployOptionsType_DefaultVirtualSites:
		if fv, exists := v.FldValidators["deploy_choice.default_virtual_sites"]; exists {
			val := m.GetDeployChoice().(*DeployOptionsType_DefaultVirtualSites).DefaultVirtualSites
			vOpts := append(opts,
				db.WithValidateField("deploy_choice"),
				db.WithValidateField("default_virtual_sites"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DeployOptionsType_DeployReSites:
		if fv, exists := v.FldValidators["deploy_choice.deploy_re_sites"]; exists {
			val := m.GetDeployChoice().(*DeployOptionsType_DeployReSites).DeployReSites
			vOpts := append(opts,
				db.WithValidateField("deploy_choice"),
				db.WithValidateField("deploy_re_sites"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeployOptionsTypeValidator = func() *ValidateDeployOptionsType {
	v := &ValidateDeployOptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDeployChoice := v.DeployChoiceValidationRuleHandler
	rulesDeployChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDeployChoice(rulesDeployChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeployOptionsType.deploy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["deploy_choice"] = vFn

	v.FldValidators["deploy_choice.deploy_re_virtual_sites"] = DeployREVirtualSiteTypeValidator().Validate
	v.FldValidators["deploy_choice.deploy_ce_virtual_sites"] = DeployCEVirtualSiteTypeValidator().Validate
	v.FldValidators["deploy_choice.deploy_ce_sites"] = DeployCESiteTypeValidator().Validate
	v.FldValidators["deploy_choice.deploy_re_sites"] = DeployRESiteTypeValidator().Validate

	return v
}()

func DeployOptionsTypeValidator() db.Validator {
	return DefaultDeployOptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeployRESiteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeployRESiteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeployRESiteType) DeepCopy() *DeployRESiteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeployRESiteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeployRESiteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeployRESiteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeployRESiteTypeValidator().Validate(ctx, m, opts...)
}

func (m *DeployRESiteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteDRefInfo()

}

func (m *DeployRESiteType) GetSiteDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetSite()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("DeployRESiteType.site[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("site.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "site",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DeployRESiteType) GetSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for i, vref := range m.GetSite() {
		if vref == nil {
			return nil, fmt.Errorf("DeployRESiteType.site[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateDeployRESiteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeployRESiteType) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for site")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for site")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated site")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items site")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDeployRESiteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeployRESiteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeployRESiteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site"]; exists {
		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeployRESiteTypeValidator = func() *ValidateDeployRESiteType {
	v := &ValidateDeployRESiteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeployRESiteType.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	return v
}()

func DeployRESiteTypeValidator() db.Validator {
	return DefaultDeployRESiteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeployREVirtualSiteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeployREVirtualSiteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeployREVirtualSiteType) DeepCopy() *DeployREVirtualSiteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeployREVirtualSiteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeployREVirtualSiteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeployREVirtualSiteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeployREVirtualSiteTypeValidator().Validate(ctx, m, opts...)
}

func (m *DeployREVirtualSiteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualSiteDRefInfo()

}

func (m *DeployREVirtualSiteType) GetVirtualSiteDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetVirtualSite()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("DeployREVirtualSiteType.virtual_site[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_site.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_site.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "virtual_site",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetVirtualSiteDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DeployREVirtualSiteType) GetVirtualSiteDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_site")
	}
	for i, vref := range m.GetVirtualSite() {
		if vref == nil {
			return nil, fmt.Errorf("DeployREVirtualSiteType.virtual_site[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_site.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateDeployREVirtualSiteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeployREVirtualSiteType) VirtualSiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for virtual_site")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for virtual_site")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated virtual_site")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items virtual_site")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDeployREVirtualSiteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeployREVirtualSiteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeployREVirtualSiteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["virtual_site"]; exists {
		vOpts := append(opts, db.WithValidateField("virtual_site"))
		if err := fv(ctx, m.GetVirtualSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeployREVirtualSiteTypeValidator = func() *ValidateDeployREVirtualSiteType {
	v := &ValidateDeployREVirtualSiteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVirtualSite := v.VirtualSiteValidationRuleHandler
	rulesVirtualSite := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhVirtualSite(rulesVirtualSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeployREVirtualSiteType.virtual_site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_site"] = vFn

	return v
}()

func DeployREVirtualSiteTypeValidator() db.Validator {
	return DefaultDeployREVirtualSiteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *EmptyDirectoryVolumeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EmptyDirectoryVolumeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EmptyDirectoryVolumeType) DeepCopy() *EmptyDirectoryVolumeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EmptyDirectoryVolumeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EmptyDirectoryVolumeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EmptyDirectoryVolumeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EmptyDirectoryVolumeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateEmptyDirectoryVolumeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEmptyDirectoryVolumeType) SizeLimitValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewDoubleValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for size_limit")
	}

	return validatorFn, nil
}

func (v *ValidateEmptyDirectoryVolumeType) MountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for mount")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := VolumeMountTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateEmptyDirectoryVolumeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EmptyDirectoryVolumeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EmptyDirectoryVolumeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mount"]; exists {

		vOpts := append(opts, db.WithValidateField("mount"))
		if err := fv(ctx, m.GetMount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["size_limit"]; exists {

		vOpts := append(opts, db.WithValidateField("size_limit"))
		if err := fv(ctx, m.GetSizeLimit(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEmptyDirectoryVolumeTypeValidator = func() *ValidateEmptyDirectoryVolumeType {
	v := &ValidateEmptyDirectoryVolumeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSizeLimit := v.SizeLimitValidationRuleHandler
	rulesSizeLimit := map[string]string{
		"ves.io.schema.rules.double.lte":       "10",
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSizeLimit(rulesSizeLimit)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EmptyDirectoryVolumeType.size_limit: %s", err)
		panic(errMsg)
	}
	v.FldValidators["size_limit"] = vFn

	vrhMount := v.MountValidationRuleHandler
	rulesMount := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMount(rulesMount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EmptyDirectoryVolumeType.mount: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mount"] = vFn

	return v
}()

func EmptyDirectoryVolumeTypeValidator() db.Validator {
	return DefaultEmptyDirectoryVolumeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *EnvironmentVariableType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnvironmentVariableType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnvironmentVariableType) DeepCopy() *EnvironmentVariableType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnvironmentVariableType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnvironmentVariableType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnvironmentVariableType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnvironmentVariableTypeValidator().Validate(ctx, m, opts...)
}

type ValidateEnvironmentVariableType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnvironmentVariableType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateEnvironmentVariableType) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value")
	}

	return validatorFn, nil
}

func (v *ValidateEnvironmentVariableType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnvironmentVariableType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnvironmentVariableType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnvironmentVariableTypeValidator = func() *ValidateEnvironmentVariableType {
	v := &ValidateEnvironmentVariableType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EnvironmentVariableType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EnvironmentVariableType.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func EnvironmentVariableTypeValidator() db.Validator {
	return DefaultEnvironmentVariableTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *EphemeralStorageVolumeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EphemeralStorageVolumeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EphemeralStorageVolumeType) DeepCopy() *EphemeralStorageVolumeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EphemeralStorageVolumeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EphemeralStorageVolumeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EphemeralStorageVolumeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EphemeralStorageVolumeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateEphemeralStorageVolumeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEphemeralStorageVolumeType) VolumeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volume_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEphemeralStorageVolumeType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateEphemeralStorageVolumeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EphemeralStorageVolumeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EphemeralStorageVolumeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volume_choice"]; exists {
		val := m.GetVolumeChoice()
		vOpts := append(opts,
			db.WithValidateField("volume_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVolumeChoice().(type) {
	case *EphemeralStorageVolumeType_EmptyDir:
		if fv, exists := v.FldValidators["volume_choice.empty_dir"]; exists {
			val := m.GetVolumeChoice().(*EphemeralStorageVolumeType_EmptyDir).EmptyDir
			vOpts := append(opts,
				db.WithValidateField("volume_choice"),
				db.WithValidateField("empty_dir"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EphemeralStorageVolumeType_HostPath:
		if fv, exists := v.FldValidators["volume_choice.host_path"]; exists {
			val := m.GetVolumeChoice().(*EphemeralStorageVolumeType_HostPath).HostPath
			vOpts := append(opts,
				db.WithValidateField("volume_choice"),
				db.WithValidateField("host_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEphemeralStorageVolumeTypeValidator = func() *ValidateEphemeralStorageVolumeType {
	v := &ValidateEphemeralStorageVolumeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVolumeChoice := v.VolumeChoiceValidationRuleHandler
	rulesVolumeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVolumeChoice(rulesVolumeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EphemeralStorageVolumeType.volume_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volume_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.dns_1123_label": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EphemeralStorageVolumeType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["volume_choice.empty_dir"] = EmptyDirectoryVolumeTypeValidator().Validate
	v.FldValidators["volume_choice.host_path"] = HostPathVolumeTypeValidator().Validate

	return v
}()

func EphemeralStorageVolumeTypeValidator() db.Validator {
	return DefaultEphemeralStorageVolumeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ExecHealthCheckType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ExecHealthCheckType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ExecHealthCheckType) DeepCopy() *ExecHealthCheckType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ExecHealthCheckType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ExecHealthCheckType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ExecHealthCheckType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ExecHealthCheckTypeValidator().Validate(ctx, m, opts...)
}

type ValidateExecHealthCheckType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateExecHealthCheckType) CommandValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for command")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for command")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated command")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items command")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateExecHealthCheckType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ExecHealthCheckType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ExecHealthCheckType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["command"]; exists {
		vOpts := append(opts, db.WithValidateField("command"))
		if err := fv(ctx, m.GetCommand(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultExecHealthCheckTypeValidator = func() *ValidateExecHealthCheckType {
	v := &ValidateExecHealthCheckType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCommand := v.CommandValidationRuleHandler
	rulesCommand := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "64",
		"ves.io.schema.rules.repeated.items.string.min_len": "1",
		"ves.io.schema.rules.repeated.max_items":            "16",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhCommand(rulesCommand)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ExecHealthCheckType.command: %s", err)
		panic(errMsg)
	}
	v.FldValidators["command"] = vFn

	return v
}()

func ExecHealthCheckTypeValidator() db.Validator {
	return DefaultExecHealthCheckTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.service")
	}

	if err := m.GetStatefulService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.stateful_service")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWorkloadChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetWorkloadChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWorkloadChoice() == nil {
		return nil, nil
	}
	switch m.GetWorkloadChoice().(type) {
	case *GetSpecType_SimpleService:

		drInfos, err := m.GetSimpleService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSimpleService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "simple_service." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Service:

		drInfos, err := m.GetService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "service." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_StatefulService:

		drInfos, err := m.GetStatefulService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStatefulService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "stateful_service." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Job:

		drInfos, err := m.GetJob().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetJob().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "job." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) WorkloadChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for workload_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["workload_choice"]; exists {
		val := m.GetWorkloadChoice()
		vOpts := append(opts,
			db.WithValidateField("workload_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWorkloadChoice().(type) {
	case *GetSpecType_SimpleService:
		if fv, exists := v.FldValidators["workload_choice.simple_service"]; exists {
			val := m.GetWorkloadChoice().(*GetSpecType_SimpleService).SimpleService
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("simple_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Service:
		if fv, exists := v.FldValidators["workload_choice.service"]; exists {
			val := m.GetWorkloadChoice().(*GetSpecType_Service).Service
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_StatefulService:
		if fv, exists := v.FldValidators["workload_choice.stateful_service"]; exists {
			val := m.GetWorkloadChoice().(*GetSpecType_StatefulService).StatefulService
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("stateful_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Job:
		if fv, exists := v.FldValidators["workload_choice.job"]; exists {
			val := m.GetWorkloadChoice().(*GetSpecType_Job).Job
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("job"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhWorkloadChoice := v.WorkloadChoiceValidationRuleHandler
	rulesWorkloadChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWorkloadChoice(rulesWorkloadChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.workload_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["workload_choice"] = vFn

	v.FldValidators["workload_choice.simple_service"] = SimpleServiceTypeValidator().Validate
	v.FldValidators["workload_choice.service"] = ServiceTypeValidator().Validate
	v.FldValidators["workload_choice.stateful_service"] = StatefulServiceTypeValidator().Validate
	v.FldValidators["workload_choice.job"] = JobTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.service")
	}

	if err := m.GetStatefulService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.stateful_service")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetViewInternalDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetViewInternalDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVirtualK8SDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVirtualK8SDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWorkloadChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWorkloadChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetViewInternalDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("view_internal.Object")
	dri := db.DRefInfo{
		RefdType:   "view_internal.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "view_internal",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetViewInternalDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetViewInternalDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "view_internal.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: view_internal")
	}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "view_internal.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

func (m *GlobalSpecType) GetVirtualK8SDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualK8S()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_k8s.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_k8s.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_k8s",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualK8SDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetVirtualK8SDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_k8s.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_k8s")
	}

	vref := m.GetVirtualK8S()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_k8s.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetWorkloadChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWorkloadChoice() == nil {
		return nil, nil
	}
	switch m.GetWorkloadChoice().(type) {
	case *GlobalSpecType_SimpleService:

		drInfos, err := m.GetSimpleService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSimpleService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "simple_service." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Service:

		drInfos, err := m.GetService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "service." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_StatefulService:

		drInfos, err := m.GetStatefulService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStatefulService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "stateful_service." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Job:

		drInfos, err := m.GetJob().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetJob().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "job." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) WorkloadChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for workload_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["view_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("view_internal"))
		if err := fv(ctx, m.GetViewInternal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_k8s"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_k8s"))
		if err := fv(ctx, m.GetVirtualK8S(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["workload_choice"]; exists {
		val := m.GetWorkloadChoice()
		vOpts := append(opts,
			db.WithValidateField("workload_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWorkloadChoice().(type) {
	case *GlobalSpecType_SimpleService:
		if fv, exists := v.FldValidators["workload_choice.simple_service"]; exists {
			val := m.GetWorkloadChoice().(*GlobalSpecType_SimpleService).SimpleService
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("simple_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Service:
		if fv, exists := v.FldValidators["workload_choice.service"]; exists {
			val := m.GetWorkloadChoice().(*GlobalSpecType_Service).Service
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_StatefulService:
		if fv, exists := v.FldValidators["workload_choice.stateful_service"]; exists {
			val := m.GetWorkloadChoice().(*GlobalSpecType_StatefulService).StatefulService
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("stateful_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Job:
		if fv, exists := v.FldValidators["workload_choice.job"]; exists {
			val := m.GetWorkloadChoice().(*GlobalSpecType_Job).Job
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("job"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhWorkloadChoice := v.WorkloadChoiceValidationRuleHandler
	rulesWorkloadChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWorkloadChoice(rulesWorkloadChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.workload_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["workload_choice"] = vFn

	v.FldValidators["workload_choice.simple_service"] = SimpleServiceTypeValidator().Validate
	v.FldValidators["workload_choice.service"] = ServiceTypeValidator().Validate
	v.FldValidators["workload_choice.stateful_service"] = StatefulServiceTypeValidator().Validate
	v.FldValidators["workload_choice.job"] = JobTypeValidator().Validate

	v.FldValidators["view_internal"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["virtual_k8s"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HTTPHealthCheckType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HTTPHealthCheckType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HTTPHealthCheckType) DeepCopy() *HTTPHealthCheckType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HTTPHealthCheckType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HTTPHealthCheckType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HTTPHealthCheckType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HTTPHealthCheckTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHTTPHealthCheckType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHTTPHealthCheckType) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path")
	}

	return validatorFn, nil
}

func (v *ValidateHTTPHealthCheckType) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for port")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := PortChoiceTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHTTPHealthCheckType) HostHeaderValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for host_header")
	}

	return validatorFn, nil
}

func (v *ValidateHTTPHealthCheckType) HeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for headers")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for headers")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHTTPHealthCheckType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HTTPHealthCheckType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HTTPHealthCheckType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["headers"]; exists {
		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_header"]; exists {

		vOpts := append(opts, db.WithValidateField("host_header"))
		if err := fv(ctx, m.GetHostHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHTTPHealthCheckTypeValidator = func() *ValidateHTTPHealthCheckType {
	v := &ValidateHTTPHealthCheckType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "2048",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPHealthCheckType.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPHealthCheckType.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	vrhHostHeader := v.HostHeaderValidationRuleHandler
	rulesHostHeader := map[string]string{
		"ves.io.schema.rules.string.hostport": "true",
		"ves.io.schema.rules.string.max_len":  "262",
	}
	vFn, err = vrhHostHeader(rulesHostHeader)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPHealthCheckType.host_header: %s", err)
		panic(errMsg)
	}
	v.FldValidators["host_header"] = vFn

	vrhHeaders := v.HeadersValidationRuleHandler
	rulesHeaders := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "256",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "2048",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhHeaders(rulesHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPHealthCheckType.headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["headers"] = vFn

	return v
}()

func HTTPHealthCheckTypeValidator() db.Validator {
	return DefaultHTTPHealthCheckTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HTTPLoadBalancerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HTTPLoadBalancerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *HTTPLoadBalancerType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetHttps().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting HTTPLoadBalancerType.https")
	}

	return nil
}

func (m *HTTPLoadBalancerType) DeepCopy() *HTTPLoadBalancerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HTTPLoadBalancerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HTTPLoadBalancerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HTTPLoadBalancerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HTTPLoadBalancerTypeValidator().Validate(ctx, m, opts...)
}

func (m *HTTPLoadBalancerType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetLoadbalancerTypeDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLoadbalancerTypeDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRouteChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRouteChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *HTTPLoadBalancerType) GetLoadbalancerTypeDRefInfo() ([]db.DRefInfo, error) {
	if m.GetLoadbalancerType() == nil {
		return nil, nil
	}
	switch m.GetLoadbalancerType().(type) {
	case *HTTPLoadBalancerType_Http:

		return nil, nil

	case *HTTPLoadBalancerType_HttpsAutoCert:

		drInfos, err := m.GetHttpsAutoCert().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttpsAutoCert().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "https_auto_cert." + dri.DRField
		}
		return drInfos, err

	case *HTTPLoadBalancerType_Https:

		drInfos, err := m.GetHttps().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetHttps().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "https." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *HTTPLoadBalancerType) GetRouteChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRouteChoice() == nil {
		return nil, nil
	}
	switch m.GetRouteChoice().(type) {
	case *HTTPLoadBalancerType_DefaultRoute:

		return nil, nil

	case *HTTPLoadBalancerType_SpecificRoutes:

		drInfos, err := m.GetSpecificRoutes().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSpecificRoutes().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "specific_routes." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateHTTPLoadBalancerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHTTPLoadBalancerType) LoadbalancerTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_type")
	}
	return validatorFn, nil
}

func (v *ValidateHTTPLoadBalancerType) RouteChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for route_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHTTPLoadBalancerType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHTTPLoadBalancerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HTTPLoadBalancerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HTTPLoadBalancerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_type"]; exists {
		val := m.GetLoadbalancerType()
		vOpts := append(opts,
			db.WithValidateField("loadbalancer_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLoadbalancerType().(type) {
	case *HTTPLoadBalancerType_Http:
		if fv, exists := v.FldValidators["loadbalancer_type.http"]; exists {
			val := m.GetLoadbalancerType().(*HTTPLoadBalancerType_Http).Http
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("http"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HTTPLoadBalancerType_HttpsAutoCert:
		if fv, exists := v.FldValidators["loadbalancer_type.https_auto_cert"]; exists {
			val := m.GetLoadbalancerType().(*HTTPLoadBalancerType_HttpsAutoCert).HttpsAutoCert
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https_auto_cert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HTTPLoadBalancerType_Https:
		if fv, exists := v.FldValidators["loadbalancer_type.https"]; exists {
			val := m.GetLoadbalancerType().(*HTTPLoadBalancerType_Https).Https
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["route_choice"]; exists {
		val := m.GetRouteChoice()
		vOpts := append(opts,
			db.WithValidateField("route_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRouteChoice().(type) {
	case *HTTPLoadBalancerType_DefaultRoute:
		if fv, exists := v.FldValidators["route_choice.default_route"]; exists {
			val := m.GetRouteChoice().(*HTTPLoadBalancerType_DefaultRoute).DefaultRoute
			vOpts := append(opts,
				db.WithValidateField("route_choice"),
				db.WithValidateField("default_route"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HTTPLoadBalancerType_SpecificRoutes:
		if fv, exists := v.FldValidators["route_choice.specific_routes"]; exists {
			val := m.GetRouteChoice().(*HTTPLoadBalancerType_SpecificRoutes).SpecificRoutes
			vOpts := append(opts,
				db.WithValidateField("route_choice"),
				db.WithValidateField("specific_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHTTPLoadBalancerTypeValidator = func() *ValidateHTTPLoadBalancerType {
	v := &ValidateHTTPLoadBalancerType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLoadbalancerType := v.LoadbalancerTypeValidationRuleHandler
	rulesLoadbalancerType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLoadbalancerType(rulesLoadbalancerType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLoadBalancerType.loadbalancer_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_type"] = vFn

	vrhRouteChoice := v.RouteChoiceValidationRuleHandler
	rulesRouteChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRouteChoice(rulesRouteChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLoadBalancerType.route_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["route_choice"] = vFn

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.max_len":   "256",
		"ves.io.schema.rules.repeated.items.string.min_len":   "1",
		"ves.io.schema.rules.repeated.items.string.vh_domain": "true",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.min_items":              "1",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HTTPLoadBalancerType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	v.FldValidators["loadbalancer_type.http"] = ves_io_schema_views_http_loadbalancer.ProxyTypeHttpValidator().Validate
	v.FldValidators["loadbalancer_type.https_auto_cert"] = ves_io_schema_views_http_loadbalancer.ProxyTypeHttpsAutoCertsValidator().Validate
	v.FldValidators["loadbalancer_type.https"] = ves_io_schema_views_http_loadbalancer.ProxyTypeHttpsValidator().Validate

	v.FldValidators["route_choice.default_route"] = MatchAllRouteTypeValidator().Validate
	v.FldValidators["route_choice.specific_routes"] = RouteTypeValidator().Validate

	return v
}()

func HTTPLoadBalancerTypeValidator() db.Validator {
	return DefaultHTTPLoadBalancerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HealthCheckType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HealthCheckType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HealthCheckType) DeepCopy() *HealthCheckType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HealthCheckType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HealthCheckType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HealthCheckType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HealthCheckTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHealthCheckType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHealthCheckType) HealthCheckChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for health_check_choice")
	}
	return validatorFn, nil
}

func (v *ValidateHealthCheckType) InitialDelayValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for initial_delay")
	}

	return validatorFn, nil
}

func (v *ValidateHealthCheckType) TimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for timeout")
	}

	return validatorFn, nil
}

func (v *ValidateHealthCheckType) IntervalValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interval")
	}

	return validatorFn, nil
}

func (v *ValidateHealthCheckType) HealthyThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for healthy_threshold")
	}

	return validatorFn, nil
}

func (v *ValidateHealthCheckType) UnhealthyThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for unhealthy_threshold")
	}

	return validatorFn, nil
}

func (v *ValidateHealthCheckType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HealthCheckType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HealthCheckType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["health_check_choice"]; exists {
		val := m.GetHealthCheckChoice()
		vOpts := append(opts,
			db.WithValidateField("health_check_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHealthCheckChoice().(type) {
	case *HealthCheckType_HttpHealthCheck:
		if fv, exists := v.FldValidators["health_check_choice.http_health_check"]; exists {
			val := m.GetHealthCheckChoice().(*HealthCheckType_HttpHealthCheck).HttpHealthCheck
			vOpts := append(opts,
				db.WithValidateField("health_check_choice"),
				db.WithValidateField("http_health_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HealthCheckType_TcpHealthCheck:
		if fv, exists := v.FldValidators["health_check_choice.tcp_health_check"]; exists {
			val := m.GetHealthCheckChoice().(*HealthCheckType_TcpHealthCheck).TcpHealthCheck
			vOpts := append(opts,
				db.WithValidateField("health_check_choice"),
				db.WithValidateField("tcp_health_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HealthCheckType_ExecHealthCheck:
		if fv, exists := v.FldValidators["health_check_choice.exec_health_check"]; exists {
			val := m.GetHealthCheckChoice().(*HealthCheckType_ExecHealthCheck).ExecHealthCheck
			vOpts := append(opts,
				db.WithValidateField("health_check_choice"),
				db.WithValidateField("exec_health_check"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["healthy_threshold"]; exists {

		vOpts := append(opts, db.WithValidateField("healthy_threshold"))
		if err := fv(ctx, m.GetHealthyThreshold(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["initial_delay"]; exists {

		vOpts := append(opts, db.WithValidateField("initial_delay"))
		if err := fv(ctx, m.GetInitialDelay(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interval"]; exists {

		vOpts := append(opts, db.WithValidateField("interval"))
		if err := fv(ctx, m.GetInterval(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("timeout"))
		if err := fv(ctx, m.GetTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unhealthy_threshold"]; exists {

		vOpts := append(opts, db.WithValidateField("unhealthy_threshold"))
		if err := fv(ctx, m.GetUnhealthyThreshold(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHealthCheckTypeValidator = func() *ValidateHealthCheckType {
	v := &ValidateHealthCheckType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHealthCheckChoice := v.HealthCheckChoiceValidationRuleHandler
	rulesHealthCheckChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHealthCheckChoice(rulesHealthCheckChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HealthCheckType.health_check_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["health_check_choice"] = vFn

	vrhInitialDelay := v.InitialDelayValidationRuleHandler
	rulesInitialDelay := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600",
	}
	vFn, err = vrhInitialDelay(rulesInitialDelay)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HealthCheckType.initial_delay: %s", err)
		panic(errMsg)
	}
	v.FldValidators["initial_delay"] = vFn

	vrhTimeout := v.TimeoutValidationRuleHandler
	rulesTimeout := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "600",
	}
	vFn, err = vrhTimeout(rulesTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HealthCheckType.timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["timeout"] = vFn

	vrhInterval := v.IntervalValidationRuleHandler
	rulesInterval := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "600",
	}
	vFn, err = vrhInterval(rulesInterval)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HealthCheckType.interval: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interval"] = vFn

	vrhHealthyThreshold := v.HealthyThresholdValidationRuleHandler
	rulesHealthyThreshold := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "16",
	}
	vFn, err = vrhHealthyThreshold(rulesHealthyThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HealthCheckType.healthy_threshold: %s", err)
		panic(errMsg)
	}
	v.FldValidators["healthy_threshold"] = vFn

	vrhUnhealthyThreshold := v.UnhealthyThresholdValidationRuleHandler
	rulesUnhealthyThreshold := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "16",
	}
	vFn, err = vrhUnhealthyThreshold(rulesUnhealthyThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HealthCheckType.unhealthy_threshold: %s", err)
		panic(errMsg)
	}
	v.FldValidators["unhealthy_threshold"] = vFn

	v.FldValidators["health_check_choice.http_health_check"] = HTTPHealthCheckTypeValidator().Validate
	v.FldValidators["health_check_choice.tcp_health_check"] = TCPHealthCheckTypeValidator().Validate
	v.FldValidators["health_check_choice.exec_health_check"] = ExecHealthCheckTypeValidator().Validate

	return v
}()

func HealthCheckTypeValidator() db.Validator {
	return DefaultHealthCheckTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HostPathVolumeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HostPathVolumeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HostPathVolumeType) DeepCopy() *HostPathVolumeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HostPathVolumeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HostPathVolumeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HostPathVolumeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HostPathVolumeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHostPathVolumeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHostPathVolumeType) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path")
	}

	return validatorFn, nil
}

func (v *ValidateHostPathVolumeType) MountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for mount")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := VolumeMountTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHostPathVolumeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HostPathVolumeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HostPathVolumeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mount"]; exists {

		vOpts := append(opts, db.WithValidateField("mount"))
		if err := fv(ctx, m.GetMount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHostPathVolumeTypeValidator = func() *ValidateHostPathVolumeType {
	v := &ValidateHostPathVolumeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.pattern":   "[^\\0]+",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HostPathVolumeType.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	vrhMount := v.MountValidationRuleHandler
	rulesMount := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMount(rulesMount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HostPathVolumeType.mount: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mount"] = vFn

	return v
}()

func HostPathVolumeTypeValidator() db.Validator {
	return DefaultHostPathVolumeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IPFamilyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPFamilyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPFamilyType) DeepCopy() *IPFamilyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPFamilyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPFamilyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPFamilyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPFamilyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateIPFamilyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPFamilyType) IpFamilyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_family_choice")
	}
	return validatorFn, nil
}

func (v *ValidateIPFamilyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPFamilyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPFamilyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_family_choice"]; exists {
		val := m.GetIpFamilyChoice()
		vOpts := append(opts,
			db.WithValidateField("ip_family_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetIpFamilyChoice().(type) {
	case *IPFamilyType_V4:
		if fv, exists := v.FldValidators["ip_family_choice.v4"]; exists {
			val := m.GetIpFamilyChoice().(*IPFamilyType_V4).V4
			vOpts := append(opts,
				db.WithValidateField("ip_family_choice"),
				db.WithValidateField("v4"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IPFamilyType_V6:
		if fv, exists := v.FldValidators["ip_family_choice.v6"]; exists {
			val := m.GetIpFamilyChoice().(*IPFamilyType_V6).V6
			vOpts := append(opts,
				db.WithValidateField("ip_family_choice"),
				db.WithValidateField("v6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IPFamilyType_DualV4Preferred:
		if fv, exists := v.FldValidators["ip_family_choice.dual_v4_preferred"]; exists {
			val := m.GetIpFamilyChoice().(*IPFamilyType_DualV4Preferred).DualV4Preferred
			vOpts := append(opts,
				db.WithValidateField("ip_family_choice"),
				db.WithValidateField("dual_v4_preferred"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IPFamilyType_DualV6Preferred:
		if fv, exists := v.FldValidators["ip_family_choice.dual_v6_preferred"]; exists {
			val := m.GetIpFamilyChoice().(*IPFamilyType_DualV6Preferred).DualV6Preferred
			vOpts := append(opts,
				db.WithValidateField("ip_family_choice"),
				db.WithValidateField("dual_v6_preferred"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPFamilyTypeValidator = func() *ValidateIPFamilyType {
	v := &ValidateIPFamilyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpFamilyChoice := v.IpFamilyChoiceValidationRuleHandler
	rulesIpFamilyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhIpFamilyChoice(rulesIpFamilyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPFamilyType.ip_family_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_family_choice"] = vFn

	return v
}()

func IPFamilyTypeValidator() db.Validator {
	return DefaultIPFamilyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ImageType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ImageType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ImageType) DeepCopy() *ImageType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ImageType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ImageType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ImageType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ImageTypeValidator().Validate(ctx, m, opts...)
}

func (m *ImageType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRegistryChoiceDRefInfo()

}

func (m *ImageType) GetRegistryChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetRegistryChoice().(type) {
	case *ImageType_Public:

		return nil, nil

	case *ImageType_ContainerRegistry:

		vref := m.GetContainerRegistry()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("container_registry.Object")
		dri := db.DRefInfo{
			RefdType:   "container_registry.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "container_registry",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetRegistryChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ImageType) GetRegistryChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetRegistryChoice().(type) {
	case *ImageType_Public:

	case *ImageType_ContainerRegistry:
		refdType, err := d.TypeForEntryKind("", "", "container_registry.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: container_registry")
		}

		vref := m.GetContainerRegistry()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "container_registry.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateImageType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateImageType) RegistryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for registry_choice")
	}
	return validatorFn, nil
}

func (v *ValidateImageType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateImageType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ImageType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ImageType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pull_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("pull_policy"))
		if err := fv(ctx, m.GetPullPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["registry_choice"]; exists {
		val := m.GetRegistryChoice()
		vOpts := append(opts,
			db.WithValidateField("registry_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRegistryChoice().(type) {
	case *ImageType_Public:
		if fv, exists := v.FldValidators["registry_choice.public"]; exists {
			val := m.GetRegistryChoice().(*ImageType_Public).Public
			vOpts := append(opts,
				db.WithValidateField("registry_choice"),
				db.WithValidateField("public"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ImageType_ContainerRegistry:
		if fv, exists := v.FldValidators["registry_choice.container_registry"]; exists {
			val := m.GetRegistryChoice().(*ImageType_ContainerRegistry).ContainerRegistry
			vOpts := append(opts,
				db.WithValidateField("registry_choice"),
				db.WithValidateField("container_registry"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultImageTypeValidator = func() *ValidateImageType {
	v := &ValidateImageType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRegistryChoice := v.RegistryChoiceValidationRuleHandler
	rulesRegistryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRegistryChoice(rulesRegistryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ImageType.registry_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["registry_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ImageType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["registry_choice.container_registry"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func ImageTypeValidator() db.Validator {
	return DefaultImageTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *JobType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JobType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JobType) DeepCopy() *JobType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JobType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JobType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JobType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JobTypeValidator().Validate(ctx, m, opts...)
}

func (m *JobType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetContainersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetContainersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDeployOptionsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDeployOptionsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *JobType) GetContainersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetContainers() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetContainers() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetContainers() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("containers[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *JobType) GetDeployOptionsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDeployOptions() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDeployOptions().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDeployOptions().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "deploy_options." + dri.DRField
	}
	return drInfos, err

}

type ValidateJobType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJobType) NumReplicasValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for num_replicas")
	}

	return validatorFn, nil
}

func (v *ValidateJobType) ContainersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for containers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ContainerType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ContainerTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for containers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ContainerType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ContainerType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated containers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items containers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJobType) VolumesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for volumes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*StorageVolumeType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := StorageVolumeTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for volumes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*StorageVolumeType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*StorageVolumeType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated volumes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items volumes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJobType) DeployOptionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for deploy_options")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := DeployOptionsTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJobType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JobType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JobType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("configuration"))
		if err := fv(ctx, m.GetConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["containers"]; exists {
		vOpts := append(opts, db.WithValidateField("containers"))
		if err := fv(ctx, m.GetContainers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deploy_options"]; exists {

		vOpts := append(opts, db.WithValidateField("deploy_options"))
		if err := fv(ctx, m.GetDeployOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["num_replicas"]; exists {

		vOpts := append(opts, db.WithValidateField("num_replicas"))
		if err := fv(ctx, m.GetNumReplicas(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volumes"]; exists {
		vOpts := append(opts, db.WithValidateField("volumes"))
		if err := fv(ctx, m.GetVolumes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJobTypeValidator = func() *ValidateJobType {
	v := &ValidateJobType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNumReplicas := v.NumReplicasValidationRuleHandler
	rulesNumReplicas := map[string]string{
		"ves.io.schema.rules.int32.lte": "5",
	}
	vFn, err = vrhNumReplicas(rulesNumReplicas)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JobType.num_replicas: %s", err)
		panic(errMsg)
	}
	v.FldValidators["num_replicas"] = vFn

	vrhContainers := v.ContainersValidationRuleHandler
	rulesContainers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhContainers(rulesContainers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JobType.containers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["containers"] = vFn

	vrhVolumes := v.VolumesValidationRuleHandler
	rulesVolumes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhVolumes(rulesVolumes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JobType.volumes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volumes"] = vFn

	vrhDeployOptions := v.DeployOptionsValidationRuleHandler
	rulesDeployOptions := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDeployOptions(rulesDeployOptions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JobType.deploy_options: %s", err)
		panic(errMsg)
	}
	v.FldValidators["deploy_options"] = vFn

	v.FldValidators["configuration"] = ConfigurationParametersTypeValidator().Validate

	return v
}()

func JobTypeValidator() db.Validator {
	return DefaultJobTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MatchAllRouteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MatchAllRouteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MatchAllRouteType) DeepCopy() *MatchAllRouteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MatchAllRouteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MatchAllRouteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MatchAllRouteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MatchAllRouteTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMatchAllRouteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMatchAllRouteType) HostRewriteParamsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for host_rewrite_params")
	}
	return validatorFn, nil
}

func (v *ValidateMatchAllRouteType) HostRewriteParamsHostRewriteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_HostRewrite, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for host_rewrite")
	}
	return oValidatorFn_HostRewrite, nil
}

func (v *ValidateMatchAllRouteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MatchAllRouteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MatchAllRouteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["host_rewrite_params"]; exists {
		val := m.GetHostRewriteParams()
		vOpts := append(opts,
			db.WithValidateField("host_rewrite_params"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHostRewriteParams().(type) {
	case *MatchAllRouteType_AutoHostRewrite:
		if fv, exists := v.FldValidators["host_rewrite_params.auto_host_rewrite"]; exists {
			val := m.GetHostRewriteParams().(*MatchAllRouteType_AutoHostRewrite).AutoHostRewrite
			vOpts := append(opts,
				db.WithValidateField("host_rewrite_params"),
				db.WithValidateField("auto_host_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatchAllRouteType_HostRewrite:
		if fv, exists := v.FldValidators["host_rewrite_params.host_rewrite"]; exists {
			val := m.GetHostRewriteParams().(*MatchAllRouteType_HostRewrite).HostRewrite
			vOpts := append(opts,
				db.WithValidateField("host_rewrite_params"),
				db.WithValidateField("host_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *MatchAllRouteType_DisableHostRewrite:
		if fv, exists := v.FldValidators["host_rewrite_params.disable_host_rewrite"]; exists {
			val := m.GetHostRewriteParams().(*MatchAllRouteType_DisableHostRewrite).DisableHostRewrite
			vOpts := append(opts,
				db.WithValidateField("host_rewrite_params"),
				db.WithValidateField("disable_host_rewrite"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMatchAllRouteTypeValidator = func() *ValidateMatchAllRouteType {
	v := &ValidateMatchAllRouteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHostRewriteParams := v.HostRewriteParamsValidationRuleHandler
	rulesHostRewriteParams := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHostRewriteParams(rulesHostRewriteParams)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MatchAllRouteType.host_rewrite_params: %s", err)
		panic(errMsg)
	}
	v.FldValidators["host_rewrite_params"] = vFn

	vrhHostRewriteParamsHostRewrite := v.HostRewriteParamsHostRewriteValidationRuleHandler
	rulesHostRewriteParamsHostRewrite := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFnMap["host_rewrite_params.host_rewrite"], err = vrhHostRewriteParamsHostRewrite(rulesHostRewriteParamsHostRewrite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field MatchAllRouteType.host_rewrite_params_host_rewrite: %s", err)
		panic(errMsg)
	}

	v.FldValidators["host_rewrite_params.host_rewrite"] = vFnMap["host_rewrite_params.host_rewrite"]

	return v
}()

func MatchAllRouteTypeValidator() db.Validator {
	return DefaultMatchAllRouteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MultiPortType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MultiPortType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MultiPortType) DeepCopy() *MultiPortType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MultiPortType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MultiPortType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MultiPortType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MultiPortTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMultiPortType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMultiPortType) PortsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for ports")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*PortType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := PortTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ports")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*PortType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*PortType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ports")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ports")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMultiPortType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MultiPortType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MultiPortType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ports"]; exists {
		vOpts := append(opts, db.WithValidateField("ports"))
		if err := fv(ctx, m.GetPorts(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMultiPortTypeValidator = func() *ValidateMultiPortType {
	v := &ValidateMultiPortType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPorts := v.PortsValidationRuleHandler
	rulesPorts := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhPorts(rulesPorts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MultiPortType.ports: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ports"] = vFn

	return v
}()

func MultiPortTypeValidator() db.Validator {
	return DefaultMultiPortTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PersistentStorageType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PersistentStorageType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PersistentStorageType) DeepCopy() *PersistentStorageType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PersistentStorageType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PersistentStorageType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PersistentStorageType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PersistentStorageTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePersistentStorageType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePersistentStorageType) ClassNameChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for class_name_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePersistentStorageType) ClassNameChoiceClassNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ClassName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for class_name")
	}
	return oValidatorFn_ClassName, nil
}

func (v *ValidatePersistentStorageType) StorageSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewDoubleValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for storage_size")
	}

	return validatorFn, nil
}

func (v *ValidatePersistentStorageType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PersistentStorageType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PersistentStorageType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["access_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("access_mode"))
		if err := fv(ctx, m.GetAccessMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["class_name_choice"]; exists {
		val := m.GetClassNameChoice()
		vOpts := append(opts,
			db.WithValidateField("class_name_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClassNameChoice().(type) {
	case *PersistentStorageType_Default:
		if fv, exists := v.FldValidators["class_name_choice.default"]; exists {
			val := m.GetClassNameChoice().(*PersistentStorageType_Default).Default
			vOpts := append(opts,
				db.WithValidateField("class_name_choice"),
				db.WithValidateField("default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PersistentStorageType_ClassName:
		if fv, exists := v.FldValidators["class_name_choice.class_name"]; exists {
			val := m.GetClassNameChoice().(*PersistentStorageType_ClassName).ClassName
			vOpts := append(opts,
				db.WithValidateField("class_name_choice"),
				db.WithValidateField("class_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["storage_size"]; exists {

		vOpts := append(opts, db.WithValidateField("storage_size"))
		if err := fv(ctx, m.GetStorageSize(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPersistentStorageTypeValidator = func() *ValidatePersistentStorageType {
	v := &ValidatePersistentStorageType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClassNameChoice := v.ClassNameChoiceValidationRuleHandler
	rulesClassNameChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClassNameChoice(rulesClassNameChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PersistentStorageType.class_name_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["class_name_choice"] = vFn

	vrhClassNameChoiceClassName := v.ClassNameChoiceClassNameValidationRuleHandler
	rulesClassNameChoiceClassName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFnMap["class_name_choice.class_name"], err = vrhClassNameChoiceClassName(rulesClassNameChoiceClassName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PersistentStorageType.class_name_choice_class_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["class_name_choice.class_name"] = vFnMap["class_name_choice.class_name"]

	vrhStorageSize := v.StorageSizeValidationRuleHandler
	rulesStorageSize := map[string]string{
		"ves.io.schema.rules.double.gte":       "0.004",
		"ves.io.schema.rules.double.lte":       "256",
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStorageSize(rulesStorageSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PersistentStorageType.storage_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage_size"] = vFn

	return v
}()

func PersistentStorageTypeValidator() db.Validator {
	return DefaultPersistentStorageTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PersistentStorageVolumeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PersistentStorageVolumeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PersistentStorageVolumeType) DeepCopy() *PersistentStorageVolumeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PersistentStorageVolumeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PersistentStorageVolumeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PersistentStorageVolumeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PersistentStorageVolumeTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePersistentStorageVolumeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePersistentStorageVolumeType) StorageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for storage")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := PersistentStorageTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePersistentStorageVolumeType) MountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for mount")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := VolumeMountTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePersistentStorageVolumeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PersistentStorageVolumeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PersistentStorageVolumeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mount"]; exists {

		vOpts := append(opts, db.WithValidateField("mount"))
		if err := fv(ctx, m.GetMount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage"]; exists {

		vOpts := append(opts, db.WithValidateField("storage"))
		if err := fv(ctx, m.GetStorage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPersistentStorageVolumeTypeValidator = func() *ValidatePersistentStorageVolumeType {
	v := &ValidatePersistentStorageVolumeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStorage := v.StorageValidationRuleHandler
	rulesStorage := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStorage(rulesStorage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PersistentStorageVolumeType.storage: %s", err)
		panic(errMsg)
	}
	v.FldValidators["storage"] = vFn

	vrhMount := v.MountValidationRuleHandler
	rulesMount := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMount(rulesMount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PersistentStorageVolumeType.mount: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mount"] = vFn

	return v
}()

func PersistentStorageVolumeTypeValidator() db.Validator {
	return DefaultPersistentStorageVolumeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PersistentVolumeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PersistentVolumeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PersistentVolumeType) DeepCopy() *PersistentVolumeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PersistentVolumeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PersistentVolumeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PersistentVolumeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PersistentVolumeTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePersistentVolumeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePersistentVolumeType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidatePersistentVolumeType) PersistentVolumeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for persistent_volume")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := PersistentStorageVolumeTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePersistentVolumeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PersistentVolumeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PersistentVolumeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["persistent_volume"]; exists {

		vOpts := append(opts, db.WithValidateField("persistent_volume"))
		if err := fv(ctx, m.GetPersistentVolume(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPersistentVolumeTypeValidator = func() *ValidatePersistentVolumeType {
	v := &ValidatePersistentVolumeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":      "true",
		"ves.io.schema.rules.string.dns_1123_label": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PersistentVolumeType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhPersistentVolume := v.PersistentVolumeValidationRuleHandler
	rulesPersistentVolume := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPersistentVolume(rulesPersistentVolume)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PersistentVolumeType.persistent_volume: %s", err)
		panic(errMsg)
	}
	v.FldValidators["persistent_volume"] = vFn

	return v
}()

func PersistentVolumeTypeValidator() db.Validator {
	return DefaultPersistentVolumeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortChoiceType) DeepCopy() *PortChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortChoiceType) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePortChoiceType) PortChoiceNumValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Num, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for num")
	}
	return oValidatorFn_Num, nil
}
func (v *ValidatePortChoiceType) PortChoiceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Name, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}
	return oValidatorFn_Name, nil
}

func (v *ValidatePortChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *PortChoiceType_Num:
		if fv, exists := v.FldValidators["port_choice.num"]; exists {
			val := m.GetPortChoice().(*PortChoiceType_Num).Num
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("num"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PortChoiceType_Name:
		if fv, exists := v.FldValidators["port_choice.name"]; exists {
			val := m.GetPortChoice().(*PortChoiceType_Name).Name
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortChoiceTypeValidator = func() *ValidatePortChoiceType {
	v := &ValidatePortChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortChoiceType.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoiceNum := v.PortChoiceNumValidationRuleHandler
	rulesPortChoiceNum := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.num"], err = vrhPortChoiceNum(rulesPortChoiceNum)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PortChoiceType.port_choice_num: %s", err)
		panic(errMsg)
	}
	vrhPortChoiceName := v.PortChoiceNameValidationRuleHandler
	rulesPortChoiceName := map[string]string{
		"ves.io.schema.rules.string.iana_svc_name": "true",
	}
	vFnMap["port_choice.name"], err = vrhPortChoiceName(rulesPortChoiceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PortChoiceType.port_choice_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.num"] = vFnMap["port_choice.num"]
	v.FldValidators["port_choice.name"] = vFnMap["port_choice.name"]

	return v
}()

func PortChoiceTypeValidator() db.Validator {
	return DefaultPortChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortInfoType) DeepCopy() *PortInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortInfoType) TargetPortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for target_port_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePortInfoType) TargetPortChoiceTargetPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_TargetPort, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for target_port")
	}
	return oValidatorFn_TargetPort, nil
}

func (v *ValidatePortInfoType) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}

	return validatorFn, nil
}

func (v *ValidatePortInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol"))
		if err := fv(ctx, m.GetProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["target_port_choice"]; exists {
		val := m.GetTargetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("target_port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTargetPortChoice().(type) {
	case *PortInfoType_SameAsPort:
		if fv, exists := v.FldValidators["target_port_choice.same_as_port"]; exists {
			val := m.GetTargetPortChoice().(*PortInfoType_SameAsPort).SameAsPort
			vOpts := append(opts,
				db.WithValidateField("target_port_choice"),
				db.WithValidateField("same_as_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PortInfoType_TargetPort:
		if fv, exists := v.FldValidators["target_port_choice.target_port"]; exists {
			val := m.GetTargetPortChoice().(*PortInfoType_TargetPort).TargetPort
			vOpts := append(opts,
				db.WithValidateField("target_port_choice"),
				db.WithValidateField("target_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortInfoTypeValidator = func() *ValidatePortInfoType {
	v := &ValidatePortInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTargetPortChoice := v.TargetPortChoiceValidationRuleHandler
	rulesTargetPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTargetPortChoice(rulesTargetPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortInfoType.target_port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["target_port_choice"] = vFn

	vrhTargetPortChoiceTargetPort := v.TargetPortChoiceTargetPortValidationRuleHandler
	rulesTargetPortChoiceTargetPort := map[string]string{
		"ves.io.schema.rules.uint32.gt":  "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["target_port_choice.target_port"], err = vrhTargetPortChoiceTargetPort(rulesTargetPortChoiceTargetPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field PortInfoType.target_port_choice_target_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["target_port_choice.target_port"] = vFnMap["target_port_choice.target_port"]

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gt":        "0",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortInfoType.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	return v
}()

func PortInfoTypeValidator() db.Validator {
	return DefaultPortInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PortType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PortType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PortType) DeepCopy() *PortType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PortType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PortType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PortType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PortTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePortType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePortType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidatePortType) InfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := PortInfoTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePortType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PortType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PortType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["info"]; exists {

		vOpts := append(opts, db.WithValidateField("info"))
		if err := fv(ctx, m.GetInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPortTypeValidator = func() *ValidatePortType {
	v := &ValidatePortType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required":     "true",
		"ves.io.schema.rules.string.iana_svc_name": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhInfo := v.InfoValidationRuleHandler
	rulesInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInfo(rulesInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PortType.info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["info"] = vFn

	return v
}()

func PortTypeValidator() db.Validator {
	return DefaultPortTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.service")
	}

	if err := m.GetStatefulService().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.stateful_service")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWorkloadChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetWorkloadChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetWorkloadChoice() == nil {
		return nil, nil
	}
	switch m.GetWorkloadChoice().(type) {
	case *ReplaceSpecType_SimpleService:

		drInfos, err := m.GetSimpleService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSimpleService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "simple_service." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Service:

		drInfos, err := m.GetService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "service." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_StatefulService:

		drInfos, err := m.GetStatefulService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStatefulService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "stateful_service." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Job:

		drInfos, err := m.GetJob().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetJob().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "job." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) WorkloadChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for workload_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["workload_choice"]; exists {
		val := m.GetWorkloadChoice()
		vOpts := append(opts,
			db.WithValidateField("workload_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWorkloadChoice().(type) {
	case *ReplaceSpecType_SimpleService:
		if fv, exists := v.FldValidators["workload_choice.simple_service"]; exists {
			val := m.GetWorkloadChoice().(*ReplaceSpecType_SimpleService).SimpleService
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("simple_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Service:
		if fv, exists := v.FldValidators["workload_choice.service"]; exists {
			val := m.GetWorkloadChoice().(*ReplaceSpecType_Service).Service
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_StatefulService:
		if fv, exists := v.FldValidators["workload_choice.stateful_service"]; exists {
			val := m.GetWorkloadChoice().(*ReplaceSpecType_StatefulService).StatefulService
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("stateful_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Job:
		if fv, exists := v.FldValidators["workload_choice.job"]; exists {
			val := m.GetWorkloadChoice().(*ReplaceSpecType_Job).Job
			vOpts := append(opts,
				db.WithValidateField("workload_choice"),
				db.WithValidateField("job"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhWorkloadChoice := v.WorkloadChoiceValidationRuleHandler
	rulesWorkloadChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWorkloadChoice(rulesWorkloadChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.workload_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["workload_choice"] = vFn

	v.FldValidators["workload_choice.simple_service"] = SimpleServiceTypeValidator().Validate
	v.FldValidators["workload_choice.service"] = ServiceTypeValidator().Validate
	v.FldValidators["workload_choice.stateful_service"] = StatefulServiceTypeValidator().Validate
	v.FldValidators["workload_choice.job"] = JobTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteInfoType) DeepCopy() *RouteInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteInfoTypeValidator().Validate(ctx, m, opts...)
}

func (m *RouteInfoType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *RouteInfoType) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetChoice() == nil {
		return nil, nil
	}
	switch m.GetChoice().(type) {
	case *RouteInfoType_SimpleRoute:

		return nil, nil

	case *RouteInfoType_RedirectRoute:

		return nil, nil

	case *RouteInfoType_DirectResponseRoute:

		return nil, nil

	case *RouteInfoType_CustomRouteObject:

		drInfos, err := m.GetCustomRouteObject().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCustomRouteObject().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "custom_route_object." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateRouteInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteInfoType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateRouteInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *RouteInfoType_SimpleRoute:
		if fv, exists := v.FldValidators["choice.simple_route"]; exists {
			val := m.GetChoice().(*RouteInfoType_SimpleRoute).SimpleRoute
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("simple_route"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteInfoType_RedirectRoute:
		if fv, exists := v.FldValidators["choice.redirect_route"]; exists {
			val := m.GetChoice().(*RouteInfoType_RedirectRoute).RedirectRoute
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("redirect_route"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteInfoType_DirectResponseRoute:
		if fv, exists := v.FldValidators["choice.direct_response_route"]; exists {
			val := m.GetChoice().(*RouteInfoType_DirectResponseRoute).DirectResponseRoute
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("direct_response_route"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RouteInfoType_CustomRouteObject:
		if fv, exists := v.FldValidators["choice.custom_route_object"]; exists {
			val := m.GetChoice().(*RouteInfoType_CustomRouteObject).CustomRouteObject
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("custom_route_object"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteInfoTypeValidator = func() *ValidateRouteInfoType {
	v := &ValidateRouteInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteInfoType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.simple_route"] = ves_io_schema_views_http_loadbalancer.RouteTypeSimpleWithDefaultOriginPoolValidator().Validate
	v.FldValidators["choice.redirect_route"] = ves_io_schema_views_http_loadbalancer.RouteTypeRedirectValidator().Validate
	v.FldValidators["choice.direct_response_route"] = ves_io_schema_views_http_loadbalancer.RouteTypeDirectResponseValidator().Validate
	v.FldValidators["choice.custom_route_object"] = ves_io_schema_views_http_loadbalancer.RouteTypeCustomRouteValidator().Validate

	return v
}()

func RouteInfoTypeValidator() db.Validator {
	return DefaultRouteInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteType) DeepCopy() *RouteType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteTypeValidator().Validate(ctx, m, opts...)
}

func (m *RouteType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRoutesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *RouteType) GetRoutesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRoutes() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetRoutes() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRoutes() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("routes[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateRouteType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteType) RoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*RouteInfoType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := RouteInfoTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*RouteInfoType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*RouteInfoType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRouteType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["routes"]; exists {
		vOpts := append(opts, db.WithValidateField("routes"))
		if err := fv(ctx, m.GetRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteTypeValidator = func() *ValidateRouteType {
	v := &ValidateRouteType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutes := v.RoutesValidationRuleHandler
	rulesRoutes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhRoutes(rulesRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RouteType.routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routes"] = vFn

	return v
}()

func RouteTypeValidator() db.Validator {
	return DefaultRouteTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ServiceType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdvertiseOptions().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ServiceType.advertise_options")
	}

	return nil
}

func (m *ServiceType) DeepCopy() *ServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceTypeValidator().Validate(ctx, m, opts...)
}

func (m *ServiceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertiseOptionsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertiseOptionsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetContainersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetContainersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDeployOptionsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDeployOptionsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ServiceType) GetAdvertiseOptionsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseOptions() == nil {
		return nil, nil
	}

	drInfos, err := m.GetAdvertiseOptions().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetAdvertiseOptions().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "advertise_options." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ServiceType) GetContainersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetContainers() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetContainers() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetContainers() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("containers[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ServiceType) GetDeployOptionsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDeployOptions() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDeployOptions().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDeployOptions().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "deploy_options." + dri.DRField
	}
	return drInfos, err

}

type ValidateServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceType) ScalingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for scaling_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServiceType) ScalingChoiceNumReplicasValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NumReplicas, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for num_replicas")
	}
	return oValidatorFn_NumReplicas, nil
}

func (v *ValidateServiceType) ContainersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for containers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ContainerType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ContainerTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for containers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ContainerType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ContainerType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated containers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items containers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceType) VolumesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for volumes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*StorageVolumeType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := StorageVolumeTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for volumes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*StorageVolumeType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*StorageVolumeType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated volumes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items volumes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceType) DeployOptionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for deploy_options")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := DeployOptionsTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceType) AdvertiseOptionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for advertise_options")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := AdvertiseOptionsTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_options"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_options"))
		if err := fv(ctx, m.GetAdvertiseOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("configuration"))
		if err := fv(ctx, m.GetConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["containers"]; exists {
		vOpts := append(opts, db.WithValidateField("containers"))
		if err := fv(ctx, m.GetContainers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deploy_options"]; exists {

		vOpts := append(opts, db.WithValidateField("deploy_options"))
		if err := fv(ctx, m.GetDeployOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["family"]; exists {

		vOpts := append(opts, db.WithValidateField("family"))
		if err := fv(ctx, m.GetFamily(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scaling_choice"]; exists {
		val := m.GetScalingChoice()
		vOpts := append(opts,
			db.WithValidateField("scaling_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetScalingChoice().(type) {
	case *ServiceType_NumReplicas:
		if fv, exists := v.FldValidators["scaling_choice.num_replicas"]; exists {
			val := m.GetScalingChoice().(*ServiceType_NumReplicas).NumReplicas
			vOpts := append(opts,
				db.WithValidateField("scaling_choice"),
				db.WithValidateField("num_replicas"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServiceType_ScaleToZero:
		if fv, exists := v.FldValidators["scaling_choice.scale_to_zero"]; exists {
			val := m.GetScalingChoice().(*ServiceType_ScaleToZero).ScaleToZero
			vOpts := append(opts,
				db.WithValidateField("scaling_choice"),
				db.WithValidateField("scale_to_zero"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volumes"]; exists {
		vOpts := append(opts, db.WithValidateField("volumes"))
		if err := fv(ctx, m.GetVolumes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceTypeValidator = func() *ValidateServiceType {
	v := &ValidateServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhScalingChoice := v.ScalingChoiceValidationRuleHandler
	rulesScalingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhScalingChoice(rulesScalingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceType.scaling_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["scaling_choice"] = vFn

	vrhScalingChoiceNumReplicas := v.ScalingChoiceNumReplicasValidationRuleHandler
	rulesScalingChoiceNumReplicas := map[string]string{
		"ves.io.schema.rules.int32.gt":  "0",
		"ves.io.schema.rules.int32.lte": "5",
	}
	vFnMap["scaling_choice.num_replicas"], err = vrhScalingChoiceNumReplicas(rulesScalingChoiceNumReplicas)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServiceType.scaling_choice_num_replicas: %s", err)
		panic(errMsg)
	}

	v.FldValidators["scaling_choice.num_replicas"] = vFnMap["scaling_choice.num_replicas"]

	vrhContainers := v.ContainersValidationRuleHandler
	rulesContainers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhContainers(rulesContainers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceType.containers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["containers"] = vFn

	vrhVolumes := v.VolumesValidationRuleHandler
	rulesVolumes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhVolumes(rulesVolumes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceType.volumes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volumes"] = vFn

	vrhDeployOptions := v.DeployOptionsValidationRuleHandler
	rulesDeployOptions := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDeployOptions(rulesDeployOptions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceType.deploy_options: %s", err)
		panic(errMsg)
	}
	v.FldValidators["deploy_options"] = vFn

	vrhAdvertiseOptions := v.AdvertiseOptionsValidationRuleHandler
	rulesAdvertiseOptions := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAdvertiseOptions(rulesAdvertiseOptions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceType.advertise_options: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_options"] = vFn

	v.FldValidators["configuration"] = ConfigurationParametersTypeValidator().Validate

	v.FldValidators["family"] = IPFamilyTypeValidator().Validate

	return v
}()

func ServiceTypeValidator() db.Validator {
	return DefaultServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SimpleServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SimpleServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SimpleServiceType) DeepCopy() *SimpleServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SimpleServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SimpleServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SimpleServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SimpleServiceTypeValidator().Validate(ctx, m, opts...)
}

func (m *SimpleServiceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetContainerDRefInfo()

}

// GetDRefInfo for the field's type
func (m *SimpleServiceType) GetContainerDRefInfo() ([]db.DRefInfo, error) {
	if m.GetContainer() == nil {
		return nil, nil
	}

	drInfos, err := m.GetContainer().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetContainer().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "container." + dri.DRField
	}
	return drInfos, err

}

type ValidateSimpleServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSimpleServiceType) AdvertiseChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for advertise_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleServiceType) AdvertiseChoiceServicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServicePort, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_port")
	}
	return oValidatorFn_ServicePort, nil
}

func (v *ValidateSimpleServiceType) PersistenceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for persistence_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleServiceType) ContainerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for container")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ContainerTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SimpleServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SimpleServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_choice"]; exists {
		val := m.GetAdvertiseChoice()
		vOpts := append(opts,
			db.WithValidateField("advertise_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdvertiseChoice().(type) {
	case *SimpleServiceType_DoNotAdvertise:
		if fv, exists := v.FldValidators["advertise_choice.do_not_advertise"]; exists {
			val := m.GetAdvertiseChoice().(*SimpleServiceType_DoNotAdvertise).DoNotAdvertise
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("do_not_advertise"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleServiceType_ServicePort:
		if fv, exists := v.FldValidators["advertise_choice.service_port"]; exists {
			val := m.GetAdvertiseChoice().(*SimpleServiceType_ServicePort).ServicePort
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("service_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleServiceType_SimpleAdvertise:
		if fv, exists := v.FldValidators["advertise_choice.simple_advertise"]; exists {
			val := m.GetAdvertiseChoice().(*SimpleServiceType_SimpleAdvertise).SimpleAdvertise
			vOpts := append(opts,
				db.WithValidateField("advertise_choice"),
				db.WithValidateField("simple_advertise"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("configuration"))
		if err := fv(ctx, m.GetConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["container"]; exists {

		vOpts := append(opts, db.WithValidateField("container"))
		if err := fv(ctx, m.GetContainer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["persistence_choice"]; exists {
		val := m.GetPersistenceChoice()
		vOpts := append(opts,
			db.WithValidateField("persistence_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPersistenceChoice().(type) {
	case *SimpleServiceType_Disabled:
		if fv, exists := v.FldValidators["persistence_choice.disabled"]; exists {
			val := m.GetPersistenceChoice().(*SimpleServiceType_Disabled).Disabled
			vOpts := append(opts,
				db.WithValidateField("persistence_choice"),
				db.WithValidateField("disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleServiceType_Enabled:
		if fv, exists := v.FldValidators["persistence_choice.enabled"]; exists {
			val := m.GetPersistenceChoice().(*SimpleServiceType_Enabled).Enabled
			vOpts := append(opts,
				db.WithValidateField("persistence_choice"),
				db.WithValidateField("enabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["scale_to_zero"]; exists {

		vOpts := append(opts, db.WithValidateField("scale_to_zero"))
		if err := fv(ctx, m.GetScaleToZero(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSimpleServiceTypeValidator = func() *ValidateSimpleServiceType {
	v := &ValidateSimpleServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdvertiseChoice := v.AdvertiseChoiceValidationRuleHandler
	rulesAdvertiseChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdvertiseChoice(rulesAdvertiseChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleServiceType.advertise_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_choice"] = vFn

	vrhAdvertiseChoiceServicePort := v.AdvertiseChoiceServicePortValidationRuleHandler
	rulesAdvertiseChoiceServicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1024",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["advertise_choice.service_port"], err = vrhAdvertiseChoiceServicePort(rulesAdvertiseChoiceServicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleServiceType.advertise_choice_service_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["advertise_choice.service_port"] = vFnMap["advertise_choice.service_port"]

	vrhPersistenceChoice := v.PersistenceChoiceValidationRuleHandler
	rulesPersistenceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPersistenceChoice(rulesPersistenceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleServiceType.persistence_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["persistence_choice"] = vFn

	vrhContainer := v.ContainerValidationRuleHandler
	rulesContainer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhContainer(rulesContainer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleServiceType.container: %s", err)
		panic(errMsg)
	}
	v.FldValidators["container"] = vFn

	v.FldValidators["advertise_choice.simple_advertise"] = AdvertiseSimpleServiceTypeValidator().Validate

	v.FldValidators["persistence_choice.enabled"] = PersistentVolumeTypeValidator().Validate

	v.FldValidators["configuration"] = ConfigurationParametersTypeValidator().Validate

	return v
}()

func SimpleServiceTypeValidator() db.Validator {
	return DefaultSimpleServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SinglePortType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SinglePortType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SinglePortType) DeepCopy() *SinglePortType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SinglePortType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SinglePortType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SinglePortType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SinglePortTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSinglePortType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSinglePortType) InfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for info")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := PortInfoTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSinglePortType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SinglePortType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SinglePortType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["info"]; exists {

		vOpts := append(opts, db.WithValidateField("info"))
		if err := fv(ctx, m.GetInfo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSinglePortTypeValidator = func() *ValidateSinglePortType {
	v := &ValidateSinglePortType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInfo := v.InfoValidationRuleHandler
	rulesInfo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInfo(rulesInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SinglePortType.info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["info"] = vFn

	return v
}()

func SinglePortTypeValidator() db.Validator {
	return DefaultSinglePortTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StatefulServiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StatefulServiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *StatefulServiceType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdvertiseOptions().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting StatefulServiceType.advertise_options")
	}

	return nil
}

func (m *StatefulServiceType) DeepCopy() *StatefulServiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StatefulServiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StatefulServiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StatefulServiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StatefulServiceTypeValidator().Validate(ctx, m, opts...)
}

func (m *StatefulServiceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAdvertiseOptionsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAdvertiseOptionsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetContainersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetContainersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDeployOptionsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDeployOptionsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *StatefulServiceType) GetAdvertiseOptionsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAdvertiseOptions() == nil {
		return nil, nil
	}

	drInfos, err := m.GetAdvertiseOptions().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetAdvertiseOptions().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "advertise_options." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *StatefulServiceType) GetContainersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetContainers() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetContainers() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetContainers() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("containers[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *StatefulServiceType) GetDeployOptionsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDeployOptions() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDeployOptions().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDeployOptions().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "deploy_options." + dri.DRField
	}
	return drInfos, err

}

type ValidateStatefulServiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStatefulServiceType) ScalingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for scaling_choice")
	}
	return validatorFn, nil
}

func (v *ValidateStatefulServiceType) ScalingChoiceNumReplicasValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NumReplicas, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for num_replicas")
	}
	return oValidatorFn_NumReplicas, nil
}

func (v *ValidateStatefulServiceType) ContainersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for containers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ContainerType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ContainerTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for containers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ContainerType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ContainerType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated containers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items containers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStatefulServiceType) PersistentVolumesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for persistent_volumes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*PersistentVolumeType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := PersistentVolumeTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for persistent_volumes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*PersistentVolumeType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*PersistentVolumeType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated persistent_volumes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items persistent_volumes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStatefulServiceType) VolumesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for volumes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*EphemeralStorageVolumeType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := EphemeralStorageVolumeTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for volumes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*EphemeralStorageVolumeType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*EphemeralStorageVolumeType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated volumes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items volumes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStatefulServiceType) DeployOptionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for deploy_options")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := DeployOptionsTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStatefulServiceType) AdvertiseOptionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for advertise_options")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := AdvertiseOptionsTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStatefulServiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StatefulServiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StatefulServiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advertise_options"]; exists {

		vOpts := append(opts, db.WithValidateField("advertise_options"))
		if err := fv(ctx, m.GetAdvertiseOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("configuration"))
		if err := fv(ctx, m.GetConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["containers"]; exists {
		vOpts := append(opts, db.WithValidateField("containers"))
		if err := fv(ctx, m.GetContainers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deploy_options"]; exists {

		vOpts := append(opts, db.WithValidateField("deploy_options"))
		if err := fv(ctx, m.GetDeployOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["family"]; exists {

		vOpts := append(opts, db.WithValidateField("family"))
		if err := fv(ctx, m.GetFamily(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["persistent_volumes"]; exists {
		vOpts := append(opts, db.WithValidateField("persistent_volumes"))
		if err := fv(ctx, m.GetPersistentVolumes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scaling_choice"]; exists {
		val := m.GetScalingChoice()
		vOpts := append(opts,
			db.WithValidateField("scaling_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetScalingChoice().(type) {
	case *StatefulServiceType_NumReplicas:
		if fv, exists := v.FldValidators["scaling_choice.num_replicas"]; exists {
			val := m.GetScalingChoice().(*StatefulServiceType_NumReplicas).NumReplicas
			vOpts := append(opts,
				db.WithValidateField("scaling_choice"),
				db.WithValidateField("num_replicas"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StatefulServiceType_ScaleToZero:
		if fv, exists := v.FldValidators["scaling_choice.scale_to_zero"]; exists {
			val := m.GetScalingChoice().(*StatefulServiceType_ScaleToZero).ScaleToZero
			vOpts := append(opts,
				db.WithValidateField("scaling_choice"),
				db.WithValidateField("scale_to_zero"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volumes"]; exists {
		vOpts := append(opts, db.WithValidateField("volumes"))
		if err := fv(ctx, m.GetVolumes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStatefulServiceTypeValidator = func() *ValidateStatefulServiceType {
	v := &ValidateStatefulServiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhScalingChoice := v.ScalingChoiceValidationRuleHandler
	rulesScalingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhScalingChoice(rulesScalingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StatefulServiceType.scaling_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["scaling_choice"] = vFn

	vrhScalingChoiceNumReplicas := v.ScalingChoiceNumReplicasValidationRuleHandler
	rulesScalingChoiceNumReplicas := map[string]string{
		"ves.io.schema.rules.int32.gt":  "0",
		"ves.io.schema.rules.int32.lte": "5",
	}
	vFnMap["scaling_choice.num_replicas"], err = vrhScalingChoiceNumReplicas(rulesScalingChoiceNumReplicas)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field StatefulServiceType.scaling_choice_num_replicas: %s", err)
		panic(errMsg)
	}

	v.FldValidators["scaling_choice.num_replicas"] = vFnMap["scaling_choice.num_replicas"]

	vrhContainers := v.ContainersValidationRuleHandler
	rulesContainers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhContainers(rulesContainers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StatefulServiceType.containers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["containers"] = vFn

	vrhPersistentVolumes := v.PersistentVolumesValidationRuleHandler
	rulesPersistentVolumes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhPersistentVolumes(rulesPersistentVolumes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StatefulServiceType.persistent_volumes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["persistent_volumes"] = vFn

	vrhVolumes := v.VolumesValidationRuleHandler
	rulesVolumes := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhVolumes(rulesVolumes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StatefulServiceType.volumes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volumes"] = vFn

	vrhDeployOptions := v.DeployOptionsValidationRuleHandler
	rulesDeployOptions := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDeployOptions(rulesDeployOptions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StatefulServiceType.deploy_options: %s", err)
		panic(errMsg)
	}
	v.FldValidators["deploy_options"] = vFn

	vrhAdvertiseOptions := v.AdvertiseOptionsValidationRuleHandler
	rulesAdvertiseOptions := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAdvertiseOptions(rulesAdvertiseOptions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StatefulServiceType.advertise_options: %s", err)
		panic(errMsg)
	}
	v.FldValidators["advertise_options"] = vFn

	v.FldValidators["configuration"] = ConfigurationParametersTypeValidator().Validate

	v.FldValidators["family"] = IPFamilyTypeValidator().Validate

	return v
}()

func StatefulServiceTypeValidator() db.Validator {
	return DefaultStatefulServiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageVolumeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageVolumeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageVolumeType) DeepCopy() *StorageVolumeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageVolumeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageVolumeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageVolumeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageVolumeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStorageVolumeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageVolumeType) VolumeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volume_choice")
	}
	return validatorFn, nil
}

func (v *ValidateStorageVolumeType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateStorageVolumeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageVolumeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageVolumeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volume_choice"]; exists {
		val := m.GetVolumeChoice()
		vOpts := append(opts,
			db.WithValidateField("volume_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVolumeChoice().(type) {
	case *StorageVolumeType_PersistentVolume:
		if fv, exists := v.FldValidators["volume_choice.persistent_volume"]; exists {
			val := m.GetVolumeChoice().(*StorageVolumeType_PersistentVolume).PersistentVolume
			vOpts := append(opts,
				db.WithValidateField("volume_choice"),
				db.WithValidateField("persistent_volume"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageVolumeType_EmptyDir:
		if fv, exists := v.FldValidators["volume_choice.empty_dir"]; exists {
			val := m.GetVolumeChoice().(*StorageVolumeType_EmptyDir).EmptyDir
			vOpts := append(opts,
				db.WithValidateField("volume_choice"),
				db.WithValidateField("empty_dir"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StorageVolumeType_HostPath:
		if fv, exists := v.FldValidators["volume_choice.host_path"]; exists {
			val := m.GetVolumeChoice().(*StorageVolumeType_HostPath).HostPath
			vOpts := append(opts,
				db.WithValidateField("volume_choice"),
				db.WithValidateField("host_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageVolumeTypeValidator = func() *ValidateStorageVolumeType {
	v := &ValidateStorageVolumeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVolumeChoice := v.VolumeChoiceValidationRuleHandler
	rulesVolumeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVolumeChoice(rulesVolumeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageVolumeType.volume_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volume_choice"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.dns_1123_label": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StorageVolumeType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["volume_choice.persistent_volume"] = PersistentStorageVolumeTypeValidator().Validate
	v.FldValidators["volume_choice.empty_dir"] = EmptyDirectoryVolumeTypeValidator().Validate
	v.FldValidators["volume_choice.host_path"] = HostPathVolumeTypeValidator().Validate

	return v
}()

func StorageVolumeTypeValidator() db.Validator {
	return DefaultStorageVolumeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TCPHealthCheckType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TCPHealthCheckType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TCPHealthCheckType) DeepCopy() *TCPHealthCheckType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TCPHealthCheckType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TCPHealthCheckType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TCPHealthCheckType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TCPHealthCheckTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTCPHealthCheckType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTCPHealthCheckType) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for port")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := PortChoiceTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTCPHealthCheckType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TCPHealthCheckType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TCPHealthCheckType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTCPHealthCheckTypeValidator = func() *ValidateTCPHealthCheckType {
	v := &ValidateTCPHealthCheckType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPHealthCheckType.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	return v
}()

func TCPHealthCheckTypeValidator() db.Validator {
	return DefaultTCPHealthCheckTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TCPLoadBalancerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TCPLoadBalancerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TCPLoadBalancerType) DeepCopy() *TCPLoadBalancerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TCPLoadBalancerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TCPLoadBalancerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TCPLoadBalancerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TCPLoadBalancerTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTCPLoadBalancerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTCPLoadBalancerType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTCPLoadBalancerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TCPLoadBalancerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TCPLoadBalancerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["with_sni"]; exists {

		vOpts := append(opts, db.WithValidateField("with_sni"))
		if err := fv(ctx, m.GetWithSni(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTCPLoadBalancerTypeValidator = func() *ValidateTCPLoadBalancerType {
	v := &ValidateTCPLoadBalancerType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.repeated.items.string.hostname": "true",
		"ves.io.schema.rules.repeated.max_items":             "32",
		"ves.io.schema.rules.repeated.unique":                "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TCPLoadBalancerType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	return v
}()

func TCPLoadBalancerTypeValidator() db.Validator {
	return DefaultTCPLoadBalancerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VolumeMountType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolumeMountType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolumeMountType) DeepCopy() *VolumeMountType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolumeMountType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolumeMountType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolumeMountType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolumeMountTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVolumeMountType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolumeMountType) MountPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mount_path")
	}

	return validatorFn, nil
}

func (v *ValidateVolumeMountType) SubPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sub_path")
	}

	return validatorFn, nil
}

func (v *ValidateVolumeMountType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolumeMountType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolumeMountType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mode"]; exists {

		vOpts := append(opts, db.WithValidateField("mode"))
		if err := fv(ctx, m.GetMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mount_path"]; exists {

		vOpts := append(opts, db.WithValidateField("mount_path"))
		if err := fv(ctx, m.GetMountPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_path"]; exists {

		vOpts := append(opts, db.WithValidateField("sub_path"))
		if err := fv(ctx, m.GetSubPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolumeMountTypeValidator = func() *ValidateVolumeMountType {
	v := &ValidateVolumeMountType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMountPath := v.MountPathValidationRuleHandler
	rulesMountPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.pattern":   "^[^:]*$",
	}
	vFn, err = vrhMountPath(rulesMountPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VolumeMountType.mount_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mount_path"] = vFn

	vrhSubPath := v.SubPathValidationRuleHandler
	rulesSubPath := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhSubPath(rulesSubPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VolumeMountType.sub_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sub_path"] = vFn

	return v
}()

func VolumeMountTypeValidator() db.Validator {
	return DefaultVolumeMountTypeValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetWorkloadChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.WorkloadChoice.(type) {
	case nil:
		o.WorkloadChoice = nil

	case *CreateSpecType_Job:
		o.WorkloadChoice = &GlobalSpecType_Job{Job: of.Job}

	case *CreateSpecType_Service:
		o.WorkloadChoice = &GlobalSpecType_Service{Service: of.Service}

	case *CreateSpecType_SimpleService:
		o.WorkloadChoice = &GlobalSpecType_SimpleService{SimpleService: of.SimpleService}

	case *CreateSpecType_StatefulService:
		o.WorkloadChoice = &GlobalSpecType_StatefulService{StatefulService: of.StatefulService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetWorkloadChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.WorkloadChoice.(type) {
	case nil:
		r.WorkloadChoice = nil

	case *GlobalSpecType_Job:
		r.WorkloadChoice = &CreateSpecType_Job{Job: of.Job}

	case *GlobalSpecType_Service:
		r.WorkloadChoice = &CreateSpecType_Service{Service: of.Service}

	case *GlobalSpecType_SimpleService:
		r.WorkloadChoice = &CreateSpecType_SimpleService{SimpleService: of.SimpleService}

	case *GlobalSpecType_StatefulService:
		r.WorkloadChoice = &CreateSpecType_StatefulService{StatefulService: of.StatefulService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetWorkloadChoiceFromGlobalSpecType(f)
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetWorkloadChoiceToGlobalSpecType(f)
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetWorkloadChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.WorkloadChoice.(type) {
	case nil:
		o.WorkloadChoice = nil

	case *GetSpecType_Job:
		o.WorkloadChoice = &GlobalSpecType_Job{Job: of.Job}

	case *GetSpecType_Service:
		o.WorkloadChoice = &GlobalSpecType_Service{Service: of.Service}

	case *GetSpecType_SimpleService:
		o.WorkloadChoice = &GlobalSpecType_SimpleService{SimpleService: of.SimpleService}

	case *GetSpecType_StatefulService:
		o.WorkloadChoice = &GlobalSpecType_StatefulService{StatefulService: of.StatefulService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetWorkloadChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.WorkloadChoice.(type) {
	case nil:
		r.WorkloadChoice = nil

	case *GlobalSpecType_Job:
		r.WorkloadChoice = &GetSpecType_Job{Job: of.Job}

	case *GlobalSpecType_Service:
		r.WorkloadChoice = &GetSpecType_Service{Service: of.Service}

	case *GlobalSpecType_SimpleService:
		r.WorkloadChoice = &GetSpecType_SimpleService{SimpleService: of.SimpleService}

	case *GlobalSpecType_StatefulService:
		r.WorkloadChoice = &GetSpecType_StatefulService{StatefulService: of.StatefulService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetWorkloadChoiceFromGlobalSpecType(f)
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetWorkloadChoiceToGlobalSpecType(f)
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetWorkloadChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.WorkloadChoice.(type) {
	case nil:
		o.WorkloadChoice = nil

	case *ReplaceSpecType_Job:
		o.WorkloadChoice = &GlobalSpecType_Job{Job: of.Job}

	case *ReplaceSpecType_Service:
		o.WorkloadChoice = &GlobalSpecType_Service{Service: of.Service}

	case *ReplaceSpecType_SimpleService:
		o.WorkloadChoice = &GlobalSpecType_SimpleService{SimpleService: of.SimpleService}

	case *ReplaceSpecType_StatefulService:
		o.WorkloadChoice = &GlobalSpecType_StatefulService{StatefulService: of.StatefulService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetWorkloadChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.WorkloadChoice.(type) {
	case nil:
		r.WorkloadChoice = nil

	case *GlobalSpecType_Job:
		r.WorkloadChoice = &ReplaceSpecType_Job{Job: of.Job}

	case *GlobalSpecType_Service:
		r.WorkloadChoice = &ReplaceSpecType_Service{Service: of.Service}

	case *GlobalSpecType_SimpleService:
		r.WorkloadChoice = &ReplaceSpecType_SimpleService{SimpleService: of.SimpleService}

	case *GlobalSpecType_StatefulService:
		r.WorkloadChoice = &ReplaceSpecType_StatefulService{StatefulService: of.StatefulService}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetWorkloadChoiceFromGlobalSpecType(f)
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetWorkloadChoiceToGlobalSpecType(f)
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
