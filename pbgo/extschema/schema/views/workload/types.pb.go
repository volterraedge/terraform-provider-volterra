// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/workload/types.proto

package workload

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	http_loadbalancer "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/http_loadbalancer"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VolumeMountModeType
//
// x-displayName: "Mode"
// Mode in which the volume should be mounted to the workload
type VolumeMountModeType int32

const (
	// ReadOnly
	//
	// x-displayName: "Read Only"
	// Mount the volume in read-only mode
	VOLUME_MOUNT_READ_ONLY VolumeMountModeType = 0
	// Read Write
	//
	// x-displayName: "Read Write"
	// Mount the volume in read-write mode
	VOLUME_MOUNT_READ_WRITE VolumeMountModeType = 1
)

var VolumeMountModeType_name = map[int32]string{
	0: "VOLUME_MOUNT_READ_ONLY",
	1: "VOLUME_MOUNT_READ_WRITE",
}

var VolumeMountModeType_value = map[string]int32{
	"VOLUME_MOUNT_READ_ONLY":  0,
	"VOLUME_MOUNT_READ_WRITE": 1,
}

func (VolumeMountModeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{0}
}

// PersistentStorageAccessModeType
//
// x-displayName: "Persistent Storage Access Mode"
// Persistence storage access mode is used to configure access mode for persistent storage
type PersistentStorageAccessModeType int32

const (
	// Read Write Once
	//
	// x-displayName: "Read Write Once (RWO)"
	// Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host
	ACCESS_MODE_READ_WRITE_ONCE PersistentStorageAccessModeType = 0
	// Read Write Many
	//
	// x-displayName: "Read Write Many (RWX)"
	// Read Write Many is used to mount persistent storage in read/write mode to many hosts
	ACCESS_MODE_READ_WRITE_MANY PersistentStorageAccessModeType = 1
	// Read Only Many
	//
	// x-displayName: "Read Only Many (ROX)"
	// Read Only Many is used to mount persistent storage in read-only mode to many hosts
	ACCESS_MODE_READ_ONLY_MANY PersistentStorageAccessModeType = 2
)

var PersistentStorageAccessModeType_name = map[int32]string{
	0: "ACCESS_MODE_READ_WRITE_ONCE",
	1: "ACCESS_MODE_READ_WRITE_MANY",
	2: "ACCESS_MODE_READ_ONLY_MANY",
}

var PersistentStorageAccessModeType_value = map[string]int32{
	"ACCESS_MODE_READ_WRITE_ONCE": 0,
	"ACCESS_MODE_READ_WRITE_MANY": 1,
	"ACCESS_MODE_READ_ONLY_MANY":  2,
}

func (PersistentStorageAccessModeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{1}
}

// ImagePullPolicyType
//
// x-displayName: "Image Pull Policy Type"
// Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload
type ImagePullPolicyType int32

const (
	// Default
	//
	// x-displayName: "Default"
	// Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it
	// does not already exist on the node
	IMAGE_PULL_POLICY_DEFAULT ImagePullPolicyType = 0
	// IfNotPresent
	//
	// x-displayName: "If Not Present"
	// Only pull the image if it does not already exist on the node
	IMAGE_PULL_POLICY_IF_NOT_PRESENT ImagePullPolicyType = 1
	// Always
	//
	// x-displayName: "Always"
	// Always pull the image
	IMAGE_PULL_POLICY_ALWAYS ImagePullPolicyType = 2
	// Never
	//
	// x-displayName: "Never"
	// Never pull the image
	IMAGE_PULL_POLICY_NEVER ImagePullPolicyType = 3
)

var ImagePullPolicyType_name = map[int32]string{
	0: "IMAGE_PULL_POLICY_DEFAULT",
	1: "IMAGE_PULL_POLICY_IF_NOT_PRESENT",
	2: "IMAGE_PULL_POLICY_ALWAYS",
	3: "IMAGE_PULL_POLICY_NEVER",
}

var ImagePullPolicyType_value = map[string]int32{
	"IMAGE_PULL_POLICY_DEFAULT":        0,
	"IMAGE_PULL_POLICY_IF_NOT_PRESENT": 1,
	"IMAGE_PULL_POLICY_ALWAYS":         2,
	"IMAGE_PULL_POLICY_NEVER":          3,
}

func (ImagePullPolicyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{2}
}

// ContainerFlavorType
//
// x-displayName: "Container Flavor Type"
// Container Flavor type
type ContainerFlavorType int32

const (
	// Tiny
	//
	// x-displayName: "Tiny"
	// Tiny containers have limit of 0.1 vCPU and 100 MiB (mebibyte) memory
	CONTAINER_FLAVOR_TYPE_TINY ContainerFlavorType = 0
	// Medium
	//
	// x-displayName: "Medium"
	// Medium containers have limit of 0.25 vCPU and 250 MiB (mebibyte) memory
	CONTAINER_FLAVOR_TYPE_MEDIUM ContainerFlavorType = 1
	// Large
	//
	// x-displayName: "Large"
	// Large containers have limit of 1 vCPU and 1024 MiB (mebibyte) memory
	CONTAINER_FLAVOR_TYPE_LARGE ContainerFlavorType = 2
)

var ContainerFlavorType_name = map[int32]string{
	0: "CONTAINER_FLAVOR_TYPE_TINY",
	1: "CONTAINER_FLAVOR_TYPE_MEDIUM",
	2: "CONTAINER_FLAVOR_TYPE_LARGE",
}

var ContainerFlavorType_value = map[string]int32{
	"CONTAINER_FLAVOR_TYPE_TINY":   0,
	"CONTAINER_FLAVOR_TYPE_MEDIUM": 1,
	"CONTAINER_FLAVOR_TYPE_LARGE":  2,
}

func (ContainerFlavorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{3}
}

// Protocol Type
//
// x-displayName: "Protocol Type"
// Type of protocol
type ProtocolType int32

const (
	// TCP
	//
	// x-displayName: "TCP"
	// TCP
	PROTOCOL_TCP ProtocolType = 0
	// HTTP
	//
	// x-displayName: "HTTP"
	// HTTP
	PROTOCOL_HTTP ProtocolType = 1
	// HTTP2
	//
	// x-displayName: "HTTP2"
	// HTTP2
	PROTOCOL_HTTP2 ProtocolType = 2
	// TLS with SNI
	//
	// x-displayName: "TLS With SNI"
	// TLS with SNI
	PROTOCOL_TLS_WITH_SNI ProtocolType = 3
	// UDP
	//
	// x-displayName: "UDP"
	// UDP
	PROTOCOL_UDP ProtocolType = 4
)

var ProtocolType_name = map[int32]string{
	0: "PROTOCOL_TCP",
	1: "PROTOCOL_HTTP",
	2: "PROTOCOL_HTTP2",
	3: "PROTOCOL_TLS_WITH_SNI",
	4: "PROTOCOL_UDP",
}

var ProtocolType_value = map[string]int32{
	"PROTOCOL_TCP":          0,
	"PROTOCOL_HTTP":         1,
	"PROTOCOL_HTTP2":        2,
	"PROTOCOL_TLS_WITH_SNI": 3,
	"PROTOCOL_UDP":          4,
}

func (ProtocolType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{4}
}

// VolumeMountType
//
// x-displayName: "Volume Mount"
// Volume mount describes how volume is mounted inside a workload
type VolumeMountType struct {
	// Mode
	//
	// x-displayName: "Mode"
	// Mode of the volume
	Mode VolumeMountModeType `protobuf:"varint,1,opt,name=mode,proto3,enum=ves.io.schema.views.workload.VolumeMountModeType" json:"mode,omitempty"`
	// MountPath
	//
	// x-displayName: "Mount Path"
	// x-required
	// Path within the workload container at which the volume should be mounted. Must not contain ':'.
	MountPath string `protobuf:"bytes,2,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	// SubPath
	//
	// x-displayName: "Sub Path"
	// Path within the volume from which the workload's volume should be mounted. Defaults to "" (volume's root).
	SubPath string `protobuf:"bytes,3,opt,name=sub_path,json=subPath,proto3" json:"sub_path,omitempty"`
}

func (m *VolumeMountType) Reset()      { *m = VolumeMountType{} }
func (*VolumeMountType) ProtoMessage() {}
func (*VolumeMountType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{0}
}
func (m *VolumeMountType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeMountType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VolumeMountType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeMountType.Merge(m, src)
}
func (m *VolumeMountType) XXX_Size() int {
	return m.Size()
}
func (m *VolumeMountType) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeMountType.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeMountType proto.InternalMessageInfo

func (m *VolumeMountType) GetMode() VolumeMountModeType {
	if m != nil {
		return m.Mode
	}
	return VOLUME_MOUNT_READ_ONLY
}

func (m *VolumeMountType) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *VolumeMountType) GetSubPath() string {
	if m != nil {
		return m.SubPath
	}
	return ""
}

// ConfigurationFileType
//
// x-displayName: "Configuration File"
// Configuration File for the workload
type ConfigurationFileType struct {
	// Name
	//
	// x-required
	// x-displayName: "Name"
	// Name of the file
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Data
	//
	// x-displayName: "Data"
	// File data
	Data string `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	// VolumeName
	//
	// x-required
	// x-displayName: "Volume Name"
	// Name of the Volume
	VolumeName string `protobuf:"bytes,6,opt,name=volume_name,json=volumeName,proto3" json:"volume_name,omitempty"`
	// VolumeMount
	//
	// x-required
	// x-displayName: "Volume Mount"
	// Volume Mount information
	Mount *VolumeMountType `protobuf:"bytes,7,opt,name=mount,proto3" json:"mount,omitempty"`
}

func (m *ConfigurationFileType) Reset()      { *m = ConfigurationFileType{} }
func (*ConfigurationFileType) ProtoMessage() {}
func (*ConfigurationFileType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{1}
}
func (m *ConfigurationFileType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigurationFileType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConfigurationFileType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationFileType.Merge(m, src)
}
func (m *ConfigurationFileType) XXX_Size() int {
	return m.Size()
}
func (m *ConfigurationFileType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationFileType.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationFileType proto.InternalMessageInfo

func (m *ConfigurationFileType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigurationFileType) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *ConfigurationFileType) GetVolumeName() string {
	if m != nil {
		return m.VolumeName
	}
	return ""
}

func (m *ConfigurationFileType) GetMount() *VolumeMountType {
	if m != nil {
		return m.Mount
	}
	return nil
}

// EnvironmentVariableType
//
// x-displayName: "Environment Variable"
// Environment Variable
type EnvironmentVariableType struct {
	// Name
	//
	// x-displayName: "Name"
	// Name of Environment Variable.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Value
	//
	// x-displayName: "Value"
	// Value of Environment Variable.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EnvironmentVariableType) Reset()      { *m = EnvironmentVariableType{} }
func (*EnvironmentVariableType) ProtoMessage() {}
func (*EnvironmentVariableType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{2}
}
func (m *EnvironmentVariableType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvironmentVariableType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnvironmentVariableType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvironmentVariableType.Merge(m, src)
}
func (m *EnvironmentVariableType) XXX_Size() int {
	return m.Size()
}
func (m *EnvironmentVariableType) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvironmentVariableType.DiscardUnknown(m)
}

var xxx_messageInfo_EnvironmentVariableType proto.InternalMessageInfo

func (m *EnvironmentVariableType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EnvironmentVariableType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// ConfigurationParameterType
//
// x-displayName: "Configuration Parameter"
// Configuration parameter for the workload
type ConfigurationParameterType struct {
	// Choice
	//
	// x-displayName: "Select Configuration Parameter Type"
	// x-required
	// Type of configuration paramater i.e. file or environment variable.
	//
	// Types that are valid to be assigned to Choice:
	//	*ConfigurationParameterType_File
	//	*ConfigurationParameterType_EnvVar
	Choice isConfigurationParameterType_Choice `protobuf_oneof:"choice"`
}

func (m *ConfigurationParameterType) Reset()      { *m = ConfigurationParameterType{} }
func (*ConfigurationParameterType) ProtoMessage() {}
func (*ConfigurationParameterType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{3}
}
func (m *ConfigurationParameterType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigurationParameterType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConfigurationParameterType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationParameterType.Merge(m, src)
}
func (m *ConfigurationParameterType) XXX_Size() int {
	return m.Size()
}
func (m *ConfigurationParameterType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationParameterType.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationParameterType proto.InternalMessageInfo

type isConfigurationParameterType_Choice interface {
	isConfigurationParameterType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConfigurationParameterType_File struct {
	File *ConfigurationFileType `protobuf:"bytes,2,opt,name=file,proto3,oneof" json:"file,omitempty"`
}
type ConfigurationParameterType_EnvVar struct {
	EnvVar *EnvironmentVariableType `protobuf:"bytes,3,opt,name=env_var,json=envVar,proto3,oneof" json:"env_var,omitempty"`
}

func (*ConfigurationParameterType_File) isConfigurationParameterType_Choice()   {}
func (*ConfigurationParameterType_EnvVar) isConfigurationParameterType_Choice() {}

func (m *ConfigurationParameterType) GetChoice() isConfigurationParameterType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *ConfigurationParameterType) GetFile() *ConfigurationFileType {
	if x, ok := m.GetChoice().(*ConfigurationParameterType_File); ok {
		return x.File
	}
	return nil
}

func (m *ConfigurationParameterType) GetEnvVar() *EnvironmentVariableType {
	if x, ok := m.GetChoice().(*ConfigurationParameterType_EnvVar); ok {
		return x.EnvVar
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConfigurationParameterType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConfigurationParameterType_File)(nil),
		(*ConfigurationParameterType_EnvVar)(nil),
	}
}

// ConfigurationParametersType
//
// x-displayName: "Configuration Parameters"
// Configuration parameters of the workload
type ConfigurationParametersType struct {
	// Parameters
	//
	// x-displayName: "Parameters"
	// Parameters for the workload
	Parameters []*ConfigurationParameterType `protobuf:"bytes,1,rep,name=parameters,proto3" json:"parameters,omitempty"`
}

func (m *ConfigurationParametersType) Reset()      { *m = ConfigurationParametersType{} }
func (*ConfigurationParametersType) ProtoMessage() {}
func (*ConfigurationParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{4}
}
func (m *ConfigurationParametersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigurationParametersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConfigurationParametersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationParametersType.Merge(m, src)
}
func (m *ConfigurationParametersType) XXX_Size() int {
	return m.Size()
}
func (m *ConfigurationParametersType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationParametersType.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationParametersType proto.InternalMessageInfo

func (m *ConfigurationParametersType) GetParameters() []*ConfigurationParameterType {
	if m != nil {
		return m.Parameters
	}
	return nil
}

// PersistentStorageType
//
// x-displayName: "Persistence Storage Configuration"
// Persistent storage configuration is used to configure Persistent Volume Claim (PVC)
type PersistentStorageType struct {
	// Access Mode
	//
	// x-displayName: "Access Mode"
	// AccessMode is used to configure access mode for the persistent storage
	AccessMode PersistentStorageAccessModeType `protobuf:"varint,1,opt,name=access_mode,json=accessMode,proto3,enum=ves.io.schema.views.workload.PersistentStorageAccessModeType" json:"access_mode,omitempty"`
	// Size (in GiB)
	//
	// x-displayName: "Size (in GiB)"
	// Size in GiB of the persistent storage
	// x-required
	StorageSize float64 `protobuf:"fixed64,2,opt,name=storage_size,json=storageSize,proto3" json:"storage_size,omitempty"`
	// Choice of Class
	//
	// x-displayName: "Select Storage Class"
	// x-required
	// Storage class to use for the persistent storage
	//
	// Types that are valid to be assigned to ClassNameChoice:
	//	*PersistentStorageType_Default
	//	*PersistentStorageType_ClassName
	ClassNameChoice isPersistentStorageType_ClassNameChoice `protobuf_oneof:"class_name_choice"`
}

func (m *PersistentStorageType) Reset()      { *m = PersistentStorageType{} }
func (*PersistentStorageType) ProtoMessage() {}
func (*PersistentStorageType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{5}
}
func (m *PersistentStorageType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PersistentStorageType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PersistentStorageType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PersistentStorageType.Merge(m, src)
}
func (m *PersistentStorageType) XXX_Size() int {
	return m.Size()
}
func (m *PersistentStorageType) XXX_DiscardUnknown() {
	xxx_messageInfo_PersistentStorageType.DiscardUnknown(m)
}

var xxx_messageInfo_PersistentStorageType proto.InternalMessageInfo

type isPersistentStorageType_ClassNameChoice interface {
	isPersistentStorageType_ClassNameChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PersistentStorageType_Default struct {
	Default *schema.Empty `protobuf:"bytes,4,opt,name=default,proto3,oneof" json:"default,omitempty"`
}
type PersistentStorageType_ClassName struct {
	ClassName string `protobuf:"bytes,5,opt,name=class_name,json=className,proto3,oneof" json:"class_name,omitempty"`
}

func (*PersistentStorageType_Default) isPersistentStorageType_ClassNameChoice()   {}
func (*PersistentStorageType_ClassName) isPersistentStorageType_ClassNameChoice() {}

func (m *PersistentStorageType) GetClassNameChoice() isPersistentStorageType_ClassNameChoice {
	if m != nil {
		return m.ClassNameChoice
	}
	return nil
}

func (m *PersistentStorageType) GetAccessMode() PersistentStorageAccessModeType {
	if m != nil {
		return m.AccessMode
	}
	return ACCESS_MODE_READ_WRITE_ONCE
}

func (m *PersistentStorageType) GetStorageSize() float64 {
	if m != nil {
		return m.StorageSize
	}
	return 0
}

func (m *PersistentStorageType) GetDefault() *schema.Empty {
	if x, ok := m.GetClassNameChoice().(*PersistentStorageType_Default); ok {
		return x.Default
	}
	return nil
}

func (m *PersistentStorageType) GetClassName() string {
	if x, ok := m.GetClassNameChoice().(*PersistentStorageType_ClassName); ok {
		return x.ClassName
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PersistentStorageType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PersistentStorageType_Default)(nil),
		(*PersistentStorageType_ClassName)(nil),
	}
}

// PersistentStorageVolumeType
//
// x-displayName: "Persistent Storage Volume"
// Volume containing the Persistent Storage for the workload
type PersistentStorageVolumeType struct {
	// Storage
	//
	// x-displayName: "Storage Configuration"
	// x-required
	// Persistent storage configuration
	Storage *PersistentStorageType `protobuf:"bytes,1,opt,name=storage,proto3" json:"storage,omitempty"`
	// Volume Mount
	//
	// x-displayName: "Volume Mount"
	// x-required
	// Volume mount associated with the persistent storage
	Mount *VolumeMountType `protobuf:"bytes,2,opt,name=mount,proto3" json:"mount,omitempty"`
}

func (m *PersistentStorageVolumeType) Reset()      { *m = PersistentStorageVolumeType{} }
func (*PersistentStorageVolumeType) ProtoMessage() {}
func (*PersistentStorageVolumeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{6}
}
func (m *PersistentStorageVolumeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PersistentStorageVolumeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PersistentStorageVolumeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PersistentStorageVolumeType.Merge(m, src)
}
func (m *PersistentStorageVolumeType) XXX_Size() int {
	return m.Size()
}
func (m *PersistentStorageVolumeType) XXX_DiscardUnknown() {
	xxx_messageInfo_PersistentStorageVolumeType.DiscardUnknown(m)
}

var xxx_messageInfo_PersistentStorageVolumeType proto.InternalMessageInfo

func (m *PersistentStorageVolumeType) GetStorage() *PersistentStorageType {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *PersistentStorageVolumeType) GetMount() *VolumeMountType {
	if m != nil {
		return m.Mount
	}
	return nil
}

// EmptyDirectoryVolumeType
//
// x-displayName: "Empty Directory Volume"
// Volume containing a temporary directory whose lifetime is the same as a replica of a workload
type EmptyDirectoryVolumeType struct {
	// Size
	//
	// x-required
	// x-displayName: "Size Limit (in GiB)"
	SizeLimit float64 `protobuf:"fixed64,1,opt,name=size_limit,json=sizeLimit,proto3" json:"size_limit,omitempty"`
	// Volume Mount
	//
	// x-displayName: "Volume Mount"
	// x-required
	// Volume mount associated with the empty directory
	Mount *VolumeMountType `protobuf:"bytes,2,opt,name=mount,proto3" json:"mount,omitempty"`
}

func (m *EmptyDirectoryVolumeType) Reset()      { *m = EmptyDirectoryVolumeType{} }
func (*EmptyDirectoryVolumeType) ProtoMessage() {}
func (*EmptyDirectoryVolumeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{7}
}
func (m *EmptyDirectoryVolumeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyDirectoryVolumeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EmptyDirectoryVolumeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyDirectoryVolumeType.Merge(m, src)
}
func (m *EmptyDirectoryVolumeType) XXX_Size() int {
	return m.Size()
}
func (m *EmptyDirectoryVolumeType) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyDirectoryVolumeType.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyDirectoryVolumeType proto.InternalMessageInfo

func (m *EmptyDirectoryVolumeType) GetSizeLimit() float64 {
	if m != nil {
		return m.SizeLimit
	}
	return 0
}

func (m *EmptyDirectoryVolumeType) GetMount() *VolumeMountType {
	if m != nil {
		return m.Mount
	}
	return nil
}

// HostPathVolumeType
//
// x-displayName: "HostPath Volume"
// Volume containing a host mapped path into the workload
type HostPathVolumeType struct {
	// Path
	//
	// x-displayName: "Path"
	// x-required
	// Path of the directory on the host
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Volume Mount
	//
	// x-displayName: "Volume Mount"
	// x-required
	// Volume mount associated with the host path
	Mount *VolumeMountType `protobuf:"bytes,2,opt,name=mount,proto3" json:"mount,omitempty"`
}

func (m *HostPathVolumeType) Reset()      { *m = HostPathVolumeType{} }
func (*HostPathVolumeType) ProtoMessage() {}
func (*HostPathVolumeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{8}
}
func (m *HostPathVolumeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostPathVolumeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HostPathVolumeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostPathVolumeType.Merge(m, src)
}
func (m *HostPathVolumeType) XXX_Size() int {
	return m.Size()
}
func (m *HostPathVolumeType) XXX_DiscardUnknown() {
	xxx_messageInfo_HostPathVolumeType.DiscardUnknown(m)
}

var xxx_messageInfo_HostPathVolumeType proto.InternalMessageInfo

func (m *HostPathVolumeType) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HostPathVolumeType) GetMount() *VolumeMountType {
	if m != nil {
		return m.Mount
	}
	return nil
}

// StorageVolumeType
//
// x-displayName: "Storage Volume"
// Storage volume configuration for the workload
type StorageVolumeType struct {
	// Name
	//
	// x-displayName: "Name"
	// Name of the volume
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Volume Choice
	//
	// x-displayName: "Volume"
	// x-required
	// Select type of volume.
	//
	// Types that are valid to be assigned to VolumeChoice:
	//	*StorageVolumeType_PersistentVolume
	//	*StorageVolumeType_EmptyDir
	//	*StorageVolumeType_HostPath
	VolumeChoice isStorageVolumeType_VolumeChoice `protobuf_oneof:"volume_choice"`
}

func (m *StorageVolumeType) Reset()      { *m = StorageVolumeType{} }
func (*StorageVolumeType) ProtoMessage() {}
func (*StorageVolumeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{9}
}
func (m *StorageVolumeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageVolumeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageVolumeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageVolumeType.Merge(m, src)
}
func (m *StorageVolumeType) XXX_Size() int {
	return m.Size()
}
func (m *StorageVolumeType) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageVolumeType.DiscardUnknown(m)
}

var xxx_messageInfo_StorageVolumeType proto.InternalMessageInfo

type isStorageVolumeType_VolumeChoice interface {
	isStorageVolumeType_VolumeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageVolumeType_PersistentVolume struct {
	PersistentVolume *PersistentStorageVolumeType `protobuf:"bytes,3,opt,name=persistent_volume,json=persistentVolume,proto3,oneof" json:"persistent_volume,omitempty"`
}
type StorageVolumeType_EmptyDir struct {
	EmptyDir *EmptyDirectoryVolumeType `protobuf:"bytes,4,opt,name=empty_dir,json=emptyDir,proto3,oneof" json:"empty_dir,omitempty"`
}
type StorageVolumeType_HostPath struct {
	HostPath *HostPathVolumeType `protobuf:"bytes,5,opt,name=host_path,json=hostPath,proto3,oneof" json:"host_path,omitempty"`
}

func (*StorageVolumeType_PersistentVolume) isStorageVolumeType_VolumeChoice() {}
func (*StorageVolumeType_EmptyDir) isStorageVolumeType_VolumeChoice()         {}
func (*StorageVolumeType_HostPath) isStorageVolumeType_VolumeChoice()         {}

func (m *StorageVolumeType) GetVolumeChoice() isStorageVolumeType_VolumeChoice {
	if m != nil {
		return m.VolumeChoice
	}
	return nil
}

func (m *StorageVolumeType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StorageVolumeType) GetPersistentVolume() *PersistentStorageVolumeType {
	if x, ok := m.GetVolumeChoice().(*StorageVolumeType_PersistentVolume); ok {
		return x.PersistentVolume
	}
	return nil
}

func (m *StorageVolumeType) GetEmptyDir() *EmptyDirectoryVolumeType {
	if x, ok := m.GetVolumeChoice().(*StorageVolumeType_EmptyDir); ok {
		return x.EmptyDir
	}
	return nil
}

func (m *StorageVolumeType) GetHostPath() *HostPathVolumeType {
	if x, ok := m.GetVolumeChoice().(*StorageVolumeType_HostPath); ok {
		return x.HostPath
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StorageVolumeType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StorageVolumeType_PersistentVolume)(nil),
		(*StorageVolumeType_EmptyDir)(nil),
		(*StorageVolumeType_HostPath)(nil),
	}
}

// EphemeralStorageVolumeType
//
// x-displayName: "Ephemeral Storage Volume"
// Ephemeral storage volume configuration for the workload
type EphemeralStorageVolumeType struct {
	// Name
	//
	// x-displayName: "Name"
	// Name of the volume
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Volume Choice
	//
	// x-displayName: "Select Volume"
	// x-required
	// Select Volume Type
	//
	// Types that are valid to be assigned to VolumeChoice:
	//	*EphemeralStorageVolumeType_EmptyDir
	//	*EphemeralStorageVolumeType_HostPath
	VolumeChoice isEphemeralStorageVolumeType_VolumeChoice `protobuf_oneof:"volume_choice"`
}

func (m *EphemeralStorageVolumeType) Reset()      { *m = EphemeralStorageVolumeType{} }
func (*EphemeralStorageVolumeType) ProtoMessage() {}
func (*EphemeralStorageVolumeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{10}
}
func (m *EphemeralStorageVolumeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EphemeralStorageVolumeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EphemeralStorageVolumeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EphemeralStorageVolumeType.Merge(m, src)
}
func (m *EphemeralStorageVolumeType) XXX_Size() int {
	return m.Size()
}
func (m *EphemeralStorageVolumeType) XXX_DiscardUnknown() {
	xxx_messageInfo_EphemeralStorageVolumeType.DiscardUnknown(m)
}

var xxx_messageInfo_EphemeralStorageVolumeType proto.InternalMessageInfo

type isEphemeralStorageVolumeType_VolumeChoice interface {
	isEphemeralStorageVolumeType_VolumeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type EphemeralStorageVolumeType_EmptyDir struct {
	EmptyDir *EmptyDirectoryVolumeType `protobuf:"bytes,3,opt,name=empty_dir,json=emptyDir,proto3,oneof" json:"empty_dir,omitempty"`
}
type EphemeralStorageVolumeType_HostPath struct {
	HostPath *HostPathVolumeType `protobuf:"bytes,4,opt,name=host_path,json=hostPath,proto3,oneof" json:"host_path,omitempty"`
}

func (*EphemeralStorageVolumeType_EmptyDir) isEphemeralStorageVolumeType_VolumeChoice() {}
func (*EphemeralStorageVolumeType_HostPath) isEphemeralStorageVolumeType_VolumeChoice() {}

func (m *EphemeralStorageVolumeType) GetVolumeChoice() isEphemeralStorageVolumeType_VolumeChoice {
	if m != nil {
		return m.VolumeChoice
	}
	return nil
}

func (m *EphemeralStorageVolumeType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EphemeralStorageVolumeType) GetEmptyDir() *EmptyDirectoryVolumeType {
	if x, ok := m.GetVolumeChoice().(*EphemeralStorageVolumeType_EmptyDir); ok {
		return x.EmptyDir
	}
	return nil
}

func (m *EphemeralStorageVolumeType) GetHostPath() *HostPathVolumeType {
	if x, ok := m.GetVolumeChoice().(*EphemeralStorageVolumeType_HostPath); ok {
		return x.HostPath
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EphemeralStorageVolumeType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EphemeralStorageVolumeType_EmptyDir)(nil),
		(*EphemeralStorageVolumeType_HostPath)(nil),
	}
}

// PersistentVolumeType
//
// x-displayName: "Persistent Storage Volume"
// Persistent storage volume configuration for the workload
type PersistentVolumeType struct {
	// Name
	//
	// x-required
	// x-displayName: "Name"
	// Name of the volume
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// PersistentStorageVolumeType
	//
	// x-required
	// x-displayName: "Persistent Storage Volume"
	// Volume containing the Persistent Storage for the workload
	PersistentVolume *PersistentStorageVolumeType `protobuf:"bytes,2,opt,name=persistent_volume,json=persistentVolume,proto3" json:"persistent_volume,omitempty"`
}

func (m *PersistentVolumeType) Reset()      { *m = PersistentVolumeType{} }
func (*PersistentVolumeType) ProtoMessage() {}
func (*PersistentVolumeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{11}
}
func (m *PersistentVolumeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PersistentVolumeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PersistentVolumeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PersistentVolumeType.Merge(m, src)
}
func (m *PersistentVolumeType) XXX_Size() int {
	return m.Size()
}
func (m *PersistentVolumeType) XXX_DiscardUnknown() {
	xxx_messageInfo_PersistentVolumeType.DiscardUnknown(m)
}

var xxx_messageInfo_PersistentVolumeType proto.InternalMessageInfo

func (m *PersistentVolumeType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PersistentVolumeType) GetPersistentVolume() *PersistentStorageVolumeType {
	if m != nil {
		return m.PersistentVolume
	}
	return nil
}

// ImageType
//
// x-displayName: "Image Configuration"
// ImageType configures the image to use, how to pull the image, and the associated secrets to use if any
type ImageType struct {
	// Name
	//
	// x-displayName: "Image Name"
	// x-example: "quay.io/etcd:0.13"
	// x-required
	// Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13.
	// The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the
	// Docker public registry is assumed. If tag is not specified, latest is assumed.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Registry Choice
	//
	// x-displayName: "Select Container Registry"
	// x-required
	// Registry choice
	//
	// Types that are valid to be assigned to RegistryChoice:
	//	*ImageType_Public
	//	*ImageType_ContainerRegistry
	RegistryChoice isImageType_RegistryChoice `protobuf_oneof:"registry_choice"`
	// PullPolicy
	//
	// x-displayName: "Select Image Pull Policy"
	// Pull Policy determines the policy to use for pulling the image prior to starting the service
	PullPolicy ImagePullPolicyType `protobuf:"varint,6,opt,name=pull_policy,json=pullPolicy,proto3,enum=ves.io.schema.views.workload.ImagePullPolicyType" json:"pull_policy,omitempty"`
}

func (m *ImageType) Reset()      { *m = ImageType{} }
func (*ImageType) ProtoMessage() {}
func (*ImageType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{12}
}
func (m *ImageType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ImageType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageType.Merge(m, src)
}
func (m *ImageType) XXX_Size() int {
	return m.Size()
}
func (m *ImageType) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageType.DiscardUnknown(m)
}

var xxx_messageInfo_ImageType proto.InternalMessageInfo

type isImageType_RegistryChoice interface {
	isImageType_RegistryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ImageType_Public struct {
	Public *schema.Empty `protobuf:"bytes,3,opt,name=public,proto3,oneof" json:"public,omitempty"`
}
type ImageType_ContainerRegistry struct {
	ContainerRegistry *views.ObjectRefType `protobuf:"bytes,4,opt,name=container_registry,json=containerRegistry,proto3,oneof" json:"container_registry,omitempty"`
}

func (*ImageType_Public) isImageType_RegistryChoice()            {}
func (*ImageType_ContainerRegistry) isImageType_RegistryChoice() {}

func (m *ImageType) GetRegistryChoice() isImageType_RegistryChoice {
	if m != nil {
		return m.RegistryChoice
	}
	return nil
}

func (m *ImageType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ImageType) GetPublic() *schema.Empty {
	if x, ok := m.GetRegistryChoice().(*ImageType_Public); ok {
		return x.Public
	}
	return nil
}

func (m *ImageType) GetContainerRegistry() *views.ObjectRefType {
	if x, ok := m.GetRegistryChoice().(*ImageType_ContainerRegistry); ok {
		return x.ContainerRegistry
	}
	return nil
}

func (m *ImageType) GetPullPolicy() ImagePullPolicyType {
	if m != nil {
		return m.PullPolicy
	}
	return IMAGE_PULL_POLICY_DEFAULT
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ImageType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ImageType_Public)(nil),
		(*ImageType_ContainerRegistry)(nil),
	}
}

// PortChoiceType
//
// x-displayName: "Port"
// Port
type PortChoiceType struct {
	// Port Choice
	//
	// x-displayName: "Select Port"
	// x-required
	// Choose port
	//
	// Types that are valid to be assigned to PortChoice:
	//	*PortChoiceType_Num
	//	*PortChoiceType_Name
	PortChoice isPortChoiceType_PortChoice `protobuf_oneof:"port_choice"`
}

func (m *PortChoiceType) Reset()      { *m = PortChoiceType{} }
func (*PortChoiceType) ProtoMessage() {}
func (*PortChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{13}
}
func (m *PortChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortChoiceType.Merge(m, src)
}
func (m *PortChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *PortChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_PortChoiceType proto.InternalMessageInfo

type isPortChoiceType_PortChoice interface {
	isPortChoiceType_PortChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PortChoiceType_Num struct {
	Num uint32 `protobuf:"varint,2,opt,name=num,proto3,oneof" json:"num,omitempty"`
}
type PortChoiceType_Name struct {
	Name string `protobuf:"bytes,3,opt,name=name,proto3,oneof" json:"name,omitempty"`
}

func (*PortChoiceType_Num) isPortChoiceType_PortChoice()  {}
func (*PortChoiceType_Name) isPortChoiceType_PortChoice() {}

func (m *PortChoiceType) GetPortChoice() isPortChoiceType_PortChoice {
	if m != nil {
		return m.PortChoice
	}
	return nil
}

func (m *PortChoiceType) GetNum() uint32 {
	if x, ok := m.GetPortChoice().(*PortChoiceType_Num); ok {
		return x.Num
	}
	return 0
}

func (m *PortChoiceType) GetName() string {
	if x, ok := m.GetPortChoice().(*PortChoiceType_Name); ok {
		return x.Name
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PortChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PortChoiceType_Num)(nil),
		(*PortChoiceType_Name)(nil),
	}
}

// HTTPHealthCheckType
//
// x-displayName: "HTTP Health Check"
// HTTPHealthCheckType describes a health check based on HTTP GET requests.
type HTTPHealthCheckType struct {
	// Path
	//
	// x-displayName: "Path"
	// x-required
	// Path to access on the HTTP server.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Port
	//
	// x-displayName: "Port"
	// x-required
	// Name or number of the port to access on the container.
	Port *PortChoiceType `protobuf:"bytes,2,opt,name=port,proto3" json:"port,omitempty"`
	// Host Header
	//
	// x-displayName: "Host Header"
	// x-example: "one.volterra.com"
	// The value of the host header in the HTTP health check request.
	HostHeader string `protobuf:"bytes,3,opt,name=host_header,json=hostHeader,proto3" json:"host_header,omitempty"`
	// Headers to add in health check request
	//
	// x-displayName: "Request Headers to Add"
	// Specifies a list of HTTP headers that should be added to each request that is sent to the
	// health checked container. This is a list of key-value pairs.
	Headers map[string]string `protobuf:"bytes,4,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *HTTPHealthCheckType) Reset()      { *m = HTTPHealthCheckType{} }
func (*HTTPHealthCheckType) ProtoMessage() {}
func (*HTTPHealthCheckType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{14}
}
func (m *HTTPHealthCheckType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPHealthCheckType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HTTPHealthCheckType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPHealthCheckType.Merge(m, src)
}
func (m *HTTPHealthCheckType) XXX_Size() int {
	return m.Size()
}
func (m *HTTPHealthCheckType) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPHealthCheckType.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPHealthCheckType proto.InternalMessageInfo

func (m *HTTPHealthCheckType) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HTTPHealthCheckType) GetPort() *PortChoiceType {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *HTTPHealthCheckType) GetHostHeader() string {
	if m != nil {
		return m.HostHeader
	}
	return ""
}

func (m *HTTPHealthCheckType) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

// ExecHealthCheckType
//
// x-displayName: "Exec Health Check"
// ExecHealthCheckType describes a health check based on "run in container" action.
// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
type ExecHealthCheckType struct {
	// Command
	//
	// x-displayName: "Command"
	// x-required
	// Command is the command line to execute inside the container, the working directory for the
	// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
	// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
	// a shell, you need to explicitly call out to that shell.
	Command []string `protobuf:"bytes,1,rep,name=command,proto3" json:"command,omitempty"`
}

func (m *ExecHealthCheckType) Reset()      { *m = ExecHealthCheckType{} }
func (*ExecHealthCheckType) ProtoMessage() {}
func (*ExecHealthCheckType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{15}
}
func (m *ExecHealthCheckType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecHealthCheckType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExecHealthCheckType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecHealthCheckType.Merge(m, src)
}
func (m *ExecHealthCheckType) XXX_Size() int {
	return m.Size()
}
func (m *ExecHealthCheckType) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecHealthCheckType.DiscardUnknown(m)
}

var xxx_messageInfo_ExecHealthCheckType proto.InternalMessageInfo

func (m *ExecHealthCheckType) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

// TCPHealthCheckType
//
// x-displayName: "TCP Health Check"
// TCPHealthCheckType describes a health check based on opening a TCP connection
type TCPHealthCheckType struct {
	// Port
	//
	// x-displayName: "Port"
	// x-required
	// Number or name of the port to access on the container.
	Port *PortChoiceType `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *TCPHealthCheckType) Reset()      { *m = TCPHealthCheckType{} }
func (*TCPHealthCheckType) ProtoMessage() {}
func (*TCPHealthCheckType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{16}
}
func (m *TCPHealthCheckType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPHealthCheckType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TCPHealthCheckType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPHealthCheckType.Merge(m, src)
}
func (m *TCPHealthCheckType) XXX_Size() int {
	return m.Size()
}
func (m *TCPHealthCheckType) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPHealthCheckType.DiscardUnknown(m)
}

var xxx_messageInfo_TCPHealthCheckType proto.InternalMessageInfo

func (m *TCPHealthCheckType) GetPort() *PortChoiceType {
	if m != nil {
		return m.Port
	}
	return nil
}

// HealthCheckType
//
// x-displayName: "Health Check"
// HealthCheckType describes a health check to be performed against a container to determine whether it has
// started up or is alive or ready to receive traffic
type HealthCheckType struct {
	// HealthCheckChoice
	//
	// x-displayName: "Select Type of Health Check"
	// x-required
	// Specifies action taken to determine health of a container
	//
	// Types that are valid to be assigned to HealthCheckChoice:
	//	*HealthCheckType_HttpHealthCheck
	//	*HealthCheckType_TcpHealthCheck
	//	*HealthCheckType_ExecHealthCheck
	HealthCheckChoice isHealthCheckType_HealthCheckChoice `protobuf_oneof:"health_check_choice"`
	// InitialDelay
	//
	// x-displayName: "Initial Delay"
	// x-example: "30"
	// Number of seconds after the container has started before health checks are initiated
	InitialDelay uint32 `protobuf:"varint,5,opt,name=initial_delay,json=initialDelay,proto3" json:"initial_delay,omitempty"`
	// Timeout
	//
	// x-displayName: "Timeout"
	// x-required
	// x-example: "3"
	// Timeout in seconds to wait for successful response. In other words, it is
	// the time to wait for a health check response. If the timeout is reached the
	// health check attempt will be considered a failure.
	Timeout uint32 `protobuf:"varint,6,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Interval
	//
	// x-displayName: "Interval"
	// x-required
	// x-example: "10"
	// Time interval in seconds between two health check requests.
	Interval uint32 `protobuf:"varint,7,opt,name=interval,proto3" json:"interval,omitempty"`
	// HealthyThreshold
	//
	// x-displayName: "Healthy Threshold"
	// x-required
	// x-example: "2"
	// Number of consecutive successful responses after having failed before declaring healthy.
	// In other words, this is the number of healthy health checks required before marking
	// healthy. Note that during startup and liveliness, only a single successful health check is
	// required to mark a container healthy.
	HealthyThreshold uint32 `protobuf:"varint,8,opt,name=healthy_threshold,json=healthyThreshold,proto3" json:"healthy_threshold,omitempty"`
	// UnhealthyThreshold
	//
	// x-displayName: "Unhealthy Threshold"
	// x-required
	// x-example: "5"
	// Number of consecutive failed responses before declaring unhealthy. In other words, this is
	// the number of unhealthy health checks required before a container is marked unhealthy.
	UnhealthyThreshold uint32 `protobuf:"varint,9,opt,name=unhealthy_threshold,json=unhealthyThreshold,proto3" json:"unhealthy_threshold,omitempty"`
}

func (m *HealthCheckType) Reset()      { *m = HealthCheckType{} }
func (*HealthCheckType) ProtoMessage() {}
func (*HealthCheckType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{17}
}
func (m *HealthCheckType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HealthCheckType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckType.Merge(m, src)
}
func (m *HealthCheckType) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckType) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckType.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckType proto.InternalMessageInfo

type isHealthCheckType_HealthCheckChoice interface {
	isHealthCheckType_HealthCheckChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HealthCheckType_HttpHealthCheck struct {
	HttpHealthCheck *HTTPHealthCheckType `protobuf:"bytes,2,opt,name=http_health_check,json=httpHealthCheck,proto3,oneof" json:"http_health_check,omitempty"`
}
type HealthCheckType_TcpHealthCheck struct {
	TcpHealthCheck *TCPHealthCheckType `protobuf:"bytes,3,opt,name=tcp_health_check,json=tcpHealthCheck,proto3,oneof" json:"tcp_health_check,omitempty"`
}
type HealthCheckType_ExecHealthCheck struct {
	ExecHealthCheck *ExecHealthCheckType `protobuf:"bytes,4,opt,name=exec_health_check,json=execHealthCheck,proto3,oneof" json:"exec_health_check,omitempty"`
}

func (*HealthCheckType_HttpHealthCheck) isHealthCheckType_HealthCheckChoice() {}
func (*HealthCheckType_TcpHealthCheck) isHealthCheckType_HealthCheckChoice()  {}
func (*HealthCheckType_ExecHealthCheck) isHealthCheckType_HealthCheckChoice() {}

func (m *HealthCheckType) GetHealthCheckChoice() isHealthCheckType_HealthCheckChoice {
	if m != nil {
		return m.HealthCheckChoice
	}
	return nil
}

func (m *HealthCheckType) GetHttpHealthCheck() *HTTPHealthCheckType {
	if x, ok := m.GetHealthCheckChoice().(*HealthCheckType_HttpHealthCheck); ok {
		return x.HttpHealthCheck
	}
	return nil
}

func (m *HealthCheckType) GetTcpHealthCheck() *TCPHealthCheckType {
	if x, ok := m.GetHealthCheckChoice().(*HealthCheckType_TcpHealthCheck); ok {
		return x.TcpHealthCheck
	}
	return nil
}

func (m *HealthCheckType) GetExecHealthCheck() *ExecHealthCheckType {
	if x, ok := m.GetHealthCheckChoice().(*HealthCheckType_ExecHealthCheck); ok {
		return x.ExecHealthCheck
	}
	return nil
}

func (m *HealthCheckType) GetInitialDelay() uint32 {
	if m != nil {
		return m.InitialDelay
	}
	return 0
}

func (m *HealthCheckType) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *HealthCheckType) GetInterval() uint32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *HealthCheckType) GetHealthyThreshold() uint32 {
	if m != nil {
		return m.HealthyThreshold
	}
	return 0
}

func (m *HealthCheckType) GetUnhealthyThreshold() uint32 {
	if m != nil {
		return m.UnhealthyThreshold
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HealthCheckType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HealthCheckType_HttpHealthCheck)(nil),
		(*HealthCheckType_TcpHealthCheck)(nil),
		(*HealthCheckType_ExecHealthCheck)(nil),
	}
}

// ContainerType
//
// x-displayName: "Container Configuration"
// ContainerType configures the container information
type ContainerType struct {
	// Name
	//
	// x-displayName: "Name"
	// x-required
	// Name of the container
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Image
	//
	// x-displayName: "Image to Use"
	// x-required
	// Container image information
	Image *ImageType `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	// Init Container
	//
	// x-displayName: "Initialization Container"
	// Specialized container that runs before application container and runs to completion
	InitContainer bool `protobuf:"varint,3,opt,name=init_container,json=initContainer,proto3" json:"init_container,omitempty"`
	// Flavor
	//
	// x-displayName: "Container Resources via Flavor"
	// Flavor
	Flavor ContainerFlavorType `protobuf:"varint,4,opt,name=flavor,proto3,enum=ves.io.schema.views.workload.ContainerFlavorType" json:"flavor,omitempty"`
	// LivenessCheck
	//
	// x-displayName: "Liveness Check"
	// Health check of container liveness.
	// Container will be restarted if the health check fails.
	LivenessCheck *HealthCheckType `protobuf:"bytes,5,opt,name=liveness_check,json=livenessCheck,proto3" json:"liveness_check,omitempty"`
	// ReadinessCheck
	//
	// x-displayName: "Readiness Check"
	// Health check of container service readiness.
	// Container will be removed from service endpoints if the health check fails.
	ReadinessCheck *HealthCheckType `protobuf:"bytes,6,opt,name=readiness_check,json=readinessCheck,proto3" json:"readiness_check,omitempty"`
	// Command
	//
	// x-displayName: "Command"
	// Command to execute. Overrides the docker image's ENTRYPOINT
	Command []string `protobuf:"bytes,7,rep,name=command,proto3" json:"command,omitempty"`
	// Args
	//
	// x-displayName: "Arguments"
	// Arguments to the entrypoint. Overrides the docker image's CMD
	Args []string `protobuf:"bytes,8,rep,name=args,proto3" json:"args,omitempty"`
}

func (m *ContainerType) Reset()      { *m = ContainerType{} }
func (*ContainerType) ProtoMessage() {}
func (*ContainerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{18}
}
func (m *ContainerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContainerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerType.Merge(m, src)
}
func (m *ContainerType) XXX_Size() int {
	return m.Size()
}
func (m *ContainerType) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerType.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerType proto.InternalMessageInfo

func (m *ContainerType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ContainerType) GetImage() *ImageType {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *ContainerType) GetInitContainer() bool {
	if m != nil {
		return m.InitContainer
	}
	return false
}

func (m *ContainerType) GetFlavor() ContainerFlavorType {
	if m != nil {
		return m.Flavor
	}
	return CONTAINER_FLAVOR_TYPE_TINY
}

func (m *ContainerType) GetLivenessCheck() *HealthCheckType {
	if m != nil {
		return m.LivenessCheck
	}
	return nil
}

func (m *ContainerType) GetReadinessCheck() *HealthCheckType {
	if m != nil {
		return m.ReadinessCheck
	}
	return nil
}

func (m *ContainerType) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerType) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

// DeployCESiteType
//
// x-displayName: "Customer Sites"
// This defines a way to deploy a workload on specific Customer sites
type DeployCESiteType struct {
	// Site
	//
	// x-displayName: "List of Customer Sites to Deploy"
	// x-required
	// Which customer sites should this workload be deployed
	Site []*views.ObjectRefType `protobuf:"bytes,1,rep,name=site,proto3" json:"site,omitempty"`
}

func (m *DeployCESiteType) Reset()      { *m = DeployCESiteType{} }
func (*DeployCESiteType) ProtoMessage() {}
func (*DeployCESiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{19}
}
func (m *DeployCESiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployCESiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeployCESiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployCESiteType.Merge(m, src)
}
func (m *DeployCESiteType) XXX_Size() int {
	return m.Size()
}
func (m *DeployCESiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployCESiteType.DiscardUnknown(m)
}

var xxx_messageInfo_DeployCESiteType proto.InternalMessageInfo

func (m *DeployCESiteType) GetSite() []*views.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

// DeployRESiteType
//
// x-displayName: "Regional Edge Sites"
// This defines a way to deploy a workload on specific Regional Edge sites
type DeployRESiteType struct {
	// Site
	//
	// x-displayName: "List of Regional Edge Sites to Deploy"
	// x-required
	// Which regional edge sites should this workload be deployed
	Site []*views.ObjectRefType `protobuf:"bytes,1,rep,name=site,proto3" json:"site,omitempty"`
}

func (m *DeployRESiteType) Reset()      { *m = DeployRESiteType{} }
func (*DeployRESiteType) ProtoMessage() {}
func (*DeployRESiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{20}
}
func (m *DeployRESiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployRESiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeployRESiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployRESiteType.Merge(m, src)
}
func (m *DeployRESiteType) XXX_Size() int {
	return m.Size()
}
func (m *DeployRESiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployRESiteType.DiscardUnknown(m)
}

var xxx_messageInfo_DeployRESiteType proto.InternalMessageInfo

func (m *DeployRESiteType) GetSite() []*views.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

// DeployREVirtualSiteType
//
// x-displayName: "Regional Edge Virtual Sites"
// This defines a way to deploy a workload on specific Regional Edge virtual sites
type DeployREVirtualSiteType struct {
	// Virtual Site
	//
	// x-displayName: "List of Regional Edge Virtual Sites to Deploy"
	// x-required
	// Which regional edge virtual sites should this workload be deployed
	VirtualSite []*views.ObjectRefType `protobuf:"bytes,1,rep,name=virtual_site,json=virtualSite,proto3" json:"virtual_site,omitempty"`
}

func (m *DeployREVirtualSiteType) Reset()      { *m = DeployREVirtualSiteType{} }
func (*DeployREVirtualSiteType) ProtoMessage() {}
func (*DeployREVirtualSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{21}
}
func (m *DeployREVirtualSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployREVirtualSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeployREVirtualSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployREVirtualSiteType.Merge(m, src)
}
func (m *DeployREVirtualSiteType) XXX_Size() int {
	return m.Size()
}
func (m *DeployREVirtualSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployREVirtualSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_DeployREVirtualSiteType proto.InternalMessageInfo

func (m *DeployREVirtualSiteType) GetVirtualSite() []*views.ObjectRefType {
	if m != nil {
		return m.VirtualSite
	}
	return nil
}

// DeployCEVirtualSiteType
//
// x-displayName: "Customer Virtual Sites"
// This defines a way to deploy a workload on specific Customer virtual sites
type DeployCEVirtualSiteType struct {
	// Virtual Site
	//
	// x-displayName: "List of Customer Virtual Sites to Deploy"
	// x-required
	// Which customer virtual sites should this workload be deployed
	VirtualSite []*views.ObjectRefType `protobuf:"bytes,1,rep,name=virtual_site,json=virtualSite,proto3" json:"virtual_site,omitempty"`
}

func (m *DeployCEVirtualSiteType) Reset()      { *m = DeployCEVirtualSiteType{} }
func (*DeployCEVirtualSiteType) ProtoMessage() {}
func (*DeployCEVirtualSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{22}
}
func (m *DeployCEVirtualSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployCEVirtualSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeployCEVirtualSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployCEVirtualSiteType.Merge(m, src)
}
func (m *DeployCEVirtualSiteType) XXX_Size() int {
	return m.Size()
}
func (m *DeployCEVirtualSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployCEVirtualSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_DeployCEVirtualSiteType proto.InternalMessageInfo

func (m *DeployCEVirtualSiteType) GetVirtualSite() []*views.ObjectRefType {
	if m != nil {
		return m.VirtualSite
	}
	return nil
}

// DeployOptionsType
//
// x-displayName: "Deploy Options"
// Deploy Options are used to configure the workload deployment options
type DeployOptionsType struct {
	// Deploy choice
	//
	// x-displayName: "Where to Deploy the workload"
	// x-required
	// This is a choice to select where to deploy the workload.
	//
	// Types that are valid to be assigned to DeployChoice:
	//	*DeployOptionsType_AllRes
	//	*DeployOptionsType_DeployReVirtualSites
	//	*DeployOptionsType_DeployCeVirtualSites
	//	*DeployOptionsType_DeployCeSites
	//	*DeployOptionsType_DefaultVirtualSites
	//	*DeployOptionsType_DeployReSites
	DeployChoice isDeployOptionsType_DeployChoice `protobuf_oneof:"deploy_choice"`
}

func (m *DeployOptionsType) Reset()      { *m = DeployOptionsType{} }
func (*DeployOptionsType) ProtoMessage() {}
func (*DeployOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{23}
}
func (m *DeployOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeployOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployOptionsType.Merge(m, src)
}
func (m *DeployOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *DeployOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_DeployOptionsType proto.InternalMessageInfo

type isDeployOptionsType_DeployChoice interface {
	isDeployOptionsType_DeployChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DeployOptionsType_AllRes struct {
	AllRes *schema.Empty `protobuf:"bytes,2,opt,name=all_res,json=allRes,proto3,oneof" json:"all_res,omitempty"`
}
type DeployOptionsType_DeployReVirtualSites struct {
	DeployReVirtualSites *DeployREVirtualSiteType `protobuf:"bytes,3,opt,name=deploy_re_virtual_sites,json=deployReVirtualSites,proto3,oneof" json:"deploy_re_virtual_sites,omitempty"`
}
type DeployOptionsType_DeployCeVirtualSites struct {
	DeployCeVirtualSites *DeployCEVirtualSiteType `protobuf:"bytes,4,opt,name=deploy_ce_virtual_sites,json=deployCeVirtualSites,proto3,oneof" json:"deploy_ce_virtual_sites,omitempty"`
}
type DeployOptionsType_DeployCeSites struct {
	DeployCeSites *DeployCESiteType `protobuf:"bytes,5,opt,name=deploy_ce_sites,json=deployCeSites,proto3,oneof" json:"deploy_ce_sites,omitempty"`
}
type DeployOptionsType_DefaultVirtualSites struct {
	DefaultVirtualSites *schema.Empty `protobuf:"bytes,6,opt,name=default_virtual_sites,json=defaultVirtualSites,proto3,oneof" json:"default_virtual_sites,omitempty"`
}
type DeployOptionsType_DeployReSites struct {
	DeployReSites *DeployRESiteType `protobuf:"bytes,7,opt,name=deploy_re_sites,json=deployReSites,proto3,oneof" json:"deploy_re_sites,omitempty"`
}

func (*DeployOptionsType_AllRes) isDeployOptionsType_DeployChoice()               {}
func (*DeployOptionsType_DeployReVirtualSites) isDeployOptionsType_DeployChoice() {}
func (*DeployOptionsType_DeployCeVirtualSites) isDeployOptionsType_DeployChoice() {}
func (*DeployOptionsType_DeployCeSites) isDeployOptionsType_DeployChoice()        {}
func (*DeployOptionsType_DefaultVirtualSites) isDeployOptionsType_DeployChoice()  {}
func (*DeployOptionsType_DeployReSites) isDeployOptionsType_DeployChoice()        {}

func (m *DeployOptionsType) GetDeployChoice() isDeployOptionsType_DeployChoice {
	if m != nil {
		return m.DeployChoice
	}
	return nil
}

func (m *DeployOptionsType) GetAllRes() *schema.Empty {
	if x, ok := m.GetDeployChoice().(*DeployOptionsType_AllRes); ok {
		return x.AllRes
	}
	return nil
}

func (m *DeployOptionsType) GetDeployReVirtualSites() *DeployREVirtualSiteType {
	if x, ok := m.GetDeployChoice().(*DeployOptionsType_DeployReVirtualSites); ok {
		return x.DeployReVirtualSites
	}
	return nil
}

func (m *DeployOptionsType) GetDeployCeVirtualSites() *DeployCEVirtualSiteType {
	if x, ok := m.GetDeployChoice().(*DeployOptionsType_DeployCeVirtualSites); ok {
		return x.DeployCeVirtualSites
	}
	return nil
}

func (m *DeployOptionsType) GetDeployCeSites() *DeployCESiteType {
	if x, ok := m.GetDeployChoice().(*DeployOptionsType_DeployCeSites); ok {
		return x.DeployCeSites
	}
	return nil
}

func (m *DeployOptionsType) GetDefaultVirtualSites() *schema.Empty {
	if x, ok := m.GetDeployChoice().(*DeployOptionsType_DefaultVirtualSites); ok {
		return x.DefaultVirtualSites
	}
	return nil
}

func (m *DeployOptionsType) GetDeployReSites() *DeployRESiteType {
	if x, ok := m.GetDeployChoice().(*DeployOptionsType_DeployReSites); ok {
		return x.DeployReSites
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DeployOptionsType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DeployOptionsType_AllRes)(nil),
		(*DeployOptionsType_DeployReVirtualSites)(nil),
		(*DeployOptionsType_DeployCeVirtualSites)(nil),
		(*DeployOptionsType_DeployCeSites)(nil),
		(*DeployOptionsType_DefaultVirtualSites)(nil),
		(*DeployOptionsType_DeployReSites)(nil),
	}
}

// RouteInfoType
//
// x-displayName: "Route Information"
// This defines various options to define a route
type RouteInfoType struct {
	// route choice
	//
	// x-displayName: "Select Type of Route"
	// x-required
	// Selection of different types of routes
	//
	// Types that are valid to be assigned to Choice:
	//	*RouteInfoType_SimpleRoute
	//	*RouteInfoType_RedirectRoute
	//	*RouteInfoType_DirectResponseRoute
	//	*RouteInfoType_CustomRouteObject
	Choice isRouteInfoType_Choice `protobuf_oneof:"choice"`
}

func (m *RouteInfoType) Reset()      { *m = RouteInfoType{} }
func (*RouteInfoType) ProtoMessage() {}
func (*RouteInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{24}
}
func (m *RouteInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteInfoType.Merge(m, src)
}
func (m *RouteInfoType) XXX_Size() int {
	return m.Size()
}
func (m *RouteInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_RouteInfoType proto.InternalMessageInfo

type isRouteInfoType_Choice interface {
	isRouteInfoType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteInfoType_SimpleRoute struct {
	SimpleRoute *http_loadbalancer.RouteTypeSimpleWithDefaultOriginPool `protobuf:"bytes,1,opt,name=simple_route,json=simpleRoute,proto3,oneof" json:"simple_route,omitempty"`
}
type RouteInfoType_RedirectRoute struct {
	RedirectRoute *http_loadbalancer.RouteTypeRedirect `protobuf:"bytes,2,opt,name=redirect_route,json=redirectRoute,proto3,oneof" json:"redirect_route,omitempty"`
}
type RouteInfoType_DirectResponseRoute struct {
	DirectResponseRoute *http_loadbalancer.RouteTypeDirectResponse `protobuf:"bytes,3,opt,name=direct_response_route,json=directResponseRoute,proto3,oneof" json:"direct_response_route,omitempty"`
}
type RouteInfoType_CustomRouteObject struct {
	CustomRouteObject *http_loadbalancer.RouteTypeCustomRoute `protobuf:"bytes,4,opt,name=custom_route_object,json=customRouteObject,proto3,oneof" json:"custom_route_object,omitempty"`
}

func (*RouteInfoType_SimpleRoute) isRouteInfoType_Choice()         {}
func (*RouteInfoType_RedirectRoute) isRouteInfoType_Choice()       {}
func (*RouteInfoType_DirectResponseRoute) isRouteInfoType_Choice() {}
func (*RouteInfoType_CustomRouteObject) isRouteInfoType_Choice()   {}

func (m *RouteInfoType) GetChoice() isRouteInfoType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *RouteInfoType) GetSimpleRoute() *http_loadbalancer.RouteTypeSimpleWithDefaultOriginPool {
	if x, ok := m.GetChoice().(*RouteInfoType_SimpleRoute); ok {
		return x.SimpleRoute
	}
	return nil
}

func (m *RouteInfoType) GetRedirectRoute() *http_loadbalancer.RouteTypeRedirect {
	if x, ok := m.GetChoice().(*RouteInfoType_RedirectRoute); ok {
		return x.RedirectRoute
	}
	return nil
}

func (m *RouteInfoType) GetDirectResponseRoute() *http_loadbalancer.RouteTypeDirectResponse {
	if x, ok := m.GetChoice().(*RouteInfoType_DirectResponseRoute); ok {
		return x.DirectResponseRoute
	}
	return nil
}

func (m *RouteInfoType) GetCustomRouteObject() *http_loadbalancer.RouteTypeCustomRoute {
	if x, ok := m.GetChoice().(*RouteInfoType_CustomRouteObject); ok {
		return x.CustomRouteObject
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteInfoType_SimpleRoute)(nil),
		(*RouteInfoType_RedirectRoute)(nil),
		(*RouteInfoType_DirectResponseRoute)(nil),
		(*RouteInfoType_CustomRouteObject)(nil),
	}
}

// RouteType
//
// x-displayName: "Route Type"
// This defines various options to define a route
type RouteType struct {
	// Routes
	//
	// x-displayName: "Routes"
	// Routes for this loadbalancer
	Routes []*RouteInfoType `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
}

func (m *RouteType) Reset()      { *m = RouteType{} }
func (*RouteType) ProtoMessage() {}
func (*RouteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{25}
}
func (m *RouteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteType.Merge(m, src)
}
func (m *RouteType) XXX_Size() int {
	return m.Size()
}
func (m *RouteType) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteType.DiscardUnknown(m)
}

var xxx_messageInfo_RouteType proto.InternalMessageInfo

func (m *RouteType) GetRoutes() []*RouteInfoType {
	if m != nil {
		return m.Routes
	}
	return nil
}

// MatchAllRouteType
//
// x-displayName: "Default Route"
// Default route matching all APIs
type MatchAllRouteType struct {
	// HostRewriteParams
	//
	// x-displayName: "Select Host Rewrite for Default Route"
	// x-required
	// Select how the host header can be modified during forwarding to the default route
	//
	// Types that are valid to be assigned to HostRewriteParams:
	//	*MatchAllRouteType_AutoHostRewrite
	//	*MatchAllRouteType_HostRewrite
	//	*MatchAllRouteType_DisableHostRewrite
	HostRewriteParams isMatchAllRouteType_HostRewriteParams `protobuf_oneof:"host_rewrite_params"`
}

func (m *MatchAllRouteType) Reset()      { *m = MatchAllRouteType{} }
func (*MatchAllRouteType) ProtoMessage() {}
func (*MatchAllRouteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{26}
}
func (m *MatchAllRouteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchAllRouteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MatchAllRouteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchAllRouteType.Merge(m, src)
}
func (m *MatchAllRouteType) XXX_Size() int {
	return m.Size()
}
func (m *MatchAllRouteType) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchAllRouteType.DiscardUnknown(m)
}

var xxx_messageInfo_MatchAllRouteType proto.InternalMessageInfo

type isMatchAllRouteType_HostRewriteParams interface {
	isMatchAllRouteType_HostRewriteParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MatchAllRouteType_AutoHostRewrite struct {
	AutoHostRewrite *schema.Empty `protobuf:"bytes,2,opt,name=auto_host_rewrite,json=autoHostRewrite,proto3,oneof" json:"auto_host_rewrite,omitempty"`
}
type MatchAllRouteType_HostRewrite struct {
	HostRewrite string `protobuf:"bytes,3,opt,name=host_rewrite,json=hostRewrite,proto3,oneof" json:"host_rewrite,omitempty"`
}
type MatchAllRouteType_DisableHostRewrite struct {
	DisableHostRewrite *schema.Empty `protobuf:"bytes,4,opt,name=disable_host_rewrite,json=disableHostRewrite,proto3,oneof" json:"disable_host_rewrite,omitempty"`
}

func (*MatchAllRouteType_AutoHostRewrite) isMatchAllRouteType_HostRewriteParams()    {}
func (*MatchAllRouteType_HostRewrite) isMatchAllRouteType_HostRewriteParams()        {}
func (*MatchAllRouteType_DisableHostRewrite) isMatchAllRouteType_HostRewriteParams() {}

func (m *MatchAllRouteType) GetHostRewriteParams() isMatchAllRouteType_HostRewriteParams {
	if m != nil {
		return m.HostRewriteParams
	}
	return nil
}

func (m *MatchAllRouteType) GetAutoHostRewrite() *schema.Empty {
	if x, ok := m.GetHostRewriteParams().(*MatchAllRouteType_AutoHostRewrite); ok {
		return x.AutoHostRewrite
	}
	return nil
}

func (m *MatchAllRouteType) GetHostRewrite() string {
	if x, ok := m.GetHostRewriteParams().(*MatchAllRouteType_HostRewrite); ok {
		return x.HostRewrite
	}
	return ""
}

func (m *MatchAllRouteType) GetDisableHostRewrite() *schema.Empty {
	if x, ok := m.GetHostRewriteParams().(*MatchAllRouteType_DisableHostRewrite); ok {
		return x.DisableHostRewrite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MatchAllRouteType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MatchAllRouteType_AutoHostRewrite)(nil),
		(*MatchAllRouteType_HostRewrite)(nil),
		(*MatchAllRouteType_DisableHostRewrite)(nil),
	}
}

// HTTP/HTTPS Load balancer
//
// x-displayName: "HTTP/HTTPS Load Balancer"
//
// HTTP/HTTPS Load balancer
type HTTPLoadBalancerType struct {
	// Domains
	//
	// x-displayName: "Domains"
	// x-example: "www.foo.com"
	// x-required
	// A list of domains (host/authority header) that will be matched to loadbalancer.
	// Wildcard hosts are supported in the suffix or prefix form
	//
	// Domain search order:
	//  1. Exact domain names: ``www.foo.com``.
	//  2. Prefix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
	//  3. Special wildcard ``*`` matching any domain.
	//
	// Wildcard will not match empty string.
	// e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
	// The longest wildcards match first.
	//
	// Domains are also used for SNI matching if the loadbalancer type is HTTPS
	// Domains also indicate the list of names for which DNS resolution will be done by VER
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Proxy choice
	//
	// x-displayName: "Select Type of Load Balancer"
	// x-required
	// Type of Load Balancer can be "http" or "https"
	//
	// Types that are valid to be assigned to LoadbalancerType:
	//	*HTTPLoadBalancerType_Http
	//	*HTTPLoadBalancerType_HttpsAutoCert
	//	*HTTPLoadBalancerType_Https
	LoadbalancerType isHTTPLoadBalancerType_LoadbalancerType `protobuf_oneof:"loadbalancer_type"`
	// Route Choice
	//
	// x-displayName: "Route Configuration"
	// x-required
	// Routes for this load balancer
	//
	// Types that are valid to be assigned to RouteChoice:
	//	*HTTPLoadBalancerType_DefaultRoute
	//	*HTTPLoadBalancerType_SpecificRoutes
	RouteChoice isHTTPLoadBalancerType_RouteChoice `protobuf_oneof:"route_choice"`
}

func (m *HTTPLoadBalancerType) Reset()      { *m = HTTPLoadBalancerType{} }
func (*HTTPLoadBalancerType) ProtoMessage() {}
func (*HTTPLoadBalancerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{27}
}
func (m *HTTPLoadBalancerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPLoadBalancerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HTTPLoadBalancerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPLoadBalancerType.Merge(m, src)
}
func (m *HTTPLoadBalancerType) XXX_Size() int {
	return m.Size()
}
func (m *HTTPLoadBalancerType) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPLoadBalancerType.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPLoadBalancerType proto.InternalMessageInfo

type isHTTPLoadBalancerType_LoadbalancerType interface {
	isHTTPLoadBalancerType_LoadbalancerType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isHTTPLoadBalancerType_RouteChoice interface {
	isHTTPLoadBalancerType_RouteChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HTTPLoadBalancerType_Http struct {
	Http *http_loadbalancer.ProxyTypeHttp `protobuf:"bytes,3,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type HTTPLoadBalancerType_HttpsAutoCert struct {
	HttpsAutoCert *http_loadbalancer.ProxyTypeHttpsAutoCerts `protobuf:"bytes,4,opt,name=https_auto_cert,json=httpsAutoCert,proto3,oneof" json:"https_auto_cert,omitempty"`
}
type HTTPLoadBalancerType_Https struct {
	Https *http_loadbalancer.ProxyTypeHttps `protobuf:"bytes,5,opt,name=https,proto3,oneof" json:"https,omitempty"`
}
type HTTPLoadBalancerType_DefaultRoute struct {
	DefaultRoute *MatchAllRouteType `protobuf:"bytes,7,opt,name=default_route,json=defaultRoute,proto3,oneof" json:"default_route,omitempty"`
}
type HTTPLoadBalancerType_SpecificRoutes struct {
	SpecificRoutes *RouteType `protobuf:"bytes,8,opt,name=specific_routes,json=specificRoutes,proto3,oneof" json:"specific_routes,omitempty"`
}

func (*HTTPLoadBalancerType_Http) isHTTPLoadBalancerType_LoadbalancerType()          {}
func (*HTTPLoadBalancerType_HttpsAutoCert) isHTTPLoadBalancerType_LoadbalancerType() {}
func (*HTTPLoadBalancerType_Https) isHTTPLoadBalancerType_LoadbalancerType()         {}
func (*HTTPLoadBalancerType_DefaultRoute) isHTTPLoadBalancerType_RouteChoice()       {}
func (*HTTPLoadBalancerType_SpecificRoutes) isHTTPLoadBalancerType_RouteChoice()     {}

func (m *HTTPLoadBalancerType) GetLoadbalancerType() isHTTPLoadBalancerType_LoadbalancerType {
	if m != nil {
		return m.LoadbalancerType
	}
	return nil
}
func (m *HTTPLoadBalancerType) GetRouteChoice() isHTTPLoadBalancerType_RouteChoice {
	if m != nil {
		return m.RouteChoice
	}
	return nil
}

func (m *HTTPLoadBalancerType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *HTTPLoadBalancerType) GetHttp() *http_loadbalancer.ProxyTypeHttp {
	if x, ok := m.GetLoadbalancerType().(*HTTPLoadBalancerType_Http); ok {
		return x.Http
	}
	return nil
}

func (m *HTTPLoadBalancerType) GetHttpsAutoCert() *http_loadbalancer.ProxyTypeHttpsAutoCerts {
	if x, ok := m.GetLoadbalancerType().(*HTTPLoadBalancerType_HttpsAutoCert); ok {
		return x.HttpsAutoCert
	}
	return nil
}

func (m *HTTPLoadBalancerType) GetHttps() *http_loadbalancer.ProxyTypeHttps {
	if x, ok := m.GetLoadbalancerType().(*HTTPLoadBalancerType_Https); ok {
		return x.Https
	}
	return nil
}

func (m *HTTPLoadBalancerType) GetDefaultRoute() *MatchAllRouteType {
	if x, ok := m.GetRouteChoice().(*HTTPLoadBalancerType_DefaultRoute); ok {
		return x.DefaultRoute
	}
	return nil
}

func (m *HTTPLoadBalancerType) GetSpecificRoutes() *RouteType {
	if x, ok := m.GetRouteChoice().(*HTTPLoadBalancerType_SpecificRoutes); ok {
		return x.SpecificRoutes
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HTTPLoadBalancerType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HTTPLoadBalancerType_Http)(nil),
		(*HTTPLoadBalancerType_HttpsAutoCert)(nil),
		(*HTTPLoadBalancerType_Https)(nil),
		(*HTTPLoadBalancerType_DefaultRoute)(nil),
		(*HTTPLoadBalancerType_SpecificRoutes)(nil),
	}
}

// TCPLoadBalancerType
//
// x-displayName: "TCP Load Balancer"
// TCP loadbalancer
type TCPLoadBalancerType struct {
	// Domains
	//
	// x-displayName: "Domains"
	// x-example: "www.foo.com"
	// A list of additional domains (host/authority header) that will be matched to this loadbalancer.
	//
	// Domains are also used for SNI matching if the `with_sni` is true
	// Domains also indicate the list of names for which DNS resolution will be done by VER
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// With SNI
	//
	// x-displayName: "With SNI"
	// x-example: "true"
	// Set to true to enable TCP loadbalancer with SNI
	WithSni bool `protobuf:"varint,2,opt,name=with_sni,json=withSni,proto3" json:"with_sni,omitempty"`
}

func (m *TCPLoadBalancerType) Reset()      { *m = TCPLoadBalancerType{} }
func (*TCPLoadBalancerType) ProtoMessage() {}
func (*TCPLoadBalancerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{28}
}
func (m *TCPLoadBalancerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TCPLoadBalancerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TCPLoadBalancerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TCPLoadBalancerType.Merge(m, src)
}
func (m *TCPLoadBalancerType) XXX_Size() int {
	return m.Size()
}
func (m *TCPLoadBalancerType) XXX_DiscardUnknown() {
	xxx_messageInfo_TCPLoadBalancerType.DiscardUnknown(m)
}

var xxx_messageInfo_TCPLoadBalancerType proto.InternalMessageInfo

func (m *TCPLoadBalancerType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *TCPLoadBalancerType) GetWithSni() bool {
	if m != nil {
		return m.WithSni
	}
	return false
}

// PortInfoType
//
// x-displayName: "Port Information"
// Port information
type PortInfoType struct {
	// Port
	//
	// x-displayName: "Port"
	// x-example: "80"
	// x-required
	// Port the workload can be reached on
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// Protocol
	//
	// x-displayName: "Application Protocol"
	// Application protocol used by the workload
	Protocol ProtocolType `protobuf:"varint,2,opt,name=protocol,proto3,enum=ves.io.schema.views.workload.ProtocolType" json:"protocol,omitempty"`
	// Target Port Choice
	//
	// x-displayName: "Target Port"
	// x-required
	// Target port choice
	//
	// Types that are valid to be assigned to TargetPortChoice:
	//	*PortInfoType_SameAsPort
	//	*PortInfoType_TargetPort
	TargetPortChoice isPortInfoType_TargetPortChoice `protobuf_oneof:"target_port_choice"`
}

func (m *PortInfoType) Reset()      { *m = PortInfoType{} }
func (*PortInfoType) ProtoMessage() {}
func (*PortInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{29}
}
func (m *PortInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortInfoType.Merge(m, src)
}
func (m *PortInfoType) XXX_Size() int {
	return m.Size()
}
func (m *PortInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_PortInfoType proto.InternalMessageInfo

type isPortInfoType_TargetPortChoice interface {
	isPortInfoType_TargetPortChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PortInfoType_SameAsPort struct {
	SameAsPort *schema.Empty `protobuf:"bytes,4,opt,name=same_as_port,json=sameAsPort,proto3,oneof" json:"same_as_port,omitempty"`
}
type PortInfoType_TargetPort struct {
	TargetPort uint32 `protobuf:"varint,5,opt,name=target_port,json=targetPort,proto3,oneof" json:"target_port,omitempty"`
}

func (*PortInfoType_SameAsPort) isPortInfoType_TargetPortChoice() {}
func (*PortInfoType_TargetPort) isPortInfoType_TargetPortChoice() {}

func (m *PortInfoType) GetTargetPortChoice() isPortInfoType_TargetPortChoice {
	if m != nil {
		return m.TargetPortChoice
	}
	return nil
}

func (m *PortInfoType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortInfoType) GetProtocol() ProtocolType {
	if m != nil {
		return m.Protocol
	}
	return PROTOCOL_TCP
}

func (m *PortInfoType) GetSameAsPort() *schema.Empty {
	if x, ok := m.GetTargetPortChoice().(*PortInfoType_SameAsPort); ok {
		return x.SameAsPort
	}
	return nil
}

func (m *PortInfoType) GetTargetPort() uint32 {
	if x, ok := m.GetTargetPortChoice().(*PortInfoType_TargetPort); ok {
		return x.TargetPort
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PortInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PortInfoType_SameAsPort)(nil),
		(*PortInfoType_TargetPort)(nil),
	}
}

// PortType
//
// x-displayName: "Port"
// Port of the workload
type PortType struct {
	// Name
	//
	// x-displayName: "Name"
	// x-required
	// Name of the Port
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Port Information
	//
	// x-displayName: "Port Information"
	// x-required
	// Information of the Port
	Info *PortInfoType `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *PortType) Reset()      { *m = PortType{} }
func (*PortType) ProtoMessage() {}
func (*PortType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{30}
}
func (m *PortType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortType.Merge(m, src)
}
func (m *PortType) XXX_Size() int {
	return m.Size()
}
func (m *PortType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortType.DiscardUnknown(m)
}

var xxx_messageInfo_PortType proto.InternalMessageInfo

func (m *PortType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PortType) GetInfo() *PortInfoType {
	if m != nil {
		return m.Info
	}
	return nil
}

// MultiPortType
//
// x-displayName: "Multiple Ports"
// Multiple ports
type MultiPortType struct {
	// Ports
	//
	// x-displayName: "Ports"
	// x-required
	// Ports to advertise
	Ports []*PortType `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
}

func (m *MultiPortType) Reset()      { *m = MultiPortType{} }
func (*MultiPortType) ProtoMessage() {}
func (*MultiPortType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{31}
}
func (m *MultiPortType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiPortType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MultiPortType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiPortType.Merge(m, src)
}
func (m *MultiPortType) XXX_Size() int {
	return m.Size()
}
func (m *MultiPortType) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiPortType.DiscardUnknown(m)
}

var xxx_messageInfo_MultiPortType proto.InternalMessageInfo

func (m *MultiPortType) GetPorts() []*PortType {
	if m != nil {
		return m.Ports
	}
	return nil
}

// SinglePortType
//
// x-displayName: "Port"
// Single port
type SinglePortType struct {
	// Port Information
	//
	// x-displayName: "Port Information"
	// x-required
	// Information of the Port
	Info *PortInfoType `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *SinglePortType) Reset()      { *m = SinglePortType{} }
func (*SinglePortType) ProtoMessage() {}
func (*SinglePortType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{32}
}
func (m *SinglePortType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SinglePortType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SinglePortType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SinglePortType.Merge(m, src)
}
func (m *SinglePortType) XXX_Size() int {
	return m.Size()
}
func (m *SinglePortType) XXX_DiscardUnknown() {
	xxx_messageInfo_SinglePortType.DiscardUnknown(m)
}

var xxx_messageInfo_SinglePortType proto.InternalMessageInfo

func (m *SinglePortType) GetInfo() *PortInfoType {
	if m != nil {
		return m.Info
	}
	return nil
}

// AdvertiseInClusterType
//
// x-displayName: "Advertise In Cluster"
// Advertise the workload locally in-cluster
type AdvertiseInClusterType struct {
	// Port Choice
	//
	// x-displayName: "Select Port to Advertise"
	// x-required
	// Port Choice
	//
	// Types that are valid to be assigned to PortChoice:
	//	*AdvertiseInClusterType_Port
	//	*AdvertiseInClusterType_MultiPorts
	PortChoice isAdvertiseInClusterType_PortChoice `protobuf_oneof:"port_choice"`
}

func (m *AdvertiseInClusterType) Reset()      { *m = AdvertiseInClusterType{} }
func (*AdvertiseInClusterType) ProtoMessage() {}
func (*AdvertiseInClusterType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{33}
}
func (m *AdvertiseInClusterType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvertiseInClusterType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvertiseInClusterType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvertiseInClusterType.Merge(m, src)
}
func (m *AdvertiseInClusterType) XXX_Size() int {
	return m.Size()
}
func (m *AdvertiseInClusterType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvertiseInClusterType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvertiseInClusterType proto.InternalMessageInfo

type isAdvertiseInClusterType_PortChoice interface {
	isAdvertiseInClusterType_PortChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AdvertiseInClusterType_Port struct {
	Port *SinglePortType `protobuf:"bytes,2,opt,name=port,proto3,oneof" json:"port,omitempty"`
}
type AdvertiseInClusterType_MultiPorts struct {
	MultiPorts *MultiPortType `protobuf:"bytes,3,opt,name=multi_ports,json=multiPorts,proto3,oneof" json:"multi_ports,omitempty"`
}

func (*AdvertiseInClusterType_Port) isAdvertiseInClusterType_PortChoice()       {}
func (*AdvertiseInClusterType_MultiPorts) isAdvertiseInClusterType_PortChoice() {}

func (m *AdvertiseInClusterType) GetPortChoice() isAdvertiseInClusterType_PortChoice {
	if m != nil {
		return m.PortChoice
	}
	return nil
}

func (m *AdvertiseInClusterType) GetPort() *SinglePortType {
	if x, ok := m.GetPortChoice().(*AdvertiseInClusterType_Port); ok {
		return x.Port
	}
	return nil
}

func (m *AdvertiseInClusterType) GetMultiPorts() *MultiPortType {
	if x, ok := m.GetPortChoice().(*AdvertiseInClusterType_MultiPorts); ok {
		return x.MultiPorts
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AdvertiseInClusterType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AdvertiseInClusterType_Port)(nil),
		(*AdvertiseInClusterType_MultiPorts)(nil),
	}
}

// AdvertiseSinglePortType
//
// x-displayName: "Advertise Port"
// Advertise single port
type AdvertiseSinglePortType struct {
	// Port
	//
	// x-displayName: "Port"
	// x-required
	// Port information
	Port *SinglePortType `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"`
	// Advertise choice
	//
	// x-displayName: "Options to Advertise the workload"
	// x-required
	// This is a choice to select method to advertise the workload.
	//
	// Types that are valid to be assigned to AdvertiseChoice:
	//	*AdvertiseSinglePortType_HttpLoadbalancer
	//	*AdvertiseSinglePortType_TcpLoadbalancer
	AdvertiseChoice isAdvertiseSinglePortType_AdvertiseChoice `protobuf_oneof:"advertise_choice"`
}

func (m *AdvertiseSinglePortType) Reset()      { *m = AdvertiseSinglePortType{} }
func (*AdvertiseSinglePortType) ProtoMessage() {}
func (*AdvertiseSinglePortType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{34}
}
func (m *AdvertiseSinglePortType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvertiseSinglePortType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvertiseSinglePortType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvertiseSinglePortType.Merge(m, src)
}
func (m *AdvertiseSinglePortType) XXX_Size() int {
	return m.Size()
}
func (m *AdvertiseSinglePortType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvertiseSinglePortType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvertiseSinglePortType proto.InternalMessageInfo

type isAdvertiseSinglePortType_AdvertiseChoice interface {
	isAdvertiseSinglePortType_AdvertiseChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AdvertiseSinglePortType_HttpLoadbalancer struct {
	HttpLoadbalancer *HTTPLoadBalancerType `protobuf:"bytes,3,opt,name=http_loadbalancer,json=httpLoadbalancer,proto3,oneof" json:"http_loadbalancer,omitempty"`
}
type AdvertiseSinglePortType_TcpLoadbalancer struct {
	TcpLoadbalancer *TCPLoadBalancerType `protobuf:"bytes,4,opt,name=tcp_loadbalancer,json=tcpLoadbalancer,proto3,oneof" json:"tcp_loadbalancer,omitempty"`
}

func (*AdvertiseSinglePortType_HttpLoadbalancer) isAdvertiseSinglePortType_AdvertiseChoice() {}
func (*AdvertiseSinglePortType_TcpLoadbalancer) isAdvertiseSinglePortType_AdvertiseChoice()  {}

func (m *AdvertiseSinglePortType) GetAdvertiseChoice() isAdvertiseSinglePortType_AdvertiseChoice {
	if m != nil {
		return m.AdvertiseChoice
	}
	return nil
}

func (m *AdvertiseSinglePortType) GetPort() *SinglePortType {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *AdvertiseSinglePortType) GetHttpLoadbalancer() *HTTPLoadBalancerType {
	if x, ok := m.GetAdvertiseChoice().(*AdvertiseSinglePortType_HttpLoadbalancer); ok {
		return x.HttpLoadbalancer
	}
	return nil
}

func (m *AdvertiseSinglePortType) GetTcpLoadbalancer() *TCPLoadBalancerType {
	if x, ok := m.GetAdvertiseChoice().(*AdvertiseSinglePortType_TcpLoadbalancer); ok {
		return x.TcpLoadbalancer
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AdvertiseSinglePortType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AdvertiseSinglePortType_HttpLoadbalancer)(nil),
		(*AdvertiseSinglePortType_TcpLoadbalancer)(nil),
	}
}

// AdvertisePortType
//
// x-displayName: "Advertise Port"
// Advertise port
type AdvertisePortType struct {
	// Port
	//
	// x-displayName: "Port"
	// x-required
	// Port information
	Port *PortType `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty"`
	// Advertise choice
	//
	// x-displayName: "Options to Advertise the workload"
	// x-required
	// This is a choice to select method to advertise the workload.
	//
	// Types that are valid to be assigned to AdvertiseChoice:
	//	*AdvertisePortType_HttpLoadbalancer
	//	*AdvertisePortType_TcpLoadbalancer
	AdvertiseChoice isAdvertisePortType_AdvertiseChoice `protobuf_oneof:"advertise_choice"`
}

func (m *AdvertisePortType) Reset()      { *m = AdvertisePortType{} }
func (*AdvertisePortType) ProtoMessage() {}
func (*AdvertisePortType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{35}
}
func (m *AdvertisePortType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvertisePortType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvertisePortType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvertisePortType.Merge(m, src)
}
func (m *AdvertisePortType) XXX_Size() int {
	return m.Size()
}
func (m *AdvertisePortType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvertisePortType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvertisePortType proto.InternalMessageInfo

type isAdvertisePortType_AdvertiseChoice interface {
	isAdvertisePortType_AdvertiseChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AdvertisePortType_HttpLoadbalancer struct {
	HttpLoadbalancer *HTTPLoadBalancerType `protobuf:"bytes,3,opt,name=http_loadbalancer,json=httpLoadbalancer,proto3,oneof" json:"http_loadbalancer,omitempty"`
}
type AdvertisePortType_TcpLoadbalancer struct {
	TcpLoadbalancer *TCPLoadBalancerType `protobuf:"bytes,4,opt,name=tcp_loadbalancer,json=tcpLoadbalancer,proto3,oneof" json:"tcp_loadbalancer,omitempty"`
}

func (*AdvertisePortType_HttpLoadbalancer) isAdvertisePortType_AdvertiseChoice() {}
func (*AdvertisePortType_TcpLoadbalancer) isAdvertisePortType_AdvertiseChoice()  {}

func (m *AdvertisePortType) GetAdvertiseChoice() isAdvertisePortType_AdvertiseChoice {
	if m != nil {
		return m.AdvertiseChoice
	}
	return nil
}

func (m *AdvertisePortType) GetPort() *PortType {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *AdvertisePortType) GetHttpLoadbalancer() *HTTPLoadBalancerType {
	if x, ok := m.GetAdvertiseChoice().(*AdvertisePortType_HttpLoadbalancer); ok {
		return x.HttpLoadbalancer
	}
	return nil
}

func (m *AdvertisePortType) GetTcpLoadbalancer() *TCPLoadBalancerType {
	if x, ok := m.GetAdvertiseChoice().(*AdvertisePortType_TcpLoadbalancer); ok {
		return x.TcpLoadbalancer
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AdvertisePortType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AdvertisePortType_HttpLoadbalancer)(nil),
		(*AdvertisePortType_TcpLoadbalancer)(nil),
	}
}

// AdvertiseMultiPortType
//
// x-displayName: "Advertise Multiple Ports"
// Advertise multiple ports
type AdvertiseMultiPortType struct {
	// Ports
	//
	// x-displayName: "Ports"
	// x-required
	// Ports to advertise
	Ports []*AdvertisePortType `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
}

func (m *AdvertiseMultiPortType) Reset()      { *m = AdvertiseMultiPortType{} }
func (*AdvertiseMultiPortType) ProtoMessage() {}
func (*AdvertiseMultiPortType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{36}
}
func (m *AdvertiseMultiPortType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvertiseMultiPortType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvertiseMultiPortType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvertiseMultiPortType.Merge(m, src)
}
func (m *AdvertiseMultiPortType) XXX_Size() int {
	return m.Size()
}
func (m *AdvertiseMultiPortType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvertiseMultiPortType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvertiseMultiPortType proto.InternalMessageInfo

func (m *AdvertiseMultiPortType) GetPorts() []*AdvertisePortType {
	if m != nil {
		return m.Ports
	}
	return nil
}

// AdvertisePublicType
//
// x-displayName: "Advertise On Internet"
// Advertise this workload via loadbalancer on Internet with default VIP
type AdvertisePublicType struct {
	// Advertise Choice
	//
	// x-displayName: "Select Port to Advertise"
	// x-required
	// Advertise choice
	//
	// Types that are valid to be assigned to AdvertiseChoice:
	//	*AdvertisePublicType_Port
	//	*AdvertisePublicType_MultiPorts
	AdvertiseChoice isAdvertisePublicType_AdvertiseChoice `protobuf_oneof:"advertise_choice"`
}

func (m *AdvertisePublicType) Reset()      { *m = AdvertisePublicType{} }
func (*AdvertisePublicType) ProtoMessage() {}
func (*AdvertisePublicType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{37}
}
func (m *AdvertisePublicType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvertisePublicType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvertisePublicType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvertisePublicType.Merge(m, src)
}
func (m *AdvertisePublicType) XXX_Size() int {
	return m.Size()
}
func (m *AdvertisePublicType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvertisePublicType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvertisePublicType proto.InternalMessageInfo

type isAdvertisePublicType_AdvertiseChoice interface {
	isAdvertisePublicType_AdvertiseChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AdvertisePublicType_Port struct {
	Port *AdvertiseSinglePortType `protobuf:"bytes,2,opt,name=port,proto3,oneof" json:"port,omitempty"`
}
type AdvertisePublicType_MultiPorts struct {
	MultiPorts *AdvertiseMultiPortType `protobuf:"bytes,3,opt,name=multi_ports,json=multiPorts,proto3,oneof" json:"multi_ports,omitempty"`
}

func (*AdvertisePublicType_Port) isAdvertisePublicType_AdvertiseChoice()       {}
func (*AdvertisePublicType_MultiPorts) isAdvertisePublicType_AdvertiseChoice() {}

func (m *AdvertisePublicType) GetAdvertiseChoice() isAdvertisePublicType_AdvertiseChoice {
	if m != nil {
		return m.AdvertiseChoice
	}
	return nil
}

func (m *AdvertisePublicType) GetPort() *AdvertiseSinglePortType {
	if x, ok := m.GetAdvertiseChoice().(*AdvertisePublicType_Port); ok {
		return x.Port
	}
	return nil
}

func (m *AdvertisePublicType) GetMultiPorts() *AdvertiseMultiPortType {
	if x, ok := m.GetAdvertiseChoice().(*AdvertisePublicType_MultiPorts); ok {
		return x.MultiPorts
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AdvertisePublicType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AdvertisePublicType_Port)(nil),
		(*AdvertisePublicType_MultiPorts)(nil),
	}
}

// AdvertiseWhereType
//
// x-displayName: "Select Where to Advertise"
// This defines various options where a load balancer could be advertised
type AdvertiseWhereType struct {
	// Advertise choice
	//
	// x-displayName: "Select Where to Advertise"
	// x-required
	// This defines various options where a load balancer could be advertised
	//
	// Types that are valid to be assigned to Choice:
	//	*AdvertiseWhereType_Site
	//	*AdvertiseWhereType_VirtualSite
	//	*AdvertiseWhereType_Vk8SService
	Choice isAdvertiseWhereType_Choice `protobuf_oneof:"choice"`
}

func (m *AdvertiseWhereType) Reset()      { *m = AdvertiseWhereType{} }
func (*AdvertiseWhereType) ProtoMessage() {}
func (*AdvertiseWhereType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{38}
}
func (m *AdvertiseWhereType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvertiseWhereType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvertiseWhereType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvertiseWhereType.Merge(m, src)
}
func (m *AdvertiseWhereType) XXX_Size() int {
	return m.Size()
}
func (m *AdvertiseWhereType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvertiseWhereType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvertiseWhereType proto.InternalMessageInfo

type isAdvertiseWhereType_Choice interface {
	isAdvertiseWhereType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AdvertiseWhereType_Site struct {
	Site *views.WhereSite `protobuf:"bytes,1,opt,name=site,proto3,oneof" json:"site,omitempty"`
}
type AdvertiseWhereType_VirtualSite struct {
	VirtualSite *views.WhereVirtualSite `protobuf:"bytes,2,opt,name=virtual_site,json=virtualSite,proto3,oneof" json:"virtual_site,omitempty"`
}
type AdvertiseWhereType_Vk8SService struct {
	Vk8SService *views.WhereVK8SService `protobuf:"bytes,3,opt,name=vk8s_service,json=vk8sService,proto3,oneof" json:"vk8s_service,omitempty"`
}

func (*AdvertiseWhereType_Site) isAdvertiseWhereType_Choice()        {}
func (*AdvertiseWhereType_VirtualSite) isAdvertiseWhereType_Choice() {}
func (*AdvertiseWhereType_Vk8SService) isAdvertiseWhereType_Choice() {}

func (m *AdvertiseWhereType) GetChoice() isAdvertiseWhereType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AdvertiseWhereType) GetSite() *views.WhereSite {
	if x, ok := m.GetChoice().(*AdvertiseWhereType_Site); ok {
		return x.Site
	}
	return nil
}

func (m *AdvertiseWhereType) GetVirtualSite() *views.WhereVirtualSite {
	if x, ok := m.GetChoice().(*AdvertiseWhereType_VirtualSite); ok {
		return x.VirtualSite
	}
	return nil
}

func (m *AdvertiseWhereType) GetVk8SService() *views.WhereVK8SService {
	if x, ok := m.GetChoice().(*AdvertiseWhereType_Vk8SService); ok {
		return x.Vk8SService
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AdvertiseWhereType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AdvertiseWhereType_Site)(nil),
		(*AdvertiseWhereType_VirtualSite)(nil),
		(*AdvertiseWhereType_Vk8SService)(nil),
	}
}

// AdvertiseCustomType
//
// x-displayName: "Advertise on specific sites"
// Advertise this workload via loadbalancer on specific sites
type AdvertiseCustomType struct {
	// Ports
	//
	// x-displayName: "Ports"
	// x-required
	// Ports to advertise
	Ports []*AdvertisePortType `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
	// Advertise Where
	//
	// x-required
	// x-displayName: "List of Sites to Advertise"
	// Where should this load balancer be available
	AdvertiseWhere []*AdvertiseWhereType `protobuf:"bytes,2,rep,name=advertise_where,json=advertiseWhere,proto3" json:"advertise_where,omitempty"`
}

func (m *AdvertiseCustomType) Reset()      { *m = AdvertiseCustomType{} }
func (*AdvertiseCustomType) ProtoMessage() {}
func (*AdvertiseCustomType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{39}
}
func (m *AdvertiseCustomType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvertiseCustomType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvertiseCustomType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvertiseCustomType.Merge(m, src)
}
func (m *AdvertiseCustomType) XXX_Size() int {
	return m.Size()
}
func (m *AdvertiseCustomType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvertiseCustomType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvertiseCustomType proto.InternalMessageInfo

func (m *AdvertiseCustomType) GetPorts() []*AdvertisePortType {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *AdvertiseCustomType) GetAdvertiseWhere() []*AdvertiseWhereType {
	if m != nil {
		return m.AdvertiseWhere
	}
	return nil
}

// Advertise Options
//
// x-displayName: "Advertise Options"
//
// Advertise options are used to configure how and where to advertise the workload using load balancers
type AdvertiseOptionsType struct {
	// Advertise choice
	//
	// x-displayName: "Options to Advertise the Workload"
	// x-required
	// This is a choice to select method to advertise the workload.
	//
	// Types that are valid to be assigned to AdvertiseChoice:
	//	*AdvertiseOptionsType_AdvertiseInCluster
	//	*AdvertiseOptionsType_AdvertiseOnPublic
	//	*AdvertiseOptionsType_AdvertiseCustom
	//	*AdvertiseOptionsType_DoNotAdvertise
	AdvertiseChoice isAdvertiseOptionsType_AdvertiseChoice `protobuf_oneof:"advertise_choice"`
}

func (m *AdvertiseOptionsType) Reset()      { *m = AdvertiseOptionsType{} }
func (*AdvertiseOptionsType) ProtoMessage() {}
func (*AdvertiseOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{40}
}
func (m *AdvertiseOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvertiseOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvertiseOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvertiseOptionsType.Merge(m, src)
}
func (m *AdvertiseOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *AdvertiseOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvertiseOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvertiseOptionsType proto.InternalMessageInfo

type isAdvertiseOptionsType_AdvertiseChoice interface {
	isAdvertiseOptionsType_AdvertiseChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AdvertiseOptionsType_AdvertiseInCluster struct {
	AdvertiseInCluster *AdvertiseInClusterType `protobuf:"bytes,3,opt,name=advertise_in_cluster,json=advertiseInCluster,proto3,oneof" json:"advertise_in_cluster,omitempty"`
}
type AdvertiseOptionsType_AdvertiseOnPublic struct {
	AdvertiseOnPublic *AdvertisePublicType `protobuf:"bytes,4,opt,name=advertise_on_public,json=advertiseOnPublic,proto3,oneof" json:"advertise_on_public,omitempty"`
}
type AdvertiseOptionsType_AdvertiseCustom struct {
	AdvertiseCustom *AdvertiseCustomType `protobuf:"bytes,5,opt,name=advertise_custom,json=advertiseCustom,proto3,oneof" json:"advertise_custom,omitempty"`
}
type AdvertiseOptionsType_DoNotAdvertise struct {
	DoNotAdvertise *schema.Empty `protobuf:"bytes,6,opt,name=do_not_advertise,json=doNotAdvertise,proto3,oneof" json:"do_not_advertise,omitempty"`
}

func (*AdvertiseOptionsType_AdvertiseInCluster) isAdvertiseOptionsType_AdvertiseChoice() {}
func (*AdvertiseOptionsType_AdvertiseOnPublic) isAdvertiseOptionsType_AdvertiseChoice()  {}
func (*AdvertiseOptionsType_AdvertiseCustom) isAdvertiseOptionsType_AdvertiseChoice()    {}
func (*AdvertiseOptionsType_DoNotAdvertise) isAdvertiseOptionsType_AdvertiseChoice()     {}

func (m *AdvertiseOptionsType) GetAdvertiseChoice() isAdvertiseOptionsType_AdvertiseChoice {
	if m != nil {
		return m.AdvertiseChoice
	}
	return nil
}

func (m *AdvertiseOptionsType) GetAdvertiseInCluster() *AdvertiseInClusterType {
	if x, ok := m.GetAdvertiseChoice().(*AdvertiseOptionsType_AdvertiseInCluster); ok {
		return x.AdvertiseInCluster
	}
	return nil
}

func (m *AdvertiseOptionsType) GetAdvertiseOnPublic() *AdvertisePublicType {
	if x, ok := m.GetAdvertiseChoice().(*AdvertiseOptionsType_AdvertiseOnPublic); ok {
		return x.AdvertiseOnPublic
	}
	return nil
}

func (m *AdvertiseOptionsType) GetAdvertiseCustom() *AdvertiseCustomType {
	if x, ok := m.GetAdvertiseChoice().(*AdvertiseOptionsType_AdvertiseCustom); ok {
		return x.AdvertiseCustom
	}
	return nil
}

func (m *AdvertiseOptionsType) GetDoNotAdvertise() *schema.Empty {
	if x, ok := m.GetAdvertiseChoice().(*AdvertiseOptionsType_DoNotAdvertise); ok {
		return x.DoNotAdvertise
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AdvertiseOptionsType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AdvertiseOptionsType_AdvertiseInCluster)(nil),
		(*AdvertiseOptionsType_AdvertiseOnPublic)(nil),
		(*AdvertiseOptionsType_AdvertiseCustom)(nil),
		(*AdvertiseOptionsType_DoNotAdvertise)(nil),
	}
}

// AdvertiseSimpleServiceType
//
// x-displayName: "Advertise Options For Simple Service"
// Advertise options for Simple Service
type AdvertiseSimpleServiceType struct {
	// Domains
	//
	// x-displayName: "Domains"
	// x-example: "www.foo.com"
	// x-required
	// A list of domains (host/authority header) that will be matched to loadbalancer.
	// Wildcard hosts are supported in the suffix or prefix form
	//
	// Domain search order:
	//  1. Exact domain names: ``www.foo.com``.
	//  2. Prefix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
	//  3. Special wildcard ``*`` matching any domain.
	//
	// Wildcard will not match empty string.
	// e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
	// The longest wildcards match first.
	//
	// Domains are also used for SNI matching if the loadbalancer type is HTTPS
	// Domains also indicate the list of names for which DNS resolution will be done by VER
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Service Port
	//
	// x-displayName: "Service Port"
	// x-required
	// Service port to advertise on Internet via HTTP loadbalancer using port 80
	ServicePort uint32 `protobuf:"varint,2,opt,name=service_port,json=servicePort,proto3" json:"service_port,omitempty"`
}

func (m *AdvertiseSimpleServiceType) Reset()      { *m = AdvertiseSimpleServiceType{} }
func (*AdvertiseSimpleServiceType) ProtoMessage() {}
func (*AdvertiseSimpleServiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{41}
}
func (m *AdvertiseSimpleServiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvertiseSimpleServiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvertiseSimpleServiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvertiseSimpleServiceType.Merge(m, src)
}
func (m *AdvertiseSimpleServiceType) XXX_Size() int {
	return m.Size()
}
func (m *AdvertiseSimpleServiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvertiseSimpleServiceType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvertiseSimpleServiceType proto.InternalMessageInfo

func (m *AdvertiseSimpleServiceType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *AdvertiseSimpleServiceType) GetServicePort() uint32 {
	if m != nil {
		return m.ServicePort
	}
	return 0
}

// SimpleService is a service having one container and one replica that is
// deployed on all Regional Edges and advertised on Internet via HTTP loadbalancer
// on default VIP
type SimpleServiceType struct {
	// Container
	//
	// x-displayName: "Container Information"
	// x-required
	// Container information
	Container *ContainerType `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	// Configuration Parameters
	//
	// x-displayName: "Configuration Parameters"
	// Configuration parameters for the service
	Configuration *ConfigurationParametersType `protobuf:"bytes,2,opt,name=configuration,proto3" json:"configuration,omitempty"`
	// Advertise
	//
	// x-displayName: "Select Advertise Options"
	// x-required
	// Advertise choice
	//
	// Types that are valid to be assigned to AdvertiseChoice:
	//	*SimpleServiceType_DoNotAdvertise
	//	*SimpleServiceType_ServicePort
	//	*SimpleServiceType_SimpleAdvertise
	AdvertiseChoice isSimpleServiceType_AdvertiseChoice `protobuf_oneof:"advertise_choice"`
	// Persistence
	//
	// x-displayName: "Persistent Storage"
	// x-required
	// Configure persistent storage
	//
	// Types that are valid to be assigned to PersistenceChoice:
	//	*SimpleServiceType_Disabled
	//	*SimpleServiceType_Enabled
	PersistenceChoice isSimpleServiceType_PersistenceChoice `protobuf_oneof:"persistence_choice"`
	// Scale down to zero
	//
	// x-displayName: "Scale Down to Zero"
	// Scale down replicas of the service to zero
	ScaleToZero bool `protobuf:"varint,10,opt,name=scale_to_zero,json=scaleToZero,proto3" json:"scale_to_zero,omitempty"`
}

func (m *SimpleServiceType) Reset()      { *m = SimpleServiceType{} }
func (*SimpleServiceType) ProtoMessage() {}
func (*SimpleServiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{42}
}
func (m *SimpleServiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleServiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SimpleServiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleServiceType.Merge(m, src)
}
func (m *SimpleServiceType) XXX_Size() int {
	return m.Size()
}
func (m *SimpleServiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleServiceType.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleServiceType proto.InternalMessageInfo

type isSimpleServiceType_AdvertiseChoice interface {
	isSimpleServiceType_AdvertiseChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isSimpleServiceType_PersistenceChoice interface {
	isSimpleServiceType_PersistenceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SimpleServiceType_DoNotAdvertise struct {
	DoNotAdvertise *schema.Empty `protobuf:"bytes,4,opt,name=do_not_advertise,json=doNotAdvertise,proto3,oneof" json:"do_not_advertise,omitempty"`
}
type SimpleServiceType_ServicePort struct {
	ServicePort uint32 `protobuf:"varint,5,opt,name=service_port,json=servicePort,proto3,oneof" json:"service_port,omitempty"`
}
type SimpleServiceType_SimpleAdvertise struct {
	SimpleAdvertise *AdvertiseSimpleServiceType `protobuf:"bytes,9,opt,name=simple_advertise,json=simpleAdvertise,proto3,oneof" json:"simple_advertise,omitempty"`
}
type SimpleServiceType_Disabled struct {
	Disabled *schema.Empty `protobuf:"bytes,7,opt,name=disabled,proto3,oneof" json:"disabled,omitempty"`
}
type SimpleServiceType_Enabled struct {
	Enabled *PersistentVolumeType `protobuf:"bytes,8,opt,name=enabled,proto3,oneof" json:"enabled,omitempty"`
}

func (*SimpleServiceType_DoNotAdvertise) isSimpleServiceType_AdvertiseChoice()  {}
func (*SimpleServiceType_ServicePort) isSimpleServiceType_AdvertiseChoice()     {}
func (*SimpleServiceType_SimpleAdvertise) isSimpleServiceType_AdvertiseChoice() {}
func (*SimpleServiceType_Disabled) isSimpleServiceType_PersistenceChoice()      {}
func (*SimpleServiceType_Enabled) isSimpleServiceType_PersistenceChoice()       {}

func (m *SimpleServiceType) GetAdvertiseChoice() isSimpleServiceType_AdvertiseChoice {
	if m != nil {
		return m.AdvertiseChoice
	}
	return nil
}
func (m *SimpleServiceType) GetPersistenceChoice() isSimpleServiceType_PersistenceChoice {
	if m != nil {
		return m.PersistenceChoice
	}
	return nil
}

func (m *SimpleServiceType) GetContainer() *ContainerType {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *SimpleServiceType) GetConfiguration() *ConfigurationParametersType {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *SimpleServiceType) GetDoNotAdvertise() *schema.Empty {
	if x, ok := m.GetAdvertiseChoice().(*SimpleServiceType_DoNotAdvertise); ok {
		return x.DoNotAdvertise
	}
	return nil
}

func (m *SimpleServiceType) GetServicePort() uint32 {
	if x, ok := m.GetAdvertiseChoice().(*SimpleServiceType_ServicePort); ok {
		return x.ServicePort
	}
	return 0
}

func (m *SimpleServiceType) GetSimpleAdvertise() *AdvertiseSimpleServiceType {
	if x, ok := m.GetAdvertiseChoice().(*SimpleServiceType_SimpleAdvertise); ok {
		return x.SimpleAdvertise
	}
	return nil
}

func (m *SimpleServiceType) GetDisabled() *schema.Empty {
	if x, ok := m.GetPersistenceChoice().(*SimpleServiceType_Disabled); ok {
		return x.Disabled
	}
	return nil
}

func (m *SimpleServiceType) GetEnabled() *PersistentVolumeType {
	if x, ok := m.GetPersistenceChoice().(*SimpleServiceType_Enabled); ok {
		return x.Enabled
	}
	return nil
}

func (m *SimpleServiceType) GetScaleToZero() bool {
	if m != nil {
		return m.ScaleToZero
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SimpleServiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SimpleServiceType_DoNotAdvertise)(nil),
		(*SimpleServiceType_ServicePort)(nil),
		(*SimpleServiceType_SimpleAdvertise)(nil),
		(*SimpleServiceType_Disabled)(nil),
		(*SimpleServiceType_Enabled)(nil),
	}
}

// Service does not maintain per replica state, however it can be configured to use persistent
// storage that is shared amongst all the replicas. Replicas of a service are fungible and do
// not have a stable network identity or storage. Common examples of services are web servers,
// application servers, traditional SQL databases, etc.
type ServiceType struct {
	// Scaling Choice
	//
	// x-displayName: "Select Scaling"
	// x-required
	// Select scaling
	//
	// Types that are valid to be assigned to ScalingChoice:
	//	*ServiceType_NumReplicas
	//	*ServiceType_ScaleToZero
	ScalingChoice isServiceType_ScalingChoice `protobuf_oneof:"scaling_choice"`
	// Containers
	//
	// x-displayName: "Containers"
	// x-required
	// Containers to use for service
	Containers []*ContainerType `protobuf:"bytes,2,rep,name=containers,proto3" json:"containers,omitempty"`
	// Volumes
	//
	// x-displayName: "Volumes"
	// Volumes for the service
	Volumes []*StorageVolumeType `protobuf:"bytes,3,rep,name=volumes,proto3" json:"volumes,omitempty"`
	// Configuration Parameters
	//
	// x-displayName: "Configuration Parameters"
	// Configuration parameters for the service
	Configuration *ConfigurationParametersType `protobuf:"bytes,4,opt,name=configuration,proto3" json:"configuration,omitempty"`
	// Deploy Options
	//
	// x-displayName: "Deploy Options"
	// x-required
	// Deploy options for the service are used to decide where and how to deploy the service
	DeployOptions *DeployOptionsType `protobuf:"bytes,5,opt,name=deploy_options,json=deployOptions,proto3" json:"deploy_options,omitempty"`
	// Advertise Options
	//
	// x-displayName: "Advertise Options"
	// x-required
	// Advertise options for the service control how the service is advertised
	AdvertiseOptions *AdvertiseOptionsType `protobuf:"bytes,6,opt,name=advertise_options,json=advertiseOptions,proto3" json:"advertise_options,omitempty"`
}

func (m *ServiceType) Reset()      { *m = ServiceType{} }
func (*ServiceType) ProtoMessage() {}
func (*ServiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{43}
}
func (m *ServiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ServiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceType.Merge(m, src)
}
func (m *ServiceType) XXX_Size() int {
	return m.Size()
}
func (m *ServiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceType.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceType proto.InternalMessageInfo

type isServiceType_ScalingChoice interface {
	isServiceType_ScalingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ServiceType_NumReplicas struct {
	NumReplicas int32 `protobuf:"varint,1,opt,name=num_replicas,json=numReplicas,proto3,oneof" json:"num_replicas,omitempty"`
}
type ServiceType_ScaleToZero struct {
	ScaleToZero *schema.Empty `protobuf:"bytes,8,opt,name=scale_to_zero,json=scaleToZero,proto3,oneof" json:"scale_to_zero,omitempty"`
}

func (*ServiceType_NumReplicas) isServiceType_ScalingChoice() {}
func (*ServiceType_ScaleToZero) isServiceType_ScalingChoice() {}

func (m *ServiceType) GetScalingChoice() isServiceType_ScalingChoice {
	if m != nil {
		return m.ScalingChoice
	}
	return nil
}

func (m *ServiceType) GetNumReplicas() int32 {
	if x, ok := m.GetScalingChoice().(*ServiceType_NumReplicas); ok {
		return x.NumReplicas
	}
	return 0
}

func (m *ServiceType) GetScaleToZero() *schema.Empty {
	if x, ok := m.GetScalingChoice().(*ServiceType_ScaleToZero); ok {
		return x.ScaleToZero
	}
	return nil
}

func (m *ServiceType) GetContainers() []*ContainerType {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *ServiceType) GetVolumes() []*StorageVolumeType {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *ServiceType) GetConfiguration() *ConfigurationParametersType {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *ServiceType) GetDeployOptions() *DeployOptionsType {
	if m != nil {
		return m.DeployOptions
	}
	return nil
}

func (m *ServiceType) GetAdvertiseOptions() *AdvertiseOptionsType {
	if m != nil {
		return m.AdvertiseOptions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ServiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ServiceType_NumReplicas)(nil),
		(*ServiceType_ScaleToZero)(nil),
	}
}

// StatefulService maintains per replica state and each replica has its own persistent storage. Each replica
// has a unique network identity and stable storage. Stateful service are used for distributed stateful
// applications like cassandra, mongodb, redis, etc.
type StatefulServiceType struct {
	// Scaling Choice
	//
	// x-displayName: "Select Scaling"
	// x-required
	// Select scaling
	//
	// Types that are valid to be assigned to ScalingChoice:
	//	*StatefulServiceType_NumReplicas
	//	*StatefulServiceType_ScaleToZero
	ScalingChoice isStatefulServiceType_ScalingChoice `protobuf_oneof:"scaling_choice"`
	// Containers
	//
	// x-displayName: "Containers"
	// x-required
	// Containers to use for service
	Containers []*ContainerType `protobuf:"bytes,2,rep,name=containers,proto3" json:"containers,omitempty"`
	// Persistence
	//
	// x-displayName: "Persistent Storage Configuration"
	// x-required
	// Persistent storage configuration for the service
	PersistentVolumes []*PersistentVolumeType `protobuf:"bytes,3,rep,name=persistent_volumes,json=persistentVolumes,proto3" json:"persistent_volumes,omitempty"`
	// Ephemeral Storage Volumes
	//
	// x-displayName: "Ephemeral Volumes"
	// Ephemeral volumes for the service
	Volumes []*EphemeralStorageVolumeType `protobuf:"bytes,4,rep,name=volumes,proto3" json:"volumes,omitempty"`
	// Configuration Parameters
	//
	// x-displayName: "Configuration Parameters"
	// Configuration parameters for the service
	Configuration *ConfigurationParametersType `protobuf:"bytes,5,opt,name=configuration,proto3" json:"configuration,omitempty"`
	// Deploy Options
	//
	// x-displayName: "Deploy Options"
	// x-required
	// Deploy options for the service are used to decide where and how to deploy the service
	DeployOptions *DeployOptionsType `protobuf:"bytes,6,opt,name=deploy_options,json=deployOptions,proto3" json:"deploy_options,omitempty"`
	// Advertise Options
	//
	// x-displayName: "Advertise Options"
	// x-required
	// Advertise options for the service control how the service is advertised
	AdvertiseOptions *AdvertiseOptionsType `protobuf:"bytes,7,opt,name=advertise_options,json=advertiseOptions,proto3" json:"advertise_options,omitempty"`
}

func (m *StatefulServiceType) Reset()      { *m = StatefulServiceType{} }
func (*StatefulServiceType) ProtoMessage() {}
func (*StatefulServiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{44}
}
func (m *StatefulServiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulServiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatefulServiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulServiceType.Merge(m, src)
}
func (m *StatefulServiceType) XXX_Size() int {
	return m.Size()
}
func (m *StatefulServiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulServiceType.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulServiceType proto.InternalMessageInfo

type isStatefulServiceType_ScalingChoice interface {
	isStatefulServiceType_ScalingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StatefulServiceType_NumReplicas struct {
	NumReplicas int32 `protobuf:"varint,1,opt,name=num_replicas,json=numReplicas,proto3,oneof" json:"num_replicas,omitempty"`
}
type StatefulServiceType_ScaleToZero struct {
	ScaleToZero *schema.Empty `protobuf:"bytes,9,opt,name=scale_to_zero,json=scaleToZero,proto3,oneof" json:"scale_to_zero,omitempty"`
}

func (*StatefulServiceType_NumReplicas) isStatefulServiceType_ScalingChoice() {}
func (*StatefulServiceType_ScaleToZero) isStatefulServiceType_ScalingChoice() {}

func (m *StatefulServiceType) GetScalingChoice() isStatefulServiceType_ScalingChoice {
	if m != nil {
		return m.ScalingChoice
	}
	return nil
}

func (m *StatefulServiceType) GetNumReplicas() int32 {
	if x, ok := m.GetScalingChoice().(*StatefulServiceType_NumReplicas); ok {
		return x.NumReplicas
	}
	return 0
}

func (m *StatefulServiceType) GetScaleToZero() *schema.Empty {
	if x, ok := m.GetScalingChoice().(*StatefulServiceType_ScaleToZero); ok {
		return x.ScaleToZero
	}
	return nil
}

func (m *StatefulServiceType) GetContainers() []*ContainerType {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *StatefulServiceType) GetPersistentVolumes() []*PersistentVolumeType {
	if m != nil {
		return m.PersistentVolumes
	}
	return nil
}

func (m *StatefulServiceType) GetVolumes() []*EphemeralStorageVolumeType {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *StatefulServiceType) GetConfiguration() *ConfigurationParametersType {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *StatefulServiceType) GetDeployOptions() *DeployOptionsType {
	if m != nil {
		return m.DeployOptions
	}
	return nil
}

func (m *StatefulServiceType) GetAdvertiseOptions() *AdvertiseOptionsType {
	if m != nil {
		return m.AdvertiseOptions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StatefulServiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StatefulServiceType_NumReplicas)(nil),
		(*StatefulServiceType_ScaleToZero)(nil),
	}
}

// Jobs are used for running batch processing tasks and run to completion. Jobs are generally used for tasks
// like report generation, billing, parallel data processing, ETL processing, etc.
type JobType struct {
	// Number of Replicas
	//
	// x-example: "2"
	// x-displayName: "Number of Replicas"
	// Number of replicas of the batch job to spawn per site
	NumReplicas int32 `protobuf:"varint,1,opt,name=num_replicas,json=numReplicas,proto3" json:"num_replicas,omitempty"`
	// Containers
	//
	// x-displayName: "Containers"
	// x-required
	// Containers to use for the job
	Containers []*ContainerType `protobuf:"bytes,2,rep,name=containers,proto3" json:"containers,omitempty"`
	// Volumes
	//
	// x-displayName: "Volumes"
	// Volumes for the job
	Volumes []*StorageVolumeType `protobuf:"bytes,3,rep,name=volumes,proto3" json:"volumes,omitempty"`
	// Configuration Parameters
	//
	// x-displayName: "Configuration Parameters"
	// Configuration parameters for the job
	Configuration *ConfigurationParametersType `protobuf:"bytes,4,opt,name=configuration,proto3" json:"configuration,omitempty"`
	// Deploy Options
	//
	// x-displayName: "Deploy Options"
	// x-required
	// Deploy options for the job are used to decide where and how to deploy the job
	DeployOptions *DeployOptionsType `protobuf:"bytes,5,opt,name=deploy_options,json=deployOptions,proto3" json:"deploy_options,omitempty"`
}

func (m *JobType) Reset()      { *m = JobType{} }
func (*JobType) ProtoMessage() {}
func (*JobType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{45}
}
func (m *JobType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobType.Merge(m, src)
}
func (m *JobType) XXX_Size() int {
	return m.Size()
}
func (m *JobType) XXX_DiscardUnknown() {
	xxx_messageInfo_JobType.DiscardUnknown(m)
}

var xxx_messageInfo_JobType proto.InternalMessageInfo

func (m *JobType) GetNumReplicas() int32 {
	if m != nil {
		return m.NumReplicas
	}
	return 0
}

func (m *JobType) GetContainers() []*ContainerType {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *JobType) GetVolumes() []*StorageVolumeType {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *JobType) GetConfiguration() *ConfigurationParametersType {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *JobType) GetDeployOptions() *DeployOptionsType {
	if m != nil {
		return m.DeployOptions
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Specification for Workload
type GlobalSpecType struct {
	// Workload Choice
	//
	// x-displayName: "Select Type of Workload"
	// x-required
	// Workload choice
	//
	// Types that are valid to be assigned to WorkloadChoice:
	//	*GlobalSpecType_SimpleService
	//	*GlobalSpecType_Service
	//	*GlobalSpecType_StatefulService
	//	*GlobalSpecType_Job
	WorkloadChoice isGlobalSpecType_WorkloadChoice `protobuf_oneof:"workload_choice"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal,proto3" json:"view_internal,omitempty"`
	// virtual_k8s
	//
	// x-displayName: "vK8S"
	// Reference to virtual K8s object
	VirtualK8S *views.ObjectRefType `protobuf:"bytes,1001,opt,name=virtual_k8s,json=virtualK8s,proto3" json:"virtual_k8s,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{46}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_WorkloadChoice interface {
	isGlobalSpecType_WorkloadChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_SimpleService struct {
	SimpleService *SimpleServiceType `protobuf:"bytes,2,opt,name=simple_service,json=simpleService,proto3,oneof" json:"simple_service,omitempty"`
}
type GlobalSpecType_Service struct {
	Service *ServiceType `protobuf:"bytes,3,opt,name=service,proto3,oneof" json:"service,omitempty"`
}
type GlobalSpecType_StatefulService struct {
	StatefulService *StatefulServiceType `protobuf:"bytes,4,opt,name=stateful_service,json=statefulService,proto3,oneof" json:"stateful_service,omitempty"`
}
type GlobalSpecType_Job struct {
	Job *JobType `protobuf:"bytes,5,opt,name=job,proto3,oneof" json:"job,omitempty"`
}

func (*GlobalSpecType_SimpleService) isGlobalSpecType_WorkloadChoice()   {}
func (*GlobalSpecType_Service) isGlobalSpecType_WorkloadChoice()         {}
func (*GlobalSpecType_StatefulService) isGlobalSpecType_WorkloadChoice() {}
func (*GlobalSpecType_Job) isGlobalSpecType_WorkloadChoice()             {}

func (m *GlobalSpecType) GetWorkloadChoice() isGlobalSpecType_WorkloadChoice {
	if m != nil {
		return m.WorkloadChoice
	}
	return nil
}

func (m *GlobalSpecType) GetSimpleService() *SimpleServiceType {
	if x, ok := m.GetWorkloadChoice().(*GlobalSpecType_SimpleService); ok {
		return x.SimpleService
	}
	return nil
}

func (m *GlobalSpecType) GetService() *ServiceType {
	if x, ok := m.GetWorkloadChoice().(*GlobalSpecType_Service); ok {
		return x.Service
	}
	return nil
}

func (m *GlobalSpecType) GetStatefulService() *StatefulServiceType {
	if x, ok := m.GetWorkloadChoice().(*GlobalSpecType_StatefulService); ok {
		return x.StatefulService
	}
	return nil
}

func (m *GlobalSpecType) GetJob() *JobType {
	if x, ok := m.GetWorkloadChoice().(*GlobalSpecType_Job); ok {
		return x.Job
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

func (m *GlobalSpecType) GetVirtualK8S() *views.ObjectRefType {
	if m != nil {
		return m.VirtualK8S
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_SimpleService)(nil),
		(*GlobalSpecType_Service)(nil),
		(*GlobalSpecType_StatefulService)(nil),
		(*GlobalSpecType_Job)(nil),
	}
}

// CreateSpecType
//
// x-displayName: "Create Workload"
// Shape of Workload
type CreateSpecType struct {
	// Workload Choice
	//
	// Types that are valid to be assigned to WorkloadChoice:
	//	*CreateSpecType_SimpleService
	//	*CreateSpecType_Service
	//	*CreateSpecType_StatefulService
	//	*CreateSpecType_Job
	WorkloadChoice isCreateSpecType_WorkloadChoice `protobuf_oneof:"workload_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{47}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_WorkloadChoice interface {
	isCreateSpecType_WorkloadChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_SimpleService struct {
	SimpleService *SimpleServiceType `protobuf:"bytes,2,opt,name=simple_service,json=simpleService,proto3,oneof" json:"simple_service,omitempty"`
}
type CreateSpecType_Service struct {
	Service *ServiceType `protobuf:"bytes,3,opt,name=service,proto3,oneof" json:"service,omitempty"`
}
type CreateSpecType_StatefulService struct {
	StatefulService *StatefulServiceType `protobuf:"bytes,4,opt,name=stateful_service,json=statefulService,proto3,oneof" json:"stateful_service,omitempty"`
}
type CreateSpecType_Job struct {
	Job *JobType `protobuf:"bytes,5,opt,name=job,proto3,oneof" json:"job,omitempty"`
}

func (*CreateSpecType_SimpleService) isCreateSpecType_WorkloadChoice()   {}
func (*CreateSpecType_Service) isCreateSpecType_WorkloadChoice()         {}
func (*CreateSpecType_StatefulService) isCreateSpecType_WorkloadChoice() {}
func (*CreateSpecType_Job) isCreateSpecType_WorkloadChoice()             {}

func (m *CreateSpecType) GetWorkloadChoice() isCreateSpecType_WorkloadChoice {
	if m != nil {
		return m.WorkloadChoice
	}
	return nil
}

func (m *CreateSpecType) GetSimpleService() *SimpleServiceType {
	if x, ok := m.GetWorkloadChoice().(*CreateSpecType_SimpleService); ok {
		return x.SimpleService
	}
	return nil
}

func (m *CreateSpecType) GetService() *ServiceType {
	if x, ok := m.GetWorkloadChoice().(*CreateSpecType_Service); ok {
		return x.Service
	}
	return nil
}

func (m *CreateSpecType) GetStatefulService() *StatefulServiceType {
	if x, ok := m.GetWorkloadChoice().(*CreateSpecType_StatefulService); ok {
		return x.StatefulService
	}
	return nil
}

func (m *CreateSpecType) GetJob() *JobType {
	if x, ok := m.GetWorkloadChoice().(*CreateSpecType_Job); ok {
		return x.Job
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_SimpleService)(nil),
		(*CreateSpecType_Service)(nil),
		(*CreateSpecType_StatefulService)(nil),
		(*CreateSpecType_Job)(nil),
	}
}

// ReplaceSpecType
//
// x-displayName: "Replace Workload"
// Shape of Workload
type ReplaceSpecType struct {
	// Workload Choice
	//
	// Types that are valid to be assigned to WorkloadChoice:
	//	*ReplaceSpecType_SimpleService
	//	*ReplaceSpecType_Service
	//	*ReplaceSpecType_StatefulService
	//	*ReplaceSpecType_Job
	WorkloadChoice isReplaceSpecType_WorkloadChoice `protobuf_oneof:"workload_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{48}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_WorkloadChoice interface {
	isReplaceSpecType_WorkloadChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_SimpleService struct {
	SimpleService *SimpleServiceType `protobuf:"bytes,2,opt,name=simple_service,json=simpleService,proto3,oneof" json:"simple_service,omitempty"`
}
type ReplaceSpecType_Service struct {
	Service *ServiceType `protobuf:"bytes,3,opt,name=service,proto3,oneof" json:"service,omitempty"`
}
type ReplaceSpecType_StatefulService struct {
	StatefulService *StatefulServiceType `protobuf:"bytes,4,opt,name=stateful_service,json=statefulService,proto3,oneof" json:"stateful_service,omitempty"`
}
type ReplaceSpecType_Job struct {
	Job *JobType `protobuf:"bytes,5,opt,name=job,proto3,oneof" json:"job,omitempty"`
}

func (*ReplaceSpecType_SimpleService) isReplaceSpecType_WorkloadChoice()   {}
func (*ReplaceSpecType_Service) isReplaceSpecType_WorkloadChoice()         {}
func (*ReplaceSpecType_StatefulService) isReplaceSpecType_WorkloadChoice() {}
func (*ReplaceSpecType_Job) isReplaceSpecType_WorkloadChoice()             {}

func (m *ReplaceSpecType) GetWorkloadChoice() isReplaceSpecType_WorkloadChoice {
	if m != nil {
		return m.WorkloadChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetSimpleService() *SimpleServiceType {
	if x, ok := m.GetWorkloadChoice().(*ReplaceSpecType_SimpleService); ok {
		return x.SimpleService
	}
	return nil
}

func (m *ReplaceSpecType) GetService() *ServiceType {
	if x, ok := m.GetWorkloadChoice().(*ReplaceSpecType_Service); ok {
		return x.Service
	}
	return nil
}

func (m *ReplaceSpecType) GetStatefulService() *StatefulServiceType {
	if x, ok := m.GetWorkloadChoice().(*ReplaceSpecType_StatefulService); ok {
		return x.StatefulService
	}
	return nil
}

func (m *ReplaceSpecType) GetJob() *JobType {
	if x, ok := m.GetWorkloadChoice().(*ReplaceSpecType_Job); ok {
		return x.Job
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_SimpleService)(nil),
		(*ReplaceSpecType_Service)(nil),
		(*ReplaceSpecType_StatefulService)(nil),
		(*ReplaceSpecType_Job)(nil),
	}
}

// GetSpecType
//
// x-displayName: "Get Workload"
// Shape of Workload
type GetSpecType struct {
	// Workload Choice
	//
	// Types that are valid to be assigned to WorkloadChoice:
	//	*GetSpecType_SimpleService
	//	*GetSpecType_Service
	//	*GetSpecType_StatefulService
	//	*GetSpecType_Job
	WorkloadChoice isGetSpecType_WorkloadChoice `protobuf_oneof:"workload_choice"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9adbda8cf19677b4, []int{49}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_WorkloadChoice interface {
	isGetSpecType_WorkloadChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_SimpleService struct {
	SimpleService *SimpleServiceType `protobuf:"bytes,2,opt,name=simple_service,json=simpleService,proto3,oneof" json:"simple_service,omitempty"`
}
type GetSpecType_Service struct {
	Service *ServiceType `protobuf:"bytes,3,opt,name=service,proto3,oneof" json:"service,omitempty"`
}
type GetSpecType_StatefulService struct {
	StatefulService *StatefulServiceType `protobuf:"bytes,4,opt,name=stateful_service,json=statefulService,proto3,oneof" json:"stateful_service,omitempty"`
}
type GetSpecType_Job struct {
	Job *JobType `protobuf:"bytes,5,opt,name=job,proto3,oneof" json:"job,omitempty"`
}

func (*GetSpecType_SimpleService) isGetSpecType_WorkloadChoice()   {}
func (*GetSpecType_Service) isGetSpecType_WorkloadChoice()         {}
func (*GetSpecType_StatefulService) isGetSpecType_WorkloadChoice() {}
func (*GetSpecType_Job) isGetSpecType_WorkloadChoice()             {}

func (m *GetSpecType) GetWorkloadChoice() isGetSpecType_WorkloadChoice {
	if m != nil {
		return m.WorkloadChoice
	}
	return nil
}

func (m *GetSpecType) GetSimpleService() *SimpleServiceType {
	if x, ok := m.GetWorkloadChoice().(*GetSpecType_SimpleService); ok {
		return x.SimpleService
	}
	return nil
}

func (m *GetSpecType) GetService() *ServiceType {
	if x, ok := m.GetWorkloadChoice().(*GetSpecType_Service); ok {
		return x.Service
	}
	return nil
}

func (m *GetSpecType) GetStatefulService() *StatefulServiceType {
	if x, ok := m.GetWorkloadChoice().(*GetSpecType_StatefulService); ok {
		return x.StatefulService
	}
	return nil
}

func (m *GetSpecType) GetJob() *JobType {
	if x, ok := m.GetWorkloadChoice().(*GetSpecType_Job); ok {
		return x.Job
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_SimpleService)(nil),
		(*GetSpecType_Service)(nil),
		(*GetSpecType_StatefulService)(nil),
		(*GetSpecType_Job)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.views.workload.VolumeMountModeType", VolumeMountModeType_name, VolumeMountModeType_value)
	golang_proto.RegisterEnum("ves.io.schema.views.workload.VolumeMountModeType", VolumeMountModeType_name, VolumeMountModeType_value)
	proto.RegisterEnum("ves.io.schema.views.workload.PersistentStorageAccessModeType", PersistentStorageAccessModeType_name, PersistentStorageAccessModeType_value)
	golang_proto.RegisterEnum("ves.io.schema.views.workload.PersistentStorageAccessModeType", PersistentStorageAccessModeType_name, PersistentStorageAccessModeType_value)
	proto.RegisterEnum("ves.io.schema.views.workload.ImagePullPolicyType", ImagePullPolicyType_name, ImagePullPolicyType_value)
	golang_proto.RegisterEnum("ves.io.schema.views.workload.ImagePullPolicyType", ImagePullPolicyType_name, ImagePullPolicyType_value)
	proto.RegisterEnum("ves.io.schema.views.workload.ContainerFlavorType", ContainerFlavorType_name, ContainerFlavorType_value)
	golang_proto.RegisterEnum("ves.io.schema.views.workload.ContainerFlavorType", ContainerFlavorType_name, ContainerFlavorType_value)
	proto.RegisterEnum("ves.io.schema.views.workload.ProtocolType", ProtocolType_name, ProtocolType_value)
	golang_proto.RegisterEnum("ves.io.schema.views.workload.ProtocolType", ProtocolType_name, ProtocolType_value)
	proto.RegisterType((*VolumeMountType)(nil), "ves.io.schema.views.workload.VolumeMountType")
	golang_proto.RegisterType((*VolumeMountType)(nil), "ves.io.schema.views.workload.VolumeMountType")
	proto.RegisterType((*ConfigurationFileType)(nil), "ves.io.schema.views.workload.ConfigurationFileType")
	golang_proto.RegisterType((*ConfigurationFileType)(nil), "ves.io.schema.views.workload.ConfigurationFileType")
	proto.RegisterType((*EnvironmentVariableType)(nil), "ves.io.schema.views.workload.EnvironmentVariableType")
	golang_proto.RegisterType((*EnvironmentVariableType)(nil), "ves.io.schema.views.workload.EnvironmentVariableType")
	proto.RegisterType((*ConfigurationParameterType)(nil), "ves.io.schema.views.workload.ConfigurationParameterType")
	golang_proto.RegisterType((*ConfigurationParameterType)(nil), "ves.io.schema.views.workload.ConfigurationParameterType")
	proto.RegisterType((*ConfigurationParametersType)(nil), "ves.io.schema.views.workload.ConfigurationParametersType")
	golang_proto.RegisterType((*ConfigurationParametersType)(nil), "ves.io.schema.views.workload.ConfigurationParametersType")
	proto.RegisterType((*PersistentStorageType)(nil), "ves.io.schema.views.workload.PersistentStorageType")
	golang_proto.RegisterType((*PersistentStorageType)(nil), "ves.io.schema.views.workload.PersistentStorageType")
	proto.RegisterType((*PersistentStorageVolumeType)(nil), "ves.io.schema.views.workload.PersistentStorageVolumeType")
	golang_proto.RegisterType((*PersistentStorageVolumeType)(nil), "ves.io.schema.views.workload.PersistentStorageVolumeType")
	proto.RegisterType((*EmptyDirectoryVolumeType)(nil), "ves.io.schema.views.workload.EmptyDirectoryVolumeType")
	golang_proto.RegisterType((*EmptyDirectoryVolumeType)(nil), "ves.io.schema.views.workload.EmptyDirectoryVolumeType")
	proto.RegisterType((*HostPathVolumeType)(nil), "ves.io.schema.views.workload.HostPathVolumeType")
	golang_proto.RegisterType((*HostPathVolumeType)(nil), "ves.io.schema.views.workload.HostPathVolumeType")
	proto.RegisterType((*StorageVolumeType)(nil), "ves.io.schema.views.workload.StorageVolumeType")
	golang_proto.RegisterType((*StorageVolumeType)(nil), "ves.io.schema.views.workload.StorageVolumeType")
	proto.RegisterType((*EphemeralStorageVolumeType)(nil), "ves.io.schema.views.workload.EphemeralStorageVolumeType")
	golang_proto.RegisterType((*EphemeralStorageVolumeType)(nil), "ves.io.schema.views.workload.EphemeralStorageVolumeType")
	proto.RegisterType((*PersistentVolumeType)(nil), "ves.io.schema.views.workload.PersistentVolumeType")
	golang_proto.RegisterType((*PersistentVolumeType)(nil), "ves.io.schema.views.workload.PersistentVolumeType")
	proto.RegisterType((*ImageType)(nil), "ves.io.schema.views.workload.ImageType")
	golang_proto.RegisterType((*ImageType)(nil), "ves.io.schema.views.workload.ImageType")
	proto.RegisterType((*PortChoiceType)(nil), "ves.io.schema.views.workload.PortChoiceType")
	golang_proto.RegisterType((*PortChoiceType)(nil), "ves.io.schema.views.workload.PortChoiceType")
	proto.RegisterType((*HTTPHealthCheckType)(nil), "ves.io.schema.views.workload.HTTPHealthCheckType")
	golang_proto.RegisterType((*HTTPHealthCheckType)(nil), "ves.io.schema.views.workload.HTTPHealthCheckType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.workload.HTTPHealthCheckType.HeadersEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.workload.HTTPHealthCheckType.HeadersEntry")
	proto.RegisterType((*ExecHealthCheckType)(nil), "ves.io.schema.views.workload.ExecHealthCheckType")
	golang_proto.RegisterType((*ExecHealthCheckType)(nil), "ves.io.schema.views.workload.ExecHealthCheckType")
	proto.RegisterType((*TCPHealthCheckType)(nil), "ves.io.schema.views.workload.TCPHealthCheckType")
	golang_proto.RegisterType((*TCPHealthCheckType)(nil), "ves.io.schema.views.workload.TCPHealthCheckType")
	proto.RegisterType((*HealthCheckType)(nil), "ves.io.schema.views.workload.HealthCheckType")
	golang_proto.RegisterType((*HealthCheckType)(nil), "ves.io.schema.views.workload.HealthCheckType")
	proto.RegisterType((*ContainerType)(nil), "ves.io.schema.views.workload.ContainerType")
	golang_proto.RegisterType((*ContainerType)(nil), "ves.io.schema.views.workload.ContainerType")
	proto.RegisterType((*DeployCESiteType)(nil), "ves.io.schema.views.workload.DeployCESiteType")
	golang_proto.RegisterType((*DeployCESiteType)(nil), "ves.io.schema.views.workload.DeployCESiteType")
	proto.RegisterType((*DeployRESiteType)(nil), "ves.io.schema.views.workload.DeployRESiteType")
	golang_proto.RegisterType((*DeployRESiteType)(nil), "ves.io.schema.views.workload.DeployRESiteType")
	proto.RegisterType((*DeployREVirtualSiteType)(nil), "ves.io.schema.views.workload.DeployREVirtualSiteType")
	golang_proto.RegisterType((*DeployREVirtualSiteType)(nil), "ves.io.schema.views.workload.DeployREVirtualSiteType")
	proto.RegisterType((*DeployCEVirtualSiteType)(nil), "ves.io.schema.views.workload.DeployCEVirtualSiteType")
	golang_proto.RegisterType((*DeployCEVirtualSiteType)(nil), "ves.io.schema.views.workload.DeployCEVirtualSiteType")
	proto.RegisterType((*DeployOptionsType)(nil), "ves.io.schema.views.workload.DeployOptionsType")
	golang_proto.RegisterType((*DeployOptionsType)(nil), "ves.io.schema.views.workload.DeployOptionsType")
	proto.RegisterType((*RouteInfoType)(nil), "ves.io.schema.views.workload.RouteInfoType")
	golang_proto.RegisterType((*RouteInfoType)(nil), "ves.io.schema.views.workload.RouteInfoType")
	proto.RegisterType((*RouteType)(nil), "ves.io.schema.views.workload.RouteType")
	golang_proto.RegisterType((*RouteType)(nil), "ves.io.schema.views.workload.RouteType")
	proto.RegisterType((*MatchAllRouteType)(nil), "ves.io.schema.views.workload.MatchAllRouteType")
	golang_proto.RegisterType((*MatchAllRouteType)(nil), "ves.io.schema.views.workload.MatchAllRouteType")
	proto.RegisterType((*HTTPLoadBalancerType)(nil), "ves.io.schema.views.workload.HTTPLoadBalancerType")
	golang_proto.RegisterType((*HTTPLoadBalancerType)(nil), "ves.io.schema.views.workload.HTTPLoadBalancerType")
	proto.RegisterType((*TCPLoadBalancerType)(nil), "ves.io.schema.views.workload.TCPLoadBalancerType")
	golang_proto.RegisterType((*TCPLoadBalancerType)(nil), "ves.io.schema.views.workload.TCPLoadBalancerType")
	proto.RegisterType((*PortInfoType)(nil), "ves.io.schema.views.workload.PortInfoType")
	golang_proto.RegisterType((*PortInfoType)(nil), "ves.io.schema.views.workload.PortInfoType")
	proto.RegisterType((*PortType)(nil), "ves.io.schema.views.workload.PortType")
	golang_proto.RegisterType((*PortType)(nil), "ves.io.schema.views.workload.PortType")
	proto.RegisterType((*MultiPortType)(nil), "ves.io.schema.views.workload.MultiPortType")
	golang_proto.RegisterType((*MultiPortType)(nil), "ves.io.schema.views.workload.MultiPortType")
	proto.RegisterType((*SinglePortType)(nil), "ves.io.schema.views.workload.SinglePortType")
	golang_proto.RegisterType((*SinglePortType)(nil), "ves.io.schema.views.workload.SinglePortType")
	proto.RegisterType((*AdvertiseInClusterType)(nil), "ves.io.schema.views.workload.AdvertiseInClusterType")
	golang_proto.RegisterType((*AdvertiseInClusterType)(nil), "ves.io.schema.views.workload.AdvertiseInClusterType")
	proto.RegisterType((*AdvertiseSinglePortType)(nil), "ves.io.schema.views.workload.AdvertiseSinglePortType")
	golang_proto.RegisterType((*AdvertiseSinglePortType)(nil), "ves.io.schema.views.workload.AdvertiseSinglePortType")
	proto.RegisterType((*AdvertisePortType)(nil), "ves.io.schema.views.workload.AdvertisePortType")
	golang_proto.RegisterType((*AdvertisePortType)(nil), "ves.io.schema.views.workload.AdvertisePortType")
	proto.RegisterType((*AdvertiseMultiPortType)(nil), "ves.io.schema.views.workload.AdvertiseMultiPortType")
	golang_proto.RegisterType((*AdvertiseMultiPortType)(nil), "ves.io.schema.views.workload.AdvertiseMultiPortType")
	proto.RegisterType((*AdvertisePublicType)(nil), "ves.io.schema.views.workload.AdvertisePublicType")
	golang_proto.RegisterType((*AdvertisePublicType)(nil), "ves.io.schema.views.workload.AdvertisePublicType")
	proto.RegisterType((*AdvertiseWhereType)(nil), "ves.io.schema.views.workload.AdvertiseWhereType")
	golang_proto.RegisterType((*AdvertiseWhereType)(nil), "ves.io.schema.views.workload.AdvertiseWhereType")
	proto.RegisterType((*AdvertiseCustomType)(nil), "ves.io.schema.views.workload.AdvertiseCustomType")
	golang_proto.RegisterType((*AdvertiseCustomType)(nil), "ves.io.schema.views.workload.AdvertiseCustomType")
	proto.RegisterType((*AdvertiseOptionsType)(nil), "ves.io.schema.views.workload.AdvertiseOptionsType")
	golang_proto.RegisterType((*AdvertiseOptionsType)(nil), "ves.io.schema.views.workload.AdvertiseOptionsType")
	proto.RegisterType((*AdvertiseSimpleServiceType)(nil), "ves.io.schema.views.workload.AdvertiseSimpleServiceType")
	golang_proto.RegisterType((*AdvertiseSimpleServiceType)(nil), "ves.io.schema.views.workload.AdvertiseSimpleServiceType")
	proto.RegisterType((*SimpleServiceType)(nil), "ves.io.schema.views.workload.SimpleServiceType")
	golang_proto.RegisterType((*SimpleServiceType)(nil), "ves.io.schema.views.workload.SimpleServiceType")
	proto.RegisterType((*ServiceType)(nil), "ves.io.schema.views.workload.ServiceType")
	golang_proto.RegisterType((*ServiceType)(nil), "ves.io.schema.views.workload.ServiceType")
	proto.RegisterType((*StatefulServiceType)(nil), "ves.io.schema.views.workload.StatefulServiceType")
	golang_proto.RegisterType((*StatefulServiceType)(nil), "ves.io.schema.views.workload.StatefulServiceType")
	proto.RegisterType((*JobType)(nil), "ves.io.schema.views.workload.JobType")
	golang_proto.RegisterType((*JobType)(nil), "ves.io.schema.views.workload.JobType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.workload.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.workload.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.workload.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.workload.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.workload.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.workload.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.workload.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.workload.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/workload/types.proto", fileDescriptor_9adbda8cf19677b4)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/workload/types.proto", fileDescriptor_9adbda8cf19677b4)
}

var fileDescriptor_9adbda8cf19677b4 = []byte{
	// 4962 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x3c, 0x5d, 0x6c, 0x1b, 0x47,
	0x7a, 0x1c, 0x72, 0xf9, 0xa3, 0x8f, 0xfa, 0x59, 0x8e, 0xec, 0x98, 0x96, 0x1d, 0x85, 0x60, 0xe2,
	0x8b, 0xa2, 0x63, 0x24, 0xeb, 0xc7, 0xb6, 0xa2, 0xbb, 0xf8, 0x22, 0xd2, 0x74, 0x24, 0x59, 0x7f,
	0xb7, 0x92, 0xed, 0xf8, 0x92, 0x78, 0xbb, 0x22, 0x47, 0xe2, 0xc6, 0x4b, 0x2e, 0xb1, 0xbb, 0x54,
	0x22, 0x17, 0xc6, 0x19, 0xc5, 0xb5, 0x49, 0x7d, 0x45, 0x11, 0xf8, 0xa1, 0x0f, 0x87, 0x3e, 0x15,
	0x45, 0x91, 0xe4, 0xa1, 0x68, 0x5f, 0x4b, 0xa3, 0x30, 0x04, 0x14, 0xbd, 0x3b, 0xf4, 0xc1, 0x2d,
	0x70, 0x85, 0x71, 0x4f, 0x89, 0xf2, 0xd0, 0xe4, 0xd0, 0x87, 0x34, 0x40, 0x81, 0x6b, 0x51, 0x20,
	0xc5, 0xcc, 0xce, 0x2e, 0x77, 0x49, 0x4a, 0xa2, 0x1c, 0xfb, 0x52, 0xa0, 0xd1, 0x13, 0x39, 0xf3,
	0xcd, 0xf7, 0x7d, 0xf3, 0xfd, 0xce, 0xf7, 0xcd, 0x50, 0x30, 0xb4, 0x45, 0xcc, 0x11, 0x55, 0x1f,
	0x35, 0x0b, 0x25, 0x52, 0x56, 0x46, 0xb7, 0x54, 0xf2, 0xb6, 0x39, 0xfa, 0xb6, 0x6e, 0xdc, 0xd0,
	0x74, 0xa5, 0x38, 0x6a, 0x6d, 0x57, 0x89, 0x39, 0x52, 0x35, 0x74, 0x4b, 0xc7, 0x27, 0x6d, 0xc8,
	0x11, 0x1b, 0x72, 0x84, 0x41, 0x8e, 0x38, 0x90, 0x03, 0x2f, 0x6e, 0xaa, 0x56, 0xa9, 0xb6, 0x3e,
	0x52, 0xd0, 0xcb, 0xa3, 0x9b, 0xfa, 0xa6, 0x3e, 0xca, 0x16, 0xad, 0xd7, 0x36, 0xd8, 0x37, 0xf6,
	0x85, 0x7d, 0xb2, 0x91, 0x0d, 0x9c, 0xf0, 0x93, 0xd5, 0xab, 0x96, 0xaa, 0x57, 0x38, 0xa5, 0x81,
	0xe3, 0xfe, 0x49, 0x0f, 0x13, 0x03, 0x27, 0x9b, 0xd8, 0x55, 0x34, 0xb5, 0xa8, 0x58, 0x84, 0xcf,
	0xa6, 0x5a, 0x37, 0x23, 0xfb, 0x51, 0x8f, 0xb5, 0xdb, 0x6e, 0xc9, 0xb2, 0xaa, 0x32, 0xdd, 0xc5,
	0xba, 0xa2, 0x29, 0x95, 0x02, 0x31, 0x7c, 0x24, 0x9f, 0x69, 0xb7, 0xc4, 0x03, 0x90, 0xfe, 0x7b,
	0x04, 0x7d, 0x57, 0x74, 0xad, 0x56, 0x26, 0x8b, 0x7a, 0xad, 0x62, 0xad, 0x6d, 0x57, 0x09, 0xce,
	0x83, 0x50, 0xd6, 0x8b, 0x24, 0x89, 0x52, 0x68, 0xa8, 0x77, 0x7c, 0x6c, 0x64, 0x3f, 0xd9, 0x8d,
	0x78, 0x16, 0x2f, 0xea, 0x45, 0x42, 0x11, 0x48, 0x6c, 0x39, 0x7e, 0x09, 0xa0, 0x4c, 0x87, 0xe5,
	0xaa, 0x62, 0x95, 0x92, 0xc1, 0x14, 0x1a, 0xea, 0xca, 0x0e, 0xfc, 0xdd, 0xe7, 0xf7, 0x43, 0x61,
	0x23, 0x94, 0xbc, 0x1d, 0xa4, 0x9f, 0xe2, 0x46, 0xd7, 0x78, 0xf4, 0xfa, 0xeb, 0xd7, 0xa7, 0xdf,
	0x1c, 0x7e, 0x4e, 0xea, 0x62, 0xd0, 0x2b, 0x8a, 0x55, 0xc2, 0x2f, 0x40, 0xcc, 0xac, 0xad, 0xdb,
	0x0b, 0x43, 0x6c, 0x61, 0xef, 0xfd, 0x3a, 0x42, 0x8d, 0xc5, 0x52, 0xd4, 0xac, 0xad, 0x53, 0xd0,
	0xf4, 0xfd, 0x20, 0x1c, 0xcd, 0xe9, 0x95, 0x0d, 0x75, 0xb3, 0x66, 0x28, 0x54, 0x5a, 0x17, 0x55,
	0x8d, 0x71, 0x81, 0x07, 0x41, 0xa8, 0x28, 0x65, 0x7b, 0x1b, 0x5d, 0x59, 0xf0, 0x2c, 0x66, 0xe3,
	0x78, 0x1e, 0x84, 0xa2, 0x62, 0x29, 0x9c, 0xc0, 0xd9, 0xdf, 0xd6, 0x91, 0xf0, 0x17, 0xf7, 0xd0,
	0x71, 0xc5, 0x2c, 0xa8, 0x6a, 0x26, 0xb5, 0xae, 0x98, 0xe4, 0xec, 0x64, 0x26, 0xf5, 0x96, 0xa9,
	0x57, 0x32, 0xa9, 0x6d, 0xa5, 0xac, 0x51, 0x04, 0x11, 0x43, 0x48, 0xde, 0xbe, 0xed, 0x30, 0xf2,
	0x3e, 0x42, 0x12, 0xc3, 0x81, 0x47, 0x21, 0xbe, 0xc5, 0x04, 0x21, 0x33, 0x92, 0x11, 0x9b, 0xe7,
	0xdf, 0xfa, 0x79, 0x06, 0x1b, 0x64, 0x89, 0x12, 0x5f, 0x85, 0x30, 0xdb, 0x6e, 0x32, 0x9a, 0x42,
	0x43, 0xf1, 0xf1, 0x17, 0x3b, 0x16, 0x32, 0xdd, 0x5a, 0x0b, 0x66, 0x1b, 0xd7, 0xf4, 0xb3, 0x3b,
	0x75, 0xf4, 0x0c, 0x3c, 0x0d, 0xd8, 0x27, 0x90, 0x14, 0x95, 0x08, 0x8e, 0x8e, 0x65, 0x26, 0x32,
	0x67, 0x33, 0xe7, 0xe6, 0x85, 0x58, 0x50, 0x0c, 0xcd, 0x0b, 0x31, 0x41, 0x0c, 0xcf, 0x0b, 0xb1,
	0xb0, 0x18, 0x49, 0x17, 0xe0, 0x58, 0xbe, 0xb2, 0xa5, 0x1a, 0x7a, 0xa5, 0x4c, 0x2a, 0xd6, 0x15,
	0xc5, 0x50, 0x95, 0x75, 0x2e, 0xc3, 0xb4, 0x4f, 0x86, 0x94, 0x6c, 0xa0, 0x45, 0x8e, 0xcf, 0x41,
	0x78, 0x4b, 0xd1, 0x6a, 0x84, 0xab, 0xb8, 0x19, 0xc8, 0x9e, 0x4c, 0x7f, 0x8c, 0x60, 0xc0, 0xc7,
	0xd6, 0x8a, 0x62, 0x28, 0x65, 0x62, 0x11, 0x83, 0x11, 0x5a, 0x06, 0x61, 0x43, 0xd5, 0x6c, 0x1c,
	0xf1, 0xf1, 0x89, 0xfd, 0xc5, 0xd1, 0x56, 0xdf, 0x59, 0xe1, 0x41, 0x1d, 0xa1, 0xd9, 0x80, 0xc4,
	0x10, 0xe1, 0x15, 0x88, 0x92, 0xca, 0x96, 0xbc, 0xa5, 0x18, 0x4c, 0xc1, 0xf1, 0xf1, 0x33, 0xfb,
	0xe3, 0xdc, 0x43, 0x02, 0xb3, 0x01, 0x29, 0x42, 0x2a, 0x5b, 0x57, 0x14, 0x23, 0x7b, 0x1c, 0x22,
	0x85, 0x92, 0xae, 0x16, 0x08, 0xee, 0xbb, 0x5f, 0x47, 0x41, 0x4a, 0x6d, 0xb7, 0x8e, 0x42, 0xe3,
	0x99, 0x89, 0x79, 0x21, 0x86, 0xc4, 0x60, 0xfa, 0xcf, 0x11, 0x9c, 0x68, 0xbf, 0x45, 0x93, 0xed,
	0xf1, 0x16, 0x40, 0xd5, 0x1d, 0x49, 0xa2, 0x54, 0x68, 0x28, 0x3e, 0x3e, 0x75, 0x88, 0x9d, 0xfa,
	0x24, 0x96, 0x7d, 0xf6, 0x0b, 0xc7, 0x06, 0xee, 0xa2, 0xa0, 0x98, 0x72, 0x3e, 0x25, 0xd1, 0xee,
	0xc7, 0xff, 0x10, 0x8a, 0xdc, 0xbd, 0x87, 0x82, 0x31, 0x24, 0x79, 0x08, 0xa6, 0x7f, 0x15, 0x84,
	0xa3, 0x2b, 0xc4, 0x30, 0x55, 0xd3, 0x22, 0x15, 0x6b, 0xd5, 0xd2, 0x0d, 0x65, 0xd3, 0xd6, 0x72,
	0x11, 0xe2, 0x4a, 0xa1, 0x40, 0x4c, 0x53, 0xf6, 0xf8, 0xfd, 0xcb, 0xfb, 0x73, 0xd6, 0x82, 0x69,
	0x86, 0x61, 0x70, 0x62, 0x40, 0x56, 0xa0, 0x0e, 0x2b, 0x81, 0xe2, 0x8e, 0xe2, 0x1c, 0x74, 0x9b,
	0x36, 0xa8, 0x6c, 0xaa, 0x37, 0x6d, 0x55, 0xa3, 0x2c, 0x63, 0x3c, 0x8e, 0xbb, 0x5e, 0xf8, 0x9f,
	0x0f, 0xff, 0xe3, 0x5f, 0x16, 0xd7, 0xab, 0x3f, 0xe0, 0xdf, 0x8f, 0x07, 0xd8, 0x5f, 0xf5, 0x15,
	0x29, 0xce, 0x57, 0xad, 0xaa, 0x37, 0x09, 0x3e, 0x0d, 0xd1, 0x22, 0xd9, 0x50, 0x6a, 0x9a, 0x95,
	0x14, 0x98, 0x5a, 0x8f, 0x34, 0xb1, 0x99, 0x2f, 0x57, 0xad, 0xed, 0xd9, 0x80, 0xe4, 0x80, 0xe1,
	0x51, 0x80, 0x82, 0xa6, 0x98, 0xa6, 0xed, 0x99, 0xe1, 0x76, 0x36, 0x3a, 0x1b, 0x90, 0xba, 0x18,
	0x0c, 0x75, 0xcd, 0xec, 0x10, 0x24, 0x1a, 0x0b, 0x64, 0xae, 0xf2, 0xfe, 0xfb, 0x75, 0x24, 0xfc,
	0xbc, 0x8e, 0xd0, 0x83, 0x3a, 0x0a, 0x51, 0xb5, 0x4f, 0x66, 0xce, 0xcc, 0x0b, 0xb1, 0x90, 0x28,
	0xa4, 0xff, 0x16, 0xc1, 0x89, 0x16, 0x69, 0xd8, 0x1e, 0xcb, 0xa4, 0xbb, 0x08, 0x51, 0xbe, 0x03,
	0x26, 0xd9, 0x03, 0xad, 0xbb, 0xad, 0x8e, 0x24, 0x07, 0x07, 0xce, 0x39, 0x91, 0x23, 0xf8, 0x08,
	0x91, 0x83, 0x47, 0x8a, 0xf4, 0xfb, 0x08, 0x92, 0x4c, 0x52, 0x17, 0x54, 0x83, 0x14, 0x2c, 0xdd,
	0xd8, 0xf6, 0x30, 0x3c, 0x0a, 0x40, 0x15, 0x24, 0x6b, 0x6a, 0x59, 0xb5, 0x18, 0xcf, 0x28, 0x2b,
	0xfa, 0xd5, 0xf2, 0xdc, 0x2b, 0x52, 0x17, 0x85, 0x59, 0xa0, 0x20, 0x8f, 0x87, 0xa5, 0x3f, 0x41,
	0x80, 0x67, 0x75, 0x93, 0x25, 0x00, 0x0f, 0x33, 0x63, 0x20, 0xb0, 0x34, 0x60, 0x47, 0xa0, 0xa7,
	0xfd, 0x81, 0x8f, 0x7e, 0x02, 0x23, 0x36, 0x1e, 0x79, 0xfd, 0xfa, 0x1b, 0xa7, 0xdf, 0xfc, 0xae,
	0xc4, 0x40, 0x1f, 0x0f, 0x3b, 0xff, 0x15, 0x84, 0x44, 0xab, 0x2e, 0xf7, 0x8e, 0x87, 0x7f, 0x13,
	0x44, 0x3c, 0x1e, 0x96, 0x20, 0x51, 0x75, 0x55, 0x28, 0xdb, 0x31, 0x9f, 0xc7, 0xa0, 0x97, 0x0e,
	0xa9, 0xf9, 0x06, 0xe5, 0xd9, 0x80, 0x24, 0x36, 0xb0, 0xda, 0xe3, 0xf8, 0x32, 0x74, 0x11, 0xaa,
	0x44, 0xb9, 0xa8, 0x1a, 0xdc, 0x1d, 0xce, 0x1e, 0x10, 0xe5, 0xf6, 0xd0, 0xf9, 0x6c, 0x40, 0x8a,
	0x11, 0x3e, 0x47, 0xd1, 0x96, 0x74, 0x93, 0xe7, 0xed, 0x30, 0x43, 0x7b, 0x7a, 0x7f, 0xb4, 0xad,
	0x7a, 0xb3, 0xfd, 0x9f, 0xa2, 0x2d, 0xf1, 0xb9, 0x6c, 0x1a, 0x7a, 0x78, 0x8e, 0xe4, 0x3e, 0x95,
	0xb8, 0x5f, 0x47, 0xa1, 0x07, 0x75, 0x14, 0xdc, 0xad, 0xa3, 0xf0, 0x44, 0xc6, 0xf6, 0xa8, 0xa0,
	0x18, 0x4a, 0xff, 0x59, 0x10, 0x06, 0xf2, 0xd5, 0x12, 0x29, 0x13, 0x43, 0xd1, 0x1e, 0x4d, 0x09,
	0x3e, 0xd1, 0x84, 0x9e, 0x8c, 0x68, 0x84, 0xc7, 0x26, 0x9a, 0x54, 0xb3, 0x68, 0xfa, 0x3c, 0xa2,
	0x09, 0x4d, 0x64, 0x26, 0xb9, 0x60, 0x3e, 0x40, 0x70, 0x64, 0xa5, 0xc9, 0x0a, 0x3a, 0x16, 0x89,
	0xd6, 0xce, 0x2e, 0x83, 0x5f, 0xd3, 0x2e, 0xb3, 0x02, 0x4d, 0x43, 0xad, 0xb6, 0x99, 0xfe, 0xe7,
	0x20, 0x74, 0xcd, 0x95, 0x9d, 0x0c, 0x73, 0xd0, 0x59, 0x6c, 0x04, 0x22, 0xd5, 0xda, 0xba, 0xa6,
	0x16, 0xb8, 0xae, 0xf6, 0x8a, 0xea, 0x1c, 0x0a, 0xbf, 0x05, 0xb8, 0xa0, 0x57, 0x2c, 0x45, 0xad,
	0x10, 0x43, 0x36, 0xc8, 0xa6, 0x6a, 0x5a, 0xc6, 0x36, 0x57, 0x48, 0xba, 0xed, 0x66, 0x96, 0xd7,
	0xdf, 0x22, 0x05, 0x4b, 0x22, 0x1b, 0x8c, 0xeb, 0xa3, 0x1f, 0xdd, 0x6a, 0x83, 0x60, 0x36, 0x20,
	0x25, 0xdc, 0x51, 0x89, 0x0f, 0xe2, 0xd7, 0x20, 0x5e, 0xad, 0x69, 0x9a, 0x5c, 0xd5, 0x35, 0xb5,
	0xb0, 0xcd, 0xce, 0x76, 0x07, 0x9e, 0x8a, 0xd9, 0xce, 0x57, 0x6a, 0x9a, 0xb6, 0xc2, 0x16, 0x79,
	0x33, 0x62, 0xd5, 0x1d, 0xcd, 0xa6, 0xa1, 0xcf, 0x21, 0xbd, 0xbf, 0xe2, 0xf9, 0x41, 0xed, 0xc7,
	0xd0, 0xbb, 0xa2, 0x1b, 0x56, 0x8e, 0x81, 0x32, 0xb9, 0x9e, 0x82, 0x50, 0xa5, 0x56, 0x66, 0x5a,
	0xec, 0xc9, 0x26, 0x1c, 0xb5, 0xc7, 0x86, 0x23, 0xc9, 0xaf, 0xbe, 0x0a, 0x0d, 0x51, 0x23, 0xa3,
	0xf3, 0x38, 0xc5, 0xc5, 0x1f, 0xf2, 0x89, 0xff, 0x83, 0x20, 0x3b, 0x2e, 0xd1, 0x99, 0xec, 0x20,
	0xc4, 0xab, 0xba, 0x61, 0xc9, 0xfb, 0x9f, 0x70, 0x3e, 0x0c, 0x43, 0xff, 0xec, 0xda, 0xda, 0xca,
	0x2c, 0x51, 0x34, 0xab, 0x94, 0x2b, 0x91, 0xc2, 0x0d, 0xc6, 0x46, 0xc1, 0x17, 0xa4, 0x97, 0x7f,
	0x5d, 0x47, 0x68, 0x74, 0xb7, 0x8e, 0xce, 0x00, 0x1a, 0x85, 0xe8, 0x68, 0x89, 0x41, 0x43, 0x37,
	0xff, 0x50, 0xa0, 0xcb, 0x20, 0xc6, 0xbf, 0xdd, 0x84, 0xc8, 0xa8, 0xa6, 0x6e, 0x91, 0x9b, 0x10,
	0x1d, 0x35, 0x88, 0x52, 0xdc, 0xbe, 0xe9, 0xee, 0xc2, 0x88, 0x24, 0x6f, 0x8b, 0x9f, 0x51, 0xfb,
	0x65, 0x61, 0xfd, 0x22, 0x08, 0x94, 0x45, 0x6e, 0xb2, 0x99, 0x03, 0x4c, 0xd6, 0x27, 0x27, 0x6e,
	0xa5, 0x6c, 0x3d, 0x7e, 0x19, 0xe2, 0xcc, 0x87, 0x4b, 0x44, 0x29, 0x12, 0x83, 0xcb, 0xe4, 0x24,
	0x55, 0x8e, 0xf7, 0x54, 0xf0, 0x47, 0x41, 0xfe, 0xe9, 0x63, 0xaa, 0x34, 0xba, 0x60, 0x96, 0xc1,
	0xe3, 0xcf, 0x83, 0x10, 0xb5, 0x97, 0x9a, 0x49, 0x81, 0x9d, 0xe1, 0xce, 0x1f, 0x10, 0x01, 0x5a,
	0x05, 0x36, 0x62, 0xe3, 0x32, 0xf3, 0x15, 0xcb, 0xd8, 0xce, 0xfe, 0x69, 0xd0, 0x29, 0x6e, 0xba,
	0x7f, 0x86, 0xba, 0xd2, 0x51, 0x23, 0x2c, 0x22, 0x9e, 0xdc, 0xc2, 0x3f, 0x43, 0x41, 0x51, 0x74,
	0xa6, 0x86, 0xf9, 0x94, 0x48, 0x8f, 0x78, 0xa9, 0x3b, 0xf7, 0xd0, 0x49, 0x3c, 0xf0, 0x9b, 0x3a,
	0x7a, 0x8a, 0x52, 0x48, 0xd9, 0x3c, 0xa5, 0x6e, 0x90, 0xed, 0x94, 0x69, 0x19, 0x6a, 0x65, 0x93,
	0x02, 0x1d, 0xbf, 0x73, 0x0f, 0x1d, 0xc5, 0xfd, 0xbb, 0x75, 0xd4, 0xc7, 0x80, 0x6c, 0xba, 0xa9,
	0x4b, 0x64, 0x9b, 0xce, 0xc2, 0x9d, 0x7b, 0x28, 0x82, 0xe9, 0xb1, 0x26, 0xc0, 0x0e, 0x8d, 0x77,
	0xd8, 0xa1, 0x91, 0x7e, 0x3c, 0x7f, 0xe7, 0x1e, 0x9a, 0x1e, 0x98, 0xfa, 0x4d, 0x1d, 0x4d, 0xae,
	0x32, 0x64, 0x29, 0x7d, 0x23, 0x55, 0xd0, 0xcb, 0x65, 0x25, 0x65, 0x12, 0x7a, 0xa6, 0xb4, 0x48,
	0x31, 0xa5, 0xa9, 0xa6, 0x45, 0xc7, 0xbd, 0xe4, 0xd9, 0x61, 0xdf, 0xa4, 0x28, 0x4e, 0xdc, 0xb9,
	0x87, 0x8e, 0x0d, 0x1c, 0xdd, 0xad, 0xa3, 0x84, 0x97, 0xf4, 0x15, 0x0a, 0xe0, 0x12, 0x1f, 0xa0,
	0xc4, 0x43, 0x9e, 0xaf, 0xcc, 0x47, 0x1c, 0xf9, 0x0e, 0x4c, 0x43, 0xb7, 0x57, 0x52, 0x58, 0x84,
	0xd0, 0x0d, 0xb2, 0x6d, 0x9b, 0x99, 0x44, 0x3f, 0xe2, 0x23, 0xbe, 0xe2, 0x83, 0x17, 0x1b, 0xd3,
	0xc1, 0x29, 0x94, 0x56, 0xa0, 0x3f, 0xff, 0x0e, 0x29, 0x34, 0x9b, 0xea, 0x3c, 0x44, 0xd9, 0x3e,
	0x2a, 0x45, 0x76, 0x02, 0xef, 0xca, 0x9e, 0xa6, 0xd2, 0xed, 0xba, 0x8b, 0x22, 0x69, 0xc1, 0x08,
	0x26, 0x5f, 0xf1, 0x7e, 0x13, 0x1b, 0xe7, 0x6b, 0xb1, 0x71, 0xbe, 0x96, 0x1c, 0x04, 0xe9, 0x37,
	0x00, 0xaf, 0xe5, 0x5a, 0x9c, 0xc1, 0xb1, 0x53, 0xf4, 0xf5, 0xec, 0x34, 0xfd, 0x41, 0x18, 0xfa,
	0x9a, 0x71, 0x13, 0x48, 0xb0, 0x82, 0xdf, 0xf6, 0x1d, 0x99, 0xb9, 0x12, 0x77, 0x88, 0xb1, 0x43,
	0x5b, 0xa1, 0x5b, 0x31, 0xf5, 0x51, 0x9c, 0x9e, 0x49, 0xbc, 0x0e, 0xa2, 0x55, 0x68, 0xa2, 0x12,
	0xea, 0x24, 0xdb, 0xb5, 0x8a, 0xc3, 0x25, 0xd2, 0x6b, 0x15, 0x7c, 0x34, 0x08, 0x24, 0xc8, 0x3b,
	0xa4, 0xe0, 0x27, 0x22, 0x74, 0xb2, 0x95, 0x36, 0x6a, 0x75, 0x73, 0x6a, 0x1f, 0xf1, 0x4f, 0xe2,
	0xef, 0x43, 0x8f, 0x5a, 0x51, 0x2d, 0x55, 0xd1, 0xe4, 0x22, 0xd1, 0x94, 0x6d, 0x76, 0xa0, 0xe9,
	0xc9, 0x1e, 0xa3, 0x31, 0xea, 0x34, 0x75, 0xf8, 0xf7, 0xee, 0xf1, 0x13, 0xe5, 0x70, 0x28, 0xf9,
	0x50, 0x90, 0xba, 0x39, 0xf4, 0x05, 0x0a, 0x8c, 0x27, 0x20, 0x6a, 0xa9, 0x65, 0xa2, 0xd7, 0x2c,
	0x16, 0xf7, 0x7b, 0xb2, 0xc7, 0xe9, 0xba, 0x31, 0xef, 0xba, 0xe8, 0x70, 0x38, 0xf9, 0x50, 0x18,
	0x42, 0x92, 0x03, 0x89, 0xcf, 0x42, 0x4c, 0xad, 0x58, 0xc4, 0xd8, 0x52, 0x34, 0x56, 0xde, 0xf7,
	0x64, 0x07, 0x7e, 0x5d, 0x47, 0xc1, 0xb1, 0xd3, 0x6d, 0x97, 0xb9, 0xb0, 0x78, 0x06, 0x12, 0xb6,
	0x30, 0xb6, 0x65, 0xab, 0x64, 0x10, 0xb3, 0xa4, 0x6b, 0xc5, 0x64, 0x8c, 0x21, 0x38, 0xe2, 0x92,
	0x65, 0x5d, 0x88, 0x61, 0x21, 0x29, 0x0e, 0x21, 0x49, 0xe4, 0xe0, 0x6b, 0x0e, 0x34, 0xce, 0x43,
	0x7f, 0xad, 0xd2, 0x8a, 0xa4, 0xab, 0x81, 0x64, 0xa2, 0x19, 0x09, 0x76, 0x17, 0xb8, 0x68, 0xb2,
	0x43, 0xd0, 0xef, 0x55, 0x8b, 0xf7, 0xc0, 0xe6, 0x64, 0x85, 0xf0, 0x78, 0xc6, 0x4e, 0x4f, 0x34,
	0x2f, 0xdc, 0x17, 0xa0, 0x27, 0xe7, 0x24, 0xce, 0x8e, 0x1b, 0x07, 0x2f, 0x43, 0x58, 0xa5, 0x79,
	0x92, 0x1b, 0xf0, 0xf3, 0x1d, 0xa4, 0x54, 0xfb, 0x84, 0xce, 0x56, 0xe1, 0x51, 0xe8, 0xa5, 0xba,
	0x92, 0xdd, 0x8c, 0xcd, 0x4c, 0x34, 0x96, 0x8d, 0x39, 0xa1, 0x5c, 0x62, 0x9a, 0x77, 0xf9, 0xc2,
	0xcb, 0x10, 0xd9, 0xd0, 0x94, 0x2d, 0xdd, 0x3e, 0x2b, 0x1f, 0x98, 0xc3, 0xdd, 0x85, 0x17, 0xd9,
	0x22, 0x4f, 0x0e, 0xe7, 0x68, 0xf0, 0x75, 0xe8, 0xa5, 0xa9, 0xab, 0x42, 0x2b, 0x67, 0xdb, 0x7e,
	0xc3, 0x9d, 0x54, 0x1c, 0xcd, 0xb6, 0xcb, 0x18, 0xa6, 0x62, 0x95, 0x7a, 0x1c, 0x74, 0xb6, 0xed,
	0xfe, 0x1e, 0x3d, 0x1f, 0x28, 0x45, 0xd5, 0x43, 0x20, 0xf2, 0xf5, 0x08, 0xf4, 0xba, 0xf8, 0x6c,
	0x0a, 0x2f, 0x36, 0xa2, 0x61, 0x94, 0x45, 0xc3, 0x7e, 0x6f, 0x1e, 0x8c, 0xdc, 0x45, 0x21, 0xf1,
	0x76, 0x23, 0xe0, 0xe1, 0xe7, 0x41, 0x50, 0x8c, 0x4d, 0x33, 0x19, 0xdb, 0x1b, 0x96, 0x01, 0x4c,
	0x9f, 0xde, 0xa9, 0xa3, 0x0c, 0x0c, 0xc3, 0x31, 0x57, 0x88, 0x29, 0x5f, 0x2b, 0x03, 0xf7, 0x8d,
	0x65, 0xa8, 0x01, 0x9d, 0xcb, 0x4c, 0xd1, 0x73, 0x7f, 0xe6, 0x6c, 0xfa, 0x2f, 0x11, 0x88, 0x17,
	0x48, 0x55, 0xd3, 0xb7, 0x73, 0xf9, 0x55, 0xd5, 0xb2, 0x8f, 0x37, 0x37, 0x40, 0x30, 0x55, 0x8b,
	0xf0, 0x5e, 0x49, 0x27, 0x07, 0xbb, 0x89, 0x8f, 0x6e, 0xb1, 0x25, 0xbf, 0xac, 0xa3, 0x60, 0x81,
	0x50, 0xe6, 0x6e, 0xdf, 0x6b, 0xd7, 0x26, 0x89, 0x21, 0x4f, 0x40, 0x67, 0x2b, 0xdc, 0xee, 0x59,
	0xd2, 0x66, 0x23, 0xa5, 0x57, 0x52, 0xb9, 0x9a, 0x69, 0xe9, 0x65, 0x62, 0xa4, 0x28, 0x47, 0x26,
	0x46, 0x63, 0xe9, 0x0f, 0x5d, 0x36, 0xa5, 0xc7, 0xc5, 0xa6, 0x71, 0x38, 0x36, 0x87, 0x76, 0xea,
	0xe8, 0x39, 0x48, 0xc3, 0xd3, 0x0d, 0x36, 0xe9, 0x51, 0x55, 0xaf, 0x28, 0x5a, 0x2a, 0x5f, 0xdc,
	0x24, 0x0d, 0x5e, 0xff, 0x11, 0xc1, 0x31, 0x87, 0xd7, 0x2b, 0xaa, 0x61, 0xd5, 0x14, 0xcd, 0x65,
	0xf9, 0x26, 0x74, 0x6f, 0xd9, 0x43, 0xf2, 0xe1, 0x59, 0xf7, 0x2d, 0xb5, 0xb7, 0x70, 0x00, 0xeb,
	0xf1, 0xad, 0x06, 0x7d, 0xd7, 0x38, 0x4e, 0xed, 0xb5, 0x03, 0xce, 0x6c, 0x63, 0x27, 0x3b, 0xee,
	0x4e, 0x72, 0x4f, 0x78, 0x27, 0x85, 0x43, 0xed, 0xe4, 0xbb, 0x3b, 0x75, 0xf4, 0x3c, 0x9c, 0x82,
	0x54, 0x1b, 0x93, 0x69, 0xd9, 0xc4, 0x97, 0x02, 0x24, 0x6c, 0xb8, 0x65, 0xbb, 0xad, 0xcf, 0x9b,
	0x2d, 0x51, 0x45, 0xd3, 0x64, 0x83, 0x98, 0x3c, 0x0c, 0xee, 0x59, 0xfa, 0x28, 0x9a, 0x26, 0x11,
	0x13, 0x5b, 0x70, 0xac, 0xc8, 0xb0, 0xc8, 0x06, 0x91, 0xbd, 0xec, 0x9b, 0x9d, 0x35, 0x3a, 0xf7,
	0xb0, 0x08, 0x37, 0x4f, 0x1f, 0xb1, 0xb1, 0x4b, 0xc4, 0x03, 0xe0, 0xa5, 0x5a, 0x68, 0xa6, 0x2a,
	0x74, 0x4e, 0x35, 0x77, 0x10, 0xd5, 0x9c, 0x9f, 0xea, 0x75, 0xe8, 0x6b, 0x50, 0xb5, 0xa9, 0xd9,
	0x11, 0x76, 0xa4, 0x33, 0x6a, 0x2d, 0x64, 0x7a, 0x1c, 0x32, 0x36, 0xfe, 0x15, 0x38, 0xca, 0xdb,
	0x84, 0x4d, 0x7b, 0x8a, 0xec, 0xad, 0x0a, 0xf7, 0xa8, 0xd1, 0xcf, 0x97, 0xee, 0xc1, 0xb1, 0xe1,
	0x70, 0x1c, 0xed, 0x9c, 0x63, 0x69, 0x4f, 0x8e, 0x25, 0x9b, 0xe3, 0xec, 0x10, 0xf4, 0x38, 0x12,
	0xb1, 0x73, 0xf2, 0x31, 0x4f, 0x4e, 0x8e, 0xb3, 0x9c, 0x9c, 0x39, 0x47, 0x03, 0x2a, 0xcf, 0xcc,
	0xef, 0x0a, 0xd0, 0x23, 0xe9, 0x35, 0x8b, 0xcc, 0x55, 0x36, 0x74, 0x66, 0x70, 0x55, 0xe8, 0x36,
	0xd5, 0x72, 0x55, 0x23, 0xb2, 0x41, 0xc7, 0xf9, 0x31, 0xf5, 0x52, 0x5b, 0xf6, 0x5a, 0x2e, 0x97,
	0x46, 0x18, 0x2e, 0x8a, 0x67, 0x95, 0xe1, 0xb8, 0xaa, 0x5a, 0xa5, 0x0b, 0xb6, 0x18, 0x96, 0x0d,
	0x75, 0x53, 0xad, 0xac, 0xe8, 0xba, 0x36, 0x1b, 0x90, 0xe2, 0x36, 0x09, 0x06, 0x8d, 0x15, 0xe8,
	0x35, 0x48, 0x91, 0x75, 0x56, 0x38, 0x4d, 0xdb, 0xd2, 0xa7, 0x0e, 0x4b, 0x53, 0xe2, 0x58, 0xa8,
	0x58, 0x1c, 0x8c, 0x36, 0x09, 0x0b, 0x8e, 0x3a, 0x04, 0x88, 0x59, 0xd5, 0x2b, 0xa6, 0xb3, 0x3b,
	0xdb, 0x25, 0xce, 0x1f, 0x96, 0x92, 0xdd, 0x07, 0x92, 0x38, 0x2e, 0xa6, 0x6c, 0xdf, 0x88, 0x4d,
	0xd5, 0x84, 0xfe, 0x02, 0x73, 0x77, 0x9b, 0x98, 0xac, 0xb3, 0xf0, 0xc2, 0x1d, 0xe2, 0x7b, 0x87,
	0xa5, 0x69, 0x47, 0x0e, 0xf6, 0xd5, 0xb5, 0xb1, 0x44, 0xa1, 0x31, 0x68, 0x07, 0xaf, 0xe9, 0xc4,
	0x4e, 0x1d, 0xf5, 0x40, 0x1c, 0x22, 0x6c, 0xd0, 0xc4, 0xe8, 0x4c, 0xf6, 0x69, 0xf7, 0x66, 0xa2,
	0x9f, 0x67, 0xfa, 0xf0, 0x6e, 0x1d, 0x45, 0xed, 0x14, 0x3b, 0xc9, 0x9b, 0x07, 0x37, 0xa1, 0xcb,
	0x25, 0x85, 0xcb, 0x10, 0x61, 0x2c, 0x3b, 0xd7, 0x10, 0xdf, 0xdd, 0xdf, 0x3a, 0x7d, 0x16, 0x94,
	0x1d, 0xa2, 0xe6, 0xe6, 0xbf, 0x7d, 0x70, 0xef, 0x1c, 0x44, 0xdf, 0xf5, 0x03, 0x27, 0x92, 0xfe,
	0xc3, 0x20, 0x24, 0x16, 0x15, 0xab, 0x50, 0x9a, 0xd1, 0xb4, 0x06, 0x13, 0x59, 0x48, 0x28, 0x35,
	0x4b, 0x97, 0x59, 0x35, 0x6e, 0x90, 0xb7, 0x0d, 0xd5, 0x35, 0x8d, 0xbd, 0x82, 0x60, 0x1f, 0x5d,
	0x30, 0xab, 0x9b, 0x96, 0x64, 0x83, 0xe3, 0x11, 0xe8, 0xf6, 0x2d, 0xb7, 0xab, 0xf9, 0x2e, 0xca,
	0x99, 0x60, 0x04, 0x4b, 0x54, 0x86, 0xac, 0xda, 0x77, 0xe0, 0x67, 0xe1, 0x48, 0x51, 0x35, 0x95,
	0x75, 0x8d, 0xf8, 0xc9, 0xee, 0x7f, 0x99, 0x80, 0xf9, 0x1a, 0x0f, 0xe5, 0x6c, 0x06, 0xfa, 0xbd,
	0x18, 0x64, 0x76, 0xd3, 0x62, 0xe2, 0xa3, 0xd4, 0x1f, 0xf9, 0x45, 0x41, 0xcb, 0x39, 0xf9, 0x17,
	0x61, 0x38, 0x42, 0x0b, 0xb1, 0x05, 0x5d, 0x29, 0x66, 0xb9, 0x01, 0xf0, 0x1b, 0x98, 0x68, 0x51,
	0x2f, 0x2b, 0x6a, 0xc5, 0xe4, 0x55, 0xe9, 0x3c, 0x6b, 0x6d, 0xdf, 0x45, 0xd1, 0x74, 0xa3, 0xd3,
	0xed, 0x2f, 0x4b, 0x9d, 0xc9, 0xf7, 0x82, 0x07, 0x9d, 0x1b, 0x1c, 0xd4, 0x78, 0x1e, 0x04, 0x6a,
	0x7f, 0xdc, 0x29, 0x26, 0x3b, 0x34, 0xd0, 0x15, 0x43, 0x7f, 0x87, 0x75, 0xb0, 0x66, 0x69, 0x95,
	0x18, 0x90, 0x18, 0x0e, 0x5c, 0x02, 0x56, 0x35, 0x9a, 0x32, 0x53, 0x61, 0x81, 0x18, 0x8e, 0xdd,
	0x9f, 0x7f, 0x14, 0xb4, 0xe6, 0x4c, 0xcd, 0xd2, 0x73, 0xc4, 0xb0, 0x4c, 0xea, 0xdb, 0x25, 0xef,
	0x08, 0x5e, 0x84, 0x30, 0x1b, 0xe0, 0xa1, 0xff, 0xcc, 0x23, 0xe1, 0x9f, 0x0d, 0x48, 0x36, 0x16,
	0xfc, 0x06, 0x8d, 0xa0, 0x76, 0xcc, 0xb7, 0x43, 0x84, 0x1d, 0x9f, 0x47, 0xf7, 0xf7, 0x80, 0x16,
	0xeb, 0xb5, 0x4b, 0xf5, 0x59, 0x24, 0x75, 0x73, 0x6c, 0x76, 0x48, 0x90, 0xa0, 0xcf, 0xac, 0x92,
	0x82, 0xba, 0xa1, 0x16, 0x64, 0xee, 0x61, 0xb1, 0x4e, 0xaa, 0x1b, 0x17, 0xef, 0x2c, 0x92, 0x7a,
	0x1d, 0x0c, 0xb6, 0x87, 0x4f, 0x7f, 0x6f, 0xa7, 0x8e, 0xce, 0xc1, 0x00, 0xf4, 0x67, 0x15, 0x53,
	0x2d, 0x34, 0x1d, 0xa4, 0x43, 0x63, 0x99, 0x71, 0x38, 0x0e, 0x47, 0x6c, 0xd8, 0xa6, 0x49, 0x74,
	0x36, 0xfb, 0x1d, 0x48, 0x78, 0xc5, 0x22, 0x5b, 0xd4, 0xdc, 0x5a, 0x3b, 0xef, 0xd9, 0x67, 0xa1,
	0xdb, 0x0e, 0x62, 0x9e, 0x48, 0x12, 0xe5, 0x76, 0x1c, 0xd9, 0xad, 0xa3, 0xd0, 0xb9, 0xcc, 0x94,
	0xdb, 0x8c, 0x8c, 0x88, 0xd1, 0xf4, 0xfb, 0x08, 0xfa, 0xd7, 0x72, 0xad, 0xa6, 0xfc, 0xfd, 0x66,
	0x53, 0x4e, 0x7b, 0x6d, 0xb7, 0xd4, 0xf6, 0xca, 0xb2, 0x61, 0xa2, 0xc7, 0x21, 0xf6, 0xb6, 0x6a,
	0x95, 0x64, 0xb3, 0xa2, 0xb2, 0x50, 0x10, 0x93, 0xa2, 0xf4, 0xfb, 0x6a, 0x45, 0x9d, 0x4e, 0xed,
	0xd4, 0xd1, 0xc9, 0xfd, 0xc4, 0x90, 0xfe, 0xeb, 0x20, 0x74, 0xaf, 0xe8, 0x86, 0xe5, 0xe6, 0xba,
	0x21, 0x4f, 0x2b, 0xa6, 0x27, 0x7b, 0x84, 0x45, 0x85, 0xe1, 0x60, 0xca, 0xad, 0x7f, 0xbf, 0xfa,
	0x2a, 0xc4, 0x9b, 0x82, 0x17, 0x21, 0xc6, 0x1e, 0x44, 0x14, 0x74, 0x8d, 0xd1, 0xed, 0x1d, 0x1f,
	0x3e, 0xa0, 0x71, 0xc3, 0xa1, 0x59, 0x5e, 0x72, 0xd7, 0xe2, 0x29, 0xe8, 0x36, 0x95, 0x32, 0x91,
	0x15, 0x53, 0x66, 0x94, 0xf7, 0x8f, 0x2b, 0x40, 0x61, 0x67, 0x4c, 0xca, 0x33, 0x3e, 0x07, 0x71,
	0x4b, 0x31, 0x36, 0x89, 0x65, 0x2f, 0x0c, 0xef, 0xcd, 0x32, 0x5d, 0x68, 0x83, 0xd2, 0x85, 0xd3,
	0xb1, 0x2f, 0xcf, 0x87, 0x59, 0xa8, 0xcf, 0xbe, 0x00, 0xd8, 0x83, 0xa2, 0x83, 0xab, 0xcb, 0x77,
	0x20, 0x46, 0x51, 0xec, 0xd3, 0xa2, 0xff, 0xc0, 0xbd, 0x3e, 0xb8, 0x00, 0x82, 0x5a, 0xd9, 0xd0,
	0x79, 0x80, 0x1e, 0x3e, 0xb8, 0xad, 0xe5, 0xe6, 0x0b, 0xde, 0xd4, 0xa2, 0xab, 0xa7, 0x23, 0x5f,
	0x9e, 0x67, 0xaa, 0xba, 0x06, 0x3d, 0x8b, 0x35, 0xcd, 0x52, 0x5d, 0xf2, 0xb3, 0x10, 0xa6, 0x4c,
	0x3b, 0x09, 0xe9, 0x3b, 0x07, 0xe3, 0x67, 0xb8, 0xa1, 0xd1, 0xa1, 0x93, 0x6c, 0x04, 0xe9, 0x2b,
	0xd0, 0xbb, 0xaa, 0x56, 0x36, 0x35, 0xe2, 0xe2, 0x76, 0x58, 0x47, 0x5f, 0x87, 0xf5, 0xf4, 0x43,
	0x04, 0x4f, 0xcd, 0x14, 0xb7, 0x88, 0x61, 0xa9, 0x26, 0x99, 0xab, 0xe4, 0xb4, 0x9a, 0xe9, 0xbc,
	0x5e, 0xc8, 0x1e, 0xa6, 0x35, 0xed, 0x67, 0x8e, 0x06, 0x54, 0x66, 0x81, 0x6b, 0x10, 0x2f, 0x53,
	0x89, 0xc8, 0xb6, 0x18, 0xec, 0x18, 0x7d, 0x40, 0x5e, 0xf6, 0x89, 0xd0, 0x3d, 0x34, 0x40, 0xd9,
	0x19, 0x36, 0x3b, 0xec, 0xeb, 0xff, 0x2a, 0x08, 0xc7, 0xdc, 0xad, 0x35, 0x09, 0xef, 0x95, 0xc3,
	0xb4, 0x33, 0xfd, 0x6b, 0xf9, 0xce, 0x36, 0x79, 0xd3, 0xd2, 0x1b, 0x87, 0xf8, 0xfe, 0xc6, 0x0f,
	0x6e, 0x5a, 0x36, 0x07, 0x18, 0xf7, 0x64, 0x2c, 0x52, 0xa4, 0x0b, 0x1e, 0x9c, 0xb8, 0x68, 0xb7,
	0x2d, 0x7d, 0x74, 0x3a, 0xea, 0x28, 0xb6, 0x89, 0x63, 0x8d, 0xe6, 0xa8, 0x55, 0xf0, 0x51, 0xc9,
	0x3e, 0x0b, 0xa2, 0xe2, 0xc8, 0xea, 0x80, 0xfb, 0xba, 0x5f, 0x04, 0x21, 0xe1, 0xca, 0xd5, 0x95,
	0xe8, 0xb4, 0x4f, 0xa2, 0x1d, 0x5a, 0xfa, 0xff, 0x7b, 0x59, 0xde, 0xf0, 0x78, 0x9f, 0x3f, 0x74,
	0xfc, 0xd0, 0x1f, 0x3a, 0x0e, 0xc8, 0xe4, 0x2d, 0xfa, 0x68, 0x17, 0x43, 0xfe, 0x1d, 0x41, 0x7f,
	0x03, 0x90, 0xdd, 0x39, 0x32, 0x52, 0x97, 0x7c, 0x8e, 0x7e, 0xa6, 0x43, 0x4a, 0x7b, 0x78, 0xfc,
	0x9b, 0xed, 0x3c, 0x7e, 0xb2, 0x43, 0x9c, 0x07, 0xbb, 0xfe, 0x5e, 0xb2, 0x6d, 0xe3, 0xff, 0x3f,
	0x0d, 0x02, 0x76, 0x31, 0x5f, 0x2d, 0x11, 0xc3, 0x3e, 0xa0, 0x4f, 0xba, 0x7d, 0x2d, 0xca, 0xd9,
	0x60, 0x5b, 0xce, 0x18, 0x34, 0xad, 0x4d, 0xe9, 0xb6, 0x28, 0x34, 0x9e, 0x6f, 0x6a, 0xc8, 0xd8,
	0xb2, 0x3a, 0xb5, 0xf7, 0x6a, 0x4f, 0x01, 0x4d, 0x8f, 0xeb, 0x9e, 0x06, 0x0b, 0x5e, 0x81, 0xee,
	0xad, 0x1b, 0x53, 0xa6, 0x6c, 0x12, 0x63, 0x4b, 0x2d, 0x38, 0xe5, 0xdc, 0x7e, 0xb8, 0x2e, 0x4d,
	0xad, 0xae, 0xda, 0xc0, 0xae, 0x50, 0xe2, 0x14, 0x85, 0x33, 0x78, 0xc2, 0xad, 0x95, 0x12, 0xbc,
	0x56, 0x12, 0xe8, 0x21, 0x88, 0x25, 0x50, 0xfb, 0x55, 0x5c, 0xfa, 0xdf, 0xbc, 0xca, 0xb7, 0xab,
	0xb2, 0x27, 0x64, 0x67, 0xf8, 0x16, 0xf4, 0x35, 0x74, 0xf4, 0x36, 0xdd, 0x40, 0x32, 0xc8, 0x90,
	0x9f, 0xee, 0x10, 0xb9, 0xab, 0xac, 0x6c, 0xba, 0xfd, 0x7b, 0x30, 0x5f, 0x25, 0xd0, 0xab, 0xf8,
	0xd6, 0xa5, 0xff, 0x29, 0x04, 0x47, 0x5c, 0x54, 0xde, 0xae, 0x54, 0x05, 0x8e, 0x34, 0xf8, 0x52,
	0x2b, 0x72, 0xc1, 0x4e, 0x76, 0x87, 0xb4, 0x51, 0x5f, 0x92, 0x74, 0x83, 0x00, 0x56, 0x5a, 0xe6,
	0x71, 0x19, 0xfa, 0x1b, 0xf4, 0xf4, 0x8a, 0xcc, 0x1f, 0x03, 0x74, 0x14, 0x70, 0xda, 0xf8, 0x69,
	0x36, 0xe6, 0x94, 0xa8, 0xb4, 0x86, 0x76, 0x31, 0x2f, 0x57, 0x6c, 0x10, 0x1a, 0xdc, 0x3c, 0xae,
	0xc1, 0x34, 0xcc, 0xab, 0x8b, 0x4e, 0x69, 0x35, 0xcc, 0xa2, 0x11, 0xdc, 0x14, 0xff, 0x24, 0x7e,
	0x05, 0xc4, 0xa2, 0x2e, 0x57, 0x74, 0x4b, 0x76, 0x67, 0xf6, 0x6b, 0x2c, 0xcd, 0x06, 0xa4, 0xde,
	0xa2, 0xbe, 0xa4, 0x5b, 0x2e, 0x91, 0xec, 0xf3, 0x6d, 0x5c, 0xb8, 0x9f, 0x87, 0x47, 0xea, 0xc2,
	0xd1, 0x09, 0xbb, 0x7b, 0xce, 0xdd, 0xf8, 0x1e, 0x82, 0x01, 0x4f, 0xd0, 0x29, 0x57, 0x35, 0xc2,
	0xcd, 0xfe, 0x77, 0x58, 0x64, 0xd2, 0x13, 0xb0, 0x4d, 0x54, 0x76, 0x43, 0x65, 0x4f, 0xf6, 0x28,
	0xbf, 0x62, 0x1b, 0xba, 0x1d, 0xf3, 0x1e, 0xbe, 0xe3, 0x1c, 0x94, 0xfa, 0x48, 0xfa, 0xa7, 0x11,
	0x48, 0xb4, 0x72, 0x3d, 0x07, 0x5d, 0x8d, 0x1b, 0x1e, 0xd4, 0xc9, 0xa9, 0xc8, 0x77, 0x13, 0x25,
	0x35, 0x56, 0x63, 0x02, 0x3d, 0x05, 0x6f, 0xd5, 0xd0, 0xd9, 0xeb, 0x97, 0x7d, 0x9e, 0x74, 0xf2,
	0xf3, 0xa1, 0x1f, 0x6b, 0x5b, 0xbd, 0x0b, 0x87, 0xd1, 0x3b, 0x3e, 0xdf, 0x24, 0x43, 0xbb, 0x18,
	0x38, 0xfe, 0x59, 0xdd, 0xbd, 0xaa, 0xf4, 0xcb, 0x91, 0x75, 0xdc, 0x1a, 0x92, 0xc4, 0x04, 0x44,
	0xde, 0xe3, 0x6b, 0x70, 0xd0, 0xb5, 0x4f, 0xcf, 0xad, 0x5d, 0xca, 0x6a, 0xd2, 0x03, 0x35, 0x70,
	0x1b, 0x67, 0x83, 0xcd, 0x71, 0x88, 0xf1, 0xc6, 0x48, 0x91, 0x57, 0xd1, 0xed, 0x37, 0x88, 0x24,
	0x17, 0x0e, 0x2f, 0x41, 0x94, 0x54, 0xec, 0x25, 0xb1, 0x4e, 0x8e, 0x2d, 0xed, 0x9e, 0x3b, 0xcd,
	0x22, 0xc9, 0x41, 0x82, 0x87, 0xa0, 0xc7, 0x2c, 0x28, 0x1a, 0x91, 0x2d, 0x5d, 0xbe, 0x49, 0x0c,
	0x3d, 0x09, 0xec, 0x12, 0xd0, 0xbe, 0xa8, 0x8b, 0xb3, 0xa9, 0x35, 0xfd, 0x47, 0xc4, 0xd0, 0xa7,
	0x2f, 0xef, 0xd4, 0xd1, 0x0f, 0x21, 0x01, 0x5d, 0x8d, 0x1b, 0x41, 0x61, 0x2c, 0x33, 0x76, 0x1a,
	0x30, 0xbb, 0xbc, 0xf4, 0x96, 0xcd, 0xe3, 0xf0, 0x94, 0xe7, 0xe0, 0x96, 0xe2, 0x91, 0x11, 0xa3,
	0x09, 0x10, 0x21, 0xee, 0x72, 0x54, 0x20, 0xb4, 0xc0, 0xde, 0x2b, 0xcd, 0x76, 0x39, 0xe5, 0xd6,
	0x4b, 0x99, 0xc9, 0xec, 0x29, 0xc0, 0xd5, 0xc6, 0x32, 0x2f, 0x58, 0xd4, 0x5f, 0x5f, 0x87, 0x44,
	0x81, 0xd7, 0xd7, 0xff, 0x19, 0x86, 0xb8, 0xd7, 0x0f, 0xbe, 0x0f, 0xdd, 0x95, 0x5a, 0x59, 0x36,
	0x48, 0x55, 0x53, 0x0b, 0x8a, 0xc9, 0x5c, 0x21, 0x6c, 0xdf, 0x63, 0x8f, 0xb1, 0x2a, 0x71, 0x80,
	0x57, 0x89, 0xc2, 0x40, 0x30, 0x19, 0xa6, 0x16, 0x51, 0xa9, 0x95, 0x25, 0x0e, 0x8d, 0xa7, 0x9b,
	0xc5, 0x14, 0xdb, 0xd7, 0x20, 0xbd, 0x82, 0xc3, 0x57, 0x01, 0x5c, 0x1f, 0x32, 0x79, 0x7e, 0x3a,
	0x8c, 0x0b, 0xfa, 0x12, 0x9f, 0x07, 0x15, 0xbe, 0x06, 0x51, 0xfb, 0x19, 0x1a, 0x3d, 0xfc, 0x74,
	0x90, 0x52, 0x5b, 0x5f, 0x9f, 0x35, 0x7e, 0x16, 0x60, 0x63, 0x77, 0xf0, 0xb5, 0xba, 0xba, 0xf0,
	0x44, 0x5c, 0xfd, 0x0d, 0xe8, 0xe5, 0xed, 0x78, 0xfe, 0x53, 0x0d, 0x9e, 0x46, 0x46, 0x3b, 0xe9,
	0xf6, 0x7b, 0x12, 0xae, 0x83, 0xbd, 0xe8, 0x9d, 0xc0, 0x04, 0x12, 0x9e, 0xac, 0xc8, 0x09, 0x44,
	0x3a, 0xf1, 0x9a, 0x76, 0x49, 0xdd, 0x79, 0xaa, 0xa7, 0x34, 0xcd, 0x4d, 0x6f, 0xec, 0xd4, 0xd1,
	0x3a, 0x24, 0x00, 0x72, 0x0d, 0xd5, 0x84, 0xc6, 0x33, 0xe7, 0xda, 0x38, 0xc6, 0x24, 0x74, 0x43,
	0xf4, 0x0a, 0x97, 0x31, 0x9a, 0x80, 0x7e, 0xe8, 0xe5, 0x57, 0x5f, 0xae, 0x8f, 0x9c, 0xd9, 0xc3,
	0x77, 0xce, 0x66, 0x07, 0xa1, 0x97, 0x9a, 0x95, 0x5a, 0xd9, 0x74, 0x1c, 0xa0, 0x9b, 0xaa, 0x8f,
	0xb7, 0x26, 0xa2, 0xf3, 0x42, 0x2c, 0x2a, 0xc6, 0xd2, 0x3f, 0x89, 0x42, 0xff, 0xaa, 0xa5, 0x58,
	0x64, 0xa3, 0xa6, 0x3d, 0x41, 0xfb, 0xef, 0xfa, 0x3f, 0x60, 0xff, 0x65, 0x4f, 0x54, 0x70, 0x5e,
	0x64, 0x3a, 0xae, 0xf0, 0x08, 0x61, 0xd1, 0x47, 0x27, 0xd1, 0xfc, 0x22, 0xd3, 0xc4, 0xaf, 0x35,
	0xdc, 0x4d, 0xe8, 0xe4, 0xc7, 0x07, 0x7b, 0x3f, 0xc1, 0xe5, 0xe1, 0x75, 0x6f, 0x6f, 0x0b, 0xff,
	0x8e, 0xbc, 0x2d, 0xf2, 0xa4, 0xbd, 0x2d, 0xfa, 0xd8, 0xbd, 0xed, 0xc7, 0x3b, 0x75, 0xf4, 0xfb,
	0xad, 0xde, 0x36, 0xd5, 0xc6, 0xdb, 0xce, 0xc0, 0x31, 0xc0, 0x0d, 0x4d, 0xa7, 0xb8, 0x1e, 0xa8,
	0xe3, 0x79, 0xdd, 0x70, 0xb2, 0x9d, 0x1b, 0x9e, 0xdd, 0xc3, 0x0d, 0xcf, 0x1d, 0xe0, 0x86, 0xb1,
	0x79, 0x21, 0x16, 0x13, 0xbb, 0xd2, 0x7f, 0x2c, 0x40, 0x74, 0x5e, 0x5f, 0x67, 0xae, 0x77, 0xa6,
	0xad, 0xeb, 0x61, 0xba, 0xca, 0xeb, 0x7e, 0xc9, 0xb0, 0xdf, 0xe7, 0xbe, 0xcd, 0x1b, 0xdf, 0x4c,
	0xde, 0x98, 0x5e, 0xda, 0xa9, 0xa3, 0xf9, 0x56, 0x13, 0x1b, 0x7b, 0xc4, 0x80, 0x9e, 0xfe, 0x57,
	0x01, 0x7a, 0x5f, 0xd5, 0xf4, 0x75, 0x45, 0x5b, 0xad, 0x12, 0xbb, 0x11, 0x72, 0x1d, 0x7a, 0xf9,
	0x09, 0xd3, 0x29, 0xcd, 0x83, 0x9d, 0x6c, 0xa0, 0xe5, 0x58, 0xd9, 0xb8, 0xe7, 0x36, 0xbd, 0x53,
	0xf8, 0x12, 0x44, 0xfd, 0x35, 0xff, 0x0b, 0x07, 0x20, 0x6e, 0x83, 0xd2, 0xc1, 0x40, 0xcb, 0x3d,
	0x93, 0x67, 0x14, 0x97, 0xdd, 0x8e, 0x4a, 0xcb, 0x36, 0x79, 0xa8, 0x51, 0xee, 0x99, 0xfe, 0x49,
	0xfc, 0x03, 0x08, 0xbd, 0xa5, 0xaf, 0x73, 0x45, 0x9e, 0xda, 0x1f, 0x31, 0xf7, 0x2c, 0x17, 0x19,
	0x5d, 0x89, 0x15, 0xe8, 0x61, 0xbf, 0xfa, 0x64, 0x0f, 0x02, 0x2b, 0x8a, 0x96, 0xfc, 0x2c, 0xda,
	0xf1, 0x83, 0xf6, 0x63, 0x1f, 0xdd, 0xf2, 0x2f, 0x7e, 0x78, 0x0b, 0xd1, 0x72, 0x41, 0xea, 0xa6,
	0xa3, 0x73, 0x7c, 0x10, 0xbf, 0x0e, 0x4e, 0x7b, 0x45, 0xbe, 0x31, 0x65, 0x26, 0x3f, 0x8f, 0x1e,
	0xe6, 0xc5, 0xbc, 0x77, 0xa9, 0x83, 0x1e, 0xf8, 0xd8, 0xa5, 0x29, 0x33, 0x3b, 0x0c, 0x7d, 0xce,
	0x06, 0xdb, 0xbd, 0x4e, 0x88, 0xda, 0xaf, 0x13, 0xce, 0xd0, 0x75, 0xce, 0xeb, 0x84, 0x10, 0xf4,
	0xe6, 0x0c, 0xa2, 0x58, 0xc4, 0x35, 0xac, 0xd7, 0x1e, 0x93, 0x61, 0xb5, 0x9a, 0x54, 0xfe, 0xd1,
	0x4d, 0xca, 0x6b, 0x4c, 0xd7, 0x1f, 0xa3, 0x31, 0xb5, 0x33, 0xa3, 0x97, 0x0e, 0x6f, 0x46, 0xdc,
	0x80, 0xa6, 0x13, 0xbf, 0x3c, 0xdf, 0xe4, 0xa7, 0xd9, 0xef, 0xb4, 0xea, 0xa4, 0xff, 0x0f, 0xfe,
	0x1b, 0x35, 0x0f, 0xa6, 0xdf, 0x0b, 0x41, 0x1f, 0x0d, 0xdc, 0x4a, 0xe1, 0x5b, 0x55, 0x7c, 0xc3,
	0xaa, 0xf8, 0x49, 0x08, 0xe2, 0xaf, 0x12, 0xeb, 0x5b, 0x35, 0x7c, 0xa3, 0x6a, 0x18, 0x7e, 0x1d,
	0xfa, 0xdb, 0xfc, 0xb6, 0x1d, 0x0f, 0xc0, 0x53, 0x57, 0x96, 0x17, 0x2e, 0x2f, 0xe6, 0xe5, 0xc5,
	0xe5, 0xcb, 0x4b, 0x6b, 0xb2, 0x94, 0x9f, 0xb9, 0x20, 0x2f, 0x2f, 0x2d, 0x5c, 0x13, 0x03, 0xf8,
	0x04, 0x1c, 0x6b, 0x9d, 0xbb, 0x2a, 0xcd, 0xad, 0xe5, 0x45, 0x34, 0x10, 0xbf, 0x5f, 0x47, 0x01,
	0x5a, 0xe8, 0x9f, 0xce, 0x8c, 0x0d, 0xdf, 0x45, 0xf0, 0xcc, 0x01, 0xbf, 0xa0, 0xc5, 0xcf, 0xc0,
	0x89, 0x99, 0x5c, 0x2e, 0xbf, 0xba, 0x2a, 0x2f, 0x2e, 0x5f, 0xc8, 0x7b, 0x90, 0xc9, 0xcb, 0x4b,
	0xb9, 0xbc, 0x18, 0xd8, 0x07, 0x60, 0x71, 0x66, 0xe9, 0x9a, 0x88, 0xf0, 0x20, 0x0c, 0xb4, 0x00,
	0x50, 0x56, 0xed, 0xf9, 0xe0, 0x40, 0x0f, 0x67, 0x29, 0x7c, 0x3a, 0x33, 0x96, 0x19, 0x1f, 0xfe,
	0x2b, 0x04, 0xfd, 0x6d, 0x7e, 0xb8, 0x84, 0x9f, 0x86, 0xe3, 0x73, 0x8b, 0x33, 0xaf, 0xe6, 0xe5,
	0x95, 0xcb, 0x0b, 0x0b, 0xf2, 0xca, 0xf2, 0xc2, 0x5c, 0xee, 0x9a, 0x7c, 0x21, 0x7f, 0x71, 0xe6,
	0xf2, 0xc2, 0x9a, 0x18, 0xc0, 0xcf, 0x41, 0xaa, 0x75, 0x7a, 0xee, 0xa2, 0xbc, 0xb4, 0xbc, 0x26,
	0xaf, 0x48, 0xf9, 0xd5, 0xfc, 0xd2, 0x9a, 0x88, 0xf0, 0x49, 0x48, 0xb6, 0x42, 0xcd, 0x2c, 0x5c,
	0x9d, 0xb9, 0xb6, 0x2a, 0x06, 0xa9, 0xe4, 0x5a, 0x67, 0x97, 0xf2, 0x57, 0xf2, 0x92, 0x18, 0x1a,
	0xe8, 0xe3, 0x6c, 0x46, 0x19, 0x9b, 0x99, 0x89, 0xe1, 0x77, 0x11, 0xf4, 0xb7, 0x79, 0x9d, 0x4d,
	0xf7, 0x9b, 0x5b, 0x5e, 0x5a, 0x9b, 0x99, 0x5b, 0xca, 0x4b, 0xf2, 0xc5, 0x85, 0x99, 0x2b, 0xcb,
	0x92, 0xbc, 0x76, 0x6d, 0x25, 0x2f, 0xaf, 0xcd, 0x2d, 0x51, 0xfd, 0xa4, 0xe0, 0x64, 0xfb, 0xf9,
	0xc5, 0xfc, 0x85, 0xb9, 0xcb, 0x8b, 0x22, 0xa2, 0x22, 0x6d, 0x0f, 0xb1, 0x30, 0x23, 0xbd, 0x9a,
	0x6f, 0x15, 0xd9, 0xbb, 0x08, 0xba, 0xbd, 0x2f, 0x01, 0xb0, 0x08, 0xdd, 0x2b, 0xd2, 0xf2, 0xda,
	0x72, 0x6e, 0x79, 0x41, 0x5e, 0xcb, 0xad, 0x88, 0x01, 0x9c, 0x80, 0x1e, 0x77, 0x64, 0x76, 0x6d,
	0x6d, 0x45, 0x44, 0x18, 0x43, 0xaf, 0x6f, 0x68, 0x5c, 0x0c, 0xe2, 0xe3, 0x70, 0xb4, 0xb1, 0x70,
	0x61, 0x55, 0xbe, 0x3a, 0xb7, 0x36, 0x2b, 0xaf, 0x2e, 0xcd, 0x89, 0x21, 0x1f, 0xce, 0xcb, 0x17,
	0x56, 0x44, 0x61, 0x20, 0xc1, 0xb9, 0xe8, 0xa2, 0x5c, 0x4c, 0x64, 0xc6, 0x33, 0x93, 0xd9, 0xf7,
	0xd1, 0x83, 0x4f, 0x06, 0x03, 0x0f, 0x3f, 0x19, 0x0c, 0x7c, 0xf1, 0xc9, 0x20, 0xba, 0xbd, 0x3b,
	0x88, 0x3e, 0xd8, 0x1d, 0x44, 0x3f, 0xdf, 0x1d, 0x44, 0x0f, 0x76, 0x07, 0xd1, 0xc3, 0xdd, 0x41,
	0xf4, 0xf1, 0xee, 0x20, 0xfa, 0x6c, 0x77, 0x30, 0xf0, 0xc5, 0xee, 0x20, 0x7a, 0xff, 0xd3, 0xc1,
	0xc0, 0xfd, 0x4f, 0x07, 0xd1, 0x83, 0x4f, 0x07, 0x03, 0x0f, 0x3f, 0x1d, 0x0c, 0xfc, 0x48, 0xda,
	0xd4, 0xab, 0x37, 0x36, 0x47, 0xb6, 0x74, 0xcd, 0x22, 0x86, 0xa1, 0x8c, 0xd4, 0xcc, 0x51, 0xf6,
	0x61, 0x43, 0x37, 0xca, 0x2f, 0x56, 0x0d, 0x7d, 0x4b, 0x2d, 0x12, 0xe3, 0x45, 0x67, 0x7a, 0xb4,
	0xba, 0xbe, 0xa9, 0x8f, 0x92, 0x77, 0x2c, 0xfe, 0x7f, 0x25, 0xda, 0xfe, 0x03, 0x8e, 0xf5, 0x08,
	0x7b, 0x15, 0x31, 0xf1, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x39, 0x75, 0xbb, 0xcf, 0xa7, 0x43,
	0x00, 0x00,
}

func (x VolumeMountModeType) String() string {
	s, ok := VolumeMountModeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PersistentStorageAccessModeType) String() string {
	s, ok := PersistentStorageAccessModeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ImagePullPolicyType) String() string {
	s, ok := ImagePullPolicyType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ContainerFlavorType) String() string {
	s, ok := ContainerFlavorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ProtocolType) String() string {
	s, ok := ProtocolType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *VolumeMountType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolumeMountType)
	if !ok {
		that2, ok := that.(VolumeMountType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.MountPath != that1.MountPath {
		return false
	}
	if this.SubPath != that1.SubPath {
		return false
	}
	return true
}
func (this *ConfigurationFileType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigurationFileType)
	if !ok {
		that2, ok := that.(ConfigurationFileType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Data != that1.Data {
		return false
	}
	if this.VolumeName != that1.VolumeName {
		return false
	}
	if !this.Mount.Equal(that1.Mount) {
		return false
	}
	return true
}
func (this *EnvironmentVariableType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EnvironmentVariableType)
	if !ok {
		that2, ok := that.(EnvironmentVariableType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ConfigurationParameterType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigurationParameterType)
	if !ok {
		that2, ok := that.(ConfigurationParameterType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *ConfigurationParameterType_File) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigurationParameterType_File)
	if !ok {
		that2, ok := that.(ConfigurationParameterType_File)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.File.Equal(that1.File) {
		return false
	}
	return true
}
func (this *ConfigurationParameterType_EnvVar) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigurationParameterType_EnvVar)
	if !ok {
		that2, ok := that.(ConfigurationParameterType_EnvVar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnvVar.Equal(that1.EnvVar) {
		return false
	}
	return true
}
func (this *ConfigurationParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigurationParametersType)
	if !ok {
		that2, ok := that.(ConfigurationParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Parameters) != len(that1.Parameters) {
		return false
	}
	for i := range this.Parameters {
		if !this.Parameters[i].Equal(that1.Parameters[i]) {
			return false
		}
	}
	return true
}
func (this *PersistentStorageType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PersistentStorageType)
	if !ok {
		that2, ok := that.(PersistentStorageType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccessMode != that1.AccessMode {
		return false
	}
	if this.StorageSize != that1.StorageSize {
		return false
	}
	if that1.ClassNameChoice == nil {
		if this.ClassNameChoice != nil {
			return false
		}
	} else if this.ClassNameChoice == nil {
		return false
	} else if !this.ClassNameChoice.Equal(that1.ClassNameChoice) {
		return false
	}
	return true
}
func (this *PersistentStorageType_Default) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PersistentStorageType_Default)
	if !ok {
		that2, ok := that.(PersistentStorageType_Default)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Default.Equal(that1.Default) {
		return false
	}
	return true
}
func (this *PersistentStorageType_ClassName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PersistentStorageType_ClassName)
	if !ok {
		that2, ok := that.(PersistentStorageType_ClassName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClassName != that1.ClassName {
		return false
	}
	return true
}
func (this *PersistentStorageVolumeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PersistentStorageVolumeType)
	if !ok {
		that2, ok := that.(PersistentStorageVolumeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Storage.Equal(that1.Storage) {
		return false
	}
	if !this.Mount.Equal(that1.Mount) {
		return false
	}
	return true
}
func (this *EmptyDirectoryVolumeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EmptyDirectoryVolumeType)
	if !ok {
		that2, ok := that.(EmptyDirectoryVolumeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SizeLimit != that1.SizeLimit {
		return false
	}
	if !this.Mount.Equal(that1.Mount) {
		return false
	}
	return true
}
func (this *HostPathVolumeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostPathVolumeType)
	if !ok {
		that2, ok := that.(HostPathVolumeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if !this.Mount.Equal(that1.Mount) {
		return false
	}
	return true
}
func (this *StorageVolumeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageVolumeType)
	if !ok {
		that2, ok := that.(StorageVolumeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.VolumeChoice == nil {
		if this.VolumeChoice != nil {
			return false
		}
	} else if this.VolumeChoice == nil {
		return false
	} else if !this.VolumeChoice.Equal(that1.VolumeChoice) {
		return false
	}
	return true
}
func (this *StorageVolumeType_PersistentVolume) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageVolumeType_PersistentVolume)
	if !ok {
		that2, ok := that.(StorageVolumeType_PersistentVolume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PersistentVolume.Equal(that1.PersistentVolume) {
		return false
	}
	return true
}
func (this *StorageVolumeType_EmptyDir) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageVolumeType_EmptyDir)
	if !ok {
		that2, ok := that.(StorageVolumeType_EmptyDir)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EmptyDir.Equal(that1.EmptyDir) {
		return false
	}
	return true
}
func (this *StorageVolumeType_HostPath) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageVolumeType_HostPath)
	if !ok {
		that2, ok := that.(StorageVolumeType_HostPath)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HostPath.Equal(that1.HostPath) {
		return false
	}
	return true
}
func (this *EphemeralStorageVolumeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EphemeralStorageVolumeType)
	if !ok {
		that2, ok := that.(EphemeralStorageVolumeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.VolumeChoice == nil {
		if this.VolumeChoice != nil {
			return false
		}
	} else if this.VolumeChoice == nil {
		return false
	} else if !this.VolumeChoice.Equal(that1.VolumeChoice) {
		return false
	}
	return true
}
func (this *EphemeralStorageVolumeType_EmptyDir) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EphemeralStorageVolumeType_EmptyDir)
	if !ok {
		that2, ok := that.(EphemeralStorageVolumeType_EmptyDir)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EmptyDir.Equal(that1.EmptyDir) {
		return false
	}
	return true
}
func (this *EphemeralStorageVolumeType_HostPath) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EphemeralStorageVolumeType_HostPath)
	if !ok {
		that2, ok := that.(EphemeralStorageVolumeType_HostPath)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HostPath.Equal(that1.HostPath) {
		return false
	}
	return true
}
func (this *PersistentVolumeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PersistentVolumeType)
	if !ok {
		that2, ok := that.(PersistentVolumeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.PersistentVolume.Equal(that1.PersistentVolume) {
		return false
	}
	return true
}
func (this *ImageType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType)
	if !ok {
		that2, ok := that.(ImageType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.RegistryChoice == nil {
		if this.RegistryChoice != nil {
			return false
		}
	} else if this.RegistryChoice == nil {
		return false
	} else if !this.RegistryChoice.Equal(that1.RegistryChoice) {
		return false
	}
	if this.PullPolicy != that1.PullPolicy {
		return false
	}
	return true
}
func (this *ImageType_Public) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType_Public)
	if !ok {
		that2, ok := that.(ImageType_Public)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Public.Equal(that1.Public) {
		return false
	}
	return true
}
func (this *ImageType_ContainerRegistry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageType_ContainerRegistry)
	if !ok {
		that2, ok := that.(ImageType_ContainerRegistry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ContainerRegistry.Equal(that1.ContainerRegistry) {
		return false
	}
	return true
}
func (this *PortChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortChoiceType)
	if !ok {
		that2, ok := that.(PortChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PortChoice == nil {
		if this.PortChoice != nil {
			return false
		}
	} else if this.PortChoice == nil {
		return false
	} else if !this.PortChoice.Equal(that1.PortChoice) {
		return false
	}
	return true
}
func (this *PortChoiceType_Num) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortChoiceType_Num)
	if !ok {
		that2, ok := that.(PortChoiceType_Num)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Num != that1.Num {
		return false
	}
	return true
}
func (this *PortChoiceType_Name) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortChoiceType_Name)
	if !ok {
		that2, ok := that.(PortChoiceType_Name)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *HTTPHealthCheckType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HTTPHealthCheckType)
	if !ok {
		that2, ok := that.(HTTPHealthCheckType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if !this.Port.Equal(that1.Port) {
		return false
	}
	if this.HostHeader != that1.HostHeader {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if this.Headers[i] != that1.Headers[i] {
			return false
		}
	}
	return true
}
func (this *ExecHealthCheckType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecHealthCheckType)
	if !ok {
		that2, ok := that.(ExecHealthCheckType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	return true
}
func (this *TCPHealthCheckType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TCPHealthCheckType)
	if !ok {
		that2, ok := that.(TCPHealthCheckType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Port.Equal(that1.Port) {
		return false
	}
	return true
}
func (this *HealthCheckType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HealthCheckType)
	if !ok {
		that2, ok := that.(HealthCheckType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HealthCheckChoice == nil {
		if this.HealthCheckChoice != nil {
			return false
		}
	} else if this.HealthCheckChoice == nil {
		return false
	} else if !this.HealthCheckChoice.Equal(that1.HealthCheckChoice) {
		return false
	}
	if this.InitialDelay != that1.InitialDelay {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if this.HealthyThreshold != that1.HealthyThreshold {
		return false
	}
	if this.UnhealthyThreshold != that1.UnhealthyThreshold {
		return false
	}
	return true
}
func (this *HealthCheckType_HttpHealthCheck) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HealthCheckType_HttpHealthCheck)
	if !ok {
		that2, ok := that.(HealthCheckType_HttpHealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpHealthCheck.Equal(that1.HttpHealthCheck) {
		return false
	}
	return true
}
func (this *HealthCheckType_TcpHealthCheck) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HealthCheckType_TcpHealthCheck)
	if !ok {
		that2, ok := that.(HealthCheckType_TcpHealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TcpHealthCheck.Equal(that1.TcpHealthCheck) {
		return false
	}
	return true
}
func (this *HealthCheckType_ExecHealthCheck) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HealthCheckType_ExecHealthCheck)
	if !ok {
		that2, ok := that.(HealthCheckType_ExecHealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExecHealthCheck.Equal(that1.ExecHealthCheck) {
		return false
	}
	return true
}
func (this *ContainerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerType)
	if !ok {
		that2, ok := that.(ContainerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Image.Equal(that1.Image) {
		return false
	}
	if this.InitContainer != that1.InitContainer {
		return false
	}
	if this.Flavor != that1.Flavor {
		return false
	}
	if !this.LivenessCheck.Equal(that1.LivenessCheck) {
		return false
	}
	if !this.ReadinessCheck.Equal(that1.ReadinessCheck) {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	return true
}
func (this *DeployCESiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployCESiteType)
	if !ok {
		that2, ok := that.(DeployCESiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	return true
}
func (this *DeployRESiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployRESiteType)
	if !ok {
		that2, ok := that.(DeployRESiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	return true
}
func (this *DeployREVirtualSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployREVirtualSiteType)
	if !ok {
		that2, ok := that.(DeployREVirtualSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VirtualSite) != len(that1.VirtualSite) {
		return false
	}
	for i := range this.VirtualSite {
		if !this.VirtualSite[i].Equal(that1.VirtualSite[i]) {
			return false
		}
	}
	return true
}
func (this *DeployCEVirtualSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployCEVirtualSiteType)
	if !ok {
		that2, ok := that.(DeployCEVirtualSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VirtualSite) != len(that1.VirtualSite) {
		return false
	}
	for i := range this.VirtualSite {
		if !this.VirtualSite[i].Equal(that1.VirtualSite[i]) {
			return false
		}
	}
	return true
}
func (this *DeployOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployOptionsType)
	if !ok {
		that2, ok := that.(DeployOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DeployChoice == nil {
		if this.DeployChoice != nil {
			return false
		}
	} else if this.DeployChoice == nil {
		return false
	} else if !this.DeployChoice.Equal(that1.DeployChoice) {
		return false
	}
	return true
}
func (this *DeployOptionsType_AllRes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployOptionsType_AllRes)
	if !ok {
		that2, ok := that.(DeployOptionsType_AllRes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllRes.Equal(that1.AllRes) {
		return false
	}
	return true
}
func (this *DeployOptionsType_DeployReVirtualSites) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployOptionsType_DeployReVirtualSites)
	if !ok {
		that2, ok := that.(DeployOptionsType_DeployReVirtualSites)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeployReVirtualSites.Equal(that1.DeployReVirtualSites) {
		return false
	}
	return true
}
func (this *DeployOptionsType_DeployCeVirtualSites) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployOptionsType_DeployCeVirtualSites)
	if !ok {
		that2, ok := that.(DeployOptionsType_DeployCeVirtualSites)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeployCeVirtualSites.Equal(that1.DeployCeVirtualSites) {
		return false
	}
	return true
}
func (this *DeployOptionsType_DeployCeSites) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployOptionsType_DeployCeSites)
	if !ok {
		that2, ok := that.(DeployOptionsType_DeployCeSites)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeployCeSites.Equal(that1.DeployCeSites) {
		return false
	}
	return true
}
func (this *DeployOptionsType_DefaultVirtualSites) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployOptionsType_DefaultVirtualSites)
	if !ok {
		that2, ok := that.(DeployOptionsType_DefaultVirtualSites)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultVirtualSites.Equal(that1.DefaultVirtualSites) {
		return false
	}
	return true
}
func (this *DeployOptionsType_DeployReSites) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeployOptionsType_DeployReSites)
	if !ok {
		that2, ok := that.(DeployOptionsType_DeployReSites)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeployReSites.Equal(that1.DeployReSites) {
		return false
	}
	return true
}
func (this *RouteInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteInfoType)
	if !ok {
		that2, ok := that.(RouteInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *RouteInfoType_SimpleRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteInfoType_SimpleRoute)
	if !ok {
		that2, ok := that.(RouteInfoType_SimpleRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SimpleRoute.Equal(that1.SimpleRoute) {
		return false
	}
	return true
}
func (this *RouteInfoType_RedirectRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteInfoType_RedirectRoute)
	if !ok {
		that2, ok := that.(RouteInfoType_RedirectRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RedirectRoute.Equal(that1.RedirectRoute) {
		return false
	}
	return true
}
func (this *RouteInfoType_DirectResponseRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteInfoType_DirectResponseRoute)
	if !ok {
		that2, ok := that.(RouteInfoType_DirectResponseRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DirectResponseRoute.Equal(that1.DirectResponseRoute) {
		return false
	}
	return true
}
func (this *RouteInfoType_CustomRouteObject) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteInfoType_CustomRouteObject)
	if !ok {
		that2, ok := that.(RouteInfoType_CustomRouteObject)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomRouteObject.Equal(that1.CustomRouteObject) {
		return false
	}
	return true
}
func (this *RouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteType)
	if !ok {
		that2, ok := that.(RouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *MatchAllRouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchAllRouteType)
	if !ok {
		that2, ok := that.(MatchAllRouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HostRewriteParams == nil {
		if this.HostRewriteParams != nil {
			return false
		}
	} else if this.HostRewriteParams == nil {
		return false
	} else if !this.HostRewriteParams.Equal(that1.HostRewriteParams) {
		return false
	}
	return true
}
func (this *MatchAllRouteType_AutoHostRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchAllRouteType_AutoHostRewrite)
	if !ok {
		that2, ok := that.(MatchAllRouteType_AutoHostRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AutoHostRewrite.Equal(that1.AutoHostRewrite) {
		return false
	}
	return true
}
func (this *MatchAllRouteType_HostRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchAllRouteType_HostRewrite)
	if !ok {
		that2, ok := that.(MatchAllRouteType_HostRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostRewrite != that1.HostRewrite {
		return false
	}
	return true
}
func (this *MatchAllRouteType_DisableHostRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchAllRouteType_DisableHostRewrite)
	if !ok {
		that2, ok := that.(MatchAllRouteType_DisableHostRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableHostRewrite.Equal(that1.DisableHostRewrite) {
		return false
	}
	return true
}
func (this *HTTPLoadBalancerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HTTPLoadBalancerType)
	if !ok {
		that2, ok := that.(HTTPLoadBalancerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if that1.LoadbalancerType == nil {
		if this.LoadbalancerType != nil {
			return false
		}
	} else if this.LoadbalancerType == nil {
		return false
	} else if !this.LoadbalancerType.Equal(that1.LoadbalancerType) {
		return false
	}
	if that1.RouteChoice == nil {
		if this.RouteChoice != nil {
			return false
		}
	} else if this.RouteChoice == nil {
		return false
	} else if !this.RouteChoice.Equal(that1.RouteChoice) {
		return false
	}
	return true
}
func (this *HTTPLoadBalancerType_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HTTPLoadBalancerType_Http)
	if !ok {
		that2, ok := that.(HTTPLoadBalancerType_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *HTTPLoadBalancerType_HttpsAutoCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HTTPLoadBalancerType_HttpsAutoCert)
	if !ok {
		that2, ok := that.(HTTPLoadBalancerType_HttpsAutoCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpsAutoCert.Equal(that1.HttpsAutoCert) {
		return false
	}
	return true
}
func (this *HTTPLoadBalancerType_Https) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HTTPLoadBalancerType_Https)
	if !ok {
		that2, ok := that.(HTTPLoadBalancerType_Https)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Https.Equal(that1.Https) {
		return false
	}
	return true
}
func (this *HTTPLoadBalancerType_DefaultRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HTTPLoadBalancerType_DefaultRoute)
	if !ok {
		that2, ok := that.(HTTPLoadBalancerType_DefaultRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultRoute.Equal(that1.DefaultRoute) {
		return false
	}
	return true
}
func (this *HTTPLoadBalancerType_SpecificRoutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HTTPLoadBalancerType_SpecificRoutes)
	if !ok {
		that2, ok := that.(HTTPLoadBalancerType_SpecificRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SpecificRoutes.Equal(that1.SpecificRoutes) {
		return false
	}
	return true
}
func (this *TCPLoadBalancerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TCPLoadBalancerType)
	if !ok {
		that2, ok := that.(TCPLoadBalancerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if this.WithSni != that1.WithSni {
		return false
	}
	return true
}
func (this *PortInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortInfoType)
	if !ok {
		that2, ok := that.(PortInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.TargetPortChoice == nil {
		if this.TargetPortChoice != nil {
			return false
		}
	} else if this.TargetPortChoice == nil {
		return false
	} else if !this.TargetPortChoice.Equal(that1.TargetPortChoice) {
		return false
	}
	return true
}
func (this *PortInfoType_SameAsPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortInfoType_SameAsPort)
	if !ok {
		that2, ok := that.(PortInfoType_SameAsPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SameAsPort.Equal(that1.SameAsPort) {
		return false
	}
	return true
}
func (this *PortInfoType_TargetPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortInfoType_TargetPort)
	if !ok {
		that2, ok := that.(PortInfoType_TargetPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TargetPort != that1.TargetPort {
		return false
	}
	return true
}
func (this *PortType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortType)
	if !ok {
		that2, ok := that.(PortType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	return true
}
func (this *MultiPortType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultiPortType)
	if !ok {
		that2, ok := that.(MultiPortType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	return true
}
func (this *SinglePortType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SinglePortType)
	if !ok {
		that2, ok := that.(SinglePortType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	return true
}
func (this *AdvertiseInClusterType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseInClusterType)
	if !ok {
		that2, ok := that.(AdvertiseInClusterType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PortChoice == nil {
		if this.PortChoice != nil {
			return false
		}
	} else if this.PortChoice == nil {
		return false
	} else if !this.PortChoice.Equal(that1.PortChoice) {
		return false
	}
	return true
}
func (this *AdvertiseInClusterType_Port) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseInClusterType_Port)
	if !ok {
		that2, ok := that.(AdvertiseInClusterType_Port)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Port.Equal(that1.Port) {
		return false
	}
	return true
}
func (this *AdvertiseInClusterType_MultiPorts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseInClusterType_MultiPorts)
	if !ok {
		that2, ok := that.(AdvertiseInClusterType_MultiPorts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MultiPorts.Equal(that1.MultiPorts) {
		return false
	}
	return true
}
func (this *AdvertiseSinglePortType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseSinglePortType)
	if !ok {
		that2, ok := that.(AdvertiseSinglePortType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Port.Equal(that1.Port) {
		return false
	}
	if that1.AdvertiseChoice == nil {
		if this.AdvertiseChoice != nil {
			return false
		}
	} else if this.AdvertiseChoice == nil {
		return false
	} else if !this.AdvertiseChoice.Equal(that1.AdvertiseChoice) {
		return false
	}
	return true
}
func (this *AdvertiseSinglePortType_HttpLoadbalancer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseSinglePortType_HttpLoadbalancer)
	if !ok {
		that2, ok := that.(AdvertiseSinglePortType_HttpLoadbalancer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpLoadbalancer.Equal(that1.HttpLoadbalancer) {
		return false
	}
	return true
}
func (this *AdvertiseSinglePortType_TcpLoadbalancer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseSinglePortType_TcpLoadbalancer)
	if !ok {
		that2, ok := that.(AdvertiseSinglePortType_TcpLoadbalancer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TcpLoadbalancer.Equal(that1.TcpLoadbalancer) {
		return false
	}
	return true
}
func (this *AdvertisePortType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertisePortType)
	if !ok {
		that2, ok := that.(AdvertisePortType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Port.Equal(that1.Port) {
		return false
	}
	if that1.AdvertiseChoice == nil {
		if this.AdvertiseChoice != nil {
			return false
		}
	} else if this.AdvertiseChoice == nil {
		return false
	} else if !this.AdvertiseChoice.Equal(that1.AdvertiseChoice) {
		return false
	}
	return true
}
func (this *AdvertisePortType_HttpLoadbalancer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertisePortType_HttpLoadbalancer)
	if !ok {
		that2, ok := that.(AdvertisePortType_HttpLoadbalancer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpLoadbalancer.Equal(that1.HttpLoadbalancer) {
		return false
	}
	return true
}
func (this *AdvertisePortType_TcpLoadbalancer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertisePortType_TcpLoadbalancer)
	if !ok {
		that2, ok := that.(AdvertisePortType_TcpLoadbalancer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TcpLoadbalancer.Equal(that1.TcpLoadbalancer) {
		return false
	}
	return true
}
func (this *AdvertiseMultiPortType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseMultiPortType)
	if !ok {
		that2, ok := that.(AdvertiseMultiPortType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	return true
}
func (this *AdvertisePublicType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertisePublicType)
	if !ok {
		that2, ok := that.(AdvertisePublicType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AdvertiseChoice == nil {
		if this.AdvertiseChoice != nil {
			return false
		}
	} else if this.AdvertiseChoice == nil {
		return false
	} else if !this.AdvertiseChoice.Equal(that1.AdvertiseChoice) {
		return false
	}
	return true
}
func (this *AdvertisePublicType_Port) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertisePublicType_Port)
	if !ok {
		that2, ok := that.(AdvertisePublicType_Port)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Port.Equal(that1.Port) {
		return false
	}
	return true
}
func (this *AdvertisePublicType_MultiPorts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertisePublicType_MultiPorts)
	if !ok {
		that2, ok := that.(AdvertisePublicType_MultiPorts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MultiPorts.Equal(that1.MultiPorts) {
		return false
	}
	return true
}
func (this *AdvertiseWhereType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseWhereType)
	if !ok {
		that2, ok := that.(AdvertiseWhereType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AdvertiseWhereType_Site) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseWhereType_Site)
	if !ok {
		that2, ok := that.(AdvertiseWhereType_Site)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	return true
}
func (this *AdvertiseWhereType_VirtualSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseWhereType_VirtualSite)
	if !ok {
		that2, ok := that.(AdvertiseWhereType_VirtualSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualSite.Equal(that1.VirtualSite) {
		return false
	}
	return true
}
func (this *AdvertiseWhereType_Vk8SService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseWhereType_Vk8SService)
	if !ok {
		that2, ok := that.(AdvertiseWhereType_Vk8SService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Vk8SService.Equal(that1.Vk8SService) {
		return false
	}
	return true
}
func (this *AdvertiseCustomType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseCustomType)
	if !ok {
		that2, ok := that.(AdvertiseCustomType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	if len(this.AdvertiseWhere) != len(that1.AdvertiseWhere) {
		return false
	}
	for i := range this.AdvertiseWhere {
		if !this.AdvertiseWhere[i].Equal(that1.AdvertiseWhere[i]) {
			return false
		}
	}
	return true
}
func (this *AdvertiseOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseOptionsType)
	if !ok {
		that2, ok := that.(AdvertiseOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AdvertiseChoice == nil {
		if this.AdvertiseChoice != nil {
			return false
		}
	} else if this.AdvertiseChoice == nil {
		return false
	} else if !this.AdvertiseChoice.Equal(that1.AdvertiseChoice) {
		return false
	}
	return true
}
func (this *AdvertiseOptionsType_AdvertiseInCluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseOptionsType_AdvertiseInCluster)
	if !ok {
		that2, ok := that.(AdvertiseOptionsType_AdvertiseInCluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AdvertiseInCluster.Equal(that1.AdvertiseInCluster) {
		return false
	}
	return true
}
func (this *AdvertiseOptionsType_AdvertiseOnPublic) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseOptionsType_AdvertiseOnPublic)
	if !ok {
		that2, ok := that.(AdvertiseOptionsType_AdvertiseOnPublic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AdvertiseOnPublic.Equal(that1.AdvertiseOnPublic) {
		return false
	}
	return true
}
func (this *AdvertiseOptionsType_AdvertiseCustom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseOptionsType_AdvertiseCustom)
	if !ok {
		that2, ok := that.(AdvertiseOptionsType_AdvertiseCustom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AdvertiseCustom.Equal(that1.AdvertiseCustom) {
		return false
	}
	return true
}
func (this *AdvertiseOptionsType_DoNotAdvertise) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseOptionsType_DoNotAdvertise)
	if !ok {
		that2, ok := that.(AdvertiseOptionsType_DoNotAdvertise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DoNotAdvertise.Equal(that1.DoNotAdvertise) {
		return false
	}
	return true
}
func (this *AdvertiseSimpleServiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvertiseSimpleServiceType)
	if !ok {
		that2, ok := that.(AdvertiseSimpleServiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if this.ServicePort != that1.ServicePort {
		return false
	}
	return true
}
func (this *SimpleServiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleServiceType)
	if !ok {
		that2, ok := that.(SimpleServiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Container.Equal(that1.Container) {
		return false
	}
	if !this.Configuration.Equal(that1.Configuration) {
		return false
	}
	if that1.AdvertiseChoice == nil {
		if this.AdvertiseChoice != nil {
			return false
		}
	} else if this.AdvertiseChoice == nil {
		return false
	} else if !this.AdvertiseChoice.Equal(that1.AdvertiseChoice) {
		return false
	}
	if that1.PersistenceChoice == nil {
		if this.PersistenceChoice != nil {
			return false
		}
	} else if this.PersistenceChoice == nil {
		return false
	} else if !this.PersistenceChoice.Equal(that1.PersistenceChoice) {
		return false
	}
	if this.ScaleToZero != that1.ScaleToZero {
		return false
	}
	return true
}
func (this *SimpleServiceType_DoNotAdvertise) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleServiceType_DoNotAdvertise)
	if !ok {
		that2, ok := that.(SimpleServiceType_DoNotAdvertise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DoNotAdvertise.Equal(that1.DoNotAdvertise) {
		return false
	}
	return true
}
func (this *SimpleServiceType_ServicePort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleServiceType_ServicePort)
	if !ok {
		that2, ok := that.(SimpleServiceType_ServicePort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServicePort != that1.ServicePort {
		return false
	}
	return true
}
func (this *SimpleServiceType_SimpleAdvertise) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleServiceType_SimpleAdvertise)
	if !ok {
		that2, ok := that.(SimpleServiceType_SimpleAdvertise)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SimpleAdvertise.Equal(that1.SimpleAdvertise) {
		return false
	}
	return true
}
func (this *SimpleServiceType_Disabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleServiceType_Disabled)
	if !ok {
		that2, ok := that.(SimpleServiceType_Disabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disabled.Equal(that1.Disabled) {
		return false
	}
	return true
}
func (this *SimpleServiceType_Enabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SimpleServiceType_Enabled)
	if !ok {
		that2, ok := that.(SimpleServiceType_Enabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Enabled.Equal(that1.Enabled) {
		return false
	}
	return true
}
func (this *ServiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceType)
	if !ok {
		that2, ok := that.(ServiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ScalingChoice == nil {
		if this.ScalingChoice != nil {
			return false
		}
	} else if this.ScalingChoice == nil {
		return false
	} else if !this.ScalingChoice.Equal(that1.ScalingChoice) {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(that1.Containers[i]) {
			return false
		}
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(that1.Volumes[i]) {
			return false
		}
	}
	if !this.Configuration.Equal(that1.Configuration) {
		return false
	}
	if !this.DeployOptions.Equal(that1.DeployOptions) {
		return false
	}
	if !this.AdvertiseOptions.Equal(that1.AdvertiseOptions) {
		return false
	}
	return true
}
func (this *ServiceType_NumReplicas) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceType_NumReplicas)
	if !ok {
		that2, ok := that.(ServiceType_NumReplicas)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumReplicas != that1.NumReplicas {
		return false
	}
	return true
}
func (this *ServiceType_ScaleToZero) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceType_ScaleToZero)
	if !ok {
		that2, ok := that.(ServiceType_ScaleToZero)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ScaleToZero.Equal(that1.ScaleToZero) {
		return false
	}
	return true
}
func (this *StatefulServiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatefulServiceType)
	if !ok {
		that2, ok := that.(StatefulServiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ScalingChoice == nil {
		if this.ScalingChoice != nil {
			return false
		}
	} else if this.ScalingChoice == nil {
		return false
	} else if !this.ScalingChoice.Equal(that1.ScalingChoice) {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(that1.Containers[i]) {
			return false
		}
	}
	if len(this.PersistentVolumes) != len(that1.PersistentVolumes) {
		return false
	}
	for i := range this.PersistentVolumes {
		if !this.PersistentVolumes[i].Equal(that1.PersistentVolumes[i]) {
			return false
		}
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(that1.Volumes[i]) {
			return false
		}
	}
	if !this.Configuration.Equal(that1.Configuration) {
		return false
	}
	if !this.DeployOptions.Equal(that1.DeployOptions) {
		return false
	}
	if !this.AdvertiseOptions.Equal(that1.AdvertiseOptions) {
		return false
	}
	return true
}
func (this *StatefulServiceType_NumReplicas) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatefulServiceType_NumReplicas)
	if !ok {
		that2, ok := that.(StatefulServiceType_NumReplicas)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumReplicas != that1.NumReplicas {
		return false
	}
	return true
}
func (this *StatefulServiceType_ScaleToZero) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatefulServiceType_ScaleToZero)
	if !ok {
		that2, ok := that.(StatefulServiceType_ScaleToZero)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ScaleToZero.Equal(that1.ScaleToZero) {
		return false
	}
	return true
}
func (this *JobType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JobType)
	if !ok {
		that2, ok := that.(JobType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumReplicas != that1.NumReplicas {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(that1.Containers[i]) {
			return false
		}
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(that1.Volumes[i]) {
			return false
		}
	}
	if !this.Configuration.Equal(that1.Configuration) {
		return false
	}
	if !this.DeployOptions.Equal(that1.DeployOptions) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.WorkloadChoice == nil {
		if this.WorkloadChoice != nil {
			return false
		}
	} else if this.WorkloadChoice == nil {
		return false
	} else if !this.WorkloadChoice.Equal(that1.WorkloadChoice) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	if !this.VirtualK8S.Equal(that1.VirtualK8S) {
		return false
	}
	return true
}
func (this *GlobalSpecType_SimpleService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_SimpleService)
	if !ok {
		that2, ok := that.(GlobalSpecType_SimpleService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SimpleService.Equal(that1.SimpleService) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Service) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Service)
	if !ok {
		that2, ok := that.(GlobalSpecType_Service)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Service.Equal(that1.Service) {
		return false
	}
	return true
}
func (this *GlobalSpecType_StatefulService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_StatefulService)
	if !ok {
		that2, ok := that.(GlobalSpecType_StatefulService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StatefulService.Equal(that1.StatefulService) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Job) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Job)
	if !ok {
		that2, ok := that.(GlobalSpecType_Job)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Job.Equal(that1.Job) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.WorkloadChoice == nil {
		if this.WorkloadChoice != nil {
			return false
		}
	} else if this.WorkloadChoice == nil {
		return false
	} else if !this.WorkloadChoice.Equal(that1.WorkloadChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_SimpleService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_SimpleService)
	if !ok {
		that2, ok := that.(CreateSpecType_SimpleService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SimpleService.Equal(that1.SimpleService) {
		return false
	}
	return true
}
func (this *CreateSpecType_Service) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Service)
	if !ok {
		that2, ok := that.(CreateSpecType_Service)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Service.Equal(that1.Service) {
		return false
	}
	return true
}
func (this *CreateSpecType_StatefulService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_StatefulService)
	if !ok {
		that2, ok := that.(CreateSpecType_StatefulService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StatefulService.Equal(that1.StatefulService) {
		return false
	}
	return true
}
func (this *CreateSpecType_Job) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Job)
	if !ok {
		that2, ok := that.(CreateSpecType_Job)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Job.Equal(that1.Job) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.WorkloadChoice == nil {
		if this.WorkloadChoice != nil {
			return false
		}
	} else if this.WorkloadChoice == nil {
		return false
	} else if !this.WorkloadChoice.Equal(that1.WorkloadChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_SimpleService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_SimpleService)
	if !ok {
		that2, ok := that.(ReplaceSpecType_SimpleService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SimpleService.Equal(that1.SimpleService) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Service) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Service)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Service)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Service.Equal(that1.Service) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_StatefulService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_StatefulService)
	if !ok {
		that2, ok := that.(ReplaceSpecType_StatefulService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StatefulService.Equal(that1.StatefulService) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Job) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Job)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Job)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Job.Equal(that1.Job) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.WorkloadChoice == nil {
		if this.WorkloadChoice != nil {
			return false
		}
	} else if this.WorkloadChoice == nil {
		return false
	} else if !this.WorkloadChoice.Equal(that1.WorkloadChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_SimpleService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_SimpleService)
	if !ok {
		that2, ok := that.(GetSpecType_SimpleService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SimpleService.Equal(that1.SimpleService) {
		return false
	}
	return true
}
func (this *GetSpecType_Service) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Service)
	if !ok {
		that2, ok := that.(GetSpecType_Service)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Service.Equal(that1.Service) {
		return false
	}
	return true
}
func (this *GetSpecType_StatefulService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_StatefulService)
	if !ok {
		that2, ok := that.(GetSpecType_StatefulService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StatefulService.Equal(that1.StatefulService) {
		return false
	}
	return true
}
func (this *GetSpecType_Job) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Job)
	if !ok {
		that2, ok := that.(GetSpecType_Job)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Job.Equal(that1.Job) {
		return false
	}
	return true
}
func (this *VolumeMountType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&workload.VolumeMountType{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "MountPath: "+fmt.Sprintf("%#v", this.MountPath)+",\n")
	s = append(s, "SubPath: "+fmt.Sprintf("%#v", this.SubPath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConfigurationFileType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.ConfigurationFileType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "VolumeName: "+fmt.Sprintf("%#v", this.VolumeName)+",\n")
	if this.Mount != nil {
		s = append(s, "Mount: "+fmt.Sprintf("%#v", this.Mount)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EnvironmentVariableType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.EnvironmentVariableType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConfigurationParameterType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.ConfigurationParameterType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConfigurationParameterType_File) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ConfigurationParameterType_File{` +
		`File:` + fmt.Sprintf("%#v", this.File) + `}`}, ", ")
	return s
}
func (this *ConfigurationParameterType_EnvVar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ConfigurationParameterType_EnvVar{` +
		`EnvVar:` + fmt.Sprintf("%#v", this.EnvVar) + `}`}, ", ")
	return s
}
func (this *ConfigurationParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.ConfigurationParametersType{")
	if this.Parameters != nil {
		s = append(s, "Parameters: "+fmt.Sprintf("%#v", this.Parameters)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PersistentStorageType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.PersistentStorageType{")
	s = append(s, "AccessMode: "+fmt.Sprintf("%#v", this.AccessMode)+",\n")
	s = append(s, "StorageSize: "+fmt.Sprintf("%#v", this.StorageSize)+",\n")
	if this.ClassNameChoice != nil {
		s = append(s, "ClassNameChoice: "+fmt.Sprintf("%#v", this.ClassNameChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PersistentStorageType_Default) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.PersistentStorageType_Default{` +
		`Default:` + fmt.Sprintf("%#v", this.Default) + `}`}, ", ")
	return s
}
func (this *PersistentStorageType_ClassName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.PersistentStorageType_ClassName{` +
		`ClassName:` + fmt.Sprintf("%#v", this.ClassName) + `}`}, ", ")
	return s
}
func (this *PersistentStorageVolumeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.PersistentStorageVolumeType{")
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	if this.Mount != nil {
		s = append(s, "Mount: "+fmt.Sprintf("%#v", this.Mount)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EmptyDirectoryVolumeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.EmptyDirectoryVolumeType{")
	s = append(s, "SizeLimit: "+fmt.Sprintf("%#v", this.SizeLimit)+",\n")
	if this.Mount != nil {
		s = append(s, "Mount: "+fmt.Sprintf("%#v", this.Mount)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostPathVolumeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.HostPathVolumeType{")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	if this.Mount != nil {
		s = append(s, "Mount: "+fmt.Sprintf("%#v", this.Mount)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageVolumeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.StorageVolumeType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.VolumeChoice != nil {
		s = append(s, "VolumeChoice: "+fmt.Sprintf("%#v", this.VolumeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageVolumeType_PersistentVolume) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.StorageVolumeType_PersistentVolume{` +
		`PersistentVolume:` + fmt.Sprintf("%#v", this.PersistentVolume) + `}`}, ", ")
	return s
}
func (this *StorageVolumeType_EmptyDir) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.StorageVolumeType_EmptyDir{` +
		`EmptyDir:` + fmt.Sprintf("%#v", this.EmptyDir) + `}`}, ", ")
	return s
}
func (this *StorageVolumeType_HostPath) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.StorageVolumeType_HostPath{` +
		`HostPath:` + fmt.Sprintf("%#v", this.HostPath) + `}`}, ", ")
	return s
}
func (this *EphemeralStorageVolumeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&workload.EphemeralStorageVolumeType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.VolumeChoice != nil {
		s = append(s, "VolumeChoice: "+fmt.Sprintf("%#v", this.VolumeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EphemeralStorageVolumeType_EmptyDir) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.EphemeralStorageVolumeType_EmptyDir{` +
		`EmptyDir:` + fmt.Sprintf("%#v", this.EmptyDir) + `}`}, ", ")
	return s
}
func (this *EphemeralStorageVolumeType_HostPath) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.EphemeralStorageVolumeType_HostPath{` +
		`HostPath:` + fmt.Sprintf("%#v", this.HostPath) + `}`}, ", ")
	return s
}
func (this *PersistentVolumeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.PersistentVolumeType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.PersistentVolume != nil {
		s = append(s, "PersistentVolume: "+fmt.Sprintf("%#v", this.PersistentVolume)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.ImageType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.RegistryChoice != nil {
		s = append(s, "RegistryChoice: "+fmt.Sprintf("%#v", this.RegistryChoice)+",\n")
	}
	s = append(s, "PullPolicy: "+fmt.Sprintf("%#v", this.PullPolicy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageType_Public) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ImageType_Public{` +
		`Public:` + fmt.Sprintf("%#v", this.Public) + `}`}, ", ")
	return s
}
func (this *ImageType_ContainerRegistry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ImageType_ContainerRegistry{` +
		`ContainerRegistry:` + fmt.Sprintf("%#v", this.ContainerRegistry) + `}`}, ", ")
	return s
}
func (this *PortChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.PortChoiceType{")
	if this.PortChoice != nil {
		s = append(s, "PortChoice: "+fmt.Sprintf("%#v", this.PortChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortChoiceType_Num) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.PortChoiceType_Num{` +
		`Num:` + fmt.Sprintf("%#v", this.Num) + `}`}, ", ")
	return s
}
func (this *PortChoiceType_Name) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.PortChoiceType_Name{` +
		`Name:` + fmt.Sprintf("%#v", this.Name) + `}`}, ", ")
	return s
}
func (this *HTTPHealthCheckType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.HTTPHealthCheckType{")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	if this.Port != nil {
		s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	}
	s = append(s, "HostHeader: "+fmt.Sprintf("%#v", this.HostHeader)+",\n")
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]string{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%#v: %#v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	if this.Headers != nil {
		s = append(s, "Headers: "+mapStringForHeaders+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecHealthCheckType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.ExecHealthCheckType{")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TCPHealthCheckType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.TCPHealthCheckType{")
	if this.Port != nil {
		s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HealthCheckType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&workload.HealthCheckType{")
	if this.HealthCheckChoice != nil {
		s = append(s, "HealthCheckChoice: "+fmt.Sprintf("%#v", this.HealthCheckChoice)+",\n")
	}
	s = append(s, "InitialDelay: "+fmt.Sprintf("%#v", this.InitialDelay)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "Interval: "+fmt.Sprintf("%#v", this.Interval)+",\n")
	s = append(s, "HealthyThreshold: "+fmt.Sprintf("%#v", this.HealthyThreshold)+",\n")
	s = append(s, "UnhealthyThreshold: "+fmt.Sprintf("%#v", this.UnhealthyThreshold)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HealthCheckType_HttpHealthCheck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.HealthCheckType_HttpHealthCheck{` +
		`HttpHealthCheck:` + fmt.Sprintf("%#v", this.HttpHealthCheck) + `}`}, ", ")
	return s
}
func (this *HealthCheckType_TcpHealthCheck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.HealthCheckType_TcpHealthCheck{` +
		`TcpHealthCheck:` + fmt.Sprintf("%#v", this.TcpHealthCheck) + `}`}, ", ")
	return s
}
func (this *HealthCheckType_ExecHealthCheck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.HealthCheckType_ExecHealthCheck{` +
		`ExecHealthCheck:` + fmt.Sprintf("%#v", this.ExecHealthCheck) + `}`}, ", ")
	return s
}
func (this *ContainerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&workload.ContainerType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Image != nil {
		s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	}
	s = append(s, "InitContainer: "+fmt.Sprintf("%#v", this.InitContainer)+",\n")
	s = append(s, "Flavor: "+fmt.Sprintf("%#v", this.Flavor)+",\n")
	if this.LivenessCheck != nil {
		s = append(s, "LivenessCheck: "+fmt.Sprintf("%#v", this.LivenessCheck)+",\n")
	}
	if this.ReadinessCheck != nil {
		s = append(s, "ReadinessCheck: "+fmt.Sprintf("%#v", this.ReadinessCheck)+",\n")
	}
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeployCESiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.DeployCESiteType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeployRESiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.DeployRESiteType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeployREVirtualSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.DeployREVirtualSiteType{")
	if this.VirtualSite != nil {
		s = append(s, "VirtualSite: "+fmt.Sprintf("%#v", this.VirtualSite)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeployCEVirtualSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.DeployCEVirtualSiteType{")
	if this.VirtualSite != nil {
		s = append(s, "VirtualSite: "+fmt.Sprintf("%#v", this.VirtualSite)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeployOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&workload.DeployOptionsType{")
	if this.DeployChoice != nil {
		s = append(s, "DeployChoice: "+fmt.Sprintf("%#v", this.DeployChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeployOptionsType_AllRes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.DeployOptionsType_AllRes{` +
		`AllRes:` + fmt.Sprintf("%#v", this.AllRes) + `}`}, ", ")
	return s
}
func (this *DeployOptionsType_DeployReVirtualSites) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.DeployOptionsType_DeployReVirtualSites{` +
		`DeployReVirtualSites:` + fmt.Sprintf("%#v", this.DeployReVirtualSites) + `}`}, ", ")
	return s
}
func (this *DeployOptionsType_DeployCeVirtualSites) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.DeployOptionsType_DeployCeVirtualSites{` +
		`DeployCeVirtualSites:` + fmt.Sprintf("%#v", this.DeployCeVirtualSites) + `}`}, ", ")
	return s
}
func (this *DeployOptionsType_DeployCeSites) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.DeployOptionsType_DeployCeSites{` +
		`DeployCeSites:` + fmt.Sprintf("%#v", this.DeployCeSites) + `}`}, ", ")
	return s
}
func (this *DeployOptionsType_DefaultVirtualSites) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.DeployOptionsType_DefaultVirtualSites{` +
		`DefaultVirtualSites:` + fmt.Sprintf("%#v", this.DefaultVirtualSites) + `}`}, ", ")
	return s
}
func (this *DeployOptionsType_DeployReSites) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.DeployOptionsType_DeployReSites{` +
		`DeployReSites:` + fmt.Sprintf("%#v", this.DeployReSites) + `}`}, ", ")
	return s
}
func (this *RouteInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.RouteInfoType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteInfoType_SimpleRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.RouteInfoType_SimpleRoute{` +
		`SimpleRoute:` + fmt.Sprintf("%#v", this.SimpleRoute) + `}`}, ", ")
	return s
}
func (this *RouteInfoType_RedirectRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.RouteInfoType_RedirectRoute{` +
		`RedirectRoute:` + fmt.Sprintf("%#v", this.RedirectRoute) + `}`}, ", ")
	return s
}
func (this *RouteInfoType_DirectResponseRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.RouteInfoType_DirectResponseRoute{` +
		`DirectResponseRoute:` + fmt.Sprintf("%#v", this.DirectResponseRoute) + `}`}, ", ")
	return s
}
func (this *RouteInfoType_CustomRouteObject) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.RouteInfoType_CustomRouteObject{` +
		`CustomRouteObject:` + fmt.Sprintf("%#v", this.CustomRouteObject) + `}`}, ", ")
	return s
}
func (this *RouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.RouteType{")
	if this.Routes != nil {
		s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatchAllRouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&workload.MatchAllRouteType{")
	if this.HostRewriteParams != nil {
		s = append(s, "HostRewriteParams: "+fmt.Sprintf("%#v", this.HostRewriteParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatchAllRouteType_AutoHostRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.MatchAllRouteType_AutoHostRewrite{` +
		`AutoHostRewrite:` + fmt.Sprintf("%#v", this.AutoHostRewrite) + `}`}, ", ")
	return s
}
func (this *MatchAllRouteType_HostRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.MatchAllRouteType_HostRewrite{` +
		`HostRewrite:` + fmt.Sprintf("%#v", this.HostRewrite) + `}`}, ", ")
	return s
}
func (this *MatchAllRouteType_DisableHostRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.MatchAllRouteType_DisableHostRewrite{` +
		`DisableHostRewrite:` + fmt.Sprintf("%#v", this.DisableHostRewrite) + `}`}, ", ")
	return s
}
func (this *HTTPLoadBalancerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&workload.HTTPLoadBalancerType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.LoadbalancerType != nil {
		s = append(s, "LoadbalancerType: "+fmt.Sprintf("%#v", this.LoadbalancerType)+",\n")
	}
	if this.RouteChoice != nil {
		s = append(s, "RouteChoice: "+fmt.Sprintf("%#v", this.RouteChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HTTPLoadBalancerType_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.HTTPLoadBalancerType_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *HTTPLoadBalancerType_HttpsAutoCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.HTTPLoadBalancerType_HttpsAutoCert{` +
		`HttpsAutoCert:` + fmt.Sprintf("%#v", this.HttpsAutoCert) + `}`}, ", ")
	return s
}
func (this *HTTPLoadBalancerType_Https) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.HTTPLoadBalancerType_Https{` +
		`Https:` + fmt.Sprintf("%#v", this.Https) + `}`}, ", ")
	return s
}
func (this *HTTPLoadBalancerType_DefaultRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.HTTPLoadBalancerType_DefaultRoute{` +
		`DefaultRoute:` + fmt.Sprintf("%#v", this.DefaultRoute) + `}`}, ", ")
	return s
}
func (this *HTTPLoadBalancerType_SpecificRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.HTTPLoadBalancerType_SpecificRoutes{` +
		`SpecificRoutes:` + fmt.Sprintf("%#v", this.SpecificRoutes) + `}`}, ", ")
	return s
}
func (this *TCPLoadBalancerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.TCPLoadBalancerType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	s = append(s, "WithSni: "+fmt.Sprintf("%#v", this.WithSni)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.PortInfoType{")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.TargetPortChoice != nil {
		s = append(s, "TargetPortChoice: "+fmt.Sprintf("%#v", this.TargetPortChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortInfoType_SameAsPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.PortInfoType_SameAsPort{` +
		`SameAsPort:` + fmt.Sprintf("%#v", this.SameAsPort) + `}`}, ", ")
	return s
}
func (this *PortInfoType_TargetPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.PortInfoType_TargetPort{` +
		`TargetPort:` + fmt.Sprintf("%#v", this.TargetPort) + `}`}, ", ")
	return s
}
func (this *PortType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.PortType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MultiPortType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.MultiPortType{")
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SinglePortType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.SinglePortType{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdvertiseInClusterType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.AdvertiseInClusterType{")
	if this.PortChoice != nil {
		s = append(s, "PortChoice: "+fmt.Sprintf("%#v", this.PortChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdvertiseInClusterType_Port) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseInClusterType_Port{` +
		`Port:` + fmt.Sprintf("%#v", this.Port) + `}`}, ", ")
	return s
}
func (this *AdvertiseInClusterType_MultiPorts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseInClusterType_MultiPorts{` +
		`MultiPorts:` + fmt.Sprintf("%#v", this.MultiPorts) + `}`}, ", ")
	return s
}
func (this *AdvertiseSinglePortType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&workload.AdvertiseSinglePortType{")
	if this.Port != nil {
		s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	}
	if this.AdvertiseChoice != nil {
		s = append(s, "AdvertiseChoice: "+fmt.Sprintf("%#v", this.AdvertiseChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdvertiseSinglePortType_HttpLoadbalancer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseSinglePortType_HttpLoadbalancer{` +
		`HttpLoadbalancer:` + fmt.Sprintf("%#v", this.HttpLoadbalancer) + `}`}, ", ")
	return s
}
func (this *AdvertiseSinglePortType_TcpLoadbalancer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseSinglePortType_TcpLoadbalancer{` +
		`TcpLoadbalancer:` + fmt.Sprintf("%#v", this.TcpLoadbalancer) + `}`}, ", ")
	return s
}
func (this *AdvertisePortType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&workload.AdvertisePortType{")
	if this.Port != nil {
		s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	}
	if this.AdvertiseChoice != nil {
		s = append(s, "AdvertiseChoice: "+fmt.Sprintf("%#v", this.AdvertiseChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdvertisePortType_HttpLoadbalancer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertisePortType_HttpLoadbalancer{` +
		`HttpLoadbalancer:` + fmt.Sprintf("%#v", this.HttpLoadbalancer) + `}`}, ", ")
	return s
}
func (this *AdvertisePortType_TcpLoadbalancer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertisePortType_TcpLoadbalancer{` +
		`TcpLoadbalancer:` + fmt.Sprintf("%#v", this.TcpLoadbalancer) + `}`}, ", ")
	return s
}
func (this *AdvertiseMultiPortType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&workload.AdvertiseMultiPortType{")
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdvertisePublicType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.AdvertisePublicType{")
	if this.AdvertiseChoice != nil {
		s = append(s, "AdvertiseChoice: "+fmt.Sprintf("%#v", this.AdvertiseChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdvertisePublicType_Port) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertisePublicType_Port{` +
		`Port:` + fmt.Sprintf("%#v", this.Port) + `}`}, ", ")
	return s
}
func (this *AdvertisePublicType_MultiPorts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertisePublicType_MultiPorts{` +
		`MultiPorts:` + fmt.Sprintf("%#v", this.MultiPorts) + `}`}, ", ")
	return s
}
func (this *AdvertiseWhereType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&workload.AdvertiseWhereType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdvertiseWhereType_Site) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseWhereType_Site{` +
		`Site:` + fmt.Sprintf("%#v", this.Site) + `}`}, ", ")
	return s
}
func (this *AdvertiseWhereType_VirtualSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseWhereType_VirtualSite{` +
		`VirtualSite:` + fmt.Sprintf("%#v", this.VirtualSite) + `}`}, ", ")
	return s
}
func (this *AdvertiseWhereType_Vk8SService) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseWhereType_Vk8SService{` +
		`Vk8SService:` + fmt.Sprintf("%#v", this.Vk8SService) + `}`}, ", ")
	return s
}
func (this *AdvertiseCustomType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.AdvertiseCustomType{")
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	if this.AdvertiseWhere != nil {
		s = append(s, "AdvertiseWhere: "+fmt.Sprintf("%#v", this.AdvertiseWhere)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdvertiseOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.AdvertiseOptionsType{")
	if this.AdvertiseChoice != nil {
		s = append(s, "AdvertiseChoice: "+fmt.Sprintf("%#v", this.AdvertiseChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdvertiseOptionsType_AdvertiseInCluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseOptionsType_AdvertiseInCluster{` +
		`AdvertiseInCluster:` + fmt.Sprintf("%#v", this.AdvertiseInCluster) + `}`}, ", ")
	return s
}
func (this *AdvertiseOptionsType_AdvertiseOnPublic) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseOptionsType_AdvertiseOnPublic{` +
		`AdvertiseOnPublic:` + fmt.Sprintf("%#v", this.AdvertiseOnPublic) + `}`}, ", ")
	return s
}
func (this *AdvertiseOptionsType_AdvertiseCustom) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseOptionsType_AdvertiseCustom{` +
		`AdvertiseCustom:` + fmt.Sprintf("%#v", this.AdvertiseCustom) + `}`}, ", ")
	return s
}
func (this *AdvertiseOptionsType_DoNotAdvertise) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.AdvertiseOptionsType_DoNotAdvertise{` +
		`DoNotAdvertise:` + fmt.Sprintf("%#v", this.DoNotAdvertise) + `}`}, ", ")
	return s
}
func (this *AdvertiseSimpleServiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&workload.AdvertiseSimpleServiceType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	s = append(s, "ServicePort: "+fmt.Sprintf("%#v", this.ServicePort)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimpleServiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&workload.SimpleServiceType{")
	if this.Container != nil {
		s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	}
	if this.Configuration != nil {
		s = append(s, "Configuration: "+fmt.Sprintf("%#v", this.Configuration)+",\n")
	}
	if this.AdvertiseChoice != nil {
		s = append(s, "AdvertiseChoice: "+fmt.Sprintf("%#v", this.AdvertiseChoice)+",\n")
	}
	if this.PersistenceChoice != nil {
		s = append(s, "PersistenceChoice: "+fmt.Sprintf("%#v", this.PersistenceChoice)+",\n")
	}
	s = append(s, "ScaleToZero: "+fmt.Sprintf("%#v", this.ScaleToZero)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SimpleServiceType_DoNotAdvertise) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.SimpleServiceType_DoNotAdvertise{` +
		`DoNotAdvertise:` + fmt.Sprintf("%#v", this.DoNotAdvertise) + `}`}, ", ")
	return s
}
func (this *SimpleServiceType_ServicePort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.SimpleServiceType_ServicePort{` +
		`ServicePort:` + fmt.Sprintf("%#v", this.ServicePort) + `}`}, ", ")
	return s
}
func (this *SimpleServiceType_SimpleAdvertise) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.SimpleServiceType_SimpleAdvertise{` +
		`SimpleAdvertise:` + fmt.Sprintf("%#v", this.SimpleAdvertise) + `}`}, ", ")
	return s
}
func (this *SimpleServiceType_Disabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.SimpleServiceType_Disabled{` +
		`Disabled:` + fmt.Sprintf("%#v", this.Disabled) + `}`}, ", ")
	return s
}
func (this *SimpleServiceType_Enabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.SimpleServiceType_Enabled{` +
		`Enabled:` + fmt.Sprintf("%#v", this.Enabled) + `}`}, ", ")
	return s
}
func (this *ServiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&workload.ServiceType{")
	if this.ScalingChoice != nil {
		s = append(s, "ScalingChoice: "+fmt.Sprintf("%#v", this.ScalingChoice)+",\n")
	}
	if this.Containers != nil {
		s = append(s, "Containers: "+fmt.Sprintf("%#v", this.Containers)+",\n")
	}
	if this.Volumes != nil {
		s = append(s, "Volumes: "+fmt.Sprintf("%#v", this.Volumes)+",\n")
	}
	if this.Configuration != nil {
		s = append(s, "Configuration: "+fmt.Sprintf("%#v", this.Configuration)+",\n")
	}
	if this.DeployOptions != nil {
		s = append(s, "DeployOptions: "+fmt.Sprintf("%#v", this.DeployOptions)+",\n")
	}
	if this.AdvertiseOptions != nil {
		s = append(s, "AdvertiseOptions: "+fmt.Sprintf("%#v", this.AdvertiseOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceType_NumReplicas) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ServiceType_NumReplicas{` +
		`NumReplicas:` + fmt.Sprintf("%#v", this.NumReplicas) + `}`}, ", ")
	return s
}
func (this *ServiceType_ScaleToZero) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ServiceType_ScaleToZero{` +
		`ScaleToZero:` + fmt.Sprintf("%#v", this.ScaleToZero) + `}`}, ", ")
	return s
}
func (this *StatefulServiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&workload.StatefulServiceType{")
	if this.ScalingChoice != nil {
		s = append(s, "ScalingChoice: "+fmt.Sprintf("%#v", this.ScalingChoice)+",\n")
	}
	if this.Containers != nil {
		s = append(s, "Containers: "+fmt.Sprintf("%#v", this.Containers)+",\n")
	}
	if this.PersistentVolumes != nil {
		s = append(s, "PersistentVolumes: "+fmt.Sprintf("%#v", this.PersistentVolumes)+",\n")
	}
	if this.Volumes != nil {
		s = append(s, "Volumes: "+fmt.Sprintf("%#v", this.Volumes)+",\n")
	}
	if this.Configuration != nil {
		s = append(s, "Configuration: "+fmt.Sprintf("%#v", this.Configuration)+",\n")
	}
	if this.DeployOptions != nil {
		s = append(s, "DeployOptions: "+fmt.Sprintf("%#v", this.DeployOptions)+",\n")
	}
	if this.AdvertiseOptions != nil {
		s = append(s, "AdvertiseOptions: "+fmt.Sprintf("%#v", this.AdvertiseOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatefulServiceType_NumReplicas) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.StatefulServiceType_NumReplicas{` +
		`NumReplicas:` + fmt.Sprintf("%#v", this.NumReplicas) + `}`}, ", ")
	return s
}
func (this *StatefulServiceType_ScaleToZero) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.StatefulServiceType_ScaleToZero{` +
		`ScaleToZero:` + fmt.Sprintf("%#v", this.ScaleToZero) + `}`}, ", ")
	return s
}
func (this *JobType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&workload.JobType{")
	s = append(s, "NumReplicas: "+fmt.Sprintf("%#v", this.NumReplicas)+",\n")
	if this.Containers != nil {
		s = append(s, "Containers: "+fmt.Sprintf("%#v", this.Containers)+",\n")
	}
	if this.Volumes != nil {
		s = append(s, "Volumes: "+fmt.Sprintf("%#v", this.Volumes)+",\n")
	}
	if this.Configuration != nil {
		s = append(s, "Configuration: "+fmt.Sprintf("%#v", this.Configuration)+",\n")
	}
	if this.DeployOptions != nil {
		s = append(s, "DeployOptions: "+fmt.Sprintf("%#v", this.DeployOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&workload.GlobalSpecType{")
	if this.WorkloadChoice != nil {
		s = append(s, "WorkloadChoice: "+fmt.Sprintf("%#v", this.WorkloadChoice)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	if this.VirtualK8S != nil {
		s = append(s, "VirtualK8S: "+fmt.Sprintf("%#v", this.VirtualK8S)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_SimpleService) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.GlobalSpecType_SimpleService{` +
		`SimpleService:` + fmt.Sprintf("%#v", this.SimpleService) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Service) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.GlobalSpecType_Service{` +
		`Service:` + fmt.Sprintf("%#v", this.Service) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_StatefulService) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.GlobalSpecType_StatefulService{` +
		`StatefulService:` + fmt.Sprintf("%#v", this.StatefulService) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Job) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.GlobalSpecType_Job{` +
		`Job:` + fmt.Sprintf("%#v", this.Job) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.CreateSpecType{")
	if this.WorkloadChoice != nil {
		s = append(s, "WorkloadChoice: "+fmt.Sprintf("%#v", this.WorkloadChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_SimpleService) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.CreateSpecType_SimpleService{` +
		`SimpleService:` + fmt.Sprintf("%#v", this.SimpleService) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Service) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.CreateSpecType_Service{` +
		`Service:` + fmt.Sprintf("%#v", this.Service) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_StatefulService) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.CreateSpecType_StatefulService{` +
		`StatefulService:` + fmt.Sprintf("%#v", this.StatefulService) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Job) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.CreateSpecType_Job{` +
		`Job:` + fmt.Sprintf("%#v", this.Job) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.ReplaceSpecType{")
	if this.WorkloadChoice != nil {
		s = append(s, "WorkloadChoice: "+fmt.Sprintf("%#v", this.WorkloadChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_SimpleService) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ReplaceSpecType_SimpleService{` +
		`SimpleService:` + fmt.Sprintf("%#v", this.SimpleService) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Service) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ReplaceSpecType_Service{` +
		`Service:` + fmt.Sprintf("%#v", this.Service) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_StatefulService) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ReplaceSpecType_StatefulService{` +
		`StatefulService:` + fmt.Sprintf("%#v", this.StatefulService) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Job) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.ReplaceSpecType_Job{` +
		`Job:` + fmt.Sprintf("%#v", this.Job) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&workload.GetSpecType{")
	if this.WorkloadChoice != nil {
		s = append(s, "WorkloadChoice: "+fmt.Sprintf("%#v", this.WorkloadChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_SimpleService) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.GetSpecType_SimpleService{` +
		`SimpleService:` + fmt.Sprintf("%#v", this.SimpleService) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Service) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.GetSpecType_Service{` +
		`Service:` + fmt.Sprintf("%#v", this.Service) + `}`}, ", ")
	return s
}
func (this *GetSpecType_StatefulService) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.GetSpecType_StatefulService{` +
		`StatefulService:` + fmt.Sprintf("%#v", this.StatefulService) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Job) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&workload.GetSpecType_Job{` +
		`Job:` + fmt.Sprintf("%#v", this.Job) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *VolumeMountType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeMountType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolumeMountType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubPath) > 0 {
		i -= len(m.SubPath)
		copy(dAtA[i:], m.SubPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubPath)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MountPath) > 0 {
		i -= len(m.MountPath)
		copy(dAtA[i:], m.MountPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MountPath)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConfigurationFileType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigurationFileType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigurationFileType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mount != nil {
		{
			size, err := m.Mount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VolumeName) > 0 {
		i -= len(m.VolumeName)
		copy(dAtA[i:], m.VolumeName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolumeName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnvironmentVariableType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvironmentVariableType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnvironmentVariableType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigurationParameterType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigurationParameterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigurationParameterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConfigurationParameterType_File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigurationParameterType_File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ConfigurationParameterType_EnvVar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigurationParameterType_EnvVar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnvVar != nil {
		{
			size, err := m.EnvVar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ConfigurationParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigurationParametersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigurationParametersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PersistentStorageType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PersistentStorageType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PersistentStorageType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClassNameChoice != nil {
		{
			size := m.ClassNameChoice.Size()
			i -= size
			if _, err := m.ClassNameChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StorageSize != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.StorageSize))))
		i--
		dAtA[i] = 0x11
	}
	if m.AccessMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AccessMode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PersistentStorageType_Default) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PersistentStorageType_Default) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PersistentStorageType_ClassName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PersistentStorageType_ClassName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ClassName)
	copy(dAtA[i:], m.ClassName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ClassName)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *PersistentStorageVolumeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PersistentStorageVolumeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PersistentStorageVolumeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mount != nil {
		{
			size, err := m.Mount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Storage != nil {
		{
			size, err := m.Storage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EmptyDirectoryVolumeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyDirectoryVolumeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyDirectoryVolumeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mount != nil {
		{
			size, err := m.Mount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SizeLimit != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SizeLimit))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *HostPathVolumeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostPathVolumeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostPathVolumeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mount != nil {
		{
			size, err := m.Mount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageVolumeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageVolumeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageVolumeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VolumeChoice != nil {
		{
			size := m.VolumeChoice.Size()
			i -= size
			if _, err := m.VolumeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageVolumeType_PersistentVolume) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageVolumeType_PersistentVolume) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PersistentVolume != nil {
		{
			size, err := m.PersistentVolume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StorageVolumeType_EmptyDir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageVolumeType_EmptyDir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EmptyDir != nil {
		{
			size, err := m.EmptyDir.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StorageVolumeType_HostPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageVolumeType_HostPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HostPath != nil {
		{
			size, err := m.HostPath.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *EphemeralStorageVolumeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EphemeralStorageVolumeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EphemeralStorageVolumeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VolumeChoice != nil {
		{
			size := m.VolumeChoice.Size()
			i -= size
			if _, err := m.VolumeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EphemeralStorageVolumeType_EmptyDir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EphemeralStorageVolumeType_EmptyDir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EmptyDir != nil {
		{
			size, err := m.EmptyDir.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *EphemeralStorageVolumeType_HostPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EphemeralStorageVolumeType_HostPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HostPath != nil {
		{
			size, err := m.HostPath.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PersistentVolumeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PersistentVolumeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PersistentVolumeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PersistentVolume != nil {
		{
			size, err := m.PersistentVolume.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImageType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PullPolicy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PullPolicy))
		i--
		dAtA[i] = 0x30
	}
	if m.RegistryChoice != nil {
		{
			size := m.RegistryChoice.Size()
			i -= size
			if _, err := m.RegistryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImageType_Public) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageType_Public) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Public != nil {
		{
			size, err := m.Public.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ImageType_ContainerRegistry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageType_ContainerRegistry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ContainerRegistry != nil {
		{
			size, err := m.ContainerRegistry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PortChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortChoice != nil {
		{
			size := m.PortChoice.Size()
			i -= size
			if _, err := m.PortChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PortChoiceType_Num) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortChoiceType_Num) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Num))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *PortChoiceType_Name) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortChoiceType_Name) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *HTTPHealthCheckType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPHealthCheckType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPHealthCheckType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		keysForHeaders := make([]string, 0, len(m.Headers))
		for k := range m.Headers {
			keysForHeaders = append(keysForHeaders, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
		for iNdEx := len(keysForHeaders) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Headers[string(keysForHeaders[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForHeaders[iNdEx])
			copy(dAtA[i:], keysForHeaders[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForHeaders[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.HostHeader) > 0 {
		i -= len(m.HostHeader)
		copy(dAtA[i:], m.HostHeader)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostHeader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Port != nil {
		{
			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecHealthCheckType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecHealthCheckType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecHealthCheckType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TCPHealthCheckType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPHealthCheckType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCPHealthCheckType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != nil {
		{
			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HealthCheckType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnhealthyThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UnhealthyThreshold))
		i--
		dAtA[i] = 0x48
	}
	if m.HealthyThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthyThreshold))
		i--
		dAtA[i] = 0x40
	}
	if m.Interval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x38
	}
	if m.Timeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x30
	}
	if m.InitialDelay != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.InitialDelay))
		i--
		dAtA[i] = 0x28
	}
	if m.HealthCheckChoice != nil {
		{
			size := m.HealthCheckChoice.Size()
			i -= size
			if _, err := m.HealthCheckChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *HealthCheckType_HttpHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckType_HttpHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpHealthCheck != nil {
		{
			size, err := m.HttpHealthCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *HealthCheckType_TcpHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckType_TcpHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TcpHealthCheck != nil {
		{
			size, err := m.TcpHealthCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HealthCheckType_ExecHealthCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckType_ExecHealthCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExecHealthCheck != nil {
		{
			size, err := m.ExecHealthCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ContainerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ReadinessCheck != nil {
		{
			size, err := m.ReadinessCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LivenessCheck != nil {
		{
			size, err := m.LivenessCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Flavor != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Flavor))
		i--
		dAtA[i] = 0x20
	}
	if m.InitContainer {
		i--
		if m.InitContainer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeployCESiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployCESiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployCESiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Site) > 0 {
		for iNdEx := len(m.Site) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Site[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeployRESiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployRESiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployRESiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Site) > 0 {
		for iNdEx := len(m.Site) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Site[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeployREVirtualSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployREVirtualSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployREVirtualSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VirtualSite) > 0 {
		for iNdEx := len(m.VirtualSite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualSite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeployCEVirtualSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployCEVirtualSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployCEVirtualSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VirtualSite) > 0 {
		for iNdEx := len(m.VirtualSite) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualSite[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeployOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeployChoice != nil {
		{
			size := m.DeployChoice.Size()
			i -= size
			if _, err := m.DeployChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeployOptionsType_AllRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployOptionsType_AllRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllRes != nil {
		{
			size, err := m.AllRes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DeployOptionsType_DeployReVirtualSites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployOptionsType_DeployReVirtualSites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeployReVirtualSites != nil {
		{
			size, err := m.DeployReVirtualSites.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DeployOptionsType_DeployCeVirtualSites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployOptionsType_DeployCeVirtualSites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeployCeVirtualSites != nil {
		{
			size, err := m.DeployCeVirtualSites.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DeployOptionsType_DeployCeSites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployOptionsType_DeployCeSites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeployCeSites != nil {
		{
			size, err := m.DeployCeSites.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DeployOptionsType_DefaultVirtualSites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployOptionsType_DefaultVirtualSites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultVirtualSites != nil {
		{
			size, err := m.DefaultVirtualSites.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DeployOptionsType_DeployReSites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployOptionsType_DeployReSites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeployReSites != nil {
		{
			size, err := m.DeployReSites.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *RouteInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteInfoType_SimpleRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteInfoType_SimpleRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SimpleRoute != nil {
		{
			size, err := m.SimpleRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RouteInfoType_RedirectRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteInfoType_RedirectRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RedirectRoute != nil {
		{
			size, err := m.RedirectRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RouteInfoType_DirectResponseRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteInfoType_DirectResponseRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DirectResponseRoute != nil {
		{
			size, err := m.DirectResponseRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RouteInfoType_CustomRouteObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteInfoType_CustomRouteObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomRouteObject != nil {
		{
			size, err := m.CustomRouteObject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchAllRouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchAllRouteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchAllRouteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HostRewriteParams != nil {
		{
			size := m.HostRewriteParams.Size()
			i -= size
			if _, err := m.HostRewriteParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MatchAllRouteType_AutoHostRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchAllRouteType_AutoHostRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutoHostRewrite != nil {
		{
			size, err := m.AutoHostRewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MatchAllRouteType_HostRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchAllRouteType_HostRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.HostRewrite)
	copy(dAtA[i:], m.HostRewrite)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.HostRewrite)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *MatchAllRouteType_DisableHostRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchAllRouteType_DisableHostRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableHostRewrite != nil {
		{
			size, err := m.DisableHostRewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *HTTPLoadBalancerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPLoadBalancerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPLoadBalancerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RouteChoice != nil {
		{
			size := m.RouteChoice.Size()
			i -= size
			if _, err := m.RouteChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LoadbalancerType != nil {
		{
			size := m.LoadbalancerType.Size()
			i -= size
			if _, err := m.LoadbalancerType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HTTPLoadBalancerType_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPLoadBalancerType_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HTTPLoadBalancerType_HttpsAutoCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPLoadBalancerType_HttpsAutoCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpsAutoCert != nil {
		{
			size, err := m.HttpsAutoCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *HTTPLoadBalancerType_Https) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPLoadBalancerType_Https) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Https != nil {
		{
			size, err := m.Https.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *HTTPLoadBalancerType_DefaultRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPLoadBalancerType_DefaultRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultRoute != nil {
		{
			size, err := m.DefaultRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *HTTPLoadBalancerType_SpecificRoutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPLoadBalancerType_SpecificRoutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SpecificRoutes != nil {
		{
			size, err := m.SpecificRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *TCPLoadBalancerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCPLoadBalancerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TCPLoadBalancerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithSni {
		i--
		if m.WithSni {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PortInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetPortChoice != nil {
		{
			size := m.TargetPortChoice.Size()
			i -= size
			if _, err := m.TargetPortChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Protocol != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x10
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PortInfoType_SameAsPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortInfoType_SameAsPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SameAsPort != nil {
		{
			size, err := m.SameAsPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PortInfoType_TargetPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortInfoType_TargetPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.TargetPort))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *PortType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiPortType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiPortType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiPortType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SinglePortType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SinglePortType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SinglePortType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdvertiseInClusterType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvertiseInClusterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseInClusterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortChoice != nil {
		{
			size := m.PortChoice.Size()
			i -= size
			if _, err := m.PortChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AdvertiseInClusterType_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseInClusterType_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Port != nil {
		{
			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseInClusterType_MultiPorts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseInClusterType_MultiPorts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultiPorts != nil {
		{
			size, err := m.MultiPorts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseSinglePortType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvertiseSinglePortType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseSinglePortType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvertiseChoice != nil {
		{
			size := m.AdvertiseChoice.Size()
			i -= size
			if _, err := m.AdvertiseChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Port != nil {
		{
			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdvertiseSinglePortType_HttpLoadbalancer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseSinglePortType_HttpLoadbalancer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpLoadbalancer != nil {
		{
			size, err := m.HttpLoadbalancer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseSinglePortType_TcpLoadbalancer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseSinglePortType_TcpLoadbalancer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TcpLoadbalancer != nil {
		{
			size, err := m.TcpLoadbalancer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AdvertisePortType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvertisePortType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertisePortType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvertiseChoice != nil {
		{
			size := m.AdvertiseChoice.Size()
			i -= size
			if _, err := m.AdvertiseChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Port != nil {
		{
			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdvertisePortType_HttpLoadbalancer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertisePortType_HttpLoadbalancer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpLoadbalancer != nil {
		{
			size, err := m.HttpLoadbalancer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AdvertisePortType_TcpLoadbalancer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertisePortType_TcpLoadbalancer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TcpLoadbalancer != nil {
		{
			size, err := m.TcpLoadbalancer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseMultiPortType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvertiseMultiPortType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseMultiPortType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AdvertisePublicType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvertisePublicType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertisePublicType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvertiseChoice != nil {
		{
			size := m.AdvertiseChoice.Size()
			i -= size
			if _, err := m.AdvertiseChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AdvertisePublicType_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertisePublicType_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Port != nil {
		{
			size, err := m.Port.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AdvertisePublicType_MultiPorts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertisePublicType_MultiPorts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultiPorts != nil {
		{
			size, err := m.MultiPorts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseWhereType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvertiseWhereType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseWhereType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AdvertiseWhereType_Site) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseWhereType_Site) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseWhereType_VirtualSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseWhereType_VirtualSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VirtualSite != nil {
		{
			size, err := m.VirtualSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseWhereType_Vk8SService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseWhereType_Vk8SService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vk8SService != nil {
		{
			size, err := m.Vk8SService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseCustomType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvertiseCustomType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseCustomType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AdvertiseWhere) > 0 {
		for iNdEx := len(m.AdvertiseWhere) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdvertiseWhere[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AdvertiseOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvertiseOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdvertiseChoice != nil {
		{
			size := m.AdvertiseChoice.Size()
			i -= size
			if _, err := m.AdvertiseChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AdvertiseOptionsType_AdvertiseInCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseOptionsType_AdvertiseInCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdvertiseInCluster != nil {
		{
			size, err := m.AdvertiseInCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseOptionsType_AdvertiseOnPublic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseOptionsType_AdvertiseOnPublic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdvertiseOnPublic != nil {
		{
			size, err := m.AdvertiseOnPublic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseOptionsType_AdvertiseCustom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseOptionsType_AdvertiseCustom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdvertiseCustom != nil {
		{
			size, err := m.AdvertiseCustom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseOptionsType_DoNotAdvertise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseOptionsType_DoNotAdvertise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DoNotAdvertise != nil {
		{
			size, err := m.DoNotAdvertise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AdvertiseSimpleServiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvertiseSimpleServiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvertiseSimpleServiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServicePort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ServicePort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SimpleServiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleServiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleServiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScaleToZero {
		i--
		if m.ScaleToZero {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.AdvertiseChoice != nil {
		{
			size := m.AdvertiseChoice.Size()
			i -= size
			if _, err := m.AdvertiseChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PersistenceChoice != nil {
		{
			size := m.PersistenceChoice.Size()
			i -= size
			if _, err := m.PersistenceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Configuration != nil {
		{
			size, err := m.Configuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Container != nil {
		{
			size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimpleServiceType_DoNotAdvertise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleServiceType_DoNotAdvertise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DoNotAdvertise != nil {
		{
			size, err := m.DoNotAdvertise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SimpleServiceType_ServicePort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleServiceType_ServicePort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.ServicePort))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *SimpleServiceType_Disabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleServiceType_Disabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disabled != nil {
		{
			size, err := m.Disabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *SimpleServiceType_Enabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleServiceType_Enabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *SimpleServiceType_SimpleAdvertise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleServiceType_SimpleAdvertise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SimpleAdvertise != nil {
		{
			size, err := m.SimpleAdvertise.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ServiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScalingChoice != nil {
		{
			size := m.ScalingChoice.Size()
			i -= size
			if _, err := m.ScalingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AdvertiseOptions != nil {
		{
			size, err := m.AdvertiseOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DeployOptions != nil {
		{
			size, err := m.DeployOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Configuration != nil {
		{
			size, err := m.Configuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Volumes) > 0 {
		for iNdEx := len(m.Volumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Volumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *ServiceType_NumReplicas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceType_NumReplicas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.NumReplicas))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ServiceType_ScaleToZero) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceType_ScaleToZero) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScaleToZero != nil {
		{
			size, err := m.ScaleToZero.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *StatefulServiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulServiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulServiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScalingChoice != nil {
		{
			size := m.ScalingChoice.Size()
			i -= size
			if _, err := m.ScalingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AdvertiseOptions != nil {
		{
			size, err := m.AdvertiseOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DeployOptions != nil {
		{
			size, err := m.DeployOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Configuration != nil {
		{
			size, err := m.Configuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Volumes) > 0 {
		for iNdEx := len(m.Volumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Volumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PersistentVolumes) > 0 {
		for iNdEx := len(m.PersistentVolumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PersistentVolumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatefulServiceType_NumReplicas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulServiceType_NumReplicas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.NumReplicas))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *StatefulServiceType_ScaleToZero) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulServiceType_ScaleToZero) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScaleToZero != nil {
		{
			size, err := m.ScaleToZero.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *JobType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeployOptions != nil {
		{
			size, err := m.DeployOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Configuration != nil {
		{
			size, err := m.Configuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Volumes) > 0 {
		for iNdEx := len(m.Volumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Volumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NumReplicas != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumReplicas))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VirtualK8S != nil {
		{
			size, err := m.VirtualK8S.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.ViewInternal != nil {
		{
			size, err := m.ViewInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.WorkloadChoice != nil {
		{
			size := m.WorkloadChoice.Size()
			i -= size
			if _, err := m.WorkloadChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_SimpleService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_SimpleService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SimpleService != nil {
		{
			size, err := m.SimpleService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_StatefulService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_StatefulService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StatefulService != nil {
		{
			size, err := m.StatefulService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadChoice != nil {
		{
			size := m.WorkloadChoice.Size()
			i -= size
			if _, err := m.WorkloadChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_SimpleService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_SimpleService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SimpleService != nil {
		{
			size, err := m.SimpleService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_StatefulService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_StatefulService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StatefulService != nil {
		{
			size, err := m.StatefulService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadChoice != nil {
		{
			size := m.WorkloadChoice.Size()
			i -= size
			if _, err := m.WorkloadChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_SimpleService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_SimpleService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SimpleService != nil {
		{
			size, err := m.SimpleService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_StatefulService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_StatefulService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StatefulService != nil {
		{
			size, err := m.StatefulService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadChoice != nil {
		{
			size := m.WorkloadChoice.Size()
			i -= size
			if _, err := m.WorkloadChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_SimpleService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_SimpleService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SimpleService != nil {
		{
			size, err := m.SimpleService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_StatefulService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_StatefulService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StatefulService != nil {
		{
			size, err := m.StatefulService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VolumeMountType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConfigurationFileType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolumeName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Mount != nil {
		l = m.Mount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EnvironmentVariableType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ConfigurationParameterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *ConfigurationParameterType_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConfigurationParameterType_EnvVar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnvVar != nil {
		l = m.EnvVar.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConfigurationParametersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PersistentStorageType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessMode != 0 {
		n += 1 + sovTypes(uint64(m.AccessMode))
	}
	if m.StorageSize != 0 {
		n += 9
	}
	if m.ClassNameChoice != nil {
		n += m.ClassNameChoice.Size()
	}
	return n
}

func (m *PersistentStorageType_Default) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Default != nil {
		l = m.Default.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PersistentStorageType_ClassName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PersistentStorageVolumeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Storage != nil {
		l = m.Storage.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Mount != nil {
		l = m.Mount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EmptyDirectoryVolumeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SizeLimit != 0 {
		n += 9
	}
	if m.Mount != nil {
		l = m.Mount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *HostPathVolumeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Mount != nil {
		l = m.Mount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StorageVolumeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VolumeChoice != nil {
		n += m.VolumeChoice.Size()
	}
	return n
}

func (m *StorageVolumeType_PersistentVolume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PersistentVolume != nil {
		l = m.PersistentVolume.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageVolumeType_EmptyDir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EmptyDir != nil {
		l = m.EmptyDir.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StorageVolumeType_HostPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostPath != nil {
		l = m.HostPath.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EphemeralStorageVolumeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VolumeChoice != nil {
		n += m.VolumeChoice.Size()
	}
	return n
}

func (m *EphemeralStorageVolumeType_EmptyDir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EmptyDir != nil {
		l = m.EmptyDir.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EphemeralStorageVolumeType_HostPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostPath != nil {
		l = m.HostPath.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PersistentVolumeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PersistentVolume != nil {
		l = m.PersistentVolume.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ImageType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RegistryChoice != nil {
		n += m.RegistryChoice.Size()
	}
	if m.PullPolicy != 0 {
		n += 1 + sovTypes(uint64(m.PullPolicy))
	}
	return n
}

func (m *ImageType_Public) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Public != nil {
		l = m.Public.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ImageType_ContainerRegistry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerRegistry != nil {
		l = m.ContainerRegistry.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortChoice != nil {
		n += m.PortChoice.Size()
	}
	return n
}

func (m *PortChoiceType_Num) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Num))
	return n
}
func (m *PortChoiceType_Name) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HTTPHealthCheckType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HostHeader)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ExecHealthCheckType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TCPHealthCheckType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *HealthCheckType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthCheckChoice != nil {
		n += m.HealthCheckChoice.Size()
	}
	if m.InitialDelay != 0 {
		n += 1 + sovTypes(uint64(m.InitialDelay))
	}
	if m.Timeout != 0 {
		n += 1 + sovTypes(uint64(m.Timeout))
	}
	if m.Interval != 0 {
		n += 1 + sovTypes(uint64(m.Interval))
	}
	if m.HealthyThreshold != 0 {
		n += 1 + sovTypes(uint64(m.HealthyThreshold))
	}
	if m.UnhealthyThreshold != 0 {
		n += 1 + sovTypes(uint64(m.UnhealthyThreshold))
	}
	return n
}

func (m *HealthCheckType_HttpHealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpHealthCheck != nil {
		l = m.HttpHealthCheck.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HealthCheckType_TcpHealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpHealthCheck != nil {
		l = m.TcpHealthCheck.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HealthCheckType_ExecHealthCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecHealthCheck != nil {
		l = m.ExecHealthCheck.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ContainerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.InitContainer {
		n += 2
	}
	if m.Flavor != 0 {
		n += 1 + sovTypes(uint64(m.Flavor))
	}
	if m.LivenessCheck != nil {
		l = m.LivenessCheck.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ReadinessCheck != nil {
		l = m.ReadinessCheck.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DeployCESiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DeployRESiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DeployREVirtualSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VirtualSite) > 0 {
		for _, e := range m.VirtualSite {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DeployCEVirtualSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VirtualSite) > 0 {
		for _, e := range m.VirtualSite {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DeployOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeployChoice != nil {
		n += m.DeployChoice.Size()
	}
	return n
}

func (m *DeployOptionsType_AllRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllRes != nil {
		l = m.AllRes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DeployOptionsType_DeployReVirtualSites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeployReVirtualSites != nil {
		l = m.DeployReVirtualSites.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DeployOptionsType_DeployCeVirtualSites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeployCeVirtualSites != nil {
		l = m.DeployCeVirtualSites.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DeployOptionsType_DeployCeSites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeployCeSites != nil {
		l = m.DeployCeSites.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DeployOptionsType_DefaultVirtualSites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultVirtualSites != nil {
		l = m.DefaultVirtualSites.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DeployOptionsType_DeployReSites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeployReSites != nil {
		l = m.DeployReSites.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *RouteInfoType_SimpleRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SimpleRoute != nil {
		l = m.SimpleRoute.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteInfoType_RedirectRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RedirectRoute != nil {
		l = m.RedirectRoute.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteInfoType_DirectResponseRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DirectResponseRoute != nil {
		l = m.DirectResponseRoute.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteInfoType_CustomRouteObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomRouteObject != nil {
		l = m.CustomRouteObject.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *MatchAllRouteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostRewriteParams != nil {
		n += m.HostRewriteParams.Size()
	}
	return n
}

func (m *MatchAllRouteType_AutoHostRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoHostRewrite != nil {
		l = m.AutoHostRewrite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *MatchAllRouteType_HostRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostRewrite)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *MatchAllRouteType_DisableHostRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableHostRewrite != nil {
		l = m.DisableHostRewrite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HTTPLoadBalancerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerType != nil {
		n += m.LoadbalancerType.Size()
	}
	if m.RouteChoice != nil {
		n += m.RouteChoice.Size()
	}
	return n
}

func (m *HTTPLoadBalancerType_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HTTPLoadBalancerType_HttpsAutoCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsAutoCert != nil {
		l = m.HttpsAutoCert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HTTPLoadBalancerType_Https) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Https != nil {
		l = m.Https.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HTTPLoadBalancerType_DefaultRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultRoute != nil {
		l = m.DefaultRoute.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HTTPLoadBalancerType_SpecificRoutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpecificRoutes != nil {
		l = m.SpecificRoutes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TCPLoadBalancerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.WithSni {
		n += 2
	}
	return n
}

func (m *PortInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.Protocol != 0 {
		n += 1 + sovTypes(uint64(m.Protocol))
	}
	if m.TargetPortChoice != nil {
		n += m.TargetPortChoice.Size()
	}
	return n
}

func (m *PortInfoType_SameAsPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SameAsPort != nil {
		l = m.SameAsPort.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortInfoType_TargetPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.TargetPort))
	return n
}
func (m *PortType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MultiPortType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SinglePortType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AdvertiseInClusterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortChoice != nil {
		n += m.PortChoice.Size()
	}
	return n
}

func (m *AdvertiseInClusterType_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseInClusterType_MultiPorts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultiPorts != nil {
		l = m.MultiPorts.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseSinglePortType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvertiseChoice != nil {
		n += m.AdvertiseChoice.Size()
	}
	return n
}

func (m *AdvertiseSinglePortType_HttpLoadbalancer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpLoadbalancer != nil {
		l = m.HttpLoadbalancer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseSinglePortType_TcpLoadbalancer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpLoadbalancer != nil {
		l = m.TcpLoadbalancer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertisePortType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvertiseChoice != nil {
		n += m.AdvertiseChoice.Size()
	}
	return n
}

func (m *AdvertisePortType_HttpLoadbalancer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpLoadbalancer != nil {
		l = m.HttpLoadbalancer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertisePortType_TcpLoadbalancer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpLoadbalancer != nil {
		l = m.TcpLoadbalancer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseMultiPortType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AdvertisePublicType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdvertiseChoice != nil {
		n += m.AdvertiseChoice.Size()
	}
	return n
}

func (m *AdvertisePublicType_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertisePublicType_MultiPorts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultiPorts != nil {
		l = m.MultiPorts.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseWhereType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AdvertiseWhereType_Site) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseWhereType_VirtualSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualSite != nil {
		l = m.VirtualSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseWhereType_Vk8SService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vk8SService != nil {
		l = m.Vk8SService.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseCustomType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AdvertiseWhere) > 0 {
		for _, e := range m.AdvertiseWhere {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AdvertiseOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdvertiseChoice != nil {
		n += m.AdvertiseChoice.Size()
	}
	return n
}

func (m *AdvertiseOptionsType_AdvertiseInCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdvertiseInCluster != nil {
		l = m.AdvertiseInCluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseOptionsType_AdvertiseOnPublic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdvertiseOnPublic != nil {
		l = m.AdvertiseOnPublic.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseOptionsType_AdvertiseCustom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdvertiseCustom != nil {
		l = m.AdvertiseCustom.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseOptionsType_DoNotAdvertise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoNotAdvertise != nil {
		l = m.DoNotAdvertise.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvertiseSimpleServiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ServicePort != 0 {
		n += 1 + sovTypes(uint64(m.ServicePort))
	}
	return n
}

func (m *SimpleServiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Configuration != nil {
		l = m.Configuration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvertiseChoice != nil {
		n += m.AdvertiseChoice.Size()
	}
	if m.PersistenceChoice != nil {
		n += m.PersistenceChoice.Size()
	}
	if m.ScaleToZero {
		n += 2
	}
	return n
}

func (m *SimpleServiceType_DoNotAdvertise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoNotAdvertise != nil {
		l = m.DoNotAdvertise.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SimpleServiceType_ServicePort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.ServicePort))
	return n
}
func (m *SimpleServiceType_Disabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled != nil {
		l = m.Disabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SimpleServiceType_Enabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SimpleServiceType_SimpleAdvertise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SimpleAdvertise != nil {
		l = m.SimpleAdvertise.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ServiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScalingChoice != nil {
		n += m.ScalingChoice.Size()
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Configuration != nil {
		l = m.Configuration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeployOptions != nil {
		l = m.DeployOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvertiseOptions != nil {
		l = m.AdvertiseOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ServiceType_NumReplicas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.NumReplicas))
	return n
}
func (m *ServiceType_ScaleToZero) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScaleToZero != nil {
		l = m.ScaleToZero.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StatefulServiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScalingChoice != nil {
		n += m.ScalingChoice.Size()
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.PersistentVolumes) > 0 {
		for _, e := range m.PersistentVolumes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Configuration != nil {
		l = m.Configuration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeployOptions != nil {
		l = m.DeployOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AdvertiseOptions != nil {
		l = m.AdvertiseOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StatefulServiceType_NumReplicas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.NumReplicas))
	return n
}
func (m *StatefulServiceType_ScaleToZero) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScaleToZero != nil {
		l = m.ScaleToZero.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *JobType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumReplicas != 0 {
		n += 1 + sovTypes(uint64(m.NumReplicas))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Configuration != nil {
		l = m.Configuration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeployOptions != nil {
		l = m.DeployOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkloadChoice != nil {
		n += m.WorkloadChoice.Size()
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VirtualK8S != nil {
		l = m.VirtualK8S.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_SimpleService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SimpleService != nil {
		l = m.SimpleService.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_StatefulService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatefulService != nil {
		l = m.StatefulService.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkloadChoice != nil {
		n += m.WorkloadChoice.Size()
	}
	return n
}

func (m *CreateSpecType_SimpleService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SimpleService != nil {
		l = m.SimpleService.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_StatefulService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatefulService != nil {
		l = m.StatefulService.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkloadChoice != nil {
		n += m.WorkloadChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_SimpleService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SimpleService != nil {
		l = m.SimpleService.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_StatefulService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatefulService != nil {
		l = m.StatefulService.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkloadChoice != nil {
		n += m.WorkloadChoice.Size()
	}
	return n
}

func (m *GetSpecType_SimpleService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SimpleService != nil {
		l = m.SimpleService.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_StatefulService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatefulService != nil {
		l = m.StatefulService.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *VolumeMountType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolumeMountType{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`MountPath:` + fmt.Sprintf("%v", this.MountPath) + `,`,
		`SubPath:` + fmt.Sprintf("%v", this.SubPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigurationFileType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigurationFileType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`VolumeName:` + fmt.Sprintf("%v", this.VolumeName) + `,`,
		`Mount:` + strings.Replace(this.Mount.String(), "VolumeMountType", "VolumeMountType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EnvironmentVariableType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EnvironmentVariableType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigurationParameterType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigurationParameterType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigurationParameterType_File) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigurationParameterType_File{`,
		`File:` + strings.Replace(fmt.Sprintf("%v", this.File), "ConfigurationFileType", "ConfigurationFileType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigurationParameterType_EnvVar) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigurationParameterType_EnvVar{`,
		`EnvVar:` + strings.Replace(fmt.Sprintf("%v", this.EnvVar), "EnvironmentVariableType", "EnvironmentVariableType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigurationParametersType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]*ConfigurationParameterType{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(f.String(), "ConfigurationParameterType", "ConfigurationParameterType", 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&ConfigurationParametersType{`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`}`,
	}, "")
	return s
}
func (this *PersistentStorageType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PersistentStorageType{`,
		`AccessMode:` + fmt.Sprintf("%v", this.AccessMode) + `,`,
		`StorageSize:` + fmt.Sprintf("%v", this.StorageSize) + `,`,
		`ClassNameChoice:` + fmt.Sprintf("%v", this.ClassNameChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PersistentStorageType_Default) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PersistentStorageType_Default{`,
		`Default:` + strings.Replace(fmt.Sprintf("%v", this.Default), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PersistentStorageType_ClassName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PersistentStorageType_ClassName{`,
		`ClassName:` + fmt.Sprintf("%v", this.ClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PersistentStorageVolumeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PersistentStorageVolumeType{`,
		`Storage:` + strings.Replace(this.Storage.String(), "PersistentStorageType", "PersistentStorageType", 1) + `,`,
		`Mount:` + strings.Replace(this.Mount.String(), "VolumeMountType", "VolumeMountType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmptyDirectoryVolumeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmptyDirectoryVolumeType{`,
		`SizeLimit:` + fmt.Sprintf("%v", this.SizeLimit) + `,`,
		`Mount:` + strings.Replace(this.Mount.String(), "VolumeMountType", "VolumeMountType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostPathVolumeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostPathVolumeType{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Mount:` + strings.Replace(this.Mount.String(), "VolumeMountType", "VolumeMountType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageVolumeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageVolumeType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`VolumeChoice:` + fmt.Sprintf("%v", this.VolumeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageVolumeType_PersistentVolume) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageVolumeType_PersistentVolume{`,
		`PersistentVolume:` + strings.Replace(fmt.Sprintf("%v", this.PersistentVolume), "PersistentStorageVolumeType", "PersistentStorageVolumeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageVolumeType_EmptyDir) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageVolumeType_EmptyDir{`,
		`EmptyDir:` + strings.Replace(fmt.Sprintf("%v", this.EmptyDir), "EmptyDirectoryVolumeType", "EmptyDirectoryVolumeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageVolumeType_HostPath) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageVolumeType_HostPath{`,
		`HostPath:` + strings.Replace(fmt.Sprintf("%v", this.HostPath), "HostPathVolumeType", "HostPathVolumeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EphemeralStorageVolumeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EphemeralStorageVolumeType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`VolumeChoice:` + fmt.Sprintf("%v", this.VolumeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EphemeralStorageVolumeType_EmptyDir) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EphemeralStorageVolumeType_EmptyDir{`,
		`EmptyDir:` + strings.Replace(fmt.Sprintf("%v", this.EmptyDir), "EmptyDirectoryVolumeType", "EmptyDirectoryVolumeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EphemeralStorageVolumeType_HostPath) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EphemeralStorageVolumeType_HostPath{`,
		`HostPath:` + strings.Replace(fmt.Sprintf("%v", this.HostPath), "HostPathVolumeType", "HostPathVolumeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PersistentVolumeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PersistentVolumeType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`PersistentVolume:` + strings.Replace(this.PersistentVolume.String(), "PersistentStorageVolumeType", "PersistentStorageVolumeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`RegistryChoice:` + fmt.Sprintf("%v", this.RegistryChoice) + `,`,
		`PullPolicy:` + fmt.Sprintf("%v", this.PullPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType_Public) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType_Public{`,
		`Public:` + strings.Replace(fmt.Sprintf("%v", this.Public), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageType_ContainerRegistry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageType_ContainerRegistry{`,
		`ContainerRegistry:` + strings.Replace(fmt.Sprintf("%v", this.ContainerRegistry), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortChoiceType{`,
		`PortChoice:` + fmt.Sprintf("%v", this.PortChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortChoiceType_Num) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortChoiceType_Num{`,
		`Num:` + fmt.Sprintf("%v", this.Num) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortChoiceType_Name) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortChoiceType_Name{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPHealthCheckType) String() string {
	if this == nil {
		return "nil"
	}
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]string{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%v: %v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	s := strings.Join([]string{`&HTTPHealthCheckType{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Port:` + strings.Replace(this.Port.String(), "PortChoiceType", "PortChoiceType", 1) + `,`,
		`HostHeader:` + fmt.Sprintf("%v", this.HostHeader) + `,`,
		`Headers:` + mapStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecHealthCheckType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecHealthCheckType{`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TCPHealthCheckType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TCPHealthCheckType{`,
		`Port:` + strings.Replace(this.Port.String(), "PortChoiceType", "PortChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HealthCheckType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HealthCheckType{`,
		`HealthCheckChoice:` + fmt.Sprintf("%v", this.HealthCheckChoice) + `,`,
		`InitialDelay:` + fmt.Sprintf("%v", this.InitialDelay) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`Interval:` + fmt.Sprintf("%v", this.Interval) + `,`,
		`HealthyThreshold:` + fmt.Sprintf("%v", this.HealthyThreshold) + `,`,
		`UnhealthyThreshold:` + fmt.Sprintf("%v", this.UnhealthyThreshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HealthCheckType_HttpHealthCheck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HealthCheckType_HttpHealthCheck{`,
		`HttpHealthCheck:` + strings.Replace(fmt.Sprintf("%v", this.HttpHealthCheck), "HTTPHealthCheckType", "HTTPHealthCheckType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HealthCheckType_TcpHealthCheck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HealthCheckType_TcpHealthCheck{`,
		`TcpHealthCheck:` + strings.Replace(fmt.Sprintf("%v", this.TcpHealthCheck), "TCPHealthCheckType", "TCPHealthCheckType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HealthCheckType_ExecHealthCheck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HealthCheckType_ExecHealthCheck{`,
		`ExecHealthCheck:` + strings.Replace(fmt.Sprintf("%v", this.ExecHealthCheck), "ExecHealthCheckType", "ExecHealthCheckType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Image:` + strings.Replace(this.Image.String(), "ImageType", "ImageType", 1) + `,`,
		`InitContainer:` + fmt.Sprintf("%v", this.InitContainer) + `,`,
		`Flavor:` + fmt.Sprintf("%v", this.Flavor) + `,`,
		`LivenessCheck:` + strings.Replace(this.LivenessCheck.String(), "HealthCheckType", "HealthCheckType", 1) + `,`,
		`ReadinessCheck:` + strings.Replace(this.ReadinessCheck.String(), "HealthCheckType", "HealthCheckType", 1) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`Args:` + fmt.Sprintf("%v", this.Args) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployCESiteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSite := "[]*ObjectRefType{"
	for _, f := range this.Site {
		repeatedStringForSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForSite += "}"
	s := strings.Join([]string{`&DeployCESiteType{`,
		`Site:` + repeatedStringForSite + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployRESiteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSite := "[]*ObjectRefType{"
	for _, f := range this.Site {
		repeatedStringForSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForSite += "}"
	s := strings.Join([]string{`&DeployRESiteType{`,
		`Site:` + repeatedStringForSite + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployREVirtualSiteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVirtualSite := "[]*ObjectRefType{"
	for _, f := range this.VirtualSite {
		repeatedStringForVirtualSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualSite += "}"
	s := strings.Join([]string{`&DeployREVirtualSiteType{`,
		`VirtualSite:` + repeatedStringForVirtualSite + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployCEVirtualSiteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVirtualSite := "[]*ObjectRefType{"
	for _, f := range this.VirtualSite {
		repeatedStringForVirtualSite += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualSite += "}"
	s := strings.Join([]string{`&DeployCEVirtualSiteType{`,
		`VirtualSite:` + repeatedStringForVirtualSite + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeployOptionsType{`,
		`DeployChoice:` + fmt.Sprintf("%v", this.DeployChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployOptionsType_AllRes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeployOptionsType_AllRes{`,
		`AllRes:` + strings.Replace(fmt.Sprintf("%v", this.AllRes), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployOptionsType_DeployReVirtualSites) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeployOptionsType_DeployReVirtualSites{`,
		`DeployReVirtualSites:` + strings.Replace(fmt.Sprintf("%v", this.DeployReVirtualSites), "DeployREVirtualSiteType", "DeployREVirtualSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployOptionsType_DeployCeVirtualSites) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeployOptionsType_DeployCeVirtualSites{`,
		`DeployCeVirtualSites:` + strings.Replace(fmt.Sprintf("%v", this.DeployCeVirtualSites), "DeployCEVirtualSiteType", "DeployCEVirtualSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployOptionsType_DeployCeSites) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeployOptionsType_DeployCeSites{`,
		`DeployCeSites:` + strings.Replace(fmt.Sprintf("%v", this.DeployCeSites), "DeployCESiteType", "DeployCESiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployOptionsType_DefaultVirtualSites) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeployOptionsType_DefaultVirtualSites{`,
		`DefaultVirtualSites:` + strings.Replace(fmt.Sprintf("%v", this.DefaultVirtualSites), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeployOptionsType_DeployReSites) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeployOptionsType_DeployReSites{`,
		`DeployReSites:` + strings.Replace(fmt.Sprintf("%v", this.DeployReSites), "DeployRESiteType", "DeployRESiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteInfoType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteInfoType_SimpleRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteInfoType_SimpleRoute{`,
		`SimpleRoute:` + strings.Replace(fmt.Sprintf("%v", this.SimpleRoute), "RouteTypeSimpleWithDefaultOriginPool", "http_loadbalancer.RouteTypeSimpleWithDefaultOriginPool", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteInfoType_RedirectRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteInfoType_RedirectRoute{`,
		`RedirectRoute:` + strings.Replace(fmt.Sprintf("%v", this.RedirectRoute), "RouteTypeRedirect", "http_loadbalancer.RouteTypeRedirect", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteInfoType_DirectResponseRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteInfoType_DirectResponseRoute{`,
		`DirectResponseRoute:` + strings.Replace(fmt.Sprintf("%v", this.DirectResponseRoute), "RouteTypeDirectResponse", "http_loadbalancer.RouteTypeDirectResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteInfoType_CustomRouteObject) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteInfoType_CustomRouteObject{`,
		`CustomRouteObject:` + strings.Replace(fmt.Sprintf("%v", this.CustomRouteObject), "RouteTypeCustomRoute", "http_loadbalancer.RouteTypeCustomRoute", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]*RouteInfoType{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(f.String(), "RouteInfoType", "RouteInfoType", 1) + ","
	}
	repeatedStringForRoutes += "}"
	s := strings.Join([]string{`&RouteType{`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchAllRouteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchAllRouteType{`,
		`HostRewriteParams:` + fmt.Sprintf("%v", this.HostRewriteParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchAllRouteType_AutoHostRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchAllRouteType_AutoHostRewrite{`,
		`AutoHostRewrite:` + strings.Replace(fmt.Sprintf("%v", this.AutoHostRewrite), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchAllRouteType_HostRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchAllRouteType_HostRewrite{`,
		`HostRewrite:` + fmt.Sprintf("%v", this.HostRewrite) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchAllRouteType_DisableHostRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchAllRouteType_DisableHostRewrite{`,
		`DisableHostRewrite:` + strings.Replace(fmt.Sprintf("%v", this.DisableHostRewrite), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPLoadBalancerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HTTPLoadBalancerType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`LoadbalancerType:` + fmt.Sprintf("%v", this.LoadbalancerType) + `,`,
		`RouteChoice:` + fmt.Sprintf("%v", this.RouteChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPLoadBalancerType_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HTTPLoadBalancerType_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ProxyTypeHttp", "http_loadbalancer.ProxyTypeHttp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPLoadBalancerType_HttpsAutoCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HTTPLoadBalancerType_HttpsAutoCert{`,
		`HttpsAutoCert:` + strings.Replace(fmt.Sprintf("%v", this.HttpsAutoCert), "ProxyTypeHttpsAutoCerts", "http_loadbalancer.ProxyTypeHttpsAutoCerts", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPLoadBalancerType_Https) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HTTPLoadBalancerType_Https{`,
		`Https:` + strings.Replace(fmt.Sprintf("%v", this.Https), "ProxyTypeHttps", "http_loadbalancer.ProxyTypeHttps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPLoadBalancerType_DefaultRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HTTPLoadBalancerType_DefaultRoute{`,
		`DefaultRoute:` + strings.Replace(fmt.Sprintf("%v", this.DefaultRoute), "MatchAllRouteType", "MatchAllRouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPLoadBalancerType_SpecificRoutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HTTPLoadBalancerType_SpecificRoutes{`,
		`SpecificRoutes:` + strings.Replace(fmt.Sprintf("%v", this.SpecificRoutes), "RouteType", "RouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TCPLoadBalancerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TCPLoadBalancerType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`WithSni:` + fmt.Sprintf("%v", this.WithSni) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortInfoType{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`TargetPortChoice:` + fmt.Sprintf("%v", this.TargetPortChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortInfoType_SameAsPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortInfoType_SameAsPort{`,
		`SameAsPort:` + strings.Replace(fmt.Sprintf("%v", this.SameAsPort), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortInfoType_TargetPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortInfoType_TargetPort{`,
		`TargetPort:` + fmt.Sprintf("%v", this.TargetPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Info:` + strings.Replace(this.Info.String(), "PortInfoType", "PortInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultiPortType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPorts := "[]*PortType{"
	for _, f := range this.Ports {
		repeatedStringForPorts += strings.Replace(f.String(), "PortType", "PortType", 1) + ","
	}
	repeatedStringForPorts += "}"
	s := strings.Join([]string{`&MultiPortType{`,
		`Ports:` + repeatedStringForPorts + `,`,
		`}`,
	}, "")
	return s
}
func (this *SinglePortType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SinglePortType{`,
		`Info:` + strings.Replace(this.Info.String(), "PortInfoType", "PortInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseInClusterType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseInClusterType{`,
		`PortChoice:` + fmt.Sprintf("%v", this.PortChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseInClusterType_Port) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseInClusterType_Port{`,
		`Port:` + strings.Replace(fmt.Sprintf("%v", this.Port), "SinglePortType", "SinglePortType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseInClusterType_MultiPorts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseInClusterType_MultiPorts{`,
		`MultiPorts:` + strings.Replace(fmt.Sprintf("%v", this.MultiPorts), "MultiPortType", "MultiPortType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseSinglePortType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseSinglePortType{`,
		`Port:` + strings.Replace(this.Port.String(), "SinglePortType", "SinglePortType", 1) + `,`,
		`AdvertiseChoice:` + fmt.Sprintf("%v", this.AdvertiseChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseSinglePortType_HttpLoadbalancer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseSinglePortType_HttpLoadbalancer{`,
		`HttpLoadbalancer:` + strings.Replace(fmt.Sprintf("%v", this.HttpLoadbalancer), "HTTPLoadBalancerType", "HTTPLoadBalancerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseSinglePortType_TcpLoadbalancer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseSinglePortType_TcpLoadbalancer{`,
		`TcpLoadbalancer:` + strings.Replace(fmt.Sprintf("%v", this.TcpLoadbalancer), "TCPLoadBalancerType", "TCPLoadBalancerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertisePortType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertisePortType{`,
		`Port:` + strings.Replace(this.Port.String(), "PortType", "PortType", 1) + `,`,
		`AdvertiseChoice:` + fmt.Sprintf("%v", this.AdvertiseChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertisePortType_HttpLoadbalancer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertisePortType_HttpLoadbalancer{`,
		`HttpLoadbalancer:` + strings.Replace(fmt.Sprintf("%v", this.HttpLoadbalancer), "HTTPLoadBalancerType", "HTTPLoadBalancerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertisePortType_TcpLoadbalancer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertisePortType_TcpLoadbalancer{`,
		`TcpLoadbalancer:` + strings.Replace(fmt.Sprintf("%v", this.TcpLoadbalancer), "TCPLoadBalancerType", "TCPLoadBalancerType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseMultiPortType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPorts := "[]*AdvertisePortType{"
	for _, f := range this.Ports {
		repeatedStringForPorts += strings.Replace(f.String(), "AdvertisePortType", "AdvertisePortType", 1) + ","
	}
	repeatedStringForPorts += "}"
	s := strings.Join([]string{`&AdvertiseMultiPortType{`,
		`Ports:` + repeatedStringForPorts + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertisePublicType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertisePublicType{`,
		`AdvertiseChoice:` + fmt.Sprintf("%v", this.AdvertiseChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertisePublicType_Port) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertisePublicType_Port{`,
		`Port:` + strings.Replace(fmt.Sprintf("%v", this.Port), "AdvertiseSinglePortType", "AdvertiseSinglePortType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertisePublicType_MultiPorts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertisePublicType_MultiPorts{`,
		`MultiPorts:` + strings.Replace(fmt.Sprintf("%v", this.MultiPorts), "AdvertiseMultiPortType", "AdvertiseMultiPortType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseWhereType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseWhereType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseWhereType_Site) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseWhereType_Site{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "WhereSite", "views.WhereSite", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseWhereType_VirtualSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseWhereType_VirtualSite{`,
		`VirtualSite:` + strings.Replace(fmt.Sprintf("%v", this.VirtualSite), "WhereVirtualSite", "views.WhereVirtualSite", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseWhereType_Vk8SService) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseWhereType_Vk8SService{`,
		`Vk8SService:` + strings.Replace(fmt.Sprintf("%v", this.Vk8SService), "WhereVK8SService", "views.WhereVK8SService", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseCustomType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPorts := "[]*AdvertisePortType{"
	for _, f := range this.Ports {
		repeatedStringForPorts += strings.Replace(f.String(), "AdvertisePortType", "AdvertisePortType", 1) + ","
	}
	repeatedStringForPorts += "}"
	repeatedStringForAdvertiseWhere := "[]*AdvertiseWhereType{"
	for _, f := range this.AdvertiseWhere {
		repeatedStringForAdvertiseWhere += strings.Replace(f.String(), "AdvertiseWhereType", "AdvertiseWhereType", 1) + ","
	}
	repeatedStringForAdvertiseWhere += "}"
	s := strings.Join([]string{`&AdvertiseCustomType{`,
		`Ports:` + repeatedStringForPorts + `,`,
		`AdvertiseWhere:` + repeatedStringForAdvertiseWhere + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseOptionsType{`,
		`AdvertiseChoice:` + fmt.Sprintf("%v", this.AdvertiseChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseOptionsType_AdvertiseInCluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseOptionsType_AdvertiseInCluster{`,
		`AdvertiseInCluster:` + strings.Replace(fmt.Sprintf("%v", this.AdvertiseInCluster), "AdvertiseInClusterType", "AdvertiseInClusterType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseOptionsType_AdvertiseOnPublic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseOptionsType_AdvertiseOnPublic{`,
		`AdvertiseOnPublic:` + strings.Replace(fmt.Sprintf("%v", this.AdvertiseOnPublic), "AdvertisePublicType", "AdvertisePublicType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseOptionsType_AdvertiseCustom) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseOptionsType_AdvertiseCustom{`,
		`AdvertiseCustom:` + strings.Replace(fmt.Sprintf("%v", this.AdvertiseCustom), "AdvertiseCustomType", "AdvertiseCustomType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseOptionsType_DoNotAdvertise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseOptionsType_DoNotAdvertise{`,
		`DoNotAdvertise:` + strings.Replace(fmt.Sprintf("%v", this.DoNotAdvertise), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvertiseSimpleServiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvertiseSimpleServiceType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`ServicePort:` + fmt.Sprintf("%v", this.ServicePort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleServiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleServiceType{`,
		`Container:` + strings.Replace(this.Container.String(), "ContainerType", "ContainerType", 1) + `,`,
		`Configuration:` + strings.Replace(this.Configuration.String(), "ConfigurationParametersType", "ConfigurationParametersType", 1) + `,`,
		`AdvertiseChoice:` + fmt.Sprintf("%v", this.AdvertiseChoice) + `,`,
		`PersistenceChoice:` + fmt.Sprintf("%v", this.PersistenceChoice) + `,`,
		`ScaleToZero:` + fmt.Sprintf("%v", this.ScaleToZero) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleServiceType_DoNotAdvertise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleServiceType_DoNotAdvertise{`,
		`DoNotAdvertise:` + strings.Replace(fmt.Sprintf("%v", this.DoNotAdvertise), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleServiceType_ServicePort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleServiceType_ServicePort{`,
		`ServicePort:` + fmt.Sprintf("%v", this.ServicePort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleServiceType_Disabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleServiceType_Disabled{`,
		`Disabled:` + strings.Replace(fmt.Sprintf("%v", this.Disabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleServiceType_Enabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleServiceType_Enabled{`,
		`Enabled:` + strings.Replace(fmt.Sprintf("%v", this.Enabled), "PersistentVolumeType", "PersistentVolumeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SimpleServiceType_SimpleAdvertise) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SimpleServiceType_SimpleAdvertise{`,
		`SimpleAdvertise:` + strings.Replace(fmt.Sprintf("%v", this.SimpleAdvertise), "AdvertiseSimpleServiceType", "AdvertiseSimpleServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContainers := "[]*ContainerType{"
	for _, f := range this.Containers {
		repeatedStringForContainers += strings.Replace(f.String(), "ContainerType", "ContainerType", 1) + ","
	}
	repeatedStringForContainers += "}"
	repeatedStringForVolumes := "[]*StorageVolumeType{"
	for _, f := range this.Volumes {
		repeatedStringForVolumes += strings.Replace(f.String(), "StorageVolumeType", "StorageVolumeType", 1) + ","
	}
	repeatedStringForVolumes += "}"
	s := strings.Join([]string{`&ServiceType{`,
		`ScalingChoice:` + fmt.Sprintf("%v", this.ScalingChoice) + `,`,
		`Containers:` + repeatedStringForContainers + `,`,
		`Volumes:` + repeatedStringForVolumes + `,`,
		`Configuration:` + strings.Replace(this.Configuration.String(), "ConfigurationParametersType", "ConfigurationParametersType", 1) + `,`,
		`DeployOptions:` + strings.Replace(this.DeployOptions.String(), "DeployOptionsType", "DeployOptionsType", 1) + `,`,
		`AdvertiseOptions:` + strings.Replace(this.AdvertiseOptions.String(), "AdvertiseOptionsType", "AdvertiseOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceType_NumReplicas) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceType_NumReplicas{`,
		`NumReplicas:` + fmt.Sprintf("%v", this.NumReplicas) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceType_ScaleToZero) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceType_ScaleToZero{`,
		`ScaleToZero:` + strings.Replace(fmt.Sprintf("%v", this.ScaleToZero), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatefulServiceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContainers := "[]*ContainerType{"
	for _, f := range this.Containers {
		repeatedStringForContainers += strings.Replace(f.String(), "ContainerType", "ContainerType", 1) + ","
	}
	repeatedStringForContainers += "}"
	repeatedStringForPersistentVolumes := "[]*PersistentVolumeType{"
	for _, f := range this.PersistentVolumes {
		repeatedStringForPersistentVolumes += strings.Replace(f.String(), "PersistentVolumeType", "PersistentVolumeType", 1) + ","
	}
	repeatedStringForPersistentVolumes += "}"
	repeatedStringForVolumes := "[]*EphemeralStorageVolumeType{"
	for _, f := range this.Volumes {
		repeatedStringForVolumes += strings.Replace(f.String(), "EphemeralStorageVolumeType", "EphemeralStorageVolumeType", 1) + ","
	}
	repeatedStringForVolumes += "}"
	s := strings.Join([]string{`&StatefulServiceType{`,
		`ScalingChoice:` + fmt.Sprintf("%v", this.ScalingChoice) + `,`,
		`Containers:` + repeatedStringForContainers + `,`,
		`PersistentVolumes:` + repeatedStringForPersistentVolumes + `,`,
		`Volumes:` + repeatedStringForVolumes + `,`,
		`Configuration:` + strings.Replace(this.Configuration.String(), "ConfigurationParametersType", "ConfigurationParametersType", 1) + `,`,
		`DeployOptions:` + strings.Replace(this.DeployOptions.String(), "DeployOptionsType", "DeployOptionsType", 1) + `,`,
		`AdvertiseOptions:` + strings.Replace(this.AdvertiseOptions.String(), "AdvertiseOptionsType", "AdvertiseOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatefulServiceType_NumReplicas) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatefulServiceType_NumReplicas{`,
		`NumReplicas:` + fmt.Sprintf("%v", this.NumReplicas) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatefulServiceType_ScaleToZero) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatefulServiceType_ScaleToZero{`,
		`ScaleToZero:` + strings.Replace(fmt.Sprintf("%v", this.ScaleToZero), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContainers := "[]*ContainerType{"
	for _, f := range this.Containers {
		repeatedStringForContainers += strings.Replace(f.String(), "ContainerType", "ContainerType", 1) + ","
	}
	repeatedStringForContainers += "}"
	repeatedStringForVolumes := "[]*StorageVolumeType{"
	for _, f := range this.Volumes {
		repeatedStringForVolumes += strings.Replace(f.String(), "StorageVolumeType", "StorageVolumeType", 1) + ","
	}
	repeatedStringForVolumes += "}"
	s := strings.Join([]string{`&JobType{`,
		`NumReplicas:` + fmt.Sprintf("%v", this.NumReplicas) + `,`,
		`Containers:` + repeatedStringForContainers + `,`,
		`Volumes:` + repeatedStringForVolumes + `,`,
		`Configuration:` + strings.Replace(this.Configuration.String(), "ConfigurationParametersType", "ConfigurationParametersType", 1) + `,`,
		`DeployOptions:` + strings.Replace(this.DeployOptions.String(), "DeployOptionsType", "DeployOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`WorkloadChoice:` + fmt.Sprintf("%v", this.WorkloadChoice) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VirtualK8S:` + strings.Replace(fmt.Sprintf("%v", this.VirtualK8S), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_SimpleService) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_SimpleService{`,
		`SimpleService:` + strings.Replace(fmt.Sprintf("%v", this.SimpleService), "SimpleServiceType", "SimpleServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Service) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Service{`,
		`Service:` + strings.Replace(fmt.Sprintf("%v", this.Service), "ServiceType", "ServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_StatefulService) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_StatefulService{`,
		`StatefulService:` + strings.Replace(fmt.Sprintf("%v", this.StatefulService), "StatefulServiceType", "StatefulServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Job) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Job{`,
		`Job:` + strings.Replace(fmt.Sprintf("%v", this.Job), "JobType", "JobType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`WorkloadChoice:` + fmt.Sprintf("%v", this.WorkloadChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_SimpleService) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_SimpleService{`,
		`SimpleService:` + strings.Replace(fmt.Sprintf("%v", this.SimpleService), "SimpleServiceType", "SimpleServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Service) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Service{`,
		`Service:` + strings.Replace(fmt.Sprintf("%v", this.Service), "ServiceType", "ServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_StatefulService) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_StatefulService{`,
		`StatefulService:` + strings.Replace(fmt.Sprintf("%v", this.StatefulService), "StatefulServiceType", "StatefulServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Job) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Job{`,
		`Job:` + strings.Replace(fmt.Sprintf("%v", this.Job), "JobType", "JobType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`WorkloadChoice:` + fmt.Sprintf("%v", this.WorkloadChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_SimpleService) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_SimpleService{`,
		`SimpleService:` + strings.Replace(fmt.Sprintf("%v", this.SimpleService), "SimpleServiceType", "SimpleServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Service) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Service{`,
		`Service:` + strings.Replace(fmt.Sprintf("%v", this.Service), "ServiceType", "ServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_StatefulService) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_StatefulService{`,
		`StatefulService:` + strings.Replace(fmt.Sprintf("%v", this.StatefulService), "StatefulServiceType", "StatefulServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Job) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Job{`,
		`Job:` + strings.Replace(fmt.Sprintf("%v", this.Job), "JobType", "JobType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`WorkloadChoice:` + fmt.Sprintf("%v", this.WorkloadChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_SimpleService) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_SimpleService{`,
		`SimpleService:` + strings.Replace(fmt.Sprintf("%v", this.SimpleService), "SimpleServiceType", "SimpleServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Service) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Service{`,
		`Service:` + strings.Replace(fmt.Sprintf("%v", this.Service), "ServiceType", "ServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_StatefulService) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_StatefulService{`,
		`StatefulService:` + strings.Replace(fmt.Sprintf("%v", this.StatefulService), "StatefulServiceType", "StatefulServiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Job) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Job{`,
		`Job:` + strings.Replace(fmt.Sprintf("%v", this.Job), "JobType", "JobType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *VolumeMountType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeMountType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeMountType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= VolumeMountModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigurationFileType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigurationFileType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigurationFileType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mount == nil {
				m.Mount = &VolumeMountType{}
			}
			if err := m.Mount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvironmentVariableType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvironmentVariableType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvironmentVariableType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigurationParameterType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigurationParameterType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigurationParameterType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConfigurationFileType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ConfigurationParameterType_File{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnvironmentVariableType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ConfigurationParameterType_EnvVar{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigurationParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigurationParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigurationParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &ConfigurationParameterType{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentStorageType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentStorageType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentStorageType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessMode", wireType)
			}
			m.AccessMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessMode |= PersistentStorageAccessModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageSize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.StorageSize = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ClassNameChoice = &PersistentStorageType_Default{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassNameChoice = &PersistentStorageType_ClassName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentStorageVolumeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentStorageVolumeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentStorageVolumeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Storage == nil {
				m.Storage = &PersistentStorageType{}
			}
			if err := m.Storage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mount == nil {
				m.Mount = &VolumeMountType{}
			}
			if err := m.Mount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyDirectoryVolumeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyDirectoryVolumeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyDirectoryVolumeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeLimit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SizeLimit = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mount == nil {
				m.Mount = &VolumeMountType{}
			}
			if err := m.Mount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostPathVolumeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostPathVolumeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostPathVolumeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mount == nil {
				m.Mount = &VolumeMountType{}
			}
			if err := m.Mount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageVolumeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageVolumeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageVolumeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistentVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PersistentStorageVolumeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VolumeChoice = &StorageVolumeType_PersistentVolume{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmptyDir", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EmptyDirectoryVolumeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VolumeChoice = &StorageVolumeType_EmptyDir{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HostPathVolumeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VolumeChoice = &StorageVolumeType_HostPath{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EphemeralStorageVolumeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EphemeralStorageVolumeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EphemeralStorageVolumeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmptyDir", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EmptyDirectoryVolumeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VolumeChoice = &EphemeralStorageVolumeType_EmptyDir{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HostPathVolumeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VolumeChoice = &EphemeralStorageVolumeType_HostPath{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentVolumeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentVolumeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentVolumeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistentVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PersistentVolume == nil {
				m.PersistentVolume = &PersistentStorageVolumeType{}
			}
			if err := m.PersistentVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RegistryChoice = &ImageType_Public{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRegistry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RegistryChoice = &ImageType_ContainerRegistry{v}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullPolicy", wireType)
			}
			m.PullPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PullPolicy |= ImagePullPolicyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortChoice = &PortChoiceType_Num{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortChoice = &PortChoiceType_Name{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPHealthCheckType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPHealthCheckType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPHealthCheckType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &PortChoiceType{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostHeader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecHealthCheckType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecHealthCheckType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecHealthCheckType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPHealthCheckType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPHealthCheckType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPHealthCheckType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &PortChoiceType{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpHealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HTTPHealthCheckType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HealthCheckChoice = &HealthCheckType_HttpHealthCheck{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TCPHealthCheckType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HealthCheckChoice = &HealthCheckType_TcpHealthCheck{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecHealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExecHealthCheckType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HealthCheckChoice = &HealthCheckType_ExecHealthCheck{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialDelay", wireType)
			}
			m.InitialDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthyThreshold", wireType)
			}
			m.HealthyThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthyThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyThreshold", wireType)
			}
			m.UnhealthyThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnhealthyThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &ImageType{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitContainer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitContainer = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavor", wireType)
			}
			m.Flavor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flavor |= ContainerFlavorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LivenessCheck == nil {
				m.LivenessCheck = &HealthCheckType{}
			}
			if err := m.LivenessCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadinessCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadinessCheck == nil {
				m.ReadinessCheck = &HealthCheckType{}
			}
			if err := m.ReadinessCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployCESiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployCESiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployCESiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &views.ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployRESiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployRESiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployRESiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &views.ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployREVirtualSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployREVirtualSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployREVirtualSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualSite = append(m.VirtualSite, &views.ObjectRefType{})
			if err := m.VirtualSite[len(m.VirtualSite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployCEVirtualSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployCEVirtualSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployCEVirtualSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualSite = append(m.VirtualSite, &views.ObjectRefType{})
			if err := m.VirtualSite[len(m.VirtualSite)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllRes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeployChoice = &DeployOptionsType_AllRes{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployReVirtualSites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeployREVirtualSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeployChoice = &DeployOptionsType_DeployReVirtualSites{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployCeVirtualSites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeployCEVirtualSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeployChoice = &DeployOptionsType_DeployCeVirtualSites{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployCeSites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeployCESiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeployChoice = &DeployOptionsType_DeployCeSites{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultVirtualSites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeployChoice = &DeployOptionsType_DefaultVirtualSites{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployReSites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeployRESiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeployChoice = &DeployOptionsType_DeployReSites{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.RouteTypeSimpleWithDefaultOriginPool{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &RouteInfoType_SimpleRoute{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.RouteTypeRedirect{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &RouteInfoType_RedirectRoute{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectResponseRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.RouteTypeDirectResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &RouteInfoType_DirectResponseRoute{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomRouteObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.RouteTypeCustomRoute{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &RouteInfoType_CustomRouteObject{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &RouteInfoType{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchAllRouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchAllRouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchAllRouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoHostRewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HostRewriteParams = &MatchAllRouteType_AutoHostRewrite{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRewrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRewriteParams = &MatchAllRouteType_HostRewrite{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableHostRewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HostRewriteParams = &MatchAllRouteType_DisableHostRewrite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPLoadBalancerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPLoadBalancerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPLoadBalancerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &HTTPLoadBalancerType_Http{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsAutoCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttpsAutoCerts{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &HTTPLoadBalancerType_HttpsAutoCert{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Https", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &HTTPLoadBalancerType_Https{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MatchAllRouteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteChoice = &HTTPLoadBalancerType_DefaultRoute{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecificRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RouteChoice = &HTTPLoadBalancerType_SpecificRoutes{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCPLoadBalancerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPLoadBalancerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPLoadBalancerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSni", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithSni = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= ProtocolType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SameAsPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TargetPortChoice = &PortInfoType_SameAsPort{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetPortChoice = &PortInfoType_TargetPort{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &PortInfoType{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiPortType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiPortType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiPortType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortType{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SinglePortType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SinglePortType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SinglePortType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &PortInfoType{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvertiseInClusterType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertiseInClusterType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertiseInClusterType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SinglePortType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AdvertiseInClusterType_Port{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MultiPortType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AdvertiseInClusterType_MultiPorts{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvertiseSinglePortType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertiseSinglePortType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertiseSinglePortType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &SinglePortType{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpLoadbalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HTTPLoadBalancerType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertiseSinglePortType_HttpLoadbalancer{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpLoadbalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TCPLoadBalancerType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertiseSinglePortType_TcpLoadbalancer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvertisePortType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertisePortType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertisePortType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &PortType{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpLoadbalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HTTPLoadBalancerType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertisePortType_HttpLoadbalancer{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpLoadbalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TCPLoadBalancerType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertisePortType_TcpLoadbalancer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvertiseMultiPortType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertiseMultiPortType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertiseMultiPortType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AdvertisePortType{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvertisePublicType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertisePublicType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertisePublicType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdvertiseSinglePortType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertisePublicType_Port{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdvertiseMultiPortType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertisePublicType_MultiPorts{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvertiseWhereType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertiseWhereType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertiseWhereType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.WhereSite{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AdvertiseWhereType_Site{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.WhereVirtualSite{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AdvertiseWhereType_VirtualSite{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vk8SService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.WhereVK8SService{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AdvertiseWhereType_Vk8SService{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvertiseCustomType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertiseCustomType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertiseCustomType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &AdvertisePortType{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseWhere", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertiseWhere = append(m.AdvertiseWhere, &AdvertiseWhereType{})
			if err := m.AdvertiseWhere[len(m.AdvertiseWhere)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvertiseOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertiseOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertiseOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseInCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdvertiseInClusterType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertiseOptionsType_AdvertiseInCluster{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseOnPublic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdvertisePublicType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertiseOptionsType_AdvertiseOnPublic{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseCustom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdvertiseCustomType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertiseOptionsType_AdvertiseCustom{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoNotAdvertise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &AdvertiseOptionsType_DoNotAdvertise{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvertiseSimpleServiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvertiseSimpleServiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvertiseSimpleServiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			m.ServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServicePort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleServiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleServiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleServiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &ContainerType{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = &ConfigurationParametersType{}
			}
			if err := m.Configuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoNotAdvertise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &SimpleServiceType_DoNotAdvertise{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdvertiseChoice = &SimpleServiceType_ServicePort{v}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PersistenceChoice = &SimpleServiceType_Disabled{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PersistentVolumeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PersistenceChoice = &SimpleServiceType_Enabled{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleAdvertise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdvertiseSimpleServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AdvertiseChoice = &SimpleServiceType_SimpleAdvertise{v}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleToZero", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScaleToZero = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScalingChoice = &ServiceType_NumReplicas{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &ContainerType{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &StorageVolumeType{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = &ConfigurationParametersType{}
			}
			if err := m.Configuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeployOptions == nil {
				m.DeployOptions = &DeployOptionsType{}
			}
			if err := m.DeployOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvertiseOptions == nil {
				m.AdvertiseOptions = &AdvertiseOptionsType{}
			}
			if err := m.AdvertiseOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleToZero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ScalingChoice = &ServiceType_ScaleToZero{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulServiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulServiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulServiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScalingChoice = &StatefulServiceType_NumReplicas{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &ContainerType{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistentVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistentVolumes = append(m.PersistentVolumes, &PersistentVolumeType{})
			if err := m.PersistentVolumes[len(m.PersistentVolumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &EphemeralStorageVolumeType{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = &ConfigurationParametersType{}
			}
			if err := m.Configuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeployOptions == nil {
				m.DeployOptions = &DeployOptionsType{}
			}
			if err := m.DeployOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdvertiseOptions == nil {
				m.AdvertiseOptions = &AdvertiseOptionsType{}
			}
			if err := m.AdvertiseOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleToZero", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ScalingChoice = &StatefulServiceType_ScaleToZero{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			m.NumReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &ContainerType{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &StorageVolumeType{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = &ConfigurationParametersType{}
			}
			if err := m.Configuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeployOptions == nil {
				m.DeployOptions = &DeployOptionsType{}
			}
			if err := m.DeployOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SimpleServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &GlobalSpecType_SimpleService{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &GlobalSpecType_Service{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatefulService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &GlobalSpecType_StatefulService{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &GlobalSpecType_Job{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualK8S", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualK8S == nil {
				m.VirtualK8S = &views.ObjectRefType{}
			}
			if err := m.VirtualK8S.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SimpleServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &CreateSpecType_SimpleService{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &CreateSpecType_Service{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatefulService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &CreateSpecType_StatefulService{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &CreateSpecType_Job{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SimpleServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &ReplaceSpecType_SimpleService{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &ReplaceSpecType_Service{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatefulService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &ReplaceSpecType_StatefulService{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &ReplaceSpecType_Job{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SimpleServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &GetSpecType_SimpleService{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &GetSpecType_Service{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatefulService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulServiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &GetSpecType_StatefulService{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.WorkloadChoice = &GetSpecType_Job{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
