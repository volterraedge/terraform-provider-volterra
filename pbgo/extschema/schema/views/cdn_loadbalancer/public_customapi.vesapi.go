// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package cdn_loadbalancer

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAPI GRPC Client satisfying server.CustomClient
type CustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAPIGrpcClient) doRPCCDNAccessLogAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &CDNAccessLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.CDNAccessLogAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.CDNAccessLogAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCCDNAccessLogs(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &CDNAccessLogRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.CDNAccessLogRequest", yamlReq)
	}
	rsp, err := c.grpcClient.CDNAccessLogs(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCCDNCachePurge(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LilacCDNCachePurgeRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeRequest", yamlReq)
	}
	rsp, err := c.grpcClient.CDNCachePurge(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCCDNMetrics(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LilacCDNMetricsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.CDNMetrics(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetServiceOperation(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetServiceOperationReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.GetServiceOperationReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetServiceOperation(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCListServiceOperations(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &ListServiceOperationsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsReq", yamlReq)
	}
	rsp, err := c.grpcClient.ListServiceOperations(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCSubscribe(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SubscribeRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.SubscribeRequest", yamlReq)
	}
	rsp, err := c.grpcClient.Subscribe(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCUnsubscribe(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &UnsubscribeRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.UnsubscribeRequest", yamlReq)
	}
	rsp, err := c.grpcClient.Unsubscribe(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["CDNAccessLogAggregationQuery"] = ccl.doRPCCDNAccessLogAggregationQuery

	rpcFns["CDNAccessLogs"] = ccl.doRPCCDNAccessLogs

	rpcFns["CDNCachePurge"] = ccl.doRPCCDNCachePurge

	rpcFns["CDNMetrics"] = ccl.doRPCCDNMetrics

	rpcFns["GetServiceOperation"] = ccl.doRPCGetServiceOperation

	rpcFns["ListServiceOperations"] = ccl.doRPCListServiceOperations

	rpcFns["Subscribe"] = ccl.doRPCSubscribe

	rpcFns["Unsubscribe"] = ccl.doRPCUnsubscribe

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPI REST Client satisfying server.CustomClient
type CustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAPIRestClient) doRPCCDNAccessLogAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &CDNAccessLogAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.CDNAccessLogAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		for _, item := range req.Query {
			q.Add("query", fmt.Sprintf("%v", item))
		}
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &CDNLogAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.cdn_loadbalancer.CDNLogAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCCDNAccessLogs(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &CDNAccessLogRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.CDNAccessLogRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		for _, item := range req.Query {
			q.Add("query", fmt.Sprintf("%v", item))
		}
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &CDNLogResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.cdn_loadbalancer.CDNLogResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCCDNCachePurge(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LilacCDNCachePurgeRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("pattern", fmt.Sprintf("%v", req.Pattern))
		q.Add("purge_epoch_timestamp", fmt.Sprintf("%v", req.PurgeEpochTimestamp))
		q.Add("purge_type", fmt.Sprintf("%v", req.PurgeType))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LilacCDNCachePurgeResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCCDNMetrics(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LilacCDNMetricsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		for _, item := range req.FieldSelector {
			q.Add("field_selector", fmt.Sprintf("%v", item))
		}
		for _, item := range req.Filter {
			q.Add("filter", fmt.Sprintf("%v", item))
		}
		for _, item := range req.GroupBy {
			q.Add("group_by", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LilacCDNMetricsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetServiceOperation(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetServiceOperationReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.GetServiceOperationReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("service_op_id", fmt.Sprintf("%v", req.ServiceOpId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetServiceOperationRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.cdn_loadbalancer.GetServiceOperationRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCListServiceOperations(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &ListServiceOperationsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("options", fmt.Sprintf("%v", req.Options))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &ListServiceOperationsRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCSubscribe(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SubscribeRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.SubscribeRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SubscribeResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.cdn_loadbalancer.SubscribeResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCUnsubscribe(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &UnsubscribeRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.cdn_loadbalancer.UnsubscribeRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &UnsubscribeResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.cdn_loadbalancer.UnsubscribeResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["CDNAccessLogAggregationQuery"] = ccl.doRPCCDNAccessLogAggregationQuery

	rpcFns["CDNAccessLogs"] = ccl.doRPCCDNAccessLogs

	rpcFns["CDNCachePurge"] = ccl.doRPCCDNCachePurge

	rpcFns["CDNMetrics"] = ccl.doRPCCDNMetrics

	rpcFns["GetServiceOperation"] = ccl.doRPCGetServiceOperation

	rpcFns["ListServiceOperations"] = ccl.doRPCListServiceOperations

	rpcFns["Subscribe"] = ccl.doRPCSubscribe

	rpcFns["Unsubscribe"] = ccl.doRPCUnsubscribe

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customAPIInprocClient

// INPROC Client (satisfying CustomAPIClient interface)
type customAPIInprocClient struct {
	CustomAPIServer
}

func (c *customAPIInprocClient) CDNAccessLogAggregationQuery(ctx context.Context, in *CDNAccessLogAggregationRequest, opts ...grpc.CallOption) (*CDNLogAggregationResponse, error) {
	return c.CustomAPIServer.CDNAccessLogAggregationQuery(ctx, in)
}
func (c *customAPIInprocClient) CDNAccessLogs(ctx context.Context, in *CDNAccessLogRequest, opts ...grpc.CallOption) (*CDNLogResponse, error) {
	return c.CustomAPIServer.CDNAccessLogs(ctx, in)
}
func (c *customAPIInprocClient) CDNCachePurge(ctx context.Context, in *LilacCDNCachePurgeRequest, opts ...grpc.CallOption) (*LilacCDNCachePurgeResponse, error) {
	return c.CustomAPIServer.CDNCachePurge(ctx, in)
}
func (c *customAPIInprocClient) CDNMetrics(ctx context.Context, in *LilacCDNMetricsRequest, opts ...grpc.CallOption) (*LilacCDNMetricsResponse, error) {
	return c.CustomAPIServer.CDNMetrics(ctx, in)
}
func (c *customAPIInprocClient) GetServiceOperation(ctx context.Context, in *GetServiceOperationReq, opts ...grpc.CallOption) (*GetServiceOperationRsp, error) {
	return c.CustomAPIServer.GetServiceOperation(ctx, in)
}
func (c *customAPIInprocClient) ListServiceOperations(ctx context.Context, in *ListServiceOperationsReq, opts ...grpc.CallOption) (*ListServiceOperationsRsp, error) {
	return c.CustomAPIServer.ListServiceOperations(ctx, in)
}
func (c *customAPIInprocClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	return c.CustomAPIServer.Subscribe(ctx, in)
}
func (c *customAPIInprocClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	return c.CustomAPIServer.Unsubscribe(ctx, in)
}

func NewCustomAPIInprocClient(svc svcfw.Service) CustomAPIClient {
	return &customAPIInprocClient{CustomAPIServer: NewCustomAPIServer(svc)}
}

// RegisterGwCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAPIHandlerClient(ctx, mux, NewCustomAPIInprocClient(s))
}

// Create customAPISrv

// SERVER (satisfying CustomAPIServer interface)
type customAPISrv struct {
	svc svcfw.Service
}

func (s *customAPISrv) CDNAccessLogAggregationQuery(ctx context.Context, in *CDNAccessLogAggregationRequest) (*CDNLogAggregationResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *CDNLogAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.CDNAccessLogAggregationQuery' operation on 'cdn_loadbalancer'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNAccessLogAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.CDNAccessLogAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.CDNLogAggregationResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) CDNAccessLogs(ctx context.Context, in *CDNAccessLogRequest) (*CDNLogResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *CDNLogResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.CDNAccessLogs' operation on 'cdn_loadbalancer'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNAccessLogs"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.CDNAccessLogs(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.CDNLogResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) CDNCachePurge(ctx context.Context, in *LilacCDNCachePurgeRequest) (*LilacCDNCachePurgeResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *LilacCDNCachePurgeResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.CDNCachePurge' operation on 'cdn_loadbalancer'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNCachePurge"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.CDNCachePurge(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) CDNMetrics(ctx context.Context, in *LilacCDNMetricsRequest) (*LilacCDNMetricsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *LilacCDNMetricsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.CDNMetrics' operation on 'cdn_loadbalancer'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNMetrics"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.CDNMetrics(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetServiceOperation(ctx context.Context, in *GetServiceOperationReq) (*GetServiceOperationRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *GetServiceOperationRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.GetServiceOperationReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetServiceOperation' operation on 'cdn_loadbalancer'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.CustomAPI.GetServiceOperation"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetServiceOperation(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.GetServiceOperationRsp", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) ListServiceOperations(ctx context.Context, in *ListServiceOperationsReq) (*ListServiceOperationsRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *ListServiceOperationsRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.ListServiceOperations' operation on 'cdn_loadbalancer'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.CustomAPI.ListServiceOperations"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ListServiceOperations(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsRsp", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) Subscribe(ctx context.Context, in *SubscribeRequest) (*SubscribeResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *SubscribeResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.SubscribeRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.Subscribe' operation on 'cdn_loadbalancer'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.CustomAPI.Subscribe"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.Subscribe(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.SubscribeResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) Unsubscribe(ctx context.Context, in *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *UnsubscribeResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.UnsubscribeRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.Unsubscribe' operation on 'cdn_loadbalancer'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.CustomAPI.Unsubscribe"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.Unsubscribe(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.cdn_loadbalancer.UnsubscribeResponse", rsp)...)

	return rsp, nil
}

func NewCustomAPIServer(svc svcfw.Service) CustomAPIServer {
	return &customAPISrv{svc: svc}
}

var CustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "CDN",
        "description": "CDN package",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/system/lilac-cdn/addon/subscribe": {
            "post": {
                "summary": "Subscribe to CDN Loadbalancer",
                "description": "Subscribe to CDN Loadbalancer",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.Subscribe",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerSubscribeResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerSubscribeRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-customapi-subscribe"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.Subscribe"
            },
            "x-displayname": "Custom API for CDN LoadBalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/lilac-cdn/addon/unsubscribe": {
            "post": {
                "summary": "Unsubscribe to CDN Loadbalancer",
                "description": "Unsubscribe to CDN Loadbalancer",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.Unsubscribe",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerUnsubscribeResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerUnsubscribeRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-customapi-unsubscribe"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.Unsubscribe"
            },
            "x-displayname": "Custom API for CDN LoadBalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancer/access_logs": {
            "post": {
                "summary": "Get CDN Access Logs",
                "description": "Retrieve CDN Load-Balancer Access logs",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNAccessLogs",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerCDNLogResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nfetch access logs for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerCDNAccessLogRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-customapi-cdnaccesslogs"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNAccessLogs"
            },
            "x-displayname": "Custom API for CDN LoadBalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancer/access_logs/aggregation": {
            "post": {
                "summary": "CDN Access Log Aggregation Query",
                "description": "Request to get summary/analytics data for the cdn access logs that matches the query in request for a given namespace.",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNAccessLogAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerCDNLogAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"value\"\nget aggregation data for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerCDNAccessLogAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-customapi-cdnaccesslogaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNAccessLogAggregationQuery"
            },
            "x-displayname": "Custom API for CDN LoadBalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancer/get-service-operation-status": {
            "post": {
                "summary": "Get Service Operation Status",
                "description": "Get status of an operation command for a given CDN Loadbalancer.",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.GetServiceOperation",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerGetServiceOperationRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"default\"\nx-required\nNamespace scope of the operation request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerGetServiceOperationReq"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-customapi-getserviceoperation"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.GetServiceOperation"
            },
            "x-displayname": "Custom API for CDN LoadBalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancer/list-service-operations-status": {
            "post": {
                "summary": "List of CDN Operation Commands",
                "description": "List of service operations for a given CDN LB",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.ListServiceOperations",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerListServiceOperationsRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"ns1\"\nx-required\nThe namespace this item belongs to",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerListServiceOperationsReq"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-customapi-listserviceoperations"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.ListServiceOperations"
            },
            "x-displayname": "Custom API for CDN LoadBalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancer/metrics": {
            "post": {
                "summary": "Get CDN Metrics",
                "description": "Initial metrics request for CDN loadbalancers",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNMetrics",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"default\"\nx-required\nNamespace scope of the metric request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-customapi-cdnmetrics"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNMetrics"
            },
            "x-displayname": "Custom API for CDN LoadBalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancer/{name}/cache-purge": {
            "post": {
                "summary": "Purge CDN Cache",
                "description": "Initiate Purge for Edge CDN Cache",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNCachePurge",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerLilacCDNCachePurgeResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"default\"\nx-required\nNamespace scope of the metric request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "CDN Distribution Name\n\nx-example: \"cdn-1\"\nx-required\nFormat: string",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name of the CDN distrubition"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerLilacCDNCachePurgeRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-customapi-cdncachepurge"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.CustomAPI.CDNCachePurge"
            },
            "x-displayname": "Custom API for CDN LoadBalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "access_logCDNAccessLogTag": {
            "type": "string",
            "description": "Tags on which CDN access logs can be filtered or grouped by\n",
            "title": "Metrics Tag options",
            "enum": [
                "CDN_NAME",
                "SITE_NAME",
                "METHOD",
                "REQ_PATH",
                "RSP_CODE",
                "USER_AGENT",
                "SCHEME",
                "COUNTRY",
                "CACHE_STATUS",
                "RSP_CONTENT_TYPE",
                "HOST_HEADER",
                "REFERER",
                "SNI",
                "UPSTREAM_STATUS",
                "RSP_CODE_CLASS",
                "SRC_IP",
                "TLS_VERSION",
                "REQ_SIZE",
                "HTTP_VERSION",
                "CITY_NAME",
                "UPSTREAM_ADDR"
            ],
            "default": "CDN_NAME",
            "x-displayname": "Tags",
            "x-ves-proto-enum": "ves.io.schema.views.cdn_loadbalancer.access_log.CDNAccessLogTag"
        },
        "cdn_loadbalancerCDNAccessLogAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for access logs",
            "title": "CDNAccessLogAggregationRequest",
            "x-displayname": "CDN Access Log Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 64\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.max_pairs: 16\n",
                    "title": "aggregations",
                    "x-displayname": "Aggregations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "64",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.max_pairs": "16"
                    }
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch access logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "namespace": {
                    "type": "string",
                    "description": " get aggregation data for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "array",
                    "description": " CDN Access Logs filter options",
                    "title": "Access Logs Filter options",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCDNAccessLogFilter"
                    },
                    "x-displayname": "Access Logs Filter"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch access logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "cdn_loadbalancerCDNAccessLogFilter": {
            "type": "object",
            "description": "CDN Access log filter options",
            "title": "Access Log filter fields",
            "x-displayname": "CDN Access log Filter",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogFilter",
            "properties": {
                "operator": {
                    "description": " Operators possible in filtering\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "CDN Access Logs Operator Types",
                    "$ref": "#/definitions/cdn_loadbalancerCDNAccessLogOperatorType",
                    "x-displayname": "CDN Access Logs Operator Types",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "tag": {
                    "description": " Tags on which CDN Access Log can be filtered by\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Access Log Filter Tag options",
                    "$ref": "#/definitions/access_logCDNAccessLogTag",
                    "x-displayname": "Filter Tags",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "values": {
                    "type": "array",
                    "description": " Filter values\n\nExample: - \"[IN, US]\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.max_len: 128\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Filter values",
                    "maxItems": 32,
                    "items": {
                        "type": "string",
                        "maxLength": 128
                    },
                    "x-displayname": "Filter values",
                    "x-ves-example": "[IN, US]",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "128",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerCDNAccessLogOperatorType": {
            "type": "string",
            "description": "Operators possible in filtering\n",
            "title": "Metrics Operator Types",
            "enum": [
                "CDN_ACCESS_LOG_OPERATOR_TYPE_IN",
                "CDN_ACCESS_LOG_OPERATOR_TYPE_NOT_IN"
            ],
            "default": "CDN_ACCESS_LOG_OPERATOR_TYPE_IN",
            "x-displayname": "Metrics Operator Types",
            "x-ves-proto-enum": "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogOperatorType"
        },
        "cdn_loadbalancerCDNAccessLogRequest": {
            "type": "object",
            "description": "Request to fetch access logs.",
            "title": "CDNAccessLogRequest",
            "x-displayname": "CDN Access Log Request",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 64\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.max_pairs: 16\n",
                    "title": "aggregations",
                    "x-displayname": "Aggregations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "64",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.max_pairs": "16"
                    }
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch access logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"2019-09-24T12:30:11.733Z\"-",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "2019-09-24T12:30:11.733Z"
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of logs returned in the response\n Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"0\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 500\n",
                    "title": "limit",
                    "format": "int64",
                    "x-displayname": "Limit",
                    "x-ves-example": "0",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "500"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch access logs for a given namespace\n\nExample: - \"value\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "value"
                },
                "query": {
                    "type": "array",
                    "description": " CDN Access Logs filter options\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 32\n",
                    "title": "Access Logs Filter options",
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCDNAccessLogFilter"
                    },
                    "x-displayname": "Access Logs Filter",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "32"
                    }
                },
                "sort": {
                    "description": " specifies whether the response should be sorted in ascending or descending order based on timestamp in the log\n Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch access logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"2019-09-23T12:30:11.733Z\"-",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z"
                }
            }
        },
        "cdn_loadbalancerCDNAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"CDN Lodbalancer Aggregation Request\"\nAggregation request for CDN Loadbalancer, to provide analytics data over the log response",
            "title": "CDN Aggregation Request",
            "properties": {
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the log",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/cdn_loadbalancerCDNDateAggregation"
                },
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the log",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/cdn_loadbalancerCDNFieldAggregation"
                }
            }
        },
        "cdn_loadbalancerCDNDateAggregation": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation\"\nAggregate access logs based on timestamp in the log",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each date bucket",
                    "title": "sub aggregation"
                }
            }
        },
        "cdn_loadbalancerCDNDateSubAggregation": {
            "type": "object",
            "description": "x-displayName: \"Date SubAggregation\"\nAggregate access logs in each date bucket based on one of the sub aggregation types",
            "title": "CDN Date SubAggregation",
            "properties": {
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the access log",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/cdn_loadbalancerCDNFieldAggregation"
                }
            }
        },
        "cdn_loadbalancerCDNFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation\"\nAggregate access logs based on the key fields in the log.",
            "title": "Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name by which the logs should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/access_logCDNAccessLogTag"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\nx-example: \"5\"\nNumber of top field values to be returned in the response.\nOptional: If not specified, top 5 values will be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "cdn_loadbalancerCDNLogAggregationResponse": {
            "type": "object",
            "description": "Response message for CDNAccessLogAggregationRequest",
            "title": "CDNLogAggregationResponse",
            "x-displayname": "CDN Log Aggregation Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNLogAggregationResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregation data is key'ed with the aggregation name specified in the request.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "total_hits": {
                    "type": "string",
                    "description": " total number of log messages that matched the query.\n\nExample: - \"0\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "0"
                }
            }
        },
        "cdn_loadbalancerCDNLogResponse": {
            "type": "object",
            "description": "Response message for AccessLogRequest",
            "title": "CDNLogResponse",
            "x-displayname": "CDN Log Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNLogResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregation data is key'ed with the aggregation name specified in the request.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "logs": {
                    "type": "array",
                    "description": " list of log messages that matched the query. Not all log messages that matched the query are returned in the response.\n\nExample: - \"value\"-",
                    "title": "logs",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerLilacCDNAccessLogsResponseData"
                    },
                    "x-displayname": "Logs",
                    "x-ves-example": "value"
                },
                "total_hits": {
                    "type": "string",
                    "description": " total number of log messages that matched the query.\n\nExample: - \"0\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "0"
                }
            }
        },
        "cdn_loadbalancerGetServiceOperationReq": {
            "type": "object",
            "description": "Get Service Operation Request",
            "title": "Service Operation Request",
            "x-displayname": "Get Service Operation Request",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.GetServiceOperationReq",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " Name of the CDN distribution.\n Format: string\n\nExample: - \"cdn-1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "CDN Distribution Name",
                    "x-displayname": "Name of the CDN distribution",
                    "x-ves-example": "cdn-1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace scope of the operation request\n\nExample: - \"default\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "default",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "service_op_id": {
                    "type": "integer",
                    "description": " Operation ID for which status is requested\n\nExample: - \"101\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Service Operation ID",
                    "format": "int64",
                    "x-displayname": "Service Operation ID",
                    "x-ves-example": "101",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerGetServiceOperationRsp": {
            "type": "object",
            "description": "Get Service Operation Response",
            "title": "Service Operation Response",
            "x-displayname": "Service Operation Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.GetServiceOperationRsp",
            "properties": {
                "error": {
                    "description": " Errors(if any) while listing items from collection ",
                    "title": "error",
                    "$ref": "#/definitions/schemaErrorType",
                    "x-displayname": "Errors"
                },
                "items": {
                    "type": "array",
                    "description": " items represents the collection in response",
                    "title": "Serice Operation Status Details",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerServiceOperationItem"
                    },
                    "x-displayname": "Operation Status Details"
                }
            }
        },
        "cdn_loadbalancerLilacCDNAccessLogsResponseData": {
            "type": "object",
            "description": "CDN Access-Log item",
            "title": "CDN access logs data item",
            "x-displayname": "CDN Access log data item",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNAccessLogsResponseData",
            "properties": {
                "cache_status": {
                    "type": "string",
                    "description": " CDN Cache Status\n\nExample: - \"MISS\"-",
                    "title": "CDN Cache Status",
                    "x-displayname": "CDN Cache Status",
                    "x-ves-example": "MISS"
                },
                "cdn_name": {
                    "type": "string",
                    "description": " Name of the CDN distribution\n\nExample: - \"my-website\"-",
                    "title": "CDN Name",
                    "x-displayname": "Name of the CDN Distribution",
                    "x-ves-example": "my-website"
                },
                "city_id": {
                    "type": "string",
                    "description": " Geo City Id [maxmind]\n\nExample: - \"3109256\"-",
                    "title": "Geo City Id",
                    "x-displayname": "Geo City Id",
                    "x-ves-example": "3109256"
                },
                "city_name": {
                    "type": "string",
                    "description": " Geo City Name\n\nExample: - \"Segovia\"-",
                    "title": "Geo City Name",
                    "x-displayname": "Geo City Name",
                    "x-ves-example": "Segovia"
                },
                "client_port": {
                    "type": "string",
                    "description": " Client Port\n\nExample: - \"50756\"-",
                    "title": "Client port",
                    "x-displayname": "Client Port",
                    "x-ves-example": "50756"
                },
                "country": {
                    "type": "string",
                    "description": " Geo Country Code of the request\n\nExample: - \"\"-",
                    "title": "Geo Country Code of the request",
                    "x-displayname": "Geo Country Code of the request"
                },
                "geo_location": {
                    "type": "string",
                    "description": " Geo Location of the request\n\nExample: - \"\"-",
                    "title": "Geo Location of the request",
                    "x-displayname": "Geo Location of the request"
                },
                "host": {
                    "type": "string",
                    "description": " Host Name of the node where the log was captured\n\nExample: - \"edge-node-1-85955f9c64-jqw7j\"-",
                    "title": "Host",
                    "x-displayname": "Name of the Host",
                    "x-ves-example": "edge-node-1-85955f9c64-jqw7j"
                },
                "host_header": {
                    "type": "string",
                    "description": " HTTP Host Header\n\nExample: - \"www.f5.com\"-",
                    "title": "Host Header",
                    "x-displayname": "HTTP Host Header Value",
                    "x-ves-example": "www.f5.com"
                },
                "http_version": {
                    "type": "string",
                    "description": " HTTP Version of the request\n\nExample: - \"HTTP/1.1\"-",
                    "title": "HTTP Version of the request",
                    "x-displayname": "HTTP Version of the request",
                    "x-ves-example": "HTTP/1.1"
                },
                "method": {
                    "type": "string",
                    "description": " HTTP Method Name\n\nExample: - \"get\"-",
                    "title": "HTTP Method Name",
                    "x-displayname": "HTTP Method Name",
                    "x-ves-example": "get"
                },
                "referer": {
                    "type": "string",
                    "description": " HTTP referer\n\nExample: - \"https://example.com/\"-",
                    "title": "HTTP referer",
                    "x-displayname": "HTTP referer",
                    "x-ves-example": "https://example.com/"
                },
                "req_content_type": {
                    "type": "string",
                    "description": " Content-Type of the request\n\nExample: - \"text/html\"-",
                    "title": "Content-Type of the request",
                    "x-displayname": "Content-Type of the request",
                    "x-ves-example": "text/html"
                },
                "req_path": {
                    "type": "string",
                    "description": " HTTP request path\n\nExample: - \"/index.html\"-",
                    "title": "HTTP request path",
                    "x-displayname": "HTTP request path",
                    "x-ves-example": "/index.html"
                },
                "req_size": {
                    "type": "string",
                    "description": " HTTP Request Size\n\nExample: - \"-",
                    "title": "HTTP Request Size",
                    "format": "uint64",
                    "x-displayname": "HTTP Request Size"
                },
                "request_time": {
                    "type": "string",
                    "description": " Time taken by the request\n\nExample: - \"0.0\"-",
                    "title": "Time taken by the request",
                    "x-displayname": "Time taken by the request",
                    "x-ves-example": "0.0"
                },
                "rsp_code": {
                    "type": "string",
                    "description": " HTTP Response Code\n\nExample: - \"200\"-",
                    "title": "HTTP Response Code",
                    "x-displayname": "HTTP Response Code",
                    "x-ves-example": "200"
                },
                "rsp_code_class": {
                    "type": "string",
                    "description": " HTTP Response Code Class\n\nExample: - \"2xx\"-",
                    "title": "HTTP Response Code Class",
                    "x-displayname": "HTTP Response Code Class",
                    "x-ves-example": "2xx"
                },
                "rsp_content_type": {
                    "type": "string",
                    "description": " Content-Type of the response\n\nExample: - \"text/html\"-",
                    "title": "Content-Type of the response",
                    "x-displayname": "Content-Type of the response",
                    "x-ves-example": "text/html"
                },
                "rsp_size": {
                    "type": "string",
                    "description": " HTTP Response Size\n\nExample: - \"600\"-",
                    "title": "HTTP Response Size",
                    "format": "uint64",
                    "x-displayname": "HTTP Response Size",
                    "x-ves-example": "600"
                },
                "scheme": {
                    "type": "string",
                    "description": " HTTP request scheme\n\nExample: - \"https\"-",
                    "title": "HTTP request scheme",
                    "x-displayname": "HTTP request scheme",
                    "x-ves-example": "https"
                },
                "site_name": {
                    "type": "string",
                    "description": " Name of the Site\n\nExample: - \"pa4-par-cdn\"-",
                    "title": "Site Name",
                    "x-displayname": "Name of the Site",
                    "x-ves-example": "pa4-par-cdn"
                },
                "src_ip": {
                    "type": "string",
                    "description": " Source IP address\n\nExample: - \"1.2.3.4\"-",
                    "title": "Source IP address",
                    "x-displayname": "IP address of the client from where the request came from ",
                    "x-ves-example": "1.2.3.4"
                },
                "timestamp": {
                    "type": "string",
                    "description": " Format: unix_timestamp|rfc 3339\n\nExample: - \"2022-10-21T01:05:32.713Z\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Timestamp",
                    "x-displayname": "Timestamp of the access log",
                    "x-ves-example": "2022-10-21T01:05:32.713Z",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "tls_sni": {
                    "type": "string",
                    "description": " TLS Service Name Indication\n\nExample: - \"www.f5.com\"-",
                    "title": "Service Name Indication",
                    "x-displayname": "TLS Service Name Indication Value",
                    "x-ves-example": "www.f5.com"
                },
                "tls_version": {
                    "type": "string",
                    "description": " TLS Version Value\n\nExample: - \"TLSv1.3\"-",
                    "title": "TLS Version",
                    "x-displayname": "TLS Version Value",
                    "x-ves-example": "TLSv1.3"
                },
                "upstream_addr": {
                    "type": "string",
                    "description": " Upstream Address\n\nExample: - \"\"-",
                    "title": "Upstream Address",
                    "x-displayname": "Upstream Address"
                },
                "upstream_connect_time": {
                    "type": "string",
                    "description": " Upstream Connect Time\n\nExample: - \"\"-",
                    "title": "Upstream Connect Time",
                    "x-displayname": "Upstream Connect Time"
                },
                "upstream_response_time": {
                    "type": "string",
                    "description": " Upstream Response Time\n\nExample: - \"nginx.data.fr-edge1-0\"-",
                    "title": "Upstream Response Time",
                    "x-displayname": "Upstream Response Time",
                    "x-ves-example": "nginx.data.fr-edge1-0"
                },
                "upstream_status": {
                    "type": "string",
                    "description": " Upstream Status\n\nExample: - \"nginx.data.fr-edge1-0\"-",
                    "title": "Upstream Status",
                    "x-displayname": "Upstream Status",
                    "x-ves-example": "nginx.data.fr-edge1-0"
                },
                "user": {
                    "type": "string",
                    "description": " Name of the user\n\nExample: - \"\"-",
                    "title": "User name",
                    "x-displayname": "Name of the User"
                },
                "user_agent": {
                    "type": "string",
                    "description": " HTTP User Agent\n\nExample: - \"Mozilla/5.0\"-",
                    "title": "HTTP User Agent",
                    "x-displayname": "HTTP User Agent",
                    "x-ves-example": "Mozilla/5.0"
                }
            }
        },
        "cdn_loadbalancerLilacCDNCachePurgeRequest": {
            "type": "object",
            "description": "CDN Cache Purge",
            "title": "Cache Purge Request",
            "x-displayname": "Cache Purge",
            "x-ves-oneof-field-purge_type": "[\"hard_purge\",\"soft_purge\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeRequest",
            "properties": {
                "hard_purge": {
                    "description": "Exclusive with [soft_purge]\n Delete the Cache entries",
                    "title": "Hard Purge",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Hard Purge"
                },
                "name": {
                    "type": "string",
                    "description": " Format: string\n\nExample: - \"cdn-1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "CDN Distribution Name",
                    "x-displayname": "Name of the CDN distrubition",
                    "x-ves-example": "cdn-1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace scope of the metric request\n\nExample: - \"default\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "default",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "pattern": {
                    "type": "string",
                    "description": " Format: string\n Purge only the objects whos name matches the pattern\n\nExample: - \"*.ts\"-",
                    "title": "Regex Pattern to match",
                    "x-displayname": "Pattern (RegEx)",
                    "x-ves-example": "*.ts"
                },
                "purge_epoch_timestamp": {
                    "type": "string",
                    "description": " Format: unix_timestamp|rfc 3339\n Purge objects that were created on or before this timestamp\n\nExample: - \"1659758607\"-",
                    "title": "Purge Timestamp",
                    "x-displayname": "Purge Time",
                    "x-ves-example": "1659758607"
                },
                "soft_purge": {
                    "description": "Exclusive with [hard_purge]\n Invalidate the Cache entries",
                    "title": "Soft Purge",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Soft Purge"
                }
            }
        },
        "cdn_loadbalancerLilacCDNCachePurgeResponse": {
            "type": "object",
            "description": "Cache Purge message",
            "title": "Purge Response",
            "x-displayname": "Cache Purge Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeResponse",
            "properties": {
                "purge_request_id": {
                    "type": "integer",
                    "description": " Request Id to track the status of the purge request",
                    "title": "Purge Request Id",
                    "format": "int64",
                    "x-displayname": "Purge Request Id"
                }
            }
        },
        "cdn_loadbalancerLilacCDNMetricUnit": {
            "type": "string",
            "description": "Metric Unit\n",
            "title": "Metric Unit",
            "enum": [
                "COUNT",
                "BYTES",
                "MILLISECONDS"
            ],
            "default": "COUNT",
            "x-displayname": "Metric Unit",
            "x-ves-proto-enum": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricUnit"
        },
        "cdn_loadbalancerLilacCDNMetricsFieldSelector": {
            "type": "string",
            "description": "CDN Metric fields. Naming convention is \u003cfield\u003e_\u003caggregation\u003e\n\nREQUEST_SUCCESS computed from REQUEST_TOTAL - REQUEST_FAILED\nBandwidth computed from DATA_OUT",
            "title": "Metrics Field Selector options",
            "enum": [
                "REQUEST_TOTAL_SUM",
                "REQUEST_FAILED_SUM",
                "REQUEST_1XX_SUM",
                "REQUEST_2XX_SUM",
                "REQUEST_3XX_SUM",
                "REQUEST_4XX_SUM",
                "REQUEST_5XX_SUM",
                "DATA_OUT_SUM",
                "LATENCY_MEAN"
            ],
            "default": "REQUEST_TOTAL_SUM",
            "x-displayname": "Metrics Field Selector",
            "x-ves-proto-enum": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFieldSelector"
        },
        "cdn_loadbalancerLilacCDNMetricsFilter": {
            "type": "object",
            "description": "CDN Metrics filter options",
            "title": "Metrics Filter options",
            "x-displayname": "Metrics Filter",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFilter",
            "properties": {
                "operator": {
                    "description": " Operators possible in filtering\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Metrics Operator Types",
                    "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsOperatorType",
                    "x-displayname": "Metrics Operator Types",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "tag": {
                    "description": " Tags on which CDN metrics can be filtered by\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Metrics Filter Tag options",
                    "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsTag",
                    "x-displayname": "Filter Tags",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "values": {
                    "type": "array",
                    "description": " Filter values\n\nExample: - \"[IN, US]\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Filter values",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Filter values",
                    "x-ves-example": "[IN, US]",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerLilacCDNMetricsOperatorType": {
            "type": "string",
            "description": "Operators possible in filtering\n",
            "title": "Metrics Operator Types",
            "enum": [
                "OPERATOR_TYPE_IN",
                "OPERATOR_TYPE_NOT_IN"
            ],
            "default": "OPERATOR_TYPE_IN",
            "x-displayname": "Metrics Operator Types",
            "x-ves-proto-enum": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsOperatorType"
        },
        "cdn_loadbalancerLilacCDNMetricsRequest": {
            "type": "object",
            "description": "CDN Metrics request parameters",
            "title": "Metrics Request parameters",
            "x-displayname": "Metrics Request",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " Format: unix_timestamp|rfc 3339\n\nExample: - \"1659758607\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "End Time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1659758607",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "field_selector": {
                    "type": "array",
                    "description": " Fields (Metrics) selected to be queried.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 10\n",
                    "title": "Field Selector",
                    "maxItems": 10,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsFieldSelector"
                    },
                    "x-displayname": "Field Selector",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "10"
                    }
                },
                "filter": {
                    "type": "array",
                    "description": " CDN Metrics filter options",
                    "title": "Metrics Filter options",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsFilter"
                    },
                    "x-displayname": "Metrics Filter"
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by zero or more tags",
                    "title": "Group By",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsTag"
                    },
                    "x-displayname": "Group By"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace scope of the metric request\n\nExample: - \"default\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "default",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "start_time": {
                    "type": "string",
                    "description": " Format: unix_timestamp|rfc 3339\n\nExample: - \"1659758607\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Start Time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1659758607",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in\n the response. The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step,\n where tn \u003c= end_time. Depending on the time range, the step has a minimum value (due to rollups).\n For e.g. for ranges in last one hr, step minimum is 5m, for ranges beyond a day, its 1h etc.\n Step value used is the max(\u003cmin-step-for-range\u003e, \u003cstep-value-in-request\u003e)\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"1m\"-",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "1m"
                }
            }
        },
        "cdn_loadbalancerLilacCDNMetricsResponse": {
            "type": "object",
            "description": "CDN Metrics response message",
            "title": "Metrics Response",
            "x-displayname": "Metrics Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponse",
            "properties": {
                "items": {
                    "type": "array",
                    "description": " CDN Metrics response data items. Each instance has response for a field queried.",
                    "title": "Metrics Response Data",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsResponseData"
                    },
                    "x-displayname": "Metrics Response data items"
                },
                "step": {
                    "type": "string",
                    "description": " The effective step used in the response. It could be higher than the requested step due to rollups.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"5m\"-",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "5m"
                }
            }
        },
        "cdn_loadbalancerLilacCDNMetricsResponseData": {
            "type": "object",
            "description": "CDN Metrics response data. This is specific to a metric field.",
            "title": "Metrics Response Data",
            "x-displayname": "Metrics Response Data",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseData",
            "properties": {
                "series": {
                    "type": "array",
                    "description": " CDN Metrics response series for the field in this message",
                    "title": "Metrics Series",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsResponseSeries"
                    },
                    "x-displayname": "Metrics Response Series"
                },
                "type": {
                    "description": " Metrics field for this response message",
                    "title": "Metrics Field Selector options",
                    "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsFieldSelector",
                    "x-displayname": "Metrics Field Selector"
                },
                "unit": {
                    "description": " Metric Unit of the field in this message",
                    "title": "Metric Unit",
                    "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricUnit",
                    "x-displayname": "Metric Unit"
                }
            }
        },
        "cdn_loadbalancerLilacCDNMetricsResponseGroupBy": {
            "type": "object",
            "description": "CDN Metrics group by options",
            "title": "Metrics group by options",
            "x-displayname": "Metrics Group By",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseGroupBy",
            "properties": {
                "name": {
                    "description": " Tag on which CDN metric was requested to be grouped in request",
                    "title": "Metric Group-By Tags",
                    "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsTag",
                    "x-displayname": "Group By Tags"
                },
                "value": {
                    "type": "string",
                    "description": " Group-By tag Value",
                    "title": "Group-By tag Value",
                    "x-displayname": "Group By Tag Value"
                }
            }
        },
        "cdn_loadbalancerLilacCDNMetricsResponseSeries": {
            "type": "object",
            "description": "CDN Metrics response series.\nEach series instance has data for a combination of group-by tag values.",
            "title": "Metrics Series",
            "x-displayname": "Metrics Response Series",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseSeries",
            "properties": {
                "group_by": {
                    "type": "array",
                    "description": " CDN Metrics group-by tag combination.",
                    "title": "Metrics group by options",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsResponseGroupBy"
                    },
                    "x-displayname": "Metrics Group By"
                },
                "value": {
                    "type": "array",
                    "description": " CDN Metrics data for the series.",
                    "title": "Metrics Response Value",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerLilacCDNMetricsResponseValue"
                    },
                    "x-displayname": "Metrics Response Value"
                }
            }
        },
        "cdn_loadbalancerLilacCDNMetricsResponseValue": {
            "type": "object",
            "description": "CDN Metrics response value",
            "title": "Metrics Response Value",
            "x-displayname": "Metrics Response Value",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseValue",
            "properties": {
                "timestamp": {
                    "type": "string",
                    "description": " Metric Timestamp in unix_timestamp",
                    "title": "Metric Timestamp",
                    "x-displayname": "Metric Timestamp"
                },
                "value": {
                    "type": "string",
                    "description": " Metric Value",
                    "title": "Metric Value",
                    "x-displayname": "Metric Value"
                }
            }
        },
        "cdn_loadbalancerLilacCDNMetricsTag": {
            "type": "string",
            "description": "Tags on which CDN metrics can be filtered or grouped by\n\nHIT|MISS\nTwo letter country code\nhttp_1_1|http_2_0 etc\ntlsv1_0|tlsv1_1|tlsv1_2 etc",
            "title": "Metrics Tag options",
            "enum": [
                "CDN_DISTRIBUTION_NAME",
                "CACHE_HIT_TYPE",
                "REQUEST_COUNTRY",
                "HTTP_VERSION",
                "TLS_VERSION",
                "POP_REGION",
                "POP"
            ],
            "default": "CDN_DISTRIBUTION_NAME",
            "x-displayname": "Tags",
            "x-ves-proto-enum": "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag"
        },
        "cdn_loadbalancerListServiceOperationsReq": {
            "type": "object",
            "description": "List Service Operations Request",
            "title": "Service Operations Request",
            "x-displayname": "List Service Operations Request",
            "x-ves-oneof-field-options": "[\"lastn\",\"time_range\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsReq",
            "properties": {
                "lastn": {
                    "type": "integer",
                    "description": "Exclusive with [time_range]\n The last n service operations\n\nExample: - \"5\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "lastn",
                    "format": "int64",
                    "x-displayname": "Last N",
                    "x-ves-example": "5",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " Name of the CDN Distribution\n\nExample: - \"name\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "name"
                },
                "namespace": {
                    "type": "string",
                    "description": " The namespace this item belongs to\n\nExample: - \"ns1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "time_range": {
                    "description": "Exclusive with [lastn]\n service operations between a start and end time.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "time-range",
                    "$ref": "#/definitions/cdn_loadbalancerServiceOperationsTimeRange",
                    "x-displayname": "Time Range",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerListServiceOperationsRsp": {
            "type": "object",
            "description": "Get Service Operations Response",
            "title": "Service Operations Response",
            "x-displayname": "Service Operations Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsRsp",
            "properties": {
                "error": {
                    "description": " Errors(if any) while listing items from collection",
                    "title": "error",
                    "$ref": "#/definitions/schemaErrorType",
                    "x-displayname": "Errors"
                },
                "items": {
                    "type": "array",
                    "description": " items represents the collection in response",
                    "title": "Details of the Service Operation",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerServiceOperationsItem"
                    },
                    "x-displayname": "Details of the Service Operation"
                }
            }
        },
        "cdn_loadbalancerPurgeOperationItem": {
            "type": "object",
            "description": "Purge Operation Status",
            "title": "Purge Operation Status",
            "x-displayname": "Purge Operation Status",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.PurgeOperationItem",
            "properties": {
                "bytes_not_purged": {
                    "type": "string",
                    "description": " Number of bytes Not Purged\n\nExample: - 1024-",
                    "title": "Number of Bytes Not Purged",
                    "format": "uint64",
                    "x-displayname": "Number of Bytes Not Purged"
                },
                "bytes_purged": {
                    "type": "string",
                    "description": " Number of bytes Purged\n\nExample: - 1024-",
                    "title": "Number of Bytes Purged",
                    "format": "uint64",
                    "x-displayname": "Number of Bytes Purged"
                },
                "finish_time": {
                    "type": "string",
                    "description": " Finish time of Purge Operation\n format: unix_timestamp|rfc 3339\n\nExample: - \"2019-09-23T12:32:11.733Z\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Finish time of Purge Operation",
                    "x-displayname": "Cache Purge Finish Time",
                    "x-ves-example": "2019-09-23T12:32:11.733Z",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "hard_purge": {
                    "type": "boolean",
                    "description": " Cache Hard Purge\n\nExample: - true-",
                    "title": "Hard Purge",
                    "format": "boolean",
                    "x-displayname": "Cache Hard Purge"
                },
                "purge_time": {
                    "type": "string",
                    "description": " Time taken for Cache Purge\n\nExample: - \"2018-12-23T12:30:11.733Z\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Time taken for Cache Purge",
                    "x-displayname": "Cache Purge Time",
                    "x-ves-example": "2018-12-23T12:30:11.733Z",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "regexp": {
                    "type": "string",
                    "description": " Regex issued in the Purge Operation\n\nExample: - \"*.m3u8\"-",
                    "title": "Regex used in Purge",
                    "x-displayname": "Cache Purge Regex",
                    "x-ves-example": "*.m3u8"
                },
                "site": {
                    "type": "string",
                    "description": " Site at which the purge operation was performed.",
                    "title": "NodeId on which the operation status is gathered",
                    "x-displayname": "CDN CE Site"
                },
                "start_time": {
                    "type": "string",
                    "description": " Start time of Purge Operation\n\nExample: - \"2019-09-23T12:30:11.733Z\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time of Purge Operation",
                    "x-displayname": "Cache Purge Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerServiceOperationItem": {
            "type": "object",
            "description": "Service Operation Item",
            "title": "Service Operation Item",
            "x-displayname": "Service Operation Item",
            "x-ves-oneof-field-op_status": "[\"purge\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ServiceOperationItem",
            "properties": {
                "purge": {
                    "description": "Exclusive with []\n",
                    "$ref": "#/definitions/cdn_loadbalancerPurgeOperationItem"
                },
                "service_op_id": {
                    "type": "integer",
                    "description": " Operation ID for which status is requested. This for example is the purge_request_id obtained in the response to the CachePurge Request.\n\nExample: - \"101\"-",
                    "title": "Service Operation ID",
                    "format": "int64",
                    "x-displayname": "Service Operation ID",
                    "x-ves-example": "101"
                },
                "status": {
                    "type": "string",
                    "description": " Status of the operation command\n\nExample: - success-",
                    "title": "Service Operation Status",
                    "x-displayname": "Service Operation Status"
                }
            }
        },
        "cdn_loadbalancerServiceOperationsItem": {
            "type": "object",
            "description": "List of Service Operations",
            "title": "Service Operations Item",
            "x-displayname": "List of Service Operations",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ServiceOperationsItem",
            "properties": {
                "created_time": {
                    "type": "string",
                    "description": " The service created time\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "created time",
                    "x-displayname": "Created Time",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "modified_time": {
                    "type": "string",
                    "description": " The service modified time\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "modified time",
                    "x-displayname": "Modified Time",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "service_op_id": {
                    "type": "integer",
                    "description": " The id of the operation command\n\nExample: - \"\"-",
                    "title": "service operation id",
                    "format": "int64",
                    "x-displayname": "Service Operation ID"
                },
                "svc_version": {
                    "type": "integer",
                    "description": " The version info of the service\n\nExample: - \"\"-",
                    "title": "svc version",
                    "format": "int64",
                    "x-displayname": "Service Version"
                }
            }
        },
        "cdn_loadbalancerServiceOperationsTimeRange": {
            "type": "object",
            "description": "Option to specify lastn or start-end time.",
            "title": "Service Operations Time Range",
            "x-displayname": "Service Operations Options",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ServiceOperationsTimeRange",
            "properties": {
                "finish_time": {
                    "type": "string",
                    "description": " A finish time for the time range in which the service operation status is requested.\n format: unix_timestamp|rfc 3339\n\nExample: - \"2019-09-23T12:32:11.733Z\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Finish time of Service Operations",
                    "x-displayname": "Service Operation Finish Time",
                    "x-ves-example": "2019-09-23T12:32:11.733Z",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "start_time": {
                    "type": "string",
                    "description": " A start time for the time range in which the service operation status is requested.\n\nExample: - \"2019-09-23T12:30:11.733Z\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time of Service Operations",
                    "x-displayname": "Service Operation Start Time",
                    "x-ves-example": "2019-09-23T12:30:11.733Z",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerSubscribeRequest": {
            "type": "object",
            "description": "Request to subscribe to CDN Loadbalancer",
            "title": "SubscribeRequest",
            "x-displayname": "Subscribe Request",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.SubscribeRequest"
        },
        "cdn_loadbalancerSubscribeResponse": {
            "type": "object",
            "description": "Response of subscribe to CDN Loadbalancer",
            "title": "SubscribeResponse",
            "x-displayname": "Subscribe Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.SubscribeResponse"
        },
        "cdn_loadbalancerUnsubscribeRequest": {
            "type": "object",
            "description": "Request to unsubscribe to CDN Loadbalancer",
            "title": "UnsubscribeRequest",
            "x-displayname": "Unsubscribe Request",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.UnsubscribeRequest"
        },
        "cdn_loadbalancerUnsubscribeResponse": {
            "type": "object",
            "description": "Response of unsubscribe to CDN Loadbalancer",
            "title": "UnsubscribeResponse",
            "x-displayname": "Unsubscribe Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.UnsubscribeResponse"
        },
        "ioschemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "logCardinalityAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Cardinality Aggregation Data\"\nApproximate count of distinct values of the log field specified in the request.",
            "title": "CardinalityAggregationData",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 100\nCount of distinct values of a log field",
                    "title": "count",
                    "format": "uint64"
                },
                "trend_value": {
                    "description": "x-displayName: \"Trend Value\"\ntrend value for the cardinality aggregation field.",
                    "title": "Trend value",
                    "$ref": "#/definitions/schemaTrendValue"
                }
            }
        },
        "logDateAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation Bucket\"\nDate histogram bucket containing the timestamp and the number of logs in that bucket.",
            "title": "DateAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nSub aggregation data for the date bucket",
                    "title": "sub aggregation"
                },
                "time": {
                    "type": "string",
                    "description": "x-displayName: \"Time\"\nx-example: 1578710280000\n\nunix timestamp",
                    "title": "time",
                    "format": "uint64"
                },
                "trend_value": {
                    "description": "x-displayName: \"Trend Value\"\ntrend value for the key present in the date aggregation bucket",
                    "title": "Trend value",
                    "$ref": "#/definitions/schemaTrendValue"
                }
            }
        },
        "logDateAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation Data\"\nDate aggregation data",
            "title": "DateAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing timestamp and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logDateAggregationBucket"
                    }
                },
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-example: \"30m\"\nActual step size in the response. It could be higher than the requested step depending on the query duration and/or the log rollups.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                }
            }
        },
        "logDateSubAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Date SubAggregation\"\n\nDate subaggregation data",
            "title": "DateSubAggregationData",
            "properties": {
                "field_aggregation": {
                    "description": "Field aggregation data",
                    "title": "field aggregation\nx-displayName: \"Field Aggregation\"",
                    "$ref": "#/definitions/logFieldAggregationData"
                },
                "multi_field_aggregation": {
                    "description": "Field aggregation data",
                    "title": "mulifield aggregation\nx-displayName: \"Multi Field Aggregation\"",
                    "$ref": "#/definitions/logMultiFieldAggregationData"
                }
            }
        },
        "logFieldAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation Bucket\"\nField aggregation bucket containing field value and the number of logs.",
            "title": "FieldAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "key": {
                    "type": "string",
                    "description": "x-displayName: \"Key\"\nx-example: \"US\"",
                    "title": "key"
                },
                "order_by": {
                    "description": "x-displayName: \"Order by\"\nOrder by data for the metrics field aggregation bucket",
                    "title": "Order by",
                    "$ref": "#/definitions/logOrderByData"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nSub aggregation data for the field aggregation bucket",
                    "title": "sub aggregation"
                },
                "trend_value": {
                    "description": "x-displayName: \"Trend Value\"\ntrend value for the keys present in the field aggregation bucket",
                    "title": "Trend value",
                    "$ref": "#/definitions/schemaTrendValue"
                }
            }
        },
        "logFieldAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation Data\"\nField Aggregation data",
            "title": "FieldAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing field value and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logFieldAggregationBucket"
                    }
                }
            }
        },
        "logFieldSubAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Field SubAggregation\"\nField subaggregation data",
            "title": "FieldSubAggregationData",
            "properties": {
                "cardinality_aggregation": {
                    "description": "cardinality aggregation data",
                    "title": "cardinality aggregation\nx-displayName: \"Cardinality Aggregation\"",
                    "$ref": "#/definitions/logCardinalityAggregationData"
                }
            }
        },
        "logLogAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Log Aggregation\"\nLog aggregation response data",
            "title": "LogAggregationData",
            "properties": {
                "cardinality_aggregation": {
                    "description": "Cardinality aggregation data",
                    "title": "cardinality aggregation\nx-displayName: \"Cardinality Aggregation\"",
                    "$ref": "#/definitions/logCardinalityAggregationData"
                },
                "date_aggregation": {
                    "description": "Date aggregation data",
                    "title": "date aggregation\nx-displayName: \"Date Aggregation\"",
                    "$ref": "#/definitions/logDateAggregationData"
                },
                "field_aggregation": {
                    "description": "Field aggregation data",
                    "title": "field aggregation\nx-displayName: \"Field Aggregation\"",
                    "$ref": "#/definitions/logFieldAggregationData"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nMetrics aggregation data",
                    "title": "metrics Aggregation",
                    "$ref": "#/definitions/logMetricsAggregationData"
                },
                "multi_field_aggregation": {
                    "description": "Multi-Field aggregation data",
                    "title": "multi-field aggregation\nx-displayName: \"Multi-Field Aggregation\"",
                    "$ref": "#/definitions/logMultiFieldAggregationData"
                }
            }
        },
        "logMetricsAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Metrics Aggregation\"\nMetrics aggregation data",
            "title": "MetricsAggregationData",
            "properties": {
                "percentile": {
                    "description": "percentile aggregation data",
                    "title": "percentile aggregation\nx-displayName: \"Percentile Aggregation\"",
                    "$ref": "#/definitions/logPercentileAggregationData"
                }
            }
        },
        "logMultiFieldAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Multi-Field Aggregation Bucket\"\nMulti-Field aggregation bucket containing field values and the number of logs.",
            "title": "MultiFieldAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "keys": {
                    "type": "object",
                    "description": "x-displayName: \"Keys\"\nKeys contain the name/value pair that identifies the unique combination of multiple key fields\nx-example: \"{\"SRC_IP\": \"10.10.10.1\", \"COUNTRY\": \"US\"}\"",
                    "title": "keys"
                },
                "order_by": {
                    "description": "x-displayName: \"Order by\"\nOrder by data for the metrics field aggregation bucket",
                    "title": "Order by",
                    "$ref": "#/definitions/logOrderByData"
                }
            }
        },
        "logMultiFieldAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Multi-Field Aggregation Data\"\nMulti-Field Aggregation data",
            "title": "MultiFieldAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing field values and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logMultiFieldAggregationBucket"
                    }
                }
            }
        },
        "logOrderByData": {
            "type": "object",
            "description": "x-displayName: \"Order by Data\"\nOrder by data",
            "title": "OrderByData",
            "properties": {
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nMetrics aggregation data",
                    "title": "metrics Aggregation",
                    "$ref": "#/definitions/logMetricsAggregationData"
                }
            }
        },
        "logPercentileAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Percentile Aggregation Data\"\nPercentile Aggregation data",
            "title": "PercentileAggregationData",
            "properties": {
                "key": {
                    "type": "number",
                    "description": "x-displayName: \"Key\"\nx-example: 99.0",
                    "title": "key",
                    "format": "double"
                },
                "value": {
                    "type": "number",
                    "description": "x-displayName: \"Value\"\nx-example: 985.0\n\nvalue corresponding to the key percent",
                    "title": "value",
                    "format": "double"
                }
            }
        },
        "protobufAny": {
            "type": "object",
            "description": "-Any- contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an -Any- value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field -@type- which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n-value- which holds the custom JSON in addition to the -@type-\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
            "properties": {
                "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n-path/google.protobuf.Duration-). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme -http-, -https-, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, -https- is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than -http-, -https- (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                }
            }
        },
        "schemaErrorCode": {
            "type": "string",
            "description": "Union of all possible error-codes from system\n\n - EOK: No error\n - EPERMS: Permissions error\n - EBADINPUT: Input is not correct\n - ENOTFOUND: Not found\n - EEXISTS: Already exists\n - EUNKNOWN: Unknown/catchall error\n - ESERIALIZE: Error in serializing/de-serializing\n - EINTERNAL: Server error\n - EPARTIAL: Partial error",
            "title": "ErrorCode",
            "enum": [
                "EOK",
                "EPERMS",
                "EBADINPUT",
                "ENOTFOUND",
                "EEXISTS",
                "EUNKNOWN",
                "ESERIALIZE",
                "EINTERNAL",
                "EPARTIAL"
            ],
            "default": "EOK",
            "x-displayname": "Error Code",
            "x-ves-proto-enum": "ves.io.schema.ErrorCode"
        },
        "schemaErrorType": {
            "type": "object",
            "description": "Information about a error in API operation",
            "title": "ErrorType",
            "x-displayname": "Error Type",
            "x-ves-proto-message": "ves.io.schema.ErrorType",
            "properties": {
                "code": {
                    "description": " A simple general code by category",
                    "title": "code",
                    "$ref": "#/definitions/schemaErrorCode",
                    "x-displayname": "Code"
                },
                "error_obj": {
                    "description": " A structured error object for machine parsing",
                    "title": "error_obj",
                    "$ref": "#/definitions/protobufAny",
                    "x-displayname": "Error Object"
                },
                "message": {
                    "type": "string",
                    "description": " A human readable string of the error\n\nExample: - \"value\"-",
                    "title": "message",
                    "x-displayname": "Message",
                    "x-ves-example": "value"
                }
            }
        },
        "schemaSortOrder": {
            "type": "string",
            "description": "Sort algorithm\n\nSort in descending order\nSort in ascending order",
            "title": "SortOrder",
            "enum": [
                "DESCENDING",
                "ASCENDING"
            ],
            "default": "DESCENDING",
            "x-displayname": "Sort Order",
            "x-ves-proto-enum": "ves.io.schema.SortOrder"
        },
        "schemaTrendSentiment": {
            "type": "string",
            "description": "x-displayName: \"Trend Sentiment\"\ntrend sentiment\n\n - TREND_SENTIMENT_NONE: x-displayName: \"None\"\n - TREND_SENTIMENT_POSITIVE: x-displayName: \"Positive\"\nIndicates trend sentiment is positive\n - TREND_SENTIMENT_NEGATIVE: x-displayName: \"Negative\"\nIndicates trend sentiment is negative.",
            "title": "Trend Sentiment",
            "enum": [
                "TREND_SENTIMENT_NONE",
                "TREND_SENTIMENT_POSITIVE",
                "TREND_SENTIMENT_NEGATIVE"
            ],
            "default": "TREND_SENTIMENT_NONE"
        },
        "schemaTrendValue": {
            "type": "object",
            "description": "x-displayName: \"Trend Value\"\nTrend value contains trend value, trend sentiment and trend calculation description and window size.",
            "title": "Trend Value",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "x-displayName: \"Description\"\nx-example: \"Trend was calculated by comparing the avg of window size intervals of end-start Time and last window time interval\"\ndescription of the method used to calculate trend.",
                    "title": "Description"
                },
                "previous_value": {
                    "type": "string",
                    "description": "x-displayName: \"Previous Value\"\nx-example: \"200.00\"",
                    "title": "Previous Value"
                },
                "sentiment": {
                    "description": "x-displayName: \"Sentiment\"\nx-example: \"Positive\"",
                    "title": "Sentiment",
                    "$ref": "#/definitions/schemaTrendSentiment"
                },
                "value": {
                    "type": "string",
                    "description": "x-displayName: \"Value\"\nx-example: \"-15\"",
                    "title": "Value"
                }
            }
        }
    },
    "x-displayname": "CDN Loadbalancer",
    "x-ves-proto-file": "ves.io/schema/views/cdn_loadbalancer/public_customapi.proto"
}`
