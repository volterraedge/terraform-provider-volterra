// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/cdn_loadbalancer/public_customapi.proto

// CDN
//
// x-displayName: "CDN Loadbalancer"
// CDN package

package cdn_loadbalancer

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/dos_mitigation"
	log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log/access_log"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	access_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/cdn_loadbalancer/access_log"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/common_security"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/common_waf"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Metrics Operator Types
//
// x-displayName: "Metrics Operator Types"
// Operators possible in filtering
type CDNAccessLogOperatorType int32

const (
	// x-displayName: " IN Operator"
	CDN_ACCESS_LOG_OPERATOR_TYPE_IN CDNAccessLogOperatorType = 0
	// x-displayName: " Not-IN Operator"
	CDN_ACCESS_LOG_OPERATOR_TYPE_NOT_IN CDNAccessLogOperatorType = 1
)

var CDNAccessLogOperatorType_name = map[int32]string{
	0: "CDN_ACCESS_LOG_OPERATOR_TYPE_IN",
	1: "CDN_ACCESS_LOG_OPERATOR_TYPE_NOT_IN",
}

var CDNAccessLogOperatorType_value = map[string]int32{
	"CDN_ACCESS_LOG_OPERATOR_TYPE_IN":     0,
	"CDN_ACCESS_LOG_OPERATOR_TYPE_NOT_IN": 1,
}

func (CDNAccessLogOperatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{0}
}

// CDN access logs data item
//
// x-displayName: "CDN Access log data item"
// CDN Access-Log item
type LilacCDNAccessLogsResponseData struct {
	// Timestamp
	//
	// x-displayName: "Timestamp of the access log"
	// x-example: "2022-10-21T01:05:32.713Z"
	// x-required
	// Format: unix_timestamp|rfc 3339
	Timestamp string `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Client port
	//
	// x-displayName: "Client Port"
	// x-example: "50756"
	// Client Port
	ClientPort string `protobuf:"bytes,4,opt,name=client_port,json=clientPort,proto3" json:"client_port,omitempty"`
	// Host
	//
	// x-displayName: "Name of the Host"
	// x-example: "edge-node-1-85955f9c64-jqw7j"
	// Host Name of the node where the log was captured
	Host string `protobuf:"bytes,5,opt,name=host,proto3" json:"host,omitempty"`
	// User name
	//
	// x-displayName: "Name of the User"
	// x-example: ""
	// Name of the user
	User string `protobuf:"bytes,6,opt,name=user,proto3" json:"user,omitempty"`
	// HTTP request scheme
	//
	// x-displayName: "HTTP request scheme"
	// x-example: "https"
	// HTTP request scheme
	Scheme string `protobuf:"bytes,7,opt,name=scheme,proto3" json:"scheme,omitempty"`
	// HTTP Method Name
	//
	// x-displayName: "HTTP Method Name"
	// x-example: "get"
	// HTTP Method Name
	Method string `protobuf:"bytes,8,opt,name=method,proto3" json:"method,omitempty"`
	// HTTP referer
	//
	// x-displayName: "HTTP referer"
	// x-example: "https://example.com/"
	// HTTP referer
	Referer string `protobuf:"bytes,12,opt,name=referer,proto3" json:"referer,omitempty"`
	// CDN Cache Status
	//
	// x-displayName: "CDN Cache Status"
	// x-example: "MISS"
	// CDN Cache Status
	CacheStatus string `protobuf:"bytes,16,opt,name=cache_status,json=cacheStatus,proto3" json:"cache_status,omitempty"`
	// Time taken by the request
	//
	// x-displayName: "Time taken by the request"
	// x-example: "0.0"
	// Time taken by the request
	RequestTime string `protobuf:"bytes,17,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	// Upstream Address
	//
	// x-displayName: "Upstream Address"
	// x-example: ""
	// Upstream Address
	UpstreamAddr string `protobuf:"bytes,18,opt,name=upstream_addr,json=upstreamAddr,proto3" json:"upstream_addr,omitempty"`
	// Upstream Connect Time
	//
	// x-displayName: "Upstream Connect Time"
	// x-example: ""
	// Upstream Connect Time
	UpstreamConnectTime string `protobuf:"bytes,19,opt,name=upstream_connect_time,json=upstreamConnectTime,proto3" json:"upstream_connect_time,omitempty"`
	// Upstream Response Time
	//
	// x-displayName: "Upstream Response Time"
	// x-example: "nginx.data.fr-edge1-0"
	// Upstream Response Time
	UpstreamResponseTime string `protobuf:"bytes,20,opt,name=upstream_response_time,json=upstreamResponseTime,proto3" json:"upstream_response_time,omitempty"`
	// Upstream Status
	//
	// x-displayName: "Upstream Status"
	// x-example: "nginx.data.fr-edge1-0"
	// Upstream Status
	UpstreamStatus string `protobuf:"bytes,21,opt,name=upstream_status,json=upstreamStatus,proto3" json:"upstream_status,omitempty"`
	// Geo Location of the request
	//
	// x-displayName: "Geo Location of the request"
	// x-example: ""
	// Geo Location of the request
	GeoLocation string `protobuf:"bytes,22,opt,name=geo_location,json=geoLocation,proto3" json:"geo_location,omitempty"`
	// Geo City Id
	//
	// x-displayName: "Geo City Id"
	// x-example: "3109256"
	// Geo City Id [maxmind]
	CityId string `protobuf:"bytes,24,opt,name=city_id,json=cityId,proto3" json:"city_id,omitempty"`
	// HTTP Version of the request
	//
	// x-displayName: "HTTP Version of the request"
	// x-example: "HTTP/1.1"
	// HTTP Version of the request
	HttpVersion string `protobuf:"bytes,26,opt,name=http_version,json=httpVersion,proto3" json:"http_version,omitempty"`
	// HTTP Response Size
	//
	// x-displayName: "HTTP Response Size"
	// x-example: "600"
	// HTTP Response Size
	RspSize uint64 `protobuf:"varint,28,opt,name=rsp_size,json=rspSize,proto3" json:"rsp_size,omitempty"`
	// Source IP address
	//
	// x-displayName: "IP address of the client from where the request came from "
	// x-example: "1.2.3.4"
	// Source IP address
	SrcIp string `protobuf:"bytes,29,opt,name=src_ip,json=srcIp,proto3" json:"src_ip,omitempty"`
	// HTTP request path
	//
	// x-displayName: "HTTP request path"
	// x-example: "/index.html"
	// HTTP request path
	ReqPath string `protobuf:"bytes,30,opt,name=req_path,json=reqPath,proto3" json:"req_path,omitempty"`
	// HTTP Response Code
	//
	// x-displayName: "HTTP Response Code"
	// x-example: "200"
	// HTTP Response Code
	RspCode string `protobuf:"bytes,31,opt,name=rsp_code,json=rspCode,proto3" json:"rsp_code,omitempty"`
	// HTTP User Agent
	//
	// x-displayName: "HTTP User Agent"
	// x-example: "Mozilla/5.0"
	// HTTP User Agent
	UserAgent string `protobuf:"bytes,32,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
	// Content-Type of the request
	//
	// x-displayName: "Content-Type of the request"
	// x-example: "text/html"
	// Content-Type of the request
	ReqContentType string `protobuf:"bytes,33,opt,name=req_content_type,json=reqContentType,proto3" json:"req_content_type,omitempty"`
	// Content-Type of the response
	//
	// x-displayName: "Content-Type of the response"
	// x-example: "text/html"
	// Content-Type of the response
	RspContentType string `protobuf:"bytes,34,opt,name=rsp_content_type,json=rspContentType,proto3" json:"rsp_content_type,omitempty"`
	// Geo Country Code of the request
	//
	// x-displayName: "Geo Country Code of the request"
	// x-example: ""
	// Geo Country Code of the request
	Country string `protobuf:"bytes,35,opt,name=country,proto3" json:"country,omitempty"`
	// Geo City Name
	//
	// x-displayName: "Geo City Name"
	// x-example: "Segovia"
	// Geo City Name
	CityName string `protobuf:"bytes,36,opt,name=city_name,json=cityName,proto3" json:"city_name,omitempty"`
	// HTTP Request Size
	//
	// x-displayName: "HTTP Request Size"
	// x-example: "
	// HTTP Request Size
	ReqSize uint64 `protobuf:"varint,37,opt,name=req_size,json=reqSize,proto3" json:"req_size,omitempty"`
	// HTTP Response Code Class
	//
	// x-displayName: "HTTP Response Code Class"
	// x-example: "2xx"
	// HTTP Response Code Class
	RspCodeClass string `protobuf:"bytes,38,opt,name=rsp_code_class,json=rspCodeClass,proto3" json:"rsp_code_class,omitempty"`
	// Host Header
	//
	// x-displayName: "HTTP Host Header Value"
	// x-example: "www.f5.com"
	// HTTP Host Header
	HostHeader string `protobuf:"bytes,39,opt,name=host_header,json=hostHeader,proto3" json:"host_header,omitempty"`
	// TLS Version
	//
	// x-displayName: "TLS Version Value"
	// x-example: "TLSv1.3"
	// TLS Version Value
	TlsVersion string `protobuf:"bytes,40,opt,name=tls_version,json=tlsVersion,proto3" json:"tls_version,omitempty"`
	// Service Name Indication
	//
	// x-displayName: "TLS Service Name Indication Value"
	// x-example: "www.f5.com"
	// TLS Service Name Indication
	TlsSni string `protobuf:"bytes,41,opt,name=tls_sni,json=tlsSni,proto3" json:"tls_sni,omitempty"`
	// CDN Name
	//
	// x-displayName: "Name of the CDN Distribution"
	// x-example: "my-website"
	// Name of the CDN distribution
	CdnName string `protobuf:"bytes,42,opt,name=cdn_name,json=cdnName,proto3" json:"cdn_name,omitempty"`
	// Site Name
	//
	// x-displayName: "Name of the Site"
	// x-example: "pa4-par-cdn"
	// Name of the Site
	SiteName string `protobuf:"bytes,43,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
}

func (m *LilacCDNAccessLogsResponseData) Reset()      { *m = LilacCDNAccessLogsResponseData{} }
func (*LilacCDNAccessLogsResponseData) ProtoMessage() {}
func (*LilacCDNAccessLogsResponseData) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{0}
}
func (m *LilacCDNAccessLogsResponseData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNAccessLogsResponseData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LilacCDNAccessLogsResponseData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LilacCDNAccessLogsResponseData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNAccessLogsResponseData.Merge(m, src)
}
func (m *LilacCDNAccessLogsResponseData) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNAccessLogsResponseData) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNAccessLogsResponseData.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNAccessLogsResponseData proto.InternalMessageInfo

func (m *LilacCDNAccessLogsResponseData) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetClientPort() string {
	if m != nil {
		return m.ClientPort
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetReferer() string {
	if m != nil {
		return m.Referer
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetCacheStatus() string {
	if m != nil {
		return m.CacheStatus
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetRequestTime() string {
	if m != nil {
		return m.RequestTime
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetUpstreamAddr() string {
	if m != nil {
		return m.UpstreamAddr
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetUpstreamConnectTime() string {
	if m != nil {
		return m.UpstreamConnectTime
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetUpstreamResponseTime() string {
	if m != nil {
		return m.UpstreamResponseTime
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetUpstreamStatus() string {
	if m != nil {
		return m.UpstreamStatus
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetGeoLocation() string {
	if m != nil {
		return m.GeoLocation
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetCityId() string {
	if m != nil {
		return m.CityId
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetHttpVersion() string {
	if m != nil {
		return m.HttpVersion
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetRspSize() uint64 {
	if m != nil {
		return m.RspSize
	}
	return 0
}

func (m *LilacCDNAccessLogsResponseData) GetSrcIp() string {
	if m != nil {
		return m.SrcIp
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetReqPath() string {
	if m != nil {
		return m.ReqPath
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetRspCode() string {
	if m != nil {
		return m.RspCode
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetReqContentType() string {
	if m != nil {
		return m.ReqContentType
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetRspContentType() string {
	if m != nil {
		return m.RspContentType
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetCityName() string {
	if m != nil {
		return m.CityName
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetReqSize() uint64 {
	if m != nil {
		return m.ReqSize
	}
	return 0
}

func (m *LilacCDNAccessLogsResponseData) GetRspCodeClass() string {
	if m != nil {
		return m.RspCodeClass
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetHostHeader() string {
	if m != nil {
		return m.HostHeader
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetTlsVersion() string {
	if m != nil {
		return m.TlsVersion
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetTlsSni() string {
	if m != nil {
		return m.TlsSni
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetCdnName() string {
	if m != nil {
		return m.CdnName
	}
	return ""
}

func (m *LilacCDNAccessLogsResponseData) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

// CDNLogResponse
//
// x-displayName: "CDN Log Response"
// Response message for AccessLogRequest
type CDNLogResponse struct {
	// logs
	//
	// x-displayName: "Logs"
	// x-example: "value"
	// list of log messages that matched the query. Not all log messages that matched the query are returned in the response.
	Logs []*LilacCDNAccessLogsResponseData `protobuf:"bytes,1,rep,name=logs,proto3" json:"logs,omitempty"`
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "0"
	// total number of log messages that matched the query.
	TotalHits uint64 `protobuf:"varint,3,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregation data is key'ed with the aggregation name specified in the request.
	Aggs map[string]*log.LogAggregationData `protobuf:"bytes,5,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CDNLogResponse) Reset()      { *m = CDNLogResponse{} }
func (*CDNLogResponse) ProtoMessage() {}
func (*CDNLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{1}
}
func (m *CDNLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNLogResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNLogResponse.Merge(m, src)
}
func (m *CDNLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *CDNLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CDNLogResponse proto.InternalMessageInfo

func (m *CDNLogResponse) GetLogs() []*LilacCDNAccessLogsResponseData {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *CDNLogResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *CDNLogResponse) GetAggs() map[string]*log.LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// CDNAccessLogRequest
//
// x-displayName: "CDN Access Log Request"
// Request to fetch access logs.
type CDNAccessLogRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// fetch access logs for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Access Logs Filter options
	//
	// x-displayName: "Access Logs Filter"
	// CDN Access Logs filter options
	Query []*CDNAccessLogFilter `protobuf:"bytes,2,rep,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch access logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch access logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// specifies whether the response should be sorted in ascending or descending order based on timestamp in the log
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,5,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "0"
	// limits the number of logs returned in the response
	// Optional: If not specified, first or last 500 log messages that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit uint32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*CDNAggregationRequest `protobuf:"bytes,7,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CDNAccessLogRequest) Reset()      { *m = CDNAccessLogRequest{} }
func (*CDNAccessLogRequest) ProtoMessage() {}
func (*CDNAccessLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{2}
}
func (m *CDNAccessLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNAccessLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNAccessLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNAccessLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNAccessLogRequest.Merge(m, src)
}
func (m *CDNAccessLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *CDNAccessLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNAccessLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CDNAccessLogRequest proto.InternalMessageInfo

func (m *CDNAccessLogRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CDNAccessLogRequest) GetQuery() []*CDNAccessLogFilter {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *CDNAccessLogRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *CDNAccessLogRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *CDNAccessLogRequest) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *CDNAccessLogRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *CDNAccessLogRequest) GetAggs() map[string]*CDNAggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// CDNLogAggregationResponse
//
// x-displayName: "CDN Log Aggregation Response"
// Response message for CDNAccessLogAggregationRequest
type CDNLogAggregationResponse struct {
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "0"
	// total number of log messages that matched the query.
	TotalHits uint64 `protobuf:"varint,1,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregation data is key'ed with the aggregation name specified in the request.
	Aggs map[string]*log.LogAggregationData `protobuf:"bytes,2,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CDNLogAggregationResponse) Reset()      { *m = CDNLogAggregationResponse{} }
func (*CDNLogAggregationResponse) ProtoMessage() {}
func (*CDNLogAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{3}
}
func (m *CDNLogAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNLogAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNLogAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNLogAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNLogAggregationResponse.Merge(m, src)
}
func (m *CDNLogAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *CDNLogAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNLogAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CDNLogAggregationResponse proto.InternalMessageInfo

func (m *CDNLogAggregationResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *CDNLogAggregationResponse) GetAggs() map[string]*log.LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// CDNAccessLogAggregationRequest
//
// x-displayName: "CDN Access Log Aggregation Request"
// Request to get only aggregation data for access logs
type CDNAccessLogAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "value"
	// get aggregation data for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Access Logs Filter options
	//
	// x-displayName: "Access Logs Filter"
	// CDN Access Logs filter options
	Query []*CDNAccessLogFilter `protobuf:"bytes,2,rep,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// fetch access logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "2019-09-24T12:30:11.733Z"
	// fetch access logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the log response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*CDNAggregationRequest `protobuf:"bytes,5,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CDNAccessLogAggregationRequest) Reset()      { *m = CDNAccessLogAggregationRequest{} }
func (*CDNAccessLogAggregationRequest) ProtoMessage() {}
func (*CDNAccessLogAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{4}
}
func (m *CDNAccessLogAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNAccessLogAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNAccessLogAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNAccessLogAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNAccessLogAggregationRequest.Merge(m, src)
}
func (m *CDNAccessLogAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *CDNAccessLogAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNAccessLogAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CDNAccessLogAggregationRequest proto.InternalMessageInfo

func (m *CDNAccessLogAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CDNAccessLogAggregationRequest) GetQuery() []*CDNAccessLogFilter {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *CDNAccessLogAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *CDNAccessLogAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *CDNAccessLogAggregationRequest) GetAggs() map[string]*CDNAggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// CDN Aggregation Request
//
// x-displayName: "CDN Lodbalancer Aggregation Request"
// Aggregation request for CDN Loadbalancer, to provide analytics data over the log response
type CDNAggregationRequest struct {
	// aggregation type
	//
	// x-displayName: "Aggregation Type"
	// Specify one of the aggregation types
	//
	// Types that are valid to be assigned to AggregationType:
	//	*CDNAggregationRequest_DateAggregation
	//	*CDNAggregationRequest_FieldAggregation
	AggregationType isCDNAggregationRequest_AggregationType `protobuf_oneof:"aggregation_type"`
}

func (m *CDNAggregationRequest) Reset()      { *m = CDNAggregationRequest{} }
func (*CDNAggregationRequest) ProtoMessage() {}
func (*CDNAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{5}
}
func (m *CDNAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNAggregationRequest.Merge(m, src)
}
func (m *CDNAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *CDNAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CDNAggregationRequest proto.InternalMessageInfo

type isCDNAggregationRequest_AggregationType interface {
	isCDNAggregationRequest_AggregationType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CDNAggregationRequest_DateAggregation struct {
	DateAggregation *CDNDateAggregation `protobuf:"bytes,2,opt,name=date_aggregation,json=dateAggregation,proto3,oneof" json:"date_aggregation,omitempty"`
}
type CDNAggregationRequest_FieldAggregation struct {
	FieldAggregation *CDNFieldAggregation `protobuf:"bytes,3,opt,name=field_aggregation,json=fieldAggregation,proto3,oneof" json:"field_aggregation,omitempty"`
}

func (*CDNAggregationRequest_DateAggregation) isCDNAggregationRequest_AggregationType()  {}
func (*CDNAggregationRequest_FieldAggregation) isCDNAggregationRequest_AggregationType() {}

func (m *CDNAggregationRequest) GetAggregationType() isCDNAggregationRequest_AggregationType {
	if m != nil {
		return m.AggregationType
	}
	return nil
}

func (m *CDNAggregationRequest) GetDateAggregation() *CDNDateAggregation {
	if x, ok := m.GetAggregationType().(*CDNAggregationRequest_DateAggregation); ok {
		return x.DateAggregation
	}
	return nil
}

func (m *CDNAggregationRequest) GetFieldAggregation() *CDNFieldAggregation {
	if x, ok := m.GetAggregationType().(*CDNAggregationRequest_FieldAggregation); ok {
		return x.FieldAggregation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CDNAggregationRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CDNAggregationRequest_DateAggregation)(nil),
		(*CDNAggregationRequest_FieldAggregation)(nil),
	}
}

// CDN Date SubAggregation
//
// x-displayName: "Date SubAggregation"
// Aggregate access logs in each date bucket based on one of the sub aggregation types
type CDNDateSubAggregation struct {
	// aggregation type
	//
	// x-displayName: "Aggregation Type"
	// Specify one of the aggregation types
	//
	// Types that are valid to be assigned to AggregationType:
	//	*CDNDateSubAggregation_FieldAggregation
	AggregationType isCDNDateSubAggregation_AggregationType `protobuf_oneof:"aggregation_type"`
}

func (m *CDNDateSubAggregation) Reset()      { *m = CDNDateSubAggregation{} }
func (*CDNDateSubAggregation) ProtoMessage() {}
func (*CDNDateSubAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{6}
}
func (m *CDNDateSubAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNDateSubAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNDateSubAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNDateSubAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNDateSubAggregation.Merge(m, src)
}
func (m *CDNDateSubAggregation) XXX_Size() int {
	return m.Size()
}
func (m *CDNDateSubAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNDateSubAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_CDNDateSubAggregation proto.InternalMessageInfo

type isCDNDateSubAggregation_AggregationType interface {
	isCDNDateSubAggregation_AggregationType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CDNDateSubAggregation_FieldAggregation struct {
	FieldAggregation *CDNFieldAggregation `protobuf:"bytes,1,opt,name=field_aggregation,json=fieldAggregation,proto3,oneof" json:"field_aggregation,omitempty"`
}

func (*CDNDateSubAggregation_FieldAggregation) isCDNDateSubAggregation_AggregationType() {}

func (m *CDNDateSubAggregation) GetAggregationType() isCDNDateSubAggregation_AggregationType {
	if m != nil {
		return m.AggregationType
	}
	return nil
}

func (m *CDNDateSubAggregation) GetFieldAggregation() *CDNFieldAggregation {
	if x, ok := m.GetAggregationType().(*CDNDateSubAggregation_FieldAggregation); ok {
		return x.FieldAggregation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CDNDateSubAggregation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CDNDateSubAggregation_FieldAggregation)(nil),
	}
}

// Date Aggregation
//
// x-displayName: "Date Aggregation"
// Aggregate access logs based on timestamp in the log
type CDNDateAggregation struct {
	// step
	//
	// x-displayName: "Step"
	// x-required
	// x-example: "5m"
	//
	// step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.
	// The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn <= end_time.
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	Step string `protobuf:"bytes,1,opt,name=step,proto3" json:"step,omitempty"`
	// sub aggregation
	//
	// x-displayName: "Sub Aggregation"
	// This option provides sub-aggregation for each date bucket
	SubAggs map[string]*CDNDateSubAggregation `protobuf:"bytes,2,rep,name=sub_aggs,json=subAggs,proto3" json:"sub_aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CDNDateAggregation) Reset()      { *m = CDNDateAggregation{} }
func (*CDNDateAggregation) ProtoMessage() {}
func (*CDNDateAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{7}
}
func (m *CDNDateAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNDateAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNDateAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNDateAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNDateAggregation.Merge(m, src)
}
func (m *CDNDateAggregation) XXX_Size() int {
	return m.Size()
}
func (m *CDNDateAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNDateAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_CDNDateAggregation proto.InternalMessageInfo

func (m *CDNDateAggregation) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

func (m *CDNDateAggregation) GetSubAggs() map[string]*CDNDateSubAggregation {
	if m != nil {
		return m.SubAggs
	}
	return nil
}

// Field Aggregation
//
// x-displayName: "Field Aggregation"
// Aggregate access logs based on the key fields in the log.
type CDNFieldAggregation struct {
	// field
	//
	// x-displayName: "Field"
	// x-required
	//
	// Field name by which the logs should be aggregated.
	Field access_log.CDNAccessLogTag `protobuf:"varint,1,opt,name=field,proto3,enum=ves.io.schema.views.cdn_loadbalancer.access_log.CDNAccessLogTag" json:"field,omitempty"`
	// topk
	//
	// x-displayName: "TopK"
	// x-example: "5"
	// Number of top field values to be returned in the response.
	// Optional: If not specified, top 5 values will be returned in the response.
	Topk uint32 `protobuf:"varint,2,opt,name=topk,proto3" json:"topk,omitempty"`
	// sub aggregation
	//
	// x-displayName: "Sub Aggregation"
	// This option provides sub-aggregation for each field bucket
	// The key holds the value of sub-aggregations
	SubAggs map[string]*CDNFieldSubAggregation `protobuf:"bytes,3,rep,name=sub_aggs,json=subAggs,proto3" json:"sub_aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CDNFieldAggregation) Reset()      { *m = CDNFieldAggregation{} }
func (*CDNFieldAggregation) ProtoMessage() {}
func (*CDNFieldAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{8}
}
func (m *CDNFieldAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNFieldAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNFieldAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNFieldAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNFieldAggregation.Merge(m, src)
}
func (m *CDNFieldAggregation) XXX_Size() int {
	return m.Size()
}
func (m *CDNFieldAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNFieldAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_CDNFieldAggregation proto.InternalMessageInfo

func (m *CDNFieldAggregation) GetField() access_log.CDNAccessLogTag {
	if m != nil {
		return m.Field
	}
	return access_log.CDN_NAME
}

func (m *CDNFieldAggregation) GetTopk() uint32 {
	if m != nil {
		return m.Topk
	}
	return 0
}

func (m *CDNFieldAggregation) GetSubAggs() map[string]*CDNFieldSubAggregation {
	if m != nil {
		return m.SubAggs
	}
	return nil
}

// CDN Fiels SubAggregation
//
// x-displayName: "CDN Field SubAggregation"
// Aggregate access logs in each field bucket based on one of the sub aggregation types
type CDNFieldSubAggregation struct {
	// aggregation type
	//
	// x-displayName: "Aggregation Type"
	// Specify one of the aggregation types
	//
	// Types that are valid to be assigned to AggregationType:
	//	*CDNFieldSubAggregation_FieldAggregation
	AggregationType isCDNFieldSubAggregation_AggregationType `protobuf_oneof:"aggregation_type"`
}

func (m *CDNFieldSubAggregation) Reset()      { *m = CDNFieldSubAggregation{} }
func (*CDNFieldSubAggregation) ProtoMessage() {}
func (*CDNFieldSubAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{9}
}
func (m *CDNFieldSubAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNFieldSubAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNFieldSubAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNFieldSubAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNFieldSubAggregation.Merge(m, src)
}
func (m *CDNFieldSubAggregation) XXX_Size() int {
	return m.Size()
}
func (m *CDNFieldSubAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNFieldSubAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_CDNFieldSubAggregation proto.InternalMessageInfo

type isCDNFieldSubAggregation_AggregationType interface {
	isCDNFieldSubAggregation_AggregationType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CDNFieldSubAggregation_FieldAggregation struct {
	FieldAggregation *FieldAggregation `protobuf:"bytes,1,opt,name=field_aggregation,json=fieldAggregation,proto3,oneof" json:"field_aggregation,omitempty"`
}

func (*CDNFieldSubAggregation_FieldAggregation) isCDNFieldSubAggregation_AggregationType() {}

func (m *CDNFieldSubAggregation) GetAggregationType() isCDNFieldSubAggregation_AggregationType {
	if m != nil {
		return m.AggregationType
	}
	return nil
}

func (m *CDNFieldSubAggregation) GetFieldAggregation() *FieldAggregation {
	if x, ok := m.GetAggregationType().(*CDNFieldSubAggregation_FieldAggregation); ok {
		return x.FieldAggregation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CDNFieldSubAggregation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CDNFieldSubAggregation_FieldAggregation)(nil),
	}
}

// Field Aggregation
//
// x-displayName: "Field Aggregation"
// Aggregate access logs based on the key fields in the log.
type FieldAggregation struct {
	// field
	//
	// x-displayName: "Field"
	// x-required
	//
	// Field name by which the logs should be aggregated.
	Field access_log.CDNAccessLogTag `protobuf:"varint,1,opt,name=field,proto3,enum=ves.io.schema.views.cdn_loadbalancer.access_log.CDNAccessLogTag" json:"field,omitempty"`
	// topk
	//
	// x-displayName: "TopK"
	// x-example: "5"
	// Number of top field values to be returned in the response.
	// Optional: If not specified, top 5 values will be returned in the response.
	Topk uint32 `protobuf:"varint,2,opt,name=topk,proto3" json:"topk,omitempty"`
}

func (m *FieldAggregation) Reset()      { *m = FieldAggregation{} }
func (*FieldAggregation) ProtoMessage() {}
func (*FieldAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{10}
}
func (m *FieldAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldAggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldAggregation.Merge(m, src)
}
func (m *FieldAggregation) XXX_Size() int {
	return m.Size()
}
func (m *FieldAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_FieldAggregation proto.InternalMessageInfo

func (m *FieldAggregation) GetField() access_log.CDNAccessLogTag {
	if m != nil {
		return m.Field
	}
	return access_log.CDN_NAME
}

func (m *FieldAggregation) GetTopk() uint32 {
	if m != nil {
		return m.Topk
	}
	return 0
}

// Access Log filter fields
//
// x-displayName: "CDN Access log Filter"
// CDN Access log filter options
type CDNAccessLogFilter struct {
	// Access Log Filter Tag options
	//
	// x-displayName: "Filter Tags"
	// x-required
	// Tags on which CDN Access Log can be filtered by
	Tag access_log.CDNAccessLogTag `protobuf:"varint,1,opt,name=tag,proto3,enum=ves.io.schema.views.cdn_loadbalancer.access_log.CDNAccessLogTag" json:"tag,omitempty"`
	// Filter values
	//
	// x-displayName: "Filter values"
	// x-example: "[IN, US]"
	// x-required
	// Filter values
	Values []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	// CDN Access Logs Operator Types
	//
	// x-displayName: "CDN Access Logs Operator Types"
	// x-required
	// Operators possible in filtering
	Operator CDNAccessLogOperatorType `protobuf:"varint,3,opt,name=operator,proto3,enum=ves.io.schema.views.cdn_loadbalancer.CDNAccessLogOperatorType" json:"operator,omitempty"`
}

func (m *CDNAccessLogFilter) Reset()      { *m = CDNAccessLogFilter{} }
func (*CDNAccessLogFilter) ProtoMessage() {}
func (*CDNAccessLogFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{11}
}
func (m *CDNAccessLogFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNAccessLogFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNAccessLogFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNAccessLogFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNAccessLogFilter.Merge(m, src)
}
func (m *CDNAccessLogFilter) XXX_Size() int {
	return m.Size()
}
func (m *CDNAccessLogFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNAccessLogFilter.DiscardUnknown(m)
}

var xxx_messageInfo_CDNAccessLogFilter proto.InternalMessageInfo

func (m *CDNAccessLogFilter) GetTag() access_log.CDNAccessLogTag {
	if m != nil {
		return m.Tag
	}
	return access_log.CDN_NAME
}

func (m *CDNAccessLogFilter) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *CDNAccessLogFilter) GetOperator() CDNAccessLogOperatorType {
	if m != nil {
		return m.Operator
	}
	return CDN_ACCESS_LOG_OPERATOR_TYPE_IN
}

// Metrics Request parameters
//
// x-displayName: "Metrics Request"
// CDN Metrics request parameters
type LilacCDNMetricsRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "default"
	// x-required
	// Namespace scope of the metric request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Start Time
	//
	// x-displayName: "Start Time"
	// x-example: "1659758607"
	// x-required
	// Format: unix_timestamp|rfc 3339
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Step
	//
	// x-displayName: "Step"
	// x-example: "1m"
	// step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in
	// the response. The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step,
	// where tn <= end_time. Depending on the time range, the step has a minimum value (due to rollups).
	// For e.g. for ranges in last one hr, step minimum is 5m, for ranges beyond a day, its 1h etc.
	// Step value used is the max(<min-step-for-range>, <step-value-in-request>)
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	//
	// Optional: If not specified, then step size is evaluated to <end_time - start_time>
	Step string `protobuf:"bytes,4,opt,name=step,proto3" json:"step,omitempty"`
	// End Time
	//
	// x-displayName: "End Time"
	// x-example: "1659758607"
	// x-required
	// Format: unix_timestamp|rfc 3339
	EndTime string `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Field Selector
	//
	// x-displayName: "Field Selector"
	// x-required
	// Fields (Metrics) selected to be queried.
	FieldSelector []LilacCDNMetricsFieldSelector `protobuf:"varint,6,rep,packed,name=field_selector,json=fieldSelector,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFieldSelector" json:"field_selector,omitempty"`
	// Metrics Filter options
	//
	// x-displayName: "Metrics Filter"
	// CDN Metrics filter options
	Filter []*LilacCDNMetricsFilter `protobuf:"bytes,7,rep,name=filter,proto3" json:"filter,omitempty"`
	// Group By
	//
	// x-displayName: "Group By"
	// Aggregate data by zero or more tags
	GroupBy []LilacCDNMetricsTag `protobuf:"varint,8,rep,packed,name=group_by,json=groupBy,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag" json:"group_by,omitempty"`
}

func (m *LilacCDNMetricsRequest) Reset()      { *m = LilacCDNMetricsRequest{} }
func (*LilacCDNMetricsRequest) ProtoMessage() {}
func (*LilacCDNMetricsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{12}
}
func (m *LilacCDNMetricsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LilacCDNMetricsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LilacCDNMetricsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsRequest.Merge(m, src)
}
func (m *LilacCDNMetricsRequest) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsRequest proto.InternalMessageInfo

func (m *LilacCDNMetricsRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *LilacCDNMetricsRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *LilacCDNMetricsRequest) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

func (m *LilacCDNMetricsRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *LilacCDNMetricsRequest) GetFieldSelector() []LilacCDNMetricsFieldSelector {
	if m != nil {
		return m.FieldSelector
	}
	return nil
}

func (m *LilacCDNMetricsRequest) GetFilter() []*LilacCDNMetricsFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *LilacCDNMetricsRequest) GetGroupBy() []LilacCDNMetricsTag {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

// Metrics Response
//
// x-displayName: "Metrics Response"
// CDN Metrics response message
type LilacCDNMetricsResponse struct {
	// Metrics Response Data
	//
	// x-displayName: "Metrics Response data items"
	// CDN Metrics response data items. Each instance has response for a field queried.
	Items []*LilacCDNMetricsResponseData `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	// Step
	//
	// x-displayName: "Step"
	// x-example: "5m"
	// The effective step used in the response. It could be higher than the requested step due to rollups.
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	Step string `protobuf:"bytes,2,opt,name=step,proto3" json:"step,omitempty"`
}

func (m *LilacCDNMetricsResponse) Reset()      { *m = LilacCDNMetricsResponse{} }
func (*LilacCDNMetricsResponse) ProtoMessage() {}
func (*LilacCDNMetricsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{13}
}
func (m *LilacCDNMetricsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LilacCDNMetricsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LilacCDNMetricsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsResponse.Merge(m, src)
}
func (m *LilacCDNMetricsResponse) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsResponse proto.InternalMessageInfo

func (m *LilacCDNMetricsResponse) GetItems() []*LilacCDNMetricsResponseData {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *LilacCDNMetricsResponse) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

// Cache Purge Request
//
// x-displayName: "Cache Purge"
// CDN Cache Purge
type LilacCDNCachePurgeRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "default"
	// x-required
	// Namespace scope of the metric request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// CDN Distribution Name
	//
	// x-displayName: "Name of the CDN distrubition"
	// x-example: "cdn-1"
	// x-required
	// Format: string
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Purge Timestamp
	//
	// x-displayName: "Purge Time"
	// x-example: "1659758607"
	// Format: unix_timestamp|rfc 3339
	// Purge objects that were created on or before this timestamp
	PurgeEpochTimestamp string `protobuf:"bytes,3,opt,name=purge_epoch_timestamp,json=purgeEpochTimestamp,proto3" json:"purge_epoch_timestamp,omitempty"`
	// Purge Options
	//
	// x-displayName: "Purge Options"
	// x-required
	// Format: string
	// Options to purge cache for a specific distribution
	//
	// Types that are valid to be assigned to PatternType:
	//	*LilacCDNCachePurgeRequest_PurgeAll
	//	*LilacCDNCachePurgeRequest_Url
	//	*LilacCDNCachePurgeRequest_Hostname
	//	*LilacCDNCachePurgeRequest_Pattern
	PatternType isLilacCDNCachePurgeRequest_PatternType `protobuf_oneof:"pattern_type"`
	// Purge Type
	//
	// x-displayName: "Purge Type"
	// x-required
	// Purge type controls how the purge is performed
	//
	// Types that are valid to be assigned to PurgeType:
	//	*LilacCDNCachePurgeRequest_SoftPurge
	//	*LilacCDNCachePurgeRequest_HardPurge
	PurgeType isLilacCDNCachePurgeRequest_PurgeType `protobuf_oneof:"purge_type"`
}

func (m *LilacCDNCachePurgeRequest) Reset()      { *m = LilacCDNCachePurgeRequest{} }
func (*LilacCDNCachePurgeRequest) ProtoMessage() {}
func (*LilacCDNCachePurgeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{14}
}
func (m *LilacCDNCachePurgeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNCachePurgeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LilacCDNCachePurgeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LilacCDNCachePurgeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNCachePurgeRequest.Merge(m, src)
}
func (m *LilacCDNCachePurgeRequest) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNCachePurgeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNCachePurgeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNCachePurgeRequest proto.InternalMessageInfo

type isLilacCDNCachePurgeRequest_PatternType interface {
	isLilacCDNCachePurgeRequest_PatternType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isLilacCDNCachePurgeRequest_PurgeType interface {
	isLilacCDNCachePurgeRequest_PurgeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LilacCDNCachePurgeRequest_PurgeAll struct {
	PurgeAll *schema.Empty `protobuf:"bytes,9,opt,name=purge_all,json=purgeAll,proto3,oneof" json:"purge_all,omitempty"`
}
type LilacCDNCachePurgeRequest_Url struct {
	Url string `protobuf:"bytes,10,opt,name=url,proto3,oneof" json:"url,omitempty"`
}
type LilacCDNCachePurgeRequest_Hostname struct {
	Hostname string `protobuf:"bytes,11,opt,name=hostname,proto3,oneof" json:"hostname,omitempty"`
}
type LilacCDNCachePurgeRequest_Pattern struct {
	Pattern string `protobuf:"bytes,4,opt,name=pattern,proto3,oneof" json:"pattern,omitempty"`
}
type LilacCDNCachePurgeRequest_SoftPurge struct {
	SoftPurge *schema.Empty `protobuf:"bytes,6,opt,name=soft_purge,json=softPurge,proto3,oneof" json:"soft_purge,omitempty"`
}
type LilacCDNCachePurgeRequest_HardPurge struct {
	HardPurge *schema.Empty `protobuf:"bytes,7,opt,name=hard_purge,json=hardPurge,proto3,oneof" json:"hard_purge,omitempty"`
}

func (*LilacCDNCachePurgeRequest_PurgeAll) isLilacCDNCachePurgeRequest_PatternType() {}
func (*LilacCDNCachePurgeRequest_Url) isLilacCDNCachePurgeRequest_PatternType()      {}
func (*LilacCDNCachePurgeRequest_Hostname) isLilacCDNCachePurgeRequest_PatternType() {}
func (*LilacCDNCachePurgeRequest_Pattern) isLilacCDNCachePurgeRequest_PatternType()  {}
func (*LilacCDNCachePurgeRequest_SoftPurge) isLilacCDNCachePurgeRequest_PurgeType()  {}
func (*LilacCDNCachePurgeRequest_HardPurge) isLilacCDNCachePurgeRequest_PurgeType()  {}

func (m *LilacCDNCachePurgeRequest) GetPatternType() isLilacCDNCachePurgeRequest_PatternType {
	if m != nil {
		return m.PatternType
	}
	return nil
}
func (m *LilacCDNCachePurgeRequest) GetPurgeType() isLilacCDNCachePurgeRequest_PurgeType {
	if m != nil {
		return m.PurgeType
	}
	return nil
}

func (m *LilacCDNCachePurgeRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetPurgeEpochTimestamp() string {
	if m != nil {
		return m.PurgeEpochTimestamp
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetPurgeAll() *schema.Empty {
	if x, ok := m.GetPatternType().(*LilacCDNCachePurgeRequest_PurgeAll); ok {
		return x.PurgeAll
	}
	return nil
}

func (m *LilacCDNCachePurgeRequest) GetUrl() string {
	if x, ok := m.GetPatternType().(*LilacCDNCachePurgeRequest_Url); ok {
		return x.Url
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetHostname() string {
	if x, ok := m.GetPatternType().(*LilacCDNCachePurgeRequest_Hostname); ok {
		return x.Hostname
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetPattern() string {
	if x, ok := m.GetPatternType().(*LilacCDNCachePurgeRequest_Pattern); ok {
		return x.Pattern
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetSoftPurge() *schema.Empty {
	if x, ok := m.GetPurgeType().(*LilacCDNCachePurgeRequest_SoftPurge); ok {
		return x.SoftPurge
	}
	return nil
}

func (m *LilacCDNCachePurgeRequest) GetHardPurge() *schema.Empty {
	if x, ok := m.GetPurgeType().(*LilacCDNCachePurgeRequest_HardPurge); ok {
		return x.HardPurge
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LilacCDNCachePurgeRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LilacCDNCachePurgeRequest_PurgeAll)(nil),
		(*LilacCDNCachePurgeRequest_Url)(nil),
		(*LilacCDNCachePurgeRequest_Hostname)(nil),
		(*LilacCDNCachePurgeRequest_Pattern)(nil),
		(*LilacCDNCachePurgeRequest_SoftPurge)(nil),
		(*LilacCDNCachePurgeRequest_HardPurge)(nil),
	}
}

// Purge Response
//
// x-displayName: "Cache Purge Response"
// Cache Purge message
type LilacCDNCachePurgeResponse struct {
	// Purge Request Id
	//
	// x-displayName: "Purge Request Id"
	// Request Id to track the status of the purge request
	PurgeRequestId uint32 `protobuf:"varint,1,opt,name=purge_request_id,json=purgeRequestId,proto3" json:"purge_request_id,omitempty"`
}

func (m *LilacCDNCachePurgeResponse) Reset()      { *m = LilacCDNCachePurgeResponse{} }
func (*LilacCDNCachePurgeResponse) ProtoMessage() {}
func (*LilacCDNCachePurgeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{15}
}
func (m *LilacCDNCachePurgeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNCachePurgeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LilacCDNCachePurgeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LilacCDNCachePurgeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNCachePurgeResponse.Merge(m, src)
}
func (m *LilacCDNCachePurgeResponse) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNCachePurgeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNCachePurgeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNCachePurgeResponse proto.InternalMessageInfo

func (m *LilacCDNCachePurgeResponse) GetPurgeRequestId() uint32 {
	if m != nil {
		return m.PurgeRequestId
	}
	return 0
}

// SubscribeRequest
//
// x-displayName: "Subscribe Request"
// Request to subscribe to CDN Loadbalancer
type SubscribeRequest struct {
}

func (m *SubscribeRequest) Reset()      { *m = SubscribeRequest{} }
func (*SubscribeRequest) ProtoMessage() {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{16}
}
func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(m, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

// SubscribeResponse
//
// x-displayName: "Subscribe Response"
// Response of subscribe to CDN Loadbalancer
type SubscribeResponse struct {
}

func (m *SubscribeResponse) Reset()      { *m = SubscribeResponse{} }
func (*SubscribeResponse) ProtoMessage() {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{17}
}
func (m *SubscribeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeResponse.Merge(m, src)
}
func (m *SubscribeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeResponse proto.InternalMessageInfo

// UnsubscribeRequest
//
// x-displayName: "Unsubscribe Request"
// Request to unsubscribe to CDN Loadbalancer
type UnsubscribeRequest struct {
}

func (m *UnsubscribeRequest) Reset()      { *m = UnsubscribeRequest{} }
func (*UnsubscribeRequest) ProtoMessage() {}
func (*UnsubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{18}
}
func (m *UnsubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsubscribeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsubscribeRequest.Merge(m, src)
}
func (m *UnsubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnsubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnsubscribeRequest proto.InternalMessageInfo

// UnsubscribeResponse
//
// x-displayName: "Unsubscribe Response"
// Response of unsubscribe to CDN Loadbalancer
type UnsubscribeResponse struct {
}

func (m *UnsubscribeResponse) Reset()      { *m = UnsubscribeResponse{} }
func (*UnsubscribeResponse) ProtoMessage() {}
func (*UnsubscribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{19}
}
func (m *UnsubscribeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsubscribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsubscribeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsubscribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsubscribeResponse.Merge(m, src)
}
func (m *UnsubscribeResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnsubscribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsubscribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnsubscribeResponse proto.InternalMessageInfo

// Service Operation Request
//
// x-displayName: "Get Service Operation Request"
// Get Service Operation Request
type GetServiceOperationReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "default"
	// x-required
	// Namespace scope of the operation request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// CDN Distribution Name
	//
	// x-displayName: "Name of the CDN distribution"
	// x-example: "cdn-1"
	// x-required
	// Name of the CDN distribution.
	// Format: string
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Service Operation ID
	//
	// x-displayName: "Service Operation ID"
	// x-example: "101"
	// x-required
	// Operation ID for which status is requested
	ServiceOpId uint32 `protobuf:"varint,3,opt,name=service_op_id,json=serviceOpId,proto3" json:"service_op_id,omitempty"`
}

func (m *GetServiceOperationReq) Reset()      { *m = GetServiceOperationReq{} }
func (*GetServiceOperationReq) ProtoMessage() {}
func (*GetServiceOperationReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{20}
}
func (m *GetServiceOperationReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetServiceOperationReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetServiceOperationReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetServiceOperationReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetServiceOperationReq.Merge(m, src)
}
func (m *GetServiceOperationReq) XXX_Size() int {
	return m.Size()
}
func (m *GetServiceOperationReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetServiceOperationReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetServiceOperationReq proto.InternalMessageInfo

func (m *GetServiceOperationReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetServiceOperationReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetServiceOperationReq) GetServiceOpId() uint32 {
	if m != nil {
		return m.ServiceOpId
	}
	return 0
}

// Purge Operation Status
//
// x-displayName: "Purge Operation Status"
// Purge Operation Status
type PurgeOperationItem struct {
	// NodeId on which the operation status is gathered
	//
	// x-displayName: "CDN CE Site"
	// Site at which the purge operation was performed.
	Site string `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
	// Time taken for Cache Purge
	//
	// x-displayName: "Cache Purge Time"
	// x-example: "2018-12-23T12:30:11.733Z"
	// Time taken for Cache Purge
	PurgeTime string `protobuf:"bytes,2,opt,name=purge_time,json=purgeTime,proto3" json:"purge_time,omitempty"`
	// Regex used in Purge
	//
	// x-displayName: "Cache Purge Regex"
	// x-example: "*.m3u8"
	// Regex issued in the Purge Operation
	Regexp string `protobuf:"bytes,3,opt,name=regexp,proto3" json:"regexp,omitempty"`
	// Start time of Purge Operation
	//
	// x-displayName: "Cache Purge Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// Start time of Purge Operation
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Finish time of Purge Operation
	//
	// x-displayName: "Cache Purge Finish Time"
	// x-example: "2019-09-23T12:32:11.733Z"
	// Finish time of Purge Operation
	// format: unix_timestamp|rfc 3339
	FinishTime string `protobuf:"bytes,5,opt,name=finish_time,json=finishTime,proto3" json:"finish_time,omitempty"`
	// Hard Purge
	//
	// x-displayName: "Cache Hard Purge"
	// x-example: true
	// Cache Hard Purge
	HardPurge bool `protobuf:"varint,6,opt,name=hard_purge,json=hardPurge,proto3" json:"hard_purge,omitempty"`
	// Number of Bytes Purged
	//
	// x-displayName: "Number of Bytes Purged"
	// x-example: 1024
	// Number of bytes Purged
	BytesPurged uint64 `protobuf:"varint,7,opt,name=bytes_purged,json=bytesPurged,proto3" json:"bytes_purged,omitempty"`
	// Number of Bytes Not Purged
	//
	// x-displayName: "Number of Bytes Not Purged"
	// x-example: 1024
	// Number of bytes Not Purged
	BytesNotPurged uint64 `protobuf:"varint,8,opt,name=bytes_not_purged,json=bytesNotPurged,proto3" json:"bytes_not_purged,omitempty"`
}

func (m *PurgeOperationItem) Reset()      { *m = PurgeOperationItem{} }
func (*PurgeOperationItem) ProtoMessage() {}
func (*PurgeOperationItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{21}
}
func (m *PurgeOperationItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PurgeOperationItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PurgeOperationItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PurgeOperationItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PurgeOperationItem.Merge(m, src)
}
func (m *PurgeOperationItem) XXX_Size() int {
	return m.Size()
}
func (m *PurgeOperationItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PurgeOperationItem.DiscardUnknown(m)
}

var xxx_messageInfo_PurgeOperationItem proto.InternalMessageInfo

func (m *PurgeOperationItem) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *PurgeOperationItem) GetPurgeTime() string {
	if m != nil {
		return m.PurgeTime
	}
	return ""
}

func (m *PurgeOperationItem) GetRegexp() string {
	if m != nil {
		return m.Regexp
	}
	return ""
}

func (m *PurgeOperationItem) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *PurgeOperationItem) GetFinishTime() string {
	if m != nil {
		return m.FinishTime
	}
	return ""
}

func (m *PurgeOperationItem) GetHardPurge() bool {
	if m != nil {
		return m.HardPurge
	}
	return false
}

func (m *PurgeOperationItem) GetBytesPurged() uint64 {
	if m != nil {
		return m.BytesPurged
	}
	return 0
}

func (m *PurgeOperationItem) GetBytesNotPurged() uint64 {
	if m != nil {
		return m.BytesNotPurged
	}
	return 0
}

// Service Operation Item
//
// x-displayName: "Service Operation Item"
// Service Operation Item
type ServiceOperationItem struct {
	// Service Operation ID
	//
	// x-displayName: "Service Operation ID"
	// x-example: "101"
	// Operation ID for which status is requested. This for example is the purge_request_id obtained in the response to the CachePurge Request.
	ServiceOpId uint32 `protobuf:"varint,1,opt,name=service_op_id,json=serviceOpId,proto3" json:"service_op_id,omitempty"`
	// Service Operation Status
	//
	// x-displayName: "Service Operation Status"
	// x-example: success
	// Status of the operation command
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// operation status
	//
	// x-displayName: "Operation Status"
	// Specify operation status of each operation item
	//
	// Types that are valid to be assigned to OpStatus:
	//	*ServiceOperationItem_Purge
	OpStatus isServiceOperationItem_OpStatus `protobuf_oneof:"op_status"`
}

func (m *ServiceOperationItem) Reset()      { *m = ServiceOperationItem{} }
func (*ServiceOperationItem) ProtoMessage() {}
func (*ServiceOperationItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{22}
}
func (m *ServiceOperationItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceOperationItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceOperationItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceOperationItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceOperationItem.Merge(m, src)
}
func (m *ServiceOperationItem) XXX_Size() int {
	return m.Size()
}
func (m *ServiceOperationItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceOperationItem.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceOperationItem proto.InternalMessageInfo

type isServiceOperationItem_OpStatus interface {
	isServiceOperationItem_OpStatus()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ServiceOperationItem_Purge struct {
	Purge *PurgeOperationItem `protobuf:"bytes,4,opt,name=purge,proto3,oneof" json:"purge,omitempty"`
}

func (*ServiceOperationItem_Purge) isServiceOperationItem_OpStatus() {}

func (m *ServiceOperationItem) GetOpStatus() isServiceOperationItem_OpStatus {
	if m != nil {
		return m.OpStatus
	}
	return nil
}

func (m *ServiceOperationItem) GetServiceOpId() uint32 {
	if m != nil {
		return m.ServiceOpId
	}
	return 0
}

func (m *ServiceOperationItem) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ServiceOperationItem) GetPurge() *PurgeOperationItem {
	if x, ok := m.GetOpStatus().(*ServiceOperationItem_Purge); ok {
		return x.Purge
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ServiceOperationItem) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ServiceOperationItem_Purge)(nil),
	}
}

// Service Operation Response
//
// x-displayName: "Service Operation Response"
// Get Service Operation Response
type GetServiceOperationRsp struct {
	// error
	//
	// x-displayName: "Errors"
	// Errors(if any) while listing items from collection
	Error *schema.ErrorType `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// Serice Operation Status Details
	//
	// x-displayName: "Operation Status Details"
	// items represents the collection in response
	Items []*ServiceOperationItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *GetServiceOperationRsp) Reset()      { *m = GetServiceOperationRsp{} }
func (*GetServiceOperationRsp) ProtoMessage() {}
func (*GetServiceOperationRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{23}
}
func (m *GetServiceOperationRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetServiceOperationRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetServiceOperationRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetServiceOperationRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetServiceOperationRsp.Merge(m, src)
}
func (m *GetServiceOperationRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetServiceOperationRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetServiceOperationRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetServiceOperationRsp proto.InternalMessageInfo

func (m *GetServiceOperationRsp) GetError() *schema.ErrorType {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetServiceOperationRsp) GetItems() []*ServiceOperationItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// Service Operations Time Range
//
// x-displayName: "Service Operations Options"
// Option to specify lastn or start-end time.
type ServiceOperationsTimeRange struct {
	// Start time of Service Operations
	//
	// x-displayName: "Service Operation Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// x-required
	// A start time for the time range in which the service operation status is requested.
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Finish time of Service Operations
	//
	// x-displayName: "Service Operation Finish Time"
	// x-example: "2019-09-23T12:32:11.733Z"
	// x-required
	// A finish time for the time range in which the service operation status is requested.
	// format: unix_timestamp|rfc 3339
	FinishTime string `protobuf:"bytes,5,opt,name=finish_time,json=finishTime,proto3" json:"finish_time,omitempty"`
}

func (m *ServiceOperationsTimeRange) Reset()      { *m = ServiceOperationsTimeRange{} }
func (*ServiceOperationsTimeRange) ProtoMessage() {}
func (*ServiceOperationsTimeRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{24}
}
func (m *ServiceOperationsTimeRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceOperationsTimeRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceOperationsTimeRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceOperationsTimeRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceOperationsTimeRange.Merge(m, src)
}
func (m *ServiceOperationsTimeRange) XXX_Size() int {
	return m.Size()
}
func (m *ServiceOperationsTimeRange) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceOperationsTimeRange.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceOperationsTimeRange proto.InternalMessageInfo

func (m *ServiceOperationsTimeRange) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *ServiceOperationsTimeRange) GetFinishTime() string {
	if m != nil {
		return m.FinishTime
	}
	return ""
}

// Service Operations Request
//
// x-displayName: "List Service Operations Request"
// List Service Operations Request
type ListServiceOperationsReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// x-required
	// The namespace this item belongs to
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "name"
	// Name of the CDN Distribution
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// service operation options
	//
	// x-required
	// x-displayName: "Options"
	// Specify one of the service operation options. It can be either operations in a timerange or last-n operations.
	//
	// Types that are valid to be assigned to Options:
	//	*ListServiceOperationsReq_TimeRange
	//	*ListServiceOperationsReq_Lastn
	Options isListServiceOperationsReq_Options `protobuf_oneof:"options"`
}

func (m *ListServiceOperationsReq) Reset()      { *m = ListServiceOperationsReq{} }
func (*ListServiceOperationsReq) ProtoMessage() {}
func (*ListServiceOperationsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{25}
}
func (m *ListServiceOperationsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListServiceOperationsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListServiceOperationsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListServiceOperationsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListServiceOperationsReq.Merge(m, src)
}
func (m *ListServiceOperationsReq) XXX_Size() int {
	return m.Size()
}
func (m *ListServiceOperationsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListServiceOperationsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListServiceOperationsReq proto.InternalMessageInfo

type isListServiceOperationsReq_Options interface {
	isListServiceOperationsReq_Options()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListServiceOperationsReq_TimeRange struct {
	TimeRange *ServiceOperationsTimeRange `protobuf:"bytes,4,opt,name=time_range,json=timeRange,proto3,oneof" json:"time_range,omitempty"`
}
type ListServiceOperationsReq_Lastn struct {
	Lastn uint32 `protobuf:"varint,5,opt,name=lastn,proto3,oneof" json:"lastn,omitempty"`
}

func (*ListServiceOperationsReq_TimeRange) isListServiceOperationsReq_Options() {}
func (*ListServiceOperationsReq_Lastn) isListServiceOperationsReq_Options()     {}

func (m *ListServiceOperationsReq) GetOptions() isListServiceOperationsReq_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ListServiceOperationsReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListServiceOperationsReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListServiceOperationsReq) GetTimeRange() *ServiceOperationsTimeRange {
	if x, ok := m.GetOptions().(*ListServiceOperationsReq_TimeRange); ok {
		return x.TimeRange
	}
	return nil
}

func (m *ListServiceOperationsReq) GetLastn() uint32 {
	if x, ok := m.GetOptions().(*ListServiceOperationsReq_Lastn); ok {
		return x.Lastn
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ListServiceOperationsReq) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ListServiceOperationsReq_TimeRange)(nil),
		(*ListServiceOperationsReq_Lastn)(nil),
	}
}

// Service Operations Item
//
// x-displayName: "List of Service Operations"
// List of Service Operations
type ServiceOperationsItem struct {
	// service operation id
	//
	// x-displayName: "Service Operation ID"
	// x-example: ""
	// The id of the operation command
	ServiceOpId uint32 `protobuf:"varint,1,opt,name=service_op_id,json=serviceOpId,proto3" json:"service_op_id,omitempty"`
	// svc version
	//
	// x-displayName: "Service Version"
	// x-example: ""
	// The version info of the service
	SvcVersion uint32 `protobuf:"varint,2,opt,name=svc_version,json=svcVersion,proto3" json:"svc_version,omitempty"`
	// created time
	//
	// x-displayName: "Created Time"
	// The service created time
	CreatedTime string `protobuf:"bytes,3,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// modified time
	//
	// x-displayName: "Modified Time"
	// The service modified time
	ModifiedTime string `protobuf:"bytes,4,opt,name=modified_time,json=modifiedTime,proto3" json:"modified_time,omitempty"`
}

func (m *ServiceOperationsItem) Reset()      { *m = ServiceOperationsItem{} }
func (*ServiceOperationsItem) ProtoMessage() {}
func (*ServiceOperationsItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{26}
}
func (m *ServiceOperationsItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceOperationsItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceOperationsItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceOperationsItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceOperationsItem.Merge(m, src)
}
func (m *ServiceOperationsItem) XXX_Size() int {
	return m.Size()
}
func (m *ServiceOperationsItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceOperationsItem.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceOperationsItem proto.InternalMessageInfo

func (m *ServiceOperationsItem) GetServiceOpId() uint32 {
	if m != nil {
		return m.ServiceOpId
	}
	return 0
}

func (m *ServiceOperationsItem) GetSvcVersion() uint32 {
	if m != nil {
		return m.SvcVersion
	}
	return 0
}

func (m *ServiceOperationsItem) GetCreatedTime() string {
	if m != nil {
		return m.CreatedTime
	}
	return ""
}

func (m *ServiceOperationsItem) GetModifiedTime() string {
	if m != nil {
		return m.ModifiedTime
	}
	return ""
}

// Service Operations Response
//
// x-displayName: "Service Operations Response"
// Get Service Operations Response
type ListServiceOperationsRsp struct {
	// error
	//
	// x-displayName: "Errors"
	// Errors(if any) while listing items from collection
	Error *schema.ErrorType `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// Details of the Service Operation
	//
	// x-displayName: "Details of the Service Operation"
	// items represents the collection in response
	Items []*ServiceOperationsItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *ListServiceOperationsRsp) Reset()      { *m = ListServiceOperationsRsp{} }
func (*ListServiceOperationsRsp) ProtoMessage() {}
func (*ListServiceOperationsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4abedfb61da15b, []int{27}
}
func (m *ListServiceOperationsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListServiceOperationsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListServiceOperationsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListServiceOperationsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListServiceOperationsRsp.Merge(m, src)
}
func (m *ListServiceOperationsRsp) XXX_Size() int {
	return m.Size()
}
func (m *ListServiceOperationsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListServiceOperationsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ListServiceOperationsRsp proto.InternalMessageInfo

func (m *ListServiceOperationsRsp) GetError() *schema.ErrorType {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ListServiceOperationsRsp) GetItems() []*ServiceOperationsItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.CDNAccessLogOperatorType", CDNAccessLogOperatorType_name, CDNAccessLogOperatorType_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.CDNAccessLogOperatorType", CDNAccessLogOperatorType_name, CDNAccessLogOperatorType_value)
	proto.RegisterType((*LilacCDNAccessLogsResponseData)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNAccessLogsResponseData")
	golang_proto.RegisterType((*LilacCDNAccessLogsResponseData)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNAccessLogsResponseData")
	proto.RegisterType((*CDNLogResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNLogResponse")
	golang_proto.RegisterType((*CDNLogResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNLogResponse")
	proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNLogResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNLogResponse.AggsEntry")
	proto.RegisterType((*CDNAccessLogRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogRequest")
	golang_proto.RegisterType((*CDNAccessLogRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogRequest")
	proto.RegisterMapType((map[string]*CDNAggregationRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*CDNAggregationRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogRequest.AggsEntry")
	proto.RegisterType((*CDNLogAggregationResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNLogAggregationResponse")
	golang_proto.RegisterType((*CDNLogAggregationResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNLogAggregationResponse")
	proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNLogAggregationResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNLogAggregationResponse.AggsEntry")
	proto.RegisterType((*CDNAccessLogAggregationRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogAggregationRequest")
	golang_proto.RegisterType((*CDNAccessLogAggregationRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogAggregationRequest")
	proto.RegisterMapType((map[string]*CDNAggregationRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*CDNAggregationRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogAggregationRequest.AggsEntry")
	proto.RegisterType((*CDNAggregationRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAggregationRequest")
	golang_proto.RegisterType((*CDNAggregationRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAggregationRequest")
	proto.RegisterType((*CDNDateSubAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDateSubAggregation")
	golang_proto.RegisterType((*CDNDateSubAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDateSubAggregation")
	proto.RegisterType((*CDNDateAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDateAggregation")
	golang_proto.RegisterType((*CDNDateAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDateAggregation")
	proto.RegisterMapType((map[string]*CDNDateSubAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDateAggregation.SubAggsEntry")
	golang_proto.RegisterMapType((map[string]*CDNDateSubAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDateAggregation.SubAggsEntry")
	proto.RegisterType((*CDNFieldAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNFieldAggregation")
	golang_proto.RegisterType((*CDNFieldAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNFieldAggregation")
	proto.RegisterMapType((map[string]*CDNFieldSubAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNFieldAggregation.SubAggsEntry")
	golang_proto.RegisterMapType((map[string]*CDNFieldSubAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNFieldAggregation.SubAggsEntry")
	proto.RegisterType((*CDNFieldSubAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNFieldSubAggregation")
	golang_proto.RegisterType((*CDNFieldSubAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNFieldSubAggregation")
	proto.RegisterType((*FieldAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.FieldAggregation")
	golang_proto.RegisterType((*FieldAggregation)(nil), "ves.io.schema.views.cdn_loadbalancer.FieldAggregation")
	proto.RegisterType((*CDNAccessLogFilter)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogFilter")
	golang_proto.RegisterType((*CDNAccessLogFilter)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNAccessLogFilter")
	proto.RegisterType((*LilacCDNMetricsRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsRequest")
	golang_proto.RegisterType((*LilacCDNMetricsRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsRequest")
	proto.RegisterType((*LilacCDNMetricsResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponse")
	golang_proto.RegisterType((*LilacCDNMetricsResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponse")
	proto.RegisterType((*LilacCDNCachePurgeRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeRequest")
	golang_proto.RegisterType((*LilacCDNCachePurgeRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeRequest")
	proto.RegisterType((*LilacCDNCachePurgeResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeResponse")
	golang_proto.RegisterType((*LilacCDNCachePurgeResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNCachePurgeResponse")
	proto.RegisterType((*SubscribeRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.SubscribeRequest")
	golang_proto.RegisterType((*SubscribeRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.SubscribeRequest")
	proto.RegisterType((*SubscribeResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.SubscribeResponse")
	golang_proto.RegisterType((*SubscribeResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.SubscribeResponse")
	proto.RegisterType((*UnsubscribeRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.UnsubscribeRequest")
	golang_proto.RegisterType((*UnsubscribeRequest)(nil), "ves.io.schema.views.cdn_loadbalancer.UnsubscribeRequest")
	proto.RegisterType((*UnsubscribeResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.UnsubscribeResponse")
	golang_proto.RegisterType((*UnsubscribeResponse)(nil), "ves.io.schema.views.cdn_loadbalancer.UnsubscribeResponse")
	proto.RegisterType((*GetServiceOperationReq)(nil), "ves.io.schema.views.cdn_loadbalancer.GetServiceOperationReq")
	golang_proto.RegisterType((*GetServiceOperationReq)(nil), "ves.io.schema.views.cdn_loadbalancer.GetServiceOperationReq")
	proto.RegisterType((*PurgeOperationItem)(nil), "ves.io.schema.views.cdn_loadbalancer.PurgeOperationItem")
	golang_proto.RegisterType((*PurgeOperationItem)(nil), "ves.io.schema.views.cdn_loadbalancer.PurgeOperationItem")
	proto.RegisterType((*ServiceOperationItem)(nil), "ves.io.schema.views.cdn_loadbalancer.ServiceOperationItem")
	golang_proto.RegisterType((*ServiceOperationItem)(nil), "ves.io.schema.views.cdn_loadbalancer.ServiceOperationItem")
	proto.RegisterType((*GetServiceOperationRsp)(nil), "ves.io.schema.views.cdn_loadbalancer.GetServiceOperationRsp")
	golang_proto.RegisterType((*GetServiceOperationRsp)(nil), "ves.io.schema.views.cdn_loadbalancer.GetServiceOperationRsp")
	proto.RegisterType((*ServiceOperationsTimeRange)(nil), "ves.io.schema.views.cdn_loadbalancer.ServiceOperationsTimeRange")
	golang_proto.RegisterType((*ServiceOperationsTimeRange)(nil), "ves.io.schema.views.cdn_loadbalancer.ServiceOperationsTimeRange")
	proto.RegisterType((*ListServiceOperationsReq)(nil), "ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsReq")
	golang_proto.RegisterType((*ListServiceOperationsReq)(nil), "ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsReq")
	proto.RegisterType((*ServiceOperationsItem)(nil), "ves.io.schema.views.cdn_loadbalancer.ServiceOperationsItem")
	golang_proto.RegisterType((*ServiceOperationsItem)(nil), "ves.io.schema.views.cdn_loadbalancer.ServiceOperationsItem")
	proto.RegisterType((*ListServiceOperationsRsp)(nil), "ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsRsp")
	golang_proto.RegisterType((*ListServiceOperationsRsp)(nil), "ves.io.schema.views.cdn_loadbalancer.ListServiceOperationsRsp")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/cdn_loadbalancer/public_customapi.proto", fileDescriptor_aa4abedfb61da15b)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/cdn_loadbalancer/public_customapi.proto", fileDescriptor_aa4abedfb61da15b)
}

var fileDescriptor_aa4abedfb61da15b = []byte{
	// 3150 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x3a, 0x5d, 0x6c, 0x1b, 0xc7,
	0x99, 0x1a, 0x72, 0x29, 0x2d, 0x47, 0x3f, 0xde, 0x8c, 0x2c, 0x79, 0x4d, 0xcb, 0xb4, 0xb2, 0x4e,
	0x2e, 0x8a, 0x6d, 0x8a, 0x89, 0x13, 0x5f, 0xfc, 0x93, 0x4b, 0x2c, 0xc9, 0xb2, 0x2d, 0x41, 0x27,
	0xdb, 0x94, 0x2f, 0x77, 0x31, 0x70, 0xb7, 0x58, 0xed, 0x8e, 0x96, 0x7b, 0x5e, 0xee, 0xac, 0x77,
	0x86, 0xb2, 0x95, 0xbb, 0x14, 0x46, 0xd0, 0x16, 0xed, 0x4b, 0x51, 0xa4, 0x79, 0x28, 0x02, 0x14,
	0x79, 0xe8, 0x0f, 0x0a, 0x04, 0x45, 0x1f, 0x5a, 0x14, 0x6d, 0xd5, 0x16, 0x6e, 0x5f, 0x12, 0xf4,
	0xa1, 0x10, 0x5a, 0xa0, 0x08, 0xda, 0x97, 0x46, 0xee, 0x43, 0x0a, 0x14, 0x68, 0x1e, 0x0a, 0xf4,
	0xe7, 0xa9, 0x98, 0x99, 0x5d, 0x72, 0x49, 0x49, 0x36, 0x45, 0xbb, 0x2e, 0xfa, 0xb6, 0xfc, 0xfe,
	0xff, 0xe6, 0x9b, 0x6f, 0x66, 0x08, 0xcf, 0xac, 0x62, 0x3a, 0xe9, 0x91, 0x32, 0xb5, 0xab, 0xb8,
	0x66, 0x95, 0x57, 0x3d, 0x7c, 0x93, 0x96, 0x6d, 0x27, 0x30, 0x7d, 0x62, 0x39, 0xcb, 0x96, 0x6f,
	0x05, 0x36, 0x8e, 0xca, 0x61, 0x7d, 0xd9, 0xf7, 0x6c, 0xd3, 0xae, 0x53, 0x46, 0x6a, 0x56, 0xe8,
	0x4d, 0x86, 0x11, 0x61, 0x04, 0x3d, 0x21, 0x99, 0x27, 0x25, 0xf3, 0xa4, 0x60, 0x9e, 0x6c, 0x67,
	0x2e, 0x94, 0x5c, 0x8f, 0x55, 0xeb, 0xcb, 0x93, 0x36, 0xa9, 0x95, 0x5d, 0xe2, 0x92, 0xb2, 0x60,
	0x5e, 0xae, 0xaf, 0x88, 0x5f, 0xe2, 0x87, 0xf8, 0x92, 0x42, 0x0b, 0x63, 0x2e, 0x21, 0xae, 0x8f,
	0xcb, 0x56, 0xe8, 0x95, 0xad, 0x20, 0x20, 0xcc, 0x62, 0x1e, 0x09, 0x68, 0x8c, 0x9d, 0x68, 0xb5,
	0xd7, 0x21, 0xd4, 0xac, 0x79, 0xcc, 0x73, 0x05, 0x51, 0x99, 0xad, 0x85, 0x38, 0xa1, 0x2c, 0xb4,
	0x52, 0xe2, 0x28, 0x22, 0xd1, 0x0e, 0x52, 0x7c, 0xe2, 0x96, 0x2d, 0xdb, 0xc6, 0x94, 0x9a, 0xfc,
	0x33, 0x2d, 0xe5, 0xe0, 0x56, 0xca, 0x34, 0xfa, 0x40, 0x2b, 0x9a, 0x84, 0x69, 0x5b, 0xf7, 0xb7,
	0x22, 0xd3, 0x7c, 0x63, 0x6d, 0x61, 0xb7, 0x7c, 0xcf, 0xb1, 0x18, 0x8e, 0xb1, 0x46, 0x1b, 0x16,
	0x53, 0x1c, 0xac, 0xb6, 0x09, 0x1f, 0xdf, 0x9a, 0x38, 0xb3, 0x95, 0xa2, 0xb3, 0xd4, 0xee, 0xe0,
	0xf7, 0x33, 0x1d, 0x31, 0xa7, 0x39, 0x4e, 0x6f, 0xcb, 0x41, 0x6a, 0x35, 0x12, 0x98, 0x14, 0xdb,
	0xf5, 0xc8, 0x63, 0x6b, 0x65, 0x59, 0x41, 0xa6, 0x15, 0x7a, 0x66, 0x9a, 0xf7, 0xc4, 0x3d, 0x78,
	0x6f, 0x5a, 0x2b, 0xa9, 0xcf, 0x34, 0x9b, 0xf1, 0x4b, 0x15, 0x16, 0x17, 0x3c, 0xdf, 0xb2, 0x67,
	0xce, 0x2d, 0x4e, 0x09, 0x3f, 0x16, 0x88, 0x4b, 0x2b, 0x98, 0x86, 0x24, 0xa0, 0xf8, 0x9c, 0xc5,
	0x2c, 0x34, 0x06, 0xf3, 0xcc, 0xab, 0x61, 0xca, 0xac, 0x5a, 0xa8, 0x83, 0x71, 0x30, 0x91, 0xaf,
	0x34, 0x01, 0xe8, 0x10, 0xec, 0xb7, 0x7d, 0x0f, 0x07, 0xcc, 0x0c, 0x49, 0xc4, 0x74, 0x45, 0xe0,
	0xa1, 0x04, 0x5d, 0x26, 0x11, 0x43, 0x08, 0x2a, 0x55, 0x42, 0x99, 0x9e, 0x13, 0x18, 0xf1, 0xcd,
	0x61, 0x75, 0x8a, 0x23, 0xbd, 0x57, 0xc2, 0xf8, 0x37, 0x1a, 0x85, 0xbd, 0xc2, 0x76, 0xac, 0xf7,
	0x09, 0x68, 0xfc, 0x8b, 0xc3, 0x6b, 0x98, 0x55, 0x89, 0xa3, 0xab, 0x12, 0x2e, 0x7f, 0x21, 0x1d,
	0xf6, 0x45, 0x78, 0x05, 0x47, 0x38, 0xd2, 0x07, 0x04, 0x22, 0xf9, 0x89, 0x1e, 0x87, 0x03, 0xb6,
	0x65, 0x57, 0xb1, 0x49, 0x99, 0xc5, 0xea, 0x54, 0xd7, 0x04, 0xba, 0x5f, 0xc0, 0x96, 0x04, 0x88,
	0x93, 0x44, 0xf8, 0x46, 0x1d, 0x53, 0x66, 0x72, 0x57, 0xf4, 0xc7, 0x24, 0x49, 0x0c, 0xbb, 0xea,
	0xd5, 0x30, 0x3a, 0x0c, 0x07, 0xeb, 0x21, 0x65, 0x11, 0xb6, 0x6a, 0xa6, 0xe5, 0x38, 0x91, 0x8e,
	0x04, 0xcd, 0x40, 0x02, 0x9c, 0x72, 0x9c, 0x08, 0x1d, 0x87, 0x23, 0x0d, 0x22, 0x9b, 0x04, 0x01,
	0xb6, 0x63, 0x81, 0xc3, 0x82, 0x78, 0x38, 0x41, 0xce, 0x48, 0x9c, 0x10, 0xfc, 0x3c, 0x1c, 0x6d,
	0xf0, 0x44, 0x71, 0xa0, 0x25, 0xd3, 0x5e, 0xc1, 0xb4, 0x37, 0xc1, 0x26, 0x59, 0x10, 0x5c, 0x4f,
	0xc1, 0x3d, 0x0d, 0xae, 0xd8, 0xaf, 0x11, 0x41, 0x3e, 0x94, 0x80, 0x9b, 0xae, 0xb9, 0x98, 0x98,
	0x3e, 0xb1, 0xc5, 0x82, 0xd6, 0x47, 0xa5, 0x6b, 0x2e, 0x26, 0x0b, 0x31, 0x08, 0xed, 0x83, 0x7d,
	0xb6, 0xc7, 0xd6, 0x4c, 0xcf, 0xd1, 0x75, 0x19, 0x53, 0xfe, 0x73, 0xce, 0xe1, 0xbc, 0x55, 0xc6,
	0x42, 0x73, 0x15, 0x47, 0x94, 0xf3, 0x16, 0x24, 0x2f, 0x87, 0xbd, 0x22, 0x41, 0x68, 0x3f, 0x54,
	0x23, 0x1a, 0x9a, 0xd4, 0x7b, 0x0d, 0xeb, 0x63, 0xe3, 0x60, 0x42, 0xa9, 0xf4, 0x45, 0x34, 0x5c,
	0xf2, 0x5e, 0xc3, 0x68, 0x04, 0xf6, 0xd2, 0xc8, 0x36, 0xbd, 0x50, 0x3f, 0x28, 0xf8, 0x72, 0x34,
	0xb2, 0xe7, 0x42, 0xc1, 0x81, 0x6f, 0x98, 0xa1, 0xc5, 0xaa, 0x7a, 0x31, 0xc9, 0xd4, 0x8d, 0xcb,
	0x16, 0xab, 0x26, 0xc2, 0x6c, 0xe2, 0x60, 0xfd, 0x50, 0x8c, 0xa2, 0xe1, 0x0c, 0x71, 0x30, 0x3a,
	0x08, 0x21, 0x2f, 0x0b, 0xd3, 0x72, 0x71, 0xc0, 0xf4, 0x71, 0x59, 0x76, 0x1c, 0x32, 0xc5, 0x01,
	0x68, 0x02, 0x6a, 0x5c, 0xa8, 0x4d, 0x02, 0xc6, 0x6b, 0x8f, 0x97, 0xb4, 0xfe, 0xb8, 0x8c, 0x47,
	0x84, 0x6f, 0xcc, 0x48, 0xf0, 0xd5, 0xb5, 0x10, 0x0b, 0x4a, 0xa1, 0x23, 0x45, 0x69, 0xc4, 0x94,
	0x5c, 0x57, 0x93, 0x52, 0x87, 0x7d, 0x36, 0xa9, 0x07, 0x2c, 0x5a, 0xd3, 0x0f, 0x4b, 0x63, 0xe2,
	0x9f, 0xe8, 0x00, 0xcc, 0x8b, 0x80, 0x05, 0x56, 0x0d, 0xeb, 0x4f, 0x08, 0x9c, 0xca, 0x01, 0x8b,
	0x56, 0x0d, 0x27, 0xfe, 0x89, 0x88, 0x3c, 0x19, 0x47, 0x04, 0xdf, 0x10, 0x11, 0x79, 0x02, 0x0e,
	0x25, 0xfe, 0x99, 0xb6, 0x6f, 0x51, 0xaa, 0xff, 0x8b, 0x2c, 0xa2, 0xd8, 0xcb, 0x19, 0x0e, 0xe3,
	0x4b, 0x88, 0xaf, 0x0a, 0xb3, 0x8a, 0x2d, 0x07, 0x47, 0xfa, 0x53, 0x72, 0x09, 0x71, 0xd0, 0x45,
	0x01, 0xe1, 0x04, 0xcc, 0xa7, 0x8d, 0xac, 0x4c, 0x48, 0x02, 0xe6, 0xd3, 0x24, 0x29, 0xfb, 0x60,
	0x1f, 0x27, 0xa0, 0x81, 0xa7, 0x3f, 0x2d, 0x13, 0xca, 0x7c, 0xba, 0x14, 0x78, 0xdc, 0x36, 0xde,
	0x71, 0x84, 0xdd, 0x47, 0x62, 0x9f, 0x9c, 0x40, 0x98, 0x7d, 0x00, 0xe6, 0xa9, 0xc7, 0xb0, 0xc4,
	0x1d, 0x95, 0x3e, 0x71, 0x00, 0x47, 0xce, 0x2b, 0x6a, 0x46, 0xcb, 0xce, 0x2b, 0x6a, 0x56, 0x53,
	0xe6, 0x15, 0x35, 0xaf, 0xc1, 0x79, 0x45, 0x85, 0x5a, 0xff, 0xbc, 0xa2, 0xf6, 0x6b, 0x03, 0xf3,
	0x8a, 0x3a, 0xa8, 0x0d, 0xcd, 0x2b, 0xea, 0x90, 0xb6, 0x67, 0x5e, 0x51, 0xf7, 0x68, 0xda, 0xbc,
	0xa2, 0xee, 0xd3, 0xf4, 0x79, 0x45, 0xdd, 0xaf, 0x15, 0xe6, 0x15, 0xf5, 0x80, 0x36, 0x66, 0xfc,
	0x30, 0x03, 0x87, 0x66, 0xce, 0x2d, 0x2e, 0x10, 0x37, 0x29, 0x63, 0xf4, 0x5f, 0x50, 0xf1, 0x89,
	0x4b, 0x75, 0x30, 0x9e, 0x9d, 0xe8, 0x3f, 0x7e, 0x6e, 0xb2, 0x93, 0xad, 0x6f, 0xf2, 0xde, 0xcd,
	0xa9, 0x22, 0x24, 0xf2, 0x62, 0x61, 0x84, 0x59, 0xbe, 0x59, 0xf5, 0x18, 0xd5, 0xb3, 0x22, 0x09,
	0x79, 0x01, 0xb9, 0xe8, 0x31, 0x8a, 0x2a, 0x50, 0xb1, 0x5c, 0x97, 0xea, 0x39, 0xa1, 0xf8, 0xa5,
	0xce, 0x14, 0xb7, 0x1a, 0x3f, 0x39, 0xe5, 0xba, 0x74, 0x96, 0x17, 0x43, 0x45, 0xc8, 0x2a, 0xfc,
	0x0f, 0xcc, 0x37, 0x40, 0x48, 0x83, 0xd9, 0xeb, 0x78, 0x2d, 0x6e, 0x8e, 0xfc, 0x13, 0x9d, 0x81,
	0xb9, 0x55, 0xcb, 0xaf, 0x63, 0x3d, 0x33, 0x0e, 0x26, 0xfa, 0x8f, 0x3f, 0xd9, 0xa6, 0xd3, 0x27,
	0xee, 0xe4, 0x02, 0x71, 0xa7, 0x5c, 0x37, 0xc2, 0x72, 0xe3, 0x15, 0xde, 0x48, 0x9e, 0xd3, 0x99,
	0x93, 0xc0, 0xf8, 0xa4, 0x02, 0x87, 0xd3, 0x6e, 0x57, 0x64, 0x6b, 0xe2, 0xdd, 0x98, 0x67, 0x8c,
	0x86, 0x96, 0x8d, 0x93, 0x6e, 0xdc, 0x00, 0xa0, 0x6b, 0x30, 0x77, 0xa3, 0x8e, 0xa3, 0x35, 0x3d,
	0x23, 0x5c, 0x3d, 0xd9, 0xb1, 0xab, 0x0d, 0x3d, 0xe7, 0x3d, 0x9f, 0xe1, 0x68, 0x1a, 0x7e, 0xff,
	0x77, 0x77, 0xb2, 0xb9, 0x37, 0x41, 0x46, 0x1b, 0xaf, 0x48, 0x91, 0x3c, 0xc8, 0x94, 0x59, 0x51,
	0xdc, 0xe0, 0xb2, 0x52, 0xb5, 0x80, 0x88, 0x06, 0xb5, 0x1f, 0xaa, 0x38, 0x70, 0x24, 0x52, 0xee,
	0x02, 0x7d, 0x38, 0x70, 0x04, 0xea, 0x18, 0x54, 0x28, 0xdf, 0x1c, 0xf8, 0x16, 0x30, 0x74, 0x5c,
	0x6f, 0x33, 0x6a, 0x89, 0x44, 0xec, 0x52, 0xe4, 0xe0, 0xa8, 0x22, 0xa8, 0xd0, 0x38, 0xcc, 0xf9,
	0x5e, 0xcd, 0x63, 0x62, 0x77, 0x18, 0x8c, 0x2d, 0x39, 0x92, 0xd5, 0xff, 0x98, 0xad, 0x48, 0x04,
	0xa2, 0x71, 0x3e, 0xfb, 0x84, 0x93, 0x33, 0xbb, 0x77, 0x32, 0x0e, 0x66, 0x33, 0xa9, 0xd3, 0x05,
	0xae, 0xa5, 0xff, 0x6d, 0xa0, 0x1a, 0xbd, 0x91, 0xa2, 0x01, 0xfd, 0xac, 0xd0, 0xfa, 0x36, 0xc8,
	0x68, 0x5a, 0x9c, 0x70, 0x76, 0xef, 0x84, 0x5f, 0x69, 0x4d, 0xf8, 0x99, 0xce, 0x8d, 0x6a, 0xd6,
	0x40, 0x6c, 0x56, 0xba, 0x0c, 0xfe, 0x02, 0xe0, 0x7e, 0x59, 0x89, 0x2d, 0x74, 0xf1, 0x8a, 0x6a,
	0xad, 0x7b, 0xd0, 0x5e, 0xf7, 0xff, 0x1d, 0xc7, 0x49, 0x16, 0xc3, 0xdc, 0x6e, 0xea, 0x7e, 0x1b,
	0x6d, 0x8f, 0x7c, 0x09, 0xfc, 0x28, 0x0b, 0x8b, 0xe9, 0xac, 0x6d, 0x8d, 0xd4, 0x7d, 0x56, 0xc3,
	0xe2, 0x43, 0x5a, 0x0d, 0x0f, 0xbe, 0x02, 0x3e, 0xd1, 0xd2, 0x81, 0x16, 0x77, 0x6f, 0xc8, 0x56,
	0xdf, 0xff, 0x09, 0x8a, 0xf7, 0xad, 0x0c, 0x1c, 0xd9, 0x96, 0x08, 0x61, 0xa8, 0xf1, 0x61, 0xdd,
	0xb4, 0x9a, 0xa8, 0x58, 0x77, 0xe7, 0x49, 0x3a, 0x67, 0x31, 0x9c, 0x12, 0x7d, 0xb1, 0xa7, 0xb2,
	0xc7, 0x69, 0x05, 0xa1, 0x2a, 0x7c, 0x6c, 0xc5, 0xc3, 0xbe, 0xd3, 0xa2, 0x27, 0x2b, 0xf4, 0x9c,
	0xea, 0x58, 0xcf, 0x79, 0x2e, 0xa1, 0x55, 0x91, 0xb6, 0xd2, 0x06, 0x3b, 0xdd, 0xfb, 0xd3, 0x75,
	0x90, 0xd1, 0xc0, 0xf4, 0x18, 0xd4, 0x52, 0xba, 0xc4, 0xb4, 0x81, 0xd4, 0x3b, 0xeb, 0x20, 0xb3,
	0xb1, 0x0e, 0xc0, 0xbc, 0xa2, 0x02, 0x2d, 0x63, 0x7c, 0x03, 0x88, 0xb0, 0x70, 0xfb, 0x97, 0xea,
	0xcb, 0xf7, 0xb5, 0x17, 0xfc, 0x23, 0xec, 0x05, 0x1b, 0xeb, 0x20, 0x23, 0xc7, 0x00, 0xe3, 0x9d,
	0x0c, 0x44, 0x5b, 0xe3, 0xcd, 0x87, 0x78, 0xca, 0x70, 0x72, 0x24, 0x10, 0xdf, 0xe8, 0xff, 0xa1,
	0x4a, 0xeb, 0xcb, 0x66, 0xaa, 0xeb, 0xcc, 0x76, 0x9b, 0xcf, 0x49, 0x19, 0x9b, 0x0e, 0x4a, 0xbc,
	0x8f, 0x4a, 0xca, 0xc2, 0x4d, 0x38, 0x90, 0x66, 0x7a, 0x98, 0x85, 0xbe, 0x35, 0x59, 0xe9, 0x42,
	0xff, 0x54, 0x56, 0x6c, 0xd6, 0xed, 0x91, 0x47, 0xaf, 0xc0, 0x9c, 0x88, 0xbc, 0x30, 0x61, 0xe8,
	0xf8, 0xd9, 0xce, 0xd4, 0x35, 0xcf, 0x93, 0x2d, 0x2d, 0xe0, 0xaa, 0xe5, 0x56, 0xa4, 0x38, 0x74,
	0x10, 0x2a, 0x8c, 0x84, 0xd7, 0x85, 0x17, 0x83, 0xd3, 0x79, 0x1e, 0x0b, 0xe5, 0x48, 0x46, 0x77,
	0x2a, 0x02, 0x8c, 0x5e, 0x4f, 0x65, 0x21, 0x2b, 0xb2, 0x70, 0xbe, 0xeb, 0xea, 0xe9, 0x22, 0x0d,
	0xb7, 0xee, 0x9b, 0x86, 0x4a, 0x6b, 0x1a, 0x5e, 0xdc, 0x9d, 0x75, 0x3b, 0xe7, 0xe1, 0x5d, 0x00,
	0x47, 0xb7, 0xa7, 0x42, 0x78, 0xe7, 0xa5, 0xf5, 0xaf, 0x9d, 0xa9, 0x7f, 0xe8, 0xeb, 0xea, 0x73,
	0x00, 0x6a, 0x8f, 0xac, 0x64, 0x8c, 0x96, 0x92, 0x19, 0xfa, 0xd5, 0x3a, 0x00, 0x27, 0xda, 0xea,
	0xc6, 0xf8, 0xac, 0x5c, 0xe8, 0x6d, 0xbb, 0x1f, 0xaa, 0xc0, 0x2c, 0xb3, 0xdc, 0x87, 0x66, 0x10,
	0x17, 0x86, 0xce, 0xc0, 0x5e, 0x91, 0x36, 0xd9, 0x26, 0xf2, 0xd3, 0x87, 0xb9, 0x2d, 0xf0, 0x4d,
	0xd0, 0x67, 0xe4, 0xa2, 0xac, 0x7e, 0x1b, 0x34, 0xc7, 0xcf, 0xe4, 0x4b, 0x07, 0x95, 0x98, 0x05,
	0x5d, 0x83, 0x2a, 0x09, 0x71, 0x64, 0x31, 0x12, 0x89, 0x6e, 0x3e, 0xb4, 0x8b, 0x99, 0xbe, 0x61,
	0xca, 0xa5, 0x58, 0x02, 0x3f, 0xfa, 0x55, 0x1a, 0xf2, 0x92, 0x04, 0x1a, 0x5f, 0xcd, 0xc2, 0xd1,
	0xe4, 0xec, 0xf1, 0xef, 0x98, 0x45, 0x9e, 0x4d, 0x3b, 0x1b, 0x3a, 0xee, 0x33, 0x24, 0x24, 0x5d,
	0x53, 0x49, 0x75, 0xcd, 0xf4, 0xe0, 0x90, 0x6b, 0x1d, 0x1c, 0xea, 0x70, 0x48, 0x96, 0x2d, 0xc5,
	0x3e, 0xb6, 0xb9, 0xc3, 0xbd, 0xe3, 0xd9, 0x89, 0xa1, 0xe3, 0xd3, 0xbb, 0x3b, 0x3d, 0xc5, 0x1e,
	0xc8, 0x85, 0x11, 0x4b, 0x4a, 0xcd, 0xf8, 0xb0, 0x32, 0xb8, 0x92, 0x46, 0xa1, 0x25, 0xd8, 0xbb,
	0x22, 0x92, 0x1f, 0xcf, 0xd8, 0x67, 0xba, 0x54, 0x27, 0xa6, 0xa7, 0x58, 0x14, 0x5a, 0x82, 0xaa,
	0x1b, 0x91, 0x7a, 0x68, 0x2e, 0xaf, 0xe9, 0xaa, 0xf0, 0xe2, 0x64, 0x57, 0x62, 0x79, 0x11, 0xf5,
	0x09, 0x49, 0xd3, 0x6b, 0xc6, 0xa7, 0x01, 0xdc, 0xb7, 0x25, 0x4f, 0xf1, 0x78, 0xfc, 0x9f, 0x30,
	0xe7, 0x31, 0x5c, 0x4b, 0x4e, 0x9c, 0x53, 0x5d, 0x69, 0x6b, 0x39, 0x6e, 0x4a, 0x79, 0x8d, 0x24,
	0x66, 0x9a, 0x49, 0x34, 0x7e, 0x9f, 0x85, 0xfb, 0x13, 0xd6, 0x19, 0xcb, 0xae, 0xe2, 0xcb, 0xf5,
	0xc8, 0xc5, 0x49, 0xcd, 0x18, 0x5b, 0x6a, 0x66, 0x5a, 0xf9, 0x68, 0x1d, 0x80, 0x74, 0xe5, 0xe8,
	0x50, 0x11, 0x87, 0xf1, 0x4c, 0x0a, 0x2d, 0x20, 0xe8, 0x24, 0x1c, 0x09, 0xb9, 0x34, 0x13, 0x87,
	0xc4, 0xae, 0x9a, 0xcd, 0xeb, 0xb8, 0x6c, 0x8a, 0x74, 0x58, 0x90, 0xcc, 0x72, 0x8a, 0xab, 0x8d,
	0xeb, 0xb9, 0xe7, 0x60, 0x5e, 0x72, 0x5a, 0xbe, 0xaf, 0xe7, 0x45, 0xbb, 0xdb, 0xdb, 0x16, 0x86,
	0xd9, 0x5a, 0xc8, 0xd6, 0x2e, 0xf6, 0x54, 0x54, 0x41, 0x38, 0xe5, 0xfb, 0x08, 0xc1, 0x6c, 0x3d,
	0xf2, 0x75, 0xc8, 0x85, 0x5f, 0xec, 0xa9, 0xf0, 0x1f, 0x68, 0x02, 0xaa, 0x55, 0x42, 0x99, 0x30,
	0xb0, 0x5f, 0x68, 0x95, 0xe5, 0x13, 0x65, 0x3f, 0x93, 0x01, 0x9c, 0x3b, 0xc1, 0xa2, 0xa3, 0xb0,
	0x2f, 0xb4, 0x18, 0xc3, 0x51, 0x20, 0x8b, 0x7c, 0x7a, 0x8f, 0x58, 0xdb, 0x91, 0xaa, 0x01, 0xfd,
	0x76, 0xe6, 0x0e, 0xe0, 0xd4, 0x09, 0x05, 0x3a, 0x01, 0x21, 0x25, 0x2b, 0xcc, 0x14, 0xba, 0xc5,
	0x89, 0x6f, 0x27, 0x03, 0x41, 0x25, 0xcf, 0x29, 0x45, 0x54, 0x39, 0x5b, 0xd5, 0x8a, 0x9c, 0x98,
	0xad, 0xef, 0xde, 0x6c, 0x9c, 0x52, 0xb0, 0x4d, 0x3f, 0x09, 0x07, 0x62, 0xc5, 0xb2, 0x23, 0x8f,
	0xdc, 0x59, 0x07, 0xf9, 0x8d, 0x75, 0xa0, 0x6e, 0xae, 0x83, 0xfc, 0xa9, 0x63, 0xcf, 0x3e, 0x73,
	0xec, 0xd9, 0x67, 0x8f, 0x3d, 0x3f, 0x3d, 0x0a, 0xa1, 0x0c, 0x5a, 0xa3, 0x6d, 0xf7, 0x6e, 0xac,
	0x83, 0xdc, 0xbc, 0xa2, 0xaa, 0x5a, 0x7e, 0x5e, 0x51, 0x73, 0x5a, 0xaf, 0x71, 0x1e, 0x16, 0xb6,
	0xcb, 0x76, 0x5c, 0x79, 0x13, 0x50, 0x93, 0x12, 0x92, 0x5b, 0x46, 0x4f, 0x36, 0xf4, 0xc1, 0xca,
	0x50, 0x98, 0x2a, 0x8b, 0x39, 0xc7, 0x40, 0x50, 0x5b, 0xaa, 0x2f, 0x53, 0x3b, 0xf2, 0x96, 0x13,
	0xa8, 0x31, 0x0c, 0x1f, 0x4b, 0xc1, 0xa4, 0x48, 0x63, 0x2f, 0x44, 0xff, 0x11, 0xd0, 0x76, 0xd2,
	0x11, 0x38, 0xdc, 0x02, 0x8d, 0x89, 0x6f, 0x03, 0x38, 0x7a, 0x01, 0xb3, 0x25, 0x1c, 0xad, 0x7a,
	0x36, 0x96, 0xad, 0x4e, 0x8e, 0xdf, 0xdb, 0x56, 0xe2, 0x9f, 0xd7, 0x41, 0xcf, 0x3d, 0x2a, 0x51,
	0xa0, 0x65, 0x25, 0x4e, 0xc0, 0x41, 0x2a, 0x85, 0x9a, 0x24, 0xe4, 0x5e, 0x65, 0xc5, 0x7e, 0x22,
	0x49, 0xfa, 0x69, 0xa2, 0x6f, 0xce, 0x31, 0xbe, 0x99, 0x81, 0x48, 0x04, 0xa5, 0xa1, 0x7d, 0x8e,
	0xe1, 0x9a, 0x58, 0x3a, 0x1e, 0xc3, 0x8d, 0xa9, 0xd1, 0x63, 0x18, 0x3d, 0xdd, 0x88, 0xb7, 0xd7,
	0x50, 0x9a, 0x54, 0xd7, 0x17, 0x15, 0x50, 0x91, 0x25, 0x2c, 0xfa, 0xe1, 0x28, 0xec, 0x8d, 0xb0,
	0x8b, 0x6f, 0xc5, 0xa5, 0x5f, 0x89, 0x7f, 0x71, 0x11, 0xa9, 0xae, 0xab, 0x6c, 0x15, 0xd1, 0xec,
	0xc0, 0x47, 0x61, 0xff, 0x8a, 0x17, 0x78, 0xb4, 0x9a, 0x6a, 0xb8, 0x2d, 0xb4, 0x50, 0xa2, 0x05,
	0xf1, 0xc1, 0x96, 0x42, 0xe3, 0xf5, 0xa9, 0xa6, 0x0a, 0x0a, 0x3d, 0x0e, 0x07, 0x96, 0xd7, 0x18,
	0xa6, 0x12, 0xef, 0x88, 0x4a, 0x54, 0x2a, 0xfd, 0x02, 0x26, 0x28, 0x1c, 0x5e, 0x0a, 0x92, 0x24,
	0x20, 0x2c, 0x21, 0x53, 0x05, 0xd9, 0x90, 0x80, 0x2f, 0x12, 0x59, 0xd3, 0x8e, 0xf1, 0x63, 0x00,
	0xf7, 0xb6, 0x67, 0x4c, 0xc4, 0xcc, 0x68, 0x0f, 0xba, 0x2c, 0xa5, 0x74, 0xb8, 0xc5, 0xf5, 0xb9,
	0xbc, 0x16, 0xce, 0xc4, 0xd7, 0xe7, 0xf2, 0x3a, 0xf8, 0x32, 0xcc, 0x49, 0xdb, 0x95, 0xdd, 0x1c,
	0xaf, 0xb6, 0x26, 0xee, 0x62, 0x4f, 0x45, 0x0a, 0x9a, 0x1e, 0x81, 0x79, 0x12, 0xc6, 0x77, 0xd0,
	0x62, 0x71, 0x28, 0x1b, 0xeb, 0x20, 0xbe, 0x2c, 0x34, 0xde, 0xde, 0xa1, 0xf0, 0x68, 0x88, 0x26,
	0x61, 0x4e, 0xbc, 0x20, 0xc5, 0x53, 0x57, 0xfb, 0x35, 0xd0, 0x2c, 0xc7, 0x89, 0xcd, 0x58, 0x92,
	0x71, 0xcb, 0x65, 0xf7, 0x96, 0x07, 0x89, 0xd3, 0x9d, 0x59, 0xbe, 0x5d, 0x00, 0xe3, 0xb6, 0x6d,
	0x30, 0x58, 0x68, 0x47, 0x53, 0x9e, 0xe5, 0x8a, 0x15, 0xb8, 0xf8, 0xef, 0x55, 0x42, 0xc6, 0x5f,
	0x01, 0xd4, 0x17, 0x3c, 0xba, 0x25, 0x26, 0xf4, 0xc1, 0x57, 0xa3, 0x0b, 0x21, 0x37, 0xc0, 0x8c,
	0xb8, 0x03, 0x71, 0x86, 0xcf, 0x76, 0x17, 0xa7, 0x66, 0x20, 0xa4, 0x86, 0x8b, 0x3d, 0xf2, 0x95,
	0x47, 0xc6, 0x66, 0x0c, 0xe6, 0x7c, 0x8b, 0xb2, 0x40, 0xb8, 0x3a, 0xd8, 0xa0, 0x90, 0xc0, 0xe9,
	0x61, 0xd8, 0x17, 0xbf, 0x9b, 0x89, 0x7a, 0xc8, 0xa5, 0xea, 0xe1, 0x07, 0x00, 0x8e, 0x6c, 0x51,
	0xd5, 0x71, 0x51, 0x1f, 0x82, 0xfd, 0x74, 0xd5, 0x6e, 0x5c, 0x7c, 0x8b, 0xd9, 0xb5, 0x02, 0xe9,
	0xaa, 0x9d, 0x5c, 0x7c, 0x97, 0xe0, 0x80, 0x1d, 0x61, 0x8b, 0x61, 0x27, 0x35, 0x6e, 0xb5, 0x64,
	0xa2, 0x3f, 0xc6, 0x8b, 0xbc, 0x95, 0xe1, 0x60, 0x8d, 0x38, 0xde, 0x8a, 0x87, 0x9d, 0x9d, 0xb2,
	0x3c, 0x90, 0x10, 0x88, 0xdc, 0x7d, 0x69, 0xc7, 0xdc, 0x75, 0x51, 0xd0, 0x57, 0x5a, 0x0b, 0xfa,
	0x4c, 0x97, 0x89, 0x4a, 0x55, 0xf4, 0x91, 0x2a, 0xd4, 0x77, 0x9a, 0x69, 0xd1, 0x61, 0x78, 0x68,
	0xe6, 0xdc, 0xa2, 0x39, 0x35, 0x33, 0x33, 0xbb, 0xb4, 0x64, 0x2e, 0x5c, 0xba, 0x60, 0x5e, 0xba,
	0x3c, 0x5b, 0x99, 0xba, 0x7a, 0xa9, 0x62, 0x5e, 0x7d, 0xf5, 0xf2, 0xac, 0x39, 0xb7, 0xa8, 0xf5,
	0xa0, 0xa7, 0xe0, 0xe1, 0x7b, 0x12, 0x2d, 0x5e, 0xba, 0xca, 0x09, 0xc1, 0xf1, 0x9f, 0x0c, 0xc3,
	0xfc, 0x8c, 0x78, 0x7a, 0x9c, 0xba, 0x3c, 0x87, 0xde, 0xcd, 0x40, 0xd8, 0x1c, 0x91, 0xd0, 0x8b,
	0x5d, 0x4e, 0x56, 0x62, 0x0f, 0x2b, 0xfc, 0xdb, 0x03, 0xcd, 0x65, 0xc6, 0x3b, 0x60, 0xf3, 0x3d,
	0xfd, 0xd5, 0x55, 0x4c, 0x4b, 0x1e, 0x29, 0x85, 0x11, 0xb9, 0xb5, 0x56, 0x8a, 0xb0, 0xe5, 0x1c,
	0x1b, 0x5f, 0x39, 0x71, 0xcb, 0x2e, 0xd9, 0x4e, 0x50, 0x5a, 0xb6, 0xa8, 0x67, 0x97, 0x6a, 0x24,
	0xf0, 0x18, 0x89, 0x12, 0xb8, 0x7c, 0xf8, 0x29, 0x39, 0xd8, 0xf7, 0x56, 0x71, 0xb4, 0x56, 0x0a,
	0x30, 0xbb, 0x49, 0xa2, 0xeb, 0x25, 0xca, 0xac, 0xc0, 0xb1, 0x22, 0x27, 0xa1, 0x7f, 0xe3, 0x17,
	0xbf, 0xfd, 0x42, 0xe6, 0x45, 0xe3, 0x85, 0xf8, 0x05, 0xbf, 0xdc, 0x58, 0x97, 0xb4, 0xfc, 0x7f,
	0x8d, 0xef, 0xd7, 0xb7, 0x3e, 0xec, 0xd6, 0xa4, 0x99, 0xa7, 0xc1, 0x11, 0xf4, 0xbd, 0x0c, 0x1c,
	0x6c, 0x99, 0x13, 0xd0, 0xcb, 0xbb, 0x73, 0x79, 0xcb, 0x3c, 0x59, 0x38, 0xdb, 0xbd, 0x80, 0x38,
	0x6c, 0x5f, 0xe1, 0x61, 0x5b, 0xba, 0x7f, 0xd8, 0xea, 0x14, 0x77, 0x1e, 0x33, 0x4e, 0x2c, 0x02,
	0x76, 0xc1, 0x98, 0xde, 0x6d, 0xc0, 0x04, 0xf2, 0xf5, 0xb2, 0x78, 0xa6, 0x2d, 0x89, 0xad, 0x86,
	0xc7, 0xee, 0x0f, 0x00, 0xe6, 0x1b, 0xc3, 0x10, 0xea, 0xf0, 0xa8, 0xde, 0x3e, 0x51, 0x15, 0x5e,
	0xd8, 0x35, 0x5f, 0x1c, 0xa5, 0x1b, 0x9b, 0xef, 0xe9, 0x65, 0xe1, 0xfc, 0xb2, 0xe7, 0xfb, 0x5e,
	0xe0, 0x1e, 0x1b, 0x5f, 0x25, 0x3e, 0xb3, 0x49, 0x40, 0x89, 0x8f, 0x45, 0x98, 0xe2, 0xe9, 0x4b,
	0x34, 0xc0, 0x52, 0xcd, 0xad, 0x31, 0x11, 0x80, 0x93, 0xc6, 0x73, 0xdb, 0x04, 0x80, 0xae, 0x51,
	0x86, 0x6b, 0x65, 0x9f, 0xa7, 0x85, 0x33, 0x97, 0x2d, 0xc7, 0x21, 0x41, 0xb9, 0x31, 0xc0, 0x71,
	0x8f, 0xff, 0x04, 0x60, 0x7f, 0x6a, 0xa6, 0x43, 0x1d, 0x6e, 0xd9, 0x5b, 0x87, 0xc3, 0xc2, 0xa9,
	0x2e, 0x38, 0x63, 0xbf, 0x69, 0xb7, 0x7e, 0x9f, 0x36, 0x4e, 0x74, 0xee, 0x77, 0x3d, 0x68, 0xf1,
	0xfc, 0x6b, 0x72, 0x9d, 0x34, 0x9f, 0xfa, 0xd0, 0xa9, 0xae, 0xdf, 0x76, 0x0a, 0xcf, 0x77, 0xf3,
	0xcc, 0x67, 0x7c, 0xf9, 0x11, 0x34, 0x93, 0xb3, 0xc6, 0x99, 0xdd, 0xae, 0x8d, 0xe6, 0x75, 0x8a,
	0x68, 0x28, 0xbf, 0xce, 0xc0, 0xb1, 0x1d, 0x5e, 0x07, 0xae, 0x88, 0x97, 0x8a, 0x73, 0x0f, 0xe3,
	0x85, 0xa1, 0xf0, 0xf2, 0x03, 0xbe, 0x18, 0x19, 0xdf, 0x02, 0xef, 0x7f, 0x37, 0xf3, 0x08, 0x22,
	0xba, 0x60, 0x5c, 0x78, 0x80, 0x88, 0x96, 0x53, 0x37, 0x75, 0x3c, 0xba, 0x1b, 0x19, 0x38, 0xb2,
	0xed, 0xa6, 0x8f, 0x5e, 0xea, 0xb4, 0xeb, 0x6e, 0x3f, 0xed, 0x15, 0x1e, 0x88, 0x9f, 0x86, 0xc6,
	0x77, 0x1e, 0x41, 0x2c, 0x97, 0x8c, 0xc5, 0xdd, 0xc6, 0xd2, 0xf7, 0x28, 0x2b, 0xc5, 0x73, 0x5b,
	0x89, 0x34, 0x2c, 0x2e, 0xc9, 0x33, 0x02, 0x0f, 0xe9, 0xfb, 0x19, 0x38, 0xbc, 0xcd, 0xb1, 0xa0,
	0xd3, 0xc1, 0x61, 0xfb, 0xa3, 0x6c, 0xe1, 0x01, 0xb8, 0x69, 0x68, 0x7c, 0xfb, 0x11, 0x04, 0xf3,
	0x8a, 0xb1, 0xb0, 0xdb, 0x60, 0xba, 0x78, 0x9b, 0x58, 0x36, 0x43, 0x59, 0x38, 0x7d, 0x67, 0x1d,
	0x64, 0x7f, 0xbe, 0x0e, 0x8e, 0x76, 0xe4, 0xfb, 0xa5, 0xe5, 0xff, 0xc5, 0x36, 0x7b, 0xe3, 0x67,
	0x7a, 0xf6, 0x0e, 0x00, 0xd3, 0x6f, 0x81, 0x8d, 0x0f, 0x8b, 0x3d, 0x1f, 0x7c, 0x58, 0xec, 0xf9,
	0xf8, 0xc3, 0x22, 0xb8, 0xbd, 0x59, 0x04, 0x5f, 0xdf, 0x2c, 0x82, 0xf7, 0x37, 0x8b, 0x60, 0x63,
	0xb3, 0x08, 0x7e, 0xb3, 0x59, 0x04, 0x1f, 0x6d, 0x16, 0x7b, 0x3e, 0xde, 0x2c, 0x82, 0xcf, 0xdf,
	0x2d, 0xf6, 0xdc, 0xb9, 0x5b, 0x04, 0x1b, 0x77, 0x8b, 0x3d, 0x1f, 0xdc, 0x2d, 0xf6, 0x5c, 0xbb,
	0xe6, 0x92, 0xf0, 0xba, 0x3b, 0xc9, 0x37, 0x01, 0x1c, 0x45, 0xd6, 0x64, 0x9d, 0x96, 0xc5, 0xc7,
	0x0a, 0x89, 0x6a, 0x3c, 0x7a, 0xab, 0x9e, 0x83, 0xa3, 0x52, 0x82, 0x2e, 0x87, 0xcb, 0x2e, 0x29,
	0xe3, 0x5b, 0x2c, 0xfe, 0x3b, 0xda, 0x3d, 0xff, 0x03, 0xb7, 0xdc, 0x2b, 0xfe, 0x8b, 0xf6, 0xdc,
	0xdf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x35, 0x06, 0x19, 0xe8, 0x4a, 0x29, 0x00, 0x00,
}

func (x CDNAccessLogOperatorType) String() string {
	s, ok := CDNAccessLogOperatorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *LilacCDNAccessLogsResponseData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNAccessLogsResponseData)
	if !ok {
		that2, ok := that.(LilacCDNAccessLogsResponseData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.ClientPort != that1.ClientPort {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.Scheme != that1.Scheme {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	if this.Referer != that1.Referer {
		return false
	}
	if this.CacheStatus != that1.CacheStatus {
		return false
	}
	if this.RequestTime != that1.RequestTime {
		return false
	}
	if this.UpstreamAddr != that1.UpstreamAddr {
		return false
	}
	if this.UpstreamConnectTime != that1.UpstreamConnectTime {
		return false
	}
	if this.UpstreamResponseTime != that1.UpstreamResponseTime {
		return false
	}
	if this.UpstreamStatus != that1.UpstreamStatus {
		return false
	}
	if this.GeoLocation != that1.GeoLocation {
		return false
	}
	if this.CityId != that1.CityId {
		return false
	}
	if this.HttpVersion != that1.HttpVersion {
		return false
	}
	if this.RspSize != that1.RspSize {
		return false
	}
	if this.SrcIp != that1.SrcIp {
		return false
	}
	if this.ReqPath != that1.ReqPath {
		return false
	}
	if this.RspCode != that1.RspCode {
		return false
	}
	if this.UserAgent != that1.UserAgent {
		return false
	}
	if this.ReqContentType != that1.ReqContentType {
		return false
	}
	if this.RspContentType != that1.RspContentType {
		return false
	}
	if this.Country != that1.Country {
		return false
	}
	if this.CityName != that1.CityName {
		return false
	}
	if this.ReqSize != that1.ReqSize {
		return false
	}
	if this.RspCodeClass != that1.RspCodeClass {
		return false
	}
	if this.HostHeader != that1.HostHeader {
		return false
	}
	if this.TlsVersion != that1.TlsVersion {
		return false
	}
	if this.TlsSni != that1.TlsSni {
		return false
	}
	if this.CdnName != that1.CdnName {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	return true
}
func (this *CDNLogResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNLogResponse)
	if !ok {
		that2, ok := that.(CDNLogResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Logs) != len(that1.Logs) {
		return false
	}
	for i := range this.Logs {
		if !this.Logs[i].Equal(that1.Logs[i]) {
			return false
		}
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *CDNAccessLogRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNAccessLogRequest)
	if !ok {
		that2, ok := that.(CDNAccessLogRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Query) != len(that1.Query) {
		return false
	}
	for i := range this.Query {
		if !this.Query[i].Equal(that1.Query[i]) {
			return false
		}
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *CDNLogAggregationResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNLogAggregationResponse)
	if !ok {
		that2, ok := that.(CDNLogAggregationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *CDNAccessLogAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNAccessLogAggregationRequest)
	if !ok {
		that2, ok := that.(CDNAccessLogAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Query) != len(that1.Query) {
		return false
	}
	for i := range this.Query {
		if !this.Query[i].Equal(that1.Query[i]) {
			return false
		}
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *CDNAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNAggregationRequest)
	if !ok {
		that2, ok := that.(CDNAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AggregationType == nil {
		if this.AggregationType != nil {
			return false
		}
	} else if this.AggregationType == nil {
		return false
	} else if !this.AggregationType.Equal(that1.AggregationType) {
		return false
	}
	return true
}
func (this *CDNAggregationRequest_DateAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNAggregationRequest_DateAggregation)
	if !ok {
		that2, ok := that.(CDNAggregationRequest_DateAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DateAggregation.Equal(that1.DateAggregation) {
		return false
	}
	return true
}
func (this *CDNAggregationRequest_FieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNAggregationRequest_FieldAggregation)
	if !ok {
		that2, ok := that.(CDNAggregationRequest_FieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FieldAggregation.Equal(that1.FieldAggregation) {
		return false
	}
	return true
}
func (this *CDNDateSubAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNDateSubAggregation)
	if !ok {
		that2, ok := that.(CDNDateSubAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AggregationType == nil {
		if this.AggregationType != nil {
			return false
		}
	} else if this.AggregationType == nil {
		return false
	} else if !this.AggregationType.Equal(that1.AggregationType) {
		return false
	}
	return true
}
func (this *CDNDateSubAggregation_FieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNDateSubAggregation_FieldAggregation)
	if !ok {
		that2, ok := that.(CDNDateSubAggregation_FieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FieldAggregation.Equal(that1.FieldAggregation) {
		return false
	}
	return true
}
func (this *CDNDateAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNDateAggregation)
	if !ok {
		that2, ok := that.(CDNDateAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Step != that1.Step {
		return false
	}
	if len(this.SubAggs) != len(that1.SubAggs) {
		return false
	}
	for i := range this.SubAggs {
		if !this.SubAggs[i].Equal(that1.SubAggs[i]) {
			return false
		}
	}
	return true
}
func (this *CDNFieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNFieldAggregation)
	if !ok {
		that2, ok := that.(CDNFieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Field != that1.Field {
		return false
	}
	if this.Topk != that1.Topk {
		return false
	}
	if len(this.SubAggs) != len(that1.SubAggs) {
		return false
	}
	for i := range this.SubAggs {
		if !this.SubAggs[i].Equal(that1.SubAggs[i]) {
			return false
		}
	}
	return true
}
func (this *CDNFieldSubAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNFieldSubAggregation)
	if !ok {
		that2, ok := that.(CDNFieldSubAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AggregationType == nil {
		if this.AggregationType != nil {
			return false
		}
	} else if this.AggregationType == nil {
		return false
	} else if !this.AggregationType.Equal(that1.AggregationType) {
		return false
	}
	return true
}
func (this *CDNFieldSubAggregation_FieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNFieldSubAggregation_FieldAggregation)
	if !ok {
		that2, ok := that.(CDNFieldSubAggregation_FieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FieldAggregation.Equal(that1.FieldAggregation) {
		return false
	}
	return true
}
func (this *FieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldAggregation)
	if !ok {
		that2, ok := that.(FieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Field != that1.Field {
		return false
	}
	if this.Topk != that1.Topk {
		return false
	}
	return true
}
func (this *CDNAccessLogFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNAccessLogFilter)
	if !ok {
		that2, ok := that.(CDNAccessLogFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tag != that1.Tag {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	if this.Operator != that1.Operator {
		return false
	}
	return true
}
func (this *LilacCDNMetricsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsRequest)
	if !ok {
		that2, ok := that.(LilacCDNMetricsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.Step != that1.Step {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.FieldSelector) != len(that1.FieldSelector) {
		return false
	}
	for i := range this.FieldSelector {
		if this.FieldSelector[i] != that1.FieldSelector[i] {
			return false
		}
	}
	if len(this.Filter) != len(that1.Filter) {
		return false
	}
	for i := range this.Filter {
		if !this.Filter[i].Equal(that1.Filter[i]) {
			return false
		}
	}
	if len(this.GroupBy) != len(that1.GroupBy) {
		return false
	}
	for i := range this.GroupBy {
		if this.GroupBy[i] != that1.GroupBy[i] {
			return false
		}
	}
	return true
}
func (this *LilacCDNMetricsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsResponse)
	if !ok {
		that2, ok := that.(LilacCDNMetricsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	if this.Step != that1.Step {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.PurgeEpochTimestamp != that1.PurgeEpochTimestamp {
		return false
	}
	if that1.PatternType == nil {
		if this.PatternType != nil {
			return false
		}
	} else if this.PatternType == nil {
		return false
	} else if !this.PatternType.Equal(that1.PatternType) {
		return false
	}
	if that1.PurgeType == nil {
		if this.PurgeType != nil {
			return false
		}
	} else if this.PurgeType == nil {
		return false
	} else if !this.PurgeType.Equal(that1.PurgeType) {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_PurgeAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_PurgeAll)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_PurgeAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PurgeAll.Equal(that1.PurgeAll) {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_Url) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_Url)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_Url)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_Hostname) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_Hostname)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_Hostname)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_Pattern) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_Pattern)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_Pattern)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pattern != that1.Pattern {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_SoftPurge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_SoftPurge)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_SoftPurge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SoftPurge.Equal(that1.SoftPurge) {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_HardPurge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_HardPurge)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_HardPurge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HardPurge.Equal(that1.HardPurge) {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeResponse)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PurgeRequestId != that1.PurgeRequestId {
		return false
	}
	return true
}
func (this *SubscribeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubscribeRequest)
	if !ok {
		that2, ok := that.(SubscribeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SubscribeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubscribeResponse)
	if !ok {
		that2, ok := that.(SubscribeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *UnsubscribeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UnsubscribeRequest)
	if !ok {
		that2, ok := that.(UnsubscribeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *UnsubscribeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UnsubscribeResponse)
	if !ok {
		that2, ok := that.(UnsubscribeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetServiceOperationReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetServiceOperationReq)
	if !ok {
		that2, ok := that.(GetServiceOperationReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ServiceOpId != that1.ServiceOpId {
		return false
	}
	return true
}
func (this *PurgeOperationItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PurgeOperationItem)
	if !ok {
		that2, ok := that.(PurgeOperationItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.PurgeTime != that1.PurgeTime {
		return false
	}
	if this.Regexp != that1.Regexp {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.FinishTime != that1.FinishTime {
		return false
	}
	if this.HardPurge != that1.HardPurge {
		return false
	}
	if this.BytesPurged != that1.BytesPurged {
		return false
	}
	if this.BytesNotPurged != that1.BytesNotPurged {
		return false
	}
	return true
}
func (this *ServiceOperationItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceOperationItem)
	if !ok {
		that2, ok := that.(ServiceOperationItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceOpId != that1.ServiceOpId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if that1.OpStatus == nil {
		if this.OpStatus != nil {
			return false
		}
	} else if this.OpStatus == nil {
		return false
	} else if !this.OpStatus.Equal(that1.OpStatus) {
		return false
	}
	return true
}
func (this *ServiceOperationItem_Purge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceOperationItem_Purge)
	if !ok {
		that2, ok := that.(ServiceOperationItem_Purge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Purge.Equal(that1.Purge) {
		return false
	}
	return true
}
func (this *GetServiceOperationRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetServiceOperationRsp)
	if !ok {
		that2, ok := that.(GetServiceOperationRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ServiceOperationsTimeRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceOperationsTimeRange)
	if !ok {
		that2, ok := that.(ServiceOperationsTimeRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.FinishTime != that1.FinishTime {
		return false
	}
	return true
}
func (this *ListServiceOperationsReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListServiceOperationsReq)
	if !ok {
		that2, ok := that.(ListServiceOperationsReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Options == nil {
		if this.Options != nil {
			return false
		}
	} else if this.Options == nil {
		return false
	} else if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *ListServiceOperationsReq_TimeRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListServiceOperationsReq_TimeRange)
	if !ok {
		that2, ok := that.(ListServiceOperationsReq_TimeRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TimeRange.Equal(that1.TimeRange) {
		return false
	}
	return true
}
func (this *ListServiceOperationsReq_Lastn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListServiceOperationsReq_Lastn)
	if !ok {
		that2, ok := that.(ListServiceOperationsReq_Lastn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Lastn != that1.Lastn {
		return false
	}
	return true
}
func (this *ServiceOperationsItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceOperationsItem)
	if !ok {
		that2, ok := that.(ServiceOperationsItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceOpId != that1.ServiceOpId {
		return false
	}
	if this.SvcVersion != that1.SvcVersion {
		return false
	}
	if this.CreatedTime != that1.CreatedTime {
		return false
	}
	if this.ModifiedTime != that1.ModifiedTime {
		return false
	}
	return true
}
func (this *ListServiceOperationsRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListServiceOperationsRsp)
	if !ok {
		that2, ok := that.(ListServiceOperationsRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *LilacCDNAccessLogsResponseData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 36)
	s = append(s, "&cdn_loadbalancer.LilacCDNAccessLogsResponseData{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "ClientPort: "+fmt.Sprintf("%#v", this.ClientPort)+",\n")
	s = append(s, "Host: "+fmt.Sprintf("%#v", this.Host)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	s = append(s, "Referer: "+fmt.Sprintf("%#v", this.Referer)+",\n")
	s = append(s, "CacheStatus: "+fmt.Sprintf("%#v", this.CacheStatus)+",\n")
	s = append(s, "RequestTime: "+fmt.Sprintf("%#v", this.RequestTime)+",\n")
	s = append(s, "UpstreamAddr: "+fmt.Sprintf("%#v", this.UpstreamAddr)+",\n")
	s = append(s, "UpstreamConnectTime: "+fmt.Sprintf("%#v", this.UpstreamConnectTime)+",\n")
	s = append(s, "UpstreamResponseTime: "+fmt.Sprintf("%#v", this.UpstreamResponseTime)+",\n")
	s = append(s, "UpstreamStatus: "+fmt.Sprintf("%#v", this.UpstreamStatus)+",\n")
	s = append(s, "GeoLocation: "+fmt.Sprintf("%#v", this.GeoLocation)+",\n")
	s = append(s, "CityId: "+fmt.Sprintf("%#v", this.CityId)+",\n")
	s = append(s, "HttpVersion: "+fmt.Sprintf("%#v", this.HttpVersion)+",\n")
	s = append(s, "RspSize: "+fmt.Sprintf("%#v", this.RspSize)+",\n")
	s = append(s, "SrcIp: "+fmt.Sprintf("%#v", this.SrcIp)+",\n")
	s = append(s, "ReqPath: "+fmt.Sprintf("%#v", this.ReqPath)+",\n")
	s = append(s, "RspCode: "+fmt.Sprintf("%#v", this.RspCode)+",\n")
	s = append(s, "UserAgent: "+fmt.Sprintf("%#v", this.UserAgent)+",\n")
	s = append(s, "ReqContentType: "+fmt.Sprintf("%#v", this.ReqContentType)+",\n")
	s = append(s, "RspContentType: "+fmt.Sprintf("%#v", this.RspContentType)+",\n")
	s = append(s, "Country: "+fmt.Sprintf("%#v", this.Country)+",\n")
	s = append(s, "CityName: "+fmt.Sprintf("%#v", this.CityName)+",\n")
	s = append(s, "ReqSize: "+fmt.Sprintf("%#v", this.ReqSize)+",\n")
	s = append(s, "RspCodeClass: "+fmt.Sprintf("%#v", this.RspCodeClass)+",\n")
	s = append(s, "HostHeader: "+fmt.Sprintf("%#v", this.HostHeader)+",\n")
	s = append(s, "TlsVersion: "+fmt.Sprintf("%#v", this.TlsVersion)+",\n")
	s = append(s, "TlsSni: "+fmt.Sprintf("%#v", this.TlsSni)+",\n")
	s = append(s, "CdnName: "+fmt.Sprintf("%#v", this.CdnName)+",\n")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNLogResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CDNLogResponse{")
	if this.Logs != nil {
		s = append(s, "Logs: "+fmt.Sprintf("%#v", this.Logs)+",\n")
	}
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNAccessLogRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cdn_loadbalancer.CDNAccessLogRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	if this.Query != nil {
		s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	}
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*CDNAggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNLogAggregationResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CDNLogAggregationResponse{")
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNAccessLogAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cdn_loadbalancer.CDNAccessLogAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	if this.Query != nil {
		s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	}
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*CDNAggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CDNAggregationRequest{")
	if this.AggregationType != nil {
		s = append(s, "AggregationType: "+fmt.Sprintf("%#v", this.AggregationType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNAggregationRequest_DateAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNAggregationRequest_DateAggregation{` +
		`DateAggregation:` + fmt.Sprintf("%#v", this.DateAggregation) + `}`}, ", ")
	return s
}
func (this *CDNAggregationRequest_FieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNAggregationRequest_FieldAggregation{` +
		`FieldAggregation:` + fmt.Sprintf("%#v", this.FieldAggregation) + `}`}, ", ")
	return s
}
func (this *CDNDateSubAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_loadbalancer.CDNDateSubAggregation{")
	if this.AggregationType != nil {
		s = append(s, "AggregationType: "+fmt.Sprintf("%#v", this.AggregationType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNDateSubAggregation_FieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNDateSubAggregation_FieldAggregation{` +
		`FieldAggregation:` + fmt.Sprintf("%#v", this.FieldAggregation) + `}`}, ", ")
	return s
}
func (this *CDNDateAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CDNDateAggregation{")
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*CDNDateSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%#v: %#v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	if this.SubAggs != nil {
		s = append(s, "SubAggs: "+mapStringForSubAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNFieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CDNFieldAggregation{")
	s = append(s, "Field: "+fmt.Sprintf("%#v", this.Field)+",\n")
	s = append(s, "Topk: "+fmt.Sprintf("%#v", this.Topk)+",\n")
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*CDNFieldSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%#v: %#v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	if this.SubAggs != nil {
		s = append(s, "SubAggs: "+mapStringForSubAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNFieldSubAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_loadbalancer.CDNFieldSubAggregation{")
	if this.AggregationType != nil {
		s = append(s, "AggregationType: "+fmt.Sprintf("%#v", this.AggregationType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNFieldSubAggregation_FieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNFieldSubAggregation_FieldAggregation{` +
		`FieldAggregation:` + fmt.Sprintf("%#v", this.FieldAggregation) + `}`}, ", ")
	return s
}
func (this *FieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.FieldAggregation{")
	s = append(s, "Field: "+fmt.Sprintf("%#v", this.Field)+",\n")
	s = append(s, "Topk: "+fmt.Sprintf("%#v", this.Topk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNAccessLogFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CDNAccessLogFilter{")
	s = append(s, "Tag: "+fmt.Sprintf("%#v", this.Tag)+",\n")
	s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "FieldSelector: "+fmt.Sprintf("%#v", this.FieldSelector)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "GroupBy: "+fmt.Sprintf("%#v", this.GroupBy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsResponse{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNCachePurgeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&cdn_loadbalancer.LilacCDNCachePurgeRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "PurgeEpochTimestamp: "+fmt.Sprintf("%#v", this.PurgeEpochTimestamp)+",\n")
	if this.PatternType != nil {
		s = append(s, "PatternType: "+fmt.Sprintf("%#v", this.PatternType)+",\n")
	}
	if this.PurgeType != nil {
		s = append(s, "PurgeType: "+fmt.Sprintf("%#v", this.PurgeType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNCachePurgeRequest_PurgeAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.LilacCDNCachePurgeRequest_PurgeAll{` +
		`PurgeAll:` + fmt.Sprintf("%#v", this.PurgeAll) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_Url) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.LilacCDNCachePurgeRequest_Url{` +
		`Url:` + fmt.Sprintf("%#v", this.Url) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_Hostname) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.LilacCDNCachePurgeRequest_Hostname{` +
		`Hostname:` + fmt.Sprintf("%#v", this.Hostname) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_Pattern) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.LilacCDNCachePurgeRequest_Pattern{` +
		`Pattern:` + fmt.Sprintf("%#v", this.Pattern) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_SoftPurge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.LilacCDNCachePurgeRequest_SoftPurge{` +
		`SoftPurge:` + fmt.Sprintf("%#v", this.SoftPurge) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_HardPurge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.LilacCDNCachePurgeRequest_HardPurge{` +
		`HardPurge:` + fmt.Sprintf("%#v", this.HardPurge) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_loadbalancer.LilacCDNCachePurgeResponse{")
	s = append(s, "PurgeRequestId: "+fmt.Sprintf("%#v", this.PurgeRequestId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubscribeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cdn_loadbalancer.SubscribeRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubscribeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cdn_loadbalancer.SubscribeResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UnsubscribeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cdn_loadbalancer.UnsubscribeRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UnsubscribeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&cdn_loadbalancer.UnsubscribeResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetServiceOperationReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.GetServiceOperationReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ServiceOpId: "+fmt.Sprintf("%#v", this.ServiceOpId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PurgeOperationItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&cdn_loadbalancer.PurgeOperationItem{")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "PurgeTime: "+fmt.Sprintf("%#v", this.PurgeTime)+",\n")
	s = append(s, "Regexp: "+fmt.Sprintf("%#v", this.Regexp)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "FinishTime: "+fmt.Sprintf("%#v", this.FinishTime)+",\n")
	s = append(s, "HardPurge: "+fmt.Sprintf("%#v", this.HardPurge)+",\n")
	s = append(s, "BytesPurged: "+fmt.Sprintf("%#v", this.BytesPurged)+",\n")
	s = append(s, "BytesNotPurged: "+fmt.Sprintf("%#v", this.BytesNotPurged)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceOperationItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.ServiceOperationItem{")
	s = append(s, "ServiceOpId: "+fmt.Sprintf("%#v", this.ServiceOpId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.OpStatus != nil {
		s = append(s, "OpStatus: "+fmt.Sprintf("%#v", this.OpStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceOperationItem_Purge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ServiceOperationItem_Purge{` +
		`Purge:` + fmt.Sprintf("%#v", this.Purge) + `}`}, ", ")
	return s
}
func (this *GetServiceOperationRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.GetServiceOperationRsp{")
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceOperationsTimeRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.ServiceOperationsTimeRange{")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "FinishTime: "+fmt.Sprintf("%#v", this.FinishTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListServiceOperationsReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_loadbalancer.ListServiceOperationsReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListServiceOperationsReq_TimeRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ListServiceOperationsReq_TimeRange{` +
		`TimeRange:` + fmt.Sprintf("%#v", this.TimeRange) + `}`}, ", ")
	return s
}
func (this *ListServiceOperationsReq_Lastn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ListServiceOperationsReq_Lastn{` +
		`Lastn:` + fmt.Sprintf("%#v", this.Lastn) + `}`}, ", ")
	return s
}
func (this *ServiceOperationsItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_loadbalancer.ServiceOperationsItem{")
	s = append(s, "ServiceOpId: "+fmt.Sprintf("%#v", this.ServiceOpId)+",\n")
	s = append(s, "SvcVersion: "+fmt.Sprintf("%#v", this.SvcVersion)+",\n")
	s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	s = append(s, "ModifiedTime: "+fmt.Sprintf("%#v", this.ModifiedTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListServiceOperationsRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.ListServiceOperationsRsp{")
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicCustomapi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CustomAPIClient is the client API for CustomAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomAPIClient interface {
	// CDNMetrics
	//
	// x-displayName: "Get CDN Metrics"
	// Initial metrics request for CDN loadbalancers
	CDNMetrics(ctx context.Context, in *LilacCDNMetricsRequest, opts ...grpc.CallOption) (*LilacCDNMetricsResponse, error)
	// CDNCachePurge
	//
	// x-displayName: "Purge CDN Cache"
	// Initiate Purge for Edge CDN Cache
	CDNCachePurge(ctx context.Context, in *LilacCDNCachePurgeRequest, opts ...grpc.CallOption) (*LilacCDNCachePurgeResponse, error)
	// Subscribe
	//
	// x-displayName: "Subscribe to CDN Loadbalancer"
	// Subscribe to CDN Loadbalancer
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	// Unsubscribe
	//
	// x-displayName: "Unsubscribe to CDN Loadbalancer"
	// Unsubscribe to CDN Loadbalancer
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// CDNAccessLogs
	//
	// x-displayName: "Get CDN Access Logs"
	// Retrieve CDN Load-Balancer Access logs
	CDNAccessLogs(ctx context.Context, in *CDNAccessLogRequest, opts ...grpc.CallOption) (*CDNLogResponse, error)
	// CDN Access Log Aggregation Query
	//
	// x-displayName: "CDN Access Log Aggregation Query"
	// Request to get summary/analytics data for the cdn access logs that matches the query in request for a given namespace.
	CDNAccessLogAggregationQuery(ctx context.Context, in *CDNAccessLogAggregationRequest, opts ...grpc.CallOption) (*CDNLogAggregationResponse, error)
	// ListServiceOperations
	//
	// x-displayName: "List of CDN Operation Commands"
	// List of service operations for a given CDN LB
	ListServiceOperations(ctx context.Context, in *ListServiceOperationsReq, opts ...grpc.CallOption) (*ListServiceOperationsRsp, error)
	// GetServiceOperation
	//
	// x-displayName: "Get Service Operation Status"
	// Get status of an operation command for a given CDN Loadbalancer.
	GetServiceOperation(ctx context.Context, in *GetServiceOperationReq, opts ...grpc.CallOption) (*GetServiceOperationRsp, error)
}

type customAPIClient struct {
	cc *grpc.ClientConn
}

func NewCustomAPIClient(cc *grpc.ClientConn) CustomAPIClient {
	return &customAPIClient{cc}
}

func (c *customAPIClient) CDNMetrics(ctx context.Context, in *LilacCDNMetricsRequest, opts ...grpc.CallOption) (*LilacCDNMetricsResponse, error) {
	out := new(LilacCDNMetricsResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/CDNMetrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) CDNCachePurge(ctx context.Context, in *LilacCDNCachePurgeRequest, opts ...grpc.CallOption) (*LilacCDNCachePurgeResponse, error) {
	out := new(LilacCDNCachePurgeResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/CDNCachePurge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/Subscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/Unsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) CDNAccessLogs(ctx context.Context, in *CDNAccessLogRequest, opts ...grpc.CallOption) (*CDNLogResponse, error) {
	out := new(CDNLogResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/CDNAccessLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) CDNAccessLogAggregationQuery(ctx context.Context, in *CDNAccessLogAggregationRequest, opts ...grpc.CallOption) (*CDNLogAggregationResponse, error) {
	out := new(CDNLogAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/CDNAccessLogAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) ListServiceOperations(ctx context.Context, in *ListServiceOperationsReq, opts ...grpc.CallOption) (*ListServiceOperationsRsp, error) {
	out := new(ListServiceOperationsRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/ListServiceOperations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) GetServiceOperation(ctx context.Context, in *GetServiceOperationReq, opts ...grpc.CallOption) (*GetServiceOperationRsp, error) {
	out := new(GetServiceOperationRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/GetServiceOperation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomAPIServer is the server API for CustomAPI service.
type CustomAPIServer interface {
	// CDNMetrics
	//
	// x-displayName: "Get CDN Metrics"
	// Initial metrics request for CDN loadbalancers
	CDNMetrics(context.Context, *LilacCDNMetricsRequest) (*LilacCDNMetricsResponse, error)
	// CDNCachePurge
	//
	// x-displayName: "Purge CDN Cache"
	// Initiate Purge for Edge CDN Cache
	CDNCachePurge(context.Context, *LilacCDNCachePurgeRequest) (*LilacCDNCachePurgeResponse, error)
	// Subscribe
	//
	// x-displayName: "Subscribe to CDN Loadbalancer"
	// Subscribe to CDN Loadbalancer
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	// Unsubscribe
	//
	// x-displayName: "Unsubscribe to CDN Loadbalancer"
	// Unsubscribe to CDN Loadbalancer
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// CDNAccessLogs
	//
	// x-displayName: "Get CDN Access Logs"
	// Retrieve CDN Load-Balancer Access logs
	CDNAccessLogs(context.Context, *CDNAccessLogRequest) (*CDNLogResponse, error)
	// CDN Access Log Aggregation Query
	//
	// x-displayName: "CDN Access Log Aggregation Query"
	// Request to get summary/analytics data for the cdn access logs that matches the query in request for a given namespace.
	CDNAccessLogAggregationQuery(context.Context, *CDNAccessLogAggregationRequest) (*CDNLogAggregationResponse, error)
	// ListServiceOperations
	//
	// x-displayName: "List of CDN Operation Commands"
	// List of service operations for a given CDN LB
	ListServiceOperations(context.Context, *ListServiceOperationsReq) (*ListServiceOperationsRsp, error)
	// GetServiceOperation
	//
	// x-displayName: "Get Service Operation Status"
	// Get status of an operation command for a given CDN Loadbalancer.
	GetServiceOperation(context.Context, *GetServiceOperationReq) (*GetServiceOperationRsp, error)
}

// UnimplementedCustomAPIServer can be embedded to have forward compatible implementations.
type UnimplementedCustomAPIServer struct {
}

func (*UnimplementedCustomAPIServer) CDNMetrics(ctx context.Context, req *LilacCDNMetricsRequest) (*LilacCDNMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CDNMetrics not implemented")
}
func (*UnimplementedCustomAPIServer) CDNCachePurge(ctx context.Context, req *LilacCDNCachePurgeRequest) (*LilacCDNCachePurgeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CDNCachePurge not implemented")
}
func (*UnimplementedCustomAPIServer) Subscribe(ctx context.Context, req *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (*UnimplementedCustomAPIServer) Unsubscribe(ctx context.Context, req *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (*UnimplementedCustomAPIServer) CDNAccessLogs(ctx context.Context, req *CDNAccessLogRequest) (*CDNLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CDNAccessLogs not implemented")
}
func (*UnimplementedCustomAPIServer) CDNAccessLogAggregationQuery(ctx context.Context, req *CDNAccessLogAggregationRequest) (*CDNLogAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CDNAccessLogAggregationQuery not implemented")
}
func (*UnimplementedCustomAPIServer) ListServiceOperations(ctx context.Context, req *ListServiceOperationsReq) (*ListServiceOperationsRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListServiceOperations not implemented")
}
func (*UnimplementedCustomAPIServer) GetServiceOperation(ctx context.Context, req *GetServiceOperationReq) (*GetServiceOperationRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServiceOperation not implemented")
}

func RegisterCustomAPIServer(s *grpc.Server, srv CustomAPIServer) {
	s.RegisterService(&_CustomAPI_serviceDesc, srv)
}

func _CustomAPI_CDNMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LilacCDNMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).CDNMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/CDNMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).CDNMetrics(ctx, req.(*LilacCDNMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_CDNCachePurge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LilacCDNCachePurgeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).CDNCachePurge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/CDNCachePurge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).CDNCachePurge(ctx, req.(*LilacCDNCachePurgeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/Unsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_CDNAccessLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CDNAccessLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).CDNAccessLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/CDNAccessLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).CDNAccessLogs(ctx, req.(*CDNAccessLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_CDNAccessLogAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CDNAccessLogAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).CDNAccessLogAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/CDNAccessLogAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).CDNAccessLogAggregationQuery(ctx, req.(*CDNAccessLogAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_ListServiceOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServiceOperationsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).ListServiceOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/ListServiceOperations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).ListServiceOperations(ctx, req.(*ListServiceOperationsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_GetServiceOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceOperationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).GetServiceOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.views.cdn_loadbalancer.CustomAPI/GetServiceOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).GetServiceOperation(ctx, req.(*GetServiceOperationReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.views.cdn_loadbalancer.CustomAPI",
	HandlerType: (*CustomAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CDNMetrics",
			Handler:    _CustomAPI_CDNMetrics_Handler,
		},
		{
			MethodName: "CDNCachePurge",
			Handler:    _CustomAPI_CDNCachePurge_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _CustomAPI_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _CustomAPI_Unsubscribe_Handler,
		},
		{
			MethodName: "CDNAccessLogs",
			Handler:    _CustomAPI_CDNAccessLogs_Handler,
		},
		{
			MethodName: "CDNAccessLogAggregationQuery",
			Handler:    _CustomAPI_CDNAccessLogAggregationQuery_Handler,
		},
		{
			MethodName: "ListServiceOperations",
			Handler:    _CustomAPI_ListServiceOperations_Handler,
		},
		{
			MethodName: "GetServiceOperation",
			Handler:    _CustomAPI_GetServiceOperation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/views/cdn_loadbalancer/public_customapi.proto",
}

func (m *LilacCDNAccessLogsResponseData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNAccessLogsResponseData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNAccessLogsResponseData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SiteName) > 0 {
		i -= len(m.SiteName)
		copy(dAtA[i:], m.SiteName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.SiteName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if len(m.CdnName) > 0 {
		i -= len(m.CdnName)
		copy(dAtA[i:], m.CdnName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.CdnName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.TlsSni) > 0 {
		i -= len(m.TlsSni)
		copy(dAtA[i:], m.TlsSni)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TlsSni)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if len(m.TlsVersion) > 0 {
		i -= len(m.TlsVersion)
		copy(dAtA[i:], m.TlsVersion)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.TlsVersion)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if len(m.HostHeader) > 0 {
		i -= len(m.HostHeader)
		copy(dAtA[i:], m.HostHeader)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.HostHeader)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.RspCodeClass) > 0 {
		i -= len(m.RspCodeClass)
		copy(dAtA[i:], m.RspCodeClass)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.RspCodeClass)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.ReqSize != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.ReqSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if len(m.CityName) > 0 {
		i -= len(m.CityName)
		copy(dAtA[i:], m.CityName)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.CityName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Country) > 0 {
		i -= len(m.Country)
		copy(dAtA[i:], m.Country)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Country)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if len(m.RspContentType) > 0 {
		i -= len(m.RspContentType)
		copy(dAtA[i:], m.RspContentType)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.RspContentType)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.ReqContentType) > 0 {
		i -= len(m.ReqContentType)
		copy(dAtA[i:], m.ReqContentType)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ReqContentType)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.UserAgent) > 0 {
		i -= len(m.UserAgent)
		copy(dAtA[i:], m.UserAgent)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.UserAgent)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.RspCode) > 0 {
		i -= len(m.RspCode)
		copy(dAtA[i:], m.RspCode)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.RspCode)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.ReqPath) > 0 {
		i -= len(m.ReqPath)
		copy(dAtA[i:], m.ReqPath)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ReqPath)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.SrcIp) > 0 {
		i -= len(m.SrcIp)
		copy(dAtA[i:], m.SrcIp)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.SrcIp)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.RspSize != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.RspSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if len(m.HttpVersion) > 0 {
		i -= len(m.HttpVersion)
		copy(dAtA[i:], m.HttpVersion)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.HttpVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.CityId) > 0 {
		i -= len(m.CityId)
		copy(dAtA[i:], m.CityId)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.CityId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.GeoLocation) > 0 {
		i -= len(m.GeoLocation)
		copy(dAtA[i:], m.GeoLocation)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.GeoLocation)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.UpstreamStatus) > 0 {
		i -= len(m.UpstreamStatus)
		copy(dAtA[i:], m.UpstreamStatus)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.UpstreamStatus)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.UpstreamResponseTime) > 0 {
		i -= len(m.UpstreamResponseTime)
		copy(dAtA[i:], m.UpstreamResponseTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.UpstreamResponseTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.UpstreamConnectTime) > 0 {
		i -= len(m.UpstreamConnectTime)
		copy(dAtA[i:], m.UpstreamConnectTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.UpstreamConnectTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.UpstreamAddr) > 0 {
		i -= len(m.UpstreamAddr)
		copy(dAtA[i:], m.UpstreamAddr)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.UpstreamAddr)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.RequestTime) > 0 {
		i -= len(m.RequestTime)
		copy(dAtA[i:], m.RequestTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.RequestTime)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.CacheStatus) > 0 {
		i -= len(m.CacheStatus)
		copy(dAtA[i:], m.CacheStatus)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.CacheStatus)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Referer) > 0 {
		i -= len(m.Referer)
		copy(dAtA[i:], m.Referer)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Referer)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Scheme) > 0 {
		i -= len(m.Scheme)
		copy(dAtA[i:], m.Scheme)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Scheme)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClientPort) > 0 {
		i -= len(m.ClientPort)
		copy(dAtA[i:], m.ClientPort)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ClientPort)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Timestamp) > 0 {
		i -= len(m.Timestamp)
		copy(dAtA[i:], m.Timestamp)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Timestamp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNLogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNLogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Logs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNAccessLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNAccessLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNAccessLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Limit != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Sort != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		for iNdEx := len(m.Query) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Query[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNLogAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNLogAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNLogAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDNAccessLogAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNAccessLogAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNAccessLogAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		for iNdEx := len(m.Query) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Query[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AggregationType != nil {
		{
			size := m.AggregationType.Size()
			i -= size
			if _, err := m.AggregationType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNAggregationRequest_DateAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNAggregationRequest_DateAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DateAggregation != nil {
		{
			size, err := m.DateAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CDNAggregationRequest_FieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNAggregationRequest_FieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FieldAggregation != nil {
		{
			size, err := m.FieldAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CDNDateSubAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNDateSubAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNDateSubAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AggregationType != nil {
		{
			size := m.AggregationType.Size()
			i -= size
			if _, err := m.AggregationType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNDateSubAggregation_FieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNDateSubAggregation_FieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FieldAggregation != nil {
		{
			size, err := m.FieldAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CDNDateAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNDateAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNDateAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubAggs) > 0 {
		for k := range m.SubAggs {
			v := m.SubAggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNFieldAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNFieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNFieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubAggs) > 0 {
		for k := range m.SubAggs {
			v := m.SubAggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Topk != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Topk))
		i--
		dAtA[i] = 0x10
	}
	if m.Field != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Field))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDNFieldSubAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNFieldSubAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNFieldSubAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AggregationType != nil {
		{
			size := m.AggregationType.Size()
			i -= size
			if _, err := m.AggregationType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNFieldSubAggregation_FieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNFieldSubAggregation_FieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FieldAggregation != nil {
		{
			size, err := m.FieldAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *FieldAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Topk != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Topk))
		i--
		dAtA[i] = 0x10
	}
	if m.Field != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Field))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDNAccessLogFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNAccessLogFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNAccessLogFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Operator))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Tag != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		dAtA12 := make([]byte, len(m.GroupBy)*10)
		var j11 int
		for _, num := range m.GroupBy {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Filter) > 0 {
		for iNdEx := len(m.Filter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.FieldSelector) > 0 {
		dAtA14 := make([]byte, len(m.FieldSelector)*10)
		var j13 int
		for _, num := range m.FieldSelector {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNCachePurgeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNCachePurgeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PatternType != nil {
		{
			size := m.PatternType.Size()
			i -= size
			if _, err := m.PatternType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PurgeType != nil {
		{
			size := m.PurgeType.Size()
			i -= size
			if _, err := m.PurgeType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.PurgeEpochTimestamp) > 0 {
		i -= len(m.PurgeEpochTimestamp)
		copy(dAtA[i:], m.PurgeEpochTimestamp)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.PurgeEpochTimestamp)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNCachePurgeRequest_Pattern) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_Pattern) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Pattern)
	copy(dAtA[i:], m.Pattern)
	i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Pattern)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_SoftPurge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_SoftPurge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SoftPurge != nil {
		{
			size, err := m.SoftPurge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_HardPurge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_HardPurge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HardPurge != nil {
		{
			size, err := m.HardPurge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_PurgeAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_PurgeAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PurgeAll != nil {
		{
			size, err := m.PurgeAll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_Url) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_Url) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Url)
	copy(dAtA[i:], m.Url)
	i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Url)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_Hostname) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_Hostname) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Hostname)
	copy(dAtA[i:], m.Hostname)
	i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Hostname)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNCachePurgeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PurgeRequestId != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.PurgeRequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SubscribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UnsubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsubscribeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UnsubscribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsubscribeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsubscribeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetServiceOperationReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetServiceOperationReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetServiceOperationReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServiceOpId != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.ServiceOpId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PurgeOperationItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PurgeOperationItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PurgeOperationItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BytesNotPurged != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.BytesNotPurged))
		i--
		dAtA[i] = 0x40
	}
	if m.BytesPurged != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.BytesPurged))
		i--
		dAtA[i] = 0x38
	}
	if m.HardPurge {
		i--
		if m.HardPurge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.FinishTime) > 0 {
		i -= len(m.FinishTime)
		copy(dAtA[i:], m.FinishTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FinishTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Regexp) > 0 {
		i -= len(m.Regexp)
		copy(dAtA[i:], m.Regexp)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Regexp)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PurgeTime) > 0 {
		i -= len(m.PurgeTime)
		copy(dAtA[i:], m.PurgeTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.PurgeTime)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceOperationItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOperationItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceOperationItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OpStatus != nil {
		{
			size := m.OpStatus.Size()
			i -= size
			if _, err := m.OpStatus.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if m.ServiceOpId != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.ServiceOpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceOperationItem_Purge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceOperationItem_Purge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Purge != nil {
		{
			size, err := m.Purge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GetServiceOperationRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetServiceOperationRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetServiceOperationRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceOperationsTimeRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOperationsTimeRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceOperationsTimeRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FinishTime) > 0 {
		i -= len(m.FinishTime)
		copy(dAtA[i:], m.FinishTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.FinishTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *ListServiceOperationsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListServiceOperationsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListServiceOperationsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		{
			size := m.Options.Size()
			i -= size
			if _, err := m.Options.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListServiceOperationsReq_TimeRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListServiceOperationsReq_TimeRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TimeRange != nil {
		{
			size, err := m.TimeRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ListServiceOperationsReq_Lastn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListServiceOperationsReq_Lastn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.Lastn))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *ServiceOperationsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOperationsItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceOperationsItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModifiedTime) > 0 {
		i -= len(m.ModifiedTime)
		copy(dAtA[i:], m.ModifiedTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.ModifiedTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CreatedTime) > 0 {
		i -= len(m.CreatedTime)
		copy(dAtA[i:], m.CreatedTime)
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(len(m.CreatedTime)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SvcVersion != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.SvcVersion))
		i--
		dAtA[i] = 0x10
	}
	if m.ServiceOpId != 0 {
		i = encodeVarintPublicCustomapi(dAtA, i, uint64(m.ServiceOpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListServiceOperationsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListServiceOperationsRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListServiceOperationsRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicCustomapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPublicCustomapi(dAtA []byte, offset int, v uint64) int {
	offset -= sovPublicCustomapi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LilacCDNAccessLogsResponseData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ClientPort)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Referer)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.CacheStatus)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.RequestTime)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.UpstreamAddr)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.UpstreamConnectTime)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.UpstreamResponseTime)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.UpstreamStatus)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.GeoLocation)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.CityId)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.HttpVersion)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.RspSize != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.RspSize))
	}
	l = len(m.SrcIp)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ReqPath)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.RspCode)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.UserAgent)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ReqContentType)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.RspContentType)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.CityName)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	if m.ReqSize != 0 {
		n += 2 + sovPublicCustomapi(uint64(m.ReqSize))
	}
	l = len(m.RspCodeClass)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.HostHeader)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TlsVersion)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.TlsSni)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.CdnName)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.SiteName)
	if l > 0 {
		n += 2 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *CDNLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if m.TotalHits != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CDNAccessLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Query) > 0 {
		for _, e := range m.Query {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Limit))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CDNLogAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CDNAccessLogAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Query) > 0 {
		for _, e := range m.Query {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CDNAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationType != nil {
		n += m.AggregationType.Size()
	}
	return n
}

func (m *CDNAggregationRequest_DateAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DateAggregation != nil {
		l = m.DateAggregation.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *CDNAggregationRequest_FieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FieldAggregation != nil {
		l = m.FieldAggregation.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *CDNDateSubAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationType != nil {
		n += m.AggregationType.Size()
	}
	return n
}

func (m *CDNDateSubAggregation_FieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FieldAggregation != nil {
		l = m.FieldAggregation.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *CDNDateAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.SubAggs) > 0 {
		for k, v := range m.SubAggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CDNFieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Field != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Field))
	}
	if m.Topk != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Topk))
	}
	if len(m.SubAggs) > 0 {
		for k, v := range m.SubAggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicCustomapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicCustomapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicCustomapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CDNFieldSubAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationType != nil {
		n += m.AggregationType.Size()
	}
	return n
}

func (m *CDNFieldSubAggregation_FieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FieldAggregation != nil {
		l = m.FieldAggregation.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *FieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Field != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Field))
	}
	if m.Topk != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Topk))
	}
	return n
}

func (m *CDNAccessLogFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Tag))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if m.Operator != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.Operator))
	}
	return n
}

func (m *LilacCDNMetricsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.FieldSelector) > 0 {
		l = 0
		for _, e := range m.FieldSelector {
			l += sovPublicCustomapi(uint64(e))
		}
		n += 1 + sovPublicCustomapi(uint64(l)) + l
	}
	if len(m.Filter) > 0 {
		for _, e := range m.Filter {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		l = 0
		for _, e := range m.GroupBy {
			l += sovPublicCustomapi(uint64(e))
		}
		n += 1 + sovPublicCustomapi(uint64(l)) + l
	}
	return n
}

func (m *LilacCDNMetricsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *LilacCDNCachePurgeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.PurgeEpochTimestamp)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.PatternType != nil {
		n += m.PatternType.Size()
	}
	if m.PurgeType != nil {
		n += m.PurgeType.Size()
	}
	return n
}

func (m *LilacCDNCachePurgeRequest_Pattern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pattern)
	n += 1 + l + sovPublicCustomapi(uint64(l))
	return n
}
func (m *LilacCDNCachePurgeRequest_SoftPurge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SoftPurge != nil {
		l = m.SoftPurge.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *LilacCDNCachePurgeRequest_HardPurge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HardPurge != nil {
		l = m.HardPurge.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *LilacCDNCachePurgeRequest_PurgeAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PurgeAll != nil {
		l = m.PurgeAll.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *LilacCDNCachePurgeRequest_Url) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	n += 1 + l + sovPublicCustomapi(uint64(l))
	return n
}
func (m *LilacCDNCachePurgeRequest_Hostname) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	n += 1 + l + sovPublicCustomapi(uint64(l))
	return n
}
func (m *LilacCDNCachePurgeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PurgeRequestId != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.PurgeRequestId))
	}
	return n
}

func (m *SubscribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SubscribeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UnsubscribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UnsubscribeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetServiceOperationReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.ServiceOpId != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.ServiceOpId))
	}
	return n
}

func (m *PurgeOperationItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.PurgeTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Regexp)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FinishTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.HardPurge {
		n += 2
	}
	if m.BytesPurged != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.BytesPurged))
	}
	if m.BytesNotPurged != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.BytesNotPurged))
	}
	return n
}

func (m *ServiceOperationItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceOpId != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.ServiceOpId))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.OpStatus != nil {
		n += m.OpStatus.Size()
	}
	return n
}

func (m *ServiceOperationItem_Purge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Purge != nil {
		l = m.Purge.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *GetServiceOperationRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func (m *ServiceOperationsTimeRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.FinishTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *ListServiceOperationsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if m.Options != nil {
		n += m.Options.Size()
	}
	return n
}

func (m *ListServiceOperationsReq_TimeRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeRange != nil {
		l = m.TimeRange.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}
func (m *ListServiceOperationsReq_Lastn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPublicCustomapi(uint64(m.Lastn))
	return n
}
func (m *ServiceOperationsItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceOpId != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.ServiceOpId))
	}
	if m.SvcVersion != 0 {
		n += 1 + sovPublicCustomapi(uint64(m.SvcVersion))
	}
	l = len(m.CreatedTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	l = len(m.ModifiedTime)
	if l > 0 {
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	return n
}

func (m *ListServiceOperationsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovPublicCustomapi(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPublicCustomapi(uint64(l))
		}
	}
	return n
}

func sovPublicCustomapi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPublicCustomapi(x uint64) (n int) {
	return sovPublicCustomapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LilacCDNAccessLogsResponseData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNAccessLogsResponseData{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`ClientPort:` + fmt.Sprintf("%v", this.ClientPort) + `,`,
		`Host:` + fmt.Sprintf("%v", this.Host) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`Referer:` + fmt.Sprintf("%v", this.Referer) + `,`,
		`CacheStatus:` + fmt.Sprintf("%v", this.CacheStatus) + `,`,
		`RequestTime:` + fmt.Sprintf("%v", this.RequestTime) + `,`,
		`UpstreamAddr:` + fmt.Sprintf("%v", this.UpstreamAddr) + `,`,
		`UpstreamConnectTime:` + fmt.Sprintf("%v", this.UpstreamConnectTime) + `,`,
		`UpstreamResponseTime:` + fmt.Sprintf("%v", this.UpstreamResponseTime) + `,`,
		`UpstreamStatus:` + fmt.Sprintf("%v", this.UpstreamStatus) + `,`,
		`GeoLocation:` + fmt.Sprintf("%v", this.GeoLocation) + `,`,
		`CityId:` + fmt.Sprintf("%v", this.CityId) + `,`,
		`HttpVersion:` + fmt.Sprintf("%v", this.HttpVersion) + `,`,
		`RspSize:` + fmt.Sprintf("%v", this.RspSize) + `,`,
		`SrcIp:` + fmt.Sprintf("%v", this.SrcIp) + `,`,
		`ReqPath:` + fmt.Sprintf("%v", this.ReqPath) + `,`,
		`RspCode:` + fmt.Sprintf("%v", this.RspCode) + `,`,
		`UserAgent:` + fmt.Sprintf("%v", this.UserAgent) + `,`,
		`ReqContentType:` + fmt.Sprintf("%v", this.ReqContentType) + `,`,
		`RspContentType:` + fmt.Sprintf("%v", this.RspContentType) + `,`,
		`Country:` + fmt.Sprintf("%v", this.Country) + `,`,
		`CityName:` + fmt.Sprintf("%v", this.CityName) + `,`,
		`ReqSize:` + fmt.Sprintf("%v", this.ReqSize) + `,`,
		`RspCodeClass:` + fmt.Sprintf("%v", this.RspCodeClass) + `,`,
		`HostHeader:` + fmt.Sprintf("%v", this.HostHeader) + `,`,
		`TlsVersion:` + fmt.Sprintf("%v", this.TlsVersion) + `,`,
		`TlsSni:` + fmt.Sprintf("%v", this.TlsSni) + `,`,
		`CdnName:` + fmt.Sprintf("%v", this.CdnName) + `,`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNLogResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLogs := "[]*LilacCDNAccessLogsResponseData{"
	for _, f := range this.Logs {
		repeatedStringForLogs += strings.Replace(f.String(), "LilacCDNAccessLogsResponseData", "LilacCDNAccessLogsResponseData", 1) + ","
	}
	repeatedStringForLogs += "}"
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&CDNLogResponse{`,
		`Logs:` + repeatedStringForLogs + `,`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNAccessLogRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForQuery := "[]*CDNAccessLogFilter{"
	for _, f := range this.Query {
		repeatedStringForQuery += strings.Replace(f.String(), "CDNAccessLogFilter", "CDNAccessLogFilter", 1) + ","
	}
	repeatedStringForQuery += "}"
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*CDNAggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&CDNAccessLogRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + repeatedStringForQuery + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNLogAggregationResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&CDNLogAggregationResponse{`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNAccessLogAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForQuery := "[]*CDNAccessLogFilter{"
	for _, f := range this.Query {
		repeatedStringForQuery += strings.Replace(f.String(), "CDNAccessLogFilter", "CDNAccessLogFilter", 1) + ","
	}
	repeatedStringForQuery += "}"
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*CDNAggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&CDNAccessLogAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + repeatedStringForQuery + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNAggregationRequest{`,
		`AggregationType:` + fmt.Sprintf("%v", this.AggregationType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNAggregationRequest_DateAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNAggregationRequest_DateAggregation{`,
		`DateAggregation:` + strings.Replace(fmt.Sprintf("%v", this.DateAggregation), "CDNDateAggregation", "CDNDateAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNAggregationRequest_FieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNAggregationRequest_FieldAggregation{`,
		`FieldAggregation:` + strings.Replace(fmt.Sprintf("%v", this.FieldAggregation), "CDNFieldAggregation", "CDNFieldAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNDateSubAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNDateSubAggregation{`,
		`AggregationType:` + fmt.Sprintf("%v", this.AggregationType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNDateSubAggregation_FieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNDateSubAggregation_FieldAggregation{`,
		`FieldAggregation:` + strings.Replace(fmt.Sprintf("%v", this.FieldAggregation), "CDNFieldAggregation", "CDNFieldAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNDateAggregation) String() string {
	if this == nil {
		return "nil"
	}
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*CDNDateSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%v: %v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	s := strings.Join([]string{`&CDNDateAggregation{`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`SubAggs:` + mapStringForSubAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNFieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*CDNFieldSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%v: %v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	s := strings.Join([]string{`&CDNFieldAggregation{`,
		`Field:` + fmt.Sprintf("%v", this.Field) + `,`,
		`Topk:` + fmt.Sprintf("%v", this.Topk) + `,`,
		`SubAggs:` + mapStringForSubAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNFieldSubAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNFieldSubAggregation{`,
		`AggregationType:` + fmt.Sprintf("%v", this.AggregationType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNFieldSubAggregation_FieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNFieldSubAggregation_FieldAggregation{`,
		`FieldAggregation:` + strings.Replace(fmt.Sprintf("%v", this.FieldAggregation), "FieldAggregation", "FieldAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FieldAggregation{`,
		`Field:` + fmt.Sprintf("%v", this.Field) + `,`,
		`Topk:` + fmt.Sprintf("%v", this.Topk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNAccessLogFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNAccessLogFilter{`,
		`Tag:` + fmt.Sprintf("%v", this.Tag) + `,`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`Operator:` + fmt.Sprintf("%v", this.Operator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFilter := "[]*LilacCDNMetricsFilter{"
	for _, f := range this.Filter {
		repeatedStringForFilter += strings.Replace(fmt.Sprintf("%v", f), "LilacCDNMetricsFilter", "LilacCDNMetricsFilter", 1) + ","
	}
	repeatedStringForFilter += "}"
	s := strings.Join([]string{`&LilacCDNMetricsRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`FieldSelector:` + fmt.Sprintf("%v", this.FieldSelector) + `,`,
		`Filter:` + repeatedStringForFilter + `,`,
		`GroupBy:` + fmt.Sprintf("%v", this.GroupBy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*LilacCDNMetricsResponseData{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(fmt.Sprintf("%v", f), "LilacCDNMetricsResponseData", "LilacCDNMetricsResponseData", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&LilacCDNMetricsResponse{`,
		`Items:` + repeatedStringForItems + `,`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`PurgeEpochTimestamp:` + fmt.Sprintf("%v", this.PurgeEpochTimestamp) + `,`,
		`PatternType:` + fmt.Sprintf("%v", this.PatternType) + `,`,
		`PurgeType:` + fmt.Sprintf("%v", this.PurgeType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_Pattern) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_Pattern{`,
		`Pattern:` + fmt.Sprintf("%v", this.Pattern) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_SoftPurge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_SoftPurge{`,
		`SoftPurge:` + strings.Replace(fmt.Sprintf("%v", this.SoftPurge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_HardPurge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_HardPurge{`,
		`HardPurge:` + strings.Replace(fmt.Sprintf("%v", this.HardPurge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_PurgeAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_PurgeAll{`,
		`PurgeAll:` + strings.Replace(fmt.Sprintf("%v", this.PurgeAll), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_Url) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_Url{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_Hostname) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_Hostname{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeResponse{`,
		`PurgeRequestId:` + fmt.Sprintf("%v", this.PurgeRequestId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubscribeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubscribeRequest{`,
		`}`,
	}, "")
	return s
}
func (this *SubscribeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubscribeResponse{`,
		`}`,
	}, "")
	return s
}
func (this *UnsubscribeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UnsubscribeRequest{`,
		`}`,
	}, "")
	return s
}
func (this *UnsubscribeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UnsubscribeResponse{`,
		`}`,
	}, "")
	return s
}
func (this *GetServiceOperationReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetServiceOperationReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ServiceOpId:` + fmt.Sprintf("%v", this.ServiceOpId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PurgeOperationItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PurgeOperationItem{`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`PurgeTime:` + fmt.Sprintf("%v", this.PurgeTime) + `,`,
		`Regexp:` + fmt.Sprintf("%v", this.Regexp) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`FinishTime:` + fmt.Sprintf("%v", this.FinishTime) + `,`,
		`HardPurge:` + fmt.Sprintf("%v", this.HardPurge) + `,`,
		`BytesPurged:` + fmt.Sprintf("%v", this.BytesPurged) + `,`,
		`BytesNotPurged:` + fmt.Sprintf("%v", this.BytesNotPurged) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceOperationItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceOperationItem{`,
		`ServiceOpId:` + fmt.Sprintf("%v", this.ServiceOpId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`OpStatus:` + fmt.Sprintf("%v", this.OpStatus) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceOperationItem_Purge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceOperationItem_Purge{`,
		`Purge:` + strings.Replace(fmt.Sprintf("%v", this.Purge), "PurgeOperationItem", "PurgeOperationItem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetServiceOperationRsp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*ServiceOperationItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "ServiceOperationItem", "ServiceOperationItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&GetServiceOperationRsp{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "ErrorType", "schema.ErrorType", 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceOperationsTimeRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceOperationsTimeRange{`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`FinishTime:` + fmt.Sprintf("%v", this.FinishTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListServiceOperationsReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListServiceOperationsReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListServiceOperationsReq_TimeRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListServiceOperationsReq_TimeRange{`,
		`TimeRange:` + strings.Replace(fmt.Sprintf("%v", this.TimeRange), "ServiceOperationsTimeRange", "ServiceOperationsTimeRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListServiceOperationsReq_Lastn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListServiceOperationsReq_Lastn{`,
		`Lastn:` + fmt.Sprintf("%v", this.Lastn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceOperationsItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceOperationsItem{`,
		`ServiceOpId:` + fmt.Sprintf("%v", this.ServiceOpId) + `,`,
		`SvcVersion:` + fmt.Sprintf("%v", this.SvcVersion) + `,`,
		`CreatedTime:` + fmt.Sprintf("%v", this.CreatedTime) + `,`,
		`ModifiedTime:` + fmt.Sprintf("%v", this.ModifiedTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListServiceOperationsRsp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*ServiceOperationsItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "ServiceOperationsItem", "ServiceOperationsItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ListServiceOperationsRsp{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "ErrorType", "schema.ErrorType", 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicCustomapi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LilacCDNAccessLogsResponseData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNAccessLogsResponseData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNAccessLogsResponseData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Referer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Referer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamConnectTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamConnectTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamResponseTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamResponseTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeoLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CityId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspSize", wireType)
			}
			m.RspSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RspSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RspCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RspContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqSize", wireType)
			}
			m.ReqSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspCodeClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RspCodeClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostHeader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsSni", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsSni = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, &LilacCDNAccessLogsResponseData{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*log.LogAggregationData)
			}
			var mapkey string
			var mapvalue *log.LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &log.LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNAccessLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNAccessLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNAccessLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = append(m.Query, &CDNAccessLogFilter{})
			if err := m.Query[len(m.Query)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*CDNAggregationRequest)
			}
			var mapkey string
			var mapvalue *CDNAggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CDNAggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNLogAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNLogAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNLogAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*log.LogAggregationData)
			}
			var mapkey string
			var mapvalue *log.LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &log.LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNAccessLogAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNAccessLogAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNAccessLogAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = append(m.Query, &CDNAccessLogFilter{})
			if err := m.Query[len(m.Query)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*CDNAggregationRequest)
			}
			var mapkey string
			var mapvalue *CDNAggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CDNAggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNDateAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &CDNAggregationRequest_DateAggregation{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNFieldAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &CDNAggregationRequest_FieldAggregation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNDateSubAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNDateSubAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNDateSubAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNFieldAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &CDNDateSubAggregation_FieldAggregation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNDateAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNDateAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNDateAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubAggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubAggs == nil {
				m.SubAggs = make(map[string]*CDNDateSubAggregation)
			}
			var mapkey string
			var mapvalue *CDNDateSubAggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CDNDateSubAggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubAggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNFieldAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNFieldAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNFieldAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			m.Field = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field |= access_log.CDNAccessLogTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topk", wireType)
			}
			m.Topk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubAggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubAggs == nil {
				m.SubAggs = make(map[string]*CDNFieldSubAggregation)
			}
			var mapkey string
			var mapvalue *CDNFieldSubAggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CDNFieldSubAggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicCustomapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubAggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNFieldSubAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNFieldSubAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNFieldSubAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FieldAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &CDNFieldSubAggregation_FieldAggregation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			m.Field = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field |= access_log.CDNAccessLogTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topk", wireType)
			}
			m.Topk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNAccessLogFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNAccessLogFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNAccessLogFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= access_log.CDNAccessLogTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			m.Operator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operator |= CDNAccessLogOperatorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v LilacCDNMetricsFieldSelector
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LilacCDNMetricsFieldSelector(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FieldSelector = append(m.FieldSelector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPublicCustomapi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPublicCustomapi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.FieldSelector) == 0 {
					m.FieldSelector = make([]LilacCDNMetricsFieldSelector, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LilacCDNMetricsFieldSelector
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LilacCDNMetricsFieldSelector(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FieldSelector = append(m.FieldSelector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldSelector", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, &LilacCDNMetricsFilter{})
			if err := m.Filter[len(m.Filter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v LilacCDNMetricsTag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LilacCDNMetricsTag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupBy = append(m.GroupBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicCustomapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPublicCustomapi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPublicCustomapi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.GroupBy) == 0 {
					m.GroupBy = make([]LilacCDNMetricsTag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LilacCDNMetricsTag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicCustomapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LilacCDNMetricsTag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupBy = append(m.GroupBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &LilacCDNMetricsResponseData{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNCachePurgeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNCachePurgeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNCachePurgeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeEpochTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurgeEpochTimestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternType = &LilacCDNCachePurgeRequest_Pattern{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftPurge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PurgeType = &LilacCDNCachePurgeRequest_SoftPurge{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardPurge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PurgeType = &LilacCDNCachePurgeRequest_HardPurge{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PatternType = &LilacCDNCachePurgeRequest_PurgeAll{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternType = &LilacCDNCachePurgeRequest_Url{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternType = &LilacCDNCachePurgeRequest_Hostname{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNCachePurgeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNCachePurgeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNCachePurgeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeRequestId", wireType)
			}
			m.PurgeRequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PurgeRequestId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsubscribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsubscribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsubscribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetServiceOperationReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetServiceOperationReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetServiceOperationReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceOpId", wireType)
			}
			m.ServiceOpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceOpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PurgeOperationItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PurgeOperationItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PurgeOperationItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurgeTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regexp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regexp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinishTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardPurge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HardPurge = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesPurged", wireType)
			}
			m.BytesPurged = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesPurged |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesNotPurged", wireType)
			}
			m.BytesNotPurged = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesNotPurged |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOperationItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOperationItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOperationItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceOpId", wireType)
			}
			m.ServiceOpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceOpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PurgeOperationItem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OpStatus = &ServiceOperationItem_Purge{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetServiceOperationRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetServiceOperationRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetServiceOperationRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &schema.ErrorType{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ServiceOperationItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOperationsTimeRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOperationsTimeRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOperationsTimeRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinishTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListServiceOperationsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListServiceOperationsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListServiceOperationsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceOperationsTimeRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &ListServiceOperationsReq_TimeRange{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Options = &ListServiceOperationsReq_Lastn{v}
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOperationsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOperationsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOperationsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceOpId", wireType)
			}
			m.ServiceOpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceOpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcVersion", wireType)
			}
			m.SvcVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SvcVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModifiedTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListServiceOperationsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListServiceOperationsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListServiceOperationsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &schema.ErrorType{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ServiceOperationsItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicCustomapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicCustomapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicCustomapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicCustomapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicCustomapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPublicCustomapi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPublicCustomapi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPublicCustomapi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPublicCustomapi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicCustomapi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPublicCustomapi = fmt.Errorf("proto: unexpected end of group")
)
