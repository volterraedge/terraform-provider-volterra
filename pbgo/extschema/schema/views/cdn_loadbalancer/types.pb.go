// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/cdn_loadbalancer/types.proto

package cdn_loadbalancer

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/rate_limiter"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/route"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy_rule"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/cdn_loadbalancer/access_log"
	http_loadbalancer "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/http_loadbalancer"
	origin_pool "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/origin_pool"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/rate_limiter_policy"
	virtual_host "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host"
	virtual_host_dns_info "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host_dns_info"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Header Options
//
// x-displayName: "Header Options"
type HeaderOptions int32

const (
	// Proxy Host
	//
	// x-displayName: "Proxy Host"
	// Name of the proxied server
	proxy_host HeaderOptions = 0
	// Referer
	//
	// x-displayName: "Referer"
	// This is the address of the previous web page from which a link to the currently requested page was followed
	referer HeaderOptions = 1
	// Scheme
	//
	// x-displayName: "Scheme"
	// The http scheme used: http or https
	scheme HeaderOptions = 2
	// User Agent
	//
	// x-displayName: "User Agent"
	// The user agent string of the user agent
	user_agent HeaderOptions = 3
)

var HeaderOptions_name = map[int32]string{
	0: "proxy_host",
	1: "referer",
	2: "scheme",
	3: "user_agent",
}

var HeaderOptions_value = map[string]int32{
	"proxy_host": 0,
	"referer":    1,
	"scheme":     2,
	"user_agent": 3,
}

func (HeaderOptions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{0}
}

// Metrics Field Selector options
//
// x-displayName: "Metrics Field Selector"
// CDN Metric fields. Naming convention is <field>_<aggregation>
type LilacCDNMetricsFieldSelector int32

const (
	// x-displayName: " REQUEST_TOTAL_SUM"
	// REQUEST_SUCCESS computed from REQUEST_TOTAL - REQUEST_FAILED
	REQUEST_TOTAL_SUM LilacCDNMetricsFieldSelector = 0
	// x-displayName: " REQUEST_FAILED_SUM"
	REQUEST_FAILED_SUM LilacCDNMetricsFieldSelector = 1
	// x-displayName: " REQUEST_1XX_SUM"
	REQUEST_1XX_SUM LilacCDNMetricsFieldSelector = 2
	// x-displayName: " REQUEST_2XX_SUM"
	REQUEST_2XX_SUM LilacCDNMetricsFieldSelector = 3
	// x-displayName: " REQUEST_3XX_SUM"
	REQUEST_3XX_SUM LilacCDNMetricsFieldSelector = 4
	// x-displayName: " REQUEST_4XX_SUM"
	REQUEST_4XX_SUM LilacCDNMetricsFieldSelector = 5
	// x-displayName: " REQUEST_5XX_SUM"
	REQUEST_5XX_SUM LilacCDNMetricsFieldSelector = 6
	// x-displayName: " DATA_OUT_SUM"
	// Bandwidth computed from DATA_OUT
	DATA_OUT_SUM LilacCDNMetricsFieldSelector = 7
	// x-displayName: " LATENCY_MEAN"
	LATENCY_MEAN LilacCDNMetricsFieldSelector = 8
)

var LilacCDNMetricsFieldSelector_name = map[int32]string{
	0: "REQUEST_TOTAL_SUM",
	1: "REQUEST_FAILED_SUM",
	2: "REQUEST_1XX_SUM",
	3: "REQUEST_2XX_SUM",
	4: "REQUEST_3XX_SUM",
	5: "REQUEST_4XX_SUM",
	6: "REQUEST_5XX_SUM",
	7: "DATA_OUT_SUM",
	8: "LATENCY_MEAN",
}

var LilacCDNMetricsFieldSelector_value = map[string]int32{
	"REQUEST_TOTAL_SUM":  0,
	"REQUEST_FAILED_SUM": 1,
	"REQUEST_1XX_SUM":    2,
	"REQUEST_2XX_SUM":    3,
	"REQUEST_3XX_SUM":    4,
	"REQUEST_4XX_SUM":    5,
	"REQUEST_5XX_SUM":    6,
	"DATA_OUT_SUM":       7,
	"LATENCY_MEAN":       8,
}

func (LilacCDNMetricsFieldSelector) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{1}
}

// Metrics Tag options
//
// x-displayName: "Tags"
// Tags on which CDN metrics can be filtered or grouped by
type LilacCDNMetricsTag int32

const (
	// x-displayName: " CDN_DISTRIBUTION_NAME"
	CDN_DISTRIBUTION_NAME LilacCDNMetricsTag = 0
	// x-displayName: " CACHE_HIT_TYPE"
	// HIT|MISS
	CACHE_HIT_TYPE LilacCDNMetricsTag = 1
	// x-displayName: "Request originating country"
	// Two letter country code
	REQUEST_COUNTRY LilacCDNMetricsTag = 2
	// x-displayName: "HTTP Protocol Version"
	// http_1_1|http_2_0 etc
	HTTP_VERSION LilacCDNMetricsTag = 3
	// x-displayName: "TLS Protocol Version"
	// tlsv1_0|tlsv1_1|tlsv1_2 etc
	TLS_VERSION LilacCDNMetricsTag = 4
	// x-displayName: " Region of the PoP"
	POP_REGION LilacCDNMetricsTag = 5
	// x-displayName: "PoP"
	POP LilacCDNMetricsTag = 6
)

var LilacCDNMetricsTag_name = map[int32]string{
	0: "CDN_DISTRIBUTION_NAME",
	1: "CACHE_HIT_TYPE",
	2: "REQUEST_COUNTRY",
	3: "HTTP_VERSION",
	4: "TLS_VERSION",
	5: "POP_REGION",
	6: "POP",
}

var LilacCDNMetricsTag_value = map[string]int32{
	"CDN_DISTRIBUTION_NAME": 0,
	"CACHE_HIT_TYPE":        1,
	"REQUEST_COUNTRY":       2,
	"HTTP_VERSION":          3,
	"TLS_VERSION":           4,
	"POP_REGION":            5,
	"POP":                   6,
}

func (LilacCDNMetricsTag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{2}
}

// Metrics Operator Types
//
// x-displayName: "Metrics Operator Types"
// Operators possible in filtering
type LilacCDNMetricsOperatorType int32

const (
	// x-displayName: " IN Operator"
	OPERATOR_TYPE_IN LilacCDNMetricsOperatorType = 0
	// x-displayName: " Not-IN Operator"
	OPERATOR_TYPE_NOT_IN LilacCDNMetricsOperatorType = 1
)

var LilacCDNMetricsOperatorType_name = map[int32]string{
	0: "OPERATOR_TYPE_IN",
	1: "OPERATOR_TYPE_NOT_IN",
}

var LilacCDNMetricsOperatorType_value = map[string]int32{
	"OPERATOR_TYPE_IN":     0,
	"OPERATOR_TYPE_NOT_IN": 1,
}

func (LilacCDNMetricsOperatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{3}
}

// Metric Unit
//
// x-displayName: "Metric Unit"
// Metric Unit
type LilacCDNMetricUnit int32

const (
	// x-displayName: "Count"
	COUNT LilacCDNMetricUnit = 0
	// x-displayName: "Bytes"
	BYTES LilacCDNMetricUnit = 1
	// x-displayName: "Milliseconds"
	MILLISECONDS LilacCDNMetricUnit = 2
)

var LilacCDNMetricUnit_name = map[int32]string{
	0: "COUNT",
	1: "BYTES",
	2: "MILLISECONDS",
}

var LilacCDNMetricUnit_value = map[string]int32{
	"COUNT":        0,
	"BYTES":        1,
	"MILLISECONDS": 2,
}

func (LilacCDNMetricUnit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{4}
}

// HTTPS with Auto Certs Choice
//
// x-displayName: "HTTPS with Auto Certs Choice"
// Choice for selecting HTTP proxy with bring your own certificates
type ProxyTypeHttpsAutoCerts struct {
	// HTTP Redirect
	//
	// x-displayName: "HTTP Redirect to HTTPS"
	// Redirect HTTP traffic to corresponding HTTPS
	HttpRedirect bool `protobuf:"varint,1,opt,name=http_redirect,json=httpRedirect,proto3" json:"http_redirect,omitempty"`
	// Add HSTS
	//
	// x-displayName: "Add HSTS Header"
	// Add HTTP Strict-Transport-Security response header
	AddHsts bool `protobuf:"varint,2,opt,name=add_hsts,json=addHsts,proto3" json:"add_hsts,omitempty"`
	// TLS Config
	//
	// x-displayName: "TLS Config"
	// Configuration for TLS parameters such as min/max TLS version and ciphers
	TlsConfig *views.TlsConfig `protobuf:"bytes,3,opt,name=tls_config,json=tlsConfig,proto3" json:"tls_config,omitempty"`
	// Server Header configuration
	//
	// x-displayName: "Server Header value to be used in response"
	// x-required
	// Specify Server Header value to be used in responses
	//
	// Types that are valid to be assigned to ServerHeaderChoice:
	//	*ProxyTypeHttpsAutoCerts_DefaultHeader
	//	*ProxyTypeHttpsAutoCerts_ServerName
	//	*ProxyTypeHttpsAutoCerts_AppendServerName
	//	*ProxyTypeHttpsAutoCerts_PassThrough
	ServerHeaderChoice isProxyTypeHttpsAutoCerts_ServerHeaderChoice `protobuf_oneof:"server_header_choice"`
}

func (m *ProxyTypeHttpsAutoCerts) Reset()      { *m = ProxyTypeHttpsAutoCerts{} }
func (*ProxyTypeHttpsAutoCerts) ProtoMessage() {}
func (*ProxyTypeHttpsAutoCerts) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{0}
}
func (m *ProxyTypeHttpsAutoCerts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyTypeHttpsAutoCerts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProxyTypeHttpsAutoCerts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyTypeHttpsAutoCerts.Merge(m, src)
}
func (m *ProxyTypeHttpsAutoCerts) XXX_Size() int {
	return m.Size()
}
func (m *ProxyTypeHttpsAutoCerts) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyTypeHttpsAutoCerts.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyTypeHttpsAutoCerts proto.InternalMessageInfo

type isProxyTypeHttpsAutoCerts_ServerHeaderChoice interface {
	isProxyTypeHttpsAutoCerts_ServerHeaderChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProxyTypeHttpsAutoCerts_DefaultHeader struct {
	DefaultHeader *schema.Empty `protobuf:"bytes,5,opt,name=default_header,json=defaultHeader,proto3,oneof" json:"default_header,omitempty"`
}
type ProxyTypeHttpsAutoCerts_ServerName struct {
	ServerName string `protobuf:"bytes,6,opt,name=server_name,json=serverName,proto3,oneof" json:"server_name,omitempty"`
}
type ProxyTypeHttpsAutoCerts_AppendServerName struct {
	AppendServerName string `protobuf:"bytes,7,opt,name=append_server_name,json=appendServerName,proto3,oneof" json:"append_server_name,omitempty"`
}
type ProxyTypeHttpsAutoCerts_PassThrough struct {
	PassThrough *schema.Empty `protobuf:"bytes,8,opt,name=pass_through,json=passThrough,proto3,oneof" json:"pass_through,omitempty"`
}

func (*ProxyTypeHttpsAutoCerts_DefaultHeader) isProxyTypeHttpsAutoCerts_ServerHeaderChoice()    {}
func (*ProxyTypeHttpsAutoCerts_ServerName) isProxyTypeHttpsAutoCerts_ServerHeaderChoice()       {}
func (*ProxyTypeHttpsAutoCerts_AppendServerName) isProxyTypeHttpsAutoCerts_ServerHeaderChoice() {}
func (*ProxyTypeHttpsAutoCerts_PassThrough) isProxyTypeHttpsAutoCerts_ServerHeaderChoice()      {}

func (m *ProxyTypeHttpsAutoCerts) GetServerHeaderChoice() isProxyTypeHttpsAutoCerts_ServerHeaderChoice {
	if m != nil {
		return m.ServerHeaderChoice
	}
	return nil
}

func (m *ProxyTypeHttpsAutoCerts) GetHttpRedirect() bool {
	if m != nil {
		return m.HttpRedirect
	}
	return false
}

func (m *ProxyTypeHttpsAutoCerts) GetAddHsts() bool {
	if m != nil {
		return m.AddHsts
	}
	return false
}

func (m *ProxyTypeHttpsAutoCerts) GetTlsConfig() *views.TlsConfig {
	if m != nil {
		return m.TlsConfig
	}
	return nil
}

func (m *ProxyTypeHttpsAutoCerts) GetDefaultHeader() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_DefaultHeader); ok {
		return x.DefaultHeader
	}
	return nil
}

func (m *ProxyTypeHttpsAutoCerts) GetServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_ServerName); ok {
		return x.ServerName
	}
	return ""
}

func (m *ProxyTypeHttpsAutoCerts) GetAppendServerName() string {
	if x, ok := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_AppendServerName); ok {
		return x.AppendServerName
	}
	return ""
}

func (m *ProxyTypeHttpsAutoCerts) GetPassThrough() *schema.Empty {
	if x, ok := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_PassThrough); ok {
		return x.PassThrough
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProxyTypeHttpsAutoCerts) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProxyTypeHttpsAutoCerts_DefaultHeader)(nil),
		(*ProxyTypeHttpsAutoCerts_ServerName)(nil),
		(*ProxyTypeHttpsAutoCerts_AppendServerName)(nil),
		(*ProxyTypeHttpsAutoCerts_PassThrough)(nil),
	}
}

// Header Control
//
// x-displayName: "Header Control"
// This defines various options related to request/response headers
type HeaderControlType struct {
	// Headers to add in request
	//
	// x-displayName: "Add Origin Request Headers"
	// Headers are key-value pairs to be added to HTTP request being routed towards upstream.
	// Headers specified at this level are applied after headers from matched Route are applied
	RequestHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,1,rep,name=request_headers_to_add,json=requestHeadersToAdd,proto3" json:"request_headers_to_add,omitempty"`
	// Header to be removed from request
	//
	// x-displayName: "Remove Origin Request Headers"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP request being sent towards upstream.
	RequestHeadersToRemove []string `protobuf:"bytes,2,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// Headers to add in response
	//
	// x-displayName: "Add Response Headers"
	// Headers are key-value pairs to be added to HTTP response being sent towards downstream.
	// Headers specified at this level are applied after headers from matched Route are applied
	ResponseHeadersToAdd []*schema.HeaderManipulationOptionType `protobuf:"bytes,3,rep,name=response_headers_to_add,json=responseHeadersToAdd,proto3" json:"response_headers_to_add,omitempty"`
	// Header to be removed from response
	//
	// x-displayName: "Remove Response Headers"
	// x-example: "host"
	// List of keys of Headers to be removed from the HTTP response being sent towards downstream.
	ResponseHeadersToRemove []string `protobuf:"bytes,4,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
}

func (m *HeaderControlType) Reset()      { *m = HeaderControlType{} }
func (*HeaderControlType) ProtoMessage() {}
func (*HeaderControlType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{1}
}
func (m *HeaderControlType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderControlType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderControlType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderControlType.Merge(m, src)
}
func (m *HeaderControlType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderControlType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderControlType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderControlType proto.InternalMessageInfo

func (m *HeaderControlType) GetRequestHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.RequestHeadersToAdd
	}
	return nil
}

func (m *HeaderControlType) GetRequestHeadersToRemove() []string {
	if m != nil {
		return m.RequestHeadersToRemove
	}
	return nil
}

func (m *HeaderControlType) GetResponseHeadersToAdd() []*schema.HeaderManipulationOptionType {
	if m != nil {
		return m.ResponseHeadersToAdd
	}
	return nil
}

func (m *HeaderControlType) GetResponseHeadersToRemove() []string {
	if m != nil {
		return m.ResponseHeadersToRemove
	}
	return nil
}

// Security options
//
// x-displayName: "Security Options"
// This defines various options related to security
type SecurityOptionsType struct {
	// ip_filtering
	//
	// x-displayName: "Client IP filtering Options"
	// IP filtering options
	IpFiltering *IpFilteringOptions `protobuf:"bytes,5,opt,name=ip_filtering,json=ipFiltering,proto3" json:"ip_filtering,omitempty"`
	// geo_filtering
	//
	// x-displayName: "Client Geo filtering Options"
	// Geo filtering options
	GeoFiltering *GeoFilteringOptions `protobuf:"bytes,6,opt,name=geo_filtering,json=geoFiltering,proto3" json:"geo_filtering,omitempty"`
	// authentication
	//
	// x-displayName: "Authentication Options"
	// Authentication Options
	AuthOptions *AuthenticationOptions `protobuf:"bytes,9,opt,name=auth_options,json=authOptions,proto3" json:"auth_options,omitempty"`
}

func (m *SecurityOptionsType) Reset()      { *m = SecurityOptionsType{} }
func (*SecurityOptionsType) ProtoMessage() {}
func (*SecurityOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{2}
}
func (m *SecurityOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecurityOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityOptionsType.Merge(m, src)
}
func (m *SecurityOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *SecurityOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityOptionsType proto.InternalMessageInfo

func (m *SecurityOptionsType) GetIpFiltering() *IpFilteringOptions {
	if m != nil {
		return m.IpFiltering
	}
	return nil
}

func (m *SecurityOptionsType) GetGeoFiltering() *GeoFilteringOptions {
	if m != nil {
		return m.GeoFiltering
	}
	return nil
}

func (m *SecurityOptionsType) GetAuthOptions() *AuthenticationOptions {
	if m != nil {
		return m.AuthOptions
	}
	return nil
}

// Logging options
//
// x-displayName: "Logging Options"
// This defines various options related to logging
type LoggingOptionsType struct {
	// client_log_options
	//
	// x-displayName: "Client Request Headers to Log"
	// Client request headers to log
	ClientLogOptions *LogHeaderOptions `protobuf:"bytes,7,opt,name=client_log_options,json=clientLogOptions,proto3" json:"client_log_options,omitempty"`
	// origin_log_options
	//
	// x-displayName: "Origin Response Headers to Log"
	// Origin response headers to log
	OriginLogOptions *LogHeaderOptions `protobuf:"bytes,8,opt,name=origin_log_options,json=originLogOptions,proto3" json:"origin_log_options,omitempty"`
}

func (m *LoggingOptionsType) Reset()      { *m = LoggingOptionsType{} }
func (*LoggingOptionsType) ProtoMessage() {}
func (*LoggingOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{3}
}
func (m *LoggingOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggingOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LoggingOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggingOptionsType.Merge(m, src)
}
func (m *LoggingOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *LoggingOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggingOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_LoggingOptionsType proto.InternalMessageInfo

func (m *LoggingOptionsType) GetClientLogOptions() *LogHeaderOptions {
	if m != nil {
		return m.ClientLogOptions
	}
	return nil
}

func (m *LoggingOptionsType) GetOriginLogOptions() *LogHeaderOptions {
	if m != nil {
		return m.OriginLogOptions
	}
	return nil
}

// Cache Rule Expression List
//
// x-displayName: "Cache Rule Expression List"
// CDN Cache Rule Expressions.
type CDNCacheRuleExpressionList struct {
	// Expression Name
	//
	// x-displayName: "Expression Name"
	// x-required
	// x-example: "Expression-1"
	// Name of the Expressions items that are ANDed
	ExpressionName string `protobuf:"bytes,1,opt,name=expression_name,json=expressionName,proto3" json:"expression_name,omitempty"`
	// Terms
	//
	// x-displayName: "Terms"
	// x-required
	// The Cache Rule Expression Terms that are ANDed
	CacheRuleExpression []*CDNCacheRuleExpression `protobuf:"bytes,2,rep,name=cache_rule_expression,json=cacheRuleExpression,proto3" json:"cache_rule_expression,omitempty"`
}

func (m *CDNCacheRuleExpressionList) Reset()      { *m = CDNCacheRuleExpressionList{} }
func (*CDNCacheRuleExpressionList) ProtoMessage() {}
func (*CDNCacheRuleExpressionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{4}
}
func (m *CDNCacheRuleExpressionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNCacheRuleExpressionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNCacheRuleExpressionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNCacheRuleExpressionList.Merge(m, src)
}
func (m *CDNCacheRuleExpressionList) XXX_Size() int {
	return m.Size()
}
func (m *CDNCacheRuleExpressionList) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNCacheRuleExpressionList.DiscardUnknown(m)
}

var xxx_messageInfo_CDNCacheRuleExpressionList proto.InternalMessageInfo

func (m *CDNCacheRuleExpressionList) GetExpressionName() string {
	if m != nil {
		return m.ExpressionName
	}
	return ""
}

func (m *CDNCacheRuleExpressionList) GetCacheRuleExpression() []*CDNCacheRuleExpression {
	if m != nil {
		return m.CacheRuleExpression
	}
	return nil
}

// Cache Operator
//
// x-displayName: "Operator"
type CacheOperator struct {
	// Cache Operator
	//
	// x-displayName: "Operator"
	//
	// Types that are valid to be assigned to CacheOperator:
	//	*CacheOperator_Equals
	//	*CacheOperator_DoesNotEqual
	//	*CacheOperator_Contains
	//	*CacheOperator_DoesNotContain
	//	*CacheOperator_Startswith
	//	*CacheOperator_DoesNotStartWith
	//	*CacheOperator_Endswith
	//	*CacheOperator_DoesNotEndWith
	//	*CacheOperator_MatchRegex
	CacheOperator isCacheOperator_CacheOperator `protobuf_oneof:"cache_operator"`
}

func (m *CacheOperator) Reset()      { *m = CacheOperator{} }
func (*CacheOperator) ProtoMessage() {}
func (*CacheOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{5}
}
func (m *CacheOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheOperator.Merge(m, src)
}
func (m *CacheOperator) XXX_Size() int {
	return m.Size()
}
func (m *CacheOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheOperator.DiscardUnknown(m)
}

var xxx_messageInfo_CacheOperator proto.InternalMessageInfo

type isCacheOperator_CacheOperator interface {
	isCacheOperator_CacheOperator()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CacheOperator_Equals struct {
	Equals string `protobuf:"bytes,2,opt,name=Equals,proto3,oneof" json:"Equals,omitempty"`
}
type CacheOperator_DoesNotEqual struct {
	DoesNotEqual string `protobuf:"bytes,3,opt,name=DoesNotEqual,proto3,oneof" json:"DoesNotEqual,omitempty"`
}
type CacheOperator_Contains struct {
	Contains string `protobuf:"bytes,4,opt,name=Contains,proto3,oneof" json:"Contains,omitempty"`
}
type CacheOperator_DoesNotContain struct {
	DoesNotContain string `protobuf:"bytes,5,opt,name=DoesNotContain,proto3,oneof" json:"DoesNotContain,omitempty"`
}
type CacheOperator_Startswith struct {
	Startswith string `protobuf:"bytes,6,opt,name=Startswith,proto3,oneof" json:"Startswith,omitempty"`
}
type CacheOperator_DoesNotStartWith struct {
	DoesNotStartWith string `protobuf:"bytes,7,opt,name=DoesNotStartWith,proto3,oneof" json:"DoesNotStartWith,omitempty"`
}
type CacheOperator_Endswith struct {
	Endswith string `protobuf:"bytes,8,opt,name=Endswith,proto3,oneof" json:"Endswith,omitempty"`
}
type CacheOperator_DoesNotEndWith struct {
	DoesNotEndWith string `protobuf:"bytes,9,opt,name=DoesNotEndWith,proto3,oneof" json:"DoesNotEndWith,omitempty"`
}
type CacheOperator_MatchRegex struct {
	MatchRegex string `protobuf:"bytes,10,opt,name=MatchRegex,proto3,oneof" json:"MatchRegex,omitempty"`
}

func (*CacheOperator_Equals) isCacheOperator_CacheOperator()           {}
func (*CacheOperator_DoesNotEqual) isCacheOperator_CacheOperator()     {}
func (*CacheOperator_Contains) isCacheOperator_CacheOperator()         {}
func (*CacheOperator_DoesNotContain) isCacheOperator_CacheOperator()   {}
func (*CacheOperator_Startswith) isCacheOperator_CacheOperator()       {}
func (*CacheOperator_DoesNotStartWith) isCacheOperator_CacheOperator() {}
func (*CacheOperator_Endswith) isCacheOperator_CacheOperator()         {}
func (*CacheOperator_DoesNotEndWith) isCacheOperator_CacheOperator()   {}
func (*CacheOperator_MatchRegex) isCacheOperator_CacheOperator()       {}

func (m *CacheOperator) GetCacheOperator() isCacheOperator_CacheOperator {
	if m != nil {
		return m.CacheOperator
	}
	return nil
}

func (m *CacheOperator) GetEquals() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_Equals); ok {
		return x.Equals
	}
	return ""
}

func (m *CacheOperator) GetDoesNotEqual() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_DoesNotEqual); ok {
		return x.DoesNotEqual
	}
	return ""
}

func (m *CacheOperator) GetContains() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_Contains); ok {
		return x.Contains
	}
	return ""
}

func (m *CacheOperator) GetDoesNotContain() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_DoesNotContain); ok {
		return x.DoesNotContain
	}
	return ""
}

func (m *CacheOperator) GetStartswith() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_Startswith); ok {
		return x.Startswith
	}
	return ""
}

func (m *CacheOperator) GetDoesNotStartWith() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_DoesNotStartWith); ok {
		return x.DoesNotStartWith
	}
	return ""
}

func (m *CacheOperator) GetEndswith() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_Endswith); ok {
		return x.Endswith
	}
	return ""
}

func (m *CacheOperator) GetDoesNotEndWith() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_DoesNotEndWith); ok {
		return x.DoesNotEndWith
	}
	return ""
}

func (m *CacheOperator) GetMatchRegex() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_MatchRegex); ok {
		return x.MatchRegex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CacheOperator) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CacheOperator_Equals)(nil),
		(*CacheOperator_DoesNotEqual)(nil),
		(*CacheOperator_Contains)(nil),
		(*CacheOperator_DoesNotContain)(nil),
		(*CacheOperator_Startswith)(nil),
		(*CacheOperator_DoesNotStartWith)(nil),
		(*CacheOperator_Endswith)(nil),
		(*CacheOperator_DoesNotEndWith)(nil),
		(*CacheOperator_MatchRegex)(nil),
	}
}

// CacheHeaderMatcherType
//
// x-displayName: "Cache Header to Match"
// Header match is done using the name of the header and its value.
// The value match is done using one of the following
//
//	regex match on value
//	exact match of value
//	presence of header
//
// Header Match can also be inverse of above, which be used to check
//
//	missing header or
//	non-matching value
type CacheHeaderMatcherType struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "Content-Type"
	// Name of the header
	Name HeaderOptions `protobuf:"varint,1,opt,name=name,proto3,enum=ves.io.schema.views.cdn_loadbalancer.HeaderOptions" json:"name,omitempty"`
	// cache_operator
	//
	// x-displayName: "Operator"
	// Available operators
	Operator *CacheOperator `protobuf:"bytes,5,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *CacheHeaderMatcherType) Reset()      { *m = CacheHeaderMatcherType{} }
func (*CacheHeaderMatcherType) ProtoMessage() {}
func (*CacheHeaderMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{6}
}
func (m *CacheHeaderMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheHeaderMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheHeaderMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheHeaderMatcherType.Merge(m, src)
}
func (m *CacheHeaderMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CacheHeaderMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheHeaderMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CacheHeaderMatcherType proto.InternalMessageInfo

func (m *CacheHeaderMatcherType) GetName() HeaderOptions {
	if m != nil {
		return m.Name
	}
	return proxy_host
}

func (m *CacheHeaderMatcherType) GetOperator() *CacheOperator {
	if m != nil {
		return m.Operator
	}
	return nil
}

// PathMatcherType
//
// x-displayName: "Path to Match"
// Path match of the URI
type CDNPathMatcherType struct {
	// cache_operator
	//
	// x-displayName: "Path Match"
	// A specification of path match
	Operator *CacheOperator `protobuf:"bytes,5,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *CDNPathMatcherType) Reset()      { *m = CDNPathMatcherType{} }
func (*CDNPathMatcherType) ProtoMessage() {}
func (*CDNPathMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{7}
}
func (m *CDNPathMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNPathMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNPathMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNPathMatcherType.Merge(m, src)
}
func (m *CDNPathMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CDNPathMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNPathMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNPathMatcherType proto.InternalMessageInfo

func (m *CDNPathMatcherType) GetOperator() *CacheOperator {
	if m != nil {
		return m.Operator
	}
	return nil
}

// CacheCookieMatcherType
//
// x-displayName: "Cookie Matcher"
// A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each
// cookie in the request.
// A cookie matcher can check for one of the following:
// * Presence or absence of the cookie
// * At least one of the values for the cookie in the request satisfies the MatcherType item
type CacheCookieMatcherType struct {
	// name
	//
	// x-displayName: "Cookie Name"
	// x-example: "Session"
	// x-required
	// A case-sensitive cookie name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// cache_operator
	//
	// x-displayName: "Operator"
	//
	Operator *CacheOperator `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *CacheCookieMatcherType) Reset()      { *m = CacheCookieMatcherType{} }
func (*CacheCookieMatcherType) ProtoMessage() {}
func (*CacheCookieMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{8}
}
func (m *CacheCookieMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheCookieMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheCookieMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheCookieMatcherType.Merge(m, src)
}
func (m *CacheCookieMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CacheCookieMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheCookieMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CacheCookieMatcherType proto.InternalMessageInfo

func (m *CacheCookieMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CacheCookieMatcherType) GetOperator() *CacheOperator {
	if m != nil {
		return m.Operator
	}
	return nil
}

// CacheQueryParameterMatcherType
//
// x-displayName: "Query Parameter to Match"
// Query parameter match can be either regex match on value or exact match of value for given key
// An example for HTTP request with query parameter https://gitlab.com/dashboard/issues?assignee_username=xxyyxx
type CacheQueryParameterMatcherType struct {
	// key
	//
	// x-displayName: "Key"
	// x-required
	// x-example: "assignee_username"
	// Query parameter key
	// In the above example, assignee_username is the key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// cache_operator
	//
	// x-displayName: "Operator"
	//
	Operator *CacheOperator `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *CacheQueryParameterMatcherType) Reset()      { *m = CacheQueryParameterMatcherType{} }
func (*CacheQueryParameterMatcherType) ProtoMessage() {}
func (*CacheQueryParameterMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{9}
}
func (m *CacheQueryParameterMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheQueryParameterMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheQueryParameterMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheQueryParameterMatcherType.Merge(m, src)
}
func (m *CacheQueryParameterMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CacheQueryParameterMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheQueryParameterMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CacheQueryParameterMatcherType proto.InternalMessageInfo

func (m *CacheQueryParameterMatcherType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *CacheQueryParameterMatcherType) GetOperator() *CacheOperator {
	if m != nil {
		return m.Operator
	}
	return nil
}

// CDNCacheRuleExpression
//
// x-displayName: "Cache Rule Expression"
// Select one of the field options
type CDNCacheRuleExpression struct {
	// path_match
	//
	// x-displayName: "Path Match"
	// URI path of route
	PathMatch *CDNPathMatcherType `protobuf:"bytes,1,opt,name=path_match,json=pathMatch,proto3" json:"path_match,omitempty"`
	// query_params
	//
	// x-displayName: "Query Parameters"
	// List of (key, value) query parameters
	QueryParameters []*CacheQueryParameterMatcherType `protobuf:"bytes,6,rep,name=query_parameters,json=queryParameters,proto3" json:"query_parameters,omitempty"`
	// Cache Headers
	//
	// x-displayName: "Cache Headers"
	// Configure cache rule headers to match the criteria
	CacheHeaders []*CacheHeaderMatcherType `protobuf:"bytes,5,rep,name=cache_headers,json=cacheHeaders,proto3" json:"cache_headers,omitempty"`
	// cookie matchers
	//
	// x-displayName: "Cookie Matchers"
	// A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances
	// of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.
	// Note that all specified cookie matcher predicates must evaluate to true.
	CookieMatcher []*CacheCookieMatcherType `protobuf:"bytes,7,rep,name=cookie_matcher,json=cookieMatcher,proto3" json:"cookie_matcher,omitempty"`
}

func (m *CDNCacheRuleExpression) Reset()      { *m = CDNCacheRuleExpression{} }
func (*CDNCacheRuleExpression) ProtoMessage() {}
func (*CDNCacheRuleExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{10}
}
func (m *CDNCacheRuleExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNCacheRuleExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNCacheRuleExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNCacheRuleExpression.Merge(m, src)
}
func (m *CDNCacheRuleExpression) XXX_Size() int {
	return m.Size()
}
func (m *CDNCacheRuleExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNCacheRuleExpression.DiscardUnknown(m)
}

var xxx_messageInfo_CDNCacheRuleExpression proto.InternalMessageInfo

func (m *CDNCacheRuleExpression) GetPathMatch() *CDNPathMatcherType {
	if m != nil {
		return m.PathMatch
	}
	return nil
}

func (m *CDNCacheRuleExpression) GetQueryParameters() []*CacheQueryParameterMatcherType {
	if m != nil {
		return m.QueryParameters
	}
	return nil
}

func (m *CDNCacheRuleExpression) GetCacheHeaders() []*CacheHeaderMatcherType {
	if m != nil {
		return m.CacheHeaders
	}
	return nil
}

func (m *CDNCacheRuleExpression) GetCookieMatcher() []*CacheCookieMatcherType {
	if m != nil {
		return m.CookieMatcher
	}
	return nil
}

// Cache TTL Enable Props
//
// x-displayName: "Cache TTL Enable Props"
// Cache TTL Enable Values
type CacheTTLEnableProps struct {
	// Cache TTL Key
	//
	// x-displayName: "Cache TTL"
	// x-required
	// x-example: "5m, 60s, 120s, 3h, 1d, 15d"
	// Cache TTL value is used to cache the resource/content for the specified amount of time
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	CacheTtl string `protobuf:"bytes,1,opt,name=cache_ttl,json=cacheTtl,proto3" json:"cache_ttl,omitempty"`
	// Set Cookie
	//
	// x-displayName: "Ignore-Response-Cookie"
	// By default, response will not be cached if set-cookie header is present. This option will override the behavior and cache response even with set-cookie header present.
	IgnoreResponseCookie bool `protobuf:"varint,5,opt,name=ignore_response_cookie,json=ignoreResponseCookie,proto3" json:"ignore_response_cookie,omitempty"`
	// Cache Override
	//
	// x-displayName: "Cache Override"
	// Honour Cache Override
	CacheOverride bool `protobuf:"varint,4,opt,name=cache_override,json=cacheOverride,proto3" json:"cache_override,omitempty"`
}

func (m *CacheTTLEnableProps) Reset()      { *m = CacheTTLEnableProps{} }
func (*CacheTTLEnableProps) ProtoMessage() {}
func (*CacheTTLEnableProps) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{11}
}
func (m *CacheTTLEnableProps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheTTLEnableProps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheTTLEnableProps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheTTLEnableProps.Merge(m, src)
}
func (m *CacheTTLEnableProps) XXX_Size() int {
	return m.Size()
}
func (m *CacheTTLEnableProps) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheTTLEnableProps.DiscardUnknown(m)
}

var xxx_messageInfo_CacheTTLEnableProps proto.InternalMessageInfo

func (m *CacheTTLEnableProps) GetCacheTtl() string {
	if m != nil {
		return m.CacheTtl
	}
	return ""
}

func (m *CacheTTLEnableProps) GetIgnoreResponseCookie() bool {
	if m != nil {
		return m.IgnoreResponseCookie
	}
	return false
}

func (m *CacheTTLEnableProps) GetCacheOverride() bool {
	if m != nil {
		return m.CacheOverride
	}
	return false
}

// Cache Action Options
//
// x-displayName: "Cache Action Options"
// List of options for Cache Action
type CacheEligibleOptions struct {
	// Eligible For Cache
	//
	// x-displayName: "Eligible For Cache"
	// x-required
	// Compose Eligible For Cache
	//
	// Types that are valid to be assigned to EligibleForCache:
	//	*CacheEligibleOptions_SchemeHostnameUri
	//	*CacheEligibleOptions_SchemeHostnameRequestUri
	//	*CacheEligibleOptions_HostnameUri
	//	*CacheEligibleOptions_SchemeHostnameUriQuery
	//	*CacheEligibleOptions_SchemeProxyHostUri
	//	*CacheEligibleOptions_SchemeProxyHostRequestUri
	EligibleForCache isCacheEligibleOptions_EligibleForCache `protobuf_oneof:"eligible_for_cache"`
}

func (m *CacheEligibleOptions) Reset()      { *m = CacheEligibleOptions{} }
func (*CacheEligibleOptions) ProtoMessage() {}
func (*CacheEligibleOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{12}
}
func (m *CacheEligibleOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheEligibleOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheEligibleOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheEligibleOptions.Merge(m, src)
}
func (m *CacheEligibleOptions) XXX_Size() int {
	return m.Size()
}
func (m *CacheEligibleOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheEligibleOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CacheEligibleOptions proto.InternalMessageInfo

type isCacheEligibleOptions_EligibleForCache interface {
	isCacheEligibleOptions_EligibleForCache()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CacheEligibleOptions_SchemeHostnameUri struct {
	SchemeHostnameUri *CacheTTLEnableProps `protobuf:"bytes,2,opt,name=scheme_hostname_uri,json=schemeHostnameUri,proto3,oneof" json:"scheme_hostname_uri,omitempty"`
}
type CacheEligibleOptions_SchemeHostnameRequestUri struct {
	SchemeHostnameRequestUri *CacheTTLEnableProps `protobuf:"bytes,3,opt,name=scheme_hostname_request_uri,json=schemeHostnameRequestUri,proto3,oneof" json:"scheme_hostname_request_uri,omitempty"`
}
type CacheEligibleOptions_HostnameUri struct {
	HostnameUri *CacheTTLEnableProps `protobuf:"bytes,4,opt,name=hostname_uri,json=hostnameUri,proto3,oneof" json:"hostname_uri,omitempty"`
}
type CacheEligibleOptions_SchemeHostnameUriQuery struct {
	SchemeHostnameUriQuery *CacheTTLEnableProps `protobuf:"bytes,5,opt,name=scheme_hostname_uri_query,json=schemeHostnameUriQuery,proto3,oneof" json:"scheme_hostname_uri_query,omitempty"`
}
type CacheEligibleOptions_SchemeProxyHostUri struct {
	SchemeProxyHostUri *CacheTTLEnableProps `protobuf:"bytes,6,opt,name=scheme_proxy_host_uri,json=schemeProxyHostUri,proto3,oneof" json:"scheme_proxy_host_uri,omitempty"`
}
type CacheEligibleOptions_SchemeProxyHostRequestUri struct {
	SchemeProxyHostRequestUri *CacheTTLEnableProps `protobuf:"bytes,7,opt,name=scheme_proxy_host_request_uri,json=schemeProxyHostRequestUri,proto3,oneof" json:"scheme_proxy_host_request_uri,omitempty"`
}

func (*CacheEligibleOptions_SchemeHostnameUri) isCacheEligibleOptions_EligibleForCache()         {}
func (*CacheEligibleOptions_SchemeHostnameRequestUri) isCacheEligibleOptions_EligibleForCache()  {}
func (*CacheEligibleOptions_HostnameUri) isCacheEligibleOptions_EligibleForCache()               {}
func (*CacheEligibleOptions_SchemeHostnameUriQuery) isCacheEligibleOptions_EligibleForCache()    {}
func (*CacheEligibleOptions_SchemeProxyHostUri) isCacheEligibleOptions_EligibleForCache()        {}
func (*CacheEligibleOptions_SchemeProxyHostRequestUri) isCacheEligibleOptions_EligibleForCache() {}

func (m *CacheEligibleOptions) GetEligibleForCache() isCacheEligibleOptions_EligibleForCache {
	if m != nil {
		return m.EligibleForCache
	}
	return nil
}

// Deprecated: Do not use.
func (m *CacheEligibleOptions) GetSchemeHostnameUri() *CacheTTLEnableProps {
	if x, ok := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeHostnameUri); ok {
		return x.SchemeHostnameUri
	}
	return nil
}

// Deprecated: Do not use.
func (m *CacheEligibleOptions) GetSchemeHostnameRequestUri() *CacheTTLEnableProps {
	if x, ok := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeHostnameRequestUri); ok {
		return x.SchemeHostnameRequestUri
	}
	return nil
}

// Deprecated: Do not use.
func (m *CacheEligibleOptions) GetHostnameUri() *CacheTTLEnableProps {
	if x, ok := m.GetEligibleForCache().(*CacheEligibleOptions_HostnameUri); ok {
		return x.HostnameUri
	}
	return nil
}

// Deprecated: Do not use.
func (m *CacheEligibleOptions) GetSchemeHostnameUriQuery() *CacheTTLEnableProps {
	if x, ok := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeHostnameUriQuery); ok {
		return x.SchemeHostnameUriQuery
	}
	return nil
}

func (m *CacheEligibleOptions) GetSchemeProxyHostUri() *CacheTTLEnableProps {
	if x, ok := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeProxyHostUri); ok {
		return x.SchemeProxyHostUri
	}
	return nil
}

func (m *CacheEligibleOptions) GetSchemeProxyHostRequestUri() *CacheTTLEnableProps {
	if x, ok := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeProxyHostRequestUri); ok {
		return x.SchemeProxyHostRequestUri
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CacheEligibleOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CacheEligibleOptions_SchemeHostnameUri)(nil),
		(*CacheEligibleOptions_SchemeHostnameRequestUri)(nil),
		(*CacheEligibleOptions_HostnameUri)(nil),
		(*CacheEligibleOptions_SchemeHostnameUriQuery)(nil),
		(*CacheEligibleOptions_SchemeProxyHostUri)(nil),
		(*CacheEligibleOptions_SchemeProxyHostRequestUri)(nil),
	}
}

// Cache Rule
//
// x-displayName: "Cache Rule"
// This defines a CDN Cache Rule
type CDNCacheRule struct {
	// Rule Name
	//
	// x-displayName: "Rule Name"
	// x-required
	// x-example: "Rule-1"
	// Name of the Cache Rule
	RuleName string `protobuf:"bytes,1,opt,name=rule_name,json=ruleName,proto3" json:"rule_name,omitempty"`
	// Expression List
	//
	// x-displayName: "Expressions"
	// x-required
	// Expressions are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs..
	RuleExpressionList []*CDNCacheRuleExpressionList `protobuf:"bytes,2,rep,name=rule_expression_list,json=ruleExpressionList,proto3" json:"rule_expression_list,omitempty"`
	// Cache Actions
	//
	// x-displayName: "Cache Actions"
	// x-required
	// Configure the Cache Actions for a rule.
	//
	// Types that are valid to be assigned to CacheActions:
	//	*CDNCacheRule_CacheBypass
	//	*CDNCacheRule_EligibleForCache
	CacheActions isCDNCacheRule_CacheActions `protobuf_oneof:"cache_actions"`
}

func (m *CDNCacheRule) Reset()      { *m = CDNCacheRule{} }
func (*CDNCacheRule) ProtoMessage() {}
func (*CDNCacheRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{13}
}
func (m *CDNCacheRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNCacheRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNCacheRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNCacheRule.Merge(m, src)
}
func (m *CDNCacheRule) XXX_Size() int {
	return m.Size()
}
func (m *CDNCacheRule) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNCacheRule.DiscardUnknown(m)
}

var xxx_messageInfo_CDNCacheRule proto.InternalMessageInfo

type isCDNCacheRule_CacheActions interface {
	isCDNCacheRule_CacheActions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CDNCacheRule_CacheBypass struct {
	CacheBypass *schema.Empty `protobuf:"bytes,4,opt,name=cache_bypass,json=cacheBypass,proto3,oneof" json:"cache_bypass,omitempty"`
}
type CDNCacheRule_EligibleForCache struct {
	EligibleForCache *CacheEligibleOptions `protobuf:"bytes,5,opt,name=eligible_for_cache,json=eligibleForCache,proto3,oneof" json:"eligible_for_cache,omitempty"`
}

func (*CDNCacheRule_CacheBypass) isCDNCacheRule_CacheActions()      {}
func (*CDNCacheRule_EligibleForCache) isCDNCacheRule_CacheActions() {}

func (m *CDNCacheRule) GetCacheActions() isCDNCacheRule_CacheActions {
	if m != nil {
		return m.CacheActions
	}
	return nil
}

func (m *CDNCacheRule) GetRuleName() string {
	if m != nil {
		return m.RuleName
	}
	return ""
}

func (m *CDNCacheRule) GetRuleExpressionList() []*CDNCacheRuleExpressionList {
	if m != nil {
		return m.RuleExpressionList
	}
	return nil
}

func (m *CDNCacheRule) GetCacheBypass() *schema.Empty {
	if x, ok := m.GetCacheActions().(*CDNCacheRule_CacheBypass); ok {
		return x.CacheBypass
	}
	return nil
}

func (m *CDNCacheRule) GetEligibleForCache() *CacheEligibleOptions {
	if x, ok := m.GetCacheActions().(*CDNCacheRule_EligibleForCache); ok {
		return x.EligibleForCache
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CDNCacheRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CDNCacheRule_CacheBypass)(nil),
		(*CDNCacheRule_EligibleForCache)(nil),
	}
}

// Default Cache TTL Props
//
// x-displayName: "Default Cache TTL Props"
// Default Cache TTL Enable Values
type DefaultCacheTTLProps struct {
	// Cache TTL Key
	//
	// x-displayName: "Cache TTL"
	// x-required
	// x-example: "5m, 60s, 120s, 3h, 1d, 15d"
	// Cache TTL value is used to cache the resource/content for the specified amount of time
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	CacheTtl string `protobuf:"bytes,1,opt,name=cache_ttl,json=cacheTtl,proto3" json:"cache_ttl,omitempty"`
}

func (m *DefaultCacheTTLProps) Reset()      { *m = DefaultCacheTTLProps{} }
func (*DefaultCacheTTLProps) ProtoMessage() {}
func (*DefaultCacheTTLProps) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{14}
}
func (m *DefaultCacheTTLProps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultCacheTTLProps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DefaultCacheTTLProps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultCacheTTLProps.Merge(m, src)
}
func (m *DefaultCacheTTLProps) XXX_Size() int {
	return m.Size()
}
func (m *DefaultCacheTTLProps) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultCacheTTLProps.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultCacheTTLProps proto.InternalMessageInfo

func (m *DefaultCacheTTLProps) GetCacheTtl() string {
	if m != nil {
		return m.CacheTtl
	}
	return ""
}

// Default Cache Action
//
// x-displayName: "Default Cache Action"
// This defines a Default Cache Action
type DefaultCacheAction struct {
	// Cache Actions
	//
	// x-displayName: "Cache Actions"
	// Configure the Cache Actions for a rule.
	//
	// Types that are valid to be assigned to CacheActions:
	//	*DefaultCacheAction_EligibleForCache
	//	*DefaultCacheAction_CacheTtlDefault
	//	*DefaultCacheAction_CacheTtlOverride
	//	*DefaultCacheAction_CacheDisabled
	CacheActions isDefaultCacheAction_CacheActions `protobuf_oneof:"cache_actions"`
}

func (m *DefaultCacheAction) Reset()      { *m = DefaultCacheAction{} }
func (*DefaultCacheAction) ProtoMessage() {}
func (*DefaultCacheAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{15}
}
func (m *DefaultCacheAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultCacheAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DefaultCacheAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultCacheAction.Merge(m, src)
}
func (m *DefaultCacheAction) XXX_Size() int {
	return m.Size()
}
func (m *DefaultCacheAction) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultCacheAction.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultCacheAction proto.InternalMessageInfo

type isDefaultCacheAction_CacheActions interface {
	isDefaultCacheAction_CacheActions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DefaultCacheAction_EligibleForCache struct {
	EligibleForCache *DefaultCacheTTLProps `protobuf:"bytes,2,opt,name=eligible_for_cache,json=eligibleForCache,proto3,oneof" json:"eligible_for_cache,omitempty"`
}
type DefaultCacheAction_CacheTtlDefault struct {
	CacheTtlDefault string `protobuf:"bytes,3,opt,name=cache_ttl_default,json=cacheTtlDefault,proto3,oneof" json:"cache_ttl_default,omitempty"`
}
type DefaultCacheAction_CacheTtlOverride struct {
	CacheTtlOverride string `protobuf:"bytes,4,opt,name=cache_ttl_override,json=cacheTtlOverride,proto3,oneof" json:"cache_ttl_override,omitempty"`
}
type DefaultCacheAction_CacheDisabled struct {
	CacheDisabled *schema.Empty `protobuf:"bytes,5,opt,name=cache_disabled,json=cacheDisabled,proto3,oneof" json:"cache_disabled,omitempty"`
}

func (*DefaultCacheAction_EligibleForCache) isDefaultCacheAction_CacheActions() {}
func (*DefaultCacheAction_CacheTtlDefault) isDefaultCacheAction_CacheActions()  {}
func (*DefaultCacheAction_CacheTtlOverride) isDefaultCacheAction_CacheActions() {}
func (*DefaultCacheAction_CacheDisabled) isDefaultCacheAction_CacheActions()    {}

func (m *DefaultCacheAction) GetCacheActions() isDefaultCacheAction_CacheActions {
	if m != nil {
		return m.CacheActions
	}
	return nil
}

// Deprecated: Do not use.
func (m *DefaultCacheAction) GetEligibleForCache() *DefaultCacheTTLProps {
	if x, ok := m.GetCacheActions().(*DefaultCacheAction_EligibleForCache); ok {
		return x.EligibleForCache
	}
	return nil
}

func (m *DefaultCacheAction) GetCacheTtlDefault() string {
	if x, ok := m.GetCacheActions().(*DefaultCacheAction_CacheTtlDefault); ok {
		return x.CacheTtlDefault
	}
	return ""
}

func (m *DefaultCacheAction) GetCacheTtlOverride() string {
	if x, ok := m.GetCacheActions().(*DefaultCacheAction_CacheTtlOverride); ok {
		return x.CacheTtlOverride
	}
	return ""
}

func (m *DefaultCacheAction) GetCacheDisabled() *schema.Empty {
	if x, ok := m.GetCacheActions().(*DefaultCacheAction_CacheDisabled); ok {
		return x.CacheDisabled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DefaultCacheAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DefaultCacheAction_EligibleForCache)(nil),
		(*DefaultCacheAction_CacheTtlDefault)(nil),
		(*DefaultCacheAction_CacheTtlOverride)(nil),
		(*DefaultCacheAction_CacheDisabled)(nil),
	}
}

// Cache options
//
// x-displayName: "Cache Options"
// This defines the options related to content caching
type CacheOptions struct {
	// Default Cache Action
	//
	// x-displayName: "Default Cache Action"
	// x-required
	// Default value for Cache action.
	DefaultCacheAction *DefaultCacheAction `protobuf:"bytes,1,opt,name=default_cache_action,json=defaultCacheAction,proto3" json:"default_cache_action,omitempty"`
	// List of Cache rules(These rules are ORed)
	//
	// x-displayName: "Cache Rules"
	// Rules are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs.
	CacheRules []*CDNCacheRule `protobuf:"bytes,2,rep,name=cache_rules,json=cacheRules,proto3" json:"cache_rules,omitempty"`
}

func (m *CacheOptions) Reset()      { *m = CacheOptions{} }
func (*CacheOptions) ProtoMessage() {}
func (*CacheOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{16}
}
func (m *CacheOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheOptions.Merge(m, src)
}
func (m *CacheOptions) XXX_Size() int {
	return m.Size()
}
func (m *CacheOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CacheOptions proto.InternalMessageInfo

func (m *CacheOptions) GetDefaultCacheAction() *DefaultCacheAction {
	if m != nil {
		return m.DefaultCacheAction
	}
	return nil
}

func (m *CacheOptions) GetCacheRules() []*CDNCacheRule {
	if m != nil {
		return m.CacheRules
	}
	return nil
}

// Cache options
//
// x-displayName: "Cache Options"
// This defines the options related to content caching
type CacheTTLOptionsType struct {
	// Cache Options
	//
	// x-displayName: "Cache Settings"
	// Configure the Cache Settings
	//
	// Types that are valid to be assigned to TtlOptions:
	//	*CacheTTLOptionsType_CacheTtlDefault
	//	*CacheTTLOptionsType_CacheTtlOverride
	//	*CacheTTLOptionsType_CacheDisabled
	TtlOptions isCacheTTLOptionsType_TtlOptions `protobuf_oneof:"ttl_options"`
}

func (m *CacheTTLOptionsType) Reset()      { *m = CacheTTLOptionsType{} }
func (*CacheTTLOptionsType) ProtoMessage() {}
func (*CacheTTLOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{17}
}
func (m *CacheTTLOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheTTLOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheTTLOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheTTLOptionsType.Merge(m, src)
}
func (m *CacheTTLOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *CacheTTLOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheTTLOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_CacheTTLOptionsType proto.InternalMessageInfo

type isCacheTTLOptionsType_TtlOptions interface {
	isCacheTTLOptionsType_TtlOptions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CacheTTLOptionsType_CacheTtlDefault struct {
	CacheTtlDefault string `protobuf:"bytes,2,opt,name=cache_ttl_default,json=cacheTtlDefault,proto3,oneof" json:"cache_ttl_default,omitempty"`
}
type CacheTTLOptionsType_CacheTtlOverride struct {
	CacheTtlOverride string `protobuf:"bytes,3,opt,name=cache_ttl_override,json=cacheTtlOverride,proto3,oneof" json:"cache_ttl_override,omitempty"`
}
type CacheTTLOptionsType_CacheDisabled struct {
	CacheDisabled *schema.Empty `protobuf:"bytes,4,opt,name=cache_disabled,json=cacheDisabled,proto3,oneof" json:"cache_disabled,omitempty"`
}

func (*CacheTTLOptionsType_CacheTtlDefault) isCacheTTLOptionsType_TtlOptions()  {}
func (*CacheTTLOptionsType_CacheTtlOverride) isCacheTTLOptionsType_TtlOptions() {}
func (*CacheTTLOptionsType_CacheDisabled) isCacheTTLOptionsType_TtlOptions()    {}

func (m *CacheTTLOptionsType) GetTtlOptions() isCacheTTLOptionsType_TtlOptions {
	if m != nil {
		return m.TtlOptions
	}
	return nil
}

func (m *CacheTTLOptionsType) GetCacheTtlDefault() string {
	if x, ok := m.GetTtlOptions().(*CacheTTLOptionsType_CacheTtlDefault); ok {
		return x.CacheTtlDefault
	}
	return ""
}

func (m *CacheTTLOptionsType) GetCacheTtlOverride() string {
	if x, ok := m.GetTtlOptions().(*CacheTTLOptionsType_CacheTtlOverride); ok {
		return x.CacheTtlOverride
	}
	return ""
}

func (m *CacheTTLOptionsType) GetCacheDisabled() *schema.Empty {
	if x, ok := m.GetTtlOptions().(*CacheTTLOptionsType_CacheDisabled); ok {
		return x.CacheDisabled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CacheTTLOptionsType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CacheTTLOptionsType_CacheTtlDefault)(nil),
		(*CacheTTLOptionsType_CacheTtlOverride)(nil),
		(*CacheTTLOptionsType_CacheDisabled)(nil),
	}
}

// Advanced options
//
// x-displayName: "Advanced Options"
// This defines various options to define a route
type AdvancedOptionsType struct {
	// Header Control
	//
	// x-displayName: "Header Control"
	// Request/Response header related options
	HeaderOptions *HeaderControlType `protobuf:"bytes,16,opt,name=header_options,json=headerOptions,proto3" json:"header_options,omitempty"`
	// Security Options
	//
	// x-displayName: "Security Options"
	// Security related options
	SecurityOptions *SecurityOptionsType `protobuf:"bytes,17,opt,name=security_options,json=securityOptions,proto3" json:"security_options,omitempty"`
	// Logging Options
	//
	// x-displayName: "Logging Options"
	// Logging related options
	LoggingOptions *LoggingOptionsType `protobuf:"bytes,18,opt,name=logging_options,json=loggingOptions,proto3" json:"logging_options,omitempty"`
	// Cache Options
	//
	// x-displayName: "Cache Options"
	// Cache Options
	CacheTtlOptions *CacheTTLOptionsType `protobuf:"bytes,19,opt,name=cache_ttl_options,json=cacheTtlOptions,proto3" json:"cache_ttl_options,omitempty"` // Deprecated: Do not use.
	// Cache Options
	//
	// x-displayName: "Cache Options"
	// Cache Options
	CacheOptions *CacheOptions `protobuf:"bytes,20,opt,name=cache_options,json=cacheOptions,proto3" json:"cache_options,omitempty"`
}

func (m *AdvancedOptionsType) Reset()      { *m = AdvancedOptionsType{} }
func (*AdvancedOptionsType) ProtoMessage() {}
func (*AdvancedOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{18}
}
func (m *AdvancedOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdvancedOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AdvancedOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdvancedOptionsType.Merge(m, src)
}
func (m *AdvancedOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *AdvancedOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_AdvancedOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_AdvancedOptionsType proto.InternalMessageInfo

func (m *AdvancedOptionsType) GetHeaderOptions() *HeaderControlType {
	if m != nil {
		return m.HeaderOptions
	}
	return nil
}

func (m *AdvancedOptionsType) GetSecurityOptions() *SecurityOptionsType {
	if m != nil {
		return m.SecurityOptions
	}
	return nil
}

func (m *AdvancedOptionsType) GetLoggingOptions() *LoggingOptionsType {
	if m != nil {
		return m.LoggingOptions
	}
	return nil
}

// Deprecated: Do not use.
func (m *AdvancedOptionsType) GetCacheTtlOptions() *CacheTTLOptionsType {
	if m != nil {
		return m.CacheTtlOptions
	}
	return nil
}

func (m *AdvancedOptionsType) GetCacheOptions() *CacheOptions {
	if m != nil {
		return m.CacheOptions
	}
	return nil
}

// CDNTLSConfig
//
// x-displayName: "TLS Config"
// This defines various options to configure TLS configuration parameters
type CDNTLSConfig struct {
	// TLS Security Level
	//
	// x-displayName: "TLS Security Level"
	// x-required
	// The security level for TLS handshake between client/server and the platform.
	//
	// Types that are valid to be assigned to Choice:
	//	*CDNTLSConfig_Tls_12Plus
	//	*CDNTLSConfig_Tls_11Plus
	Choice isCDNTLSConfig_Choice `protobuf_oneof:"choice"`
}

func (m *CDNTLSConfig) Reset()      { *m = CDNTLSConfig{} }
func (*CDNTLSConfig) ProtoMessage() {}
func (*CDNTLSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{19}
}
func (m *CDNTLSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNTLSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNTLSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNTLSConfig.Merge(m, src)
}
func (m *CDNTLSConfig) XXX_Size() int {
	return m.Size()
}
func (m *CDNTLSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNTLSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CDNTLSConfig proto.InternalMessageInfo

type isCDNTLSConfig_Choice interface {
	isCDNTLSConfig_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CDNTLSConfig_Tls_12Plus struct {
	Tls_12Plus *schema.Empty `protobuf:"bytes,1,opt,name=tls_12_plus,json=tls12Plus,proto3,oneof" json:"tls_12_plus,omitempty"`
}
type CDNTLSConfig_Tls_11Plus struct {
	Tls_11Plus *schema.Empty `protobuf:"bytes,2,opt,name=tls_11_plus,json=tls11Plus,proto3,oneof" json:"tls_11_plus,omitempty"`
}

func (*CDNTLSConfig_Tls_12Plus) isCDNTLSConfig_Choice() {}
func (*CDNTLSConfig_Tls_11Plus) isCDNTLSConfig_Choice() {}

func (m *CDNTLSConfig) GetChoice() isCDNTLSConfig_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *CDNTLSConfig) GetTls_12Plus() *schema.Empty {
	if x, ok := m.GetChoice().(*CDNTLSConfig_Tls_12Plus); ok {
		return x.Tls_12Plus
	}
	return nil
}

func (m *CDNTLSConfig) GetTls_11Plus() *schema.Empty {
	if x, ok := m.GetChoice().(*CDNTLSConfig_Tls_11Plus); ok {
		return x.Tls_11Plus
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CDNTLSConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CDNTLSConfig_Tls_12Plus)(nil),
		(*CDNTLSConfig_Tls_11Plus)(nil),
	}
}

// HTTPS with Automatic Certificate
//
// x-displayName: "HTTPS with Automatic Certificate"
// Choice for selecting HTTPS CDN distribution with bring your own certificates
type CDNHTTPSAutoCertsType struct {
	// HTTP Redirect
	//
	// x-displayName: "HTTP Redirect to HTTPS"
	// Redirect HTTP traffic to HTTPS
	HttpRedirect bool `protobuf:"varint,1,opt,name=http_redirect,json=httpRedirect,proto3" json:"http_redirect,omitempty"`
	// Add HSTS
	//
	// x-displayName: "Add HSTS Header"
	// Add HTTP Strict-Transport-Security response header
	AddHsts bool `protobuf:"varint,2,opt,name=add_hsts,json=addHsts,proto3" json:"add_hsts,omitempty"`
	// TLS Config
	//
	// x-displayName: "TLS"
	// TLS Configuration Parameters
	TlsConfig *CDNTLSConfig `protobuf:"bytes,3,opt,name=tls_config,json=tlsConfig,proto3" json:"tls_config,omitempty"`
}

func (m *CDNHTTPSAutoCertsType) Reset()      { *m = CDNHTTPSAutoCertsType{} }
func (*CDNHTTPSAutoCertsType) ProtoMessage() {}
func (*CDNHTTPSAutoCertsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{20}
}
func (m *CDNHTTPSAutoCertsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNHTTPSAutoCertsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNHTTPSAutoCertsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNHTTPSAutoCertsType.Merge(m, src)
}
func (m *CDNHTTPSAutoCertsType) XXX_Size() int {
	return m.Size()
}
func (m *CDNHTTPSAutoCertsType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNHTTPSAutoCertsType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNHTTPSAutoCertsType proto.InternalMessageInfo

func (m *CDNHTTPSAutoCertsType) GetHttpRedirect() bool {
	if m != nil {
		return m.HttpRedirect
	}
	return false
}

func (m *CDNHTTPSAutoCertsType) GetAddHsts() bool {
	if m != nil {
		return m.AddHsts
	}
	return false
}

func (m *CDNHTTPSAutoCertsType) GetTlsConfig() *CDNTLSConfig {
	if m != nil {
		return m.TlsConfig
	}
	return nil
}

// CDNDownstreamTlsParamsType
//
// x-displayName: "TLS Parameters"
// TLS parameters for CDN distribution
type CDNDownstreamTlsParamsType struct {
	// TLS Config
	//
	// x-displayName: "TLS"
	// TLS Configuration Parameters
	TlsConfig *CDNTLSConfig `protobuf:"bytes,1,opt,name=tls_config,json=tlsConfig,proto3" json:"tls_config,omitempty"`
	// tls_certificates
	//
	// x-displayName: "TLS Certificates"
	// x-required
	// Users can add one or more certificates that share the same set of domains.
	// for example, domain.com and *.domain.com - but use different signature algorithms
	TlsCertificates []*schema.TlsCertificateType `protobuf:"bytes,2,rep,name=tls_certificates,json=tlsCertificates,proto3" json:"tls_certificates,omitempty"`
}

func (m *CDNDownstreamTlsParamsType) Reset()      { *m = CDNDownstreamTlsParamsType{} }
func (*CDNDownstreamTlsParamsType) ProtoMessage() {}
func (*CDNDownstreamTlsParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{21}
}
func (m *CDNDownstreamTlsParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNDownstreamTlsParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNDownstreamTlsParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNDownstreamTlsParamsType.Merge(m, src)
}
func (m *CDNDownstreamTlsParamsType) XXX_Size() int {
	return m.Size()
}
func (m *CDNDownstreamTlsParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNDownstreamTlsParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNDownstreamTlsParamsType proto.InternalMessageInfo

func (m *CDNDownstreamTlsParamsType) GetTlsConfig() *CDNTLSConfig {
	if m != nil {
		return m.TlsConfig
	}
	return nil
}

func (m *CDNDownstreamTlsParamsType) GetTlsCertificates() []*schema.TlsCertificateType {
	if m != nil {
		return m.TlsCertificates
	}
	return nil
}

// BYOC for the CDN distribution
//
// x-displayName: "BYOC HTTPS Choice"
// Choice for selecting CDN Distribution with bring your own certificates
type CDNHTTPSCustomCertsType struct {
	// HTTP Redirect
	//
	// x-displayName: "HTTP Redirect to HTTPS"
	// Redirect HTTP traffic to HTTPS
	HttpRedirect bool `protobuf:"varint,1,opt,name=http_redirect,json=httpRedirect,proto3" json:"http_redirect,omitempty"`
	// Add HSTS
	//
	// x-displayName: "Add HSTS Header"
	// Add HTTP Strict-Transport-Security response header
	AddHsts bool `protobuf:"varint,2,opt,name=add_hsts,json=addHsts,proto3" json:"add_hsts,omitempty"`
	// TLS parameters.
	//
	// x-displayName: "TLS Parameters"
	// TLS parameters for the downstream connections.
	TlsParameters *CDNDownstreamTlsParamsType `protobuf:"bytes,3,opt,name=tls_parameters,json=tlsParameters,proto3" json:"tls_parameters,omitempty"`
}

func (m *CDNHTTPSCustomCertsType) Reset()      { *m = CDNHTTPSCustomCertsType{} }
func (*CDNHTTPSCustomCertsType) ProtoMessage() {}
func (*CDNHTTPSCustomCertsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{22}
}
func (m *CDNHTTPSCustomCertsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNHTTPSCustomCertsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNHTTPSCustomCertsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNHTTPSCustomCertsType.Merge(m, src)
}
func (m *CDNHTTPSCustomCertsType) XXX_Size() int {
	return m.Size()
}
func (m *CDNHTTPSCustomCertsType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNHTTPSCustomCertsType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNHTTPSCustomCertsType proto.InternalMessageInfo

func (m *CDNHTTPSCustomCertsType) GetHttpRedirect() bool {
	if m != nil {
		return m.HttpRedirect
	}
	return false
}

func (m *CDNHTTPSCustomCertsType) GetAddHsts() bool {
	if m != nil {
		return m.AddHsts
	}
	return false
}

func (m *CDNHTTPSCustomCertsType) GetTlsParameters() *CDNDownstreamTlsParamsType {
	if m != nil {
		return m.TlsParameters
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Shape of the CDN loadbalancer specification
type GlobalSpecType struct {
	// Domains
	//
	// x-displayName: "Domains"
	// x-example: "www.foo.com"
	// x-required
	// A list of fully qualified domain names.
	// The CDN Distribution will be setup for these FQDN name(s).
	// [This can be a domain or a sub-domain]
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Proxy choice
	//
	// x-displayName: "Select Type of CDN Distribution"
	// x-required
	// CDN Distribution type can be "http" or "https"
	//
	// Types that are valid to be assigned to LoadbalancerType:
	//	*GlobalSpecType_Http
	//	*GlobalSpecType_HttpsAutoCert
	//	*GlobalSpecType_Https
	LoadbalancerType isGlobalSpecType_LoadbalancerType `protobuf_oneof:"loadbalancer_type"`
	// Add Site information
	//
	// x-displayName: "Add Location"
	// x-example: "true"
	// x-example: true
	// Appends header x-volterra-location = <re-site-name> in responses.
	AddLocation bool `protobuf:"varint,11,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	// More Options
	//
	// x-displayName: "More Options"
	// More options like header manipulation, compression etc.
	MoreOption *AdvancedOptionsType `protobuf:"bytes,13,opt,name=more_option,json=moreOption,proto3" json:"more_option,omitempty"`
	// Origin Pool
	//
	// x-displayName: "CDN Origin Pool"
	// x-required
	OriginPool *CdnOriginPoolType `protobuf:"bytes,16,opt,name=origin_pool,json=originPool,proto3" json:"origin_pool,omitempty"`
	// view_internal
	//
	// x-displayName: "View Internal"
	// Reference to view internal object
	ViewInternal *views.ObjectRefType `protobuf:"bytes,1000,opt,name=view_internal,json=viewInternal,proto3" json:"view_internal,omitempty"`
	// host name
	//
	// x-displayName: "Host Name"
	// x-example: "ves-io-cf8684b9-a18f-4843-a24f-1f9ee8ea2776.ac.vh.ves.io"
	// Internally generated host name to be used for the virtual host
	HostName string `protobuf:"bytes,1001,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// DNS information
	//
	// x-displayName: "DNS Information"
	// DNS information for this virtual host
	DnsInfo []*virtual_host_dns_info.DnsInfo `protobuf:"bytes,1002,rep,name=dns_info,json=dnsInfo,proto3" json:"dns_info,omitempty"`
	// Virtual Host state
	//
	// x-displayName: "Virtual Host State"
	// State of the virtual host
	State virtual_host.VirtualHostState `protobuf:"varint,1003,opt,name=state,proto3,enum=ves.io.schema.virtual_host.VirtualHostState" json:"state,omitempty"`
	// Auto Cert State
	//
	// x-displayName: "Auto Cert State"
	// State of auto certificate generation.
	AutoCertState virtual_host.CertificationState `protobuf:"varint,1004,opt,name=auto_cert_state,json=autoCertState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"auto_cert_state,omitempty"` // Deprecated: Do not use.
	// Auto Cert Information
	//
	// x-displayName: "Auto Cert Information"
	// Auto certificate related information
	AutoCertInfo *virtual_host.AutoCertInfoType `protobuf:"bytes,1010,opt,name=auto_cert_info,json=autoCertInfo,proto3" json:"auto_cert_info,omitempty"`
	// Service Domains
	//
	// x-displayName: "Service Domains"
	// CNAME provided from service per domain
	ServiceDomains []*virtual_host.ServiceDomain `protobuf:"bytes,1011,rep,name=service_domains,json=serviceDomains,proto3" json:"service_domains,omitempty"`
	// Cert State
	//
	// x-displayName: "Cert State"
	// State of Custom certificate or Auto certificate generation.
	CertState virtual_host.CertificationState `protobuf:"varint,1012,opt,name=cert_state,json=certState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"cert_state,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{23}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_LoadbalancerType interface {
	isGlobalSpecType_LoadbalancerType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_Http struct {
	Http *http_loadbalancer.ProxyTypeHttp `protobuf:"bytes,3,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type GlobalSpecType_HttpsAutoCert struct {
	HttpsAutoCert *CDNHTTPSAutoCertsType `protobuf:"bytes,18,opt,name=https_auto_cert,json=httpsAutoCert,proto3,oneof" json:"https_auto_cert,omitempty"`
}
type GlobalSpecType_Https struct {
	Https *CDNHTTPSCustomCertsType `protobuf:"bytes,19,opt,name=https,proto3,oneof" json:"https,omitempty"`
}

func (*GlobalSpecType_Http) isGlobalSpecType_LoadbalancerType()          {}
func (*GlobalSpecType_HttpsAutoCert) isGlobalSpecType_LoadbalancerType() {}
func (*GlobalSpecType_Https) isGlobalSpecType_LoadbalancerType()         {}

func (m *GlobalSpecType) GetLoadbalancerType() isGlobalSpecType_LoadbalancerType {
	if m != nil {
		return m.LoadbalancerType
	}
	return nil
}

func (m *GlobalSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *GlobalSpecType) GetHttp() *http_loadbalancer.ProxyTypeHttp {
	if x, ok := m.GetLoadbalancerType().(*GlobalSpecType_Http); ok {
		return x.Http
	}
	return nil
}

func (m *GlobalSpecType) GetHttpsAutoCert() *CDNHTTPSAutoCertsType {
	if x, ok := m.GetLoadbalancerType().(*GlobalSpecType_HttpsAutoCert); ok {
		return x.HttpsAutoCert
	}
	return nil
}

func (m *GlobalSpecType) GetHttps() *CDNHTTPSCustomCertsType {
	if x, ok := m.GetLoadbalancerType().(*GlobalSpecType_Https); ok {
		return x.Https
	}
	return nil
}

func (m *GlobalSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *GlobalSpecType) GetMoreOption() *AdvancedOptionsType {
	if m != nil {
		return m.MoreOption
	}
	return nil
}

func (m *GlobalSpecType) GetOriginPool() *CdnOriginPoolType {
	if m != nil {
		return m.OriginPool
	}
	return nil
}

func (m *GlobalSpecType) GetViewInternal() *views.ObjectRefType {
	if m != nil {
		return m.ViewInternal
	}
	return nil
}

func (m *GlobalSpecType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *GlobalSpecType) GetDnsInfo() []*virtual_host_dns_info.DnsInfo {
	if m != nil {
		return m.DnsInfo
	}
	return nil
}

func (m *GlobalSpecType) GetState() virtual_host.VirtualHostState {
	if m != nil {
		return m.State
	}
	return virtual_host.VIRTUAL_HOST_READY
}

// Deprecated: Do not use.
func (m *GlobalSpecType) GetAutoCertState() virtual_host.CertificationState {
	if m != nil {
		return m.AutoCertState
	}
	return virtual_host.AutoCertDisabled
}

func (m *GlobalSpecType) GetAutoCertInfo() *virtual_host.AutoCertInfoType {
	if m != nil {
		return m.AutoCertInfo
	}
	return nil
}

func (m *GlobalSpecType) GetServiceDomains() []*virtual_host.ServiceDomain {
	if m != nil {
		return m.ServiceDomains
	}
	return nil
}

func (m *GlobalSpecType) GetCertState() virtual_host.CertificationState {
	if m != nil {
		return m.CertState
	}
	return virtual_host.AutoCertDisabled
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_Http)(nil),
		(*GlobalSpecType_HttpsAutoCert)(nil),
		(*GlobalSpecType_Https)(nil),
	}
}

// IpFilteringOptions
//
// x-displayName: "IP Filtering Options"
// Options to filter based on IP prefix
type IpFilteringOptions struct {
	// ip_filtering_type
	//
	// x-displayName: "Ip Filtering Type"
	// Type of IP filtering (Allow vs Block)
	//
	// Types that are valid to be assigned to IpFilteringType:
	//	*IpFilteringOptions_AllowList
	//	*IpFilteringOptions_BlockList
	IpFilteringType isIpFilteringOptions_IpFilteringType `protobuf_oneof:"ip_filtering_type"`
}

func (m *IpFilteringOptions) Reset()      { *m = IpFilteringOptions{} }
func (*IpFilteringOptions) ProtoMessage() {}
func (*IpFilteringOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{24}
}
func (m *IpFilteringOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpFilteringOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpFilteringOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpFilteringOptions.Merge(m, src)
}
func (m *IpFilteringOptions) XXX_Size() int {
	return m.Size()
}
func (m *IpFilteringOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_IpFilteringOptions.DiscardUnknown(m)
}

var xxx_messageInfo_IpFilteringOptions proto.InternalMessageInfo

type isIpFilteringOptions_IpFilteringType interface {
	isIpFilteringOptions_IpFilteringType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IpFilteringOptions_AllowList struct {
	AllowList *policy.PrefixMatchList `protobuf:"bytes,2,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type IpFilteringOptions_BlockList struct {
	BlockList *policy.PrefixMatchList `protobuf:"bytes,3,opt,name=block_list,json=blockList,proto3,oneof" json:"block_list,omitempty"`
}

func (*IpFilteringOptions_AllowList) isIpFilteringOptions_IpFilteringType() {}
func (*IpFilteringOptions_BlockList) isIpFilteringOptions_IpFilteringType() {}

func (m *IpFilteringOptions) GetIpFilteringType() isIpFilteringOptions_IpFilteringType {
	if m != nil {
		return m.IpFilteringType
	}
	return nil
}

func (m *IpFilteringOptions) GetAllowList() *policy.PrefixMatchList {
	if x, ok := m.GetIpFilteringType().(*IpFilteringOptions_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *IpFilteringOptions) GetBlockList() *policy.PrefixMatchList {
	if x, ok := m.GetIpFilteringType().(*IpFilteringOptions_BlockList); ok {
		return x.BlockList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IpFilteringOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IpFilteringOptions_AllowList)(nil),
		(*IpFilteringOptions_BlockList)(nil),
	}
}

// GeoFilteringOptions
//
// x-displayName: "Geo Filtering Options"
// Options to filter based on Geo prefix
type GeoFilteringOptions struct {
	// geo_filtering_type
	//
	// x-displayName: "Geo Filtering Type"
	// Type of Geo filtering (Allow vs Block)
	//
	// Types that are valid to be assigned to GeoFilteringType:
	//	*GeoFilteringOptions_AllowList
	//	*GeoFilteringOptions_BlockList
	GeoFilteringType isGeoFilteringOptions_GeoFilteringType `protobuf_oneof:"geo_filtering_type"`
}

func (m *GeoFilteringOptions) Reset()      { *m = GeoFilteringOptions{} }
func (*GeoFilteringOptions) ProtoMessage() {}
func (*GeoFilteringOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{25}
}
func (m *GeoFilteringOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoFilteringOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GeoFilteringOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoFilteringOptions.Merge(m, src)
}
func (m *GeoFilteringOptions) XXX_Size() int {
	return m.Size()
}
func (m *GeoFilteringOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoFilteringOptions.DiscardUnknown(m)
}

var xxx_messageInfo_GeoFilteringOptions proto.InternalMessageInfo

type isGeoFilteringOptions_GeoFilteringType interface {
	isGeoFilteringOptions_GeoFilteringType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GeoFilteringOptions_AllowList struct {
	AllowList *policy.CountryCodeList `protobuf:"bytes,2,opt,name=allow_list,json=allowList,proto3,oneof" json:"allow_list,omitempty"`
}
type GeoFilteringOptions_BlockList struct {
	BlockList *policy.CountryCodeList `protobuf:"bytes,3,opt,name=block_list,json=blockList,proto3,oneof" json:"block_list,omitempty"`
}

func (*GeoFilteringOptions_AllowList) isGeoFilteringOptions_GeoFilteringType() {}
func (*GeoFilteringOptions_BlockList) isGeoFilteringOptions_GeoFilteringType() {}

func (m *GeoFilteringOptions) GetGeoFilteringType() isGeoFilteringOptions_GeoFilteringType {
	if m != nil {
		return m.GeoFilteringType
	}
	return nil
}

func (m *GeoFilteringOptions) GetAllowList() *policy.CountryCodeList {
	if x, ok := m.GetGeoFilteringType().(*GeoFilteringOptions_AllowList); ok {
		return x.AllowList
	}
	return nil
}

func (m *GeoFilteringOptions) GetBlockList() *policy.CountryCodeList {
	if x, ok := m.GetGeoFilteringType().(*GeoFilteringOptions_BlockList); ok {
		return x.BlockList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GeoFilteringOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GeoFilteringOptions_AllowList)(nil),
		(*GeoFilteringOptions_BlockList)(nil),
	}
}

// LogHeaderOptions
//
// x-displayName: "Headers to Log"
// List of headers to Log
type LogHeaderOptions struct {
	// List of Headers
	//
	// x-displayName: "Headers"
	// x-example: "x-custom-length"
	// List of headers
	HeaderList []string `protobuf:"bytes,1,rep,name=header_list,json=headerList,proto3" json:"header_list,omitempty"`
}

func (m *LogHeaderOptions) Reset()      { *m = LogHeaderOptions{} }
func (*LogHeaderOptions) ProtoMessage() {}
func (*LogHeaderOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{26}
}
func (m *LogHeaderOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogHeaderOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogHeaderOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogHeaderOptions.Merge(m, src)
}
func (m *LogHeaderOptions) XXX_Size() int {
	return m.Size()
}
func (m *LogHeaderOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_LogHeaderOptions.DiscardUnknown(m)
}

var xxx_messageInfo_LogHeaderOptions proto.InternalMessageInfo

func (m *LogHeaderOptions) GetHeaderList() []string {
	if m != nil {
		return m.HeaderList
	}
	return nil
}

// CDNCustomAuthentication
//
// x-displayName: "Custom Authentication"
// Custom  Authentication
type CDNCustomAuthentication struct {
	// custom_auth_config
	//
	// x-displayName: "Custom Auth Config"
	// x-example: ""
	// This is custom authentication configuration parameters. Please reach out to the support for custom authentication details.
	CustomAuthConfig string `protobuf:"bytes,1,opt,name=custom_auth_config,json=customAuthConfig,proto3" json:"custom_auth_config,omitempty"`
}

func (m *CDNCustomAuthentication) Reset()      { *m = CDNCustomAuthentication{} }
func (*CDNCustomAuthentication) ProtoMessage() {}
func (*CDNCustomAuthentication) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{27}
}
func (m *CDNCustomAuthentication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNCustomAuthentication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNCustomAuthentication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNCustomAuthentication.Merge(m, src)
}
func (m *CDNCustomAuthentication) XXX_Size() int {
	return m.Size()
}
func (m *CDNCustomAuthentication) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNCustomAuthentication.DiscardUnknown(m)
}

var xxx_messageInfo_CDNCustomAuthentication proto.InternalMessageInfo

func (m *CDNCustomAuthentication) GetCustomAuthConfig() string {
	if m != nil {
		return m.CustomAuthConfig
	}
	return ""
}

// AuthenticationOptions
//
// x-displayName: "Authentication Options"
// Options to authenticate incoming client requests
type AuthenticationOptions struct {
	// Authentication Options
	//
	// x-displayName: "Authentication Type"
	// Type of Authentication
	//
	// Types that are valid to be assigned to AuthOptions:
	//	*AuthenticationOptions_DisableAuth
	//	*AuthenticationOptions_Jwt
	//	*AuthenticationOptions_Custom
	AuthOptions isAuthenticationOptions_AuthOptions `protobuf_oneof:"auth_options"`
}

func (m *AuthenticationOptions) Reset()      { *m = AuthenticationOptions{} }
func (*AuthenticationOptions) ProtoMessage() {}
func (*AuthenticationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{28}
}
func (m *AuthenticationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AuthenticationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticationOptions.Merge(m, src)
}
func (m *AuthenticationOptions) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticationOptions proto.InternalMessageInfo

type isAuthenticationOptions_AuthOptions interface {
	isAuthenticationOptions_AuthOptions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuthenticationOptions_DisableAuth struct {
	DisableAuth *schema.Empty `protobuf:"bytes,2,opt,name=disable_auth,json=disableAuth,proto3,oneof" json:"disable_auth,omitempty"`
}
type AuthenticationOptions_Jwt struct {
	Jwt *policy.JwtTokenAuthOptions `protobuf:"bytes,3,opt,name=jwt,proto3,oneof" json:"jwt,omitempty"`
}
type AuthenticationOptions_Custom struct {
	Custom *CDNCustomAuthentication `protobuf:"bytes,4,opt,name=custom,proto3,oneof" json:"custom,omitempty"`
}

func (*AuthenticationOptions_DisableAuth) isAuthenticationOptions_AuthOptions() {}
func (*AuthenticationOptions_Jwt) isAuthenticationOptions_AuthOptions()         {}
func (*AuthenticationOptions_Custom) isAuthenticationOptions_AuthOptions()      {}

func (m *AuthenticationOptions) GetAuthOptions() isAuthenticationOptions_AuthOptions {
	if m != nil {
		return m.AuthOptions
	}
	return nil
}

func (m *AuthenticationOptions) GetDisableAuth() *schema.Empty {
	if x, ok := m.GetAuthOptions().(*AuthenticationOptions_DisableAuth); ok {
		return x.DisableAuth
	}
	return nil
}

func (m *AuthenticationOptions) GetJwt() *policy.JwtTokenAuthOptions {
	if x, ok := m.GetAuthOptions().(*AuthenticationOptions_Jwt); ok {
		return x.Jwt
	}
	return nil
}

func (m *AuthenticationOptions) GetCustom() *CDNCustomAuthentication {
	if x, ok := m.GetAuthOptions().(*AuthenticationOptions_Custom); ok {
		return x.Custom
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AuthenticationOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AuthenticationOptions_DisableAuth)(nil),
		(*AuthenticationOptions_Jwt)(nil),
		(*AuthenticationOptions_Custom)(nil),
	}
}

// CDNOriginServerType
//
// x-displayName: "Origin Server"
// Various options to specify origin server
type CDNOriginServerType struct {
	// Origin Server Type
	//
	// x-displayName: "Select Type of Origin Server"
	// x-required
	// Various options to specify origin server
	//
	// Types that are valid to be assigned to Choice:
	//	*CDNOriginServerType_PublicIp
	//	*CDNOriginServerType_PublicName
	Choice isCDNOriginServerType_Choice `protobuf_oneof:"choice"`
	// Port
	//
	// x-displayName: "Origin Server Port"
	// x-example: "80"
	// Port the workload can be reached on
	Port uint32 `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *CDNOriginServerType) Reset()      { *m = CDNOriginServerType{} }
func (*CDNOriginServerType) ProtoMessage() {}
func (*CDNOriginServerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{29}
}
func (m *CDNOriginServerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNOriginServerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNOriginServerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNOriginServerType.Merge(m, src)
}
func (m *CDNOriginServerType) XXX_Size() int {
	return m.Size()
}
func (m *CDNOriginServerType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNOriginServerType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNOriginServerType proto.InternalMessageInfo

type isCDNOriginServerType_Choice interface {
	isCDNOriginServerType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CDNOriginServerType_PublicIp struct {
	PublicIp *origin_pool.OriginServerPublicIP `protobuf:"bytes,2,opt,name=public_ip,json=publicIp,proto3,oneof" json:"public_ip,omitempty"`
}
type CDNOriginServerType_PublicName struct {
	PublicName *origin_pool.OriginServerPublicName `protobuf:"bytes,3,opt,name=public_name,json=publicName,proto3,oneof" json:"public_name,omitempty"`
}

func (*CDNOriginServerType_PublicIp) isCDNOriginServerType_Choice()   {}
func (*CDNOriginServerType_PublicName) isCDNOriginServerType_Choice() {}

func (m *CDNOriginServerType) GetChoice() isCDNOriginServerType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *CDNOriginServerType) GetPublicIp() *origin_pool.OriginServerPublicIP {
	if x, ok := m.GetChoice().(*CDNOriginServerType_PublicIp); ok {
		return x.PublicIp
	}
	return nil
}

func (m *CDNOriginServerType) GetPublicName() *origin_pool.OriginServerPublicName {
	if x, ok := m.GetChoice().(*CDNOriginServerType_PublicName); ok {
		return x.PublicName
	}
	return nil
}

func (m *CDNOriginServerType) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CDNOriginServerType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CDNOriginServerType_PublicIp)(nil),
		(*CDNOriginServerType_PublicName)(nil),
	}
}

// CdnOriginPoolType
//
// x-displayName: "CDN Origin Pool"
// Origin Pool for the CDN distribution
type CdnOriginPoolType struct {
	// OriginServerPublicName
	//
	// x-required
	// x-displayName: "Origin Host Header"
	// The DNS name to be used as the host header for the request to the origin server
	PublicName *origin_pool.OriginServerPublicName `protobuf:"bytes,1,opt,name=public_name,json=publicName,proto3" json:"public_name,omitempty"`
	// Enable TLS
	//
	// x-displayName: "Enable TLS for Origin Servers"
	// x-required
	// Choice to enable TLS for origin servers
	//
	// Types that are valid to be assigned to TlsChoice:
	//	*CdnOriginPoolType_NoTls
	//	*CdnOriginPoolType_UseTls
	TlsChoice isCdnOriginPoolType_TlsChoice `protobuf_oneof:"tls_choice"`
	// List of Origin Servers
	//
	// x-displayName: "List Of Origin Servers"
	// x-required
	// List of original servers
	OriginServers []*CDNOriginServerType `protobuf:"bytes,5,rep,name=origin_servers,json=originServers,proto3" json:"origin_servers,omitempty"`
	// Follow Origin Redirect
	//
	// x-displayName: "Follow Origin Redirect"
	// x-example: "true"
	// x-example: true
	// Instructs the CDN to follow redirects from the origin server(s)
	FollowOriginRedirect bool `protobuf:"varint,6,opt,name=follow_origin_redirect,json=followOriginRedirect,proto3" json:"follow_origin_redirect,omitempty"`
	// Origin Request Timeout
	//
	// x-displayName: "Origin Request Timeout Duration"
	// x-example: "100s"
	// Configures the time after which a request to the origin will time out waiting for a response
	OriginRequestTimeout string `protobuf:"bytes,7,opt,name=origin_request_timeout,json=originRequestTimeout,proto3" json:"origin_request_timeout,omitempty"`
	// Advanced Configuration
	//
	// x-displayName: "Advanced Configuration"
	MoreOriginOptions *OriginAdvancedConfiguration `protobuf:"bytes,8,opt,name=more_origin_options,json=moreOriginOptions,proto3" json:"more_origin_options,omitempty"`
}

func (m *CdnOriginPoolType) Reset()      { *m = CdnOriginPoolType{} }
func (*CdnOriginPoolType) ProtoMessage() {}
func (*CdnOriginPoolType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{30}
}
func (m *CdnOriginPoolType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CdnOriginPoolType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CdnOriginPoolType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CdnOriginPoolType.Merge(m, src)
}
func (m *CdnOriginPoolType) XXX_Size() int {
	return m.Size()
}
func (m *CdnOriginPoolType) XXX_DiscardUnknown() {
	xxx_messageInfo_CdnOriginPoolType.DiscardUnknown(m)
}

var xxx_messageInfo_CdnOriginPoolType proto.InternalMessageInfo

type isCdnOriginPoolType_TlsChoice interface {
	isCdnOriginPoolType_TlsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CdnOriginPoolType_NoTls struct {
	NoTls *schema.Empty `protobuf:"bytes,3,opt,name=no_tls,json=noTls,proto3,oneof" json:"no_tls,omitempty"`
}
type CdnOriginPoolType_UseTls struct {
	UseTls *origin_pool.UpstreamTlsParameters `protobuf:"bytes,4,opt,name=use_tls,json=useTls,proto3,oneof" json:"use_tls,omitempty"`
}

func (*CdnOriginPoolType_NoTls) isCdnOriginPoolType_TlsChoice()  {}
func (*CdnOriginPoolType_UseTls) isCdnOriginPoolType_TlsChoice() {}

func (m *CdnOriginPoolType) GetTlsChoice() isCdnOriginPoolType_TlsChoice {
	if m != nil {
		return m.TlsChoice
	}
	return nil
}

func (m *CdnOriginPoolType) GetPublicName() *origin_pool.OriginServerPublicName {
	if m != nil {
		return m.PublicName
	}
	return nil
}

func (m *CdnOriginPoolType) GetNoTls() *schema.Empty {
	if x, ok := m.GetTlsChoice().(*CdnOriginPoolType_NoTls); ok {
		return x.NoTls
	}
	return nil
}

func (m *CdnOriginPoolType) GetUseTls() *origin_pool.UpstreamTlsParameters {
	if x, ok := m.GetTlsChoice().(*CdnOriginPoolType_UseTls); ok {
		return x.UseTls
	}
	return nil
}

func (m *CdnOriginPoolType) GetOriginServers() []*CDNOriginServerType {
	if m != nil {
		return m.OriginServers
	}
	return nil
}

func (m *CdnOriginPoolType) GetFollowOriginRedirect() bool {
	if m != nil {
		return m.FollowOriginRedirect
	}
	return false
}

func (m *CdnOriginPoolType) GetOriginRequestTimeout() string {
	if m != nil {
		return m.OriginRequestTimeout
	}
	return ""
}

func (m *CdnOriginPoolType) GetMoreOriginOptions() *OriginAdvancedConfiguration {
	if m != nil {
		return m.MoreOriginOptions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CdnOriginPoolType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CdnOriginPoolType_NoTls)(nil),
		(*CdnOriginPoolType_UseTls)(nil),
	}
}

// Origin Byte Range Request Config
//
// x-displayName: "Origin Byte Range Request Config"
type OriginAdvancedConfiguration struct {
	// Disable Origin Byte Range Requests
	//
	// x-displayName: "Disable Origin Byte Range Requests"
	// x-example: "true/false"
	// Choice to enable/disable origin byte range requrests towards origin
	DisableByteRangeRequest bool `protobuf:"varint,1,opt,name=disable_byte_range_request,json=disableByteRangeRequest,proto3" json:"disable_byte_range_request,omitempty"`
	// Enable websocket proxy to the origin
	//
	// x-displayName: "Enable websocket proxy to the origin"
	// Option to enable proxying of websocket connections to the origin server
	WebsocketProxy bool `protobuf:"varint,2,opt,name=websocket_proxy,json=websocketProxy,proto3" json:"websocket_proxy,omitempty"`
}

func (m *OriginAdvancedConfiguration) Reset()      { *m = OriginAdvancedConfiguration{} }
func (*OriginAdvancedConfiguration) ProtoMessage() {}
func (*OriginAdvancedConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{31}
}
func (m *OriginAdvancedConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OriginAdvancedConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OriginAdvancedConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OriginAdvancedConfiguration.Merge(m, src)
}
func (m *OriginAdvancedConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *OriginAdvancedConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_OriginAdvancedConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_OriginAdvancedConfiguration proto.InternalMessageInfo

func (m *OriginAdvancedConfiguration) GetDisableByteRangeRequest() bool {
	if m != nil {
		return m.DisableByteRangeRequest
	}
	return false
}

func (m *OriginAdvancedConfiguration) GetWebsocketProxy() bool {
	if m != nil {
		return m.WebsocketProxy
	}
	return false
}

// CreateSpecType
//
// x-displayName: "Create CDN Loadbalancer"
// Shape of the CDN loadbalancer specification
type CreateSpecType struct {
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Types that are valid to be assigned to LoadbalancerType:
	//	*CreateSpecType_Http
	//	*CreateSpecType_HttpsAutoCert
	//	*CreateSpecType_Https
	LoadbalancerType isCreateSpecType_LoadbalancerType `protobuf_oneof:"loadbalancer_type"`
	AddLocation      bool                              `protobuf:"varint,11,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	MoreOption       *AdvancedOptionsType              `protobuf:"bytes,13,opt,name=more_option,json=moreOption,proto3" json:"more_option,omitempty"`
	// Origin Pool
	//
	// x-displayName: "CDN Origin Pool"
	// x-required
	OriginPool *CdnOriginPoolType `protobuf:"bytes,16,opt,name=origin_pool,json=originPool,proto3" json:"origin_pool,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{32}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_LoadbalancerType interface {
	isCreateSpecType_LoadbalancerType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_Http struct {
	Http *http_loadbalancer.ProxyTypeHttp `protobuf:"bytes,3,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type CreateSpecType_HttpsAutoCert struct {
	HttpsAutoCert *CDNHTTPSAutoCertsType `protobuf:"bytes,18,opt,name=https_auto_cert,json=httpsAutoCert,proto3,oneof" json:"https_auto_cert,omitempty"`
}
type CreateSpecType_Https struct {
	Https *CDNHTTPSCustomCertsType `protobuf:"bytes,19,opt,name=https,proto3,oneof" json:"https,omitempty"`
}

func (*CreateSpecType_Http) isCreateSpecType_LoadbalancerType()          {}
func (*CreateSpecType_HttpsAutoCert) isCreateSpecType_LoadbalancerType() {}
func (*CreateSpecType_Https) isCreateSpecType_LoadbalancerType()         {}

func (m *CreateSpecType) GetLoadbalancerType() isCreateSpecType_LoadbalancerType {
	if m != nil {
		return m.LoadbalancerType
	}
	return nil
}

func (m *CreateSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *CreateSpecType) GetHttp() *http_loadbalancer.ProxyTypeHttp {
	if x, ok := m.GetLoadbalancerType().(*CreateSpecType_Http); ok {
		return x.Http
	}
	return nil
}

func (m *CreateSpecType) GetHttpsAutoCert() *CDNHTTPSAutoCertsType {
	if x, ok := m.GetLoadbalancerType().(*CreateSpecType_HttpsAutoCert); ok {
		return x.HttpsAutoCert
	}
	return nil
}

func (m *CreateSpecType) GetHttps() *CDNHTTPSCustomCertsType {
	if x, ok := m.GetLoadbalancerType().(*CreateSpecType_Https); ok {
		return x.Https
	}
	return nil
}

func (m *CreateSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *CreateSpecType) GetMoreOption() *AdvancedOptionsType {
	if m != nil {
		return m.MoreOption
	}
	return nil
}

func (m *CreateSpecType) GetOriginPool() *CdnOriginPoolType {
	if m != nil {
		return m.OriginPool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_Http)(nil),
		(*CreateSpecType_HttpsAutoCert)(nil),
		(*CreateSpecType_Https)(nil),
	}
}

// ReplaceSpecType
//
// x-displayName: "Replace CDN Loadbalancer"
// Shape of the CDN loadbalancer specification
type ReplaceSpecType struct {
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Types that are valid to be assigned to LoadbalancerType:
	//	*ReplaceSpecType_Http
	//	*ReplaceSpecType_HttpsAutoCert
	//	*ReplaceSpecType_Https
	LoadbalancerType isReplaceSpecType_LoadbalancerType `protobuf_oneof:"loadbalancer_type"`
	AddLocation      bool                               `protobuf:"varint,11,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	MoreOption       *AdvancedOptionsType               `protobuf:"bytes,13,opt,name=more_option,json=moreOption,proto3" json:"more_option,omitempty"`
	// Origin Pool
	//
	// x-displayName: "CDN Origin Pool"
	// x-required
	OriginPool *CdnOriginPoolType `protobuf:"bytes,16,opt,name=origin_pool,json=originPool,proto3" json:"origin_pool,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{33}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_LoadbalancerType interface {
	isReplaceSpecType_LoadbalancerType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_Http struct {
	Http *http_loadbalancer.ProxyTypeHttp `protobuf:"bytes,3,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type ReplaceSpecType_HttpsAutoCert struct {
	HttpsAutoCert *CDNHTTPSAutoCertsType `protobuf:"bytes,18,opt,name=https_auto_cert,json=httpsAutoCert,proto3,oneof" json:"https_auto_cert,omitempty"`
}
type ReplaceSpecType_Https struct {
	Https *CDNHTTPSCustomCertsType `protobuf:"bytes,19,opt,name=https,proto3,oneof" json:"https,omitempty"`
}

func (*ReplaceSpecType_Http) isReplaceSpecType_LoadbalancerType()          {}
func (*ReplaceSpecType_HttpsAutoCert) isReplaceSpecType_LoadbalancerType() {}
func (*ReplaceSpecType_Https) isReplaceSpecType_LoadbalancerType()         {}

func (m *ReplaceSpecType) GetLoadbalancerType() isReplaceSpecType_LoadbalancerType {
	if m != nil {
		return m.LoadbalancerType
	}
	return nil
}

func (m *ReplaceSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *ReplaceSpecType) GetHttp() *http_loadbalancer.ProxyTypeHttp {
	if x, ok := m.GetLoadbalancerType().(*ReplaceSpecType_Http); ok {
		return x.Http
	}
	return nil
}

func (m *ReplaceSpecType) GetHttpsAutoCert() *CDNHTTPSAutoCertsType {
	if x, ok := m.GetLoadbalancerType().(*ReplaceSpecType_HttpsAutoCert); ok {
		return x.HttpsAutoCert
	}
	return nil
}

func (m *ReplaceSpecType) GetHttps() *CDNHTTPSCustomCertsType {
	if x, ok := m.GetLoadbalancerType().(*ReplaceSpecType_Https); ok {
		return x.Https
	}
	return nil
}

func (m *ReplaceSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *ReplaceSpecType) GetMoreOption() *AdvancedOptionsType {
	if m != nil {
		return m.MoreOption
	}
	return nil
}

func (m *ReplaceSpecType) GetOriginPool() *CdnOriginPoolType {
	if m != nil {
		return m.OriginPool
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_Http)(nil),
		(*ReplaceSpecType_HttpsAutoCert)(nil),
		(*ReplaceSpecType_Https)(nil),
	}
}

// GetSpecType
//
// x-displayName: "Get CDN Loadbalancer"
// Shape of the CDN loadbalancer specification
type GetSpecType struct {
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
	// Types that are valid to be assigned to LoadbalancerType:
	//	*GetSpecType_Http
	//	*GetSpecType_HttpsAutoCert
	//	*GetSpecType_Https
	LoadbalancerType isGetSpecType_LoadbalancerType   `protobuf_oneof:"loadbalancer_type"`
	AddLocation      bool                             `protobuf:"varint,11,opt,name=add_location,json=addLocation,proto3" json:"add_location,omitempty"`
	MoreOption       *AdvancedOptionsType             `protobuf:"bytes,13,opt,name=more_option,json=moreOption,proto3" json:"more_option,omitempty"`
	OriginPool       *CdnOriginPoolType               `protobuf:"bytes,16,opt,name=origin_pool,json=originPool,proto3" json:"origin_pool,omitempty"`
	HostName         string                           `protobuf:"bytes,1001,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	DnsInfo          []*virtual_host_dns_info.DnsInfo `protobuf:"bytes,1002,rep,name=dns_info,json=dnsInfo,proto3" json:"dns_info,omitempty"`
	State            virtual_host.VirtualHostState    `protobuf:"varint,1003,opt,name=state,proto3,enum=ves.io.schema.virtual_host.VirtualHostState" json:"state,omitempty"`
	AutoCertInfo     *virtual_host.AutoCertInfoType   `protobuf:"bytes,1010,opt,name=auto_cert_info,json=autoCertInfo,proto3" json:"auto_cert_info,omitempty"`
	ServiceDomains   []*virtual_host.ServiceDomain    `protobuf:"bytes,1011,rep,name=service_domains,json=serviceDomains,proto3" json:"service_domains,omitempty"`
	CertState        virtual_host.CertificationState  `protobuf:"varint,1012,opt,name=cert_state,json=certState,proto3,enum=ves.io.schema.virtual_host.CertificationState" json:"cert_state,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{34}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_LoadbalancerType interface {
	isGetSpecType_LoadbalancerType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_Http struct {
	Http *http_loadbalancer.ProxyTypeHttp `protobuf:"bytes,3,opt,name=http,proto3,oneof" json:"http,omitempty"`
}
type GetSpecType_HttpsAutoCert struct {
	HttpsAutoCert *CDNHTTPSAutoCertsType `protobuf:"bytes,18,opt,name=https_auto_cert,json=httpsAutoCert,proto3,oneof" json:"https_auto_cert,omitempty"`
}
type GetSpecType_Https struct {
	Https *CDNHTTPSCustomCertsType `protobuf:"bytes,19,opt,name=https,proto3,oneof" json:"https,omitempty"`
}

func (*GetSpecType_Http) isGetSpecType_LoadbalancerType()          {}
func (*GetSpecType_HttpsAutoCert) isGetSpecType_LoadbalancerType() {}
func (*GetSpecType_Https) isGetSpecType_LoadbalancerType()         {}

func (m *GetSpecType) GetLoadbalancerType() isGetSpecType_LoadbalancerType {
	if m != nil {
		return m.LoadbalancerType
	}
	return nil
}

func (m *GetSpecType) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *GetSpecType) GetHttp() *http_loadbalancer.ProxyTypeHttp {
	if x, ok := m.GetLoadbalancerType().(*GetSpecType_Http); ok {
		return x.Http
	}
	return nil
}

func (m *GetSpecType) GetHttpsAutoCert() *CDNHTTPSAutoCertsType {
	if x, ok := m.GetLoadbalancerType().(*GetSpecType_HttpsAutoCert); ok {
		return x.HttpsAutoCert
	}
	return nil
}

func (m *GetSpecType) GetHttps() *CDNHTTPSCustomCertsType {
	if x, ok := m.GetLoadbalancerType().(*GetSpecType_Https); ok {
		return x.Https
	}
	return nil
}

func (m *GetSpecType) GetAddLocation() bool {
	if m != nil {
		return m.AddLocation
	}
	return false
}

func (m *GetSpecType) GetMoreOption() *AdvancedOptionsType {
	if m != nil {
		return m.MoreOption
	}
	return nil
}

func (m *GetSpecType) GetOriginPool() *CdnOriginPoolType {
	if m != nil {
		return m.OriginPool
	}
	return nil
}

func (m *GetSpecType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *GetSpecType) GetDnsInfo() []*virtual_host_dns_info.DnsInfo {
	if m != nil {
		return m.DnsInfo
	}
	return nil
}

func (m *GetSpecType) GetState() virtual_host.VirtualHostState {
	if m != nil {
		return m.State
	}
	return virtual_host.VIRTUAL_HOST_READY
}

func (m *GetSpecType) GetAutoCertInfo() *virtual_host.AutoCertInfoType {
	if m != nil {
		return m.AutoCertInfo
	}
	return nil
}

func (m *GetSpecType) GetServiceDomains() []*virtual_host.ServiceDomain {
	if m != nil {
		return m.ServiceDomains
	}
	return nil
}

func (m *GetSpecType) GetCertState() virtual_host.CertificationState {
	if m != nil {
		return m.CertState
	}
	return virtual_host.AutoCertDisabled
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_Http)(nil),
		(*GetSpecType_HttpsAutoCert)(nil),
		(*GetSpecType_Https)(nil),
	}
}

// Metrics Filter options
//
// x-displayName: "Metrics Filter"
// CDN Metrics filter options
type LilacCDNMetricsFilter struct {
	// Metrics Filter Tag options
	//
	// x-displayName: "Filter Tags"
	// x-required
	// Tags on which CDN metrics can be filtered by
	Tag LilacCDNMetricsTag `protobuf:"varint,1,opt,name=tag,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag" json:"tag,omitempty"`
	// Filter values
	//
	// x-displayName: "Filter values"
	// x-example: "[IN, US]"
	// x-required
	// Filter values
	Values []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	// Metrics Operator Types
	//
	// x-displayName: "Metrics Operator Types"
	// x-required
	// Operators possible in filtering
	Operator LilacCDNMetricsOperatorType `protobuf:"varint,3,opt,name=operator,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsOperatorType" json:"operator,omitempty"`
}

func (m *LilacCDNMetricsFilter) Reset()      { *m = LilacCDNMetricsFilter{} }
func (*LilacCDNMetricsFilter) ProtoMessage() {}
func (*LilacCDNMetricsFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{35}
}
func (m *LilacCDNMetricsFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsFilter.Merge(m, src)
}
func (m *LilacCDNMetricsFilter) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsFilter.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsFilter proto.InternalMessageInfo

func (m *LilacCDNMetricsFilter) GetTag() LilacCDNMetricsTag {
	if m != nil {
		return m.Tag
	}
	return CDN_DISTRIBUTION_NAME
}

func (m *LilacCDNMetricsFilter) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *LilacCDNMetricsFilter) GetOperator() LilacCDNMetricsOperatorType {
	if m != nil {
		return m.Operator
	}
	return OPERATOR_TYPE_IN
}

// Metrics group by options
//
// x-displayName: "Metrics Group By"
// CDN Metrics group by options
type LilacCDNMetricsResponseGroupBy struct {
	// Metric Group-By Tags
	//
	// x-displayName: "Group By Tags"
	// Tag on which CDN metric was requested to be grouped in request
	Name LilacCDNMetricsTag `protobuf:"varint,1,opt,name=name,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag" json:"name,omitempty"`
	// Group-By tag Value
	//
	// x-displayName: "Group By Tag Value"
	// Group-By tag Value
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *LilacCDNMetricsResponseGroupBy) Reset()      { *m = LilacCDNMetricsResponseGroupBy{} }
func (*LilacCDNMetricsResponseGroupBy) ProtoMessage() {}
func (*LilacCDNMetricsResponseGroupBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{36}
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsResponseGroupBy.Merge(m, src)
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsResponseGroupBy) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsResponseGroupBy.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsResponseGroupBy proto.InternalMessageInfo

func (m *LilacCDNMetricsResponseGroupBy) GetName() LilacCDNMetricsTag {
	if m != nil {
		return m.Name
	}
	return CDN_DISTRIBUTION_NAME
}

func (m *LilacCDNMetricsResponseGroupBy) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Metrics Response Value
//
// x-displayName: "Metrics Response Value"
// CDN Metrics response value
type LilacCDNMetricsResponseValue struct {
	// Metric Timestamp
	//
	// x-displayName: "Metric Timestamp"
	// Metric Timestamp in unix_timestamp
	Timestamp string `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Metric Value
	//
	// x-displayName: "Metric Value"
	// Metric Value
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *LilacCDNMetricsResponseValue) Reset()      { *m = LilacCDNMetricsResponseValue{} }
func (*LilacCDNMetricsResponseValue) ProtoMessage() {}
func (*LilacCDNMetricsResponseValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{37}
}
func (m *LilacCDNMetricsResponseValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsResponseValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsResponseValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsResponseValue.Merge(m, src)
}
func (m *LilacCDNMetricsResponseValue) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsResponseValue) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsResponseValue.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsResponseValue proto.InternalMessageInfo

func (m *LilacCDNMetricsResponseValue) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *LilacCDNMetricsResponseValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Metrics Series
//
// x-displayName: "Metrics Response Series"
// CDN Metrics response series.
// Each series instance has data for a combination of group-by tag values.
type LilacCDNMetricsResponseSeries struct {
	// Metrics group by options
	//
	// x-displayName: "Metrics Group By"
	// CDN Metrics group-by tag combination.
	GroupBy []*LilacCDNMetricsResponseGroupBy `protobuf:"bytes,1,rep,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	// Metrics Response Value
	//
	// x-displayName: "Metrics Response Value"
	// CDN Metrics data for the series.
	Value []*LilacCDNMetricsResponseValue `protobuf:"bytes,2,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *LilacCDNMetricsResponseSeries) Reset()      { *m = LilacCDNMetricsResponseSeries{} }
func (*LilacCDNMetricsResponseSeries) ProtoMessage() {}
func (*LilacCDNMetricsResponseSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{38}
}
func (m *LilacCDNMetricsResponseSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsResponseSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsResponseSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsResponseSeries.Merge(m, src)
}
func (m *LilacCDNMetricsResponseSeries) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsResponseSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsResponseSeries.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsResponseSeries proto.InternalMessageInfo

func (m *LilacCDNMetricsResponseSeries) GetGroupBy() []*LilacCDNMetricsResponseGroupBy {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *LilacCDNMetricsResponseSeries) GetValue() []*LilacCDNMetricsResponseValue {
	if m != nil {
		return m.Value
	}
	return nil
}

// Metrics Response Data
//
// x-displayName: "Metrics Response Data"
// CDN Metrics response data. This is specific to a metric field.
type LilacCDNMetricsResponseData struct {
	// Metrics Field Selector options
	//
	// x-displayName: "Metrics Field Selector"
	// Metrics field for this response message
	Type LilacCDNMetricsFieldSelector `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFieldSelector" json:"type,omitempty"`
	// Metric Unit
	//
	// x-displayName: "Metric Unit"
	// Metric Unit of the field in this message
	Unit LilacCDNMetricUnit `protobuf:"varint,2,opt,name=unit,proto3,enum=ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricUnit" json:"unit,omitempty"`
	// Metrics Series
	//
	// x-displayName: "Metrics Response Series"
	// CDN Metrics response series for the field in this message
	Series []*LilacCDNMetricsResponseSeries `protobuf:"bytes,3,rep,name=series,proto3" json:"series,omitempty"`
}

func (m *LilacCDNMetricsResponseData) Reset()      { *m = LilacCDNMetricsResponseData{} }
func (*LilacCDNMetricsResponseData) ProtoMessage() {}
func (*LilacCDNMetricsResponseData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a2659efdd085843, []int{39}
}
func (m *LilacCDNMetricsResponseData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNMetricsResponseData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LilacCDNMetricsResponseData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNMetricsResponseData.Merge(m, src)
}
func (m *LilacCDNMetricsResponseData) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNMetricsResponseData) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNMetricsResponseData.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNMetricsResponseData proto.InternalMessageInfo

func (m *LilacCDNMetricsResponseData) GetType() LilacCDNMetricsFieldSelector {
	if m != nil {
		return m.Type
	}
	return REQUEST_TOTAL_SUM
}

func (m *LilacCDNMetricsResponseData) GetUnit() LilacCDNMetricUnit {
	if m != nil {
		return m.Unit
	}
	return COUNT
}

func (m *LilacCDNMetricsResponseData) GetSeries() []*LilacCDNMetricsResponseSeries {
	if m != nil {
		return m.Series
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.HeaderOptions", HeaderOptions_name, HeaderOptions_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.HeaderOptions", HeaderOptions_name, HeaderOptions_value)
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFieldSelector", LilacCDNMetricsFieldSelector_name, LilacCDNMetricsFieldSelector_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFieldSelector", LilacCDNMetricsFieldSelector_name, LilacCDNMetricsFieldSelector_value)
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag", LilacCDNMetricsTag_name, LilacCDNMetricsTag_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsTag", LilacCDNMetricsTag_name, LilacCDNMetricsTag_value)
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsOperatorType", LilacCDNMetricsOperatorType_name, LilacCDNMetricsOperatorType_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsOperatorType", LilacCDNMetricsOperatorType_name, LilacCDNMetricsOperatorType_value)
	proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricUnit", LilacCDNMetricUnit_name, LilacCDNMetricUnit_value)
	golang_proto.RegisterEnum("ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricUnit", LilacCDNMetricUnit_name, LilacCDNMetricUnit_value)
	proto.RegisterType((*ProxyTypeHttpsAutoCerts)(nil), "ves.io.schema.views.cdn_loadbalancer.ProxyTypeHttpsAutoCerts")
	golang_proto.RegisterType((*ProxyTypeHttpsAutoCerts)(nil), "ves.io.schema.views.cdn_loadbalancer.ProxyTypeHttpsAutoCerts")
	proto.RegisterType((*HeaderControlType)(nil), "ves.io.schema.views.cdn_loadbalancer.HeaderControlType")
	golang_proto.RegisterType((*HeaderControlType)(nil), "ves.io.schema.views.cdn_loadbalancer.HeaderControlType")
	proto.RegisterType((*SecurityOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.SecurityOptionsType")
	golang_proto.RegisterType((*SecurityOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.SecurityOptionsType")
	proto.RegisterType((*LoggingOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.LoggingOptionsType")
	golang_proto.RegisterType((*LoggingOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.LoggingOptionsType")
	proto.RegisterType((*CDNCacheRuleExpressionList)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCacheRuleExpressionList")
	golang_proto.RegisterType((*CDNCacheRuleExpressionList)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCacheRuleExpressionList")
	proto.RegisterType((*CacheOperator)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheOperator")
	golang_proto.RegisterType((*CacheOperator)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheOperator")
	proto.RegisterType((*CacheHeaderMatcherType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheHeaderMatcherType")
	golang_proto.RegisterType((*CacheHeaderMatcherType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheHeaderMatcherType")
	proto.RegisterType((*CDNPathMatcherType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNPathMatcherType")
	golang_proto.RegisterType((*CDNPathMatcherType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNPathMatcherType")
	proto.RegisterType((*CacheCookieMatcherType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheCookieMatcherType")
	golang_proto.RegisterType((*CacheCookieMatcherType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheCookieMatcherType")
	proto.RegisterType((*CacheQueryParameterMatcherType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheQueryParameterMatcherType")
	golang_proto.RegisterType((*CacheQueryParameterMatcherType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheQueryParameterMatcherType")
	proto.RegisterType((*CDNCacheRuleExpression)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCacheRuleExpression")
	golang_proto.RegisterType((*CDNCacheRuleExpression)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCacheRuleExpression")
	proto.RegisterType((*CacheTTLEnableProps)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheTTLEnableProps")
	golang_proto.RegisterType((*CacheTTLEnableProps)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheTTLEnableProps")
	proto.RegisterType((*CacheEligibleOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheEligibleOptions")
	golang_proto.RegisterType((*CacheEligibleOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheEligibleOptions")
	proto.RegisterType((*CDNCacheRule)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCacheRule")
	golang_proto.RegisterType((*CDNCacheRule)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCacheRule")
	proto.RegisterType((*DefaultCacheTTLProps)(nil), "ves.io.schema.views.cdn_loadbalancer.DefaultCacheTTLProps")
	golang_proto.RegisterType((*DefaultCacheTTLProps)(nil), "ves.io.schema.views.cdn_loadbalancer.DefaultCacheTTLProps")
	proto.RegisterType((*DefaultCacheAction)(nil), "ves.io.schema.views.cdn_loadbalancer.DefaultCacheAction")
	golang_proto.RegisterType((*DefaultCacheAction)(nil), "ves.io.schema.views.cdn_loadbalancer.DefaultCacheAction")
	proto.RegisterType((*CacheOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheOptions")
	golang_proto.RegisterType((*CacheOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheOptions")
	proto.RegisterType((*CacheTTLOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheTTLOptionsType")
	golang_proto.RegisterType((*CacheTTLOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CacheTTLOptionsType")
	proto.RegisterType((*AdvancedOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.AdvancedOptionsType")
	golang_proto.RegisterType((*AdvancedOptionsType)(nil), "ves.io.schema.views.cdn_loadbalancer.AdvancedOptionsType")
	proto.RegisterType((*CDNTLSConfig)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNTLSConfig")
	golang_proto.RegisterType((*CDNTLSConfig)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNTLSConfig")
	proto.RegisterType((*CDNHTTPSAutoCertsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSAutoCertsType")
	golang_proto.RegisterType((*CDNHTTPSAutoCertsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSAutoCertsType")
	proto.RegisterType((*CDNDownstreamTlsParamsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDownstreamTlsParamsType")
	golang_proto.RegisterType((*CDNDownstreamTlsParamsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNDownstreamTlsParamsType")
	proto.RegisterType((*CDNHTTPSCustomCertsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSCustomCertsType")
	golang_proto.RegisterType((*CDNHTTPSCustomCertsType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSCustomCertsType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.GlobalSpecType")
	proto.RegisterType((*IpFilteringOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.IpFilteringOptions")
	golang_proto.RegisterType((*IpFilteringOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.IpFilteringOptions")
	proto.RegisterType((*GeoFilteringOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.GeoFilteringOptions")
	golang_proto.RegisterType((*GeoFilteringOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.GeoFilteringOptions")
	proto.RegisterType((*LogHeaderOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.LogHeaderOptions")
	golang_proto.RegisterType((*LogHeaderOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.LogHeaderOptions")
	proto.RegisterType((*CDNCustomAuthentication)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCustomAuthentication")
	golang_proto.RegisterType((*CDNCustomAuthentication)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNCustomAuthentication")
	proto.RegisterType((*AuthenticationOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.AuthenticationOptions")
	golang_proto.RegisterType((*AuthenticationOptions)(nil), "ves.io.schema.views.cdn_loadbalancer.AuthenticationOptions")
	proto.RegisterType((*CDNOriginServerType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNOriginServerType")
	golang_proto.RegisterType((*CDNOriginServerType)(nil), "ves.io.schema.views.cdn_loadbalancer.CDNOriginServerType")
	proto.RegisterType((*CdnOriginPoolType)(nil), "ves.io.schema.views.cdn_loadbalancer.CdnOriginPoolType")
	golang_proto.RegisterType((*CdnOriginPoolType)(nil), "ves.io.schema.views.cdn_loadbalancer.CdnOriginPoolType")
	proto.RegisterType((*OriginAdvancedConfiguration)(nil), "ves.io.schema.views.cdn_loadbalancer.OriginAdvancedConfiguration")
	golang_proto.RegisterType((*OriginAdvancedConfiguration)(nil), "ves.io.schema.views.cdn_loadbalancer.OriginAdvancedConfiguration")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.cdn_loadbalancer.GetSpecType")
	proto.RegisterType((*LilacCDNMetricsFilter)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFilter")
	golang_proto.RegisterType((*LilacCDNMetricsFilter)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsFilter")
	proto.RegisterType((*LilacCDNMetricsResponseGroupBy)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseGroupBy")
	golang_proto.RegisterType((*LilacCDNMetricsResponseGroupBy)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseGroupBy")
	proto.RegisterType((*LilacCDNMetricsResponseValue)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseValue")
	golang_proto.RegisterType((*LilacCDNMetricsResponseValue)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseValue")
	proto.RegisterType((*LilacCDNMetricsResponseSeries)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseSeries")
	golang_proto.RegisterType((*LilacCDNMetricsResponseSeries)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseSeries")
	proto.RegisterType((*LilacCDNMetricsResponseData)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseData")
	golang_proto.RegisterType((*LilacCDNMetricsResponseData)(nil), "ves.io.schema.views.cdn_loadbalancer.LilacCDNMetricsResponseData")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/cdn_loadbalancer/types.proto", fileDescriptor_0a2659efdd085843)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/cdn_loadbalancer/types.proto", fileDescriptor_0a2659efdd085843)
}

var fileDescriptor_0a2659efdd085843 = []byte{
	// 5219 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7c, 0x6f, 0x6c, 0x5b, 0x59,
	0x56, 0xb8, 0xaf, 0xed, 0xd8, 0xce, 0x71, 0xe2, 0x38, 0x37, 0x69, 0xe2, 0x64, 0x3a, 0xa9, 0xc7,
	0xbf, 0xce, 0x8f, 0x4c, 0x9a, 0x3a, 0x8d, 0x3b, 0xed, 0x4c, 0x33, 0xb3, 0x9d, 0x8d, 0x9d, 0xb4,
	0x49, 0x48, 0x93, 0xcc, 0x8b, 0x33, 0x7f, 0x77, 0xf6, 0xe9, 0xc5, 0xbe, 0x71, 0xde, 0xf4, 0xc5,
	0xcf, 0xf3, 0xde, 0x73, 0x3b, 0x59, 0x51, 0x31, 0x42, 0xbb, 0x1f, 0x16, 0x04, 0x82, 0xb2, 0x68,
	0xf9, 0x02, 0x82, 0x0f, 0xc0, 0xb2, 0x1f, 0x56, 0xf0, 0x05, 0x24, 0xcc, 0x4a, 0x55, 0x05, 0x68,
	0x55, 0x24, 0xe8, 0x17, 0xa4, 0xd1, 0x22, 0x10, 0x93, 0x11, 0x30, 0xbb, 0x0c, 0xd2, 0x50, 0x46,
	0x68, 0x85, 0x16, 0x2d, 0xba, 0x7f, 0x9e, 0xfd, 0x9e, 0xfd, 0xec, 0xda, 0x6d, 0x67, 0x24, 0xa0,
	0x9f, 0x62, 0xdf, 0x7b, 0xfe, 0xdd, 0x73, 0xcf, 0x39, 0xf7, 0xdc, 0x73, 0x8f, 0x03, 0x67, 0xae,
	0x11, 0x33, 0xad, 0xea, 0x73, 0x66, 0x61, 0x9f, 0x1c, 0x28, 0x73, 0xd7, 0x54, 0x72, 0xdd, 0x9c,
	0x2b, 0x14, 0xcb, 0xb2, 0xa6, 0x2b, 0xc5, 0x5d, 0x45, 0x53, 0xca, 0x05, 0x62, 0xcc, 0x59, 0x87,
	0x15, 0x62, 0xa6, 0x2b, 0x86, 0x6e, 0xe9, 0xf8, 0x24, 0xc7, 0x48, 0x73, 0x8c, 0x34, 0xc3, 0x48,
	0x37, 0x63, 0x4c, 0x9e, 0x2e, 0xa9, 0xd6, 0x7e, 0x75, 0x37, 0x5d, 0xd0, 0x0f, 0xe6, 0x4a, 0x7a,
	0x49, 0x9f, 0x63, 0xc8, 0xbb, 0xd5, 0x3d, 0xf6, 0x8d, 0x7d, 0x61, 0x9f, 0x38, 0xd1, 0xc9, 0x13,
	0x25, 0x5d, 0x2f, 0x69, 0xa4, 0x01, 0x65, 0xa9, 0x07, 0xc4, 0xb4, 0x94, 0x83, 0x8a, 0x00, 0x78,
	0xc2, 0x2d, 0xa7, 0x5e, 0xb1, 0x54, 0xbd, 0x2c, 0x44, 0x9a, 0x4c, 0xba, 0x27, 0x2b, 0xba, 0xa6,
	0x16, 0x0e, 0x9d, 0x42, 0x4f, 0xfe, 0x7f, 0x37, 0x84, 0xa1, 0x58, 0x44, 0xd6, 0xd4, 0x03, 0xd5,
	0x72, 0x2f, 0x6e, 0xf2, 0x44, 0x13, 0x9c, 0x5e, 0xb5, 0x88, 0x0b, 0x60, 0xda, 0x0d, 0x60, 0x12,
	0xe3, 0x9a, 0x5a, 0x20, 0xb2, 0x07, 0xcb, 0xd3, 0x9d, 0x20, 0x65, 0xa3, 0xaa, 0xb9, 0x09, 0x4f,
	0xb8, 0xc1, 0x9d, 0x53, 0xc7, 0x9b, 0xf6, 0x48, 0xd1, 0xd4, 0xa2, 0x62, 0x11, 0xef, 0xc5, 0xd3,
	0xfd, 0x90, 0xdd, 0xea, 0x79, 0xa1, 0xab, 0x3d, 0x56, 0x0a, 0x05, 0x62, 0x9a, 0xb2, 0xa6, 0x97,
	0x5c, 0xcc, 0xe7, 0xbd, 0x90, 0xf7, 0x2d, 0xab, 0xd2, 0xd6, 0x42, 0x26, 0x4f, 0x79, 0xa1, 0xe8,
	0x86, 0x5a, 0x52, 0xcb, 0x72, 0x45, 0xd7, 0x35, 0x17, 0xf0, 0x59, 0x2f, 0x60, 0xe7, 0xfe, 0x78,
	0xe9, 0xf6, 0x84, 0x17, 0x52, 0x87, 0xfd, 0xbe, 0xa6, 0x1a, 0x56, 0x55, 0xd1, 0xe4, 0x7d, 0xdd,
	0xb4, 0x5c, 0x70, 0x67, 0xda, 0xc3, 0xc9, 0xc5, 0xb2, 0x29, 0xab, 0xe5, 0x3d, 0x7d, 0x4e, 0xdf,
	0x7d, 0x9b, 0x14, 0x2c, 0x8e, 0x91, 0xfa, 0xa7, 0x00, 0x8c, 0x6f, 0x19, 0xfa, 0xbb, 0x87, 0xf9,
	0xc3, 0x0a, 0x59, 0xb1, 0xac, 0x8a, 0xb9, 0x58, 0xb5, 0xf4, 0x1c, 0x31, 0x2c, 0x13, 0x3f, 0x03,
	0x83, 0x4c, 0x33, 0x06, 0x29, 0xaa, 0x06, 0x29, 0x58, 0x09, 0x94, 0x44, 0xd3, 0x91, 0x6c, 0xf0,
	0x47, 0x35, 0xe4, 0x93, 0x06, 0xe8, 0x94, 0x24, 0x66, 0xf0, 0x09, 0x88, 0x28, 0xc5, 0xa2, 0xbc,
	0x6f, 0x5a, 0x66, 0xc2, 0xef, 0x80, 0x0a, 0x2b, 0xc5, 0xe2, 0x8a, 0x69, 0x99, 0x38, 0x07, 0x60,
	0x69, 0xa6, 0x5c, 0xd0, 0xcb, 0x7b, 0x6a, 0x29, 0x11, 0x48, 0xa2, 0xe9, 0x68, 0x66, 0x2a, 0xed,
	0xe5, 0x7b, 0x79, 0xcd, 0xcc, 0x31, 0xa8, 0x6c, 0xf0, 0x93, 0x1a, 0x42, 0x52, 0xbf, 0x65, 0x0f,
	0xe0, 0x1c, 0xc4, 0x8a, 0x64, 0x4f, 0xa9, 0x6a, 0x96, 0xbc, 0x4f, 0x94, 0x22, 0x31, 0x12, 0x7d,
	0x8c, 0xd0, 0x68, 0x13, 0xa1, 0xe5, 0x83, 0x8a, 0x75, 0x98, 0x0d, 0xde, 0xaa, 0x21, 0xb4, 0xe2,
	0x93, 0x06, 0x05, 0xce, 0x0a, 0x43, 0xc1, 0xf3, 0x10, 0xa5, 0xc6, 0x4b, 0x0c, 0xb9, 0xac, 0x1c,
	0x90, 0x44, 0x28, 0x89, 0xa6, 0xfb, 0xb3, 0x31, 0x0a, 0xfb, 0x27, 0x3f, 0xb8, 0x15, 0xe8, 0x33,
	0x02, 0xef, 0xfb, 0x29, 0x16, 0x70, 0xa0, 0x0d, 0xe5, 0x80, 0xe0, 0x8b, 0x80, 0x95, 0x4a, 0x85,
	0x94, 0x8b, 0xb2, 0x13, 0x33, 0xdc, 0x06, 0x33, 0xce, 0x61, 0xb7, 0x1b, 0xf8, 0x2f, 0xc1, 0x40,
	0x45, 0x31, 0x4d, 0xd9, 0xda, 0x37, 0xf4, 0x6a, 0x69, 0x3f, 0x11, 0xe9, 0x42, 0xea, 0x28, 0xc5,
	0xc8, 0x73, 0x84, 0x05, 0xb8, 0x77, 0x31, 0x3c, 0x3f, 0x9b, 0x99, 0x3d, 0x3b, 0xfb, 0x6c, 0x76,
	0x0e, 0x46, 0x85, 0x14, 0x5c, 0x07, 0x72, 0x61, 0x5f, 0x57, 0x0b, 0x04, 0x8f, 0xdf, 0xaa, 0xa1,
	0xbe, 0xef, 0xd5, 0x10, 0xba, 0x5b, 0x43, 0xc1, 0xa3, 0x1a, 0x0a, 0x9f, 0x9b, 0x3d, 0x3f, 0xfb,
	0xdc, 0xec, 0xf3, 0x6b, 0xc1, 0x48, 0x30, 0xde, 0x97, 0xfa, 0xc5, 0x20, 0x0c, 0x73, 0x0d, 0xe4,
	0xf4, 0xb2, 0x65, 0xe8, 0x1a, 0xdd, 0x70, 0xfc, 0x15, 0x18, 0x33, 0xc8, 0x3b, 0x55, 0x62, 0xda,
	0x1a, 0x35, 0x65, 0x4b, 0x97, 0x95, 0x62, 0x31, 0x81, 0x92, 0x81, 0xe9, 0x68, 0xe6, 0x54, 0x93,
	0x8c, 0x9c, 0xc2, 0x15, 0xa5, 0xac, 0x56, 0xaa, 0x9a, 0x42, 0xbd, 0x72, 0x93, 0xf9, 0x26, 0x25,
	0x96, 0x4d, 0xdc, 0xb5, 0x55, 0x71, 0x13, 0xf9, 0xe3, 0x49, 0xfb, 0x53, 0x02, 0x49, 0x23, 0x82,
	0x09, 0x47, 0x37, 0xf3, 0xfa, 0x62, 0xb1, 0x88, 0xbf, 0x86, 0x60, 0xc2, 0x83, 0xb9, 0x41, 0x0e,
	0xf4, 0x6b, 0x24, 0xe1, 0x4f, 0x06, 0xa6, 0xfb, 0xb3, 0x6b, 0x36, 0xc9, 0x81, 0x9b, 0xa8, 0x3f,
	0x15, 0x36, 0xe8, 0x7e, 0xbf, 0xe7, 0xa7, 0x03, 0xc7, 0x6f, 0xa2, 0x89, 0xd4, 0xb8, 0x71, 0x2c,
	0x33, 0xf2, 0xe5, 0x37, 0xcf, 0x9c, 0xbe, 0xb0, 0x78, 0xfa, 0x0d, 0xe5, 0xf4, 0x57, 0xe4, 0x2f,
	0x9d, 0xfe, 0x52, 0xfa, 0xad, 0x53, 0x27, 0x3d, 0x85, 0x18, 0x6b, 0x16, 0x42, 0x62, 0x9c, 0xf0,
	0xcf, 0xc0, 0xb8, 0x41, 0xcc, 0x8a, 0x5e, 0x36, 0x49, 0xb3, 0x12, 0x02, 0x8f, 0x52, 0x09, 0xa3,
	0x36, 0x17, 0x97, 0x16, 0xae, 0xc1, 0xa4, 0x17, 0x77, 0xa1, 0x85, 0x20, 0xd3, 0xc2, 0x05, 0x9b,
	0x66, 0xef, 0x8b, 0x1e, 0x6f, 0x61, 0xca, 0x57, 0x9d, 0xfa, 0x33, 0x3f, 0x8c, 0x6c, 0x93, 0x42,
	0xd5, 0x50, 0xad, 0x43, 0x2e, 0xbe, 0xc9, 0x2c, 0x42, 0x81, 0x01, 0xb5, 0x22, 0xef, 0xa9, 0x9a,
	0x45, 0x0c, 0xb5, 0x5c, 0x12, 0x1e, 0xf6, 0x7c, 0xba, 0x9b, 0x63, 0x32, 0xbd, 0x5a, 0xb9, 0x64,
	0x23, 0x0a, 0x9a, 0xd9, 0x20, 0x95, 0x5d, 0x8a, 0xaa, 0x8d, 0x19, 0x5c, 0x84, 0xc1, 0x12, 0xd1,
	0x1d, 0x3c, 0x42, 0x8c, 0xc7, 0x85, 0xee, 0x78, 0x5c, 0x26, 0x7a, 0x1b, 0x26, 0x03, 0x25, 0xc7,
	0x14, 0x2e, 0xc2, 0x80, 0x52, 0xb5, 0xf6, 0xed, 0xc3, 0x23, 0xd1, 0xcf, 0x98, 0xbc, 0xd0, 0x1d,
	0x93, 0xc5, 0xaa, 0xb5, 0x4f, 0xca, 0x96, 0x5a, 0x70, 0x6c, 0x6f, 0x7d, 0x2d, 0x94, 0xac, 0x18,
	0x4a, 0x7d, 0x8c, 0x00, 0xaf, 0xeb, 0xa5, 0x52, 0x43, 0x18, 0xa6, 0xc5, 0xb7, 0x01, 0x17, 0x34,
	0x95, 0x94, 0x2d, 0x7a, 0x00, 0xd5, 0x45, 0x08, 0x33, 0x11, 0xce, 0x77, 0x27, 0xc2, 0xba, 0x5e,
	0xe2, 0x7b, 0xe6, 0xe6, 0x1e, 0xe7, 0x74, 0xd7, 0x75, 0x9b, 0x1f, 0xe5, 0x25, 0x4e, 0x23, 0x27,
	0xaf, 0xc8, 0xa3, 0xe0, 0xc5, 0xe9, 0x36, 0x78, 0xa5, 0xfe, 0xce, 0x0f, 0x93, 0xb9, 0xa5, 0x8d,
	0x9c, 0x52, 0xd8, 0x27, 0x52, 0x55, 0x23, 0xcb, 0xef, 0x56, 0x0c, 0x62, 0x9a, 0xaa, 0x5e, 0x5e,
	0x57, 0x4d, 0x0b, 0x9f, 0x85, 0x21, 0x52, 0x1f, 0xe1, 0x51, 0x12, 0xb1, 0x28, 0x09, 0x22, 0x42,
	0x26, 0xde, 0x43, 0x52, 0xac, 0x01, 0xc2, 0xa2, 0xe3, 0x37, 0x10, 0x1c, 0x2b, 0x50, 0x82, 0x2c,
	0x8b, 0x90, 0x1b, 0xb3, 0x2c, 0x06, 0x44, 0x33, 0x2f, 0x76, 0xb7, 0x06, 0x6f, 0xb1, 0xb2, 0xa9,
	0x4f, 0x9c, 0xfe, 0x18, 0xb1, 0x3f, 0x45, 0x90, 0x33, 0x3c, 0x15, 0x5a, 0x11, 0x17, 0xcc, 0x3b,
	0x35, 0xa4, 0xc3, 0x49, 0x18, 0x6a, 0x8c, 0x25, 0xa9, 0xbc, 0x93, 0xc3, 0x2d, 0x8b, 0x84, 0xcb,
	0x10, 0x77, 0x40, 0x5d, 0x51, 0xac, 0xc2, 0x7e, 0xea, 0x6c, 0x9b, 0x55, 0x61, 0xe0, 0xa7, 0x59,
	0xd5, 0x20, 0xc5, 0xc9, 0xd8, 0x86, 0x6e, 0x25, 0x1b, 0xdf, 0x53, 0x5f, 0x0f, 0xc0, 0x20, 0x5b,
	0xc5, 0x66, 0x85, 0x18, 0x8a, 0xa5, 0x1b, 0x38, 0x01, 0xa1, 0xe5, 0x77, 0xaa, 0x8a, 0xc6, 0xcf,
	0xd5, 0xfe, 0x15, 0x9f, 0x24, 0xbe, 0xe3, 0x93, 0x30, 0xb0, 0xa4, 0x13, 0x73, 0x43, 0xb7, 0xd8,
	0x00, 0x3b, 0x54, 0xe9, 0xbc, 0x6b, 0x14, 0x1f, 0x87, 0x08, 0x0d, 0xf8, 0x8a, 0x5a, 0x36, 0x13,
	0x41, 0x01, 0x51, 0x1f, 0xc1, 0xd3, 0x10, 0x13, 0xd0, 0x62, 0x88, 0xf9, 0x3b, 0x85, 0x69, 0x1a,
	0xc7, 0x49, 0x80, 0x6d, 0x4b, 0x31, 0x2c, 0xf3, 0xba, 0x6a, 0xed, 0xf3, 0x53, 0x93, 0x9e, 0x92,
	0x8d, 0x31, 0x3c, 0x0b, 0x71, 0x81, 0xc3, 0x06, 0x5f, 0xa5, 0x70, 0x61, 0x01, 0xd7, 0x32, 0x43,
	0xe5, 0x5a, 0x2e, 0x17, 0x39, 0xb5, 0x88, 0x2d, 0x97, 0x3d, 0xe2, 0x90, 0x6b, 0xb9, 0x5c, 0x64,
	0x94, 0xfa, 0x9b, 0xe4, 0x12, 0xe3, 0x54, 0x2e, 0xa6, 0x6f, 0x89, 0x94, 0xc8, 0xbb, 0x09, 0xb0,
	0xe5, 0x6a, 0x8c, 0x65, 0xcf, 0x40, 0x8c, 0x6f, 0x84, 0x6e, 0xeb, 0x74, 0xea, 0x56, 0x0d, 0xf9,
	0xa9, 0x85, 0x1f, 0xd5, 0x10, 0x66, 0xa7, 0xea, 0xac, 0x38, 0x2c, 0x67, 0x2f, 0xcc, 0xce, 0x9f,
	0x59, 0x0b, 0x46, 0x50, 0xdc, 0x9f, 0xfa, 0xa3, 0x10, 0x8c, 0xb1, 0xbd, 0xb0, 0xe3, 0xbd, 0x55,
	0xd8, 0x27, 0x06, 0x73, 0xef, 0xcb, 0x10, 0xac, 0x1b, 0x77, 0x2c, 0x73, 0xb6, 0x3b, 0x03, 0x75,
	0x79, 0x98, 0xc4, 0x08, 0xe0, 0x1d, 0x88, 0xd8, 0x52, 0x89, 0x48, 0xdb, 0x25, 0x31, 0x97, 0x91,
	0x88, 0x4c, 0xa9, 0x4e, 0x6a, 0xe1, 0xc3, 0xe0, 0xed, 0x1a, 0x4a, 0xc0, 0x18, 0x0c, 0x71, 0xa6,
	0x49, 0x4b, 0xe7, 0x56, 0x89, 0x03, 0xf3, 0xb3, 0xe7, 0xee, 0xd4, 0xd0, 0xed, 0x20, 0xc4, 0x21,
	0xc8, 0xcc, 0x39, 0xc2, 0xd7, 0x92, 0x44, 0xf0, 0xb7, 0x7e, 0x88, 0xd8, 0x24, 0x67, 0xfe, 0xca,
	0x0f, 0x7f, 0xe9, 0x87, 0x09, 0x18, 0xb2, 0x89, 0xa6, 0xb9, 0xd9, 0x65, 0x84, 0xf9, 0xc1, 0xd3,
	0x70, 0xac, 0x3e, 0xe5, 0xb4, 0xb8, 0x8c, 0xcb, 0xfe, 0xe0, 0x49, 0x18, 0xae, 0x83, 0xd9, 0x66,
	0x97, 0xa9, 0x1b, 0x20, 0x3c, 0x03, 0xe3, 0xcd, 0x54, 0xc4, 0x5c, 0xa6, 0xc9, 0x02, 0xe1, 0x29,
	0x18, 0xa9, 0x83, 0x36, 0xcc, 0x2e, 0xe3, 0x30, 0x41, 0x38, 0x0d, 0x13, 0xcd, 0xd4, 0xea, 0x16,
	0x97, 0x69, 0xb1, 0x41, 0x97, 0x6c, 0xb6, 0xe9, 0x65, 0xea, 0x46, 0xe8, 0x25, 0x9b, 0xb0, 0xba,
	0x4c, 0x93, 0x15, 0xba, 0x64, 0x6b, 0x98, 0x5e, 0xc6, 0x61, 0x86, 0xf0, 0xd7, 0x08, 0xfa, 0x5e,
	0x51, 0xb4, 0x2a, 0xc9, 0xfc, 0x39, 0x6a, 0xd1, 0x6a, 0x1b, 0x5d, 0x7a, 0xe8, 0xae, 0xad, 0xbe,
	0x3c, 0xb5, 0xd3, 0x41, 0x1f, 0x1e, 0x6b, 0x6f, 0xbb, 0x5e, 0xcf, 0xd5, 0xad, 0x05, 0x23, 0xa1,
	0x78, 0x78, 0x2d, 0x18, 0xf1, 0xc7, 0x03, 0x6b, 0xc1, 0x48, 0x20, 0x1e, 0x14, 0xa9, 0xe6, 0xd7,
	0x11, 0xe0, 0xdc, 0xd2, 0xc6, 0x96, 0x62, 0xed, 0x3b, 0x9d, 0xe6, 0x51, 0xd9, 0xfa, 0x1f, 0xfc,
	0xa9, 0xcb, 0xd6, 0x83, 0xf7, 0x2e, 0xa2, 0x73, 0x9c, 0x33, 0x77, 0x5c, 0xa7, 0x44, 0xa9, 0x1f,
	0xf7, 0x09, 0x27, 0xce, 0xe9, 0xfa, 0x55, 0x95, 0x38, 0xe5, 0x99, 0x72, 0x38, 0x71, 0xe3, 0x84,
	0x9a, 0x7e, 0xcf, 0xef, 0xe1, 0x9b, 0xfe, 0x47, 0xe7, 0x9b, 0x3f, 0xa4, 0xbe, 0xf9, 0x14, 0x9c,
	0x80, 0x04, 0x83, 0x4b, 0x6e, 0x29, 0x86, 0x72, 0x40, 0x2c, 0x62, 0x24, 0xf3, 0x0e, 0x27, 0xcd,
	0xdc, 0xa9, 0xa1, 0x5b, 0x41, 0x88, 0x09, 0x27, 0x0d, 0x71, 0x59, 0x1f, 0xbb, 0xe8, 0x63, 0x17,
	0xed, 0xc5, 0x45, 0x53, 0xbf, 0x16, 0x82, 0x29, 0x66, 0x66, 0x2f, 0x57, 0x89, 0x71, 0x58, 0x37,
	0x35, 0xa7, 0x1b, 0x3c, 0x0d, 0x81, 0xab, 0xe4, 0x50, 0x78, 0xc1, 0x48, 0xc3, 0x0b, 0xe8, 0xa7,
	0xa0, 0xe1, 0x4f, 0x22, 0x89, 0xce, 0x7f, 0x56, 0xde, 0xf0, 0x69, 0xdd, 0x1b, 0x98, 0x84, 0x1d,
	0xbc, 0xe1, 0x4e, 0x10, 0x06, 0x20, 0xf0, 0xd3, 0xe4, 0x70, 0xb2, 0x8f, 0x49, 0x0c, 0x1f, 0xf8,
	0x21, 0xc6, 0x20, 0x92, 0x8f, 0x3d, 0xe2, 0xb3, 0xf2, 0x88, 0xbf, 0x41, 0x10, 0xe5, 0x3a, 0xfe,
	0xdf, 0xe5, 0x17, 0x9f, 0x46, 0x61, 0xcc, 0xfb, 0xc2, 0x80, 0xdf, 0x02, 0xa8, 0x28, 0xd6, 0xbe,
	0x7c, 0x40, 0xa1, 0x99, 0x5b, 0x74, 0x7d, 0xfd, 0x6d, 0x3d, 0xf4, 0xc4, 0x69, 0xd5, 0x5f, 0xb1,
	0x87, 0xf1, 0xd7, 0x10, 0xc4, 0xdf, 0xa1, 0xa6, 0x2e, 0x57, 0x6c, 0x53, 0x37, 0x13, 0x21, 0x76,
	0xd1, 0x59, 0xea, 0xc1, 0xa1, 0xda, 0xfa, 0x73, 0x76, 0xb4, 0xf5, 0xb2, 0x93, 0x40, 0xd2, 0xd0,
	0x3b, 0x2e, 0x04, 0x13, 0x5f, 0x87, 0x41, 0x9e, 0x15, 0x8b, 0xa2, 0x43, 0xa2, 0xaf, 0xa7, 0xcb,
	0x96, 0x67, 0x5e, 0xdc, 0x86, 0xf7, 0x40, 0xa1, 0x01, 0x6d, 0xe2, 0x43, 0x88, 0x15, 0xd8, 0x59,
	0xcc, 0x35, 0x4c, 0x8c, 0x44, 0xb8, 0x67, 0xce, 0x2d, 0x87, 0x79, 0x1b, 0xce, 0x83, 0x05, 0x27,
	0xe0, 0xc2, 0xc7, 0x61, 0x56, 0x47, 0x3b, 0x3f, 0x7b, 0x6e, 0xf6, 0xb9, 0xdb, 0x35, 0x74, 0x1c,
	0x26, 0x61, 0x88, 0x5b, 0x77, 0x4e, 0x2f, 0x17, 0x55, 0x9a, 0x98, 0x63, 0x7b, 0xfe, 0x4e, 0x0d,
	0x7d, 0x37, 0x0c, 0xb7, 0x02, 0x00, 0x74, 0x4b, 0x79, 0x28, 0x9a, 0xf9, 0xc3, 0x00, 0x7c, 0x27,
	0x00, 0x27, 0x61, 0xb2, 0x61, 0x21, 0xe9, 0x76, 0xa1, 0xe6, 0x0c, 0x24, 0xbd, 0xa0, 0x3a, 0x44,
	0x9d, 0x69, 0x38, 0xee, 0x85, 0xe1, 0x11, 0x80, 0x9e, 0x85, 0x54, 0x07, 0xda, 0xed, 0x62, 0xd1,
	0x2c, 0x4c, 0x79, 0x61, 0xb5, 0x09, 0x4b, 0xcf, 0xc3, 0xc9, 0x0e, 0x3c, 0x3a, 0x45, 0xa8, 0x36,
	0xeb, 0xf0, 0x08, 0x56, 0x9d, 0xd7, 0xd1, 0x2e, 0x6e, 0xb5, 0x59, 0x47, 0x9b, 0x10, 0xf6, 0xc7,
	0x7e, 0xb1, 0x85, 0x3c, 0x82, 0x7d, 0xcb, 0xdf, 0x69, 0xf7, 0xee, 0xbf, 0x67, 0x9d, 0xf7, 0xa8,
	0x9b, 0x7d, 0xb9, 0xdf, 0x2e, 0x74, 0xa7, 0xf7, 0xce, 0x3a, 0xee, 0x46, 0xaf, 0xf7, 0xd3, 0x22,
	0xe4, 0x60, 0xd8, 0x71, 0x28, 0x8b, 0xb2, 0x46, 0xba, 0x35, 0x7c, 0x75, 0xaa, 0x68, 0xc0, 0x0b,
	0x30, 0x20, 0xee, 0xa0, 0x1c, 0xff, 0x54, 0x53, 0xdc, 0xe9, 0x88, 0xfc, 0x22, 0x0c, 0x70, 0x57,
	0x17, 0xc8, 0xb3, 0xcd, 0xb1, 0xa3, 0x13, 0xb6, 0xc7, 0xcd, 0xe4, 0xb7, 0x11, 0x8c, 0xb0, 0x00,
	0x92, 0xcf, 0xaf, 0x2f, 0x97, 0x95, 0x5d, 0x8d, 0x6c, 0x19, 0x7a, 0xc5, 0xc4, 0x3f, 0x05, 0xfd,
	0x5c, 0x28, 0xcb, 0xd2, 0x9a, 0xee, 0x03, 0x9f, 0xf8, 0x91, 0x14, 0x61, 0x93, 0x79, 0x4b, 0xc3,
	0xcf, 0xc2, 0x98, 0x5a, 0x2a, 0xeb, 0x06, 0x91, 0xeb, 0x45, 0x5b, 0x2e, 0x10, 0xbb, 0xd1, 0x44,
	0xa4, 0x51, 0x3e, 0x2b, 0x89, 0x49, 0x2e, 0x3c, 0x7e, 0xba, 0x5e, 0x81, 0xb8, 0x46, 0x0c, 0x43,
	0x2d, 0x12, 0x56, 0x89, 0x89, 0x48, 0x5c, 0x13, 0x9b, 0x62, 0x50, 0xdc, 0x58, 0xbe, 0x1b, 0x86,
	0x51, 0x26, 0xe3, 0xb2, 0xa6, 0x96, 0xd4, 0x5d, 0x8d, 0xd8, 0x75, 0xbe, 0x6f, 0x22, 0x18, 0x61,
	0xb1, 0x91, 0xb0, 0x07, 0x1d, 0x7a, 0x1f, 0x90, 0xab, 0x86, 0x2a, 0xb2, 0xb1, 0x0b, 0x3d, 0x84,
	0x4f, 0xf7, 0xea, 0xb3, 0x33, 0x47, 0x37, 0x9e, 0x92, 0x48, 0x45, 0x53, 0x0a, 0xa4, 0x98, 0xdc,
	0x3d, 0x4c, 0x0a, 0x26, 0x15, 0x43, 0x7f, 0xf7, 0x90, 0xbf, 0x1d, 0x55, 0x0d, 0xf5, 0xa3, 0x1a,
	0x42, 0x09, 0xb4, 0xe2, 0x93, 0x86, 0xf9, 0xf4, 0x8a, 0x10, 0x61, 0xc7, 0x50, 0xf1, 0x77, 0x10,
	0x3c, 0xd1, 0x2c, 0x99, 0x5d, 0xd9, 0xa7, 0x12, 0x06, 0x1e, 0x56, 0xc2, 0xcc, 0xd1, 0x8d, 0x67,
	0x3a, 0x4b, 0xe8, 0x60, 0x57, 0x97, 0x34, 0xe1, 0x96, 0x54, 0xe2, 0x20, 0x54, 0xe0, 0x9f, 0x47,
	0x30, 0xe0, 0xd2, 0x61, 0xf0, 0xf3, 0xd5, 0x61, 0x74, 0xdf, 0xa1, 0xbd, 0x6f, 0x23, 0x98, 0xf0,
	0xd8, 0x57, 0x99, 0xb9, 0x99, 0xb8, 0x29, 0x7f, 0xee, 0xba, 0x1b, 0x6b, 0xd9, 0x65, 0x16, 0x0a,
	0x70, 0x19, 0x8e, 0x79, 0x2e, 0xad, 0xb7, 0x1a, 0xbe, 0x87, 0x9c, 0x2b, 0x3e, 0x09, 0x73, 0xca,
	0xec, 0x39, 0x92, 0x32, 0xa6, 0xca, 0xb9, 0x01, 0x4f, 0x76, 0x14, 0x58, 0xd4, 0xd4, 0x1f, 0x8a,
	0xef, 0x44, 0x13, 0xdf, 0x86, 0xa1, 0xb0, 0xe2, 0xc2, 0x7c, 0xf6, 0x69, 0xc0, 0x44, 0x38, 0xa3,
	0xbc, 0xa7, 0x1b, 0x32, 0x73, 0x5b, 0x3c, 0x74, 0xab, 0x86, 0x42, 0xa2, 0x8a, 0x18, 0x38, 0x3f,
	0xfb, 0x9c, 0x28, 0x1b, 0xfe, 0x42, 0x04, 0x06, 0x9c, 0xa9, 0x25, 0x0d, 0x2e, 0xac, 0x04, 0xdc,
	0xa6, 0x1c, 0x1e, 0xa1, 0x93, 0xac, 0x10, 0x7e, 0x13, 0xc1, 0x68, 0x53, 0xb1, 0x58, 0xd6, 0x54,
	0xd3, 0x12, 0x75, 0xf0, 0x2f, 0x3e, 0x4c, 0x1d, 0x7c, 0x5d, 0x35, 0xad, 0xec, 0xd4, 0x7d, 0xea,
	0xe0, 0xd8, 0x68, 0x2d, 0xe9, 0x5f, 0x00, 0x9e, 0xbe, 0xc9, 0xbb, 0x87, 0x15, 0xc5, 0x34, 0x85,
	0xa7, 0x78, 0xbe, 0x5d, 0x52, 0xc3, 0x66, 0xb0, 0x59, 0x06, 0x8a, 0xdf, 0xf6, 0x52, 0x9b, 0x30,
	0xe8, 0x85, 0x1e, 0x36, 0xac, 0x29, 0x10, 0xae, 0xf8, 0xa4, 0xb8, 0x4d, 0xf7, 0x92, 0x6e, 0x30,
	0x90, 0x85, 0x4f, 0x83, 0xf7, 0x2e, 0xf6, 0xb1, 0x27, 0xd2, 0x3b, 0x35, 0xf4, 0xcf, 0x41, 0x18,
	0x11, 0x85, 0x93, 0xa8, 0x43, 0xf9, 0xf0, 0xd5, 0xa0, 0xa8, 0xae, 0x27, 0x17, 0x0b, 0xbc, 0x0a,
	0x7b, 0x2f, 0x00, 0x29, 0xec, 0x5a, 0xe0, 0xe4, 0x00, 0x97, 0x3e, 0xc9, 0xe9, 0x06, 0x2d, 0xa3,
	0x4a, 0xe0, 0x25, 0x9c, 0x69, 0x5d, 0x49, 0xda, 0xd3, 0x11, 0xd2, 0xf5, 0x83, 0x64, 0xb2, 0x9f,
	0xf3, 0xca, 0xe7, 0xd7, 0xe1, 0x32, 0x5e, 0xe8, 0x8a, 0x80, 0xc3, 0xb2, 0xbd, 0x09, 0x5d, 0xc1,
	0x2f, 0x75, 0x2d, 0x89, 0xf7, 0x49, 0x35, 0x09, 0xdb, 0xc4, 0x4a, 0xf2, 0xcf, 0xb0, 0x83, 0x2f,
	0xf7, 0x2c, 0x57, 0x17, 0x64, 0x57, 0xf1, 0x73, 0x3d, 0xea, 0xcb, 0x3e, 0x19, 0x27, 0x63, 0x7c,
	0xad, 0xf6, 0x77, 0x78, 0xb9, 0xcb, 0x05, 0xb7, 0x6a, 0xae, 0x2d, 0xc9, 0x55, 0x18, 0xa1, 0xa6,
	0x9d, 0xd4, 0xf7, 0x92, 0x0d, 0x63, 0x37, 0x53, 0x19, 0x6f, 0xef, 0xeb, 0x94, 0x62, 0x64, 0x27,
	0xec, 0x6c, 0x46, 0xe1, 0x06, 0x85, 0x23, 0xb7, 0x6a, 0x28, 0x78, 0xb7, 0x86, 0xec, 0xfa, 0xe3,
	0x4b, 0x30, 0xba, 0xc4, 0xdb, 0x0f, 0xec, 0xd8, 0xd3, 0x5b, 0xc6, 0x91, 0xfa, 0xd5, 0x00, 0x60,
	0x27, 0x05, 0x6e, 0xb9, 0xf8, 0x77, 0x91, 0xa7, 0x73, 0xf9, 0x7b, 0x71, 0x2e, 0x2f, 0xc1, 0xb2,
	0x0b, 0x47, 0x37, 0xe6, 0x9d, 0xc7, 0x45, 0x5d, 0xca, 0xba, 0x3e, 0x93, 0x4a, 0xb9, 0x28, 0x86,
	0x8b, 0xaa, 0x49, 0x03, 0x69, 0xb1, 0x7e, 0x6c, 0xb4, 0x38, 0x26, 0x7e, 0x1e, 0x86, 0x1b, 0x24,
	0x44, 0x27, 0x06, 0x7f, 0xaa, 0x72, 0x2e, 0x78, 0xc5, 0x27, 0x0d, 0xd9, 0x4b, 0x16, 0x62, 0xe1,
	0x05, 0xc0, 0xad, 0xcc, 0xf9, 0x1b, 0x56, 0x13, 0x6a, 0xdc, 0x46, 0xb5, 0x53, 0x29, 0xfc, 0x05,
	0x3b, 0xe3, 0xb2, 0x25, 0xec, 0xd4, 0x29, 0xb2, 0xe2, 0x13, 0x99, 0xd8, 0x92, 0x00, 0xf6, 0xde,
	0xd6, 0x00, 0x8d, 0xf5, 0x22, 0xc8, 0xff, 0x23, 0x82, 0x01, 0x51, 0xd8, 0xb2, 0x1f, 0x61, 0x47,
	0xed, 0xd6, 0x14, 0x27, 0x66, 0x6f, 0xf5, 0x83, 0xd6, 0x7d, 0x96, 0x70, 0xb1, 0x75, 0xef, 0x55,
	0x88, 0x36, 0x5e, 0x16, 0x4d, 0x71, 0x3a, 0x64, 0x7a, 0x3f, 0x1d, 0xda, 0x5c, 0x9a, 0xa1, 0xfe,
	0x1a, 0x6a, 0xa6, 0x7e, 0xe0, 0x48, 0x98, 0x9d, 0xef, 0xdb, 0x9e, 0xbb, 0xea, 0x7f, 0xf0, 0x5d,
	0x0d, 0x3c, 0xe0, 0xae, 0x06, 0x7b, 0xd9, 0xd5, 0x71, 0x88, 0x32, 0xa6, 0x95, 0xc6, 0x9e, 0xfa,
	0x1d, 0x7b, 0xfa, 0xd5, 0x3e, 0x18, 0x59, 0x2c, 0x5e, 0xa3, 0x7a, 0x2a, 0x3a, 0xd7, 0xba, 0x0f,
	0x31, 0xd1, 0x69, 0x63, 0xbf, 0xad, 0xc7, 0x19, 0xd7, 0xe7, 0x7a, 0x79, 0xf6, 0x73, 0x34, 0xdd,
	0x64, 0x29, 0x63, 0xc4, 0x1e, 0xd8, 0x07, 0xf7, 0x9d, 0x6f, 0x82, 0xb8, 0x0c, 0x71, 0x53, 0xb4,
	0x64, 0xd4, 0x79, 0x0d, 0xf7, 0x92, 0xdf, 0x78, 0x34, 0x74, 0x38, 0xb8, 0x0d, 0x99, 0xee, 0x69,
	0x7c, 0x15, 0x86, 0x34, 0xde, 0xbb, 0x50, 0x67, 0x87, 0x7b, 0xb1, 0xd7, 0xd6, 0xc6, 0x07, 0x07,
	0xb7, 0x98, 0xe6, 0x9a, 0xc5, 0xbf, 0x89, 0x9c, 0x36, 0x63, 0xf3, 0x1b, 0x79, 0x90, 0xf4, 0xcd,
	0xc9, 0xf0, 0xb9, 0xf7, 0x6f, 0xa0, 0xa3, 0x1b, 0xff, 0xcf, 0x19, 0xb2, 0xca, 0xe4, 0x7a, 0x72,
	0x4f, 0x25, 0x9a, 0x1d, 0xa5, 0x04, 0x2f, 0x5b, 0x32, 0x1e, 0xac, 0x1a, 0x96, 0x69, 0x0b, 0xa8,
	0xd8, 0x4e, 0x6f, 0xcb, 0x36, 0xca, 0x64, 0xcb, 0xf4, 0x54, 0xe6, 0xe6, 0xed, 0x13, 0x0d, 0x2d,
	0xf0, 0xdc, 0x42, 0x8c, 0xb7, 0xbe, 0x4f, 0xd5, 0xdf, 0xad, 0x62, 0xf1, 0xa1, 0xb5, 0x60, 0x64,
	0x28, 0x1e, 0x4f, 0xfd, 0x0e, 0x62, 0xf9, 0x63, 0x7e, 0x7d, 0x5b, 0x74, 0xbd, 0x9d, 0x87, 0xa8,
	0xa5, 0x99, 0xf2, 0x7c, 0x46, 0xae, 0x68, 0x55, 0x53, 0x44, 0x94, 0x76, 0x26, 0xdf, 0x6f, 0x69,
	0xe6, 0x7c, 0x66, 0x4b, 0xab, 0x9a, 0x75, 0xbc, 0x79, 0x8e, 0xe7, 0xbf, 0x3f, 0xde, 0x3c, 0xc5,
	0xe3, 0x0f, 0x6a, 0xd9, 0x09, 0x08, 0x89, 0xc6, 0xb2, 0x21, 0xb1, 0x98, 0x3e, 0x9a, 0xe7, 0xce,
	0xcf, 0x66, 0xd6, 0x82, 0x91, 0xbe, 0x78, 0x28, 0xf5, 0x17, 0x08, 0x8e, 0xe5, 0x96, 0x36, 0x56,
	0xf2, 0xf9, 0xad, 0xed, 0x7a, 0xcf, 0x20, 0x73, 0x98, 0x47, 0xd9, 0x37, 0xf8, 0xaa, 0x47, 0xdf,
	0x60, 0xf7, 0xa1, 0xae, 0xae, 0xc4, 0x96, 0x5e, 0xc2, 0x85, 0x88, 0x9d, 0x2f, 0xa6, 0xfe, 0x03,
	0xb1, 0x9e, 0x96, 0x25, 0xfd, 0x7a, 0xd9, 0xb4, 0x0c, 0xa2, 0x1c, 0xe4, 0x35, 0x93, 0x55, 0x3c,
	0xf8, 0x6a, 0xdc, 0x12, 0xa0, 0x47, 0x26, 0x01, 0xde, 0x85, 0x38, 0x23, 0x4c, 0x0c, 0x4b, 0xdd,
	0x53, 0x0b, 0x8a, 0x55, 0x8f, 0xe5, 0x4f, 0x35, 0x91, 0xcf, 0x6b, 0x66, 0xae, 0x01, 0xd5, 0x54,
	0xef, 0x8c, 0x37, 0x52, 0x79, 0x69, 0xc8, 0x72, 0x41, 0x9a, 0x0b, 0x4f, 0xdc, 0xae, 0xa1, 0x71,
	0x38, 0x06, 0xb1, 0xfc, 0xfa, 0x76, 0xd2, 0x51, 0xfd, 0xa5, 0xfb, 0x98, 0xfa, 0x7b, 0x04, 0xe3,
	0xf6, 0x0e, 0xe6, 0xaa, 0xa6, 0xa5, 0x1f, 0x7c, 0x36, 0x7b, 0x78, 0x00, 0x31, 0xba, 0x50, 0x47,
	0xbd, 0x9b, 0xef, 0x63, 0xf7, 0x17, 0x9a, 0x36, 0x7b, 0x23, 0xda, 0x94, 0x06, 0x2d, 0x31, 0xc8,
	0x88, 0x3b, 0x76, 0xf6, 0x37, 0xa2, 0x10, 0xbb, 0xac, 0xe9, 0xbb, 0x8a, 0xb6, 0x5d, 0x21, 0x05,
	0xb6, 0xae, 0x9f, 0x85, 0x70, 0x51, 0x3f, 0x60, 0xdd, 0x30, 0x88, 0xf5, 0xd6, 0x11, 0xaa, 0xbe,
	0xfe, 0x9b, 0x28, 0x94, 0x0a, 0x1a, 0xfe, 0x7d, 0x76, 0x1b, 0x82, 0x9b, 0x28, 0x9c, 0x62, 0xb7,
	0x33, 0xbf, 0x73, 0x32, 0xce, 0x26, 0xc7, 0x6f, 0xa2, 0xd1, 0x14, 0x36, 0xe2, 0x99, 0xd8, 0x9b,
	0x5f, 0x4a, 0xbf, 0x75, 0xea, 0x4d, 0xde, 0x83, 0xf7, 0xd6, 0xa9, 0xd6, 0xee, 0x3b, 0xd7, 0xd5,
	0xca, 0xe6, 0x8a, 0xd7, 0x20, 0x48, 0xb5, 0x27, 0x54, 0xf0, 0xac, 0xa7, 0x0a, 0x5a, 0xfa, 0x91,
	0xd3, 0xae, 0x16, 0xdd, 0x15, 0x9f, 0xc4, 0x68, 0x60, 0x02, 0x43, 0xf4, 0xaf, 0x29, 0x2b, 0x55,
	0x4b, 0x67, 0x86, 0x24, 0xe2, 0xf7, 0x0b, 0x5d, 0x6b, 0xb6, 0xd5, 0x7d, 0xe9, 0xb9, 0xb9, 0xef,
	0x6c, 0x04, 0xc6, 0x3b, 0xd0, 0xc7, 0x06, 0x44, 0xb0, 0xfe, 0x42, 0x6f, 0xc4, 0x9b, 0x2c, 0x6b,
	0xc5, 0x27, 0x71, 0x6a, 0xf8, 0x14, 0x0c, 0x50, 0xbb, 0xd1, 0x74, 0xde, 0x64, 0x97, 0x88, 0x32,
	0xdb, 0x61, 0xa1, 0x93, 0xd9, 0x4f, 0x54, 0x29, 0x16, 0xd7, 0xc5, 0x24, 0x2e, 0x42, 0xf4, 0x80,
	0xde, 0x3a, 0x78, 0x6c, 0x4e, 0x0c, 0xf6, 0x72, 0x6c, 0x78, 0x1c, 0xea, 0x9c, 0x0d, 0xf3, 0x48,
	0xa0, 0x74, 0xf9, 0x14, 0xfe, 0x32, 0x44, 0x1d, 0x8d, 0xdd, 0xbd, 0x9d, 0xf3, 0xb9, 0x62, 0x79,
	0x93, 0xe1, 0x6e, 0xe9, 0xe2, 0x9c, 0xe7, 0xd6, 0x09, 0x7a, 0x7d, 0x14, 0x7f, 0x19, 0x06, 0x59,
	0x43, 0xbb, 0x5a, 0xb6, 0x88, 0x51, 0x56, 0xb4, 0xc4, 0x47, 0xbc, 0x7c, 0x91, 0xf2, 0x64, 0xb1,
	0xc9, 0x1a, 0xb5, 0x25, 0xb2, 0xc7, 0x3d, 0xfe, 0xdb, 0x37, 0xdc, 0xc8, 0x1f, 0xb1, 0xf3, 0x85,
	0x0e, 0xad, 0x8a, 0x11, 0x7c, 0x1c, 0xfa, 0xd9, 0x65, 0x88, 0x95, 0x1a, 0x7e, 0xc0, 0x9a, 0xaf,
	0xa4, 0x08, 0x1d, 0x61, 0xf5, 0x85, 0x15, 0x88, 0xd8, 0x4d, 0xe0, 0x89, 0x1f, 0xf2, 0x47, 0x97,
	0xd9, 0x16, 0xc6, 0x1e, 0x1d, 0xe3, 0xe9, 0xa5, 0xb2, 0xb9, 0x5a, 0xde, 0xd3, 0xa5, 0x70, 0x91,
	0x7f, 0xc0, 0x39, 0xe8, 0x33, 0x2d, 0xc5, 0x22, 0x89, 0x7f, 0x09, 0xb3, 0x0e, 0xa8, 0x4e, 0x64,
	0xd2, 0xaf, 0xf0, 0x2f, 0x2b, 0xba, 0x69, 0x6d, 0x53, 0x24, 0x89, 0xe3, 0xe2, 0x37, 0x61, 0xa8,
	0x6e, 0xb7, 0x32, 0x27, 0xf7, 0x31, 0x27, 0x97, 0xee, 0x44, 0xae, 0x11, 0xdf, 0x54, 0xbd, 0xcc,
	0x08, 0x66, 0xd9, 0x53, 0x8f, 0x22, 0xcc, 0x95, 0x0d, 0xe1, 0x6d, 0x88, 0x35, 0x88, 0xb3, 0x15,
	0xdf, 0xe3, 0xaa, 0xee, 0x28, 0xaa, 0x6d, 0xf2, 0x74, 0x91, 0x54, 0xe9, 0xd2, 0x80, 0xe2, 0x18,
	0xc1, 0xdb, 0x30, 0x64, 0xff, 0xee, 0xc1, 0x0e, 0x22, 0xff, 0xce, 0xf5, 0xf8, 0x4c, 0x27, 0xaa,
	0xdb, 0x1c, 0x67, 0x89, 0xa1, 0x48, 0x31, 0xd3, 0xf9, 0xd5, 0xc4, 0x1b, 0x00, 0x0e, 0x0d, 0x7c,
	0xfa, 0x40, 0x1a, 0x90, 0xfa, 0x0b, 0xf6, 0xca, 0x17, 0xde, 0xb8, 0x5d, 0x43, 0xaf, 0xc0, 0x24,
	0x8c, 0x64, 0x15, 0x53, 0x2d, 0xd4, 0x2f, 0xab, 0xdc, 0x8d, 0x68, 0xdc, 0x87, 0x71, 0x18, 0xca,
	0x2d, 0x6d, 0x24, 0xb9, 0xb5, 0x26, 0x99, 0x61, 0xfa, 0xe7, 0xcf, 0x4f, 0x23, 0x38, 0x01, 0x63,
	0xb6, 0xaf, 0x34, 0xe1, 0xf5, 0xcd, 0xcf, 0xcf, 0xce, 0x9f, 0xcd, 0x3e, 0x09, 0xc3, 0x4e, 0x9b,
	0x97, 0x2d, 0x1a, 0x52, 0xa9, 0x2b, 0xe1, 0xbb, 0x35, 0xd4, 0x48, 0x6c, 0x78, 0x4a, 0xd3, 0x17,
	0x0f, 0xd5, 0x5b, 0x84, 0xc2, 0xf1, 0xc8, 0x5a, 0x30, 0x32, 0x10, 0x1f, 0x74, 0xa5, 0x3a, 0xff,
	0x86, 0x00, 0xb7, 0xb6, 0x0c, 0xe3, 0x4b, 0x00, 0x8a, 0xa6, 0xe9, 0xd7, 0xed, 0xe2, 0x17, 0xdd,
	0xb6, 0xa7, 0x9b, 0x14, 0xc2, 0x7f, 0x45, 0x91, 0xde, 0x32, 0xc8, 0x9e, 0xfa, 0x2e, 0x7b, 0x1c,
	0xa0, 0x57, 0x7a, 0x9a, 0xc8, 0x30, 0x54, 0x56, 0xba, 0xba, 0x04, 0xb0, 0xab, 0xe9, 0x85, 0xab,
	0x9c, 0x4e, 0xa0, 0x47, 0x3a, 0x0c, 0x95, 0x7e, 0x59, 0x38, 0x71, 0xbb, 0x86, 0x9e, 0x80, 0x09,
	0x18, 0x5d, 0xdd, 0x4a, 0xd6, 0x85, 0x4d, 0xda, 0xd2, 0xa2, 0xf9, 0xec, 0x49, 0x18, 0x76, 0xf6,
	0x4c, 0x73, 0xb5, 0x0c, 0x39, 0x9a, 0x0c, 0x03, 0x99, 0xd9, 0xb3, 0xe2, 0x96, 0xf1, 0x29, 0x82,
	0x11, 0x8f, 0x16, 0xe6, 0x5e, 0x16, 0x9d, 0xd3, 0xab, 0x65, 0xcb, 0x38, 0xcc, 0xe9, 0x45, 0xf2,
	0x50, 0x8b, 0xf6, 0xa0, 0xd3, 0x58, 0x74, 0x52, 0x3c, 0x90, 0x1e, 0xbb, 0x4c, 0x74, 0xef, 0x55,
	0x3f, 0x0d, 0xd8, 0xd5, 0xc6, 0xdd, 0x71, 0xd9, 0xab, 0x10, 0x6f, 0x6e, 0x32, 0xc6, 0xe7, 0x20,
	0x2a, 0x2e, 0x56, 0x4c, 0x56, 0x7e, 0x1e, 0x37, 0x12, 0x9b, 0x2f, 0x3a, 0xef, 0xa4, 0x1c, 0x90,
	0x4a, 0x96, 0x7a, 0x95, 0x65, 0x2d, 0xfc, 0x58, 0x71, 0xf7, 0x69, 0xe3, 0x17, 0x01, 0x17, 0xd8,
	0xb8, 0xcc, 0x5a, 0xbf, 0x1d, 0x39, 0x5b, 0x7f, 0x36, 0xf6, 0xa3, 0x1a, 0x0a, 0xd4, 0xeb, 0xae,
	0x49, 0x29, 0x5e, 0xa8, 0x53, 0xe0, 0xb6, 0x9e, 0xfa, 0x15, 0x3f, 0x1c, 0xf3, 0x6c, 0xfc, 0xc6,
	0x17, 0x60, 0x40, 0x5c, 0x39, 0x19, 0xe1, 0xfb, 0xe4, 0xd2, 0x51, 0x01, 0x4b, 0x69, 0xe1, 0x2f,
	0x40, 0xe0, 0xed, 0xeb, 0xf6, 0x46, 0x3c, 0xe3, 0xbd, 0x11, 0x6b, 0xd7, 0xad, 0xbc, 0x7e, 0x95,
	0x94, 0x17, 0x1b, 0x8d, 0xe5, 0x2b, 0x3e, 0x89, 0xe2, 0xe1, 0x57, 0x21, 0xc4, 0xe5, 0x14, 0x57,
	0xdd, 0xee, 0x0f, 0x5f, 0x2f, 0x05, 0xad, 0xf8, 0x24, 0x41, 0x2e, 0x7b, 0xc2, 0xdd, 0x1e, 0xdf,
	0x6e, 0xdf, 0x7e, 0x2f, 0x00, 0x23, 0xb9, 0xa5, 0x0d, 0x1e, 0x2b, 0xf8, 0x4f, 0x5a, 0x58, 0x1e,
	0x95, 0x87, 0xfe, 0x4a, 0x75, 0x57, 0x53, 0x0b, 0xb2, 0x5a, 0x11, 0xea, 0x38, 0xe7, 0x29, 0x9a,
	0xe3, 0x3c, 0x4d, 0x3b, 0xa9, 0x6c, 0x31, 0xec, 0xd5, 0xad, 0x15, 0x9f, 0x14, 0xe1, 0x94, 0x56,
	0x2b, 0xf8, 0x0d, 0x88, 0x0a, 0xaa, 0xec, 0x04, 0x0b, 0x74, 0x38, 0x7f, 0x3b, 0xd3, 0xa5, 0xe7,
	0xdd, 0x8a, 0x4f, 0x82, 0x4a, 0xfd, 0x1b, 0x9e, 0x86, 0x60, 0x45, 0x37, 0x2c, 0xa6, 0xc7, 0x41,
	0x6e, 0x66, 0xc1, 0x19, 0xff, 0xb4, 0x8f, 0x7e, 0x08, 0xcd, 0x04, 0x13, 0x3f, 0xf9, 0x49, 0x40,
	0x62, 0x10, 0x0b, 0xbf, 0x84, 0xee, 0xd4, 0xd0, 0xd7, 0x11, 0x5c, 0x82, 0x20, 0x5d, 0xeb, 0xcc,
	0x45, 0x38, 0x0b, 0x63, 0x8e, 0xf5, 0x66, 0xfa, 0x39, 0x93, 0xe4, 0xea, 0x16, 0x4c, 0xb8, 0x24,
	0xce, 0x80, 0x98, 0x59, 0xda, 0xd8, 0xc6, 0xe1, 0x9d, 0xf2, 0xd5, 0xb2, 0x7e, 0xbd, 0x0c, 0x73,
	0x10, 0xa6, 0x12, 0xcc, 0xad, 0x6e, 0x65, 0x4e, 0xc2, 0x40, 0x9d, 0x4c, 0x5a, 0xad, 0xc0, 0xa8,
	0x03, 0x39, 0x4d, 0xcf, 0x5b, 0x56, 0xa7, 0x8e, 0x41, 0x70, 0x4b, 0x37, 0xac, 0x4c, 0x88, 0x8b,
	0x9c, 0x7d, 0xb2, 0x7e, 0x17, 0x1b, 0xb1, 0xeb, 0x50, 0x62, 0x97, 0x7e, 0xd4, 0x28, 0x5f, 0xfc,
	0x7e, 0x1f, 0x0c, 0xb7, 0xe4, 0x20, 0xf8, 0x35, 0xb7, 0x46, 0xd1, 0x43, 0x69, 0xd4, 0xa5, 0xcf,
	0xd3, 0x10, 0x2a, 0xeb, 0xb2, 0xa5, 0xd9, 0xd9, 0x7c, 0x3b, 0x6f, 0xe8, 0x2b, 0xeb, 0x79, 0xcd,
	0xc4, 0x2f, 0x43, 0xb8, 0x6a, 0x12, 0x06, 0x1f, 0xec, 0xf0, 0xd3, 0x04, 0xa7, 0x10, 0x3b, 0x15,
	0x77, 0xce, 0xcf, 0xd2, 0x7b, 0x6a, 0xc2, 0x55, 0x93, 0x50, 0x92, 0xef, 0x21, 0x88, 0x09, 0x78,
	0xfe, 0x8b, 0x28, 0xbb, 0x89, 0xe5, 0x42, 0xd7, 0x4e, 0xd2, 0x6c, 0xd7, 0x8e, 0x27, 0x12, 0xef,
	0x3c, 0x7e, 0x50, 0x77, 0x60, 0x98, 0x78, 0x01, 0xc6, 0xf6, 0x74, 0x16, 0xb6, 0x85, 0x20, 0xf5,
	0xfb, 0x52, 0x88, 0xdf, 0x84, 0x58, 0x92, 0x36, 0xca, 0x61, 0x38, 0xb3, 0xfa, 0xbd, 0x49, 0x81,
	0xb1, 0x3a, 0x12, 0xaf, 0x5d, 0x5b, 0xea, 0x01, 0xd1, 0xab, 0x96, 0xf8, 0x65, 0xd9, 0xa9, 0xef,
	0xd7, 0x50, 0xe0, 0xfc, 0x19, 0x93, 0x72, 0x8f, 0x18, 0xa1, 0x1f, 0x06, 0x02, 0xf3, 0x67, 0x0e,
	0xc4, 0x97, 0x23, 0xfa, 0xc5, 0x74, 0x14, 0x8c, 0x47, 0x75, 0x41, 0x9c, 0x51, 0xca, 0x73, 0x42,
	0xf8, 0x1d, 0x18, 0xe1, 0x59, 0x33, 0xe7, 0xe3, 0xfe, 0x6d, 0xc8, 0x62, 0x77, 0x5a, 0xe2, 0x52,
	0xdb, 0x79, 0x81, 0x2b, 0x2d, 0x90, 0x86, 0x59, 0xee, 0xcc, 0x00, 0xec, 0xd2, 0xc7, 0x93, 0xe2,
	0xba, 0xdc, 0xa8, 0x1d, 0xd0, 0x34, 0xd8, 0x4f, 0xed, 0xf5, 0xec, 0xec, 0xb3, 0x3c, 0x45, 0x48,
	0x7d, 0x13, 0xc1, 0x13, 0x1d, 0xe8, 0xe2, 0x45, 0x98, 0xb4, 0xe3, 0xed, 0xee, 0xa1, 0x45, 0x64,
	0x43, 0x29, 0x97, 0xea, 0x4f, 0xca, 0xf6, 0x55, 0x94, 0x66, 0xf0, 0xd2, 0xb8, 0x80, 0xcb, 0x1e,
	0x5a, 0x44, 0xa2, 0x50, 0x42, 0x03, 0xf8, 0x34, 0x0c, 0x5d, 0x27, 0xbb, 0xa6, 0x5e, 0xb8, 0x4a,
	0x2c, 0xfe, 0x4e, 0x60, 0x5f, 0x4e, 0x19, 0x5e, 0xac, 0x3e, 0xc9, 0xae, 0x56, 0x0b, 0xa1, 0x7b,
	0x17, 0xd9, 0x9d, 0xf8, 0xc7, 0x41, 0x88, 0xe5, 0x0c, 0xa2, 0x58, 0xa4, 0x7e, 0x65, 0x4c, 0x34,
	0x5d, 0x19, 0x1f, 0xdf, 0xe5, 0x5a, 0xef, 0x72, 0x4f, 0x79, 0xdd, 0xe5, 0xdc, 0x37, 0xb8, 0x37,
	0x1e, 0xed, 0x0d, 0xce, 0x75, 0x6f, 0x7b, 0xed, 0x51, 0xde, 0xdb, 0x9c, 0x37, 0xb6, 0x85, 0xe1,
	0x3b, 0x17, 0x9b, 0x4a, 0x08, 0xd9, 0x19, 0xaf, 0x24, 0xf8, 0xd8, 0xcf, 0xfd, 0x27, 0x6a, 0x1d,
	0xee, 0x39, 0x23, 0xfe, 0xaf, 0x20, 0x0c, 0x89, 0x52, 0xe6, 0x63, 0xfb, 0x7b, 0x6c, 0x7f, 0x9f,
	0xbb, 0xfd, 0x7d, 0x2b, 0x02, 0xd1, 0xcb, 0xc4, 0x7a, 0x6c, 0x7b, 0x8f, 0x6d, 0xef, 0x7f, 0x58,
	0x35, 0xe9, 0xff, 0x6e, 0xc1, 0xe7, 0xf3, 0x0d, 0x11, 0x6b, 0xa1, 0xc8, 0xc7, 0xe1, 0xf8, 0xbf,
	0x86, 0x53, 0x47, 0x08, 0x8e, 0xad, 0xab, 0x9a, 0x52, 0xc8, 0x2d, 0x6d, 0x5c, 0x21, 0x96, 0xa1,
	0x16, 0x4c, 0x5e, 0x26, 0xc0, 0x6b, 0x10, 0xb0, 0x94, 0x92, 0xf8, 0x71, 0x64, 0xb7, 0x4f, 0x89,
	0x6e, 0x4a, 0x79, 0xa5, 0x24, 0x51, 0x22, 0x78, 0x0c, 0x42, 0xd7, 0x14, 0xad, 0x2a, 0x9e, 0x46,
	0xfa, 0x25, 0xf1, 0x0d, 0xbf, 0xe5, 0xf8, 0x39, 0x4a, 0x80, 0x31, 0x5a, 0x7c, 0x20, 0x46, 0xf6,
	0x4f, 0x47, 0xd8, 0xe6, 0x37, 0x7e, 0x96, 0x12, 0xba, 0x53, 0x43, 0xfe, 0x38, 0x4a, 0x7d, 0x15,
	0xc1, 0x54, 0x13, 0x86, 0xdd, 0xdb, 0x79, 0xd9, 0xd0, 0xab, 0x95, 0xec, 0x21, 0x5e, 0x77, 0xfd,
	0x16, 0xf4, 0xc1, 0x97, 0xcb, 0x7f, 0x74, 0x36, 0x0a, 0x7d, 0x6c, 0x85, 0xfc, 0x31, 0x5d, 0xe2,
	0x5f, 0x52, 0x12, 0x1c, 0x6f, 0x23, 0x05, 0x6b, 0x6a, 0xa6, 0x9e, 0x5a, 0xff, 0x0f, 0x33, 0xbc,
	0xdc, 0x21, 0x35, 0x06, 0xda, 0xd0, 0xfc, 0x3e, 0x82, 0x27, 0xdb, 0x10, 0xdd, 0x26, 0x86, 0x4a,
	0x4c, 0x2c, 0x43, 0xa4, 0x44, 0x17, 0x29, 0xef, 0x1e, 0x8a, 0x7f, 0x07, 0xb1, 0xf4, 0x40, 0xab,
	0x6b, 0xd2, 0x98, 0x14, 0x2e, 0x09, 0xd5, 0xbd, 0xd6, 0x10, 0x8c, 0x52, 0xcf, 0x3e, 0x14, 0x75,
	0xa6, 0x09, 0x7b, 0x71, 0xbf, 0xe5, 0x87, 0x27, 0xda, 0xc0, 0x2d, 0x29, 0x96, 0x82, 0x5f, 0x81,
	0x20, 0x35, 0x7e, 0xb1, 0x69, 0x0f, 0xc6, 0xf8, 0x92, 0x4a, 0xb4, 0xe2, 0x36, 0xd1, 0x48, 0xc1,
	0xd2, 0x0d, 0x89, 0xd1, 0xa3, 0xc6, 0x50, 0x2d, 0xab, 0xbc, 0x7e, 0xf7, 0x80, 0xc6, 0xb0, 0x53,
	0x56, 0x2d, 0x89, 0x51, 0xc1, 0x6f, 0x42, 0xc8, 0x64, 0x5b, 0x21, 0xfe, 0x11, 0x45, 0xee, 0xa1,
	0x14, 0xc4, 0x77, 0x55, 0x12, 0x24, 0x67, 0x56, 0x60, 0xd0, 0x5d, 0x8e, 0x8b, 0x01, 0x34, 0xfa,
	0xa9, 0xe2, 0x3e, 0x1c, 0x85, 0xb0, 0x41, 0xf6, 0x88, 0x41, 0x8c, 0x38, 0xc2, 0x00, 0x21, 0xde,
	0x73, 0x15, 0xf7, 0x53, 0xc0, 0xaa, 0x49, 0x0c, 0x59, 0x29, 0x91, 0xb2, 0x15, 0x0f, 0xcc, 0x7c,
	0x1f, 0xb5, 0x98, 0xa7, 0x4b, 0x37, 0xf8, 0x18, 0x0c, 0x4b, 0xcb, 0x2f, 0xef, 0x2c, 0x6f, 0xe7,
	0xe5, 0xfc, 0x66, 0x7e, 0x71, 0x5d, 0xde, 0xde, 0xb9, 0x12, 0xf7, 0xe1, 0x31, 0xc0, 0xf6, 0xf0,
	0xa5, 0xc5, 0xd5, 0xf5, 0xe5, 0x25, 0x36, 0x8e, 0xf0, 0x08, 0x0c, 0xd9, 0xe3, 0xf3, 0xaf, 0xbd,
	0xc6, 0x06, 0xfd, 0xce, 0xc1, 0x8c, 0x18, 0x0c, 0x38, 0x07, 0xcf, 0x8a, 0xc1, 0xa0, 0x73, 0xf0,
	0x59, 0x31, 0xd8, 0xe7, 0x1c, 0x3c, 0x27, 0x06, 0x43, 0x38, 0x0e, 0x03, 0x4b, 0x8b, 0xf9, 0x45,
	0x79, 0x73, 0x27, 0xcf, 0x46, 0xc2, 0x74, 0x64, 0x7d, 0x31, 0xbf, 0xbc, 0x91, 0x7b, 0x5d, 0xbe,
	0xb2, 0xbc, 0xb8, 0x11, 0x8f, 0xcc, 0x7c, 0x03, 0x01, 0x6e, 0xf5, 0x56, 0x3c, 0xc1, 0x1e, 0xbf,
	0xe5, 0xa5, 0xd5, 0xed, 0xbc, 0xb4, 0x9a, 0xdd, 0xc9, 0xaf, 0x6e, 0x6e, 0xc8, 0x1b, 0x8b, 0x57,
	0x96, 0xe3, 0x3e, 0x8c, 0x21, 0x96, 0x5b, 0xcc, 0xad, 0x2c, 0xcb, 0x2b, 0xab, 0x79, 0x39, 0xff,
	0xfa, 0xd6, 0xb2, 0x7b, 0x49, 0xb9, 0xcd, 0x9d, 0x8d, 0xbc, 0xf4, 0x7a, 0xdc, 0x4f, 0x99, 0xd1,
	0xcc, 0x42, 0x7e, 0x65, 0x59, 0xda, 0x5e, 0xdd, 0xdc, 0x88, 0x07, 0xf0, 0x10, 0x44, 0xf3, 0xeb,
	0xdb, 0xf5, 0x81, 0x20, 0x55, 0xf5, 0xd6, 0xe6, 0x96, 0x2c, 0x2d, 0x5f, 0xa6, 0xdf, 0xfb, 0x70,
	0x18, 0x02, 0x5b, 0x9b, 0x5b, 0xf1, 0xd0, 0xcc, 0x95, 0x16, 0xfb, 0x76, 0x46, 0x32, 0x3c, 0x0a,
	0xf1, 0xcd, 0xad, 0x65, 0x69, 0x31, 0xbf, 0x29, 0x31, 0x11, 0xe4, 0xd5, 0x8d, 0xb8, 0x0f, 0x27,
	0x60, 0xd4, 0x3d, 0xba, 0xb1, 0x99, 0xa7, 0x33, 0x68, 0xe6, 0xc5, 0xe6, 0x45, 0x52, 0x2b, 0xc4,
	0xfd, 0xd0, 0xc7, 0xa4, 0x8d, 0xfb, 0xe8, 0xc7, 0xec, 0xeb, 0xf9, 0xe5, 0xed, 0x38, 0xa2, 0x62,
	0x5f, 0x59, 0x5d, 0x5f, 0x5f, 0xdd, 0x5e, 0xce, 0x6d, 0x6e, 0x2c, 0x6d, 0xc7, 0xfd, 0xd9, 0x5f,
	0x47, 0x77, 0x3f, 0x98, 0xf2, 0xbd, 0xff, 0xc1, 0x94, 0xef, 0x93, 0x0f, 0xa6, 0xd0, 0x7b, 0x47,
	0x53, 0xe8, 0x5b, 0x47, 0x53, 0xe8, 0x7b, 0x47, 0x53, 0xe8, 0xee, 0xd1, 0x14, 0x7a, 0xff, 0x68,
	0x0a, 0xfd, 0xc3, 0xd1, 0x14, 0xfa, 0xe8, 0x68, 0xca, 0xf7, 0xc9, 0xd1, 0x14, 0xfa, 0xe5, 0x0f,
	0xa7, 0x7c, 0xb7, 0x3e, 0x9c, 0x42, 0x77, 0x3f, 0x9c, 0xf2, 0xbd, 0xff, 0xe1, 0x94, 0xef, 0x8d,
	0x37, 0x4a, 0x7a, 0xe5, 0x6a, 0x29, 0x7d, 0x4d, 0xa7, 0xa7, 0x87, 0xa1, 0xa4, 0xab, 0xe6, 0x1c,
	0xfb, 0xb0, 0xa7, 0x1b, 0x07, 0xa7, 0x2b, 0x86, 0x7e, 0x4d, 0x2d, 0x12, 0xe3, 0xb4, 0x3d, 0x3d,
	0x57, 0xd9, 0x2d, 0xe9, 0x73, 0xe4, 0x5d, 0xcb, 0xfe, 0x4f, 0x54, 0x9d, 0xfe, 0x0d, 0xd4, 0x6e,
	0x88, 0xfd, 0x9b, 0xa3, 0xb3, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x94, 0x52, 0x24, 0x3b, 0x19,
	0x4c, 0x00, 0x00,
}

func (x HeaderOptions) String() string {
	s, ok := HeaderOptions_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LilacCDNMetricsFieldSelector) String() string {
	s, ok := LilacCDNMetricsFieldSelector_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LilacCDNMetricsTag) String() string {
	s, ok := LilacCDNMetricsTag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LilacCDNMetricsOperatorType) String() string {
	s, ok := LilacCDNMetricsOperatorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LilacCDNMetricUnit) String() string {
	s, ok := LilacCDNMetricUnit_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ProxyTypeHttpsAutoCerts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpRedirect != that1.HttpRedirect {
		return false
	}
	if this.AddHsts != that1.AddHsts {
		return false
	}
	if !this.TlsConfig.Equal(that1.TlsConfig) {
		return false
	}
	if that1.ServerHeaderChoice == nil {
		if this.ServerHeaderChoice != nil {
			return false
		}
	} else if this.ServerHeaderChoice == nil {
		return false
	} else if !this.ServerHeaderChoice.Equal(that1.ServerHeaderChoice) {
		return false
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts_DefaultHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts_DefaultHeader)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts_DefaultHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultHeader.Equal(that1.DefaultHeader) {
		return false
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts_ServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts_ServerName)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts_ServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts_AppendServerName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts_AppendServerName)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts_AppendServerName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppendServerName != that1.AppendServerName {
		return false
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts_PassThrough) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProxyTypeHttpsAutoCerts_PassThrough)
	if !ok {
		that2, ok := that.(ProxyTypeHttpsAutoCerts_PassThrough)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PassThrough.Equal(that1.PassThrough) {
		return false
	}
	return true
}
func (this *HeaderControlType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderControlType)
	if !ok {
		that2, ok := that.(HeaderControlType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RequestHeadersToAdd) != len(that1.RequestHeadersToAdd) {
		return false
	}
	for i := range this.RequestHeadersToAdd {
		if !this.RequestHeadersToAdd[i].Equal(that1.RequestHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.RequestHeadersToRemove) != len(that1.RequestHeadersToRemove) {
		return false
	}
	for i := range this.RequestHeadersToRemove {
		if this.RequestHeadersToRemove[i] != that1.RequestHeadersToRemove[i] {
			return false
		}
	}
	if len(this.ResponseHeadersToAdd) != len(that1.ResponseHeadersToAdd) {
		return false
	}
	for i := range this.ResponseHeadersToAdd {
		if !this.ResponseHeadersToAdd[i].Equal(that1.ResponseHeadersToAdd[i]) {
			return false
		}
	}
	if len(this.ResponseHeadersToRemove) != len(that1.ResponseHeadersToRemove) {
		return false
	}
	for i := range this.ResponseHeadersToRemove {
		if this.ResponseHeadersToRemove[i] != that1.ResponseHeadersToRemove[i] {
			return false
		}
	}
	return true
}
func (this *SecurityOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityOptionsType)
	if !ok {
		that2, ok := that.(SecurityOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpFiltering.Equal(that1.IpFiltering) {
		return false
	}
	if !this.GeoFiltering.Equal(that1.GeoFiltering) {
		return false
	}
	if !this.AuthOptions.Equal(that1.AuthOptions) {
		return false
	}
	return true
}
func (this *LoggingOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoggingOptionsType)
	if !ok {
		that2, ok := that.(LoggingOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClientLogOptions.Equal(that1.ClientLogOptions) {
		return false
	}
	if !this.OriginLogOptions.Equal(that1.OriginLogOptions) {
		return false
	}
	return true
}
func (this *CDNCacheRuleExpressionList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRuleExpressionList)
	if !ok {
		that2, ok := that.(CDNCacheRuleExpressionList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpressionName != that1.ExpressionName {
		return false
	}
	if len(this.CacheRuleExpression) != len(that1.CacheRuleExpression) {
		return false
	}
	for i := range this.CacheRuleExpression {
		if !this.CacheRuleExpression[i].Equal(that1.CacheRuleExpression[i]) {
			return false
		}
	}
	return true
}
func (this *CacheOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator)
	if !ok {
		that2, ok := that.(CacheOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CacheOperator == nil {
		if this.CacheOperator != nil {
			return false
		}
	} else if this.CacheOperator == nil {
		return false
	} else if !this.CacheOperator.Equal(that1.CacheOperator) {
		return false
	}
	return true
}
func (this *CacheOperator_Equals) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_Equals)
	if !ok {
		that2, ok := that.(CacheOperator_Equals)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Equals != that1.Equals {
		return false
	}
	return true
}
func (this *CacheOperator_DoesNotEqual) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_DoesNotEqual)
	if !ok {
		that2, ok := that.(CacheOperator_DoesNotEqual)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoesNotEqual != that1.DoesNotEqual {
		return false
	}
	return true
}
func (this *CacheOperator_Contains) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_Contains)
	if !ok {
		that2, ok := that.(CacheOperator_Contains)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Contains != that1.Contains {
		return false
	}
	return true
}
func (this *CacheOperator_DoesNotContain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_DoesNotContain)
	if !ok {
		that2, ok := that.(CacheOperator_DoesNotContain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoesNotContain != that1.DoesNotContain {
		return false
	}
	return true
}
func (this *CacheOperator_Startswith) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_Startswith)
	if !ok {
		that2, ok := that.(CacheOperator_Startswith)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Startswith != that1.Startswith {
		return false
	}
	return true
}
func (this *CacheOperator_DoesNotStartWith) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_DoesNotStartWith)
	if !ok {
		that2, ok := that.(CacheOperator_DoesNotStartWith)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoesNotStartWith != that1.DoesNotStartWith {
		return false
	}
	return true
}
func (this *CacheOperator_Endswith) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_Endswith)
	if !ok {
		that2, ok := that.(CacheOperator_Endswith)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Endswith != that1.Endswith {
		return false
	}
	return true
}
func (this *CacheOperator_DoesNotEndWith) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_DoesNotEndWith)
	if !ok {
		that2, ok := that.(CacheOperator_DoesNotEndWith)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoesNotEndWith != that1.DoesNotEndWith {
		return false
	}
	return true
}
func (this *CacheOperator_MatchRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_MatchRegex)
	if !ok {
		that2, ok := that.(CacheOperator_MatchRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MatchRegex != that1.MatchRegex {
		return false
	}
	return true
}
func (this *CacheHeaderMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheHeaderMatcherType)
	if !ok {
		that2, ok := that.(CacheHeaderMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Operator.Equal(that1.Operator) {
		return false
	}
	return true
}
func (this *CDNPathMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNPathMatcherType)
	if !ok {
		that2, ok := that.(CDNPathMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Operator.Equal(that1.Operator) {
		return false
	}
	return true
}
func (this *CacheCookieMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheCookieMatcherType)
	if !ok {
		that2, ok := that.(CacheCookieMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Operator.Equal(that1.Operator) {
		return false
	}
	return true
}
func (this *CacheQueryParameterMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheQueryParameterMatcherType)
	if !ok {
		that2, ok := that.(CacheQueryParameterMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if !this.Operator.Equal(that1.Operator) {
		return false
	}
	return true
}
func (this *CDNCacheRuleExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRuleExpression)
	if !ok {
		that2, ok := that.(CDNCacheRuleExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PathMatch.Equal(that1.PathMatch) {
		return false
	}
	if len(this.QueryParameters) != len(that1.QueryParameters) {
		return false
	}
	for i := range this.QueryParameters {
		if !this.QueryParameters[i].Equal(that1.QueryParameters[i]) {
			return false
		}
	}
	if len(this.CacheHeaders) != len(that1.CacheHeaders) {
		return false
	}
	for i := range this.CacheHeaders {
		if !this.CacheHeaders[i].Equal(that1.CacheHeaders[i]) {
			return false
		}
	}
	if len(this.CookieMatcher) != len(that1.CookieMatcher) {
		return false
	}
	for i := range this.CookieMatcher {
		if !this.CookieMatcher[i].Equal(that1.CookieMatcher[i]) {
			return false
		}
	}
	return true
}
func (this *CacheTTLEnableProps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLEnableProps)
	if !ok {
		that2, ok := that.(CacheTTLEnableProps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheTtl != that1.CacheTtl {
		return false
	}
	if this.IgnoreResponseCookie != that1.IgnoreResponseCookie {
		return false
	}
	if this.CacheOverride != that1.CacheOverride {
		return false
	}
	return true
}
func (this *CacheEligibleOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions)
	if !ok {
		that2, ok := that.(CacheEligibleOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.EligibleForCache == nil {
		if this.EligibleForCache != nil {
			return false
		}
	} else if this.EligibleForCache == nil {
		return false
	} else if !this.EligibleForCache.Equal(that1.EligibleForCache) {
		return false
	}
	return true
}
func (this *CacheEligibleOptions_SchemeHostnameUri) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions_SchemeHostnameUri)
	if !ok {
		that2, ok := that.(CacheEligibleOptions_SchemeHostnameUri)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemeHostnameUri.Equal(that1.SchemeHostnameUri) {
		return false
	}
	return true
}
func (this *CacheEligibleOptions_SchemeHostnameRequestUri) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions_SchemeHostnameRequestUri)
	if !ok {
		that2, ok := that.(CacheEligibleOptions_SchemeHostnameRequestUri)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemeHostnameRequestUri.Equal(that1.SchemeHostnameRequestUri) {
		return false
	}
	return true
}
func (this *CacheEligibleOptions_HostnameUri) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions_HostnameUri)
	if !ok {
		that2, ok := that.(CacheEligibleOptions_HostnameUri)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HostnameUri.Equal(that1.HostnameUri) {
		return false
	}
	return true
}
func (this *CacheEligibleOptions_SchemeHostnameUriQuery) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions_SchemeHostnameUriQuery)
	if !ok {
		that2, ok := that.(CacheEligibleOptions_SchemeHostnameUriQuery)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemeHostnameUriQuery.Equal(that1.SchemeHostnameUriQuery) {
		return false
	}
	return true
}
func (this *CacheEligibleOptions_SchemeProxyHostUri) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions_SchemeProxyHostUri)
	if !ok {
		that2, ok := that.(CacheEligibleOptions_SchemeProxyHostUri)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemeProxyHostUri.Equal(that1.SchemeProxyHostUri) {
		return false
	}
	return true
}
func (this *CacheEligibleOptions_SchemeProxyHostRequestUri) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions_SchemeProxyHostRequestUri)
	if !ok {
		that2, ok := that.(CacheEligibleOptions_SchemeProxyHostRequestUri)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemeProxyHostRequestUri.Equal(that1.SchemeProxyHostRequestUri) {
		return false
	}
	return true
}
func (this *CDNCacheRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRule)
	if !ok {
		that2, ok := that.(CDNCacheRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RuleName != that1.RuleName {
		return false
	}
	if len(this.RuleExpressionList) != len(that1.RuleExpressionList) {
		return false
	}
	for i := range this.RuleExpressionList {
		if !this.RuleExpressionList[i].Equal(that1.RuleExpressionList[i]) {
			return false
		}
	}
	if that1.CacheActions == nil {
		if this.CacheActions != nil {
			return false
		}
	} else if this.CacheActions == nil {
		return false
	} else if !this.CacheActions.Equal(that1.CacheActions) {
		return false
	}
	return true
}
func (this *CDNCacheRule_CacheBypass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRule_CacheBypass)
	if !ok {
		that2, ok := that.(CDNCacheRule_CacheBypass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CacheBypass.Equal(that1.CacheBypass) {
		return false
	}
	return true
}
func (this *CDNCacheRule_EligibleForCache) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRule_EligibleForCache)
	if !ok {
		that2, ok := that.(CDNCacheRule_EligibleForCache)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EligibleForCache.Equal(that1.EligibleForCache) {
		return false
	}
	return true
}
func (this *DefaultCacheTTLProps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultCacheTTLProps)
	if !ok {
		that2, ok := that.(DefaultCacheTTLProps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheTtl != that1.CacheTtl {
		return false
	}
	return true
}
func (this *DefaultCacheAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultCacheAction)
	if !ok {
		that2, ok := that.(DefaultCacheAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CacheActions == nil {
		if this.CacheActions != nil {
			return false
		}
	} else if this.CacheActions == nil {
		return false
	} else if !this.CacheActions.Equal(that1.CacheActions) {
		return false
	}
	return true
}
func (this *DefaultCacheAction_EligibleForCache) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultCacheAction_EligibleForCache)
	if !ok {
		that2, ok := that.(DefaultCacheAction_EligibleForCache)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EligibleForCache.Equal(that1.EligibleForCache) {
		return false
	}
	return true
}
func (this *DefaultCacheAction_CacheTtlDefault) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultCacheAction_CacheTtlDefault)
	if !ok {
		that2, ok := that.(DefaultCacheAction_CacheTtlDefault)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheTtlDefault != that1.CacheTtlDefault {
		return false
	}
	return true
}
func (this *DefaultCacheAction_CacheTtlOverride) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultCacheAction_CacheTtlOverride)
	if !ok {
		that2, ok := that.(DefaultCacheAction_CacheTtlOverride)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheTtlOverride != that1.CacheTtlOverride {
		return false
	}
	return true
}
func (this *DefaultCacheAction_CacheDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultCacheAction_CacheDisabled)
	if !ok {
		that2, ok := that.(DefaultCacheAction_CacheDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CacheDisabled.Equal(that1.CacheDisabled) {
		return false
	}
	return true
}
func (this *CacheOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOptions)
	if !ok {
		that2, ok := that.(CacheOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultCacheAction.Equal(that1.DefaultCacheAction) {
		return false
	}
	if len(this.CacheRules) != len(that1.CacheRules) {
		return false
	}
	for i := range this.CacheRules {
		if !this.CacheRules[i].Equal(that1.CacheRules[i]) {
			return false
		}
	}
	return true
}
func (this *CacheTTLOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLOptionsType)
	if !ok {
		that2, ok := that.(CacheTTLOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.TtlOptions == nil {
		if this.TtlOptions != nil {
			return false
		}
	} else if this.TtlOptions == nil {
		return false
	} else if !this.TtlOptions.Equal(that1.TtlOptions) {
		return false
	}
	return true
}
func (this *CacheTTLOptionsType_CacheTtlDefault) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLOptionsType_CacheTtlDefault)
	if !ok {
		that2, ok := that.(CacheTTLOptionsType_CacheTtlDefault)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheTtlDefault != that1.CacheTtlDefault {
		return false
	}
	return true
}
func (this *CacheTTLOptionsType_CacheTtlOverride) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLOptionsType_CacheTtlOverride)
	if !ok {
		that2, ok := that.(CacheTTLOptionsType_CacheTtlOverride)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheTtlOverride != that1.CacheTtlOverride {
		return false
	}
	return true
}
func (this *CacheTTLOptionsType_CacheDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLOptionsType_CacheDisabled)
	if !ok {
		that2, ok := that.(CacheTTLOptionsType_CacheDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CacheDisabled.Equal(that1.CacheDisabled) {
		return false
	}
	return true
}
func (this *AdvancedOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdvancedOptionsType)
	if !ok {
		that2, ok := that.(AdvancedOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HeaderOptions.Equal(that1.HeaderOptions) {
		return false
	}
	if !this.SecurityOptions.Equal(that1.SecurityOptions) {
		return false
	}
	if !this.LoggingOptions.Equal(that1.LoggingOptions) {
		return false
	}
	if !this.CacheTtlOptions.Equal(that1.CacheTtlOptions) {
		return false
	}
	if !this.CacheOptions.Equal(that1.CacheOptions) {
		return false
	}
	return true
}
func (this *CDNTLSConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNTLSConfig)
	if !ok {
		that2, ok := that.(CDNTLSConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *CDNTLSConfig_Tls_12Plus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNTLSConfig_Tls_12Plus)
	if !ok {
		that2, ok := that.(CDNTLSConfig_Tls_12Plus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tls_12Plus.Equal(that1.Tls_12Plus) {
		return false
	}
	return true
}
func (this *CDNTLSConfig_Tls_11Plus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNTLSConfig_Tls_11Plus)
	if !ok {
		that2, ok := that.(CDNTLSConfig_Tls_11Plus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tls_11Plus.Equal(that1.Tls_11Plus) {
		return false
	}
	return true
}
func (this *CDNHTTPSAutoCertsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNHTTPSAutoCertsType)
	if !ok {
		that2, ok := that.(CDNHTTPSAutoCertsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpRedirect != that1.HttpRedirect {
		return false
	}
	if this.AddHsts != that1.AddHsts {
		return false
	}
	if !this.TlsConfig.Equal(that1.TlsConfig) {
		return false
	}
	return true
}
func (this *CDNDownstreamTlsParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNDownstreamTlsParamsType)
	if !ok {
		that2, ok := that.(CDNDownstreamTlsParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TlsConfig.Equal(that1.TlsConfig) {
		return false
	}
	if len(this.TlsCertificates) != len(that1.TlsCertificates) {
		return false
	}
	for i := range this.TlsCertificates {
		if !this.TlsCertificates[i].Equal(that1.TlsCertificates[i]) {
			return false
		}
	}
	return true
}
func (this *CDNHTTPSCustomCertsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNHTTPSCustomCertsType)
	if !ok {
		that2, ok := that.(CDNHTTPSCustomCertsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpRedirect != that1.HttpRedirect {
		return false
	}
	if this.AddHsts != that1.AddHsts {
		return false
	}
	if !this.TlsParameters.Equal(that1.TlsParameters) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if that1.LoadbalancerType == nil {
		if this.LoadbalancerType != nil {
			return false
		}
	} else if this.LoadbalancerType == nil {
		return false
	} else if !this.LoadbalancerType.Equal(that1.LoadbalancerType) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.MoreOption.Equal(that1.MoreOption) {
		return false
	}
	if !this.OriginPool.Equal(that1.OriginPool) {
		return false
	}
	if !this.ViewInternal.Equal(that1.ViewInternal) {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if len(this.DnsInfo) != len(that1.DnsInfo) {
		return false
	}
	for i := range this.DnsInfo {
		if !this.DnsInfo[i].Equal(that1.DnsInfo[i]) {
			return false
		}
	}
	if this.State != that1.State {
		return false
	}
	if this.AutoCertState != that1.AutoCertState {
		return false
	}
	if !this.AutoCertInfo.Equal(that1.AutoCertInfo) {
		return false
	}
	if len(this.ServiceDomains) != len(that1.ServiceDomains) {
		return false
	}
	for i := range this.ServiceDomains {
		if !this.ServiceDomains[i].Equal(that1.ServiceDomains[i]) {
			return false
		}
	}
	if this.CertState != that1.CertState {
		return false
	}
	return true
}
func (this *GlobalSpecType_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Http)
	if !ok {
		that2, ok := that.(GlobalSpecType_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *GlobalSpecType_HttpsAutoCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_HttpsAutoCert)
	if !ok {
		that2, ok := that.(GlobalSpecType_HttpsAutoCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpsAutoCert.Equal(that1.HttpsAutoCert) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Https) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Https)
	if !ok {
		that2, ok := that.(GlobalSpecType_Https)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Https.Equal(that1.Https) {
		return false
	}
	return true
}
func (this *IpFilteringOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpFilteringOptions)
	if !ok {
		that2, ok := that.(IpFilteringOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.IpFilteringType == nil {
		if this.IpFilteringType != nil {
			return false
		}
	} else if this.IpFilteringType == nil {
		return false
	} else if !this.IpFilteringType.Equal(that1.IpFilteringType) {
		return false
	}
	return true
}
func (this *IpFilteringOptions_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpFilteringOptions_AllowList)
	if !ok {
		that2, ok := that.(IpFilteringOptions_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *IpFilteringOptions_BlockList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpFilteringOptions_BlockList)
	if !ok {
		that2, ok := that.(IpFilteringOptions_BlockList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlockList.Equal(that1.BlockList) {
		return false
	}
	return true
}
func (this *GeoFilteringOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoFilteringOptions)
	if !ok {
		that2, ok := that.(GeoFilteringOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.GeoFilteringType == nil {
		if this.GeoFilteringType != nil {
			return false
		}
	} else if this.GeoFilteringType == nil {
		return false
	} else if !this.GeoFilteringType.Equal(that1.GeoFilteringType) {
		return false
	}
	return true
}
func (this *GeoFilteringOptions_AllowList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoFilteringOptions_AllowList)
	if !ok {
		that2, ok := that.(GeoFilteringOptions_AllowList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowList.Equal(that1.AllowList) {
		return false
	}
	return true
}
func (this *GeoFilteringOptions_BlockList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoFilteringOptions_BlockList)
	if !ok {
		that2, ok := that.(GeoFilteringOptions_BlockList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlockList.Equal(that1.BlockList) {
		return false
	}
	return true
}
func (this *LogHeaderOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogHeaderOptions)
	if !ok {
		that2, ok := that.(LogHeaderOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.HeaderList) != len(that1.HeaderList) {
		return false
	}
	for i := range this.HeaderList {
		if this.HeaderList[i] != that1.HeaderList[i] {
			return false
		}
	}
	return true
}
func (this *CDNCustomAuthentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCustomAuthentication)
	if !ok {
		that2, ok := that.(CDNCustomAuthentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomAuthConfig != that1.CustomAuthConfig {
		return false
	}
	return true
}
func (this *AuthenticationOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationOptions)
	if !ok {
		that2, ok := that.(AuthenticationOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthOptions == nil {
		if this.AuthOptions != nil {
			return false
		}
	} else if this.AuthOptions == nil {
		return false
	} else if !this.AuthOptions.Equal(that1.AuthOptions) {
		return false
	}
	return true
}
func (this *AuthenticationOptions_DisableAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationOptions_DisableAuth)
	if !ok {
		that2, ok := that.(AuthenticationOptions_DisableAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableAuth.Equal(that1.DisableAuth) {
		return false
	}
	return true
}
func (this *AuthenticationOptions_Jwt) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationOptions_Jwt)
	if !ok {
		that2, ok := that.(AuthenticationOptions_Jwt)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Jwt.Equal(that1.Jwt) {
		return false
	}
	return true
}
func (this *AuthenticationOptions_Custom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthenticationOptions_Custom)
	if !ok {
		that2, ok := that.(AuthenticationOptions_Custom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Custom.Equal(that1.Custom) {
		return false
	}
	return true
}
func (this *CDNOriginServerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNOriginServerType)
	if !ok {
		that2, ok := that.(CDNOriginServerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *CDNOriginServerType_PublicIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNOriginServerType_PublicIp)
	if !ok {
		that2, ok := that.(CDNOriginServerType_PublicIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PublicIp.Equal(that1.PublicIp) {
		return false
	}
	return true
}
func (this *CDNOriginServerType_PublicName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNOriginServerType_PublicName)
	if !ok {
		that2, ok := that.(CDNOriginServerType_PublicName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PublicName.Equal(that1.PublicName) {
		return false
	}
	return true
}
func (this *CdnOriginPoolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CdnOriginPoolType)
	if !ok {
		that2, ok := that.(CdnOriginPoolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PublicName.Equal(that1.PublicName) {
		return false
	}
	if that1.TlsChoice == nil {
		if this.TlsChoice != nil {
			return false
		}
	} else if this.TlsChoice == nil {
		return false
	} else if !this.TlsChoice.Equal(that1.TlsChoice) {
		return false
	}
	if len(this.OriginServers) != len(that1.OriginServers) {
		return false
	}
	for i := range this.OriginServers {
		if !this.OriginServers[i].Equal(that1.OriginServers[i]) {
			return false
		}
	}
	if this.FollowOriginRedirect != that1.FollowOriginRedirect {
		return false
	}
	if this.OriginRequestTimeout != that1.OriginRequestTimeout {
		return false
	}
	if !this.MoreOriginOptions.Equal(that1.MoreOriginOptions) {
		return false
	}
	return true
}
func (this *CdnOriginPoolType_NoTls) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CdnOriginPoolType_NoTls)
	if !ok {
		that2, ok := that.(CdnOriginPoolType_NoTls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoTls.Equal(that1.NoTls) {
		return false
	}
	return true
}
func (this *CdnOriginPoolType_UseTls) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CdnOriginPoolType_UseTls)
	if !ok {
		that2, ok := that.(CdnOriginPoolType_UseTls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseTls.Equal(that1.UseTls) {
		return false
	}
	return true
}
func (this *OriginAdvancedConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OriginAdvancedConfiguration)
	if !ok {
		that2, ok := that.(OriginAdvancedConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DisableByteRangeRequest != that1.DisableByteRangeRequest {
		return false
	}
	if this.WebsocketProxy != that1.WebsocketProxy {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if that1.LoadbalancerType == nil {
		if this.LoadbalancerType != nil {
			return false
		}
	} else if this.LoadbalancerType == nil {
		return false
	} else if !this.LoadbalancerType.Equal(that1.LoadbalancerType) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.MoreOption.Equal(that1.MoreOption) {
		return false
	}
	if !this.OriginPool.Equal(that1.OriginPool) {
		return false
	}
	return true
}
func (this *CreateSpecType_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Http)
	if !ok {
		that2, ok := that.(CreateSpecType_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *CreateSpecType_HttpsAutoCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_HttpsAutoCert)
	if !ok {
		that2, ok := that.(CreateSpecType_HttpsAutoCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpsAutoCert.Equal(that1.HttpsAutoCert) {
		return false
	}
	return true
}
func (this *CreateSpecType_Https) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Https)
	if !ok {
		that2, ok := that.(CreateSpecType_Https)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Https.Equal(that1.Https) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if that1.LoadbalancerType == nil {
		if this.LoadbalancerType != nil {
			return false
		}
	} else if this.LoadbalancerType == nil {
		return false
	} else if !this.LoadbalancerType.Equal(that1.LoadbalancerType) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.MoreOption.Equal(that1.MoreOption) {
		return false
	}
	if !this.OriginPool.Equal(that1.OriginPool) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Http)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_HttpsAutoCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_HttpsAutoCert)
	if !ok {
		that2, ok := that.(ReplaceSpecType_HttpsAutoCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpsAutoCert.Equal(that1.HttpsAutoCert) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Https) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Https)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Https)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Https.Equal(that1.Https) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if that1.LoadbalancerType == nil {
		if this.LoadbalancerType != nil {
			return false
		}
	} else if this.LoadbalancerType == nil {
		return false
	} else if !this.LoadbalancerType.Equal(that1.LoadbalancerType) {
		return false
	}
	if this.AddLocation != that1.AddLocation {
		return false
	}
	if !this.MoreOption.Equal(that1.MoreOption) {
		return false
	}
	if !this.OriginPool.Equal(that1.OriginPool) {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if len(this.DnsInfo) != len(that1.DnsInfo) {
		return false
	}
	for i := range this.DnsInfo {
		if !this.DnsInfo[i].Equal(that1.DnsInfo[i]) {
			return false
		}
	}
	if this.State != that1.State {
		return false
	}
	if !this.AutoCertInfo.Equal(that1.AutoCertInfo) {
		return false
	}
	if len(this.ServiceDomains) != len(that1.ServiceDomains) {
		return false
	}
	for i := range this.ServiceDomains {
		if !this.ServiceDomains[i].Equal(that1.ServiceDomains[i]) {
			return false
		}
	}
	if this.CertState != that1.CertState {
		return false
	}
	return true
}
func (this *GetSpecType_Http) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Http)
	if !ok {
		that2, ok := that.(GetSpecType_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Http.Equal(that1.Http) {
		return false
	}
	return true
}
func (this *GetSpecType_HttpsAutoCert) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_HttpsAutoCert)
	if !ok {
		that2, ok := that.(GetSpecType_HttpsAutoCert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpsAutoCert.Equal(that1.HttpsAutoCert) {
		return false
	}
	return true
}
func (this *GetSpecType_Https) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Https)
	if !ok {
		that2, ok := that.(GetSpecType_Https)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Https.Equal(that1.Https) {
		return false
	}
	return true
}
func (this *LilacCDNMetricsFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsFilter)
	if !ok {
		that2, ok := that.(LilacCDNMetricsFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tag != that1.Tag {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	if this.Operator != that1.Operator {
		return false
	}
	return true
}
func (this *LilacCDNMetricsResponseGroupBy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsResponseGroupBy)
	if !ok {
		that2, ok := that.(LilacCDNMetricsResponseGroupBy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *LilacCDNMetricsResponseValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsResponseValue)
	if !ok {
		that2, ok := that.(LilacCDNMetricsResponseValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *LilacCDNMetricsResponseSeries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsResponseSeries)
	if !ok {
		that2, ok := that.(LilacCDNMetricsResponseSeries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.GroupBy) != len(that1.GroupBy) {
		return false
	}
	for i := range this.GroupBy {
		if !this.GroupBy[i].Equal(that1.GroupBy[i]) {
			return false
		}
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if !this.Value[i].Equal(that1.Value[i]) {
			return false
		}
	}
	return true
}
func (this *LilacCDNMetricsResponseData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNMetricsResponseData)
	if !ok {
		that2, ok := that.(LilacCDNMetricsResponseData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	if len(this.Series) != len(that1.Series) {
		return false
	}
	for i := range this.Series {
		if !this.Series[i].Equal(that1.Series[i]) {
			return false
		}
	}
	return true
}
func (this *ProxyTypeHttpsAutoCerts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cdn_loadbalancer.ProxyTypeHttpsAutoCerts{")
	s = append(s, "HttpRedirect: "+fmt.Sprintf("%#v", this.HttpRedirect)+",\n")
	s = append(s, "AddHsts: "+fmt.Sprintf("%#v", this.AddHsts)+",\n")
	if this.TlsConfig != nil {
		s = append(s, "TlsConfig: "+fmt.Sprintf("%#v", this.TlsConfig)+",\n")
	}
	if this.ServerHeaderChoice != nil {
		s = append(s, "ServerHeaderChoice: "+fmt.Sprintf("%#v", this.ServerHeaderChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProxyTypeHttpsAutoCerts_DefaultHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ProxyTypeHttpsAutoCerts_DefaultHeader{` +
		`DefaultHeader:` + fmt.Sprintf("%#v", this.DefaultHeader) + `}`}, ", ")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_ServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ProxyTypeHttpsAutoCerts_ServerName{` +
		`ServerName:` + fmt.Sprintf("%#v", this.ServerName) + `}`}, ", ")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_AppendServerName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ProxyTypeHttpsAutoCerts_AppendServerName{` +
		`AppendServerName:` + fmt.Sprintf("%#v", this.AppendServerName) + `}`}, ", ")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_PassThrough) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ProxyTypeHttpsAutoCerts_PassThrough{` +
		`PassThrough:` + fmt.Sprintf("%#v", this.PassThrough) + `}`}, ", ")
	return s
}
func (this *HeaderControlType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_loadbalancer.HeaderControlType{")
	if this.RequestHeadersToAdd != nil {
		s = append(s, "RequestHeadersToAdd: "+fmt.Sprintf("%#v", this.RequestHeadersToAdd)+",\n")
	}
	s = append(s, "RequestHeadersToRemove: "+fmt.Sprintf("%#v", this.RequestHeadersToRemove)+",\n")
	if this.ResponseHeadersToAdd != nil {
		s = append(s, "ResponseHeadersToAdd: "+fmt.Sprintf("%#v", this.ResponseHeadersToAdd)+",\n")
	}
	s = append(s, "ResponseHeadersToRemove: "+fmt.Sprintf("%#v", this.ResponseHeadersToRemove)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.SecurityOptionsType{")
	if this.IpFiltering != nil {
		s = append(s, "IpFiltering: "+fmt.Sprintf("%#v", this.IpFiltering)+",\n")
	}
	if this.GeoFiltering != nil {
		s = append(s, "GeoFiltering: "+fmt.Sprintf("%#v", this.GeoFiltering)+",\n")
	}
	if this.AuthOptions != nil {
		s = append(s, "AuthOptions: "+fmt.Sprintf("%#v", this.AuthOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoggingOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.LoggingOptionsType{")
	if this.ClientLogOptions != nil {
		s = append(s, "ClientLogOptions: "+fmt.Sprintf("%#v", this.ClientLogOptions)+",\n")
	}
	if this.OriginLogOptions != nil {
		s = append(s, "OriginLogOptions: "+fmt.Sprintf("%#v", this.OriginLogOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNCacheRuleExpressionList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CDNCacheRuleExpressionList{")
	s = append(s, "ExpressionName: "+fmt.Sprintf("%#v", this.ExpressionName)+",\n")
	if this.CacheRuleExpression != nil {
		s = append(s, "CacheRuleExpression: "+fmt.Sprintf("%#v", this.CacheRuleExpression)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&cdn_loadbalancer.CacheOperator{")
	if this.CacheOperator != nil {
		s = append(s, "CacheOperator: "+fmt.Sprintf("%#v", this.CacheOperator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheOperator_Equals) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheOperator_Equals{` +
		`Equals:` + fmt.Sprintf("%#v", this.Equals) + `}`}, ", ")
	return s
}
func (this *CacheOperator_DoesNotEqual) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheOperator_DoesNotEqual{` +
		`DoesNotEqual:` + fmt.Sprintf("%#v", this.DoesNotEqual) + `}`}, ", ")
	return s
}
func (this *CacheOperator_Contains) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheOperator_Contains{` +
		`Contains:` + fmt.Sprintf("%#v", this.Contains) + `}`}, ", ")
	return s
}
func (this *CacheOperator_DoesNotContain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheOperator_DoesNotContain{` +
		`DoesNotContain:` + fmt.Sprintf("%#v", this.DoesNotContain) + `}`}, ", ")
	return s
}
func (this *CacheOperator_Startswith) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheOperator_Startswith{` +
		`Startswith:` + fmt.Sprintf("%#v", this.Startswith) + `}`}, ", ")
	return s
}
func (this *CacheOperator_DoesNotStartWith) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheOperator_DoesNotStartWith{` +
		`DoesNotStartWith:` + fmt.Sprintf("%#v", this.DoesNotStartWith) + `}`}, ", ")
	return s
}
func (this *CacheOperator_Endswith) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheOperator_Endswith{` +
		`Endswith:` + fmt.Sprintf("%#v", this.Endswith) + `}`}, ", ")
	return s
}
func (this *CacheOperator_DoesNotEndWith) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheOperator_DoesNotEndWith{` +
		`DoesNotEndWith:` + fmt.Sprintf("%#v", this.DoesNotEndWith) + `}`}, ", ")
	return s
}
func (this *CacheOperator_MatchRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheOperator_MatchRegex{` +
		`MatchRegex:` + fmt.Sprintf("%#v", this.MatchRegex) + `}`}, ", ")
	return s
}
func (this *CacheHeaderMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CacheHeaderMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Operator != nil {
		s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNPathMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_loadbalancer.CDNPathMatcherType{")
	if this.Operator != nil {
		s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheCookieMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CacheCookieMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Operator != nil {
		s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheQueryParameterMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CacheQueryParameterMatcherType{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Operator != nil {
		s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNCacheRuleExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_loadbalancer.CDNCacheRuleExpression{")
	if this.PathMatch != nil {
		s = append(s, "PathMatch: "+fmt.Sprintf("%#v", this.PathMatch)+",\n")
	}
	if this.QueryParameters != nil {
		s = append(s, "QueryParameters: "+fmt.Sprintf("%#v", this.QueryParameters)+",\n")
	}
	if this.CacheHeaders != nil {
		s = append(s, "CacheHeaders: "+fmt.Sprintf("%#v", this.CacheHeaders)+",\n")
	}
	if this.CookieMatcher != nil {
		s = append(s, "CookieMatcher: "+fmt.Sprintf("%#v", this.CookieMatcher)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheTTLEnableProps) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CacheTTLEnableProps{")
	s = append(s, "CacheTtl: "+fmt.Sprintf("%#v", this.CacheTtl)+",\n")
	s = append(s, "IgnoreResponseCookie: "+fmt.Sprintf("%#v", this.IgnoreResponseCookie)+",\n")
	s = append(s, "CacheOverride: "+fmt.Sprintf("%#v", this.CacheOverride)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheEligibleOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cdn_loadbalancer.CacheEligibleOptions{")
	if this.EligibleForCache != nil {
		s = append(s, "EligibleForCache: "+fmt.Sprintf("%#v", this.EligibleForCache)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheEligibleOptions_SchemeHostnameUri) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheEligibleOptions_SchemeHostnameUri{` +
		`SchemeHostnameUri:` + fmt.Sprintf("%#v", this.SchemeHostnameUri) + `}`}, ", ")
	return s
}
func (this *CacheEligibleOptions_SchemeHostnameRequestUri) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheEligibleOptions_SchemeHostnameRequestUri{` +
		`SchemeHostnameRequestUri:` + fmt.Sprintf("%#v", this.SchemeHostnameRequestUri) + `}`}, ", ")
	return s
}
func (this *CacheEligibleOptions_HostnameUri) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheEligibleOptions_HostnameUri{` +
		`HostnameUri:` + fmt.Sprintf("%#v", this.HostnameUri) + `}`}, ", ")
	return s
}
func (this *CacheEligibleOptions_SchemeHostnameUriQuery) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheEligibleOptions_SchemeHostnameUriQuery{` +
		`SchemeHostnameUriQuery:` + fmt.Sprintf("%#v", this.SchemeHostnameUriQuery) + `}`}, ", ")
	return s
}
func (this *CacheEligibleOptions_SchemeProxyHostUri) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheEligibleOptions_SchemeProxyHostUri{` +
		`SchemeProxyHostUri:` + fmt.Sprintf("%#v", this.SchemeProxyHostUri) + `}`}, ", ")
	return s
}
func (this *CacheEligibleOptions_SchemeProxyHostRequestUri) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheEligibleOptions_SchemeProxyHostRequestUri{` +
		`SchemeProxyHostRequestUri:` + fmt.Sprintf("%#v", this.SchemeProxyHostRequestUri) + `}`}, ", ")
	return s
}
func (this *CDNCacheRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_loadbalancer.CDNCacheRule{")
	s = append(s, "RuleName: "+fmt.Sprintf("%#v", this.RuleName)+",\n")
	if this.RuleExpressionList != nil {
		s = append(s, "RuleExpressionList: "+fmt.Sprintf("%#v", this.RuleExpressionList)+",\n")
	}
	if this.CacheActions != nil {
		s = append(s, "CacheActions: "+fmt.Sprintf("%#v", this.CacheActions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNCacheRule_CacheBypass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNCacheRule_CacheBypass{` +
		`CacheBypass:` + fmt.Sprintf("%#v", this.CacheBypass) + `}`}, ", ")
	return s
}
func (this *CDNCacheRule_EligibleForCache) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNCacheRule_EligibleForCache{` +
		`EligibleForCache:` + fmt.Sprintf("%#v", this.EligibleForCache) + `}`}, ", ")
	return s
}
func (this *DefaultCacheTTLProps) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_loadbalancer.DefaultCacheTTLProps{")
	s = append(s, "CacheTtl: "+fmt.Sprintf("%#v", this.CacheTtl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DefaultCacheAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_loadbalancer.DefaultCacheAction{")
	if this.CacheActions != nil {
		s = append(s, "CacheActions: "+fmt.Sprintf("%#v", this.CacheActions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DefaultCacheAction_EligibleForCache) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.DefaultCacheAction_EligibleForCache{` +
		`EligibleForCache:` + fmt.Sprintf("%#v", this.EligibleForCache) + `}`}, ", ")
	return s
}
func (this *DefaultCacheAction_CacheTtlDefault) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.DefaultCacheAction_CacheTtlDefault{` +
		`CacheTtlDefault:` + fmt.Sprintf("%#v", this.CacheTtlDefault) + `}`}, ", ")
	return s
}
func (this *DefaultCacheAction_CacheTtlOverride) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.DefaultCacheAction_CacheTtlOverride{` +
		`CacheTtlOverride:` + fmt.Sprintf("%#v", this.CacheTtlOverride) + `}`}, ", ")
	return s
}
func (this *DefaultCacheAction_CacheDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.DefaultCacheAction_CacheDisabled{` +
		`CacheDisabled:` + fmt.Sprintf("%#v", this.CacheDisabled) + `}`}, ", ")
	return s
}
func (this *CacheOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CacheOptions{")
	if this.DefaultCacheAction != nil {
		s = append(s, "DefaultCacheAction: "+fmt.Sprintf("%#v", this.DefaultCacheAction)+",\n")
	}
	if this.CacheRules != nil {
		s = append(s, "CacheRules: "+fmt.Sprintf("%#v", this.CacheRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheTTLOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CacheTTLOptionsType{")
	if this.TtlOptions != nil {
		s = append(s, "TtlOptions: "+fmt.Sprintf("%#v", this.TtlOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheTTLOptionsType_CacheTtlDefault) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheTTLOptionsType_CacheTtlDefault{` +
		`CacheTtlDefault:` + fmt.Sprintf("%#v", this.CacheTtlDefault) + `}`}, ", ")
	return s
}
func (this *CacheTTLOptionsType_CacheTtlOverride) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheTTLOptionsType_CacheTtlOverride{` +
		`CacheTtlOverride:` + fmt.Sprintf("%#v", this.CacheTtlOverride) + `}`}, ", ")
	return s
}
func (this *CacheTTLOptionsType_CacheDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CacheTTLOptionsType_CacheDisabled{` +
		`CacheDisabled:` + fmt.Sprintf("%#v", this.CacheDisabled) + `}`}, ", ")
	return s
}
func (this *AdvancedOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cdn_loadbalancer.AdvancedOptionsType{")
	if this.HeaderOptions != nil {
		s = append(s, "HeaderOptions: "+fmt.Sprintf("%#v", this.HeaderOptions)+",\n")
	}
	if this.SecurityOptions != nil {
		s = append(s, "SecurityOptions: "+fmt.Sprintf("%#v", this.SecurityOptions)+",\n")
	}
	if this.LoggingOptions != nil {
		s = append(s, "LoggingOptions: "+fmt.Sprintf("%#v", this.LoggingOptions)+",\n")
	}
	if this.CacheTtlOptions != nil {
		s = append(s, "CacheTtlOptions: "+fmt.Sprintf("%#v", this.CacheTtlOptions)+",\n")
	}
	if this.CacheOptions != nil {
		s = append(s, "CacheOptions: "+fmt.Sprintf("%#v", this.CacheOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNTLSConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CDNTLSConfig{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNTLSConfig_Tls_12Plus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNTLSConfig_Tls_12Plus{` +
		`Tls_12Plus:` + fmt.Sprintf("%#v", this.Tls_12Plus) + `}`}, ", ")
	return s
}
func (this *CDNTLSConfig_Tls_11Plus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNTLSConfig_Tls_11Plus{` +
		`Tls_11Plus:` + fmt.Sprintf("%#v", this.Tls_11Plus) + `}`}, ", ")
	return s
}
func (this *CDNHTTPSAutoCertsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CDNHTTPSAutoCertsType{")
	s = append(s, "HttpRedirect: "+fmt.Sprintf("%#v", this.HttpRedirect)+",\n")
	s = append(s, "AddHsts: "+fmt.Sprintf("%#v", this.AddHsts)+",\n")
	if this.TlsConfig != nil {
		s = append(s, "TlsConfig: "+fmt.Sprintf("%#v", this.TlsConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNDownstreamTlsParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.CDNDownstreamTlsParamsType{")
	if this.TlsConfig != nil {
		s = append(s, "TlsConfig: "+fmt.Sprintf("%#v", this.TlsConfig)+",\n")
	}
	if this.TlsCertificates != nil {
		s = append(s, "TlsCertificates: "+fmt.Sprintf("%#v", this.TlsCertificates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNHTTPSCustomCertsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CDNHTTPSCustomCertsType{")
	s = append(s, "HttpRedirect: "+fmt.Sprintf("%#v", this.HttpRedirect)+",\n")
	s = append(s, "AddHsts: "+fmt.Sprintf("%#v", this.AddHsts)+",\n")
	if this.TlsParameters != nil {
		s = append(s, "TlsParameters: "+fmt.Sprintf("%#v", this.TlsParameters)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&cdn_loadbalancer.GlobalSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.LoadbalancerType != nil {
		s = append(s, "LoadbalancerType: "+fmt.Sprintf("%#v", this.LoadbalancerType)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.MoreOption != nil {
		s = append(s, "MoreOption: "+fmt.Sprintf("%#v", this.MoreOption)+",\n")
	}
	if this.OriginPool != nil {
		s = append(s, "OriginPool: "+fmt.Sprintf("%#v", this.OriginPool)+",\n")
	}
	if this.ViewInternal != nil {
		s = append(s, "ViewInternal: "+fmt.Sprintf("%#v", this.ViewInternal)+",\n")
	}
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	if this.DnsInfo != nil {
		s = append(s, "DnsInfo: "+fmt.Sprintf("%#v", this.DnsInfo)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "AutoCertState: "+fmt.Sprintf("%#v", this.AutoCertState)+",\n")
	if this.AutoCertInfo != nil {
		s = append(s, "AutoCertInfo: "+fmt.Sprintf("%#v", this.AutoCertInfo)+",\n")
	}
	if this.ServiceDomains != nil {
		s = append(s, "ServiceDomains: "+fmt.Sprintf("%#v", this.ServiceDomains)+",\n")
	}
	s = append(s, "CertState: "+fmt.Sprintf("%#v", this.CertState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GlobalSpecType_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_HttpsAutoCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GlobalSpecType_HttpsAutoCert{` +
		`HttpsAutoCert:` + fmt.Sprintf("%#v", this.HttpsAutoCert) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Https) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GlobalSpecType_Https{` +
		`Https:` + fmt.Sprintf("%#v", this.Https) + `}`}, ", ")
	return s
}
func (this *IpFilteringOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.IpFilteringOptions{")
	if this.IpFilteringType != nil {
		s = append(s, "IpFilteringType: "+fmt.Sprintf("%#v", this.IpFilteringType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpFilteringOptions_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.IpFilteringOptions_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *IpFilteringOptions_BlockList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.IpFilteringOptions_BlockList{` +
		`BlockList:` + fmt.Sprintf("%#v", this.BlockList) + `}`}, ", ")
	return s
}
func (this *GeoFilteringOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.GeoFilteringOptions{")
	if this.GeoFilteringType != nil {
		s = append(s, "GeoFilteringType: "+fmt.Sprintf("%#v", this.GeoFilteringType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoFilteringOptions_AllowList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GeoFilteringOptions_AllowList{` +
		`AllowList:` + fmt.Sprintf("%#v", this.AllowList) + `}`}, ", ")
	return s
}
func (this *GeoFilteringOptions_BlockList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GeoFilteringOptions_BlockList{` +
		`BlockList:` + fmt.Sprintf("%#v", this.BlockList) + `}`}, ", ")
	return s
}
func (this *LogHeaderOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_loadbalancer.LogHeaderOptions{")
	s = append(s, "HeaderList: "+fmt.Sprintf("%#v", this.HeaderList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNCustomAuthentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_loadbalancer.CDNCustomAuthentication{")
	s = append(s, "CustomAuthConfig: "+fmt.Sprintf("%#v", this.CustomAuthConfig)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthenticationOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.AuthenticationOptions{")
	if this.AuthOptions != nil {
		s = append(s, "AuthOptions: "+fmt.Sprintf("%#v", this.AuthOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthenticationOptions_DisableAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.AuthenticationOptions_DisableAuth{` +
		`DisableAuth:` + fmt.Sprintf("%#v", this.DisableAuth) + `}`}, ", ")
	return s
}
func (this *AuthenticationOptions_Jwt) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.AuthenticationOptions_Jwt{` +
		`Jwt:` + fmt.Sprintf("%#v", this.Jwt) + `}`}, ", ")
	return s
}
func (this *AuthenticationOptions_Custom) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.AuthenticationOptions_Custom{` +
		`Custom:` + fmt.Sprintf("%#v", this.Custom) + `}`}, ", ")
	return s
}
func (this *CDNOriginServerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.CDNOriginServerType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNOriginServerType_PublicIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNOriginServerType_PublicIp{` +
		`PublicIp:` + fmt.Sprintf("%#v", this.PublicIp) + `}`}, ", ")
	return s
}
func (this *CDNOriginServerType_PublicName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CDNOriginServerType_PublicName{` +
		`PublicName:` + fmt.Sprintf("%#v", this.PublicName) + `}`}, ", ")
	return s
}
func (this *CdnOriginPoolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cdn_loadbalancer.CdnOriginPoolType{")
	if this.PublicName != nil {
		s = append(s, "PublicName: "+fmt.Sprintf("%#v", this.PublicName)+",\n")
	}
	if this.TlsChoice != nil {
		s = append(s, "TlsChoice: "+fmt.Sprintf("%#v", this.TlsChoice)+",\n")
	}
	if this.OriginServers != nil {
		s = append(s, "OriginServers: "+fmt.Sprintf("%#v", this.OriginServers)+",\n")
	}
	s = append(s, "FollowOriginRedirect: "+fmt.Sprintf("%#v", this.FollowOriginRedirect)+",\n")
	s = append(s, "OriginRequestTimeout: "+fmt.Sprintf("%#v", this.OriginRequestTimeout)+",\n")
	if this.MoreOriginOptions != nil {
		s = append(s, "MoreOriginOptions: "+fmt.Sprintf("%#v", this.MoreOriginOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CdnOriginPoolType_NoTls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CdnOriginPoolType_NoTls{` +
		`NoTls:` + fmt.Sprintf("%#v", this.NoTls) + `}`}, ", ")
	return s
}
func (this *CdnOriginPoolType_UseTls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CdnOriginPoolType_UseTls{` +
		`UseTls:` + fmt.Sprintf("%#v", this.UseTls) + `}`}, ", ")
	return s
}
func (this *OriginAdvancedConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.OriginAdvancedConfiguration{")
	s = append(s, "DisableByteRangeRequest: "+fmt.Sprintf("%#v", this.DisableByteRangeRequest)+",\n")
	s = append(s, "WebsocketProxy: "+fmt.Sprintf("%#v", this.WebsocketProxy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cdn_loadbalancer.CreateSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.LoadbalancerType != nil {
		s = append(s, "LoadbalancerType: "+fmt.Sprintf("%#v", this.LoadbalancerType)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.MoreOption != nil {
		s = append(s, "MoreOption: "+fmt.Sprintf("%#v", this.MoreOption)+",\n")
	}
	if this.OriginPool != nil {
		s = append(s, "OriginPool: "+fmt.Sprintf("%#v", this.OriginPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CreateSpecType_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_HttpsAutoCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CreateSpecType_HttpsAutoCert{` +
		`HttpsAutoCert:` + fmt.Sprintf("%#v", this.HttpsAutoCert) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Https) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.CreateSpecType_Https{` +
		`Https:` + fmt.Sprintf("%#v", this.Https) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cdn_loadbalancer.ReplaceSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.LoadbalancerType != nil {
		s = append(s, "LoadbalancerType: "+fmt.Sprintf("%#v", this.LoadbalancerType)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.MoreOption != nil {
		s = append(s, "MoreOption: "+fmt.Sprintf("%#v", this.MoreOption)+",\n")
	}
	if this.OriginPool != nil {
		s = append(s, "OriginPool: "+fmt.Sprintf("%#v", this.OriginPool)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ReplaceSpecType_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_HttpsAutoCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ReplaceSpecType_HttpsAutoCert{` +
		`HttpsAutoCert:` + fmt.Sprintf("%#v", this.HttpsAutoCert) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Https) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.ReplaceSpecType_Https{` +
		`Https:` + fmt.Sprintf("%#v", this.Https) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&cdn_loadbalancer.GetSpecType{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	if this.LoadbalancerType != nil {
		s = append(s, "LoadbalancerType: "+fmt.Sprintf("%#v", this.LoadbalancerType)+",\n")
	}
	s = append(s, "AddLocation: "+fmt.Sprintf("%#v", this.AddLocation)+",\n")
	if this.MoreOption != nil {
		s = append(s, "MoreOption: "+fmt.Sprintf("%#v", this.MoreOption)+",\n")
	}
	if this.OriginPool != nil {
		s = append(s, "OriginPool: "+fmt.Sprintf("%#v", this.OriginPool)+",\n")
	}
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	if this.DnsInfo != nil {
		s = append(s, "DnsInfo: "+fmt.Sprintf("%#v", this.DnsInfo)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.AutoCertInfo != nil {
		s = append(s, "AutoCertInfo: "+fmt.Sprintf("%#v", this.AutoCertInfo)+",\n")
	}
	if this.ServiceDomains != nil {
		s = append(s, "ServiceDomains: "+fmt.Sprintf("%#v", this.ServiceDomains)+",\n")
	}
	s = append(s, "CertState: "+fmt.Sprintf("%#v", this.CertState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GetSpecType_Http{` +
		`Http:` + fmt.Sprintf("%#v", this.Http) + `}`}, ", ")
	return s
}
func (this *GetSpecType_HttpsAutoCert) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GetSpecType_HttpsAutoCert{` +
		`HttpsAutoCert:` + fmt.Sprintf("%#v", this.HttpsAutoCert) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Https) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_loadbalancer.GetSpecType_Https{` +
		`Https:` + fmt.Sprintf("%#v", this.Https) + `}`}, ", ")
	return s
}
func (this *LilacCDNMetricsFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsFilter{")
	s = append(s, "Tag: "+fmt.Sprintf("%#v", this.Tag)+",\n")
	s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsResponseGroupBy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsResponseGroupBy{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsResponseValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsResponseValue{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsResponseSeries) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsResponseSeries{")
	if this.GroupBy != nil {
		s = append(s, "GroupBy: "+fmt.Sprintf("%#v", this.GroupBy)+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNMetricsResponseData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_loadbalancer.LilacCDNMetricsResponseData{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	if this.Series != nil {
		s = append(s, "Series: "+fmt.Sprintf("%#v", this.Series)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ProxyTypeHttpsAutoCerts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyTypeHttpsAutoCerts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServerHeaderChoice != nil {
		{
			size := m.ServerHeaderChoice.Size()
			i -= size
			if _, err := m.ServerHeaderChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TlsConfig != nil {
		{
			size, err := m.TlsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AddHsts {
		i--
		if m.AddHsts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HttpRedirect {
		i--
		if m.HttpRedirect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProxyTypeHttpsAutoCerts_DefaultHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts_DefaultHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultHeader != nil {
		{
			size, err := m.DefaultHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ProxyTypeHttpsAutoCerts_ServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts_ServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ServerName)
	copy(dAtA[i:], m.ServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *ProxyTypeHttpsAutoCerts_AppendServerName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts_AppendServerName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AppendServerName)
	copy(dAtA[i:], m.AppendServerName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.AppendServerName)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *ProxyTypeHttpsAutoCerts_PassThrough) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyTypeHttpsAutoCerts_PassThrough) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PassThrough != nil {
		{
			size, err := m.PassThrough.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *HeaderControlType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderControlType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderControlType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResponseHeadersToRemove) > 0 {
		for iNdEx := len(m.ResponseHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResponseHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.ResponseHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for iNdEx := len(m.ResponseHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResponseHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for iNdEx := len(m.RequestHeadersToRemove) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHeadersToRemove[iNdEx])
			copy(dAtA[i:], m.RequestHeadersToRemove[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestHeadersToRemove[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RequestHeadersToAdd) > 0 {
		for iNdEx := len(m.RequestHeadersToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestHeadersToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecurityOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthOptions != nil {
		{
			size, err := m.AuthOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.GeoFiltering != nil {
		{
			size, err := m.GeoFiltering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IpFiltering != nil {
		{
			size, err := m.IpFiltering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}

func (m *LoggingOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggingOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggingOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OriginLogOptions != nil {
		{
			size, err := m.OriginLogOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ClientLogOptions != nil {
		{
			size, err := m.ClientLogOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}

func (m *CDNCacheRuleExpressionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNCacheRuleExpressionList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRuleExpressionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CacheRuleExpression) > 0 {
		for iNdEx := len(m.CacheRuleExpression) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CacheRuleExpression[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ExpressionName) > 0 {
		i -= len(m.ExpressionName)
		copy(dAtA[i:], m.ExpressionName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExpressionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheOperator != nil {
		{
			size := m.CacheOperator.Size()
			i -= size
			if _, err := m.CacheOperator.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CacheOperator_Equals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_Equals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Equals)
	copy(dAtA[i:], m.Equals)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Equals)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CacheOperator_DoesNotEqual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_DoesNotEqual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DoesNotEqual)
	copy(dAtA[i:], m.DoesNotEqual)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DoesNotEqual)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *CacheOperator_Contains) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_Contains) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Contains)
	copy(dAtA[i:], m.Contains)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Contains)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *CacheOperator_DoesNotContain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_DoesNotContain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DoesNotContain)
	copy(dAtA[i:], m.DoesNotContain)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DoesNotContain)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *CacheOperator_Startswith) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_Startswith) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Startswith)
	copy(dAtA[i:], m.Startswith)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Startswith)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *CacheOperator_DoesNotStartWith) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_DoesNotStartWith) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DoesNotStartWith)
	copy(dAtA[i:], m.DoesNotStartWith)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DoesNotStartWith)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *CacheOperator_Endswith) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_Endswith) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Endswith)
	copy(dAtA[i:], m.Endswith)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Endswith)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *CacheOperator_DoesNotEndWith) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_DoesNotEndWith) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DoesNotEndWith)
	copy(dAtA[i:], m.DoesNotEndWith)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DoesNotEndWith)))
	i--
	dAtA[i] = 0x4a
	return len(dAtA) - i, nil
}
func (m *CacheOperator_MatchRegex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_MatchRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.MatchRegex)
	copy(dAtA[i:], m.MatchRegex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MatchRegex)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *CacheHeaderMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheHeaderMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheHeaderMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != nil {
		{
			size, err := m.Operator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Name != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Name))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDNPathMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNPathMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNPathMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != nil {
		{
			size, err := m.Operator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}

func (m *CacheCookieMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheCookieMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheCookieMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != nil {
		{
			size, err := m.Operator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheQueryParameterMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheQueryParameterMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheQueryParameterMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != nil {
		{
			size, err := m.Operator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNCacheRuleExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNCacheRuleExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRuleExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookieMatcher) > 0 {
		for iNdEx := len(m.CookieMatcher) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieMatcher[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.QueryParameters) > 0 {
		for iNdEx := len(m.QueryParameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CacheHeaders) > 0 {
		for iNdEx := len(m.CacheHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CacheHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PathMatch != nil {
		{
			size, err := m.PathMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheTTLEnableProps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheTTLEnableProps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLEnableProps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreResponseCookie {
		i--
		if m.IgnoreResponseCookie {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.CacheOverride {
		i--
		if m.CacheOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.CacheTtl) > 0 {
		i -= len(m.CacheTtl)
		copy(dAtA[i:], m.CacheTtl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CacheTtl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheEligibleOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheEligibleOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EligibleForCache != nil {
		{
			size := m.EligibleForCache.Size()
			i -= size
			if _, err := m.EligibleForCache.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CacheEligibleOptions_SchemeHostnameUri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions_SchemeHostnameUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemeHostnameUri != nil {
		{
			size, err := m.SchemeHostnameUri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CacheEligibleOptions_SchemeHostnameRequestUri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions_SchemeHostnameRequestUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemeHostnameRequestUri != nil {
		{
			size, err := m.SchemeHostnameRequestUri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CacheEligibleOptions_HostnameUri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions_HostnameUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HostnameUri != nil {
		{
			size, err := m.HostnameUri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CacheEligibleOptions_SchemeHostnameUriQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions_SchemeHostnameUriQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemeHostnameUriQuery != nil {
		{
			size, err := m.SchemeHostnameUriQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CacheEligibleOptions_SchemeProxyHostUri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions_SchemeProxyHostUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemeProxyHostUri != nil {
		{
			size, err := m.SchemeProxyHostUri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CacheEligibleOptions_SchemeProxyHostRequestUri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions_SchemeProxyHostRequestUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemeProxyHostRequestUri != nil {
		{
			size, err := m.SchemeProxyHostRequestUri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CDNCacheRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNCacheRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheActions != nil {
		{
			size := m.CacheActions.Size()
			i -= size
			if _, err := m.CacheActions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.RuleExpressionList) > 0 {
		for iNdEx := len(m.RuleExpressionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuleExpressionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RuleName) > 0 {
		i -= len(m.RuleName)
		copy(dAtA[i:], m.RuleName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RuleName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNCacheRule_CacheBypass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRule_CacheBypass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CacheBypass != nil {
		{
			size, err := m.CacheBypass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CDNCacheRule_EligibleForCache) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRule_EligibleForCache) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EligibleForCache != nil {
		{
			size, err := m.EligibleForCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DefaultCacheTTLProps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultCacheTTLProps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultCacheTTLProps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CacheTtl) > 0 {
		i -= len(m.CacheTtl)
		copy(dAtA[i:], m.CacheTtl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CacheTtl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DefaultCacheAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultCacheAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultCacheAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheActions != nil {
		{
			size := m.CacheActions.Size()
			i -= size
			if _, err := m.CacheActions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DefaultCacheAction_EligibleForCache) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultCacheAction_EligibleForCache) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EligibleForCache != nil {
		{
			size, err := m.EligibleForCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DefaultCacheAction_CacheTtlDefault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultCacheAction_CacheTtlDefault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CacheTtlDefault)
	copy(dAtA[i:], m.CacheTtlDefault)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.CacheTtlDefault)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *DefaultCacheAction_CacheTtlOverride) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultCacheAction_CacheTtlOverride) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CacheTtlOverride)
	copy(dAtA[i:], m.CacheTtlOverride)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.CacheTtlOverride)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *DefaultCacheAction_CacheDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultCacheAction_CacheDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CacheDisabled != nil {
		{
			size, err := m.CacheDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CacheOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CacheRules) > 0 {
		for iNdEx := len(m.CacheRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CacheRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultCacheAction != nil {
		{
			size, err := m.DefaultCacheAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheTTLOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheTTLOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TtlOptions != nil {
		{
			size := m.TtlOptions.Size()
			i -= size
			if _, err := m.TtlOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CacheTTLOptionsType_CacheTtlDefault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLOptionsType_CacheTtlDefault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CacheTtlDefault)
	copy(dAtA[i:], m.CacheTtlDefault)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.CacheTtlDefault)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CacheTTLOptionsType_CacheTtlOverride) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLOptionsType_CacheTtlOverride) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CacheTtlOverride)
	copy(dAtA[i:], m.CacheTtlOverride)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.CacheTtlOverride)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *CacheTTLOptionsType_CacheDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLOptionsType_CacheDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CacheDisabled != nil {
		{
			size, err := m.CacheDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AdvancedOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvancedOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdvancedOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheOptions != nil {
		{
			size, err := m.CacheOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.CacheTtlOptions != nil {
		{
			size, err := m.CacheTtlOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.LoggingOptions != nil {
		{
			size, err := m.LoggingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.SecurityOptions != nil {
		{
			size, err := m.SecurityOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.HeaderOptions != nil {
		{
			size, err := m.HeaderOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}

func (m *CDNTLSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNTLSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNTLSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNTLSConfig_Tls_12Plus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNTLSConfig_Tls_12Plus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tls_12Plus != nil {
		{
			size, err := m.Tls_12Plus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CDNTLSConfig_Tls_11Plus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNTLSConfig_Tls_11Plus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tls_11Plus != nil {
		{
			size, err := m.Tls_11Plus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CDNHTTPSAutoCertsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNHTTPSAutoCertsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNHTTPSAutoCertsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TlsConfig != nil {
		{
			size, err := m.TlsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AddHsts {
		i--
		if m.AddHsts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HttpRedirect {
		i--
		if m.HttpRedirect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDNDownstreamTlsParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNDownstreamTlsParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNDownstreamTlsParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TlsCertificates) > 0 {
		for iNdEx := len(m.TlsCertificates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TlsCertificates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TlsConfig != nil {
		{
			size, err := m.TlsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNHTTPSCustomCertsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNHTTPSCustomCertsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNHTTPSCustomCertsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TlsParameters != nil {
		{
			size, err := m.TlsParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AddHsts {
		i--
		if m.AddHsts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HttpRedirect {
		i--
		if m.HttpRedirect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CertState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CertState))
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0xa0
	}
	if len(m.ServiceDomains) > 0 {
		for iNdEx := len(m.ServiceDomains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServiceDomains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3f
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.AutoCertInfo != nil {
		{
			size, err := m.AutoCertInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x92
	}
	if m.AutoCertState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AutoCertState))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe0
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd8
	}
	if len(m.DnsInfo) > 0 {
		for iNdEx := len(m.DnsInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.ViewInternal != nil {
		{
			size, err := m.ViewInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xc2
	}
	if m.LoadbalancerType != nil {
		{
			size := m.LoadbalancerType.Size()
			i -= size
			if _, err := m.LoadbalancerType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OriginPool != nil {
		{
			size, err := m.OriginPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MoreOption != nil {
		{
			size, err := m.MoreOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_HttpsAutoCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_HttpsAutoCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpsAutoCert != nil {
		{
			size, err := m.HttpsAutoCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Https) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Https) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Https != nil {
		{
			size, err := m.Https.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *IpFilteringOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpFilteringOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpFilteringOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IpFilteringType != nil {
		{
			size := m.IpFilteringType.Size()
			i -= size
			if _, err := m.IpFilteringType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IpFilteringOptions_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpFilteringOptions_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IpFilteringOptions_BlockList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpFilteringOptions_BlockList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockList != nil {
		{
			size, err := m.BlockList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GeoFilteringOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoFilteringOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoFilteringOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GeoFilteringType != nil {
		{
			size := m.GeoFilteringType.Size()
			i -= size
			if _, err := m.GeoFilteringType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeoFilteringOptions_AllowList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoFilteringOptions_AllowList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowList != nil {
		{
			size, err := m.AllowList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GeoFilteringOptions_BlockList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoFilteringOptions_BlockList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockList != nil {
		{
			size, err := m.BlockList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LogHeaderOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogHeaderOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogHeaderOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HeaderList) > 0 {
		for iNdEx := len(m.HeaderList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HeaderList[iNdEx])
			copy(dAtA[i:], m.HeaderList[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.HeaderList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNCustomAuthentication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNCustomAuthentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCustomAuthentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomAuthConfig) > 0 {
		i -= len(m.CustomAuthConfig)
		copy(dAtA[i:], m.CustomAuthConfig)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomAuthConfig)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthOptions != nil {
		{
			size := m.AuthOptions.Size()
			i -= size
			if _, err := m.AuthOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticationOptions_DisableAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationOptions_DisableAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableAuth != nil {
		{
			size, err := m.DisableAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AuthenticationOptions_Jwt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationOptions_Jwt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Jwt != nil {
		{
			size, err := m.Jwt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AuthenticationOptions_Custom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationOptions_Custom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Custom != nil {
		{
			size, err := m.Custom.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CDNOriginServerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNOriginServerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNOriginServerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x20
	}
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CDNOriginServerType_PublicIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNOriginServerType_PublicIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PublicIp != nil {
		{
			size, err := m.PublicIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CDNOriginServerType_PublicName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNOriginServerType_PublicName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PublicName != nil {
		{
			size, err := m.PublicName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CdnOriginPoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CdnOriginPoolType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CdnOriginPoolType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MoreOriginOptions != nil {
		{
			size, err := m.MoreOriginOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.OriginRequestTimeout) > 0 {
		i -= len(m.OriginRequestTimeout)
		copy(dAtA[i:], m.OriginRequestTimeout)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OriginRequestTimeout)))
		i--
		dAtA[i] = 0x3a
	}
	if m.FollowOriginRedirect {
		i--
		if m.FollowOriginRedirect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.OriginServers) > 0 {
		for iNdEx := len(m.OriginServers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OriginServers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TlsChoice != nil {
		{
			size := m.TlsChoice.Size()
			i -= size
			if _, err := m.TlsChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PublicName != nil {
		{
			size, err := m.PublicName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CdnOriginPoolType_NoTls) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CdnOriginPoolType_NoTls) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoTls != nil {
		{
			size, err := m.NoTls.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CdnOriginPoolType_UseTls) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CdnOriginPoolType_UseTls) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseTls != nil {
		{
			size, err := m.UseTls.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *OriginAdvancedConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OriginAdvancedConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OriginAdvancedConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WebsocketProxy {
		i--
		if m.WebsocketProxy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.DisableByteRangeRequest {
		i--
		if m.DisableByteRangeRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoadbalancerType != nil {
		{
			size := m.LoadbalancerType.Size()
			i -= size
			if _, err := m.LoadbalancerType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OriginPool != nil {
		{
			size, err := m.OriginPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MoreOption != nil {
		{
			size, err := m.MoreOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_HttpsAutoCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_HttpsAutoCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpsAutoCert != nil {
		{
			size, err := m.HttpsAutoCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_Https) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Https) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Https != nil {
		{
			size, err := m.Https.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoadbalancerType != nil {
		{
			size := m.LoadbalancerType.Size()
			i -= size
			if _, err := m.LoadbalancerType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OriginPool != nil {
		{
			size, err := m.OriginPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MoreOption != nil {
		{
			size, err := m.MoreOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_HttpsAutoCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_HttpsAutoCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpsAutoCert != nil {
		{
			size, err := m.HttpsAutoCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_Https) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Https) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Https != nil {
		{
			size, err := m.Https.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CertState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CertState))
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0xa0
	}
	if len(m.ServiceDomains) > 0 {
		for iNdEx := len(m.ServiceDomains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServiceDomains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3f
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.AutoCertInfo != nil {
		{
			size, err := m.AutoCertInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x92
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd8
	}
	if len(m.DnsInfo) > 0 {
		for iNdEx := len(m.DnsInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.LoadbalancerType != nil {
		{
			size := m.LoadbalancerType.Size()
			i -= size
			if _, err := m.LoadbalancerType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OriginPool != nil {
		{
			size, err := m.OriginPool.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MoreOption != nil {
		{
			size, err := m.MoreOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AddLocation {
		i--
		if m.AddLocation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_Http) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Http) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Http != nil {
		{
			size, err := m.Http.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_HttpsAutoCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_HttpsAutoCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HttpsAutoCert != nil {
		{
			size, err := m.HttpsAutoCert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_Https) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Https) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Https != nil {
		{
			size, err := m.Https.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *LilacCDNMetricsFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Operator))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Tag != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsResponseGroupBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsResponseGroupBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsResponseGroupBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Name))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsResponseValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsResponseValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsResponseValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Timestamp) > 0 {
		i -= len(m.Timestamp)
		copy(dAtA[i:], m.Timestamp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Timestamp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsResponseSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsResponseSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsResponseSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNMetricsResponseData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNMetricsResponseData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNMetricsResponseData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Unit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProxyTypeHttpsAutoCerts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpRedirect {
		n += 2
	}
	if m.AddHsts {
		n += 2
	}
	if m.TlsConfig != nil {
		l = m.TlsConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServerHeaderChoice != nil {
		n += m.ServerHeaderChoice.Size()
	}
	return n
}

func (m *ProxyTypeHttpsAutoCerts_DefaultHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultHeader != nil {
		l = m.DefaultHeader.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ProxyTypeHttpsAutoCerts_ServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ProxyTypeHttpsAutoCerts_AppendServerName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppendServerName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ProxyTypeHttpsAutoCerts_PassThrough) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PassThrough != nil {
		l = m.PassThrough.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderControlType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestHeadersToAdd) > 0 {
		for _, e := range m.RequestHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestHeadersToRemove) > 0 {
		for _, s := range m.RequestHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToAdd) > 0 {
		for _, e := range m.ResponseHeadersToAdd {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResponseHeadersToRemove) > 0 {
		for _, s := range m.ResponseHeadersToRemove {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SecurityOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpFiltering != nil {
		l = m.IpFiltering.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GeoFiltering != nil {
		l = m.GeoFiltering.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AuthOptions != nil {
		l = m.AuthOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LoggingOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientLogOptions != nil {
		l = m.ClientLogOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginLogOptions != nil {
		l = m.OriginLogOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CDNCacheRuleExpressionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExpressionName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CacheRuleExpression) > 0 {
		for _, e := range m.CacheRuleExpression {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CacheOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheOperator != nil {
		n += m.CacheOperator.Size()
	}
	return n
}

func (m *CacheOperator_Equals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Equals)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_DoesNotEqual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DoesNotEqual)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_Contains) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Contains)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_DoesNotContain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DoesNotContain)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_Startswith) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Startswith)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_DoesNotStartWith) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DoesNotStartWith)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_Endswith) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endswith)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_DoesNotEndWith) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DoesNotEndWith)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_MatchRegex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MatchRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheHeaderMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != 0 {
		n += 1 + sovTypes(uint64(m.Name))
	}
	if m.Operator != nil {
		l = m.Operator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CDNPathMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operator != nil {
		l = m.Operator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CacheCookieMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Operator != nil {
		l = m.Operator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CacheQueryParameterMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Operator != nil {
		l = m.Operator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CDNCacheRuleExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PathMatch != nil {
		l = m.PathMatch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CacheHeaders) > 0 {
		for _, e := range m.CacheHeaders {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParameters) > 0 {
		for _, e := range m.QueryParameters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatcher) > 0 {
		for _, e := range m.CookieMatcher {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CacheTTLEnableProps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacheTtl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CacheOverride {
		n += 2
	}
	if m.IgnoreResponseCookie {
		n += 2
	}
	return n
}

func (m *CacheEligibleOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EligibleForCache != nil {
		n += m.EligibleForCache.Size()
	}
	return n
}

func (m *CacheEligibleOptions_SchemeHostnameUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemeHostnameUri != nil {
		l = m.SchemeHostnameUri.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CacheEligibleOptions_SchemeHostnameRequestUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemeHostnameRequestUri != nil {
		l = m.SchemeHostnameRequestUri.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CacheEligibleOptions_HostnameUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostnameUri != nil {
		l = m.HostnameUri.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CacheEligibleOptions_SchemeHostnameUriQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemeHostnameUriQuery != nil {
		l = m.SchemeHostnameUriQuery.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CacheEligibleOptions_SchemeProxyHostUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemeProxyHostUri != nil {
		l = m.SchemeProxyHostUri.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CacheEligibleOptions_SchemeProxyHostRequestUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemeProxyHostRequestUri != nil {
		l = m.SchemeProxyHostRequestUri.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNCacheRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RuleName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RuleExpressionList) > 0 {
		for _, e := range m.RuleExpressionList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CacheActions != nil {
		n += m.CacheActions.Size()
	}
	return n
}

func (m *CDNCacheRule_CacheBypass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheBypass != nil {
		l = m.CacheBypass.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNCacheRule_EligibleForCache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EligibleForCache != nil {
		l = m.EligibleForCache.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DefaultCacheTTLProps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacheTtl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DefaultCacheAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheActions != nil {
		n += m.CacheActions.Size()
	}
	return n
}

func (m *DefaultCacheAction_EligibleForCache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EligibleForCache != nil {
		l = m.EligibleForCache.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DefaultCacheAction_CacheTtlDefault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacheTtlDefault)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DefaultCacheAction_CacheTtlOverride) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacheTtlOverride)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DefaultCacheAction_CacheDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheDisabled != nil {
		l = m.CacheDisabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CacheOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultCacheAction != nil {
		l = m.DefaultCacheAction.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CacheRules) > 0 {
		for _, e := range m.CacheRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CacheTTLOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TtlOptions != nil {
		n += m.TtlOptions.Size()
	}
	return n
}

func (m *CacheTTLOptionsType_CacheTtlDefault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacheTtlDefault)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheTTLOptionsType_CacheTtlOverride) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacheTtlOverride)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheTTLOptionsType_CacheDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheDisabled != nil {
		l = m.CacheDisabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AdvancedOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderOptions != nil {
		l = m.HeaderOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.SecurityOptions != nil {
		l = m.SecurityOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LoggingOptions != nil {
		l = m.LoggingOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CacheTtlOptions != nil {
		l = m.CacheTtlOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CacheOptions != nil {
		l = m.CacheOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CDNTLSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *CDNTLSConfig_Tls_12Plus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tls_12Plus != nil {
		l = m.Tls_12Plus.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNTLSConfig_Tls_11Plus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tls_11Plus != nil {
		l = m.Tls_11Plus.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNHTTPSAutoCertsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpRedirect {
		n += 2
	}
	if m.AddHsts {
		n += 2
	}
	if m.TlsConfig != nil {
		l = m.TlsConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CDNDownstreamTlsParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TlsConfig != nil {
		l = m.TlsConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.TlsCertificates) > 0 {
		for _, e := range m.TlsCertificates {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CDNHTTPSCustomCertsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpRedirect {
		n += 2
	}
	if m.AddHsts {
		n += 2
	}
	if m.TlsParameters != nil {
		l = m.TlsParameters.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerType != nil {
		n += m.LoadbalancerType.Size()
	}
	if m.AddLocation {
		n += 2
	}
	if m.MoreOption != nil {
		l = m.MoreOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginPool != nil {
		l = m.OriginPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ViewInternal != nil {
		l = m.ViewInternal.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DnsInfo) > 0 {
		for _, e := range m.DnsInfo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.State != 0 {
		n += 2 + sovTypes(uint64(m.State))
	}
	if m.AutoCertState != 0 {
		n += 2 + sovTypes(uint64(m.AutoCertState))
	}
	if m.AutoCertInfo != nil {
		l = m.AutoCertInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ServiceDomains) > 0 {
		for _, e := range m.ServiceDomains {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.CertState != 0 {
		n += 2 + sovTypes(uint64(m.CertState))
	}
	return n
}

func (m *GlobalSpecType_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_HttpsAutoCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsAutoCert != nil {
		l = m.HttpsAutoCert.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Https) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Https != nil {
		l = m.Https.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IpFilteringOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpFilteringType != nil {
		n += m.IpFilteringType.Size()
	}
	return n
}

func (m *IpFilteringOptions_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IpFilteringOptions_BlockList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockList != nil {
		l = m.BlockList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GeoFilteringOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GeoFilteringType != nil {
		n += m.GeoFilteringType.Size()
	}
	return n
}

func (m *GeoFilteringOptions_AllowList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowList != nil {
		l = m.AllowList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GeoFilteringOptions_BlockList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockList != nil {
		l = m.BlockList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LogHeaderOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.HeaderList) > 0 {
		for _, s := range m.HeaderList {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CDNCustomAuthentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomAuthConfig)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuthenticationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthOptions != nil {
		n += m.AuthOptions.Size()
	}
	return n
}

func (m *AuthenticationOptions_DisableAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableAuth != nil {
		l = m.DisableAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AuthenticationOptions_Jwt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Jwt != nil {
		l = m.Jwt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AuthenticationOptions_Custom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Custom != nil {
		l = m.Custom.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNOriginServerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	return n
}

func (m *CDNOriginServerType_PublicIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicIp != nil {
		l = m.PublicIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNOriginServerType_PublicName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicName != nil {
		l = m.PublicName.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CdnOriginPoolType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicName != nil {
		l = m.PublicName.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TlsChoice != nil {
		n += m.TlsChoice.Size()
	}
	if len(m.OriginServers) > 0 {
		for _, e := range m.OriginServers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.FollowOriginRedirect {
		n += 2
	}
	l = len(m.OriginRequestTimeout)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MoreOriginOptions != nil {
		l = m.MoreOriginOptions.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CdnOriginPoolType_NoTls) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoTls != nil {
		l = m.NoTls.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CdnOriginPoolType_UseTls) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseTls != nil {
		l = m.UseTls.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *OriginAdvancedConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableByteRangeRequest {
		n += 2
	}
	if m.WebsocketProxy {
		n += 2
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerType != nil {
		n += m.LoadbalancerType.Size()
	}
	if m.AddLocation {
		n += 2
	}
	if m.MoreOption != nil {
		l = m.MoreOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginPool != nil {
		l = m.OriginPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_HttpsAutoCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsAutoCert != nil {
		l = m.HttpsAutoCert.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_Https) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Https != nil {
		l = m.Https.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerType != nil {
		n += m.LoadbalancerType.Size()
	}
	if m.AddLocation {
		n += 2
	}
	if m.MoreOption != nil {
		l = m.MoreOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginPool != nil {
		l = m.OriginPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_HttpsAutoCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsAutoCert != nil {
		l = m.HttpsAutoCert.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_Https) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Https != nil {
		l = m.Https.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LoadbalancerType != nil {
		n += m.LoadbalancerType.Size()
	}
	if m.AddLocation {
		n += 2
	}
	if m.MoreOption != nil {
		l = m.MoreOption.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OriginPool != nil {
		l = m.OriginPool.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DnsInfo) > 0 {
		for _, e := range m.DnsInfo {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.State != 0 {
		n += 2 + sovTypes(uint64(m.State))
	}
	if m.AutoCertInfo != nil {
		l = m.AutoCertInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.ServiceDomains) > 0 {
		for _, e := range m.ServiceDomains {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.CertState != 0 {
		n += 2 + sovTypes(uint64(m.CertState))
	}
	return n
}

func (m *GetSpecType_Http) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Http != nil {
		l = m.Http.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_HttpsAutoCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HttpsAutoCert != nil {
		l = m.HttpsAutoCert.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Https) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Https != nil {
		l = m.Https.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LilacCDNMetricsFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovTypes(uint64(m.Tag))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Operator != 0 {
		n += 1 + sovTypes(uint64(m.Operator))
	}
	return n
}

func (m *LilacCDNMetricsResponseGroupBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != 0 {
		n += 1 + sovTypes(uint64(m.Name))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LilacCDNMetricsResponseValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LilacCDNMetricsResponseSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LilacCDNMetricsResponseData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Unit != 0 {
		n += 1 + sovTypes(uint64(m.Unit))
	}
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ProxyTypeHttpsAutoCerts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts{`,
		`HttpRedirect:` + fmt.Sprintf("%v", this.HttpRedirect) + `,`,
		`AddHsts:` + fmt.Sprintf("%v", this.AddHsts) + `,`,
		`TlsConfig:` + strings.Replace(fmt.Sprintf("%v", this.TlsConfig), "TlsConfig", "views.TlsConfig", 1) + `,`,
		`ServerHeaderChoice:` + fmt.Sprintf("%v", this.ServerHeaderChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_DefaultHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts_DefaultHeader{`,
		`DefaultHeader:` + strings.Replace(fmt.Sprintf("%v", this.DefaultHeader), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_ServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts_ServerName{`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_AppendServerName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts_AppendServerName{`,
		`AppendServerName:` + fmt.Sprintf("%v", this.AppendServerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProxyTypeHttpsAutoCerts_PassThrough) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProxyTypeHttpsAutoCerts_PassThrough{`,
		`PassThrough:` + strings.Replace(fmt.Sprintf("%v", this.PassThrough), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderControlType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRequestHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.RequestHeadersToAdd {
		repeatedStringForRequestHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForRequestHeadersToAdd += "}"
	repeatedStringForResponseHeadersToAdd := "[]*HeaderManipulationOptionType{"
	for _, f := range this.ResponseHeadersToAdd {
		repeatedStringForResponseHeadersToAdd += strings.Replace(fmt.Sprintf("%v", f), "HeaderManipulationOptionType", "schema.HeaderManipulationOptionType", 1) + ","
	}
	repeatedStringForResponseHeadersToAdd += "}"
	s := strings.Join([]string{`&HeaderControlType{`,
		`RequestHeadersToAdd:` + repeatedStringForRequestHeadersToAdd + `,`,
		`RequestHeadersToRemove:` + fmt.Sprintf("%v", this.RequestHeadersToRemove) + `,`,
		`ResponseHeadersToAdd:` + repeatedStringForResponseHeadersToAdd + `,`,
		`ResponseHeadersToRemove:` + fmt.Sprintf("%v", this.ResponseHeadersToRemove) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityOptionsType{`,
		`IpFiltering:` + strings.Replace(this.IpFiltering.String(), "IpFilteringOptions", "IpFilteringOptions", 1) + `,`,
		`GeoFiltering:` + strings.Replace(this.GeoFiltering.String(), "GeoFilteringOptions", "GeoFilteringOptions", 1) + `,`,
		`AuthOptions:` + strings.Replace(this.AuthOptions.String(), "AuthenticationOptions", "AuthenticationOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoggingOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoggingOptionsType{`,
		`ClientLogOptions:` + strings.Replace(this.ClientLogOptions.String(), "LogHeaderOptions", "LogHeaderOptions", 1) + `,`,
		`OriginLogOptions:` + strings.Replace(this.OriginLogOptions.String(), "LogHeaderOptions", "LogHeaderOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRuleExpressionList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCacheRuleExpression := "[]*CDNCacheRuleExpression{"
	for _, f := range this.CacheRuleExpression {
		repeatedStringForCacheRuleExpression += strings.Replace(f.String(), "CDNCacheRuleExpression", "CDNCacheRuleExpression", 1) + ","
	}
	repeatedStringForCacheRuleExpression += "}"
	s := strings.Join([]string{`&CDNCacheRuleExpressionList{`,
		`ExpressionName:` + fmt.Sprintf("%v", this.ExpressionName) + `,`,
		`CacheRuleExpression:` + repeatedStringForCacheRuleExpression + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator{`,
		`CacheOperator:` + fmt.Sprintf("%v", this.CacheOperator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_Equals) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_Equals{`,
		`Equals:` + fmt.Sprintf("%v", this.Equals) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_DoesNotEqual) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_DoesNotEqual{`,
		`DoesNotEqual:` + fmt.Sprintf("%v", this.DoesNotEqual) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_Contains) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_Contains{`,
		`Contains:` + fmt.Sprintf("%v", this.Contains) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_DoesNotContain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_DoesNotContain{`,
		`DoesNotContain:` + fmt.Sprintf("%v", this.DoesNotContain) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_Startswith) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_Startswith{`,
		`Startswith:` + fmt.Sprintf("%v", this.Startswith) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_DoesNotStartWith) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_DoesNotStartWith{`,
		`DoesNotStartWith:` + fmt.Sprintf("%v", this.DoesNotStartWith) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_Endswith) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_Endswith{`,
		`Endswith:` + fmt.Sprintf("%v", this.Endswith) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_DoesNotEndWith) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_DoesNotEndWith{`,
		`DoesNotEndWith:` + fmt.Sprintf("%v", this.DoesNotEndWith) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_MatchRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_MatchRegex{`,
		`MatchRegex:` + fmt.Sprintf("%v", this.MatchRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheHeaderMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheHeaderMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Operator:` + strings.Replace(this.Operator.String(), "CacheOperator", "CacheOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNPathMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNPathMatcherType{`,
		`Operator:` + strings.Replace(this.Operator.String(), "CacheOperator", "CacheOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheCookieMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheCookieMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Operator:` + strings.Replace(this.Operator.String(), "CacheOperator", "CacheOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheQueryParameterMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheQueryParameterMatcherType{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Operator:` + strings.Replace(this.Operator.String(), "CacheOperator", "CacheOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRuleExpression) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCacheHeaders := "[]*CacheHeaderMatcherType{"
	for _, f := range this.CacheHeaders {
		repeatedStringForCacheHeaders += strings.Replace(f.String(), "CacheHeaderMatcherType", "CacheHeaderMatcherType", 1) + ","
	}
	repeatedStringForCacheHeaders += "}"
	repeatedStringForQueryParameters := "[]*CacheQueryParameterMatcherType{"
	for _, f := range this.QueryParameters {
		repeatedStringForQueryParameters += strings.Replace(f.String(), "CacheQueryParameterMatcherType", "CacheQueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParameters += "}"
	repeatedStringForCookieMatcher := "[]*CacheCookieMatcherType{"
	for _, f := range this.CookieMatcher {
		repeatedStringForCookieMatcher += strings.Replace(f.String(), "CacheCookieMatcherType", "CacheCookieMatcherType", 1) + ","
	}
	repeatedStringForCookieMatcher += "}"
	s := strings.Join([]string{`&CDNCacheRuleExpression{`,
		`PathMatch:` + strings.Replace(this.PathMatch.String(), "CDNPathMatcherType", "CDNPathMatcherType", 1) + `,`,
		`CacheHeaders:` + repeatedStringForCacheHeaders + `,`,
		`QueryParameters:` + repeatedStringForQueryParameters + `,`,
		`CookieMatcher:` + repeatedStringForCookieMatcher + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLEnableProps) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLEnableProps{`,
		`CacheTtl:` + fmt.Sprintf("%v", this.CacheTtl) + `,`,
		`CacheOverride:` + fmt.Sprintf("%v", this.CacheOverride) + `,`,
		`IgnoreResponseCookie:` + fmt.Sprintf("%v", this.IgnoreResponseCookie) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions{`,
		`EligibleForCache:` + fmt.Sprintf("%v", this.EligibleForCache) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions_SchemeHostnameUri) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions_SchemeHostnameUri{`,
		`SchemeHostnameUri:` + strings.Replace(fmt.Sprintf("%v", this.SchemeHostnameUri), "CacheTTLEnableProps", "CacheTTLEnableProps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions_SchemeHostnameRequestUri) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions_SchemeHostnameRequestUri{`,
		`SchemeHostnameRequestUri:` + strings.Replace(fmt.Sprintf("%v", this.SchemeHostnameRequestUri), "CacheTTLEnableProps", "CacheTTLEnableProps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions_HostnameUri) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions_HostnameUri{`,
		`HostnameUri:` + strings.Replace(fmt.Sprintf("%v", this.HostnameUri), "CacheTTLEnableProps", "CacheTTLEnableProps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions_SchemeHostnameUriQuery) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions_SchemeHostnameUriQuery{`,
		`SchemeHostnameUriQuery:` + strings.Replace(fmt.Sprintf("%v", this.SchemeHostnameUriQuery), "CacheTTLEnableProps", "CacheTTLEnableProps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions_SchemeProxyHostUri) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions_SchemeProxyHostUri{`,
		`SchemeProxyHostUri:` + strings.Replace(fmt.Sprintf("%v", this.SchemeProxyHostUri), "CacheTTLEnableProps", "CacheTTLEnableProps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions_SchemeProxyHostRequestUri) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions_SchemeProxyHostRequestUri{`,
		`SchemeProxyHostRequestUri:` + strings.Replace(fmt.Sprintf("%v", this.SchemeProxyHostRequestUri), "CacheTTLEnableProps", "CacheTTLEnableProps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRule) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRuleExpressionList := "[]*CDNCacheRuleExpressionList{"
	for _, f := range this.RuleExpressionList {
		repeatedStringForRuleExpressionList += strings.Replace(f.String(), "CDNCacheRuleExpressionList", "CDNCacheRuleExpressionList", 1) + ","
	}
	repeatedStringForRuleExpressionList += "}"
	s := strings.Join([]string{`&CDNCacheRule{`,
		`RuleName:` + fmt.Sprintf("%v", this.RuleName) + `,`,
		`RuleExpressionList:` + repeatedStringForRuleExpressionList + `,`,
		`CacheActions:` + fmt.Sprintf("%v", this.CacheActions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRule_CacheBypass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNCacheRule_CacheBypass{`,
		`CacheBypass:` + strings.Replace(fmt.Sprintf("%v", this.CacheBypass), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRule_EligibleForCache) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNCacheRule_EligibleForCache{`,
		`EligibleForCache:` + strings.Replace(fmt.Sprintf("%v", this.EligibleForCache), "CacheEligibleOptions", "CacheEligibleOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultCacheTTLProps) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultCacheTTLProps{`,
		`CacheTtl:` + fmt.Sprintf("%v", this.CacheTtl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultCacheAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultCacheAction{`,
		`CacheActions:` + fmt.Sprintf("%v", this.CacheActions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultCacheAction_EligibleForCache) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultCacheAction_EligibleForCache{`,
		`EligibleForCache:` + strings.Replace(fmt.Sprintf("%v", this.EligibleForCache), "DefaultCacheTTLProps", "DefaultCacheTTLProps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultCacheAction_CacheTtlDefault) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultCacheAction_CacheTtlDefault{`,
		`CacheTtlDefault:` + fmt.Sprintf("%v", this.CacheTtlDefault) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultCacheAction_CacheTtlOverride) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultCacheAction_CacheTtlOverride{`,
		`CacheTtlOverride:` + fmt.Sprintf("%v", this.CacheTtlOverride) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultCacheAction_CacheDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultCacheAction_CacheDisabled{`,
		`CacheDisabled:` + strings.Replace(fmt.Sprintf("%v", this.CacheDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOptions) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCacheRules := "[]*CDNCacheRule{"
	for _, f := range this.CacheRules {
		repeatedStringForCacheRules += strings.Replace(f.String(), "CDNCacheRule", "CDNCacheRule", 1) + ","
	}
	repeatedStringForCacheRules += "}"
	s := strings.Join([]string{`&CacheOptions{`,
		`DefaultCacheAction:` + strings.Replace(this.DefaultCacheAction.String(), "DefaultCacheAction", "DefaultCacheAction", 1) + `,`,
		`CacheRules:` + repeatedStringForCacheRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLOptionsType{`,
		`TtlOptions:` + fmt.Sprintf("%v", this.TtlOptions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLOptionsType_CacheTtlDefault) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLOptionsType_CacheTtlDefault{`,
		`CacheTtlDefault:` + fmt.Sprintf("%v", this.CacheTtlDefault) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLOptionsType_CacheTtlOverride) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLOptionsType_CacheTtlOverride{`,
		`CacheTtlOverride:` + fmt.Sprintf("%v", this.CacheTtlOverride) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLOptionsType_CacheDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLOptionsType_CacheDisabled{`,
		`CacheDisabled:` + strings.Replace(fmt.Sprintf("%v", this.CacheDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdvancedOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdvancedOptionsType{`,
		`HeaderOptions:` + strings.Replace(this.HeaderOptions.String(), "HeaderControlType", "HeaderControlType", 1) + `,`,
		`SecurityOptions:` + strings.Replace(this.SecurityOptions.String(), "SecurityOptionsType", "SecurityOptionsType", 1) + `,`,
		`LoggingOptions:` + strings.Replace(this.LoggingOptions.String(), "LoggingOptionsType", "LoggingOptionsType", 1) + `,`,
		`CacheTtlOptions:` + strings.Replace(this.CacheTtlOptions.String(), "CacheTTLOptionsType", "CacheTTLOptionsType", 1) + `,`,
		`CacheOptions:` + strings.Replace(this.CacheOptions.String(), "CacheOptions", "CacheOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNTLSConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNTLSConfig{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNTLSConfig_Tls_12Plus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNTLSConfig_Tls_12Plus{`,
		`Tls_12Plus:` + strings.Replace(fmt.Sprintf("%v", this.Tls_12Plus), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNTLSConfig_Tls_11Plus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNTLSConfig_Tls_11Plus{`,
		`Tls_11Plus:` + strings.Replace(fmt.Sprintf("%v", this.Tls_11Plus), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNHTTPSAutoCertsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNHTTPSAutoCertsType{`,
		`HttpRedirect:` + fmt.Sprintf("%v", this.HttpRedirect) + `,`,
		`AddHsts:` + fmt.Sprintf("%v", this.AddHsts) + `,`,
		`TlsConfig:` + strings.Replace(this.TlsConfig.String(), "CDNTLSConfig", "CDNTLSConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNDownstreamTlsParamsType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTlsCertificates := "[]*TlsCertificateType{"
	for _, f := range this.TlsCertificates {
		repeatedStringForTlsCertificates += strings.Replace(fmt.Sprintf("%v", f), "TlsCertificateType", "schema.TlsCertificateType", 1) + ","
	}
	repeatedStringForTlsCertificates += "}"
	s := strings.Join([]string{`&CDNDownstreamTlsParamsType{`,
		`TlsConfig:` + strings.Replace(this.TlsConfig.String(), "CDNTLSConfig", "CDNTLSConfig", 1) + `,`,
		`TlsCertificates:` + repeatedStringForTlsCertificates + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNHTTPSCustomCertsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNHTTPSCustomCertsType{`,
		`HttpRedirect:` + fmt.Sprintf("%v", this.HttpRedirect) + `,`,
		`AddHsts:` + fmt.Sprintf("%v", this.AddHsts) + `,`,
		`TlsParameters:` + strings.Replace(this.TlsParameters.String(), "CDNDownstreamTlsParamsType", "CDNDownstreamTlsParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsInfo := "[]*DnsInfo{"
	for _, f := range this.DnsInfo {
		repeatedStringForDnsInfo += strings.Replace(fmt.Sprintf("%v", f), "DnsInfo", "virtual_host_dns_info.DnsInfo", 1) + ","
	}
	repeatedStringForDnsInfo += "}"
	repeatedStringForServiceDomains := "[]*ServiceDomain{"
	for _, f := range this.ServiceDomains {
		repeatedStringForServiceDomains += strings.Replace(fmt.Sprintf("%v", f), "ServiceDomain", "virtual_host.ServiceDomain", 1) + ","
	}
	repeatedStringForServiceDomains += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`LoadbalancerType:` + fmt.Sprintf("%v", this.LoadbalancerType) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`MoreOption:` + strings.Replace(this.MoreOption.String(), "AdvancedOptionsType", "AdvancedOptionsType", 1) + `,`,
		`OriginPool:` + strings.Replace(this.OriginPool.String(), "CdnOriginPoolType", "CdnOriginPoolType", 1) + `,`,
		`ViewInternal:` + strings.Replace(fmt.Sprintf("%v", this.ViewInternal), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`DnsInfo:` + repeatedStringForDnsInfo + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`AutoCertState:` + fmt.Sprintf("%v", this.AutoCertState) + `,`,
		`AutoCertInfo:` + strings.Replace(fmt.Sprintf("%v", this.AutoCertInfo), "AutoCertInfoType", "virtual_host.AutoCertInfoType", 1) + `,`,
		`ServiceDomains:` + repeatedStringForServiceDomains + `,`,
		`CertState:` + fmt.Sprintf("%v", this.CertState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ProxyTypeHttp", "http_loadbalancer.ProxyTypeHttp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_HttpsAutoCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_HttpsAutoCert{`,
		`HttpsAutoCert:` + strings.Replace(fmt.Sprintf("%v", this.HttpsAutoCert), "CDNHTTPSAutoCertsType", "CDNHTTPSAutoCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Https) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Https{`,
		`Https:` + strings.Replace(fmt.Sprintf("%v", this.Https), "CDNHTTPSCustomCertsType", "CDNHTTPSCustomCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpFilteringOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpFilteringOptions{`,
		`IpFilteringType:` + fmt.Sprintf("%v", this.IpFilteringType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpFilteringOptions_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpFilteringOptions_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpFilteringOptions_BlockList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpFilteringOptions_BlockList{`,
		`BlockList:` + strings.Replace(fmt.Sprintf("%v", this.BlockList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoFilteringOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoFilteringOptions{`,
		`GeoFilteringType:` + fmt.Sprintf("%v", this.GeoFilteringType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoFilteringOptions_AllowList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoFilteringOptions_AllowList{`,
		`AllowList:` + strings.Replace(fmt.Sprintf("%v", this.AllowList), "CountryCodeList", "policy.CountryCodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoFilteringOptions_BlockList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoFilteringOptions_BlockList{`,
		`BlockList:` + strings.Replace(fmt.Sprintf("%v", this.BlockList), "CountryCodeList", "policy.CountryCodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogHeaderOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogHeaderOptions{`,
		`HeaderList:` + fmt.Sprintf("%v", this.HeaderList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCustomAuthentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNCustomAuthentication{`,
		`CustomAuthConfig:` + fmt.Sprintf("%v", this.CustomAuthConfig) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationOptions{`,
		`AuthOptions:` + fmt.Sprintf("%v", this.AuthOptions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationOptions_DisableAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationOptions_DisableAuth{`,
		`DisableAuth:` + strings.Replace(fmt.Sprintf("%v", this.DisableAuth), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationOptions_Jwt) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationOptions_Jwt{`,
		`Jwt:` + strings.Replace(fmt.Sprintf("%v", this.Jwt), "JwtTokenAuthOptions", "policy.JwtTokenAuthOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthenticationOptions_Custom) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthenticationOptions_Custom{`,
		`Custom:` + strings.Replace(fmt.Sprintf("%v", this.Custom), "CDNCustomAuthentication", "CDNCustomAuthentication", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNOriginServerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNOriginServerType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNOriginServerType_PublicIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNOriginServerType_PublicIp{`,
		`PublicIp:` + strings.Replace(fmt.Sprintf("%v", this.PublicIp), "OriginServerPublicIP", "origin_pool.OriginServerPublicIP", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNOriginServerType_PublicName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNOriginServerType_PublicName{`,
		`PublicName:` + strings.Replace(fmt.Sprintf("%v", this.PublicName), "OriginServerPublicName", "origin_pool.OriginServerPublicName", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CdnOriginPoolType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOriginServers := "[]*CDNOriginServerType{"
	for _, f := range this.OriginServers {
		repeatedStringForOriginServers += strings.Replace(f.String(), "CDNOriginServerType", "CDNOriginServerType", 1) + ","
	}
	repeatedStringForOriginServers += "}"
	s := strings.Join([]string{`&CdnOriginPoolType{`,
		`PublicName:` + strings.Replace(fmt.Sprintf("%v", this.PublicName), "OriginServerPublicName", "origin_pool.OriginServerPublicName", 1) + `,`,
		`TlsChoice:` + fmt.Sprintf("%v", this.TlsChoice) + `,`,
		`OriginServers:` + repeatedStringForOriginServers + `,`,
		`FollowOriginRedirect:` + fmt.Sprintf("%v", this.FollowOriginRedirect) + `,`,
		`OriginRequestTimeout:` + fmt.Sprintf("%v", this.OriginRequestTimeout) + `,`,
		`MoreOriginOptions:` + strings.Replace(this.MoreOriginOptions.String(), "OriginAdvancedConfiguration", "OriginAdvancedConfiguration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CdnOriginPoolType_NoTls) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CdnOriginPoolType_NoTls{`,
		`NoTls:` + strings.Replace(fmt.Sprintf("%v", this.NoTls), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CdnOriginPoolType_UseTls) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CdnOriginPoolType_UseTls{`,
		`UseTls:` + strings.Replace(fmt.Sprintf("%v", this.UseTls), "UpstreamTlsParameters", "origin_pool.UpstreamTlsParameters", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OriginAdvancedConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OriginAdvancedConfiguration{`,
		`DisableByteRangeRequest:` + fmt.Sprintf("%v", this.DisableByteRangeRequest) + `,`,
		`WebsocketProxy:` + fmt.Sprintf("%v", this.WebsocketProxy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`LoadbalancerType:` + fmt.Sprintf("%v", this.LoadbalancerType) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`MoreOption:` + strings.Replace(this.MoreOption.String(), "AdvancedOptionsType", "AdvancedOptionsType", 1) + `,`,
		`OriginPool:` + strings.Replace(this.OriginPool.String(), "CdnOriginPoolType", "CdnOriginPoolType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ProxyTypeHttp", "http_loadbalancer.ProxyTypeHttp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_HttpsAutoCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_HttpsAutoCert{`,
		`HttpsAutoCert:` + strings.Replace(fmt.Sprintf("%v", this.HttpsAutoCert), "CDNHTTPSAutoCertsType", "CDNHTTPSAutoCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Https) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Https{`,
		`Https:` + strings.Replace(fmt.Sprintf("%v", this.Https), "CDNHTTPSCustomCertsType", "CDNHTTPSCustomCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`LoadbalancerType:` + fmt.Sprintf("%v", this.LoadbalancerType) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`MoreOption:` + strings.Replace(this.MoreOption.String(), "AdvancedOptionsType", "AdvancedOptionsType", 1) + `,`,
		`OriginPool:` + strings.Replace(this.OriginPool.String(), "CdnOriginPoolType", "CdnOriginPoolType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ProxyTypeHttp", "http_loadbalancer.ProxyTypeHttp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_HttpsAutoCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_HttpsAutoCert{`,
		`HttpsAutoCert:` + strings.Replace(fmt.Sprintf("%v", this.HttpsAutoCert), "CDNHTTPSAutoCertsType", "CDNHTTPSAutoCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Https) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Https{`,
		`Https:` + strings.Replace(fmt.Sprintf("%v", this.Https), "CDNHTTPSCustomCertsType", "CDNHTTPSCustomCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsInfo := "[]*DnsInfo{"
	for _, f := range this.DnsInfo {
		repeatedStringForDnsInfo += strings.Replace(fmt.Sprintf("%v", f), "DnsInfo", "virtual_host_dns_info.DnsInfo", 1) + ","
	}
	repeatedStringForDnsInfo += "}"
	repeatedStringForServiceDomains := "[]*ServiceDomain{"
	for _, f := range this.ServiceDomains {
		repeatedStringForServiceDomains += strings.Replace(fmt.Sprintf("%v", f), "ServiceDomain", "virtual_host.ServiceDomain", 1) + ","
	}
	repeatedStringForServiceDomains += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`LoadbalancerType:` + fmt.Sprintf("%v", this.LoadbalancerType) + `,`,
		`AddLocation:` + fmt.Sprintf("%v", this.AddLocation) + `,`,
		`MoreOption:` + strings.Replace(this.MoreOption.String(), "AdvancedOptionsType", "AdvancedOptionsType", 1) + `,`,
		`OriginPool:` + strings.Replace(this.OriginPool.String(), "CdnOriginPoolType", "CdnOriginPoolType", 1) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`DnsInfo:` + repeatedStringForDnsInfo + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`AutoCertInfo:` + strings.Replace(fmt.Sprintf("%v", this.AutoCertInfo), "AutoCertInfoType", "virtual_host.AutoCertInfoType", 1) + `,`,
		`ServiceDomains:` + repeatedStringForServiceDomains + `,`,
		`CertState:` + fmt.Sprintf("%v", this.CertState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Http{`,
		`Http:` + strings.Replace(fmt.Sprintf("%v", this.Http), "ProxyTypeHttp", "http_loadbalancer.ProxyTypeHttp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_HttpsAutoCert) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_HttpsAutoCert{`,
		`HttpsAutoCert:` + strings.Replace(fmt.Sprintf("%v", this.HttpsAutoCert), "CDNHTTPSAutoCertsType", "CDNHTTPSAutoCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Https) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Https{`,
		`Https:` + strings.Replace(fmt.Sprintf("%v", this.Https), "CDNHTTPSCustomCertsType", "CDNHTTPSCustomCertsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNMetricsFilter{`,
		`Tag:` + fmt.Sprintf("%v", this.Tag) + `,`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`Operator:` + fmt.Sprintf("%v", this.Operator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsResponseGroupBy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNMetricsResponseGroupBy{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsResponseValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNMetricsResponseValue{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsResponseSeries) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGroupBy := "[]*LilacCDNMetricsResponseGroupBy{"
	for _, f := range this.GroupBy {
		repeatedStringForGroupBy += strings.Replace(f.String(), "LilacCDNMetricsResponseGroupBy", "LilacCDNMetricsResponseGroupBy", 1) + ","
	}
	repeatedStringForGroupBy += "}"
	repeatedStringForValue := "[]*LilacCDNMetricsResponseValue{"
	for _, f := range this.Value {
		repeatedStringForValue += strings.Replace(f.String(), "LilacCDNMetricsResponseValue", "LilacCDNMetricsResponseValue", 1) + ","
	}
	repeatedStringForValue += "}"
	s := strings.Join([]string{`&LilacCDNMetricsResponseSeries{`,
		`GroupBy:` + repeatedStringForGroupBy + `,`,
		`Value:` + repeatedStringForValue + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNMetricsResponseData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSeries := "[]*LilacCDNMetricsResponseSeries{"
	for _, f := range this.Series {
		repeatedStringForSeries += strings.Replace(f.String(), "LilacCDNMetricsResponseSeries", "LilacCDNMetricsResponseSeries", 1) + ","
	}
	repeatedStringForSeries += "}"
	s := strings.Join([]string{`&LilacCDNMetricsResponseData{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`Series:` + repeatedStringForSeries + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ProxyTypeHttpsAutoCerts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyTypeHttpsAutoCerts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyTypeHttpsAutoCerts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpRedirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HttpRedirect = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHsts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddHsts = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsConfig == nil {
				m.TlsConfig = &views.TlsConfig{}
			}
			if err := m.TlsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &ProxyTypeHttpsAutoCerts_DefaultHeader{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &ProxyTypeHttpsAutoCerts_ServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerHeaderChoice = &ProxyTypeHttpsAutoCerts_AppendServerName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassThrough", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServerHeaderChoice = &ProxyTypeHttpsAutoCerts_PassThrough{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderControlType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderControlType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderControlType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToAdd = append(m.RequestHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.RequestHeadersToAdd[len(m.RequestHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHeadersToRemove = append(m.RequestHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToAdd = append(m.ResponseHeadersToAdd, &schema.HeaderManipulationOptionType{})
			if err := m.ResponseHeadersToAdd[len(m.ResponseHeadersToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeadersToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseHeadersToRemove = append(m.ResponseHeadersToRemove, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFiltering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpFiltering == nil {
				m.IpFiltering = &IpFilteringOptions{}
			}
			if err := m.IpFiltering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoFiltering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoFiltering == nil {
				m.GeoFiltering = &GeoFilteringOptions{}
			}
			if err := m.GeoFiltering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthOptions == nil {
				m.AuthOptions = &AuthenticationOptions{}
			}
			if err := m.AuthOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggingOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggingOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggingOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLogOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientLogOptions == nil {
				m.ClientLogOptions = &LogHeaderOptions{}
			}
			if err := m.ClientLogOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginLogOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginLogOptions == nil {
				m.OriginLogOptions = &LogHeaderOptions{}
			}
			if err := m.OriginLogOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNCacheRuleExpressionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNCacheRuleExpressionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNCacheRuleExpressionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheRuleExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheRuleExpression = append(m.CacheRuleExpression, &CDNCacheRuleExpression{})
			if err := m.CacheRuleExpression[len(m.CacheRuleExpression)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_Equals{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoesNotEqual", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_DoesNotEqual{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_Contains{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoesNotContain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_DoesNotContain{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Startswith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_Startswith{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoesNotStartWith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_DoesNotStartWith{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endswith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_Endswith{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoesNotEndWith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_DoesNotEndWith{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_MatchRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheHeaderMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheHeaderMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheHeaderMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			m.Name = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Name |= HeaderOptions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operator == nil {
				m.Operator = &CacheOperator{}
			}
			if err := m.Operator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNPathMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNPathMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNPathMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operator == nil {
				m.Operator = &CacheOperator{}
			}
			if err := m.Operator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheCookieMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheCookieMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheCookieMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operator == nil {
				m.Operator = &CacheOperator{}
			}
			if err := m.Operator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheQueryParameterMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheQueryParameterMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheQueryParameterMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operator == nil {
				m.Operator = &CacheOperator{}
			}
			if err := m.Operator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNCacheRuleExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNCacheRuleExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNCacheRuleExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PathMatch == nil {
				m.PathMatch = &CDNPathMatcherType{}
			}
			if err := m.PathMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheHeaders = append(m.CacheHeaders, &CacheHeaderMatcherType{})
			if err := m.CacheHeaders[len(m.CacheHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParameters = append(m.QueryParameters, &CacheQueryParameterMatcherType{})
			if err := m.QueryParameters[len(m.QueryParameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatcher = append(m.CookieMatcher, &CacheCookieMatcherType{})
			if err := m.CookieMatcher[len(m.CookieMatcher)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheTTLEnableProps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheTTLEnableProps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheTTLEnableProps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheTtl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheOverride = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreResponseCookie", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreResponseCookie = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheEligibleOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheEligibleOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheEligibleOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemeHostnameUri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheTTLEnableProps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EligibleForCache = &CacheEligibleOptions_SchemeHostnameUri{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemeHostnameRequestUri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheTTLEnableProps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EligibleForCache = &CacheEligibleOptions_SchemeHostnameRequestUri{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostnameUri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheTTLEnableProps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EligibleForCache = &CacheEligibleOptions_HostnameUri{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemeHostnameUriQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheTTLEnableProps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EligibleForCache = &CacheEligibleOptions_SchemeHostnameUriQuery{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemeProxyHostUri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheTTLEnableProps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EligibleForCache = &CacheEligibleOptions_SchemeProxyHostUri{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemeProxyHostRequestUri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheTTLEnableProps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EligibleForCache = &CacheEligibleOptions_SchemeProxyHostRequestUri{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNCacheRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNCacheRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNCacheRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleExpressionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleExpressionList = append(m.RuleExpressionList, &CDNCacheRuleExpressionList{})
			if err := m.RuleExpressionList[len(m.RuleExpressionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CacheActions = &CDNCacheRule_CacheBypass{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EligibleForCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheEligibleOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CacheActions = &CDNCacheRule_EligibleForCache{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultCacheTTLProps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultCacheTTLProps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultCacheTTLProps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheTtl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultCacheAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultCacheAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultCacheAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EligibleForCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DefaultCacheTTLProps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CacheActions = &DefaultCacheAction_EligibleForCache{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtlDefault", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheActions = &DefaultCacheAction_CacheTtlDefault{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtlOverride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheActions = &DefaultCacheAction_CacheTtlOverride{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CacheActions = &DefaultCacheAction_CacheDisabled{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultCacheAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultCacheAction == nil {
				m.DefaultCacheAction = &DefaultCacheAction{}
			}
			if err := m.DefaultCacheAction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheRules = append(m.CacheRules, &CDNCacheRule{})
			if err := m.CacheRules[len(m.CacheRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheTTLOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheTTLOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheTTLOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtlDefault", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TtlOptions = &CacheTTLOptionsType_CacheTtlDefault{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtlOverride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TtlOptions = &CacheTTLOptionsType_CacheTtlOverride{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TtlOptions = &CacheTTLOptionsType_CacheDisabled{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvancedOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvancedOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvancedOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeaderOptions == nil {
				m.HeaderOptions = &HeaderControlType{}
			}
			if err := m.HeaderOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityOptions == nil {
				m.SecurityOptions = &SecurityOptionsType{}
			}
			if err := m.SecurityOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoggingOptions == nil {
				m.LoggingOptions = &LoggingOptionsType{}
			}
			if err := m.LoggingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtlOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheTtlOptions == nil {
				m.CacheTtlOptions = &CacheTTLOptionsType{}
			}
			if err := m.CacheTtlOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheOptions == nil {
				m.CacheOptions = &CacheOptions{}
			}
			if err := m.CacheOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNTLSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNTLSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNTLSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls_12Plus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CDNTLSConfig_Tls_12Plus{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls_11Plus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CDNTLSConfig_Tls_11Plus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNHTTPSAutoCertsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNHTTPSAutoCertsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNHTTPSAutoCertsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpRedirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HttpRedirect = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHsts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddHsts = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsConfig == nil {
				m.TlsConfig = &CDNTLSConfig{}
			}
			if err := m.TlsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNDownstreamTlsParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNDownstreamTlsParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNDownstreamTlsParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsConfig == nil {
				m.TlsConfig = &CDNTLSConfig{}
			}
			if err := m.TlsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertificates = append(m.TlsCertificates, &schema.TlsCertificateType{})
			if err := m.TlsCertificates[len(m.TlsCertificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNHTTPSCustomCertsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNHTTPSCustomCertsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNHTTPSCustomCertsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpRedirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HttpRedirect = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHsts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddHsts = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsParameters == nil {
				m.TlsParameters = &CDNDownstreamTlsParamsType{}
			}
			if err := m.TlsParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GlobalSpecType_Http{v}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoreOption == nil {
				m.MoreOption = &AdvancedOptionsType{}
			}
			if err := m.MoreOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginPool == nil {
				m.OriginPool = &CdnOriginPoolType{}
			}
			if err := m.OriginPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsAutoCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSAutoCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GlobalSpecType_HttpsAutoCert{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Https", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSCustomCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GlobalSpecType_Https{v}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewInternal == nil {
				m.ViewInternal = &views.ObjectRefType{}
			}
			if err := m.ViewInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsInfo = append(m.DnsInfo, &virtual_host_dns_info.DnsInfo{})
			if err := m.DnsInfo[len(m.DnsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= virtual_host.VirtualHostState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1004:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertState", wireType)
			}
			m.AutoCertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoCertState |= virtual_host.CertificationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1010:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertInfo == nil {
				m.AutoCertInfo = &virtual_host.AutoCertInfoType{}
			}
			if err := m.AutoCertInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1011:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceDomains = append(m.ServiceDomains, &virtual_host.ServiceDomain{})
			if err := m.ServiceDomains[len(m.ServiceDomains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1012:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertState", wireType)
			}
			m.CertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertState |= virtual_host.CertificationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpFilteringOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpFilteringOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpFilteringOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpFilteringType = &IpFilteringOptions_AllowList{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.PrefixMatchList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IpFilteringType = &IpFilteringOptions_BlockList{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoFilteringOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoFilteringOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoFilteringOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.CountryCodeList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GeoFilteringType = &GeoFilteringOptions_AllowList{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.CountryCodeList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GeoFilteringType = &GeoFilteringOptions_BlockList{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogHeaderOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogHeaderOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogHeaderOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderList = append(m.HeaderList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNCustomAuthentication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNCustomAuthentication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNCustomAuthentication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomAuthConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomAuthConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthOptions = &AuthenticationOptions_DisableAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &policy.JwtTokenAuthOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthOptions = &AuthenticationOptions_Jwt{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Custom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNCustomAuthentication{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthOptions = &AuthenticationOptions_Custom{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNOriginServerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNOriginServerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNOriginServerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &origin_pool.OriginServerPublicIP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CDNOriginServerType_PublicIp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &origin_pool.OriginServerPublicName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CDNOriginServerType_PublicName{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CdnOriginPoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CdnOriginPoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CdnOriginPoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicName == nil {
				m.PublicName = &origin_pool.OriginServerPublicName{}
			}
			if err := m.PublicName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoTls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsChoice = &CdnOriginPoolType_NoTls{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &origin_pool.UpstreamTlsParameters{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsChoice = &CdnOriginPoolType_UseTls{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginServers = append(m.OriginServers, &CDNOriginServerType{})
			if err := m.OriginServers[len(m.OriginServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowOriginRedirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FollowOriginRedirect = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginRequestTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginRequestTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreOriginOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoreOriginOptions == nil {
				m.MoreOriginOptions = &OriginAdvancedConfiguration{}
			}
			if err := m.MoreOriginOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OriginAdvancedConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OriginAdvancedConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OriginAdvancedConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableByteRangeRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableByteRangeRequest = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebsocketProxy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WebsocketProxy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &CreateSpecType_Http{v}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoreOption == nil {
				m.MoreOption = &AdvancedOptionsType{}
			}
			if err := m.MoreOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginPool == nil {
				m.OriginPool = &CdnOriginPoolType{}
			}
			if err := m.OriginPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsAutoCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSAutoCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &CreateSpecType_HttpsAutoCert{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Https", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSCustomCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &CreateSpecType_Https{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &ReplaceSpecType_Http{v}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoreOption == nil {
				m.MoreOption = &AdvancedOptionsType{}
			}
			if err := m.MoreOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginPool == nil {
				m.OriginPool = &CdnOriginPoolType{}
			}
			if err := m.OriginPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsAutoCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSAutoCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &ReplaceSpecType_HttpsAutoCert{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Https", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSCustomCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &ReplaceSpecType_Https{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &http_loadbalancer.ProxyTypeHttp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GetSpecType_Http{v}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLocation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddLocation = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MoreOption == nil {
				m.MoreOption = &AdvancedOptionsType{}
			}
			if err := m.MoreOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginPool == nil {
				m.OriginPool = &CdnOriginPoolType{}
			}
			if err := m.OriginPool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsAutoCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSAutoCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GetSpecType_HttpsAutoCert{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Https", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CDNHTTPSCustomCertsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LoadbalancerType = &GetSpecType_Https{v}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsInfo = append(m.DnsInfo, &virtual_host_dns_info.DnsInfo{})
			if err := m.DnsInfo[len(m.DnsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= virtual_host.VirtualHostState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1010:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoCertInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoCertInfo == nil {
				m.AutoCertInfo = &virtual_host.AutoCertInfoType{}
			}
			if err := m.AutoCertInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1011:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceDomains = append(m.ServiceDomains, &virtual_host.ServiceDomain{})
			if err := m.ServiceDomains[len(m.ServiceDomains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1012:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertState", wireType)
			}
			m.CertState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertState |= virtual_host.CertificationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= LilacCDNMetricsTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			m.Operator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operator |= LilacCDNMetricsOperatorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsResponseGroupBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseGroupBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseGroupBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			m.Name = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Name |= LilacCDNMetricsTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsResponseValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsResponseSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &LilacCDNMetricsResponseGroupBy{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &LilacCDNMetricsResponseValue{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNMetricsResponseData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNMetricsResponseData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LilacCDNMetricsFieldSelector(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= LilacCDNMetricUnit(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, &LilacCDNMetricsResponseSeries{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
