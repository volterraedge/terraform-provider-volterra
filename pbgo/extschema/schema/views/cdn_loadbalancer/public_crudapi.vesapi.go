// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package cdn_loadbalancer

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"

	google_protobuf "github.com/gogo/protobuf/types"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	multierror "github.com/hashicorp/go-multierror"
	"go.uber.org/zap"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/client/configapi"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

const (
	// CreateRequestFQN is the fully-qualified-name of the CreateRequest message
	CreateRequestFQN = "ves.io.schema.views.cdn_loadbalancer.CreateRequest"
	// CreateResponseFQN is the fully-qualified-name of the CreateResponse message
	CreateResponseFQN = "ves.io.schema.views.cdn_loadbalancer.CreateResponse"
	// ReplaceRequestFQN is the fully-qualified-name of the ReplaceRequest message
	ReplaceRequestFQN = "ves.io.schema.views.cdn_loadbalancer.ReplaceRequest"
	// ReplaceResponseFQN is the fully-qualified-name of the ReplaceResponse message
	ReplaceResponseFQN = "ves.io.schema.views.cdn_loadbalancer.ReplaceResponse"
	// GetRequestFQN is the fully-qualified-name of the GetRequest message
	GetRequestFQN = "ves.io.schema.views.cdn_loadbalancer.GetRequest"
	// GetResponseFQN is the fully-qualified-name of the GetResponse message
	GetResponseFQN = "ves.io.schema.views.cdn_loadbalancer.GetResponse"
	// ListRequestFQN is the fully-qualified-name of the ListRequest message
	ListRequestFQN = "ves.io.schema.views.cdn_loadbalancer.ListRequest"
	// ListResponseFQN is the fully-qualified-name of the ListResponse message
	ListResponseFQN = "ves.io.schema.views.cdn_loadbalancer.ListResponse"
	// DeleteRequestFQN is the fully-qualified-name of the DeleteRequest message
	DeleteRequestFQN = "ves.io.schema.views.cdn_loadbalancer.DeleteRequest"
	// DeleteResponseFQN is the fully-qualified-name of the DeleteResponse message
	DeleteResponseFQN = "ves.io.schema.views.cdn_loadbalancer.DeleteResponse"
)

// CLIENT side
func NewCreateRequest(e db.Entry) (*CreateRequest, error) {
	r := &CreateRequest{}
	if e == nil {
		return r, nil
	}
	r.FromObject(e)
	return r, nil
}

func NewReplaceRequest(e db.Entry) (*ReplaceRequest, error) {
	r := &ReplaceRequest{}
	if e == nil {
		return r, nil
	}
	r.FromObject(e)
	return r, nil
}

func NewGetRequest(key string, opts ...server.CRUDCallOpt) (*GetRequest, error) {
	strs := strings.Split(key, "/")
	if len(strs) != 2 {
		return nil, fmt.Errorf("key must have namespace and name separated by /, but found %s", key)
	}
	ccOpts := server.NewCRUDCallOpts()
	for _, o := range opts {
		o(ccOpts)
	}
	var rspFmt GetResponseFormatCode
	switch ccOpts.ResponseFormat {
	case server.DefaultForm:
		rspFmt = GET_RSP_FORMAT_DEFAULT
	case server.CreateRequestForm:
		rspFmt = GET_RSP_FORMAT_FOR_CREATE
	case server.ReplaceRequestForm:
		rspFmt = GET_RSP_FORMAT_FOR_REPLACE
	case server.StatusForm:
		rspFmt = GET_RSP_FORMAT_STATUS
	case server.GetSpecForm:
		rspFmt = GET_RSP_FORMAT_READ
	case server.BrokenRefsForm:
		rspFmt = GET_RSP_FORMAT_BROKEN_REFERENCES
	default:
		return nil, fmt.Errorf("Unsupported Response Format %s", ccOpts.ResponseFormat)
	}
	return &GetRequest{Namespace: strs[0], Name: strs[1], ResponseFormat: rspFmt}, nil
}
func (m *GetRequest) ResponseFormatString() string {
	return m.GetResponseFormat().String()
}

func NewListRequest(opts ...server.CRUDCallOpt) *ListRequest {
	ccOpts := server.NewCRUDCallOpts()
	for _, o := range opts {
		o(ccOpts)
	}
	return &ListRequest{Namespace: ccOpts.Namespace}
}

func NewDeleteRequest(key string) (*DeleteRequest, error) {
	strs := strings.Split(key, "/")
	if len(strs) != 2 {
		return nil, fmt.Errorf("key must have namespace and name separated by /, but found %s", key)
	}
	return &DeleteRequest{Namespace: strs[0], Name: strs[1]}, nil
}

// GRPC Client
type crudAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient APIClient
}

func (c *crudAPIGrpcClient) Create(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) (db.Entry, error) {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	var req *CreateRequest
	if cco.RequestProto != nil {
		r, ok := cco.RequestProto.(*CreateRequest)
		if !ok {
			return nil, fmt.Errorf("%T is not *CreateRequest", cco.RequestProto)
		}
		req = r
	} else {
		r, err := NewCreateRequest(e)
		if err != nil {
			return nil, errors.Wrap(err, "Create")
		}
		req = r
		if cco.ObjToMsgConverter != nil {
			if err := cco.ObjToMsgConverter(e, req); err != nil {
				return nil, err
			}
		}
	}

	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := c.grpcClient.Create(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return nil, err
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	obj := NewDBObject(nil)
	rsp.ToObject(obj)
	if cco.MsgToObjConverter != nil {
		if err := cco.MsgToObjConverter(rsp, obj); err != nil {
			return nil, err
		}
	}
	return obj, nil

}

func (c *crudAPIGrpcClient) Replace(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) error {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	var req *ReplaceRequest
	if cco.RequestProto != nil {
		r, ok := cco.RequestProto.(*ReplaceRequest)
		if !ok {
			return fmt.Errorf("%T is not *ReplaceRequest", cco.RequestProto)
		}
		req = r
	} else {
		r, err := NewReplaceRequest(e)
		if err != nil {
			return errors.Wrap(err, "Replace")
		}
		req = r
		if cco.ObjToMsgConverter != nil {
			if err := cco.ObjToMsgConverter(e, req); err != nil {
				return err
			}
		}
	}

	ctx = client.AddHdrsToCtx(cco.Headers, ctx)
	req.ResourceVersion = cco.ResourceVersion

	rsp, err := c.grpcClient.Replace(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return err
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return nil

}

func (c *crudAPIGrpcClient) GetRaw(ctx context.Context, key string, opts ...server.CRUDCallOpt) (*GetResponse, error) {
	req, err := NewGetRequest(key, opts...)
	if err != nil {
		return nil, errors.Wrap(err, "Get")
	}
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := c.grpcClient.Get(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return nil, err
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rsp.ResourceVersion
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func (c *crudAPIGrpcClient) Get(ctx context.Context, key string, opts ...server.CRUDCallOpt) (db.Entry, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	if gRsp != nil {
		obj := NewDBObject(nil)
		gRsp.ToObject(obj)
		return obj, err
	}
	return nil, err

}

func (c *crudAPIGrpcClient) GetDetail(ctx context.Context, key string, nef db.NewEntryFunc, opts ...server.CRUDCallOpt) (*server.GetResponse, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	respDetail := server.GetResponse{}
	if gRsp != nil {
		respDetail.Entry = NewDBObject(nil)
		gRsp.ToObject(respDetail.Entry)
		for _, status := range gRsp.Status {
			respDetail.BackRefs = append(respDetail.BackRefs, NewDBStatusObject(status))
		}

		return &respDetail, err
	}
	return nil, err

}

func (c *crudAPIGrpcClient) ListIDs(ctx context.Context, opts ...server.CRUDCallOpt) ([]string, error) {

	idSet := []string{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return idSet, err
	}
	for _, li := range listRsp.GetItems() {
		idSet = append(idSet, li.GetUid())
	}
	return idSet, err

}

func (c *crudAPIGrpcClient) ListItems(ctx context.Context, opts ...server.CRUDCallOpt) ([]server.ListItem, error) {

	sliSet := []server.ListItem{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return sliSet, err
	}
	for _, li := range listRsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err

}

func (c *crudAPIGrpcClient) List(ctx context.Context, opts ...server.CRUDCallOpt) (*ListResponse, error) {
	req := NewListRequest(opts...)

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		req.LabelFilter = cco.LabelFilter[0]
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}
	req.ReportFields = cco.ReportFields
	req.ReportStatusFields = cco.ReportStatusFields
	rsp, err := c.grpcClient.List(ctx, req, cco.GrpcCallOpts...)
	if err != nil {
		return nil, err
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func (c *crudAPIGrpcClient) ListStream(ctx context.Context, opts ...server.CRUDCallOpt) (server.ListStreamRsp, error) {
	return nil, fmt.Errorf("Not implemented")
}

func (c *crudAPIGrpcClient) Delete(ctx context.Context, key string, opts ...server.CRUDCallOpt) error {

	req, err := NewDeleteRequest(key)
	if err != nil {
		return errors.Wrap(err, "Delete")
	}

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := c.grpcClient.Delete(ctx, req, cco.GrpcCallOpts...)
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err

}

func NewCRUDAPIGrpcClient(cc *grpc.ClientConn) server.CRUDClient {
	ccl := &crudAPIGrpcClient{cc, NewAPIClient(cc)}
	return ccl
}

// REST Client
type crudAPIRestClient struct {
	baseURL string
	client  http.Client
}

func (c *crudAPIRestClient) Create(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) (db.Entry, error) {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	got := 0
	if e != nil {
		got++
	}
	if cco.RequestProto != nil {
		got++
	}
	if cco.RequestJSON != "" {
		got++
	}
	if got != 1 {
		return nil, fmt.Errorf("Only one of entry(%v), WithRequestProto()(%v) or WithRequestJSON()(%v) should be specified", e, cco.RequestProto, cco.RequestJSON)
	}

	var jsn string
	if cco.RequestJSON != "" {
		jsn = cco.RequestJSON
	} else {
		var req *CreateRequest
		if cco.RequestProto != nil {
			r, ok := cco.RequestProto.(*CreateRequest)
			if !ok {
				return nil, fmt.Errorf("%T is not *CreateRequest", cco.RequestProto)
			}
			req = r
		} else {
			r, err := NewCreateRequest(e)
			if err != nil {
				return nil, errors.Wrap(err, "Creating new create request")
			}
			req = r
			if cco.ObjToMsgConverter != nil {
				if err := cco.ObjToMsgConverter(e, req); err != nil {
					return nil, err
				}
			}
		}

		j, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "RestClient Create")
		}
		jsn = j
	}

	var namespace string
	reqMap := make(map[string]interface{})
	if err := json.Unmarshal([]byte(jsn), &reqMap); err != nil {
		return nil, errors.Wrapf(err, "Unmarshaling json to find namespace/name")
	}
	md, ok := reqMap["metadata"].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("Request %s does not have 'metadata'", jsn)
	}
	if val, ok := md["namespace"].(string); ok {
		namespace = val
	} else {
		return nil, fmt.Errorf("Request %s does not have 'metadata.namespace'", jsn)
	}

	url := fmt.Sprintf("%s/public/namespaces/%s/cdn_loadbalancers", c.baseURL, namespace)

	hReq, err := http.NewRequest("POST", url, bytes.NewBuffer([]byte(jsn)))
	if err != nil {
		return nil, err
	}
	hReq = hReq.WithContext(ctx)

	client.AddHdrsToReq(cco.Headers, hReq)
	hReq.Header.Set("Content-Type", "application/json")

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()
	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return nil, fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return nil, fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}
	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient create")
	}

	rspo := &CreateResponse{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return nil, errors.Wrap(err, "Converting json to response protobuf message")
	}
	configapi.TranscribeCall(ctx, jsn, string(body))
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}

	obj := NewDBObject(nil)
	rspo.ToObject(obj)
	if cco.MsgToObjConverter != nil {
		if err := cco.MsgToObjConverter(rspo, obj); err != nil {
			return nil, err
		}
	}
	return obj, nil

}

func (c *crudAPIRestClient) Replace(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) error {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	got := 0
	if e != nil {
		got++
	}
	if cco.RequestProto != nil {
		got++
	}
	if cco.RequestJSON != "" {
		got++
	}
	if got != 1 {
		return fmt.Errorf("Only one of entry(%v), WithRequestProto()(%v) or WithRequestJSON()(%v) should be specified", e, cco.RequestProto, cco.RequestJSON)
	}

	var jsn string
	if cco.RequestJSON != "" {
		jsn = cco.RequestJSON
	} else {
		var rReq *ReplaceRequest
		if cco.RequestProto != nil {
			r, ok := cco.RequestProto.(*ReplaceRequest)
			if !ok {
				return fmt.Errorf("%T is not *ReplaceRequest", cco.RequestProto)
			}
			rReq = r
		} else {
			r, err := NewReplaceRequest(e)
			if err != nil {
				return errors.Wrap(err, "Creating new replace request")
			}
			rReq = r
			if cco.ObjToMsgConverter != nil {
				if err := cco.ObjToMsgConverter(e, rReq); err != nil {
					return err
				}
			}
		}

		rReq.ResourceVersion = cco.ResourceVersion
		j, err := codec.ToJSON(rReq, codec.ToWithUseProtoFieldName())
		if err != nil {
			return errors.Wrap(err, "RestClient Replace")
		}
		jsn = j
	}

	var namespace, name string
	_ = namespace
	reqMap := make(map[string]interface{})
	if err := json.Unmarshal([]byte(jsn), &reqMap); err != nil {
		return errors.Wrapf(err, "Unmarshaling json to find namespace/name")
	}
	md, ok := reqMap["metadata"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("Request %s does not have 'metadata'", jsn)
	}

	if val, ok := md["namespace"].(string); ok {
		namespace = val
	} else {
		return fmt.Errorf("Request %s does not have 'metadata.namespace'", jsn)
	}

	if val, ok := md["name"].(string); ok {
		name = val
	} else {
		return fmt.Errorf("Request %s does not have 'metadata.name'", jsn)
	}

	url := fmt.Sprintf("%s/public/namespaces/%s/cdn_loadbalancers/%s", c.baseURL, namespace, name)

	hReq, err := http.NewRequest(http.MethodPut, url, bytes.NewBuffer([]byte(jsn)))
	if err != nil {
		return errors.Wrap(err, "RestClient replace")
	}
	hReq = hReq.WithContext(ctx)
	client.AddHdrsToReq(cco.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return err
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return fmt.Errorf("Unsuccessful PUT at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}

	if _, err := io.ReadAll(rsp.Body); err != nil {
		return errors.Wrap(err, "RestClient replace")
	}

	configapi.TranscribeCall(ctx, jsn, nil)
	return nil

}

func (c *crudAPIRestClient) GetRaw(ctx context.Context, key string, opts ...server.CRUDCallOpt) (*GetResponse, error) {
	req, err := NewGetRequest(key, opts...)
	if err != nil {
		return nil, errors.Wrap(err, "Get")
	}

	url := fmt.Sprintf("%s/public/namespaces/%s/cdn_loadbalancers/%s", c.baseURL, req.Namespace, req.Name)
	hReq, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	hReq = hReq.WithContext(ctx)

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	client.AddHdrsToReq(cco.Headers, hReq)

	q := hReq.URL.Query()
	q.Add("response_format", fmt.Sprintf("%d", req.ResponseFormat))
	hReq.URL.RawQuery += q.Encode()

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()
	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return nil, fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return nil, fmt.Errorf("Unsuccessful GET at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}
	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient Get")
	}

	rspo := &GetResponse{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return nil, errors.Wrap(err, "Converting json to response protobuf message")
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rspo.ResourceVersion
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}
	configapi.TranscribeCall(ctx, req, rspo)
	return rspo, nil
}

func (c *crudAPIRestClient) Get(ctx context.Context, key string, opts ...server.CRUDCallOpt) (db.Entry, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	if gRsp != nil {
		obj := NewDBObject(nil)
		gRsp.ToObject(obj)
		return obj, err
	}
	return nil, err

}

func (c *crudAPIRestClient) GetDetail(ctx context.Context, key string, nef db.NewEntryFunc, opts ...server.CRUDCallOpt) (*server.GetResponse, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	respDetail := server.GetResponse{}
	if gRsp != nil {
		respDetail.Entry = NewDBObject(nil)
		gRsp.ToObject(respDetail.Entry)
		for _, status := range gRsp.Status {
			respDetail.BackRefs = append(respDetail.BackRefs, NewDBStatusObject(status))
		}

		return &respDetail, err
	}

	return nil, err

}

func (c *crudAPIRestClient) ListIDs(ctx context.Context, opts ...server.CRUDCallOpt) ([]string, error) {

	idSet := []string{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return idSet, err
	}
	for _, li := range listRsp.GetItems() {
		idSet = append(idSet, li.GetUid())
	}
	return idSet, err

}

func (c *crudAPIRestClient) ListItems(ctx context.Context, opts ...server.CRUDCallOpt) ([]server.ListItem, error) {

	sliSet := []server.ListItem{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return sliSet, err
	}
	for _, li := range listRsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err

}

func (c *crudAPIRestClient) List(ctx context.Context, opts ...server.CRUDCallOpt) (*ListResponse, error) {
	req := NewListRequest(opts...)
	_ = req
	url := fmt.Sprintf("%s/public/namespaces/%s/cdn_loadbalancers", c.baseURL, req.Namespace)

	hReq, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	hReq = hReq.WithContext(ctx)

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	client.AddHdrsToReq(cco.Headers, hReq)

	q := hReq.URL.Query()
	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		q.Add("label_filter", cco.LabelFilter[0])
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}

	for _, fName := range cco.ReportFields {
		q.Add("report_fields", fName)
	}
	for _, fName := range cco.ReportStatusFields {
		q.Add("report_status_fields", fName)
	}

	hReq.URL.RawQuery += q.Encode()
	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()
	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return nil, fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return nil, fmt.Errorf("Unsuccessful List at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}
	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "RestClient List")
	}

	rspo := &ListResponse{}
	if err := codec.FromJSON(string(body), rspo); err != nil {
		return nil, errors.Wrap(err, "Converting json to response protobuf message")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rspo
		cco.OutCallResponse.JSON = string(body)
	}
	configapi.TranscribeCall(ctx, req, rspo)
	return rspo, nil
}

func (c *crudAPIRestClient) ListStream(ctx context.Context, opts ...server.CRUDCallOpt) (server.ListStreamRsp, error) {
	return nil, fmt.Errorf("Not implemented")
}

func (c *crudAPIRestClient) Delete(ctx context.Context, key string, opts ...server.CRUDCallOpt) error {

	dReq, err := NewDeleteRequest(key)
	if err != nil {
		return errors.Wrap(err, "Delete")
	}

	url := fmt.Sprintf("%s/public/namespaces/%s/cdn_loadbalancers/%s", c.baseURL, dReq.Namespace, dReq.Name)
	hReq, err := http.NewRequest(http.MethodDelete, url, nil)
	if err != nil {
		return errors.Wrap(err, "RestClient delete")
	}
	hReq = hReq.WithContext(ctx)

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	client.AddHdrsToReq(cco.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return err
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(rsp.Body)
		if err != nil {
			return fmt.Errorf("Unsuccessful POST at URL %s, status code %d, body %s, err %s", url, rsp.StatusCode, body, err.Error())
		}
		return fmt.Errorf("Unsuccessful DELETE at URL %s, status code %d, body %s", url, rsp.StatusCode, body)
	}

	_, err = io.ReadAll(rsp.Body)
	if err != nil {
		return errors.Wrap(err, "RestClient delete")
	}
	configapi.TranscribeCall(ctx, dReq, nil)

	return nil

}

func NewCRUDAPIRestClient(baseURL string, cl http.Client) server.CRUDClient {
	var bURL string
	if strings.HasSuffix(baseURL, "/") {
		bURL = baseURL[:len(baseURL)-1]
	} else {
		bURL = baseURL
	}
	crcl := &crudAPIRestClient{bURL, cl}
	return crcl
}

// INPROC Client (satisfying APIClient interface)
type APIInprocClient struct {
	svc svcfw.Service
}

func (c *APIInprocClient) Create(ctx context.Context, req *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.views.cdn_loadbalancer")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.views.cdn_loadbalancer.API.Create")
	rsp, err := oah.Create(ctx, req)
	if err != nil {
		return rsp, err
	}
	return rsp, nil
}

func (c *APIInprocClient) Replace(ctx context.Context, req *ReplaceRequest, opts ...grpc.CallOption) (*ReplaceResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.views.cdn_loadbalancer")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.views.cdn_loadbalancer.API.Replace")
	if rsp, err := oah.Replace(ctx, req); err != nil {
		return rsp, err
	}
	return NewObjectReplaceRsp(nil)
}

func (c *APIInprocClient) Get(ctx context.Context, req *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.views.cdn_loadbalancer")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.views.cdn_loadbalancer.API.Get")
	rsp, err := oah.Get(ctx, req)
	if err != nil {
		return rsp, err
	}
	return rsp, nil
}

func (c *APIInprocClient) List(ctx context.Context, req *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.views.cdn_loadbalancer")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.views.cdn_loadbalancer.API.List")
	rsp, err := oah.List(ctx, req)
	if err != nil {
		return rsp, err
	}
	return rsp, nil
}

func (c *APIInprocClient) Delete(ctx context.Context, req *DeleteRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.views.cdn_loadbalancer.API")
	oah, ok := ah.(*APISrv)
	if !ok {
		err := fmt.Errorf("No CRUD Server for ves.io.schema.views.cdn_loadbalancer")
		return nil, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.views.cdn_loadbalancer.API.Delete")
	rsp, err := oah.Delete(ctx, req)
	if err != nil {
		return rsp, err
	}
	return rsp, nil
}

func NewAPIInprocClient(svc svcfw.Service) APIClient {
	return &APIInprocClient{svc: svc}
}

// INPROC CRUD Client (satisfying server.CRUDClient interface)
type crudAPIInprocClient struct {
	cl APIClient
}

func (c *crudAPIInprocClient) Create(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) (db.Entry, error) {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req, err := NewCreateRequest(e)
	if err != nil {
		return nil, errors.Wrap(err, "Creating new create request")
	}
	if cco.ObjToMsgConverter != nil {
		if err := cco.ObjToMsgConverter(e, req); err != nil {
			return nil, err
		}
	}

	rsp, err := c.cl.Create(ctx, req)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	if err != nil {
		return nil, err
	}
	obj := NewDBObject(nil)
	rsp.ToObject(obj)
	if cco.MsgToObjConverter != nil {
		if err := cco.MsgToObjConverter(rsp, obj); err != nil {
			return nil, err
		}
	}
	return obj, nil

}

func (c *crudAPIInprocClient) Replace(ctx context.Context, e db.Entry, opts ...server.CRUDCallOpt) error {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req, err := NewReplaceRequest(e)
	if err != nil {
		return errors.Wrap(err, "Creating new replace request")
	}
	if cco.ObjToMsgConverter != nil {
		if err := cco.ObjToMsgConverter(e, req); err != nil {
			return err
		}
	}

	req.ResourceVersion = cco.ResourceVersion

	rsp, err := c.cl.Replace(ctx, req)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err

}

func (c *crudAPIInprocClient) GetRaw(ctx context.Context, key string, opts ...server.CRUDCallOpt) (*GetResponse, error) {
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	req, err := NewGetRequest(key, opts...)
	if err != nil {
		return nil, errors.Wrap(err, "Get")
	}
	rsp, err := c.cl.Get(ctx, req)
	if err != nil {
		return nil, err
	}
	if cco.OutResourceVersion != nil {
		*cco.OutResourceVersion = rsp.ResourceVersion
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func (c *crudAPIInprocClient) Get(ctx context.Context, key string, opts ...server.CRUDCallOpt) (db.Entry, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	if gRsp != nil {
		obj := NewDBObject(nil)
		gRsp.ToObject(obj)
		return obj, err
	}
	return nil, err

}

func (c *crudAPIInprocClient) GetDetail(ctx context.Context, key string, nef db.NewEntryFunc, opts ...server.CRUDCallOpt) (*server.GetResponse, error) {

	gRsp, err := c.GetRaw(ctx, key, opts...)
	respDetail := server.GetResponse{}
	if gRsp != nil {
		respDetail.Entry = NewDBObject(nil)
		gRsp.ToObject(respDetail.Entry)
		for _, status := range gRsp.Status {
			respDetail.BackRefs = append(respDetail.BackRefs, NewDBStatusObject(status))
		}

		return &respDetail, err
	}

	return nil, err

}

func (c *crudAPIInprocClient) ListIDs(ctx context.Context, opts ...server.CRUDCallOpt) ([]string, error) {

	idSet := []string{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return idSet, err
	}
	for _, li := range listRsp.GetItems() {
		idSet = append(idSet, li.GetUid())
	}
	return idSet, err

}

func (c *crudAPIInprocClient) ListItems(ctx context.Context, opts ...server.CRUDCallOpt) ([]server.ListItem, error) {

	sliSet := []server.ListItem{}
	listRsp, err := c.List(ctx, opts...)
	if listRsp == nil {
		return sliSet, err
	}
	for _, li := range listRsp.GetItems() {
		sliSet = append(sliSet, li)
	}
	return sliSet, err

}

func (c *crudAPIInprocClient) List(ctx context.Context, opts ...server.CRUDCallOpt) (*ListResponse, error) {
	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req := NewListRequest(opts...)
	switch len(cco.LabelFilter) {
	case 0:
	case 1:
		req.LabelFilter = cco.LabelFilter[0]
	default:
		return nil, fmt.Errorf("Only one label selector expression can be provided, got %d: %s", len(cco.LabelFilter), cco.LabelFilter)
	}

	rsp, err := c.cl.List(ctx, req)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, err
}

func (c *crudAPIInprocClient) ListStream(ctx context.Context, opts ...server.CRUDCallOpt) (server.ListStreamRsp, error) {
	return nil, fmt.Errorf("Not implemented")
}

func (c *crudAPIInprocClient) Delete(ctx context.Context, key string, opts ...server.CRUDCallOpt) error {

	cco := server.NewCRUDCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	req, err := NewDeleteRequest(key)
	if err != nil {
		return errors.Wrap(err, "Delete")
	}

	rsp, err := c.cl.Delete(ctx, req)

	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return err

}

func newCRUDAPIInprocClient(svc svcfw.Service) *crudAPIInprocClient {
	return &crudAPIInprocClient{cl: NewAPIInprocClient(svc)}
}

func NewCRUDAPIInprocClient(svc svcfw.Service) server.CRUDClient {
	return newCRUDAPIInprocClient(svc)
}

// SERVER side
type APISrv struct {
	oType   string
	tblName string
	sf      svcfw.Service

	opts *server.CrudServerOpts
	// derived from opts
	apiWrapper *server.DBAPIWrapper

	// resource handler function pointers
}

func (s *APISrv) validateTransport(ctx context.Context) error {
	if s.sf.IsTransportNotSupported("ves.io.schema.views.cdn_loadbalancer.API", server.TransportFromContext(ctx)) {
		userMsg := fmt.Sprintf("ves.io.schema.views.cdn_loadbalancer.API not allowed in transport '%s'", server.TransportFromContext(ctx))
		err := svcfw.NewPermissionDeniedError(userMsg, fmt.Errorf(userMsg))
		return server.GRPCStatusFromError(err).Err()
	}
	return nil
}

func (s *APISrv) Create(ctx context.Context, req *CreateRequest) (*CreateResponse, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if err := svcfw.FillOneofDefaultChoice(ctx, s.sf, req); err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.API.Create"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				if !server.NoReqValidateFromContext(ctx) {
					err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
					return nil, server.GRPCStatusFromError(err).Err()
				}
				s.sf.Logger().Warn(server.NoReqValidateAcceptLog, zap.String("rpc_fqn", "ves.io.schema.views.cdn_loadbalancer.API.Create"), zap.Error(err))
			}
		}
	}
	reqMsgFQN := "ves.io.schema.views.cdn_loadbalancer.CreateRequest"
	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.sf, reqMsgFQN, req)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
	}()

	obj := NewDBObject(nil)
	req.ToObject(obj)
	if conv, exists := s.sf.Config().MsgToObjConverters[reqMsgFQN]; exists {
		if err := conv(req, obj); err != nil {
			return nil, err
		}
	}
	obj.SystemMetadata = &ves_io_schema.SystemObjectMetaType{}
	rsrcReq := &server.ResourceCreateRequest{Entry: obj}
	rsrcRsp, err := s.opts.RsrcHandler.CreateFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "CreateResource"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rsp, err := NewObjectCreateRsp(rsrcRsp.Entry)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "CreateResponse"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rspMsgFQN := "ves.io.schema.views.cdn_loadbalancer.CreateResponse"
	if conv, exists := s.sf.Config().ObjToMsgConverters[rspMsgFQN]; exists {
		if err := conv(rsrcRsp.Entry, rsp); err != nil {
			return nil, err
		}
	}
	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.sf, "ves.io.schema.views.cdn_loadbalancer.API.CreateResponse", rsp)...)
	return rsp, nil
}

func (s *APISrv) Replace(ctx context.Context, req *ReplaceRequest) (*ReplaceResponse, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if req.Spec == nil {
		err := fmt.Errorf("Nil spec in Replace Request")
		return nil, svcfw.NewInvalidInputError(err.Error(), err)
	}
	if err := svcfw.FillOneofDefaultChoice(ctx, s.sf, req); err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.API.Replace"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				if !server.NoReqValidateFromContext(ctx) {
					err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
					return nil, server.GRPCStatusFromError(err).Err()
				}
				s.sf.Logger().Warn(server.NoReqValidateAcceptLog, zap.String("rpc_fqn", "ves.io.schema.views.cdn_loadbalancer.API.Replace"), zap.Error(err))
			}
		}
	}
	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.sf, "ves.io.schema.views.cdn_loadbalancer.API.ReplaceRequest", req)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
	}()

	rsrcReq := &server.ResourceReplaceRequest{RequestMsg: req}
	rsrcRsp, err := s.opts.RsrcHandler.ReplaceFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "ReplaceResource"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rsp, err := NewObjectReplaceRsp(rsrcRsp.Entry)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "ReplaceResponse"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.sf, "ves.io.schema.views.cdn_loadbalancer.API.ReplaceResponse", rsp)...)
	return rsp, nil
}

func (s *APISrv) Get(ctx context.Context, req *GetRequest) (*GetResponse, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.API.Get"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}
	tenant := server.TenantFromContext(ctx)
	rsrcReq := &server.ResourceGetRequest{IsPublic: true, Tenant: tenant, Namespace: req.GetNamespace(), Name: req.GetName()}
	switch req.ResponseFormat {
	case GET_RSP_FORMAT_FOR_CREATE:
		rsrcReq.RspInCreateForm = true

	case GET_RSP_FORMAT_FOR_REPLACE:
		rsrcReq.RspInReplaceForm = true

	case GET_RSP_FORMAT_READ:
		rsrcReq.RspInReadForm = true

	case GET_RSP_FORMAT_STATUS:
		rsrcReq.RspInStatusForm = true

	case GET_RSP_FORMAT_REFERRING_OBJECTS:
		rsrcReq.RspInReferringObjectsForm = true

	case GET_RSP_FORMAT_BROKEN_REFERENCES:
		rsrcReq.RspInBrokenReferencesForm = true

	}

	rsrcRsp, err := s.opts.RsrcHandler.GetFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "GetResource"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rsp, err := NewObjectGetRsp(ctx, s.sf, req, rsrcRsp)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "GetResponse"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	rspMsgFQN := "ves.io.schema.views.cdn_loadbalancer.GetResponse"
	if conv, exists := s.sf.Config().ObjToMsgConverters[rspMsgFQN]; exists {
		if err := conv(rsrcRsp.Entry, rsp); err != nil {
			return nil, err
		}
	}
	return rsp, nil
}

func (s *APISrv) List(ctx context.Context, req *ListRequest) (*ListResponse, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.API.List"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}
	var merr *multierror.Error
	rsrcReq := &server.ResourceListRequest{
		Namespace:   req.Namespace,
		LabelFilter: req.LabelFilter,
		RspStreamed: false,
	}
	if len(req.ReportStatusFields) > 0 {
		rsrcReq.ReportStatusFields = &req.ReportStatusFields
	}
	rsrcRsp, err := s.opts.RsrcHandler.ListFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		merr = multierror.Append(merr, errors.Wrap(err, "ListResource"))
	}
	rsp, err := NewListResponse(ctx, req, s.sf, rsrcRsp)
	if err != nil {
		merr = multierror.Append(merr, errors.Wrap(err, "ListResponse allocation failed"))
	}
	if merr != nil {
		if rsp == nil {
			return nil, merr
		}
		rsp.Errors = append(rsp.Errors, &ves_io_schema.ErrorType{
			Code:    ves_io_schema.EINTERNAL,
			Message: merr.Error(),
		})

	}
	return rsp, nil
}

func (s *APISrv) Delete(ctx context.Context, req *DeleteRequest) (*google_protobuf.Empty, error) {
	if err := s.validateTransport(ctx); err != nil {
		return nil, err
	}
	if s.sf.Config().EnableAPIValidation {
		if rvFn := s.sf.GetRPCValidator("ves.io.schema.views.cdn_loadbalancer.API.Delete"); rvFn != nil {
			if err := rvFn(ctx, req); err != nil {
				if !server.NoReqValidateFromContext(ctx) {
					err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "Validating Request"))
					return nil, server.GRPCStatusFromError(err).Err()
				}
				s.sf.Logger().Warn(server.NoReqValidateAcceptLog, zap.String("rpc_fqn", "ves.io.schema.views.cdn_loadbalancer.API.Delete"), zap.Error(err))
			}
		}
	}
	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.sf, "ves.io.schema.views.cdn_loadbalancer.API.DeleteRequest", req)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
	}()

	tenant := server.TenantFromContext(ctx)
	key := fmt.Sprintf("%s/%s/%s", tenant, req.GetNamespace(), req.GetName())
	rsrcReq := &server.ResourceDeleteRequest{Key: key}
	rsrcReq.FailIfReferred = req.FailIfReferred
	_, err := s.opts.RsrcHandler.DeleteFn(ctx, rsrcReq, s.apiWrapper)
	if err != nil {
		err := server.MaybePublicRestError(ctx, errors.Wrapf(err, "DeleteResource"))
		return nil, server.GRPCStatusFromError(err).Err()
	}
	return &google_protobuf.Empty{}, nil
}

// Assert that APISrv implements the generated gRPC APIServer interface
var _ APIServer = &APISrv{}

func NewCRUDAPIServer(oType string, tblName string, sf svcfw.Service, opts ...server.CRUDServerOpt) (server.APIHandler, string) {
	// convert ves.io.examplesvc.objectone.Object to
	//         ves.io.examplesvc.objectone.API
	sl := strings.Split(oType, ".")
	csOpts := server.NewCRUDServerOpts()
	for _, o := range opts {
		o(csOpts)
	}
	wrapper := server.NewDBAPIWrapper(csOpts.APIWrapperOpts...)
	s := &APISrv{
		oType:      oType,
		tblName:    tblName,
		sf:         sf,
		opts:       csOpts,
		apiWrapper: wrapper,
	}
	return s, fmt.Sprintf("%s.API", strings.Join(sl[:len(sl)-1], "."))
}

func (r *Object) Key() string {
	m := r.GetMetadata()
	if m == nil {
		return ""
	}
	return strings.Join([]string{m.Namespace, m.Name}, "/")
}

func (r *Object) Uid() string {
	return r.SystemMetadata.Uid
}

func (r *ListResponse) GetKeys() []string {
	var ret []string
	for _, i := range r.Items {
		ret = append(ret, i.Namespace+"/"+i.Name)
	}
	return ret
}

// Implement server.SROListItem interface on ListResponseItem
func (l *ListResponseItem) GetObjUid() string {
	return l.Uid
}

func (l *ListResponseItem) GetObjTenant() string {
	return l.Tenant
}

func (l *ListResponseItem) GetObjNamespace() string {
	return l.Namespace
}

func (l *ListResponseItem) GetObjName() string {
	return l.Name
}

func (l *ListResponseItem) GetObjLabels() map[string]string {
	return l.Labels
}

func NewObjectCreateRsp(e db.Entry) (*CreateResponse, error) {
	switch e.(type) {
	case nil:
		return nil, nil
	case *DBObject:
		rsp := &CreateResponse{}
		rsp.FromObject(e)
		return rsp, nil
	}
	return nil, fmt.Errorf("Entry not of type *DBObject in NewObjectCreateRsp")
}

func NewObjectReplaceRsp(e db.Entry) (*ReplaceResponse, error) {
	return &ReplaceResponse{}, nil
}

func NewObjectGetRsp(ctx context.Context, sf svcfw.Service, req *GetRequest, rsrcRsp *server.ResourceGetResponse) (*GetResponse, error) {
	rsp := &GetResponse{}
	e := rsrcRsp.Entry
	if e == nil {
		return rsp, nil
	}
	o, ok := e.(*DBObject)
	if !ok {
		return nil, fmt.Errorf("entry not of type *DBObject in NewObjectGetRsp")
	}

	rsp.ResourceVersion = rsrcRsp.ResourceVersion
	var merr *multierror.Error
	buildReadForm := func() {
		rsp.Metadata = &ves_io_schema.ObjectGetMetaType{}
		rsp.Metadata.FromObjectMetaType(o.Metadata)
		rsp.SystemMetadata = &ves_io_schema.SystemObjectGetMetaType{}
		rsp.SystemMetadata.FromSystemObjectMetaType(o.SystemMetadata)
		rsp.Spec = &GetSpecType{}
		if redactor, ok := e.(db.Redactor); ok {
			if err := redactor.Redact(ctx); err != nil {
				merr = multierror.Append(merr, errors.WithMessage(err, "Error while redacting entry"))
				return
			}
		}
		rsp.Spec.FromGlobalSpecType(o.Spec.GcSpec)

	}
	_ = buildReadForm
	buildStatusForm := func() {
		for _, statusEnt := range rsrcRsp.BackRefs {
			statusObj, ok := statusEnt.ToStore().(*StatusObject)
			if !ok {
				merr = multierror.Append(merr, fmt.Errorf("%T is not *StatusObject", statusEnt))
				continue
			}
			rsp.Status = append(rsp.Status, statusObj)
		}

	}
	_ = buildStatusForm
	buildReferringObjectsForm := func() {
		for _, br := range rsrcRsp.ReferringObjects {
			rsp.ReferringObjects = append(rsp.ReferringObjects, &ves_io_schema.ObjectRefType{
				Kind:      db.KindForEntryType(br.Type),
				Uid:       br.UID,
				Tenant:    br.Tenant,
				Namespace: br.Namespace,
				Name:      br.Name,
			})
		}

	}
	_ = buildReferringObjectsForm
	buildBrokenReferencesForm := func() {
		for _, br := range rsrcRsp.DeletedReferredObjects {
			rsp.DeletedReferredObjects = append(rsp.DeletedReferredObjects, &ves_io_schema.ObjectRefType{
				Kind:      db.KindForEntryType(br.Type),
				Uid:       br.UID,
				Tenant:    br.Tenant,
				Namespace: br.Namespace,
				Name:      br.Name,
			})
		}
		for _, br := range rsrcRsp.DisabledReferredObjects {
			rsp.DisabledReferredObjects = append(rsp.DisabledReferredObjects, &ves_io_schema.ObjectRefType{
				Kind:      db.KindForEntryType(br.Type),
				Uid:       br.UID,
				Tenant:    br.Tenant,
				Namespace: br.Namespace,
				Name:      br.Name,
			})
		}

	}
	_ = buildBrokenReferencesForm

	switch req.ResponseFormat {

	case GET_RSP_FORMAT_FOR_CREATE:
		createReq, err := NewCreateRequest(e)
		if err != nil {
			return nil, errors.Wrap(err, "Building CreateRequest from entry")
		}
		// Name has to be specified for a new create
		createReq.Metadata.Name = ""
		rsp.CreateForm = createReq

	case GET_RSP_FORMAT_FOR_REPLACE:
		replaceReq, err := NewReplaceRequest(e)
		if err != nil {
			return nil, errors.Wrap(err, "Building ReplaceRequest from entry")
		}
		rsp.ReplaceForm = replaceReq

	case GET_RSP_FORMAT_STATUS:
		buildStatusForm()

	case GET_RSP_FORMAT_READ:
		buildReadForm()

	case GET_RSP_FORMAT_REFERRING_OBJECTS:
		buildReferringObjectsForm()

	case GET_RSP_FORMAT_BROKEN_REFERENCES:
		buildBrokenReferencesForm()

	default:
		buildReadForm()

		buildStatusForm()
	}

	return rsp, errors.ErrOrNil(merr)
}

func NewListResponse(ctx context.Context, req *ListRequest, sf svcfw.Service, rsrcRsp *server.ResourceListResponse) (*ListResponse, error) {
	if req == nil {
		return nil, fmt.Errorf("Nil ListRequest")
	}
	if rsrcRsp == nil {
		return nil, fmt.Errorf("Nil ResourceResponse")
	}

	errStrs := []string{}
	resp := &ListResponse{}
	resp.Items = []*ListResponseItem{}

	for _, rsrcItem := range rsrcRsp.Items {
		if rsrcItem == nil {
			errStrs = append(errStrs, fmt.Sprintf("Nil ResourceListResponseItem"))
			continue
		}

		e := rsrcItem.Entry
		o, ok := e.(*DBObject)
		if !ok {
			resp.Errors = append(resp.Errors, &ves_io_schema.ErrorType{
				Code:    ves_io_schema.EINTERNAL,
				Message: fmt.Sprintf("Entry %T not of type *DBObject in NewListResponse", e),
			})

			continue
		}
		if redactor, ok := e.(db.Redactor); ok {
			if err := redactor.Redact(ctx); err != nil {
				resp.Errors = append(resp.Errors, &ves_io_schema.ErrorType{
					Code:    ves_io_schema.EINTERNAL,
					Message: fmt.Sprintf("Error while redacting in NewListResponse: %s", err),
				})
				continue
			}
		}
		item := &ListResponseItem{
			Tenant:    o.GetSystemMetadata().GetTenant(),
			Namespace: o.GetMetadata().GetNamespace(),
			Name:      o.GetMetadata().GetName(),
			Uid:       o.GetMetadata().GetUid(),
			OwnerView: o.GetSystemMetadata().GetOwnerView(),
			Labels:    o.GetMetadata().GetLabels(),
		}

		item.Description = o.GetMetadata().GetDescription()
		item.Annotations = o.GetMetadata().GetAnnotations()
		item.Disabled = o.GetMetadata().GetDisable()

		if len(req.ReportFields) > 0 {
			item.Metadata = &ves_io_schema.ObjectGetMetaType{}
			item.Metadata.FromObjectMetaType(o.Metadata)
			item.SystemMetadata = &ves_io_schema.SystemObjectGetMetaType{}
			item.SystemMetadata.FromSystemObjectMetaType(o.SystemMetadata)

			if o.Object.GetSpec().GetGcSpec() != nil {
				msgFQN := "ves.io.schema.views.cdn_loadbalancer.GetResponse"
				if conv, exists := sf.Config().ObjToMsgConverters[msgFQN]; exists {
					getSpec := &GetSpecType{}
					getSpec.FromGlobalSpecType(o.Spec.GcSpec)
					getRsp := &GetResponse{Spec: getSpec}
					if err := conv(o, getRsp); err != nil {
						resp.Errors = append(resp.Errors, &ves_io_schema.ErrorType{
							Code:    ves_io_schema.EINTERNAL,
							Message: fmt.Sprintf("Converting entry to getResponse: %s", err),
						})

						continue
					}
					item.GetSpec = getRsp.Spec
				} else {
					item.GetSpec = &GetSpecType{}
					item.GetSpec.FromGlobalSpecType(o.Spec.GcSpec)
				}
			}

		}

		if len(req.ReportStatusFields) > 0 {
			for _, sroStatus := range rsrcItem.StatusSet {
				statusDBO, ok := sroStatus.(*DBStatusObject)
				if !ok {
					resp.Errors = append(resp.Errors, &ves_io_schema.ErrorType{
						Code:    ves_io_schema.EINTERNAL,
						Message: fmt.Sprintf("sro.Status %T is not of type *DBStatusObject in NewListResponse", sroStatus),
					})

					continue
				}
				item.StatusSet = append(item.StatusSet, statusDBO.StatusObject)
			}
		}

		resp.Items = append(resp.Items, item)
	}
	return resp, nil
}

func RegisterGwAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterAPIHandlerClient(ctx, mux, NewAPIInprocClient(s))
}

var APISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "CDN loadbalancer",
        "description": "CDN Loadbalancer view defines a required parameters that can be used in CRUD, to create and manage CDN loadbalancer.\nIt can be used to create CDN loadbalancer and HTTPS loadbalancer.\n\nView will create following child objects.\n\n* Virtual-host\n* routes\n* endpoints\n* advertise policy",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{metadata.namespace}/cdn_loadbalancers": {
            "post": {
                "summary": "Create CDN Loadbalancer",
                "description": "Shape of the CDN loadbalancer specification",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.API.Create",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerCreateResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "metadata.namespace",
                        "description": "namespace\n\nx-example: \"staging\"\nThis defines the workspace within which each the configuration object is to be created.\nMust be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerCreateRequest"
                        }
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-api-create"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.API.Create"
            },
            "x-displayname": "CDN Loadbalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.API",
            "x-ves-proto-service-type": "AUTO_CRUD_PUBLIC"
        },
        "/public/namespaces/{metadata.namespace}/cdn_loadbalancers/{metadata.name}": {
            "put": {
                "summary": "Replace CDN Loadbalancer",
                "description": "Shape of the CDN loadbalancer specification",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.API.Replace",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerReplaceResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "metadata.namespace",
                        "description": "namespace\n\nx-example: \"staging\"\nThis defines the workspace within which each the configuration object is to be created.\nMust be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "metadata.name",
                        "description": "name\n\nx-example: \"acmecorp-web\"\nThe configuration object to be replaced will be looked up by name",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerReplaceRequest"
                        }
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-api-replace"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.API.Replace"
            },
            "x-displayname": "CDN Loadbalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.API",
            "x-ves-proto-service-type": "AUTO_CRUD_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancers": {
            "get": {
                "summary": "List CDN Loadbalancer",
                "description": "List the set of cdn_loadbalancer in a namespace",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.API.List",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerListResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"ns1\"\nNamespace to scope the listing of cdn_loadbalancer",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "label_filter",
                        "description": "x-example: \"env in (staging, testing), tier in (web, db)\"\nA LabelSelectorType expression that every item in list response will satisfy",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Label Filter"
                    },
                    {
                        "name": "report_fields",
                        "description": "x-example: \"\"\nExtra fields to return along with summary fields",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Report Fields"
                    },
                    {
                        "name": "report_status_fields",
                        "description": "x-example: \"\"\nExtra status fields to return along with summary fields",
                        "in": "query",
                        "required": false,
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "collectionFormat": "multi",
                        "x-displayname": "Report Status Fields"
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-api-list"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.API.List"
            },
            "x-displayname": "CDN Loadbalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.API",
            "x-ves-proto-service-type": "AUTO_CRUD_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancers/{name}": {
            "get": {
                "summary": "Get CDN Loadbalancer",
                "description": "Shape of the CDN loadbalancer specification",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.API.Get",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerGetResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"ns1\"\nThe namespace in which the configuration object is present",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "name\n\nx-example: \"name\"\nThe name of the configuration object to be fetched",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    },
                    {
                        "name": "response_format",
                        "description": "The format in which the configuration object is to be fetched. This could be for example\n    - in GetSpec form for the contents of object\n    - in CreateRequest form to create a new similar object\n    - to ReplaceRequest form to replace changeable values\n\nDefault format of returned resource\nResponse should be in CreateRequest format\nResponse should be in ReplaceRequest format\nResponse should be in StatusObject(s) format\nResponse should be in format of GetSpecType\nResponse should have other objects referring to this object\nResponse should have deleted and disabled objects referrred by this object",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "enum": [
                            "GET_RSP_FORMAT_DEFAULT",
                            "GET_RSP_FORMAT_FOR_CREATE",
                            "GET_RSP_FORMAT_FOR_REPLACE",
                            "GET_RSP_FORMAT_STATUS",
                            "GET_RSP_FORMAT_READ",
                            "GET_RSP_FORMAT_REFERRING_OBJECTS",
                            "GET_RSP_FORMAT_BROKEN_REFERENCES"
                        ],
                        "default": "GET_RSP_FORMAT_DEFAULT",
                        "x-displayname": "Broken Referred Objects"
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-api-get"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.API.Get"
            },
            "delete": {
                "summary": "Delete CDN Loadbalancer",
                "description": "Delete the specified cdn_loadbalancer",
                "operationId": "ves.io.schema.views.cdn_loadbalancer.API.Delete",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {}
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"ns1\"\nNamespace in which the configuration object is present",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "name\n\nx-example: \"name\"\nName of the configuration object",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/cdn_loadbalancerDeleteRequest"
                        }
                    }
                ],
                "tags": [
                    "API"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-views-cdn_loadbalancer-api-delete"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.cdn_loadbalancer.API.Delete"
            },
            "x-displayname": "CDN Loadbalancer",
            "x-ves-proto-service": "ves.io.schema.views.cdn_loadbalancer.API",
            "x-ves-proto-service-type": "AUTO_CRUD_PUBLIC"
        }
    },
    "definitions": {
        "app_firewallAppFirewallViolationType": {
            "type": "string",
            "description": "List of all supported Violation Types\n\nVIOL_NONE\nVIOL_FILETYPE\nVIOL_METHOD\nVIOL_MANDATORY_HEADER\nVIOL_HTTP_RESPONSE_STATUS\nVIOL_REQUEST_MAX_LENGTH\nVIOL_FILE_UPLOAD\nVIOL_FILE_UPLOAD_IN_BODY\nVIOL_XML_MALFORMED\nVIOL_JSON_MALFORMED\nVIOL_ASM_COOKIE_MODIFIED\nVIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS\nVIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE\nVIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT\nVIOL_HTTP_PROTOCOL_NULL_IN_REQUEST\nVIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION\nVIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START\nVIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST\nVIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING\nVIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS\nVIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER\nVIOL_EVASION_DIRECTORY_TRAVERSALS\nVIOL_MALFORMED_REQUEST\nVIOL_EVASION_MULTIPLE_DECODING\nVIOL_DATA_GUARD\nVIOL_EVASION_APACHE_WHITESPACE\nVIOL_COOKIE_MODIFIED\nVIOL_EVASION_IIS_UNICODE_CODEPOINTS\nVIOL_EVASION_IIS_BACKSLASHES\nVIOL_EVASION_PERCENT_U_DECODING\nVIOL_EVASION_BARE_BYTE_DECODING\nVIOL_EVASION_BAD_UNESCAPE\nVIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORMDATA_REQUEST_PARSING\nVIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST\nVIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS\nVIOL_ENCODING\nVIOL_COOKIE_MALFORMED\nVIOL_GRAPHQL_FORMAT\nVIOL_GRAPHQL_MALFORMED\nVIOL_GRAPHQL_INTROSPECTION_QUERY",
            "title": "App Firewall Violation Type",
            "enum": [
                "VIOL_NONE",
                "VIOL_FILETYPE",
                "VIOL_METHOD",
                "VIOL_MANDATORY_HEADER",
                "VIOL_HTTP_RESPONSE_STATUS",
                "VIOL_REQUEST_MAX_LENGTH",
                "VIOL_FILE_UPLOAD",
                "VIOL_FILE_UPLOAD_IN_BODY",
                "VIOL_XML_MALFORMED",
                "VIOL_JSON_MALFORMED",
                "VIOL_ASM_COOKIE_MODIFIED",
                "VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS",
                "VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE",
                "VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT",
                "VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST",
                "VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION",
                "VIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START",
                "VIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST",
                "VIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING",
                "VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS",
                "VIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER",
                "VIOL_EVASION_DIRECTORY_TRAVERSALS",
                "VIOL_MALFORMED_REQUEST",
                "VIOL_EVASION_MULTIPLE_DECODING",
                "VIOL_DATA_GUARD",
                "VIOL_EVASION_APACHE_WHITESPACE",
                "VIOL_COOKIE_MODIFIED",
                "VIOL_EVASION_IIS_UNICODE_CODEPOINTS",
                "VIOL_EVASION_IIS_BACKSLASHES",
                "VIOL_EVASION_PERCENT_U_DECODING",
                "VIOL_EVASION_BARE_BYTE_DECODING",
                "VIOL_EVASION_BAD_UNESCAPE",
                "VIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORMDATA_REQUEST_PARSING",
                "VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST",
                "VIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS",
                "VIOL_ENCODING",
                "VIOL_COOKIE_MALFORMED",
                "VIOL_GRAPHQL_FORMAT",
                "VIOL_GRAPHQL_MALFORMED",
                "VIOL_GRAPHQL_INTROSPECTION_QUERY"
            ],
            "default": "VIOL_NONE",
            "x-displayname": "App Firewall Violation Type",
            "x-ves-proto-enum": "ves.io.schema.app_firewall.AppFirewallViolationType"
        },
        "app_firewallAttackType": {
            "type": "string",
            "description": "List of all Attack Types\n\nATTACK_TYPE_NONE\nATTACK_TYPE_NON_BROWSER_CLIENT\nATTACK_TYPE_OTHER_APPLICATION_ATTACKS\nATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE\nATTACK_TYPE_DETECTION_EVASION\nATTACK_TYPE_VULNERABILITY_SCAN\nATTACK_TYPE_ABUSE_OF_FUNCTIONALITY\nATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS\nATTACK_TYPE_BUFFER_OVERFLOW\nATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION\nATTACK_TYPE_INFORMATION_LEAKAGE\nATTACK_TYPE_DIRECTORY_INDEXING\nATTACK_TYPE_PATH_TRAVERSAL\nATTACK_TYPE_XPATH_INJECTION\nATTACK_TYPE_LDAP_INJECTION\nATTACK_TYPE_SERVER_SIDE_CODE_INJECTION\nATTACK_TYPE_COMMAND_EXECUTION\nATTACK_TYPE_SQL_INJECTION\nATTACK_TYPE_CROSS_SITE_SCRIPTING\nATTACK_TYPE_DENIAL_OF_SERVICE\nATTACK_TYPE_HTTP_PARSER_ATTACK\nATTACK_TYPE_SESSION_HIJACKING\nATTACK_TYPE_HTTP_RESPONSE_SPLITTING\nATTACK_TYPE_FORCEFUL_BROWSING\nATTACK_TYPE_REMOTE_FILE_INCLUDE\nATTACK_TYPE_MALICIOUS_FILE_UPLOAD\nATTACK_TYPE_GRAPHQL_PARSER_ATTACK",
            "title": "AttackType",
            "enum": [
                "ATTACK_TYPE_NONE",
                "ATTACK_TYPE_NON_BROWSER_CLIENT",
                "ATTACK_TYPE_OTHER_APPLICATION_ATTACKS",
                "ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE",
                "ATTACK_TYPE_DETECTION_EVASION",
                "ATTACK_TYPE_VULNERABILITY_SCAN",
                "ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY",
                "ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS",
                "ATTACK_TYPE_BUFFER_OVERFLOW",
                "ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION",
                "ATTACK_TYPE_INFORMATION_LEAKAGE",
                "ATTACK_TYPE_DIRECTORY_INDEXING",
                "ATTACK_TYPE_PATH_TRAVERSAL",
                "ATTACK_TYPE_XPATH_INJECTION",
                "ATTACK_TYPE_LDAP_INJECTION",
                "ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION",
                "ATTACK_TYPE_COMMAND_EXECUTION",
                "ATTACK_TYPE_SQL_INJECTION",
                "ATTACK_TYPE_CROSS_SITE_SCRIPTING",
                "ATTACK_TYPE_DENIAL_OF_SERVICE",
                "ATTACK_TYPE_HTTP_PARSER_ATTACK",
                "ATTACK_TYPE_SESSION_HIJACKING",
                "ATTACK_TYPE_HTTP_RESPONSE_SPLITTING",
                "ATTACK_TYPE_FORCEFUL_BROWSING",
                "ATTACK_TYPE_REMOTE_FILE_INCLUDE",
                "ATTACK_TYPE_MALICIOUS_FILE_UPLOAD",
                "ATTACK_TYPE_GRAPHQL_PARSER_ATTACK"
            ],
            "default": "ATTACK_TYPE_NONE",
            "x-displayname": "Attack Types",
            "x-ves-proto-enum": "ves.io.schema.app_firewall.AttackType"
        },
        "app_typeAPIEndpoint": {
            "type": "object",
            "description": "x-required\nx-displayName: \"API Endpoint\"\nThe rule is applied only for the specified api endpoints.",
            "title": "api endpoint",
            "properties": {
                "api_endpoint_path": {
                    "type": "string",
                    "description": "x-required\nx-example: \"/endpoint1\"\nx-displayName: \"API Endpoint\"\nThe rule is applied only for the specified api endpoints.",
                    "title": "api endpoint path"
                },
                "methods": {
                    "type": "array",
                    "description": "x-displayName: \"Methods\"\nList of methods values to match against.\nx-required\nx-example: \"['GET', 'POST', 'DELETE']\"",
                    "title": "methods",
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    }
                }
            }
        },
        "app_typeBuiltInSensitiveDataType": {
            "type": "object",
            "description": "x-displayName: \"Built-In Sensitive Data Type\"\nx-example: \"[EMAIL, CC]\"\nMessage wrapper for built-in sensitive data type.",
            "title": "BuiltInSensitiveDataType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Name\"\nx-example: \"[EMAIL, CC]\"\nx-required\nBuilt-in rule for sensitive data detection.",
                    "title": "name"
                }
            }
        },
        "app_typeCustomDataDetectionConfig": {
            "type": "object",
            "description": "x-displayName: \"Custom Data Detection Config\"\nThe custom data detection config specifies targets, scopes \u0026 the pattern to be detected.",
            "title": "CustomDataDetectionConfig",
            "properties": {
                "all_request_sections": {
                    "description": "x-displayName: \"All Request\"",
                    "title": "all_request_sections",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "all_response_sections": {
                    "description": "x-displayName: \"All Response\"",
                    "title": "all_response_sections",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "all_sections": {
                    "description": "x-displayName: \"All Request \u0026 Response\"",
                    "title": "all_sections",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "any_domain": {
                    "description": "x-displayName: \"Any Domain\"\nThe rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "any_target": {
                    "description": "x-displayName: \"All API Endpoints\"\nThe rule will be applied for all requests on this LB.",
                    "title": "any domain",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "api_endpoint_target": {
                    "description": "x-example: \"/endpoint1\"\nx-displayName: \"API Endpoint\"\nThe rule is applied only for the specified api endpoints.",
                    "title": "api endpoint target",
                    "$ref": "#/definitions/app_typeAPIEndpoint"
                },
                "api_group": {
                    "type": "string",
                    "description": "x-displayName: \"API Group\"\nx-example: \"oas-all-operations\"\nThe rule is applied on the APIs that belong to specified api_group.\nAPI groups derived from API Definition swaggers.\nFor example oas-all-operations including all paths and methods from the swaggers, oas-base-urls covering all requests under base-paths from the swaggers.\nCustom groups can be created if user tags paths or operations with \"x-volterra-api-group\" extensions inside swaggers.",
                    "title": "api_group"
                },
                "base_path": {
                    "type": "string",
                    "description": "x-example: \"/v1\"\nx-displayName: \"Base Path\"\nThe rule is applied only for the requests matching the specified base path.",
                    "title": "base path"
                },
                "custom_sections": {
                    "description": "x-displayName: \"Custom Sections\"",
                    "title": "sections",
                    "$ref": "#/definitions/app_typeCustomSections"
                },
                "key_pattern": {
                    "description": "x-displayName: \"Key Pattern\"\nSearch for pattern across all field names in the specified sections.",
                    "title": "key pattern",
                    "$ref": "#/definitions/app_typeKeyPattern"
                },
                "key_value_pattern": {
                    "description": "x-displayName: \"Key-Value Pattern\"\nSearch for specific field and value patterns in the specified sections.",
                    "title": "key-value pattern",
                    "$ref": "#/definitions/app_typeKeyValuePattern"
                },
                "specific_domain": {
                    "type": "string",
                    "description": "x-displayName: \"Specific Domain\"\nx-example: \"api.example.com\"\nThe rule will apply for a specific domain.\nFor example: api.example.com",
                    "title": "domain"
                },
                "value_pattern": {
                    "description": "x-displayName: \"Value Pattern\"\nSearch for pattern across all field values in the specified sections.",
                    "title": "value pattern",
                    "$ref": "#/definitions/app_typeValuePattern"
                }
            }
        },
        "app_typeCustomSections": {
            "type": "object",
            "description": "x-displayName: \"Custom Sections\"\nRequest \u0026 Response Sections.",
            "title": "CustomSections",
            "properties": {
                "custom_sections": {
                    "type": "array",
                    "description": "x-displayName: \"Custom Sections\"\nx-required\nRequest \u0026 Response Sections.",
                    "title": "custom_sections",
                    "items": {
                        "$ref": "#/definitions/schemaHttpSections"
                    }
                }
            }
        },
        "app_typeCustomSensitiveDataDetectionRule": {
            "type": "object",
            "description": "x-displayName: \"Custom Sensitive Data Detection Rule\"\nCustom Sensitive Data Rule Definition.",
            "title": "CustomSensitiveDataRule",
            "properties": {
                "metadata": {
                    "description": "x-required\nx-displayName: \"Metadata\"\nCommon attributes for the rule including name and description.",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType"
                },
                "sensitive_data_detection_config": {
                    "description": "x-required\nx-displayName: \"Sensitive Data Detection Config\"\nThe custom data detection config specifies targets, scopes \u0026 the pattern to be detected.",
                    "title": "sensitive_data_detection_config",
                    "$ref": "#/definitions/app_typeCustomDataDetectionConfig"
                },
                "sensitive_data_type": {
                    "description": "x-required\nx-displayName: \"Sensitive Data Type\"\nIf the pattern is detected, the request is labeled with specified sensitive data type.",
                    "title": "sensitive_data_type",
                    "$ref": "#/definitions/app_typeCustomSensitiveDataType"
                }
            }
        },
        "app_typeCustomSensitiveDataType": {
            "type": "object",
            "description": "x-displayName: \"Custom Sensitive Data Type\"\nThe type/category of the sensitive data this rule detects. e.g. Email, Credit Card etc.",
            "title": "CustomSensitiveDataType",
            "properties": {
                "type": {
                    "type": "string",
                    "description": "x-required\nx-displayName: \"Type\"\nx-example: \"EMAIL\"\nThe request is labeled as specified sensitive data type.",
                    "title": "sensitive data type"
                }
            }
        },
        "app_typeDiscoveredAPISettings": {
            "type": "object",
            "description": "x-example: \"2\"\nConfigure Discovered API Settings.",
            "title": "DiscoveredAPISettings",
            "x-displayname": "Discovered API Settings",
            "x-ves-proto-message": "ves.io.schema.app_type.DiscoveredAPISettings",
            "properties": {
                "purge_duration_for_inactive_discovered_apis": {
                    "type": "integer",
                    "description": " Inactive discovered API will be deleted after configured duration.\n\nExample: - \"2\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 7\n",
                    "title": "purge_duration_for_inactive_discovered_apis",
                    "format": "int64",
                    "x-displayname": "Purge Duration for Inactive Discovered APIs",
                    "x-ves-example": "2",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "7"
                    }
                }
            }
        },
        "app_typeKeyPattern": {
            "type": "object",
            "description": "x-displayName: \"Key Pattern\"\nPattern to detect. Could be exact match or regex match.",
            "title": "Key Pattern",
            "properties": {
                "exact_value": {
                    "type": "string",
                    "description": "x-displayName: \"Exact Value\"\nx-example: \"x-volt-header\"\nSearch for values with exact match.",
                    "title": "exact value"
                },
                "regex_value": {
                    "type": "string",
                    "description": "x-displayName: \"Regex Value\"\nx-example: \"'^new.*$', 'san f.*', '.* del .*'\"\nSearch for values matching this regular expression.",
                    "title": "regex value"
                }
            }
        },
        "app_typeKeyValuePattern": {
            "type": "object",
            "description": "x-displayName: \"Key \u0026 Value Pattern\"\nSearch for specific key \u0026 value patterns in the specified sections.",
            "title": "Key-Value Pattern",
            "properties": {
                "key_pattern": {
                    "description": "x-displayName: \"Key Pattern\"\nx-required\nPattern for key/field.",
                    "title": "key_pattern",
                    "$ref": "#/definitions/app_typeKeyPattern"
                },
                "value_pattern": {
                    "description": "x-displayName: \"Value Pattern\"\nx-required\nPattern for value.",
                    "title": "value_pattern",
                    "$ref": "#/definitions/app_typeValuePattern"
                }
            }
        },
        "app_typeSensitiveDataDetectionRules": {
            "type": "object",
            "description": "x-displayName: \"Sensitive Data Detection Rules\"\nRules to manage/configure sensitive data detection in requests and/or response sections.",
            "title": "Sensitive Data Detection Rules",
            "properties": {
                "custom_sensitive_data_detection_rules": {
                    "type": "array",
                    "description": "x-displayName: \"Defined Custom Sensitive Data Types\"\nRules to detect custom sensitive data in requests and/or responses sections.",
                    "title": "custom sensitive data rules",
                    "items": {
                        "$ref": "#/definitions/app_typeCustomSensitiveDataDetectionRule"
                    }
                },
                "disabled_built_in_rules": {
                    "type": "array",
                    "description": "x-displayName: \"Disabled Built-In Sensitive Data Types\"\nx-example: \"[EMAIL, CC]\"\nList of disabled built-in sensitive data detection rules.",
                    "title": "disabled_built_in_rules",
                    "items": {
                        "$ref": "#/definitions/app_typeBuiltInSensitiveDataType"
                    }
                }
            }
        },
        "app_typeValuePattern": {
            "type": "object",
            "description": "x-displayName: \"Value Pattern\"\nPattern to detect. Could be exact match or regex match.",
            "title": "Value Pattern",
            "properties": {
                "exact_value": {
                    "type": "string",
                    "description": "x-displayName: \"Exact Value\"\nx-example: \"x-volt-header\"\nPattern value to be detected.",
                    "title": "exact value"
                },
                "regex_value": {
                    "type": "string",
                    "description": "x-displayName: \"Regex Value\"\nx-example: \"'^new.*$', 'san f.*', '.* del .*'\"\nRegular expression for this pattern.",
                    "title": "regex value"
                }
            }
        },
        "cdn_loadbalancerApiProtection": {
            "type": "object",
            "description": "x-displayName: \"API Definition\"\nAPI Definition based on the imported swagger specs",
            "title": "API Definition",
            "properties": {
                "api_discovery_on_cache_miss": {
                    "description": "x-displayName: \"Enable Only on Cache Miss\"\nEnable api discovery only on cache miss in this distribution",
                    "title": "Enable API Discovery Only on Cache Miss",
                    "$ref": "#/definitions/common_wafApiDiscoverySetting"
                },
                "api_protection_rules": {
                    "description": "x-displayName: \"API Protection Rules\"\nAPI Protection Rules can be defined in two categories.\nThe first category includes fine-grained rules, per API path and methods.\nThe second category includes rules per API groups or Server URLs.\nIf request matches any rule in the first category, second category rules are not evaluated.\nRules can also include additional conditions, for example specific clients can access certain API endpoint or API group.",
                    "title": "API Protection rules",
                    "$ref": "#/definitions/common_wafAPIProtectionRules"
                },
                "api_specification": {
                    "description": "x-displayName: \"Enable for All Requests\"\nSpecify API definition and OpenAPI Validation",
                    "title": "API Specification",
                    "$ref": "#/definitions/common_wafAPISpecificationSettings"
                },
                "api_specification_on_cache_miss": {
                    "description": "x-displayName: \"Enable Only on Cache Miss\"\nEnable API definition and OpenAPI Validation only on cache miss in this distribution",
                    "title": "Enable API Specification Only on Cache Miss",
                    "$ref": "#/definitions/common_wafAPISpecificationSettings"
                },
                "default_sensitive_data_policy": {
                    "description": "x-displayName: \"Default\"\nApply system default sensitive data discovery",
                    "title": "Apply sensitive data discovery",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "disable_api_definition": {
                    "description": "x-displayName: \"Disable\"\nAPI Definition is not currently used for this load balancer",
                    "title": "Don not use API Definition",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "disable_api_discovery": {
                    "description": "x-displayName: \"Disable\"\nDisable api discovery for this distribution",
                    "title": "Disable API discovery",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "enable_api_discovery": {
                    "description": "x-displayName: \"Enable for All Requests\"\nEnable api discovery for all requests in this distribution",
                    "title": "Enable API discovery",
                    "$ref": "#/definitions/common_wafApiDiscoverySetting"
                },
                "jwt_validation": {
                    "description": "x-displayName: \"JWT Validation\"\nJWT Validation stops JWT replay attacks and JWT tampering by cryptographically verifying incoming\nJWTs before they are passed to origin APIs. JWT Validation will also stop requests with expired\ntokens or tokens that are not yet valid.",
                    "title": "JWT Validation",
                    "$ref": "#/definitions/common_wafJWTValidation"
                },
                "sensitive_data_policy": {
                    "description": "x-displayName: \"Custom\"\nApply custom sensitive data discovery",
                    "title": "Apply Specified Sensitive Data Discovery",
                    "$ref": "#/definitions/common_securitySensitiveDataPolicySettings"
                }
            }
        },
        "cdn_loadbalancerAuthenticationOptions": {
            "type": "object",
            "description": "x-displayName: \"Authentication Options\"\nOptions to authenticate incoming client requests",
            "title": "AuthenticationOptions",
            "properties": {
                "custom": {
                    "description": "x-displayName: \"Custom Authentication\"\nEnable Custom Authentication",
                    "title": "Custom Authentication",
                    "$ref": "#/definitions/cdn_loadbalancerCDNCustomAuthentication"
                },
                "disable_auth": {
                    "description": "x-displayName: \"No Authentication\"\nNo Authentication",
                    "title": "No Authentication",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "jwt": {
                    "description": "x-displayName: \"JWT Token Authentication\"\nEnable JWT Authentication",
                    "title": "JWT Token Authentication",
                    "$ref": "#/definitions/policyJwtTokenAuthOptions"
                }
            }
        },
        "cdn_loadbalancerCDNCacheRule": {
            "type": "object",
            "description": "This defines a CDN Cache Rule",
            "title": "Cache Rule",
            "x-displayname": "Cache Rule",
            "x-ves-displayorder": "1,2,3",
            "x-ves-oneof-field-cache_actions": "[\"cache_bypass\",\"eligible_for_cache\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNCacheRule",
            "properties": {
                "cache_bypass": {
                    "description": "Exclusive with [eligible_for_cache]\n Bypass Caching of content from the origin",
                    "title": "Bypass Cache",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Bypass Cache"
                },
                "eligible_for_cache": {
                    "description": "Exclusive with [cache_bypass]\n Eligible for caching the content",
                    "title": "Eligible For Cache",
                    "$ref": "#/definitions/cdn_loadbalancerCacheEligibleOptions",
                    "x-displayname": "Eligible For Cache"
                },
                "rule_expression_list": {
                    "type": "array",
                    "description": " Expressions are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs..\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 8\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Expression List",
                    "minItems": 1,
                    "maxItems": 8,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCDNCacheRuleExpressionList"
                    },
                    "x-displayname": "Expressions",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "8",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "rule_name": {
                    "type": "string",
                    "description": " Name of the Cache Rule\n\nExample: - \"Rule-1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Rule Name",
                    "maxLength": 128,
                    "x-displayname": "Rule Name",
                    "x-ves-example": "Rule-1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                }
            }
        },
        "cdn_loadbalancerCDNCacheRuleExpression": {
            "type": "object",
            "description": "Select one of the field options",
            "title": "CDNCacheRuleExpression",
            "x-displayname": "Cache Rule Expression",
            "x-ves-displayorder": "1,6,5,7",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNCacheRuleExpression",
            "properties": {
                "cache_headers": {
                    "type": "array",
                    "description": " Configure cache rule headers to match the criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 8\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Cache Headers",
                    "maxItems": 8,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCacheHeaderMatcherType"
                    },
                    "x-displayname": "Cache Headers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "8",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "cookie_matcher": {
                    "type": "array",
                    "description": " A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances\n of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.\n Note that all specified cookie matcher predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 8\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "cookie matchers",
                    "maxItems": 8,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCacheCookieMatcherType"
                    },
                    "x-displayname": "Cookie Matchers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "8",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "path_match": {
                    "description": " URI path of route",
                    "title": "path_match",
                    "$ref": "#/definitions/cdn_loadbalancerCDNPathMatcherType",
                    "x-displayname": "Path Match"
                },
                "query_parameters": {
                    "type": "array",
                    "description": " List of (key, value) query parameters\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 8\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "query_params",
                    "maxItems": 8,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCacheQueryParameterMatcherType"
                    },
                    "x-displayname": "Query Parameters",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "8",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerCDNCacheRuleExpressionList": {
            "type": "object",
            "description": "CDN Cache Rule Expressions.",
            "title": "Cache Rule Expression List",
            "x-displayname": "Cache Rule Expression List",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNCacheRuleExpressionList",
            "properties": {
                "cache_rule_expression": {
                    "type": "array",
                    "description": " The Cache Rule Expression Terms that are ANDed\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 8\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Terms",
                    "minItems": 1,
                    "maxItems": 8,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCDNCacheRuleExpression"
                    },
                    "x-displayname": "Terms",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "8",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "expression_name": {
                    "type": "string",
                    "description": " Name of the Expressions items that are ANDed\n\nExample: - \"Expression-1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Expression Name",
                    "maxLength": 128,
                    "x-displayname": "Expression Name",
                    "x-ves-example": "Expression-1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                }
            }
        },
        "cdn_loadbalancerCDNCustomAuthentication": {
            "type": "object",
            "description": "x-displayName: \"Custom Authentication\"\nCustom  Authentication",
            "title": "CDNCustomAuthentication",
            "properties": {
                "custom_auth_config": {
                    "type": "string",
                    "description": "x-displayName: \"Custom Auth Config\"\nx-example: \"\"\nThis is custom authentication configuration parameters. Please reach out to the support for custom authentication details.",
                    "title": "custom_auth_config"
                }
            }
        },
        "cdn_loadbalancerCDNDownstreamTlsParamsType": {
            "type": "object",
            "description": "x-displayName: \"TLS Parameters\"\nTLS parameters for CDN distribution",
            "title": "CDNDownstreamTlsParamsType",
            "properties": {
                "tls_certificates": {
                    "type": "array",
                    "description": "x-displayName: \"TLS Certificates\"\nx-required\nUsers can add one or more certificates that share the same set of domains.\nfor example, domain.com and *.domain.com - but use different signature algorithms",
                    "title": "tls_certificates",
                    "items": {
                        "$ref": "#/definitions/schemaTlsCertificateType"
                    }
                },
                "tls_config": {
                    "description": "x-displayName: \"TLS\"\nTLS Configuration Parameters",
                    "title": "TLS Config",
                    "$ref": "#/definitions/cdn_loadbalancerCDNTLSConfig"
                }
            }
        },
        "cdn_loadbalancerCDNHTTPSAutoCertsType": {
            "type": "object",
            "description": "Choice for selecting HTTPS CDN distribution with bring your own certificates",
            "title": "HTTPS with Automatic Certificate",
            "x-displayname": "HTTPS with Automatic Certificate",
            "x-ves-displayorder": "1,2,3",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSAutoCertsType",
            "properties": {
                "add_hsts": {
                    "type": "boolean",
                    "description": " Add HTTP Strict-Transport-Security response header",
                    "title": "Add HSTS",
                    "format": "boolean",
                    "x-displayname": "Add HSTS Header"
                },
                "http_redirect": {
                    "type": "boolean",
                    "description": " Redirect HTTP traffic to HTTPS",
                    "title": "HTTP Redirect",
                    "format": "boolean",
                    "x-displayname": "HTTP Redirect to HTTPS"
                },
                "tls_config": {
                    "description": " TLS Configuration Parameters",
                    "title": "TLS Config",
                    "$ref": "#/definitions/cdn_loadbalancerCDNTLSConfig",
                    "x-displayname": "TLS"
                }
            }
        },
        "cdn_loadbalancerCDNHTTPSCustomCertsType": {
            "type": "object",
            "description": "Choice for selecting CDN Distribution with bring your own certificates",
            "title": "BYOC for the CDN distribution",
            "x-displayname": "BYOC HTTPS Choice",
            "x-ves-displayorder": "1,2,3,4",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNHTTPSCustomCertsType",
            "properties": {
                "add_hsts": {
                    "type": "boolean",
                    "description": " Add HTTP Strict-Transport-Security response header",
                    "title": "Add HSTS",
                    "format": "boolean",
                    "x-displayname": "Add HSTS Header"
                },
                "http_redirect": {
                    "type": "boolean",
                    "description": " Redirect HTTP traffic to HTTPS",
                    "title": "HTTP Redirect",
                    "format": "boolean",
                    "x-displayname": "HTTP Redirect to HTTPS"
                },
                "tls_cert_options": {
                    "description": " TLS Certificate Options",
                    "title": "TLS Certificate Options",
                    "$ref": "#/definitions/cdn_loadbalancerTlsCertOptions",
                    "x-displayname": "TLS Certificate Options"
                }
            }
        },
        "cdn_loadbalancerCDNLbStatusType": {
            "type": "object",
            "description": "This CDN LB status is per site and it indicates the status of the LB on the site",
            "title": "CDN LB status details",
            "x-displayname": "CDN LB Status",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNLbStatusType",
            "properties": {
                "error": {
                    "type": "string",
                    "description": " Error message (if any)",
                    "title": "Error",
                    "x-displayname": "Error"
                },
                "site": {
                    "type": "string",
                    "description": " Name of the site that reported this status",
                    "title": "Site Name",
                    "x-displayname": "Site"
                },
                "status": {
                    "description": " Indicates the status of deployment on the site",
                    "title": "Deployment Status",
                    "$ref": "#/definitions/cdn_loadbalancerCDNSiteDeploymentStatus",
                    "x-displayname": "Deployment Status"
                }
            }
        },
        "cdn_loadbalancerCDNLoadbalancerDeploymentStatus": {
            "type": "string",
            "description": "Deployment status\n\n - CDN_LB_STATUS_FAILED: x-displayname: \"Failed\"",
            "title": "CDN LoadBalancer Deployment status",
            "enum": [
                "CDN_LB_STATUS_CREATED",
                "CDN_LB_STATUS_DEPLOYING",
                "CDN_LB_STATUS_DEPLOY_FAILED",
                "CDN_LB_STATUS_DEPLOYED",
                "CDN_LB_STATUS_FAILED"
            ],
            "default": "CDN_LB_STATUS_CREATED",
            "x-displayname": "CDN LoadBalancer Deployment status",
            "x-ves-proto-enum": "ves.io.schema.views.cdn_loadbalancer.CDNLoadbalancerDeploymentStatus"
        },
        "cdn_loadbalancerCDNLoadbalancerStatus": {
            "type": "object",
            "description": "CDN LoadBalancer Status",
            "title": "CDNLoadBalancer status",
            "x-displayname": "CDN LoadBalancer Status",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNLoadbalancerStatus",
            "properties": {
                "cfg_version": {
                    "type": "integer",
                    "description": " Cfg version",
                    "title": "Cfg Version",
                    "format": "int64",
                    "x-displayname": "Cfg Version"
                },
                "cp_version": {
                    "type": "integer",
                    "description": " CP version",
                    "title": "CP Version",
                    "format": "int64",
                    "x-displayname": "CP Version"
                },
                "deployment_status": {
                    "description": " Deployment status",
                    "title": "Deployment Status",
                    "$ref": "#/definitions/cdn_loadbalancerCDNLoadbalancerDeploymentStatus",
                    "x-displayname": "Deployment Status"
                },
                "error_msg": {
                    "type": "string",
                    "description": " Error message",
                    "title": "Error Message",
                    "x-displayname": "Error Message"
                }
            }
        },
        "cdn_loadbalancerCDNOriginServerType": {
            "type": "object",
            "description": "Various options to specify origin server",
            "title": "CDNOriginServerType",
            "x-displayname": "Origin Server",
            "x-ves-oneof-field-choice": "[\"public_ip\",\"public_name\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNOriginServerType",
            "properties": {
                "port": {
                    "type": "integer",
                    "description": " Port the workload can be reached on\n\nExample: - \"80\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 65535\n",
                    "title": "Port",
                    "format": "int64",
                    "x-displayname": "Origin Server Port",
                    "x-ves-example": "80",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "65535"
                    }
                },
                "public_ip": {
                    "description": "Exclusive with [public_name]\n Specify origin server with public IP",
                    "title": "OriginServerPublicName",
                    "$ref": "#/definitions/origin_poolOriginServerPublicIP",
                    "x-displayname": "Public IP of Origin Server"
                },
                "public_name": {
                    "description": "Exclusive with [public_ip]\n Specify origin server with public DNS name",
                    "title": "OriginServerPublicName",
                    "$ref": "#/definitions/origin_poolOriginServerPublicName",
                    "x-displayname": "Public DNS Name of Origin Server"
                }
            }
        },
        "cdn_loadbalancerCDNPathMatcherType": {
            "type": "object",
            "description": "Path match of the URI",
            "title": "PathMatcherType",
            "x-displayname": "Path to Match",
            "x-ves-displayorder": "5",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNPathMatcherType",
            "properties": {
                "operator": {
                    "description": " A specification of path match",
                    "title": "cache_operator",
                    "$ref": "#/definitions/cdn_loadbalancerCacheOperator",
                    "x-displayname": "Path Match"
                }
            }
        },
        "cdn_loadbalancerCDNSiteDeploymentStatus": {
            "type": "string",
            "title": "CDNSiteDeploymentStatus",
            "enum": [
                "DEPLOYMENT_STATUS_NOT_DEPLOYED",
                "DEPLOYMENT_STATUS_DEPLOYING",
                "DEPLOYMENT_STATUS_DEPLOY_FAILED",
                "DEPLOYMENT_STATUS_DEPLOYED"
            ],
            "default": "DEPLOYMENT_STATUS_NOT_DEPLOYED",
            "x-displayname": "CDN LoadBalancer Site Deployment status",
            "x-ves-proto-enum": "ves.io.schema.views.cdn_loadbalancer.CDNSiteDeploymentStatus"
        },
        "cdn_loadbalancerCDNTLSConfig": {
            "type": "object",
            "description": "This defines various options to configure TLS configuration parameters",
            "title": "CDNTLSConfig",
            "x-displayname": "TLS Config",
            "x-ves-displayorder": "5",
            "x-ves-oneof-field-choice": "[\"tls_11_plus\",\"tls_12_plus\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CDNTLSConfig",
            "properties": {
                "tls_11_plus": {
                    "description": "Exclusive with [tls_12_plus]\n TLS v1.1+ with PFS ciphers and medium strength crypto algorithms.",
                    "title": "Medium Security",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Medium"
                },
                "tls_12_plus": {
                    "description": "Exclusive with [tls_11_plus]\n TLS v1.2+ with PFS ciphers and strong crypto algorithms.",
                    "title": "Default Security",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "High"
                }
            }
        },
        "cdn_loadbalancerCacheCookieMatcherType": {
            "type": "object",
            "description": "A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each\ncookie in the request.\nA cookie matcher can check for one of the following:\n* Presence or absence of the cookie\n* At least one of the values for the cookie in the request satisfies the MatcherType item",
            "title": "CacheCookieMatcherType",
            "x-displayname": "Cookie Matcher",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CacheCookieMatcherType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " A case-sensitive cookie name.\n\nExample: - \"Session\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Cookie Name",
                    "x-ves-example": "Session",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                },
                "operator": {
                    "description": " ",
                    "title": "cache_operator",
                    "$ref": "#/definitions/cdn_loadbalancerCacheOperator",
                    "x-displayname": "Operator"
                }
            }
        },
        "cdn_loadbalancerCacheEligibleOptions": {
            "type": "object",
            "description": "List of options for Cache Action",
            "title": "Cache Action Options",
            "x-displayname": "Cache Action Options",
            "x-ves-displayorder": "1",
            "x-ves-oneof-field-eligible_for_cache": "[\"scheme_proxy_host_request_uri\",\"scheme_proxy_host_uri\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CacheEligibleOptions",
            "properties": {
                "scheme_proxy_host_request_uri": {
                    "description": "Exclusive with [scheme_proxy_host_uri]\n ",
                    "title": "Scheme + Proxy Host + Request URI",
                    "$ref": "#/definitions/cdn_loadbalancerCacheTTLEnableProps",
                    "x-displayname": "Scheme + Proxy Host + Request URI"
                },
                "scheme_proxy_host_uri": {
                    "description": "Exclusive with [scheme_proxy_host_request_uri]\n ",
                    "title": "Scheme + Proxy Host + URI",
                    "$ref": "#/definitions/cdn_loadbalancerCacheTTLEnableProps",
                    "x-displayname": "Scheme + Proxy Host + URI"
                }
            }
        },
        "cdn_loadbalancerCacheHeaderMatcherType": {
            "type": "object",
            "description": "Header match is done using the name of the header and its value.\nThe value match is done using one of the following\n    regex match on value\n    exact match of value\n    presence of header\n\nHeader Match can also be inverse of above, which be used to check\n    missing header or\n    non-matching value",
            "title": "CacheHeaderMatcherType",
            "x-displayname": "Cache Header to Match",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CacheHeaderMatcherType",
            "properties": {
                "name": {
                    "description": " Name of the header\n\nExample: - \"Content-Type\"-",
                    "title": "Name",
                    "$ref": "#/definitions/cdn_loadbalancerHeaderOptions",
                    "x-displayname": "Name",
                    "x-ves-example": "Content-Type"
                },
                "operator": {
                    "description": " Available operators",
                    "title": "cache_operator",
                    "$ref": "#/definitions/cdn_loadbalancerCacheOperator",
                    "x-displayname": "Operator"
                }
            }
        },
        "cdn_loadbalancerCacheOperator": {
            "type": "object",
            "title": "Cache Operator",
            "x-displayname": "Operator",
            "x-ves-oneof-field-cache_operator": "[\"Contains\",\"DoesNotContain\",\"DoesNotEndWith\",\"DoesNotEqual\",\"DoesNotStartWith\",\"Endswith\",\"Equals\",\"MatchRegex\",\"Startswith\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CacheOperator",
            "properties": {
                "Contains": {
                    "type": "string",
                    "description": "Exclusive with [DoesNotContain DoesNotEndWith DoesNotEqual DoesNotStartWith Endswith Equals MatchRegex Startswith]\n Field must contain",
                    "title": "Contains",
                    "x-displayname": "Contains"
                },
                "DoesNotContain": {
                    "type": "string",
                    "description": "Exclusive with [Contains DoesNotEndWith DoesNotEqual DoesNotStartWith Endswith Equals MatchRegex Startswith]\n Field must not contain",
                    "title": "Does Not Contain",
                    "x-displayname": "Does Not Contain"
                },
                "DoesNotEndWith": {
                    "type": "string",
                    "description": "Exclusive with [Contains DoesNotContain DoesNotEqual DoesNotStartWith Endswith Equals MatchRegex Startswith]\n Field must not end with",
                    "title": "Does Not End With",
                    "x-displayname": "Does Not End With"
                },
                "DoesNotEqual": {
                    "type": "string",
                    "description": "Exclusive with [Contains DoesNotContain DoesNotEndWith DoesNotStartWith Endswith Equals MatchRegex Startswith]\n Field must not equal",
                    "title": "Does Not Equal",
                    "x-displayname": "Does Not Equal"
                },
                "DoesNotStartWith": {
                    "type": "string",
                    "description": "Exclusive with [Contains DoesNotContain DoesNotEndWith DoesNotEqual Endswith Equals MatchRegex Startswith]\n Field must not start with",
                    "title": "Does Not Start With",
                    "x-displayname": "Does Not Start With"
                },
                "Endswith": {
                    "type": "string",
                    "description": "Exclusive with [Contains DoesNotContain DoesNotEndWith DoesNotEqual DoesNotStartWith Equals MatchRegex Startswith]\n Field must end with",
                    "title": "Ends With",
                    "x-displayname": "Ends With"
                },
                "Equals": {
                    "type": "string",
                    "description": "Exclusive with [Contains DoesNotContain DoesNotEndWith DoesNotEqual DoesNotStartWith Endswith MatchRegex Startswith]\n Field must exactly match",
                    "title": "Equals",
                    "x-displayname": "Equals"
                },
                "MatchRegex": {
                    "type": "string",
                    "description": "Exclusive with [Contains DoesNotContain DoesNotEndWith DoesNotEqual DoesNotStartWith Endswith Equals Startswith]\n Field matches regular expression",
                    "title": "Matches Regex",
                    "x-displayname": "Matches Regex"
                },
                "Startswith": {
                    "type": "string",
                    "description": "Exclusive with [Contains DoesNotContain DoesNotEndWith DoesNotEqual DoesNotStartWith Endswith Equals MatchRegex]\n Field must start with",
                    "title": "Starts With",
                    "x-displayname": "Starts With"
                }
            }
        },
        "cdn_loadbalancerCacheOptions": {
            "type": "object",
            "description": "x-displayName: \"Cache Options\"\nThis defines the options related to content caching",
            "title": "Cache options",
            "properties": {
                "cache_rules": {
                    "type": "array",
                    "description": "x-displayName: \"Cache Rules\"\nRules are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs.",
                    "title": "List of Cache rules(These rules are ORed)",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCDNCacheRule"
                    }
                },
                "default_cache_action": {
                    "description": "x-displayName: \"Default Cache Action\"\nx-required\nDefault value for Cache action.",
                    "title": "Default Cache Action",
                    "$ref": "#/definitions/cdn_loadbalancerDefaultCacheAction"
                }
            }
        },
        "cdn_loadbalancerCacheQueryParameterMatcherType": {
            "type": "object",
            "description": "Query parameter match can be either regex match on value or exact match of value for given key\nAn example for HTTP request with query parameter https://gitlab.com/dashboard/issues?assignee_username=xxyyxx",
            "title": "CacheQueryParameterMatcherType",
            "x-displayname": "Query Parameter to Match",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CacheQueryParameterMatcherType",
            "properties": {
                "key": {
                    "type": "string",
                    "description": " Query parameter key\n In the above example, assignee_username is the key\n\nExample: - \"assignee_username\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "key",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Key",
                    "x-ves-example": "assignee_username",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "operator": {
                    "description": " ",
                    "title": "cache_operator",
                    "$ref": "#/definitions/cdn_loadbalancerCacheOperator",
                    "x-displayname": "Operator"
                }
            }
        },
        "cdn_loadbalancerCacheTTLEnableProps": {
            "type": "object",
            "description": "Cache TTL Enable Values",
            "title": "Cache TTL Enable Props",
            "x-displayname": "Cache TTL Enable Props",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CacheTTLEnableProps",
            "properties": {
                "cache_override": {
                    "type": "boolean",
                    "description": " Honour Cache Override",
                    "title": "Cache Override",
                    "format": "boolean",
                    "x-displayname": "Cache Override"
                },
                "cache_ttl": {
                    "type": "string",
                    "description": " Cache TTL value is used to cache the resource/content for the specified amount of time\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"5m, 60s, 120s, 3h, 1d, 15d\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "Cache TTL Key",
                    "x-displayname": "Cache TTL",
                    "x-ves-example": "5m, 60s, 120s, 3h, 1d, 15d",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                },
                "ignore_response_cookie": {
                    "type": "boolean",
                    "description": " By default, response will not be cached if set-cookie header is present. This option will override the behavior and cache response even with set-cookie header present.",
                    "title": "Set Cookie",
                    "format": "boolean",
                    "x-displayname": "Ignore-Response-Cookie"
                }
            }
        },
        "cdn_loadbalancerCacheTTLOptionsType": {
            "type": "object",
            "description": "x-displayName: \"Cache Options\"\nThis defines the options related to content caching",
            "title": "Cache options",
            "properties": {
                "cache_disabled": {
                    "description": "x-displayName: \"Disable Cache\"\nDisable Caching of content from the origin",
                    "title": "Disable Cache",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "cache_ttl_default": {
                    "type": "string",
                    "description": "x-displayName: \"Default Cache TTL\"\nCache TTL value to use when the origin does not provide one",
                    "title": "Default Cache TTL"
                },
                "cache_ttl_override": {
                    "type": "string",
                    "description": "x-displayName: \"Override Cache TTL\"\nOverride the Cache TTL directive in the response from the origin",
                    "title": "Override Cache TTL"
                }
            }
        },
        "cdn_loadbalancerCdnOriginPoolType": {
            "type": "object",
            "description": "Origin Pool for the CDN distribution",
            "title": "CdnOriginPoolType",
            "x-displayname": "CDN Origin Pool",
            "x-ves-oneof-field-tls_choice": "[\"no_tls\",\"use_tls\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CdnOriginPoolType",
            "properties": {
                "more_origin_options": {
                    "title": "Advanced Configuration",
                    "$ref": "#/definitions/cdn_loadbalancerOriginAdvancedConfiguration",
                    "x-displayname": "Advanced Configuration"
                },
                "no_tls": {
                    "description": "Exclusive with [use_tls]\n Origin servers do not use TLS",
                    "title": "No TLS",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No TLS"
                },
                "origin_request_timeout": {
                    "type": "string",
                    "description": " Configures the time after which a request to the origin will time out waiting for a response\n\nExample: - \"100s\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_time_interval: 10m\n  ves.io.schema.rules.string.min_time_interval: 10s\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "Origin Request Timeout",
                    "x-displayname": "Origin Request Timeout Duration",
                    "x-ves-example": "100s",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_time_interval": "10m",
                        "ves.io.schema.rules.string.min_time_interval": "10s",
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                },
                "origin_servers": {
                    "type": "array",
                    "description": " List of original servers\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "List of Origin Servers",
                    "minItems": 1,
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCDNOriginServerType"
                    },
                    "x-displayname": "List Of Origin Servers",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "public_name": {
                    "description": " The DNS name to be used as the host header for the request to the origin server\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "OriginServerPublicName",
                    "$ref": "#/definitions/origin_poolOriginServerPublicName",
                    "x-displayname": "Origin Host Header",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "use_tls": {
                    "description": "Exclusive with [no_tls]\n Origin servers use TLS",
                    "title": "Use TLS",
                    "$ref": "#/definitions/origin_poolUpstreamTlsParameters",
                    "x-displayname": "TLS"
                }
            }
        },
        "cdn_loadbalancerCommonSecurityControls": {
            "type": "object",
            "description": "x-displayName: \"Common Security Controls\"",
            "title": "Common Security Controls",
            "properties": {
                "active_service_policies": {
                    "description": "x-displayName: \"Apply Specified Service Policies\"\nApply the specified list of service policies and bypass the namespace service policy set",
                    "title": "Apply Specified Service Policies",
                    "$ref": "#/definitions/common_wafServicePolicyList"
                },
                "api_rate_limit": {
                    "description": "x-displayName: \"API Rate Limit\"\nDefine rate limiting for one or more API endpoints",
                    "title": "Rate Limiting Parameters",
                    "$ref": "#/definitions/common_wafAPIRateLimit"
                },
                "blocked_clients": {
                    "type": "array",
                    "description": "x-displayName: \"Client Blocking Rules\"\nDefine rules to block IP Prefixes or AS numbers.",
                    "title": "Client Blocking Rules",
                    "items": {
                        "$ref": "#/definitions/common_wafSimpleClientSrcRule"
                    }
                },
                "captcha_challenge": {
                    "description": "x-displayName: \"Captcha Challenge\"\nConfigure Captcha challenge on this load balancer",
                    "title": "Captcha Challenge",
                    "$ref": "#/definitions/virtual_hostCaptchaChallengeType"
                },
                "challenge_on_cache_miss": {
                    "description": "x-displayName: \"Enable Only on Cache Miss\"\nConfigure auto mitigation i.e risk based challenges for malicious users only on cache miss in this load balancer",
                    "title": "Enable Challenge Only on Cache Miss",
                    "$ref": "#/definitions/common_wafEnableChallenge"
                },
                "cors_policy": {
                    "description": "x-displayName: \"CORS Policy\"\nCross-Origin Resource Sharing requests configuration\n\nCORS is a mechanism that uses additional HTTP headers to tell a browser to let\na web application running at one origin (domain) have permission to access selected\nresources from a server at a different origin",
                    "title": "cors_policy",
                    "$ref": "#/definitions/schemaCorsPolicy"
                },
                "disable_ip_reputation": {
                    "description": "x-displayName: \"Disable\"\nNo IP reputation configured this distribution",
                    "title": "disable_ip_reputation",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "disable_malicious_user_detection": {
                    "description": "x-displayName: \"Disable\"\nDisable malicious user detection for this distribution",
                    "title": "Disable malicious user detection",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "disable_rate_limit": {
                    "description": "x-displayName: \"Disable\"\nRate limiting is not currently enabled for this load balancer",
                    "title": "Disable Rate Limiting",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "disable_threat_mesh": {
                    "description": "x-displayName: \"Disable\"",
                    "title": "disable_threat_mesh",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "enable_challenge": {
                    "description": "x-displayName: \"Enable for All Requests\"\nConfigure auto mitigation i.e risk based challenges for malicious users for this load balancer",
                    "title": "Enable",
                    "$ref": "#/definitions/common_wafEnableChallenge"
                },
                "enable_ip_reputation": {
                    "description": "x-displayName: \"Enable for All Requests\"\nEnable IP reputation for all requests in this distribution",
                    "title": "enable_ip_reputation",
                    "$ref": "#/definitions/viewscommon_wafIPThreatCategoryListType"
                },
                "enable_malicious_user_detection": {
                    "description": "x-displayName: \"Enable for All Requests\"\nEnable malicious user detection for all requests in this distribution",
                    "title": "Enable malicious user detection",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "enable_threat_mesh": {
                    "description": "x-displayName: \"Enable\"",
                    "title": "enable_threat_mesh",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "ip_reputation_on_cache_miss": {
                    "description": "x-displayName: \"Enable Only on Cache Miss\"\nEnable IP reputation only on cache miss in this distribution",
                    "title": "Enable Ip Reuputation Only on Cache Miss",
                    "$ref": "#/definitions/viewscommon_wafIPThreatCategoryListType"
                },
                "js_challenge": {
                    "description": "x-displayName: \"JavaScript Challenge\"\nConfigure JavaScript challenge on this load balancer",
                    "title": "JavaScript Challenge",
                    "$ref": "#/definitions/virtual_hostJavascriptChallengeType"
                },
                "malicious_user_detection_on_cache_miss": {
                    "description": "x-displayName: \"Enable Only on Cache Miss\"\nEnable malicious user detection only on cache miss in this distribution",
                    "title": "Enable Malicious User Detection Only on Cache Miss",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "no_challenge": {
                    "description": "x-displayName: \"Disable\"\nNo challenge is enabled for this load balancer",
                    "title": "Disable",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "no_service_policies": {
                    "description": "x-displayName: \"Do Not Apply Service Policies\"\nDo not apply any service policies i.e. bypass the namespace service policy set",
                    "title": "Do Not Apply Service Policies",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "policy_based_challenge": {
                    "description": "x-displayName: \"Policy Based Challenge\"\nSpecifies the settings for policy rule based challenge",
                    "title": "policy based challenge",
                    "$ref": "#/definitions/viewscommon_wafPolicyBasedChallenge"
                },
                "rate_limit": {
                    "description": "x-displayName: \"Custom Rate Limiting Parameters\"\nDefine custom rate limiting parameters for this load balancer",
                    "title": "Custom Rate Limiting Parameters",
                    "$ref": "#/definitions/common_wafRateLimitConfigType"
                },
                "service_policies_from_namespace": {
                    "description": "x-displayName: \"Apply Namespace Service Policies\"\nApply the active service policies configured as part of the namespace service policy set",
                    "title": "Apply Namespace Service Policies",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "trusted_clients": {
                    "type": "array",
                    "description": "x-displayName: \"Trusted Client Rules\"\nDefine rules to skip processing of one or more features such as WAF, Bot Defense etc. for clients.",
                    "title": "Trusted Client Rules",
                    "items": {
                        "$ref": "#/definitions/common_wafSimpleClientSrcRule"
                    }
                },
                "user_id_client_ip": {
                    "description": "x-displayName: \"Client IP Address\"\nUse the Client IP address as the user identifier.",
                    "title": "user_id_client_ip",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "user_identification": {
                    "description": "x-displayName: \"User Identification Policy\"\nA reference to user_identification object.\nThe rules in the user_identification object are evaluated to determine the user identifier.",
                    "title": "user_identification",
                    "$ref": "#/definitions/schemaviewsObjectRefType"
                }
            }
        },
        "cdn_loadbalancerCreateRequest": {
            "type": "object",
            "description": "This is the input message of the 'Create' RPC",
            "title": "CreateRequest is used to create an instance of cdn_loadbalancer",
            "x-displayname": "Create Request",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CreateRequest",
            "properties": {
                "metadata": {
                    "description": " Standard object's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectCreateMetaType",
                    "x-displayname": "Metadata"
                },
                "spec": {
                    "description": " Specification of the desired behavior of the tenant",
                    "title": "spec",
                    "$ref": "#/definitions/viewscdn_loadbalancerCreateSpecType",
                    "x-displayname": "Spec"
                }
            }
        },
        "cdn_loadbalancerCreateResponse": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CreateResponse",
            "properties": {
                "metadata": {
                    "description": " Standard object's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectGetMetaType",
                    "x-displayname": "Metadata"
                },
                "spec": {
                    "description": " Specification of the desired behavior of the tenant",
                    "title": "spec",
                    "$ref": "#/definitions/viewscdn_loadbalancerGetSpecType",
                    "x-displayname": "Spec"
                },
                "system_metadata": {
                    "description": " System generated object's metadata",
                    "title": "system metadata",
                    "$ref": "#/definitions/schemaSystemObjectGetMetaType",
                    "x-displayname": "System Metadata"
                }
            }
        },
        "cdn_loadbalancerDefaultCacheAction": {
            "type": "object",
            "description": "This defines a Default Cache Action",
            "title": "Default Cache Action",
            "x-displayname": "Default Cache Action",
            "x-ves-oneof-field-cache_actions": "[\"cache_disabled\",\"cache_ttl_default\",\"cache_ttl_override\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.DefaultCacheAction",
            "properties": {
                "cache_disabled": {
                    "description": "Exclusive with [cache_ttl_default cache_ttl_override]\n Disable Caching of content from the origin",
                    "title": "Disable Cache",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable Cache"
                },
                "cache_ttl_default": {
                    "type": "string",
                    "description": "Exclusive with [cache_disabled cache_ttl_override]\n Cache TTL value to use when the origin does not provide one\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "Default Cache TTL",
                    "x-displayname": "Default Cache TTL",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                },
                "cache_ttl_override": {
                    "type": "string",
                    "description": "Exclusive with [cache_disabled cache_ttl_default]\n Override the Cache TTL directive in the response from the origin\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "Override Cache TTL",
                    "x-displayname": "Override Cache TTL",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerDefaultCacheTTLProps": {
            "type": "object",
            "description": "x-displayName: \"Default Cache TTL Props\"\nDefault Cache TTL Enable Values",
            "title": "Default Cache TTL Props",
            "properties": {
                "cache_ttl": {
                    "type": "string",
                    "description": "x-displayName: \"Cache TTL\"\nx-required\nx-example: \"5m, 60s, 120s, 3h, 1d, 15d\"\nCache TTL value is used to cache the resource/content for the specified amount of time\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "Cache TTL Key"
                }
            }
        },
        "cdn_loadbalancerDeleteRequest": {
            "type": "object",
            "description": "This is the input message of the 'Delete' RPC.",
            "title": "DeleteRequest is used to delete a cdn_loadbalancer",
            "x-displayname": "Delete Request",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.DeleteRequest",
            "properties": {
                "fail_if_referred": {
                    "type": "boolean",
                    "description": " Fail the delete operation if this object is being referred by other objects",
                    "title": "fail_if_referred",
                    "format": "boolean",
                    "x-displayname": "Fail-If-Referred"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the configuration object\n\nExample: - \"name\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "name"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace in which the configuration object is present\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                }
            }
        },
        "cdn_loadbalancerGeoFilteringOptions": {
            "type": "object",
            "description": "x-displayName: \"Geo Filtering Options\"\nOptions to filter based on Geo prefix",
            "title": "GeoFilteringOptions",
            "properties": {
                "allow_list": {
                    "description": "x-displayName: \"Allow List\"\nAllow list of countries",
                    "title": "Geo filtering type Allow List",
                    "$ref": "#/definitions/policyCountryCodeList"
                },
                "block_list": {
                    "description": "x-displayName: \"Block List\"\nBlock list of countries",
                    "title": "geo filtering type Block List",
                    "$ref": "#/definitions/policyCountryCodeList"
                }
            }
        },
        "cdn_loadbalancerGetResponse": {
            "type": "object",
            "description": "This is the output message of the 'Get' RPC",
            "title": "GetResponse is the shape of a read cdn_loadbalancer",
            "x-displayname": "Get Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.GetResponse",
            "properties": {
                "create_form": {
                    "description": "Format used to create a new similar object",
                    "title": "create_form",
                    "$ref": "#/definitions/cdn_loadbalancerCreateRequest",
                    "x-displayname": "CreateRequest Format"
                },
                "deleted_referred_objects": {
                    "type": "array",
                    "description": "The set of deleted objects that are referred by this object",
                    "title": "deleted_referred_objects",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Deleted Referred Objects"
                },
                "disabled_referred_objects": {
                    "type": "array",
                    "description": "The set of deleted objects that are referred by this object",
                    "title": "disabled_referred_objects",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Disabled Referred Objects"
                },
                "metadata": {
                    "description": " Standard object's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectGetMetaType",
                    "x-displayname": "Metadata"
                },
                "referring_objects": {
                    "type": "array",
                    "description": "The set of objects that are referring to this object in their spec",
                    "title": "referring_objects",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Referring Objects"
                },
                "replace_form": {
                    "description": "Format to replace changeable values in object",
                    "title": "replace_form",
                    "$ref": "#/definitions/cdn_loadbalancerReplaceRequest",
                    "x-displayname": "ReplaceRequest Format"
                },
                "spec": {
                    "description": " Specification of the desired behavior of the tenant",
                    "title": "spec",
                    "$ref": "#/definitions/viewscdn_loadbalancerGetSpecType",
                    "x-displayname": "Spec"
                },
                "status": {
                    "type": "array",
                    "description": "The status reported by different services for this configuration object",
                    "title": "status",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerStatusObject"
                    },
                    "x-displayname": "Status"
                },
                "system_metadata": {
                    "description": " System generated object's metadata",
                    "title": "system metadata",
                    "$ref": "#/definitions/schemaSystemObjectGetMetaType",
                    "x-displayname": "System Metadata"
                }
            }
        },
        "cdn_loadbalancerGetResponseFormatCode": {
            "type": "string",
            "description": "x-displayName: \"Get Response Format\"\nThis is the various forms that can be requested to be sent in the GetResponse\n\n - GET_RSP_FORMAT_DEFAULT: x-displayName: \"Default Format\"\nDefault format of returned resource\n - GET_RSP_FORMAT_FOR_CREATE: x-displayName: \"Create request Format\"\nResponse should be in CreateRequest format\n - GET_RSP_FORMAT_FOR_REPLACE: x-displayName: \"Replace request format\"\nResponse should be in ReplaceRequest format\n - GET_RSP_FORMAT_STATUS: x-displayName: \"Status format\"\nResponse should be in StatusObject(s) format\n - GET_RSP_FORMAT_READ: x-displayName: \"GetSpecType format\"\nResponse should be in format of GetSpecType\n - GET_RSP_FORMAT_REFERRING_OBJECTS: x-displayName: \"Referring Objects\"\nResponse should have other objects referring to this object\n - GET_RSP_FORMAT_BROKEN_REFERENCES: x-displayName: \"Broken Referred Objects\"\nResponse should have deleted and disabled objects referrred by this object",
            "title": "GetResponseFormatCode",
            "enum": [
                "GET_RSP_FORMAT_DEFAULT",
                "GET_RSP_FORMAT_FOR_CREATE",
                "GET_RSP_FORMAT_FOR_REPLACE",
                "GET_RSP_FORMAT_STATUS",
                "GET_RSP_FORMAT_READ",
                "GET_RSP_FORMAT_REFERRING_OBJECTS",
                "GET_RSP_FORMAT_BROKEN_REFERENCES"
            ],
            "default": "GET_RSP_FORMAT_DEFAULT"
        },
        "cdn_loadbalancerHeaderControlType": {
            "type": "object",
            "description": "This defines various options related to request/response headers",
            "title": "Header Control",
            "x-displayname": "Header Control",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.HeaderControlType",
            "properties": {
                "request_headers_to_add": {
                    "type": "array",
                    "description": " Headers are key-value pairs to be added to HTTP request being routed towards upstream.\n Headers specified at this level are applied after headers from matched Route are applied\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Headers to add in request",
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/schemaHeaderManipulationOptionType"
                    },
                    "x-displayname": "Add Origin Request Headers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "request_headers_to_remove": {
                    "type": "array",
                    "description": " List of keys of Headers to be removed from the HTTP request being sent towards upstream.\n\nExample: - \"host\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.min_bytes: 1\n  ves.io.schema.rules.repeated.items.string.pattern: ^[0-9A-Za-z_\\\\-\\\\.]+$\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Header to be removed from request",
                    "maxItems": 32,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 256
                    },
                    "x-displayname": "Remove Origin Request Headers",
                    "x-ves-example": "host",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.min_bytes": "1",
                        "ves.io.schema.rules.repeated.items.string.pattern": "^[0-9A-Za-z_\\\\-\\\\.]+$",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "response_headers_to_add": {
                    "type": "array",
                    "description": " Headers are key-value pairs to be added to HTTP response being sent towards downstream.\n Headers specified at this level are applied after headers from matched Route are applied\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Headers to add in response",
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/schemaHeaderManipulationOptionType"
                    },
                    "x-displayname": "Add Response Headers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "response_headers_to_remove": {
                    "type": "array",
                    "description": " List of keys of Headers to be removed from the HTTP response being sent towards downstream.\n\nExample: - \"host\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.pattern: ^[0-9A-Za-z_\\\\-\\\\.]+$\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Header to be removed from response",
                    "maxItems": 32,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Remove Response Headers",
                    "x-ves-example": "host",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.pattern": "^[0-9A-Za-z_\\\\-\\\\.]+$",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerHeaderOptions": {
            "type": "string",
            "description": "\n - proxy_host: Proxy Host\n\nName of the proxied server\n - referer: Referer\n\nThis is the address of the previous web page from which a link to the currently requested page was followed\n - scheme: Scheme\n\nThe http scheme used: http or https\n - user_agent: User Agent\n\nThe user agent string of the user agent",
            "title": "Header Options",
            "enum": [
                "proxy_host",
                "referer",
                "scheme",
                "user_agent"
            ],
            "default": "proxy_host",
            "x-displayname": "Header Options",
            "x-ves-proto-enum": "ves.io.schema.views.cdn_loadbalancer.HeaderOptions"
        },
        "cdn_loadbalancerIpFilteringOptions": {
            "type": "object",
            "description": "x-displayName: \"IP Filtering Options\"\nOptions to filter based on IP prefix",
            "title": "IpFilteringOptions",
            "properties": {
                "allow_list": {
                    "description": "x-displayName: \"Allow List\"\nAllow list of ip prefixes",
                    "title": "Ip filtering type Allow List",
                    "$ref": "#/definitions/policyPrefixMatchList"
                },
                "block_list": {
                    "description": "x-displayName: \"Block List\"\nBlock list of ip prefixes",
                    "title": "Ip filtering type Block List",
                    "$ref": "#/definitions/policyPrefixMatchList"
                }
            }
        },
        "cdn_loadbalancerListResponse": {
            "type": "object",
            "description": "This is the output message of 'List' RPC.",
            "title": "ListResponse is the collection of cdn_loadbalancer",
            "x-displayname": "List Response",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ListResponse",
            "properties": {
                "errors": {
                    "type": "array",
                    "description": " Errors(if any) while listing items from collection",
                    "title": "errors",
                    "items": {
                        "$ref": "#/definitions/schemaErrorType"
                    },
                    "x-displayname": "Errors"
                },
                "items": {
                    "type": "array",
                    "description": " items represents the collection in response",
                    "title": "items",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerListResponseItem"
                    },
                    "x-displayname": "Items"
                }
            }
        },
        "cdn_loadbalancerListResponseItem": {
            "type": "object",
            "description": "By default a summary of cdn_loadbalancer is returned in 'List'. By setting\n'report_fields' in the ListRequest more details of each item can be got.",
            "title": "ListResponseItem is an individual item in a collection of cdn_loadbalancer",
            "x-displayname": "List Item",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ListResponseItem",
            "properties": {
                "annotations": {
                    "type": "object",
                    "description": " The set of annotations present on this cdn_loadbalancer",
                    "title": "annotations",
                    "x-displayname": "Annotations"
                },
                "description": {
                    "type": "string",
                    "description": " The description set for this cdn_loadbalancer",
                    "title": "description",
                    "x-displayname": "Description"
                },
                "disabled": {
                    "type": "boolean",
                    "description": " A value of true indicates cdn_loadbalancer is administratively disabled",
                    "title": "disabled",
                    "format": "boolean",
                    "x-displayname": "Disabled"
                },
                "get_spec": {
                    "description": " If ListRequest has any specified report_fields, it will appear in object",
                    "title": "get_spec",
                    "$ref": "#/definitions/viewscdn_loadbalancerGetSpecType",
                    "x-displayname": "Get Specification"
                },
                "labels": {
                    "type": "object",
                    "description": " The set of labels present on this cdn_loadbalancer",
                    "title": "labels",
                    "x-displayname": "Labels"
                },
                "metadata": {
                    "description": " If list request has report_fields set then metadata will\n contain all the metadata associated with the object.",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectGetMetaType",
                    "x-displayname": "Metadata"
                },
                "name": {
                    "type": "string",
                    "description": " The name of this cdn_loadbalancer\n\nExample: - \"name\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "name"
                },
                "namespace": {
                    "type": "string",
                    "description": " The namespace this item belongs to\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "owner_view": {
                    "description": " Reference to the view object that owns this object.\n If there is no view owner, this field will be nil.\n If not nil, this object can only be edited/deleted through the view",
                    "title": "owner_view",
                    "$ref": "#/definitions/schemaViewRefType",
                    "x-displayname": "Owner View"
                },
                "status_set": {
                    "type": "array",
                    "description": " The status reported by different services for this configuration object",
                    "title": "status",
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerStatusObject"
                    },
                    "x-displayname": "Status"
                },
                "system_metadata": {
                    "description": " If list request has report_fields set then system_metadata will\n contain all the system generated details of this object.",
                    "title": "system_metadata",
                    "$ref": "#/definitions/schemaSystemObjectGetMetaType",
                    "x-displayname": "System Metadata"
                },
                "tenant": {
                    "type": "string",
                    "description": " The tenant this item belongs to\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " The unique uid of this cdn_loadbalancer\n\nExample: - \"d27938ba-967e-40a7-9709-57b8627f9f75\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d27938ba-967e-40a7-9709-57b8627f9f75"
                }
            }
        },
        "cdn_loadbalancerLogHeaderOptions": {
            "type": "object",
            "description": "List of headers to Log",
            "title": "LogHeaderOptions",
            "x-displayname": "Headers to Log",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LogHeaderOptions",
            "properties": {
                "header_list": {
                    "type": "array",
                    "description": " List of headers\n\nExample: - \"x-custom-length\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "List of Headers",
                    "maxItems": 64,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Headers",
                    "x-ves-example": "x-custom-length",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "cdn_loadbalancerLoggingOptionsType": {
            "type": "object",
            "description": "This defines various options related to logging",
            "title": "Logging options",
            "x-displayname": "Logging Options",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.LoggingOptionsType",
            "properties": {
                "client_log_options": {
                    "description": " Client request headers to log",
                    "title": "client_log_options",
                    "$ref": "#/definitions/cdn_loadbalancerLogHeaderOptions",
                    "x-displayname": "Client Request Headers to Log"
                },
                "origin_log_options": {
                    "description": " Origin response headers to log",
                    "title": "origin_log_options",
                    "$ref": "#/definitions/cdn_loadbalancerLogHeaderOptions",
                    "x-displayname": "Origin Response Headers to Log"
                }
            }
        },
        "cdn_loadbalancerOriginAdvancedConfiguration": {
            "type": "object",
            "title": "Origin Byte Range Request Config",
            "x-displayname": "Origin Byte Range Request Config",
            "x-ves-displayorder": "1,2",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.OriginAdvancedConfiguration",
            "properties": {
                "disable_byte_range_request": {
                    "type": "boolean",
                    "description": " Choice to enable/disable origin byte range requrests towards origin\n\nExample: - \"true/false\"-",
                    "title": "Disable Origin Byte Range Requests",
                    "format": "boolean",
                    "x-displayname": "Disable Origin Byte Range Requests",
                    "x-ves-example": "true/false"
                },
                "websocket_proxy": {
                    "type": "boolean",
                    "description": " Option to enable proxying of websocket connections to the origin server",
                    "title": "Enable websocket proxy to the origin",
                    "format": "boolean",
                    "x-displayname": "Enable websocket proxy to the origin"
                }
            }
        },
        "cdn_loadbalancerOtherSettings": {
            "type": "object",
            "description": "Other Settings",
            "title": "Other Settings",
            "x-displayname": "Other Settings",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.OtherSettings",
            "properties": {
                "add_location": {
                    "type": "boolean",
                    "description": " x-example: true\n Appends header x-volterra-location = \u003cre-site-name\u003e in responses.\n\nExample: - \"true\"-",
                    "title": "Add Site information",
                    "format": "boolean",
                    "x-displayname": "Add Location",
                    "x-ves-example": "true"
                },
                "header_options": {
                    "description": " Request/Response header related options",
                    "title": "Header Control",
                    "$ref": "#/definitions/cdn_loadbalancerHeaderControlType",
                    "x-displayname": "Header Control"
                },
                "logging_options": {
                    "description": " Logging related options",
                    "title": "Logging Options",
                    "$ref": "#/definitions/cdn_loadbalancerLoggingOptionsType",
                    "x-displayname": "Logging Options"
                }
            }
        },
        "cdn_loadbalancerReplaceRequest": {
            "type": "object",
            "description": "This is the input message of the 'Replace' RPC",
            "title": "ReplaceRequest is used to replace contents of a cdn_loadbalancer",
            "x-displayname": "Replace Request",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ReplaceRequest",
            "properties": {
                "metadata": {
                    "description": " Standard object's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaObjectReplaceMetaType",
                    "x-displayname": "Metadata"
                },
                "spec": {
                    "description": " Specification of the desired behavior of the tenant",
                    "title": "spec",
                    "$ref": "#/definitions/viewscdn_loadbalancerReplaceSpecType",
                    "x-displayname": "Spec"
                }
            }
        },
        "cdn_loadbalancerReplaceResponse": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ReplaceResponse"
        },
        "cdn_loadbalancerSecurityOptionsType": {
            "type": "object",
            "description": "x-displayName: \"Security Options\"\nThis defines various options related to security",
            "title": "Security options",
            "properties": {
                "api_protection": {
                    "description": "x-displayName: \"API Protection\"",
                    "title": "API Protection",
                    "$ref": "#/definitions/cdn_loadbalancerApiProtection"
                },
                "auth_options": {
                    "description": "x-displayName: \"Authentication Options\"\nAuthentication Options",
                    "title": "authentication",
                    "$ref": "#/definitions/cdn_loadbalancerAuthenticationOptions"
                },
                "common_security_controls": {
                    "description": "x-displayName: \"Common Security Controls\"",
                    "title": "Common Security Controls",
                    "$ref": "#/definitions/cdn_loadbalancerCommonSecurityControls"
                },
                "geo_filtering": {
                    "description": "x-displayName: \"Client Geo filtering Options\"\nGeo filtering options",
                    "title": "geo_filtering",
                    "$ref": "#/definitions/cdn_loadbalancerGeoFilteringOptions"
                },
                "ip_filtering": {
                    "description": "x-displayName: \"Client IP filtering Options\"\nIP filtering options",
                    "title": "ip_filtering",
                    "$ref": "#/definitions/cdn_loadbalancerIpFilteringOptions"
                },
                "web_app_firewall": {
                    "description": "x-displayName: \"Web Application Firewall\"\nWeb Application Firewall",
                    "title": "Web Application Firewall",
                    "$ref": "#/definitions/cdn_loadbalancerWebApplicationFirewall"
                }
            }
        },
        "cdn_loadbalancerStatusObject": {
            "type": "object",
            "description": "Most recently observed status of object",
            "title": "StatusObject",
            "x-displayname": "Status",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.StatusObject",
            "properties": {
                "conditions": {
                    "type": "array",
                    "description": " Conditions represent the normalized status values for configuration object",
                    "title": "conditions",
                    "items": {
                        "$ref": "#/definitions/schemaConditionType"
                    },
                    "x-displayname": "Conditions"
                },
                "metadata": {
                    "description": " Standard status's metadata",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaStatusMetaType",
                    "x-displayname": "Metadata"
                },
                "object_refs": {
                    "type": "array",
                    "description": " CDN loadbalancer view object direct reference",
                    "title": "object_refs",
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "Config Object"
                },
                "site_status": {
                    "description": " CDNLbStatusType shows deployment status on a specific site",
                    "title": "site_status",
                    "$ref": "#/definitions/cdn_loadbalancerCDNLbStatusType",
                    "x-displayname": "Site Status"
                },
                "status": {
                    "description": " Status of CDN loadbalancer deployment on Lilac GC",
                    "title": "status",
                    "$ref": "#/definitions/cdn_loadbalancerCDNLoadbalancerStatus",
                    "x-displayname": "CDN LoadBalancer Status"
                },
                "virtual_host_status": {
                    "description": " DNS related Virtual Host status",
                    "title": "DNS Virtual Host Status",
                    "$ref": "#/definitions/virtual_hostDNSVHostStatusType",
                    "x-displayname": "DNS Virtual Host Status"
                }
            }
        },
        "cdn_loadbalancerTlsCertOptions": {
            "type": "object",
            "description": "TLS Certificate Options",
            "title": "TLS Configuration Options",
            "x-displayname": "TLS Options",
            "x-ves-oneof-field-tls_certificates_choice": "[\"tls_cert_params\",\"tls_inline_params\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.TlsCertOptions",
            "properties": {
                "tls_cert_params": {
                    "description": "Exclusive with [tls_inline_params]\n Select/Add one or more TLS Certificate objects to associate with this Load Balancer",
                    "title": "TLS Certificates",
                    "$ref": "#/definitions/viewsDownstreamTLSCertsParams",
                    "x-displayname": "TLS Certificates"
                },
                "tls_inline_params": {
                    "description": "Exclusive with [tls_cert_params]\n Upload a TLS certificate covering all domain names for this Load Balancer",
                    "title": "Inline TLS Parameters (legacy)",
                    "$ref": "#/definitions/schemaviewsDownstreamTlsParamsType",
                    "x-displayname": "Inline Certificate (legacy)"
                }
            }
        },
        "cdn_loadbalancerWebApplicationFirewall": {
            "type": "object",
            "description": "x-displayName: \"Web Application Firewall\"\nWeb Application Firewall",
            "title": "Web Application Firewall",
            "properties": {
                "app_firewall": {
                    "description": "x-displayName: \"Enable for All Requests\"\nEnable WAF configuration for all requests in this distribution",
                    "title": "Application Firewall for All Requests",
                    "$ref": "#/definitions/schemaviewsObjectRefType"
                },
                "app_firewall_on_cache_miss": {
                    "description": "x-displayName: \"Enable Only on Cache Miss\"\nEnable WAF configuration only on cache miss in this distribution",
                    "title": "Application Firewall Enable Only on Cache Miss",
                    "$ref": "#/definitions/schemaviewsObjectRefType"
                },
                "csrf_policy": {
                    "description": "x-displayName: \"Cross-Site Request Forgery Protection\"\nCross-Site Request Forgery (CSRF) is an attack that occurs when a malicious third-party website exploits a vulnerability thats allows them to submit an undesired request on user's behalf.\n\nThe policy checks where a request is coming from to determine if the request's origin is the same as its destination. The policy relies on two pieces of information used in determining if a request originated from the same host.\n\n1. The origin that caused the user agent to issue the request (source origin).\n2. The origin that the request is going to (target origin).\nWhen the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being the source-origin has been added to the policy as valid.\nBecause CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).",
                    "title": "csrf_policy",
                    "$ref": "#/definitions/schemaCsrfPolicy"
                },
                "data_guard_rules": {
                    "type": "array",
                    "description": "x-displayName: \"Data Guard Rules\"\nData Guard prevents responses from exposing sensitive information by masking the data.\nThe system masks credit card numbers and social security numbers leaked from the application from within the http response with a string of asterisks (*).\nNote: App Firewall should be enabled, to use Data Guard feature.",
                    "title": "Data Guard Rules",
                    "items": {
                        "$ref": "#/definitions/policySimpleDataGuardRule"
                    }
                },
                "disable_waf": {
                    "description": "x-displayName: \"Disable\"\nNo WAF configuration for this load balancer",
                    "title": "Disable WAF",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "graphql_rules": {
                    "type": "array",
                    "description": "x-displayName: \"GraphQL Inspection\"\nGraphQL is a query language and server-side runtime for APIs which provides a complete and understandable\ndescription of the data in API. GraphQL gives clients the power to ask for exactly what they need, makes it\neasier to evolve APIs over time, and enables powerful developer tools. Policy configuration to analyze GraphQL\nqueries and prevent GraphQL tailored attacks.",
                    "title": "GraphQL Inspection",
                    "items": {
                        "$ref": "#/definitions/policyGraphQLRule"
                    }
                },
                "protected_cookies": {
                    "type": "array",
                    "description": "x-displayName: \"Cookie Protection\"\nAllows setting attributes (SameSite, Secure, and HttpOnly) on cookies in responses.\nCookie Tampering Protection prevents attackers from modifying the value of session cookies.\nFor Cookie Tampering Protection, enabling a web app firewall (WAF) is a prerequisite.\nThe configured mode of WAF (monitoring or blocking) will be enforced on the request when cookie tampering is identified.\nNote: We recommend enabling Secure and HttpOnly attributes along with cookie tampering protection.",
                    "title": "Cookie protection",
                    "items": {
                        "$ref": "#/definitions/schemaCookieManipulationOptionType"
                    }
                },
                "waf_exclusion_rules": {
                    "type": "array",
                    "description": "x-displayName: \"WAF Exclusion Rules\"\nDefine the Signature IDs, Violations, Attack Types and Bot Names that should be excluded from WAF processing on specific match criteria.\nThe match criteria include domain, path and method.\nWAF Exclusion rules is a sequential engine where rules are evaluated one after the other.\nIt's important to define the correct order for WAF exclusion rules to get the intended result, rules are evaluated from top to bottom in the list.\nFor each request, its characteristics are evaluated based on the match criteria in each WAF exclusion rule, starting from the top.\nWhen an exclusion rule is matched, then this exclusion rule takes effect and no more rules are evaluated.",
                    "title": "WAF Exclusion Rules",
                    "items": {
                        "$ref": "#/definitions/policySimpleWafExclusionRule"
                    }
                }
            }
        },
        "common_securityAppEndpointType": {
            "type": "object",
            "description": "Application Endpoint.",
            "title": "AppEndpointType",
            "x-displayname": "Application Endpoint",
            "x-ves-displayorder": "1,2,13,3,5,4,8,12,16",
            "x-ves-oneof-field-app_traffic_type_choice": "[\"mobile\",\"web\",\"web_mobile\"]",
            "x-ves-oneof-field-domain_matcher_choice": "[\"any_domain\",\"domain\"]",
            "x-ves-oneof-field-flow_label_choice": "[\"flow_label\",\"undefined_flow_label\"]",
            "x-ves-oneof-field-goodbot_choice": "[\"allow_good_bots\",\"mitigate_good_bots\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_security.AppEndpointType",
            "properties": {
                "allow_good_bots": {
                    "description": "Exclusive with [mitigate_good_bots]\n System flags Good Bot traffic and allow it to continue to the origin",
                    "title": "x-displayName: \"Allow All Good Bots to Continue to Origin\"",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Allow All Good Bots to Continue to Origin"
                },
                "any_domain": {
                    "description": "Exclusive with [domain]\n Any Domain.",
                    "title": "Any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "domain": {
                    "description": "Exclusive with [any_domain]\n Domain matcher.",
                    "title": "Domain",
                    "$ref": "#/definitions/schemaDomainType",
                    "x-displayname": "Domain"
                },
                "flow_label": {
                    "description": "Exclusive with [undefined_flow_label]\n",
                    "title": "flow_label",
                    "$ref": "#/definitions/schemaBotDefenseFlowLabelCategoriesChoiceType",
                    "x-displayname": "Specify Endpoint label category"
                },
                "http_methods": {
                    "type": "array",
                    "description": " List of HTTP methods.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.in: [0,1,3,4,10]\n  ves.io.schema.rules.repeated.max_items: 5\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "HTTP Methods",
                    "minItems": 1,
                    "maxItems": 5,
                    "items": {
                        "$ref": "#/definitions/schemaBotHttpMethod"
                    },
                    "x-displayname": "HTTP Methods",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.in": "[0,1,3,4,10]",
                        "ves.io.schema.rules.repeated.max_items": "5",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "mitigate_good_bots": {
                    "description": "Exclusive with [allow_good_bots]\n System flags Good Bot Traffic, but mitigation is handled in the  same manner as malicious automated traffic defined above",
                    "title": "x-displayName: \"Apply Mitigation to Good Bots\"",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Apply Mitigation to Good Bots"
                },
                "mitigation": {
                    "description": " Mitigation action.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Mitigation",
                    "$ref": "#/definitions/policyShapeBotMitigationAction",
                    "x-displayname": "Bot Traffic Mitigation",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "mobile": {
                    "description": "Exclusive with [web web_mobile]\n Mobile traffic channel.",
                    "title": "MobileTrafficChannel",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Mobile Traffic"
                },
                "path": {
                    "description": " Matching URI path of the route.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Path",
                    "$ref": "#/definitions/ioschemaPathMatcherType",
                    "x-displayname": "Path",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "protocol": {
                    "description": " Protocol.",
                    "title": "Protocol",
                    "$ref": "#/definitions/common_securityURLScheme",
                    "x-displayname": "Protocol"
                },
                "undefined_flow_label": {
                    "description": "Exclusive with [flow_label]\n",
                    "title": "undefined",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Undefined"
                },
                "web": {
                    "description": "Exclusive with [mobile web_mobile]\n Web traffic channel.",
                    "title": "WebTrafficChannel",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Web Traffic"
                },
                "web_mobile": {
                    "description": "Exclusive with [mobile web]\n Web and mobile traffic channel.",
                    "title": "WebMobileTrafficChannel",
                    "$ref": "#/definitions/common_securityWebMobileTrafficType",
                    "x-displayname": "Web and Mobile Traffic"
                }
            }
        },
        "common_securityBotAdvancedMobileSDKConfigType": {
            "type": "object",
            "description": "x-displayName: \"Mobile Request Identifier Headers\"\nMobile Request Identifier Headers.",
            "title": "BotAdvancedMobileSDKConfigType",
            "properties": {
                "mobile_identifier": {
                    "description": "x-displayName: \"Mobile Request Identifier Headers\"\nMobile Request Identifier Headers Type.",
                    "title": "MobileTrafficIdentifierType",
                    "$ref": "#/definitions/common_securityMobileTrafficIdentifierType"
                }
            }
        },
        "common_securityBotDefenseAdvancedPolicyType": {
            "type": "object",
            "description": "x-displayName: \"Bot Defense Advanced Policy\"\nThis defines various configuration options for Bot Defense Advanced Policy.",
            "title": "BotDefenseAdvancedPolicyType",
            "properties": {
                "disable_mobile_sdk": {
                    "description": "x-displayName: \"Disable Mobile SDK\"\nDisable Mobile SDK.",
                    "title": "Disable Mobile SDK",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "js_download_path": {
                    "type": "string",
                    "description": "x-displayName: \"Web Client JavaScript Download Path\"\nx-example: \"/common.js\"\nx-required\nCustomize Bot Defense Web Client JavaScript path",
                    "title": "js_download_path"
                },
                "mobile_sdk_config": {
                    "description": "x-displayName: \"Enable Mobile SDK\"\nEnable Mobile SDK Configuration",
                    "title": "Enable Mobile SDK",
                    "$ref": "#/definitions/common_securityBotAdvancedMobileSDKConfigType"
                },
                "protected_app_endpoints": {
                    "type": "array",
                    "description": "x-displayName: \"Protected App Endpoints\"\nx-required\nList of protected endpoints (max 128 items)",
                    "title": "ProtectedAppEndpointType",
                    "items": {
                        "$ref": "#/definitions/common_securityProtectedAppEndpointType"
                    }
                }
            }
        },
        "common_securityBotDefenseAdvancedType": {
            "type": "object",
            "description": "x-displayName: \"Bot Defense Advanced\"\nBot Defense Advanced",
            "title": "BotDefenseAdvancedType",
            "properties": {
                "mobile": {
                    "description": "x-displayName: \"Infrastructure For Mobile\"\nSelect infrastructure for mobile.",
                    "title": "Mobile",
                    "$ref": "#/definitions/schemaviewsObjectRefType"
                },
                "policy": {
                    "description": "x-displayName: \"Bot Defense Advanced Policy\"\nx-required\nBot Defense Advanced Policy.",
                    "title": "BotDefenseAdvancedPolicyType",
                    "$ref": "#/definitions/common_securityBotDefenseAdvancedPolicyType"
                },
                "web": {
                    "description": "x-displayName: \"Infrastructure For Web\"\nSelect infrastructure for web.",
                    "title": "Web",
                    "$ref": "#/definitions/schemaviewsObjectRefType"
                }
            }
        },
        "common_securityCSDJavaScriptInsertAllWithExceptionsType": {
            "type": "object",
            "description": "Insert Client-Side Defense JavaScript in all pages  with the exceptions",
            "title": "CSDJavaScriptInsertAllWithExceptionsType",
            "x-displayname": "Insert JavaScript in All Pages with the Exceptions",
            "x-ves-proto-message": "ves.io.schema.views.common_security.CSDJavaScriptInsertAllWithExceptionsType",
            "properties": {
                "exclude_list": {
                    "type": "array",
                    "description": " Optional JavaScript insertions exclude list of domain and path matchers.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exclude_list",
                    "maxItems": 128,
                    "items": {
                        "$ref": "#/definitions/common_securityShapeJavaScriptExclusionRule"
                    },
                    "x-displayname": "Exclude Pages",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_securityCSDJavaScriptInsertType": {
            "type": "object",
            "description": "This defines custom JavaScript insertion rules for Client-Side Defense Policy.",
            "title": "CSDJavaScriptInsertType",
            "x-displayname": "JavaScript Custom Insertion Rules",
            "x-ves-proto-message": "ves.io.schema.views.common_security.CSDJavaScriptInsertType",
            "properties": {
                "exclude_list": {
                    "type": "array",
                    "description": " Optional JavaScript insertions exclude list of domain and path matchers.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exclude_list",
                    "maxItems": 128,
                    "items": {
                        "$ref": "#/definitions/common_securityShapeJavaScriptExclusionRule"
                    },
                    "x-displayname": "Exclude Paths",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "rules": {
                    "type": "array",
                    "description": " Required list of pages to insert Client-Side Defense client JavaScript.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "rules",
                    "minItems": 1,
                    "maxItems": 128,
                    "items": {
                        "$ref": "#/definitions/common_securityCSDJavaScriptInsertionRule"
                    },
                    "x-displayname": "JavaScript Insertions",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_securityCSDJavaScriptInsertionRule": {
            "type": "object",
            "description": "This defines a rule for Client-Side Defense JavaScript insertion.",
            "title": "CSDJavaScriptInsertionRule",
            "x-displayname": "JavaScript Insertion Rule",
            "x-ves-oneof-field-domain_matcher_choice": "[\"any_domain\",\"domain\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_security.CSDJavaScriptInsertionRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [domain]\n Any Domain.",
                    "title": "Any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "domain": {
                    "description": "Exclusive with [any_domain]\n Domain matcher.",
                    "title": "Domain",
                    "$ref": "#/definitions/schemaDomainType",
                    "x-displayname": "Domain"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "description": " URI path matcher.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Path",
                    "$ref": "#/definitions/ioschemaPathMatcherType",
                    "x-displayname": "Path",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_securityClientSideDefensePolicyType": {
            "type": "object",
            "description": "This defines various configuration options for Client-Side Defense policy.",
            "title": "ClientSideDefensePolicyType",
            "x-displayname": "Client-Side Defense Policy",
            "x-ves-oneof-field-java_script_choice": "[\"disable_js_insert\",\"js_insert_all_pages\",\"js_insert_all_pages_except\",\"js_insertion_rules\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_security.ClientSideDefensePolicyType",
            "properties": {
                "disable_js_insert": {
                    "description": "Exclusive with [js_insert_all_pages js_insert_all_pages_except js_insertion_rules]\n Disable JavaScript insertion.",
                    "title": "Disable JavaScript Insertion",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable JavaScript Insertion"
                },
                "js_insert_all_pages": {
                    "description": "Exclusive with [disable_js_insert js_insert_all_pages_except js_insertion_rules]\n Insert Client-Side Defense JavaScript in all pages.",
                    "title": "Insert JavaScript in All Pages",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Insert JavaScript in All Pages"
                },
                "js_insert_all_pages_except": {
                    "description": "Exclusive with [disable_js_insert js_insert_all_pages js_insertion_rules]\n Insert Client-Side Defense JavaScript in all pages with the exceptions.",
                    "title": "Insert JavaScript in All Pages with the Exceptions",
                    "$ref": "#/definitions/common_securityCSDJavaScriptInsertAllWithExceptionsType",
                    "x-displayname": "Insert JavaScript in All Pages with the Exceptions"
                },
                "js_insertion_rules": {
                    "description": "Exclusive with [disable_js_insert js_insert_all_pages js_insert_all_pages_except]\n Specify custom JavaScript insertion rules.",
                    "title": "Custom JavaScript Insertion Rules",
                    "$ref": "#/definitions/common_securityCSDJavaScriptInsertType",
                    "x-displayname": "Custom JavaScript Insertion Rules"
                }
            }
        },
        "common_securityClientSideDefenseType": {
            "type": "object",
            "description": "This defines various configuration options for Client-Side Defense Policy.",
            "title": "ClientSideDefenseType",
            "x-displayname": "Client-Side Defense",
            "x-ves-proto-message": "ves.io.schema.views.common_security.ClientSideDefenseType",
            "properties": {
                "policy": {
                    "description": " Configure the pages where you want Client-Side Defense Protection.\n Please ensure that the same domains are configured in the Client-Side Defense configuration.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "ClientSideDefensePolicyType",
                    "$ref": "#/definitions/common_securityClientSideDefensePolicyType",
                    "x-displayname": "Client-Side Defense Policy",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_securityDDoSClientSource": {
            "type": "object",
            "description": "DDoS Mitigation sources to be blocked",
            "title": "DDoSClientSource",
            "x-displayname": "DDoS Client Source Choice",
            "x-ves-displayorder": "1,3,5",
            "x-ves-proto-message": "ves.io.schema.views.common_security.DDoSClientSource",
            "properties": {
                "asn_list": {
                    "description": " Addresses that belong to the ASNs in the given list\n The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.",
                    "title": "asn_list",
                    "$ref": "#/definitions/policyAsnMatchList",
                    "x-displayname": "ASN List"
                },
                "country_list": {
                    "type": "array",
                    "description": " Sources that are located in one of the countries in the given list\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.not_in: [0]\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "country_list",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyCountryCode"
                    },
                    "x-displayname": "Country List",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.not_in": "[0]",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "tls_fingerprint_matcher": {
                    "description": " TLS JA3 fingerprints to be matched.\n The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.",
                    "title": "TLS JA3 fingerprint matcher",
                    "$ref": "#/definitions/policyTlsFingerprintMatcherType",
                    "x-displayname": "TLS Fingerprint Matcher"
                }
            }
        },
        "common_securityDDoSMitigationRule": {
            "type": "object",
            "description": "DDoS Mitigation Rule specifies the sources to be blocked",
            "title": "DDoSMitigationRule",
            "x-displayname": "DDoS Mitigation Rule",
            "x-ves-displayorder": "1,2,7,10",
            "x-ves-oneof-field-mitigation_action": "[\"block\"]",
            "x-ves-oneof-field-mitigation_choice": "[\"ddos_client_source\",\"ip_prefix_list\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_security.DDoSMitigationRule",
            "properties": {
                "block": {
                    "description": "Exclusive with []\n Block user for a duration determined by the expiration time",
                    "title": "Block User",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Block User"
                },
                "ddos_client_source": {
                    "description": "Exclusive with [ip_prefix_list]\n Combination of Region, ASN and TLS Fingerprints\n\nValidation Rules:\n  ves.io.schema.rules.message.required_one_nonzero_field: true\n",
                    "title": "ddos_client_source",
                    "$ref": "#/definitions/common_securityDDoSClientSource",
                    "x-displayname": "DDoS Client Source",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required_one_nonzero_field": "true"
                    }
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": " The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\n the configuration but is not applied anymore.\n\nExample: - \"2019-12-31:44:34.171543432Z\"-\n\nValidation Rules:\n  ves.io.schema.rules.timestamp.within.seconds: 31536000\n",
                    "title": "expiration timestamp",
                    "format": "date-time",
                    "x-displayname": "Expiration Timestamp",
                    "x-ves-example": "2019-12-31:44:34.171543432Z",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.timestamp.within.seconds": "31536000"
                    }
                },
                "ip_prefix_list": {
                    "description": "Exclusive with [ddos_client_source]\n IPv4 prefix string.",
                    "title": "ip source",
                    "$ref": "#/definitions/policyPrefixMatchList",
                    "x-displayname": "IP Source"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_securityMobileIdentifier": {
            "type": "string",
            "description": "Mobile identifier type\n\n - HEADERS: Headers\n\nHeaders",
            "title": "MobileIdentifier",
            "enum": [
                "HEADERS"
            ],
            "default": "HEADERS",
            "x-displayname": "Mobile Identifier",
            "x-ves-proto-enum": "ves.io.schema.views.common_security.MobileIdentifier"
        },
        "common_securityMobileSDKConfigType": {
            "type": "object",
            "description": "Mobile SDK configuration.",
            "title": "MobileSDKConfigType",
            "x-displayname": "Mobile SDK Configuration",
            "x-ves-proto-message": "ves.io.schema.views.common_security.MobileSDKConfigType",
            "properties": {
                "mobile_identifier": {
                    "description": " Mobile traffic identifier type.",
                    "title": "Mobile Traffic Identifier Type",
                    "$ref": "#/definitions/common_securityMobileTrafficIdentifierType",
                    "x-displayname": "Mobile Traffic Identifier"
                }
            }
        },
        "common_securityMobileTrafficIdentifierType": {
            "type": "object",
            "description": "Mobile traffic identifier type.",
            "title": "MobileTrafficIdentifierType",
            "x-displayname": "Mobile Traffic Identifier",
            "x-ves-proto-message": "ves.io.schema.views.common_security.MobileTrafficIdentifierType",
            "properties": {
                "headers": {
                    "type": "array",
                    "description": " Headers that can be used to identify mobile traffic.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Mobile headers",
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/policyHeaderMatcherTypeBasic"
                    },
                    "x-displayname": "Headers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_securityProtectedAppEndpointType": {
            "type": "object",
            "description": "x-displayName: \"Protected App Endpoint\"\nProtected Application Endpoint.",
            "title": "ProtectedAppEndpointType",
            "properties": {
                "any_domain": {
                    "description": "x-displayName: \"Any Domain\"\nAny Domain",
                    "title": "Any domain",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "domain": {
                    "description": "x-displayName: \"Domain\"\nSelect Domain matcher",
                    "title": "Domain",
                    "$ref": "#/definitions/schemaDomainType"
                },
                "flow_label": {
                    "description": "x-displayName: \"Specify endpoint label category\"",
                    "title": "flow_label",
                    "$ref": "#/definitions/schemaBotDefenseFlowLabelCategoriesChoiceType"
                },
                "http_methods": {
                    "type": "array",
                    "description": "x-displayName: \"HTTP Methods\"\nx-required\nList of HTTP methods.",
                    "title": "HTTP Methods",
                    "items": {
                        "$ref": "#/definitions/schemaBotHttpMethod"
                    }
                },
                "metadata": {
                    "description": "x-displayName: \"Metadata\"\nx-required\nCommon attributes for the rule including name and description.",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType"
                },
                "mobile_client": {
                    "description": "x-displayName: \"Mobile Traffic\"\nMobile traffic channel.",
                    "title": "MobileTraffic",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "path": {
                    "description": "x-displayName: \"Path\"\nx-required\nx-example: \"/id/1\"\nx-example: \"/id/*\"\nx-example: \"*login\"\nAccepts wildcards * to match multiple characters or ? to match a single character",
                    "title": "Path",
                    "$ref": "#/definitions/ioschemaPathMatcherType"
                },
                "query": {
                    "type": "array",
                    "description": "x-displayName: \"Query\"\nx-example: \"(^|[^\\\\w])action=login([^\\\\w]|$)\"\nEnter a regular expression or exact value to match your query parameters of interest",
                    "title": "Query",
                    "items": {
                        "$ref": "#/definitions/common_securityQuery"
                    }
                },
                "request_body": {
                    "type": "array",
                    "description": "x-displayName: \"Request Body\"\nRequest Body",
                    "title": "Request Body",
                    "items": {
                        "$ref": "#/definitions/common_securityRequestBody"
                    }
                },
                "undefined_flow_label": {
                    "description": "x-displayName: \"Undefined\"",
                    "title": "undefined",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "web_client": {
                    "description": "x-displayName: \"Web Traffic\"\nWeb traffic channel.",
                    "title": "WebTraffic",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "web_mobile_client": {
                    "description": "x-displayName: \"Web and Mobile Traffic\"\nWeb and mobile traffic channel.",
                    "title": "WebMobileTraffic",
                    "$ref": "#/definitions/common_securityWebMobileTrafficType"
                }
            }
        },
        "common_securityQuery": {
            "type": "object",
            "description": "x-displayName: \"Query Parameter Matcher\"\nQuery Parameter Matcher",
            "title": "Query",
            "properties": {
                "check_presence": {
                    "description": "x-displayName: \"Presence\"\nParameter name taken which is exist in the query parameter",
                    "title": "check_presence",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "exact_value": {
                    "type": "string",
                    "description": "x-displayName: \"Exact Value\"\nx-example: \"login\"\nExact query value to match",
                    "title": "exact value"
                },
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Query Parameter Name\"\nx-example: \"id\"\nEnter query parameter name",
                    "title": "Name"
                },
                "regex_value": {
                    "type": "string",
                    "description": "x-displayName: \"Regex Value\"\nx-example: \"([a-z]([-a-z0-9]*[a-z0-9])?)$'\"\nRegular expression of query match (e.g. the value .* will match on all query)",
                    "title": "regex value"
                }
            }
        },
        "common_securityRequestBody": {
            "type": "object",
            "description": "x-displayName: \"Request Body Parameter Matcher\"\nRequest Body Parameter Matcher",
            "title": "RequestBody",
            "properties": {
                "exact_value": {
                    "type": "string",
                    "description": "x-displayName: \"Exact Value\"\nx-example: \"login\"\nExact query value to match",
                    "title": "exact value"
                },
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Request Body Parameter Name\"\nx-example: \"id\"\nEnter request body parameter name",
                    "title": "Name"
                },
                "regex_value": {
                    "type": "string",
                    "description": "x-displayName: \"Regex Value\"\nx-example: \"([a-z]([-a-z0-9]*[a-z0-9])?)$'\"\nRegular expression of query match (e.g. the value .* will match on all query)",
                    "title": "regex value"
                }
            }
        },
        "common_securitySensitiveDataPolicySettings": {
            "type": "object",
            "description": "Settings for data type policy",
            "title": "SensitiveDataPolicySettings",
            "x-displayname": "Sensitive Data Discovery",
            "x-ves-proto-message": "ves.io.schema.views.common_security.SensitiveDataPolicySettings",
            "properties": {
                "sensitive_data_policy_ref": {
                    "description": " Specify Sensitive Data Discovery\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Specify Sensitive Data Discovery",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Specify Sensitive Data Discovery",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_securityShapeBotDefensePolicyType": {
            "type": "object",
            "description": "This defines various configuration options for Bot Defense policy.",
            "title": "ShapeShapeBotDefensePolicyType",
            "x-displayname": "Bot Defense Policy",
            "x-ves-oneof-field-java_script_choice": "[\"disable_js_insert\",\"js_insert_all_pages\",\"js_insert_all_pages_except\",\"js_insertion_rules\"]",
            "x-ves-oneof-field-mobile_sdk_choice": "[\"disable_mobile_sdk\",\"mobile_sdk_config\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_security.ShapeBotDefensePolicyType",
            "properties": {
                "disable_js_insert": {
                    "description": "Exclusive with [js_insert_all_pages js_insert_all_pages_except js_insertion_rules]\n Disable JavaScript insertion.",
                    "title": "Disable JavaScript Insertion",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable JavaScript Insertion"
                },
                "disable_mobile_sdk": {
                    "description": "Exclusive with [mobile_sdk_config]\n Disable Mobile SDK.",
                    "title": "Disable Mobile SDK",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable Mobile SDK"
                },
                "javascript_mode": {
                    "description": " Determine the mode in which the JavaScript is loaded into the entry page.\n The JavaScript is split into 2 chunks.\n The larger chunk can be loaded asynchronously or synchronously. It can also be cacheable or non-cacheable on the browser.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "javascript_mode",
                    "$ref": "#/definitions/schemaJavaScriptMode",
                    "x-displayname": "Web Client JavaScript Mode",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "js_download_path": {
                    "type": "string",
                    "description": " Customize Bot Defense Client JavaScript path. If not specified, default -/common.js-\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n",
                    "title": "js_download_path",
                    "x-displayname": "JavaScript Download Path",
                    "x-ves-example": "value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true"
                    }
                },
                "js_insert_all_pages": {
                    "description": "Exclusive with [disable_js_insert js_insert_all_pages_except js_insertion_rules]\n Insert Bot Defense JavaScript in all pages.",
                    "title": "Insert JavaScript in All Pages",
                    "$ref": "#/definitions/common_securityShapeJavaScriptInsertAllType",
                    "x-displayname": "Insert JavaScript in All Pages"
                },
                "js_insert_all_pages_except": {
                    "description": "Exclusive with [disable_js_insert js_insert_all_pages js_insertion_rules]\n Insert Bot Defense JavaScript in all pages with the exceptions.",
                    "title": "Insert JavaScript in All Pages with the Exceptions",
                    "$ref": "#/definitions/common_securityShapeJavaScriptInsertAllWithExceptionsType",
                    "x-displayname": "Insert JavaScript in All Pages with the Exceptions"
                },
                "js_insertion_rules": {
                    "description": "Exclusive with [disable_js_insert js_insert_all_pages js_insert_all_pages_except]\n Specify custom JavaScript insertion rules.",
                    "title": "Custom JavaScript Insertion Rules",
                    "$ref": "#/definitions/common_securityShapeJavaScriptInsertType",
                    "x-displayname": "Custom JavaScript Insertion Rules"
                },
                "mobile_sdk_config": {
                    "description": "Exclusive with [disable_mobile_sdk]\n Mobile SDK configuration",
                    "title": "Mobile SDK configuration",
                    "$ref": "#/definitions/common_securityMobileSDKConfigType",
                    "x-displayname": "Mobile SDK Configuration"
                },
                "protected_app_endpoints": {
                    "type": "array",
                    "description": " List of protected application endpoints (max 128 items).\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "AppEndpointType",
                    "minItems": 1,
                    "maxItems": 128,
                    "items": {
                        "$ref": "#/definitions/common_securityAppEndpointType"
                    },
                    "x-displayname": "App Endpoint Type",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_securityShapeBotDefenseRegion": {
            "type": "string",
            "description": "Defines a selection for Bot Defense region\n\n - AUTO: AUTO\n\nAutomatic selection based on client IP address\n - US: US\n\nUS region\n - EU: EU\n\nEuropean Union region\n - ASIA: ASIA\n\nAsia region",
            "title": "ShapeBotDefenseRegion",
            "enum": [
                "AUTO",
                "US",
                "EU",
                "ASIA"
            ],
            "default": "AUTO",
            "x-displayname": "Bot Defense Region",
            "x-ves-proto-enum": "ves.io.schema.views.common_security.ShapeBotDefenseRegion"
        },
        "common_securityShapeBotDefenseType": {
            "type": "object",
            "description": "This defines various configuration options for Bot Defense Policy.",
            "title": "ShapeBotDefenseType",
            "x-displayname": "Bot Defense",
            "x-ves-oneof-field-cors_support_choice": "[\"disable_cors_support\",\"enable_cors_support\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_security.ShapeBotDefenseType",
            "properties": {
                "disable_cors_support": {
                    "description": "Exclusive with [enable_cors_support]\n Blocks Bot Defense from working with existing CORS policies on your \n application. This will significantly impact Bot Defense's ability to \n protect against Bot Attacks.",
                    "title": "Disable CORS Support",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "enable_cors_support": {
                    "description": "Exclusive with [disable_cors_support]\n Allows Bot Defense to work with your existing CORS policies.",
                    "title": "Enable CORS Support",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable"
                },
                "policy": {
                    "description": " Bot Defense Policy.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "ShapeBotDefensePolicyType",
                    "$ref": "#/definitions/common_securityShapeBotDefensePolicyType",
                    "x-displayname": "Bot Defense Policy",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "regional_endpoint": {
                    "description": " Specify Bot Defense region to use\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.enum.defined_only: true\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Bot Defense Region",
                    "$ref": "#/definitions/common_securityShapeBotDefenseRegion",
                    "x-displayname": "Bot Defense Region",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.defined_only": "true",
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "timeout": {
                    "type": "integer",
                    "description": " The timeout for the inference check, in milliseconds.\n\nExample: - \"300\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 60000\n",
                    "title": "timeout",
                    "format": "int64",
                    "x-displayname": "Timeout",
                    "x-ves-example": "300",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "60000"
                    }
                }
            }
        },
        "common_securityShapeJavaScriptExclusionRule": {
            "type": "object",
            "description": "Define JavaScript insertion exclusion rule",
            "title": "ShapeJavaScriptExclusionRule",
            "x-displayname": "JavaScript Insertion Exclusion Rule",
            "x-ves-oneof-field-domain_matcher_choice": "[\"any_domain\",\"domain\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_security.ShapeJavaScriptExclusionRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [domain]\n Any Domain.",
                    "title": "Any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "domain": {
                    "description": "Exclusive with [any_domain]\n Domain matcher.",
                    "title": "Domain",
                    "$ref": "#/definitions/schemaDomainType",
                    "x-displayname": "Domain"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "description": " URI path matcher.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Path",
                    "$ref": "#/definitions/ioschemaPathMatcherType",
                    "x-displayname": "Path",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_securityShapeJavaScriptInsertAllType": {
            "type": "object",
            "description": "Insert Bot Defense JavaScript in all pages",
            "title": "ShapeJavaScriptInsertAllType",
            "x-displayname": "Insert Bot Defense JavaScript in All Pages",
            "x-ves-proto-message": "ves.io.schema.views.common_security.ShapeJavaScriptInsertAllType",
            "properties": {
                "javascript_location": {
                    "description": " Defines where to insert Bot Defense JavaScript in HTML page.",
                    "title": "javascript_location",
                    "$ref": "#/definitions/viewscommon_securityJavaScriptLocation",
                    "x-displayname": "JavaScript Location"
                }
            }
        },
        "common_securityShapeJavaScriptInsertAllWithExceptionsType": {
            "type": "object",
            "description": "Insert Bot Defense JavaScript in all pages  with the exceptions",
            "title": "ShapeJavaScriptInsertAllWithExceptionsType",
            "x-displayname": "Insert JavaScript in All Pages with the Exceptions",
            "x-ves-proto-message": "ves.io.schema.views.common_security.ShapeJavaScriptInsertAllWithExceptionsType",
            "properties": {
                "exclude_list": {
                    "type": "array",
                    "description": " Optional JavaScript insertions exclude list of domain and path matchers.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exclude_list",
                    "maxItems": 128,
                    "items": {
                        "$ref": "#/definitions/common_securityShapeJavaScriptExclusionRule"
                    },
                    "x-displayname": "Exclude Pages",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "javascript_location": {
                    "description": " Defines where to insert Bot Defense JavaScript in HTML page.",
                    "title": "javascript_location",
                    "$ref": "#/definitions/viewscommon_securityJavaScriptLocation",
                    "x-displayname": "JavaScript Location"
                }
            }
        },
        "common_securityShapeJavaScriptInsertType": {
            "type": "object",
            "description": "This defines custom JavaScript insertion rules for Bot Defense Policy.",
            "title": "ShapeJavaScriptInsertType",
            "x-displayname": "JavaScript Custom Insertion Rules",
            "x-ves-proto-message": "ves.io.schema.views.common_security.ShapeJavaScriptInsertType",
            "properties": {
                "exclude_list": {
                    "type": "array",
                    "description": " Optional JavaScript insertions exclude list of domain and path matchers.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exclude_list",
                    "maxItems": 128,
                    "items": {
                        "$ref": "#/definitions/common_securityShapeJavaScriptExclusionRule"
                    },
                    "x-displayname": "Exclude Paths",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "rules": {
                    "type": "array",
                    "description": " Required list of pages to insert Bot Defense client JavaScript.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "rules",
                    "minItems": 1,
                    "maxItems": 128,
                    "items": {
                        "$ref": "#/definitions/common_securityShapeJavaScriptInsertionRule"
                    },
                    "x-displayname": "JavaScript Insertions",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_securityShapeJavaScriptInsertionRule": {
            "type": "object",
            "description": "This defines a rule for Bot Defense JavaScript insertion.",
            "title": "ShapeJavaScriptInsertionRule",
            "x-displayname": "JavaScript Insertion Rule",
            "x-ves-oneof-field-domain_matcher_choice": "[\"any_domain\",\"domain\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_security.ShapeJavaScriptInsertionRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [domain]\n Any Domain.",
                    "title": "Any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "domain": {
                    "description": "Exclusive with [any_domain]\n Domain matcher.",
                    "title": "Domain",
                    "$ref": "#/definitions/schemaDomainType",
                    "x-displayname": "Domain"
                },
                "javascript_location": {
                    "description": " Defines where to insert Bot Defense JavaScript in HTML page.",
                    "title": "javascript_location",
                    "$ref": "#/definitions/viewscommon_securityJavaScriptLocation",
                    "x-displayname": "JavaScript Location"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "description": " URI path matcher.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Path",
                    "$ref": "#/definitions/ioschemaPathMatcherType",
                    "x-displayname": "Path",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_securityURLScheme": {
            "type": "string",
            "description": "SchemeType is used to indicate URL scheme.\n\n - BOTH: BOTH\n\nURL scheme for https:// or http://.\n - HTTP: HTTP\n\nURL scheme http:// only.\n - HTTPS: HTTPS\n\nURL scheme https:// only.",
            "title": "URLSchemeType",
            "enum": [
                "BOTH",
                "HTTP",
                "HTTPS"
            ],
            "default": "BOTH",
            "x-displayname": "URL Scheme",
            "x-ves-proto-enum": "ves.io.schema.views.common_security.URLScheme"
        },
        "common_securityWebMobileTrafficType": {
            "type": "object",
            "description": "Web and Mobile traffic type",
            "title": "WebMobileTrafficType",
            "x-displayname": "Web and Mobile traffic type",
            "x-ves-proto-message": "ves.io.schema.views.common_security.WebMobileTrafficType",
            "properties": {
                "mobile_identifier": {
                    "description": " Mobile identifier type",
                    "title": "Mobile Identifier",
                    "$ref": "#/definitions/common_securityMobileIdentifier",
                    "x-displayname": "Mobile Identifier"
                }
            }
        },
        "common_wafAPIEndpointProtectionRule": {
            "type": "object",
            "description": "x-displayName: \"API Endpoint Protection Rule\"\nAPI Protection Rule for a specific endpoint",
            "title": "API Endpoint Protection Rule",
            "properties": {
                "action": {
                    "description": "x-required\nx-displayName: \"Rule Action\"\nThe action to take if the input request matches the rule.",
                    "title": "action",
                    "$ref": "#/definitions/common_wafAPIProtectionRuleAction"
                },
                "any_domain": {
                    "description": "x-displayName: \"Any Domain\"\nThe rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "api_endpoint_method": {
                    "description": "x-displayName: \"HTTP Methods\"\nThe list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.\nThe predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.",
                    "title": "method",
                    "$ref": "#/definitions/policyHttpMethodMatcherType"
                },
                "api_endpoint_path": {
                    "type": "string",
                    "description": "x-required\nx-example: \"/endpoint1\"\nx-displayName: \"API Endpoint\"\nThe endpoint (path) of the request.",
                    "title": "api endpoint path"
                },
                "client_matcher": {
                    "description": "x-displayName: \"Clients\"\nConditions related to the origin of the request, such as client IP, TLS fingerprint, etc.",
                    "title": "client_matcher",
                    "$ref": "#/definitions/policyClientMatcher"
                },
                "metadata": {
                    "description": "x-displayName: \"Metadata\"\nx-required\nCommon attributes for the rule including name and description.",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType"
                },
                "request_matcher": {
                    "description": "x-displayName: \"Request\"\nConditions related to the request, such as query parameters, headers, etc.",
                    "title": "request_matcher",
                    "$ref": "#/definitions/policyRequestMatcher"
                },
                "specific_domain": {
                    "type": "string",
                    "description": "x-displayName: \"Specific Domain\"\nx-example: \"api.example.com\"\nThe rule will apply for a specific domain.\nFor example: api.example.com",
                    "title": "domain"
                }
            }
        },
        "common_wafAPIGroupProtectionRule": {
            "type": "object",
            "description": "x-displayName: \"API Group Protection Rule\"\nAPI Protection Rule for a group or a base url",
            "title": "API Group Protection  Rule",
            "properties": {
                "action": {
                    "description": "x-required\nx-displayName: \"Rule Action\"\nThe action to take if the input request matches the rule.",
                    "title": "action",
                    "$ref": "#/definitions/common_wafAPIProtectionRuleAction"
                },
                "any_domain": {
                    "description": "x-displayName: \"Any Domain\"\nThe rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "api_group": {
                    "type": "string",
                    "description": "x-displayName: \"API Group\"\nx-example: \"oas-all-operations\"\nAPI groups derived from API Definition swaggers.\nFor example oas-all-operations including all paths and methods from the swaggers, oas-base-urls covering all requests under base-paths from the swaggers.\nCustom groups can be created if user tags paths or operations with \"x-volterra-api-group\" extensions inside swaggers.",
                    "title": "api_group"
                },
                "base_path": {
                    "type": "string",
                    "description": "x-required\nx-example: \"/v1\"\nx-displayName: \"Base Path\"\nPrefix of the request path.\nFor example: /v1",
                    "title": "base path"
                },
                "client_matcher": {
                    "description": "x-displayName: \"Clients\"\nConditions related to the origin of the request, such as client IP, TLS fingerprint, etc.",
                    "title": "client_matcher",
                    "$ref": "#/definitions/policyClientMatcher"
                },
                "metadata": {
                    "description": "x-displayName: \"Metadata\"\nx-required\nCommon attributes for the rule including name and description.",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType"
                },
                "request_matcher": {
                    "description": "x-displayName: \"Request\"\nConditions related to the request, such as query parameters, headers, etc.",
                    "title": "request_matcher",
                    "$ref": "#/definitions/policyRequestMatcher"
                },
                "specific_domain": {
                    "type": "string",
                    "description": "x-displayName: \"Specific Domain\"\nx-example: \"api.example.com\"\nThe rule will apply for a specific domain.\nFor example: api.example.com",
                    "title": "domain"
                }
            }
        },
        "common_wafAPIGroups": {
            "type": "object",
            "title": "api groups",
            "x-displayname": "API Groups",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.APIGroups",
            "properties": {
                "api_groups": {
                    "type": "array",
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "api group",
                    "maxItems": 32,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "API Groups",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafAPIProtectionRuleAction": {
            "type": "object",
            "description": "x-displayName: \"API Protection Rule Action\"\nThe action to take if the input request matches the rule.",
            "title": "API Protection Rule Action",
            "properties": {
                "allow": {
                    "description": "x-displayName: \"Allow\"\nAllow the request to proceed.",
                    "title": "Allow",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "deny": {
                    "description": "x-displayName: \"Deny\"\nDeny the request.",
                    "title": "Deny",
                    "$ref": "#/definitions/ioschemaEmpty"
                }
            }
        },
        "common_wafAPIProtectionRules": {
            "type": "object",
            "description": "x-displayName: \"API Protection Rules\"\nAPI Protection Rules",
            "title": "API Protection Rules",
            "properties": {
                "api_endpoint_rules": {
                    "type": "array",
                    "description": "x-displayName: \"API Endpoints\"\nThis category defines specific rules per API endpoints.\nIf request matches any of these rules, skipping second category rules.",
                    "title": "api_endpoint_rules",
                    "items": {
                        "$ref": "#/definitions/common_wafAPIEndpointProtectionRule"
                    }
                },
                "api_groups_rules": {
                    "type": "array",
                    "description": "x-displayName: \"Server URLs and API Groups\"\nThis category includes rules per API group or Server URL.\nFor API groups, refer to API Definition which includes API groups derived from uploaded swaggers.",
                    "title": "api_groups_rules",
                    "items": {
                        "$ref": "#/definitions/common_wafAPIGroupProtectionRule"
                    }
                }
            }
        },
        "common_wafAPIRateLimit": {
            "type": "object",
            "title": "APIRateLimit",
            "x-displayname": "APIRateLimit",
            "x-ves-oneof-field-ip_allowed_list_choice": "[\"bypass_rate_limiting_rules\",\"custom_ip_allowed_list\",\"ip_allowed_list\",\"no_ip_allowed_list\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.APIRateLimit",
            "properties": {
                "api_endpoint_rules": {
                    "type": "array",
                    "description": " Sets of rules for a specific endpoints.\n Order is matter as it uses first match policy.\n For creating rule that contain a whole domain or group of endpoints, please use the server URL rules above.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 20\n",
                    "title": "api_endpoint_policy",
                    "maxItems": 20,
                    "items": {
                        "$ref": "#/definitions/common_wafApiEndpointRule"
                    },
                    "x-displayname": "API Endpoints",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "20"
                    }
                },
                "bypass_rate_limiting_rules": {
                    "description": "Exclusive with [custom_ip_allowed_list ip_allowed_list no_ip_allowed_list]\n This category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
                    "title": "bypass_rate_limiting_policy",
                    "$ref": "#/definitions/common_wafBypassRateLimitingRules",
                    "x-displayname": "Bypass Rate Limiting"
                },
                "custom_ip_allowed_list": {
                    "description": "Exclusive with [bypass_rate_limiting_rules ip_allowed_list no_ip_allowed_list]\n IP Allowed list using existing ip_prefix_set objects.",
                    "title": "Custom IP list",
                    "$ref": "#/definitions/common_wafCustomIpAllowedList",
                    "x-displayname": "IP Allowed List using IP Prefix Set(s)"
                },
                "ip_allowed_list": {
                    "description": "Exclusive with [bypass_rate_limiting_rules custom_ip_allowed_list no_ip_allowed_list]\n List of IP(s) for which rate limiting will be disabled.",
                    "title": "IP Allowed List",
                    "$ref": "#/definitions/viewsPrefixStringListType",
                    "x-displayname": "IP Allowed List"
                },
                "no_ip_allowed_list": {
                    "description": "Exclusive with [bypass_rate_limiting_rules custom_ip_allowed_list ip_allowed_list]\n There is no ip allowed list for rate limiting, all clients go through rate limiting.",
                    "title": "No IP Allowed List",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No IP Allowed"
                },
                "server_url_rules": {
                    "type": "array",
                    "description": " Set of rules for entire domain or base path that contain multiple endpoints.\n Order is matter as it uses first match policy.\n For matching also specific endpoints you can use the API endpoint rules set bellow.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 20\n",
                    "title": "server_url_policy",
                    "maxItems": 20,
                    "items": {
                        "$ref": "#/definitions/common_wafServerUrlRule"
                    },
                    "x-displayname": "Server URLs",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "20"
                    }
                }
            }
        },
        "common_wafAPISpecificationSettings": {
            "type": "object",
            "description": "Settings for api specification (api definition, OpenAPI validation, etc.)",
            "title": "APISpecificationSettings",
            "x-displayname": "API Specification and Validation",
            "x-ves-oneof-field-validation_target_choice": "[\"validation_all_spec_endpoints\",\"validation_custom_list\",\"validation_disabled\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.APISpecificationSettings",
            "properties": {
                "api_definition": {
                    "description": " Specify API definition which includes application API paths and methods derived from swagger files.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Use API Definition",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "API Definition",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "validation_all_spec_endpoints": {
                    "description": "Exclusive with [validation_custom_list validation_disabled]\n Validate all API endpoints specified by the API Inventory.\n  All other API endpoints would proceed according to \"Fall Through Mode\"",
                    "title": "validation_all_spec_endpoints",
                    "$ref": "#/definitions/common_wafOpenApiValidationAllSpecEndpointsSettings",
                    "x-displayname": "API Inventory"
                },
                "validation_custom_list": {
                    "description": "Exclusive with [validation_all_spec_endpoints validation_disabled]\n Define API groups, base paths, or API endpoints and their OpenAPI validation modes.\n  Any other end-points not listed will act according to \"Fall Through Mode\"",
                    "title": "Custom list",
                    "$ref": "#/definitions/common_wafValidateApiBySpecRule",
                    "x-displayname": "Custom List"
                },
                "validation_disabled": {
                    "description": "Exclusive with [validation_all_spec_endpoints validation_custom_list]\n Don't run OpenAPI validation",
                    "title": "Disabled",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disabled"
                }
            }
        },
        "common_wafApiCodeRepos": {
            "type": "object",
            "description": "Select which API repositories represent the LB applications",
            "title": "API Code Repositories",
            "x-displayname": "API Code Repositories",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ApiCodeRepos",
            "properties": {
                "api_code_repo": {
                    "type": "array",
                    "description": " Code repository which contain API endpoints\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "API Code Repository",
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "API Code Repository",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                }
            }
        },
        "common_wafApiDiscoveryFromCodeScan": {
            "type": "object",
            "description": "x-required",
            "title": "API Discovery Code Scan",
            "x-displayname": "Select Code Base and Repositories",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ApiDiscoveryFromCodeScan",
            "properties": {
                "code_base_integrations": {
                    "type": "array",
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 5\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Code Base Integrations",
                    "maxItems": 5,
                    "items": {
                        "$ref": "#/definitions/common_wafCodeBaseIntegrationSelection"
                    },
                    "x-displayname": "Select Code Base Integrations",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "5",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafApiDiscoverySetting": {
            "type": "object",
            "description": "Specifies the settings used for API discovery",
            "title": "API Discovery Setting",
            "x-displayname": "API Discovery Setting",
            "x-ves-displayorder": "1,6,5",
            "x-ves-oneof-field-learn_from_redirect_traffic": "[\"disable_learn_from_redirect_traffic\",\"enable_learn_from_redirect_traffic\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ApiDiscoverySetting",
            "properties": {
                "api_discovery_from_code_scan": {
                    "description": " Select API code repositories to the load balancer to use them as a source for API endpoint discovery.",
                    "title": "Code Base Integration",
                    "$ref": "#/definitions/common_wafApiDiscoveryFromCodeScan",
                    "x-displayname": "API repositories"
                },
                "disable_learn_from_redirect_traffic": {
                    "description": "Exclusive with [enable_learn_from_redirect_traffic]\n Disable learning API patterns from traffic with redirect response codes 3xx",
                    "title": "Disable learning from redirected request traffic",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable Learning From Redirect Traffic"
                },
                "discovered_api_settings": {
                    "description": " Configure Discovered API Settings.",
                    "title": "Discovered API Settings",
                    "$ref": "#/definitions/app_typeDiscoveredAPISettings",
                    "x-displayname": "Discovered API Settings"
                },
                "enable_learn_from_redirect_traffic": {
                    "description": "Exclusive with [disable_learn_from_redirect_traffic]\n Enable learning API patterns from traffic with redirect response codes 3xx",
                    "title": "Enable learning from redirected request traffic",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable Learning From Redirect Traffic"
                }
            }
        },
        "common_wafApiEndpointDetails": {
            "type": "object",
            "description": "This defines api endpoint",
            "title": "ApiEndpointDetails",
            "x-displayname": "API Endpoint",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ApiEndpointDetails",
            "properties": {
                "methods": {
                    "type": "array",
                    "description": " Methods to be matched\n\nExample: - \"GET\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Methods",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "Methods",
                    "x-ves-example": "GET",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "path": {
                    "type": "string",
                    "description": " Path to be matched\n\nExample: - \"/api/v1/login\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "Path",
                    "maxLength": 1024,
                    "x-displayname": "Path",
                    "x-ves-example": "/api/v1/login",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                }
            }
        },
        "common_wafApiEndpointRule": {
            "type": "object",
            "title": "ApiEndpointRule",
            "x-displayname": "ApiEndpointRule",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"specific_domain\"]",
            "x-ves-oneof-field-rate_limiter_choice": "[\"inline_rate_limiter\",\"ref_rate_limiter\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ApiEndpointRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [specific_domain]\n The rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "api_endpoint_method": {
                    "description": " The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.\n The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.",
                    "title": "method",
                    "$ref": "#/definitions/policyHttpMethodMatcherType",
                    "x-displayname": "HTTP Methods"
                },
                "api_endpoint_path": {
                    "type": "string",
                    "description": " The endpoint (path) of the request.\n\nExample: - \"value\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "api endpoint path",
                    "maxLength": 1024,
                    "x-displayname": "API Endpoint",
                    "x-ves-example": "value",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                },
                "client_matcher": {
                    "description": " Conditions related to the origin of the request, such as client IP, TLS fingerprint, etc.",
                    "title": "client_matcher",
                    "$ref": "#/definitions/policyClientMatcher",
                    "x-displayname": "Clients"
                },
                "inline_rate_limiter": {
                    "description": "Exclusive with [ref_rate_limiter]\n Specify rate values for the rule.",
                    "title": "Inline Rate Limiter",
                    "$ref": "#/definitions/common_wafInlineRateLimiter",
                    "x-displayname": "Specific Values"
                },
                "ref_rate_limiter": {
                    "description": "Exclusive with [inline_rate_limiter]\n Select external rate limiter.",
                    "title": "External Rate Limiter",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "External Rate Limiter"
                },
                "request_matcher": {
                    "description": " Conditions related to the request, such as query parameters, headers, etc.",
                    "title": "request_matcher",
                    "$ref": "#/definitions/policyRequestMatcher",
                    "x-displayname": "Request"
                },
                "specific_domain": {
                    "type": "string",
                    "description": "Exclusive with [any_domain]\n The rule will apply for a specific domain.\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n  ves.io.schema.rules.string.vh_domain: true\n",
                    "title": "domain",
                    "maxLength": 128,
                    "x-displayname": "Specific Domain",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128",
                        "ves.io.schema.rules.string.vh_domain": "true"
                    }
                }
            }
        },
        "common_wafAudiences": {
            "type": "object",
            "title": "audiences",
            "x-displayname": "Audiences",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.Audiences",
            "properties": {
                "audiences": {
                    "type": "array",
                    "description": "\nExample: - \"value\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "audiences",
                    "minItems": 1,
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Values",
                    "x-ves-example": "value",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafBasePathsType": {
            "type": "object",
            "title": "base_paths",
            "x-displayname": "Base Paths",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.BasePathsType",
            "properties": {
                "base_paths": {
                    "type": "array",
                    "description": "\nExample: - \"/basepath\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.http_path: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "base_paths",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Prefix Values",
                    "x-ves-example": "/basepath",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.http_path": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafBypassRateLimitingRule": {
            "type": "object",
            "title": "BypassRateLimitingRule",
            "x-displayname": "Bypass Rate Limiting Rule",
            "x-ves-oneof-field-destination_type": "[\"any_url\",\"api_endpoint\",\"api_groups\",\"base_path\"]",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"specific_domain\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.BypassRateLimitingRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [specific_domain]\n The rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "any_url": {
                    "description": "Exclusive with [api_endpoint api_groups base_path]\n Any URL ",
                    "title": "any_url",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any URL"
                },
                "api_endpoint": {
                    "description": "Exclusive with [any_url api_groups base_path]\n The endpoint (path) of the request.\n\nExample: - \"/endpoint1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "api endpoint path",
                    "$ref": "#/definitions/common_wafApiEndpointDetails",
                    "x-displayname": "API Endpoint",
                    "x-ves-example": "/endpoint1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "api_groups": {
                    "description": "Exclusive with [any_url api_endpoint base_path]\n Validation will be performed for the endpoints mentioned in the API Groups",
                    "title": "api group",
                    "$ref": "#/definitions/common_wafAPIGroups",
                    "x-displayname": "API Groups"
                },
                "base_path": {
                    "type": "string",
                    "description": "Exclusive with [any_url api_endpoint api_groups]\n The base path which this validation applies to\n\nExample: - \"/api/v1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "base path",
                    "maxLength": 128,
                    "x-displayname": "Base Path",
                    "x-ves-example": "/api/v1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "client_matcher": {
                    "description": " Conditions related to the origin of the request, such as client IP, TLS fingerprint, etc.",
                    "title": "client_matcher",
                    "$ref": "#/definitions/policyClientMatcher",
                    "x-displayname": "Clients"
                },
                "request_matcher": {
                    "description": " Conditions related to the request, such as query parameters, headers, etc.",
                    "title": "request_matcher",
                    "$ref": "#/definitions/policyRequestMatcher",
                    "x-displayname": "Request"
                },
                "specific_domain": {
                    "type": "string",
                    "description": "Exclusive with [any_domain]\n The rule will apply for a specific domain.\n For example: api.example.com\n\nExample: - \"api.example.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n  ves.io.schema.rules.string.vh_domain: true\n",
                    "title": "domain",
                    "maxLength": 128,
                    "x-displayname": "Specific Domain",
                    "x-ves-example": "api.example.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128",
                        "ves.io.schema.rules.string.vh_domain": "true"
                    }
                }
            }
        },
        "common_wafBypassRateLimitingRules": {
            "type": "object",
            "description": "This category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.",
            "title": "bypass_rate_limiting_policy",
            "x-displayname": "Bypass Rate Limiting",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.BypassRateLimitingRules",
            "properties": {
                "bypass_rate_limiting_rules": {
                    "type": "array",
                    "description": " This category defines rules per URL or API group. If request matches any of these rules, skip Rate Limiting.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 20\n",
                    "title": "bypass_rate_limiting_policy",
                    "maxItems": 20,
                    "items": {
                        "$ref": "#/definitions/common_wafBypassRateLimitingRule"
                    },
                    "x-displayname": "Bypass Rate Limiting",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "20"
                    }
                }
            }
        },
        "common_wafChallengeRule": {
            "type": "object",
            "description": "Challenge rule",
            "title": "Challenge Rule",
            "x-displayname": "Challenge Rule",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ChallengeRule",
            "properties": {
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "spec": {
                    "description": " Specification for the rule including match predicates and actions.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "spec",
                    "$ref": "#/definitions/service_policy_ruleChallengeRuleSpec",
                    "x-displayname": "Challenge Rule Specification",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_wafChallengeRuleList": {
            "type": "object",
            "description": "List of challenge rules to be used in policy based challenge",
            "title": "Challenge Rule List",
            "x-displayname": "Challenge Rule List",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ChallengeRuleList",
            "properties": {
                "rules": {
                    "type": "array",
                    "description": " Rules that specify the match conditions and challenge type to be launched.\n When a challenge type is selected to be always enabled,\n these rules can be used to disable challenge or launch a different challenge for requests that match the specified conditions\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "title": "Rules",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/common_wafChallengeRule"
                    },
                    "x-displayname": "Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                }
            }
        },
        "common_wafClientSrcRuleAction": {
            "type": "string",
            "description": "Action that should be taken when client identifier matches the rule\n",
            "title": "action",
            "enum": [
                "SKIP_PROCESSING_WAF",
                "SKIP_PROCESSING_BOT",
                "SKIP_PROCESSING_MUM",
                "SKIP_PROCESSING_IP_REPUTATION",
                "SKIP_PROCESSING_API_PROTECTION",
                "SKIP_PROCESSING_OAS_VALIDATION",
                "SKIP_PROCESSING_DDOS_PROTECTION",
                "SKIP_PROCESSING_THREAT_MESH"
            ],
            "default": "SKIP_PROCESSING_WAF",
            "x-displayname": "Action",
            "x-ves-proto-enum": "ves.io.schema.views.common_waf.ClientSrcRuleAction"
        },
        "common_wafCodeBaseIntegrationSelection": {
            "type": "object",
            "title": "Code Base Integration",
            "x-displayname": "Code Base Integration",
            "x-ves-oneof-field-api_repos_choice": "[\"all_repos\",\"selected_repos\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.CodeBaseIntegrationSelection",
            "properties": {
                "all_repos": {
                    "description": "Exclusive with [selected_repos]\n",
                    "title": "All API Repositories",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "All API Repositories"
                },
                "code_base_integration": {
                    "description": " Select the code base integration for use in code-based API discovery\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Code Base Integration Selection",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Select Code Base",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "selected_repos": {
                    "description": "Exclusive with [all_repos]\n",
                    "title": "Selected API Repositories",
                    "$ref": "#/definitions/common_wafApiCodeRepos",
                    "x-displayname": "Selected API Repositories"
                }
            }
        },
        "common_wafCustomFallThroughMode": {
            "type": "object",
            "description": "Define the fall through settings",
            "title": "Custom Fall Through Mode",
            "x-displayname": "Custom Fall Through Mode",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.CustomFallThroughMode",
            "properties": {
                "open_api_validation_rules": {
                    "type": "array",
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 15\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "title": "Custom Fall Through Rule List",
                    "maxItems": 15,
                    "items": {
                        "$ref": "#/definitions/common_wafFallThroughRule"
                    },
                    "x-displayname": "Custom Fall Through Rule List",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "15",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                }
            }
        },
        "common_wafCustomIpAllowedList": {
            "type": "object",
            "description": "IP Allowed list using existing ip_prefix_set objects",
            "title": "Custom IP Allowed List",
            "x-displayname": "Custom IP Allowed List",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.CustomIpAllowedList",
            "properties": {
                "rate_limiter_allowed_prefixes": {
                    "type": "array",
                    "description": " References to ip_prefix_set objects.\n Requests from source IP addresses that are covered by one of the allowed IP Prefixes are not subjected to rate limiting.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 4\n  ves.io.schema.rules.repeated.min_items: 1\n",
                    "title": "rate_limiter_allowed_prefixes",
                    "minItems": 1,
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "List of IP Prefix Sets",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "4",
                        "ves.io.schema.rules.repeated.min_items": "1"
                    }
                }
            }
        },
        "common_wafEnableChallenge": {
            "type": "object",
            "description": "Configure auto mitigation i.e risk based challenges for malicious users",
            "title": "enable challenge",
            "x-displayname": "Enable Malicious User Challenge",
            "x-ves-oneof-field-captcha_challenge_parameters_choice": "[\"captcha_challenge_parameters\",\"default_captcha_challenge_parameters\"]",
            "x-ves-oneof-field-js_challenge_parameters_choice": "[\"default_js_challenge_parameters\",\"js_challenge_parameters\"]",
            "x-ves-oneof-field-malicious_user_mitigation_choice": "[\"default_mitigation_settings\",\"malicious_user_mitigation\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.EnableChallenge",
            "properties": {
                "captcha_challenge_parameters": {
                    "description": "Exclusive with [default_captcha_challenge_parameters]\n Configure captcha challenge parameters",
                    "title": "Captcha Challenge",
                    "$ref": "#/definitions/virtual_hostCaptchaChallengeType",
                    "x-displayname": "Captcha Challenge Parameters"
                },
                "default_captcha_challenge_parameters": {
                    "description": "Exclusive with [captcha_challenge_parameters]\n Use default parameters",
                    "title": "default parameters",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Use Default Parameters"
                },
                "default_js_challenge_parameters": {
                    "description": "Exclusive with [js_challenge_parameters]\n Use default parameters",
                    "title": "default parameters",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Use Default Parameters"
                },
                "default_mitigation_settings": {
                    "description": "Exclusive with [malicious_user_mitigation]\n For low threat level, JavaScript Challenge will be applied. For medium threat level, Captcha Challenge will be applied.\n For high level, users will be temporarily blocked.",
                    "title": "default parameters",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "js_challenge_parameters": {
                    "description": "Exclusive with [default_js_challenge_parameters]\n Configure JavaScript challenge parameters",
                    "title": "JavaScript Challenge",
                    "$ref": "#/definitions/virtual_hostJavascriptChallengeType",
                    "x-displayname": "JavaScript Challenge Parameters"
                },
                "malicious_user_mitigation": {
                    "description": "Exclusive with [default_mitigation_settings]\n Define the mitigation actions to be taken for different threat levels",
                    "title": "Malicious User Mitigation",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Custom"
                }
            }
        },
        "common_wafFallThroughRule": {
            "type": "object",
            "description": "Fall Through Rule for a specific endpoint, base-path, or API group",
            "title": "Fall Through Rule",
            "x-displayname": "Fall Through Rule",
            "x-ves-oneof-field-action_choice": "[\"action_block\",\"action_report\",\"action_skip\"]",
            "x-ves-oneof-field-condition_type_choice": "[\"api_endpoint\",\"api_group\",\"base_path\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.FallThroughRule",
            "properties": {
                "action_block": {
                    "description": "Exclusive with [action_report action_skip]\n Block the request and issue an API security event",
                    "title": "block",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Block"
                },
                "action_report": {
                    "description": "Exclusive with [action_block action_skip]\n Continue processing the request and issue an API security event",
                    "title": "report",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Report"
                },
                "action_skip": {
                    "description": "Exclusive with [action_block action_report]\n Continue processing the request",
                    "title": "skip",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip"
                },
                "api_endpoint": {
                    "description": "Exclusive with [api_group base_path]\n The API endpoint (Path + Method) which this validation applies to",
                    "title": "API Endpoint",
                    "$ref": "#/definitions/common_wafApiEndpointDetails",
                    "x-displayname": "API Endpoint"
                },
                "api_group": {
                    "type": "string",
                    "description": "Exclusive with [api_endpoint base_path]\n The API group which this validation applies to\n\nExample: - \"oas-all-operations\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "api_group",
                    "maxLength": 128,
                    "x-displayname": "API Group",
                    "x-ves-example": "oas-all-operations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "base_path": {
                    "type": "string",
                    "description": "Exclusive with [api_endpoint api_group]\n The base path which this validation applies to\n\nExample: - \"/api/v1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "base path",
                    "maxLength": 128,
                    "x-displayname": "Base Path",
                    "x-ves-example": "/api/v1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_wafHttpHeaderMatcherList": {
            "type": "object",
            "description": "Request header name and value pairs",
            "title": "HTTP Header",
            "x-displayname": "HTTP Header",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.HttpHeaderMatcherList",
            "properties": {
                "headers": {
                    "type": "array",
                    "description": " List of HTTP header name and value pairs\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "headers",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/ioschemaHeaderMatcherType"
                    },
                    "x-displayname": "HTTP Headers",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                }
            }
        },
        "common_wafInlineRateLimiter": {
            "type": "object",
            "title": "InlineRateLimiter",
            "x-displayname": "InlineRateLimiter",
            "x-ves-oneof-field-count_by_choice": "[\"ref_user_id\",\"use_http_lb_user_id\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.InlineRateLimiter",
            "properties": {
                "ref_user_id": {
                    "description": "Exclusive with [use_http_lb_user_id]\n A reference to user_identification object.\n The rules in the user_identification object are evaluated to determine the user identifier to be rate limited.",
                    "title": "ref_user_id",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "User Identification Policy"
                },
                "threshold": {
                    "type": "integer",
                    "description": " The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.\n\nExample: - \"1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gt: 0\n  ves.io.schema.rules.uint32.lte: 8192\n",
                    "title": "threshold",
                    "format": "int64",
                    "x-displayname": "Threshold",
                    "x-ves-example": "1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gt": "0",
                        "ves.io.schema.rules.uint32.lte": "8192"
                    }
                },
                "unit": {
                    "description": " Unit for the period per which the rate limit is applied.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "rate",
                    "$ref": "#/definitions/rate_limiterRateLimitPeriodUnit",
                    "x-displayname": "Duration",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "use_http_lb_user_id": {
                    "description": "Exclusive with [ref_user_id]\n Defined in HTTP-LB Security Configuration -\u003e User Identifier.",
                    "title": "use_http_lb_user_id",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Use HTTP-LB User Identifier"
                }
            }
        },
        "common_wafJWKS": {
            "type": "object",
            "description": "The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
            "title": "jwks",
            "x-displayname": "JSON Web Key Set (JWKS)",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.JWKS",
            "properties": {
                "cleartext": {
                    "type": "string",
                    "description": " The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
                    "title": "cleartext",
                    "x-displayname": "JSON Web Key Set (JWKS)"
                }
            }
        },
        "common_wafJWTValidation": {
            "type": "object",
            "description": "JWT Validation stops JWT replay attacks and JWT tampering by cryptographically verifying incoming\nJWTs before they are passed to your API origin. JWT Validation will also stop requests with expired\ntokens or tokens that are not yet valid.",
            "title": "JWT Validation",
            "x-displayname": "JWT Validation",
            "x-ves-oneof-field-jwks_configuration": "[\"jwks_config\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.JWTValidation",
            "properties": {
                "action": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "action",
                    "$ref": "#/definitions/schemaAction",
                    "x-displayname": "Action",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "jwks_config": {
                    "description": "Exclusive with []\n The JSON Web Key Set (JWKS) is a set of keys used to verify JSON Web Token (JWT) issued by the Authorization Server. See RFC 7517 for more details.",
                    "title": "jwks_config",
                    "$ref": "#/definitions/common_wafJWKS",
                    "x-displayname": "JSON Web Key Set (JWKS)"
                },
                "mandatory_claims": {
                    "description": " Configuration for validation of mandatory claims. The system will verify that the claim exists in JWT.\n If the claim does not exist JWT token validation will fail.",
                    "title": "Mandatory Claims",
                    "$ref": "#/definitions/common_wafMandatoryClaims",
                    "x-displayname": "Mandatory Claims"
                },
                "reserved_claims": {
                    "description": " Configuration required for validation of reserved claims. If some claims are absent in\n the token validation of these claims should be disabled.",
                    "title": "reserved_claims",
                    "$ref": "#/definitions/common_wafReservedClaims",
                    "x-displayname": "Reserved Claims Validation"
                },
                "target": {
                    "description": " Define endpoints for which JWT token validation will be performed\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "target",
                    "$ref": "#/definitions/common_wafTarget",
                    "x-displayname": "Target",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "token_location": {
                    "description": " Define where in the HTTP request the JWT token will be extracted\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "token location",
                    "$ref": "#/definitions/common_wafTokenLocation",
                    "x-displayname": "Token Location",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_wafMandatoryClaims": {
            "type": "object",
            "description": "Configurable Validation of mandatory Claims.",
            "title": "MandatoryClaims",
            "x-displayname": "Mandatory Claims",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.MandatoryClaims",
            "properties": {
                "claim_names": {
                    "type": "array",
                    "description": "\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Claim names",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Claim Names",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafOpenApiFallThroughMode": {
            "type": "object",
            "description": "x-required\nDetermine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. swagger) or doesn't have a specific rule in custom rules)",
            "title": "Fall Through Mode",
            "x-displayname": "Fall Through Mode",
            "x-ves-oneof-field-fall_through_mode_choice": "[\"fall_through_mode_allow\",\"fall_through_mode_custom\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiFallThroughMode",
            "properties": {
                "fall_through_mode_allow": {
                    "description": "Exclusive with [fall_through_mode_custom]\n Allow any unprotected end point",
                    "title": "Allow",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Allow"
                },
                "fall_through_mode_custom": {
                    "description": "Exclusive with [fall_through_mode_allow]\n Custom rules for any unprotected end point",
                    "title": "Custom",
                    "$ref": "#/definitions/common_wafCustomFallThroughMode",
                    "x-displayname": "Custom"
                }
            }
        },
        "common_wafOpenApiValidationAllSpecEndpointsSettings": {
            "type": "object",
            "description": "Settings for API Inventory validation",
            "title": "OpenAPI Validation API Inventory Settings",
            "x-displayname": "API Inventory",
            "x-ves-oneof-field-oversized_body_choice": "[]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationAllSpecEndpointsSettings",
            "properties": {
                "fall_through_mode": {
                    "description": " Determine what to do with unprotected endpoints (not part of the API Inventory or doesn't have a specific rule in custom rules)\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Fall Through Mode",
                    "$ref": "#/definitions/common_wafOpenApiFallThroughMode",
                    "x-displayname": "Fall Through Mode",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "settings": {
                    "description": " OpenAPI specification validation settings relevant for \"API Inventory\" enforcement and for \"Custom list\" enforcement",
                    "title": "OpenAPI specification validation common settings",
                    "$ref": "#/definitions/common_wafOpenApiValidationCommonSettings",
                    "x-displayname": "Common Settings"
                },
                "validation_mode": {
                    "description": " Validation mode of OpenAPI specification.\n  When a validation mismatch occurs on a request to one of the API Inventory endpoints\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Validation Mode",
                    "$ref": "#/definitions/common_wafOpenApiValidationMode",
                    "x-displayname": "Validation Mode",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_wafOpenApiValidationCommonSettings": {
            "type": "object",
            "description": "OpenAPI specification validation settings relevant for \"API Inventory\" enforcement and for \"Custom list\" enforcement",
            "title": "OpenAPI specification validation common settings",
            "x-displayname": "Common Settings",
            "x-ves-oneof-field-fail_configuration": "[]",
            "x-ves-oneof-field-oversized_body_choice": "[\"oversized_body_fail_validation\",\"oversized_body_skip_validation\"]",
            "x-ves-oneof-field-property_validation_settings_choice": "[\"property_validation_settings_custom\",\"property_validation_settings_default\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationCommonSettings",
            "properties": {
                "oversized_body_fail_validation": {
                    "description": "Exclusive with [oversized_body_skip_validation]\n Apply the request/response action (block or report) when the body length is too long to verify (default 64Kb)",
                    "title": "Fail the validation for over-sized body",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Fail Body Validation"
                },
                "oversized_body_skip_validation": {
                    "description": "Exclusive with [oversized_body_fail_validation]\n Skip body validation when the body length is too long to verify (default 64Kb)",
                    "title": "Skip validation for over-sized body",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip Body Validation"
                },
                "property_validation_settings_custom": {
                    "description": "Exclusive with [property_validation_settings_default]\n Use custom settings with Open API specification validation",
                    "title": "Custom settings",
                    "$ref": "#/definitions/common_wafValidationPropertySetting",
                    "x-displayname": "Custom"
                },
                "property_validation_settings_default": {
                    "description": "Exclusive with [property_validation_settings_custom]\n Keep the default settings of OpenAPI specification validation",
                    "title": "Default",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                }
            }
        },
        "common_wafOpenApiValidationMode": {
            "type": "object",
            "description": "x-required\nValidation mode of OpenAPI specification.\n When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. swagger)",
            "title": "Validation Mode",
            "x-displayname": "Validation Mode",
            "x-ves-oneof-field-response_validation_mode_choice": "[\"response_validation_mode_active\",\"skip_response_validation\"]",
            "x-ves-oneof-field-validation_mode_choice": "[\"skip_validation\",\"validation_mode_active\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationMode",
            "properties": {
                "response_validation_mode_active": {
                    "description": "Exclusive with [skip_response_validation]\n Enforce OpenAPI validation processing for this event",
                    "title": "Validate",
                    "$ref": "#/definitions/common_wafOpenApiValidationModeActiveResponse",
                    "x-displayname": "Validate"
                },
                "skip_response_validation": {
                    "description": "Exclusive with [response_validation_mode_active]\n Skip OpenAPI validation processing for this event",
                    "title": "Skip",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip"
                },
                "skip_validation": {
                    "description": "Exclusive with [validation_mode_active]\n Skip OpenAPI validation processing for this event",
                    "title": "Skip",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip"
                },
                "validation_mode_active": {
                    "description": "Exclusive with [skip_validation]\n Enforce OpenAPI validation processing for this event",
                    "title": "Validate",
                    "$ref": "#/definitions/common_wafOpenApiValidationModeActive",
                    "x-displayname": "Validate"
                }
            }
        },
        "common_wafOpenApiValidationModeActive": {
            "type": "object",
            "description": "Validation mode properties of request",
            "title": "Open API Validation Mode Active For Request",
            "x-displayname": "Open API Validation Mode Active",
            "x-ves-oneof-field-validation_enforcement_type": "[\"enforcement_block\",\"enforcement_report\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationModeActive",
            "properties": {
                "enforcement_block": {
                    "description": "Exclusive with [enforcement_report]\n Block the request, trigger an API security event",
                    "title": "Block",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Block"
                },
                "enforcement_report": {
                    "description": "Exclusive with [enforcement_block]\n Allow the request, trigger an API security event",
                    "title": "Report",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Report"
                },
                "request_validation_properties": {
                    "type": "array",
                    "description": " List of properties of the request to validate according to the OpenAPI specification file (a.k.a. swagger)\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.not_in: [7]\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Request Validation Properties",
                    "minItems": 1,
                    "items": {
                        "$ref": "#/definitions/schemaOpenApiValidationProperties"
                    },
                    "x-displayname": "Request Validation Properties",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.not_in": "[7]",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafOpenApiValidationModeActiveResponse": {
            "type": "object",
            "description": "Validation mode properties of response",
            "title": "Open API Validation Mode Active For Response",
            "x-displayname": "Open API Validation Mode Active",
            "x-ves-oneof-field-validation_enforcement_type": "[\"enforcement_block\",\"enforcement_report\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationModeActiveResponse",
            "properties": {
                "enforcement_block": {
                    "description": "Exclusive with [enforcement_report]\n Block the response, trigger an API security event",
                    "title": "Block",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Block"
                },
                "enforcement_report": {
                    "description": "Exclusive with [enforcement_block]\n Allow the response, trigger an API security event",
                    "title": "Report",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Report"
                },
                "response_validation_properties": {
                    "type": "array",
                    "description": " List of properties of the response to validate according to the OpenAPI specification file (a.k.a. swagger)\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.in: [2,4,5,7]\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Response Validation Properties",
                    "minItems": 1,
                    "items": {
                        "$ref": "#/definitions/schemaOpenApiValidationProperties"
                    },
                    "x-displayname": "Response Validation Properties",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.in": "[2,4,5,7]",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafOpenApiValidationRule": {
            "type": "object",
            "description": "OpenAPI Validation Rule for a specific endpoint, base-path, or API group",
            "title": "OpenAPI Validation Rule",
            "x-displayname": "OpenAPI Validation Rule",
            "x-ves-oneof-field-condition_type_choice": "[\"api_endpoint\",\"api_group\",\"base_path\"]",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"specific_domain\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.OpenApiValidationRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [specific_domain]\n The rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "api_endpoint": {
                    "description": "Exclusive with [api_group base_path]\n The API endpoint (Path + Method) which this validation applies to",
                    "title": "API Endpoint",
                    "$ref": "#/definitions/common_wafApiEndpointDetails",
                    "x-displayname": "API Endpoint"
                },
                "api_group": {
                    "type": "string",
                    "description": "Exclusive with [api_endpoint base_path]\n The API group which this validation applies to\n\nExample: - \"oas-all-operations\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "api_group",
                    "maxLength": 128,
                    "x-displayname": "API Group",
                    "x-ves-example": "oas-all-operations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "base_path": {
                    "type": "string",
                    "description": "Exclusive with [api_endpoint api_group]\n The base path which this validation applies to\n\nExample: - \"/api/v1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "base path",
                    "maxLength": 128,
                    "x-displayname": "Base Path",
                    "x-ves-example": "/api/v1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "specific_domain": {
                    "type": "string",
                    "description": "Exclusive with [any_domain]\n The rule will apply for a specific domain.\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n  ves.io.schema.rules.string.vh_domain: true\n",
                    "title": "domain",
                    "maxLength": 128,
                    "x-displayname": "Specific Domain",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128",
                        "ves.io.schema.rules.string.vh_domain": "true"
                    }
                },
                "validation_mode": {
                    "description": " Validation mode of OpenAPI specification.\n  When a validation mismatch occurs on a request to one of the endpoints listed on the OpenAPI specification file (a.k.a. swagger)\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Validation Mode",
                    "$ref": "#/definitions/common_wafOpenApiValidationMode",
                    "x-displayname": "Validation Mode",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_wafRateLimitConfigType": {
            "type": "object",
            "title": "RateLimitConfigType",
            "x-displayname": "RateLimitConfigType",
            "x-ves-oneof-field-ip_allowed_list_choice": "[\"custom_ip_allowed_list\",\"ip_allowed_list\",\"no_ip_allowed_list\"]",
            "x-ves-oneof-field-policy_choice": "[\"no_policies\",\"policies\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.RateLimitConfigType",
            "properties": {
                "custom_ip_allowed_list": {
                    "description": "Exclusive with [ip_allowed_list no_ip_allowed_list]\n IP Allowed list using existing ip_prefix_set objects.",
                    "title": "Custom IP list",
                    "$ref": "#/definitions/common_wafCustomIpAllowedList",
                    "x-displayname": "IP Allowed List using IP Prefix Set(s)"
                },
                "ip_allowed_list": {
                    "description": "Exclusive with [custom_ip_allowed_list no_ip_allowed_list]\n List of IP(s) for which rate limiting will be disabled.",
                    "title": "IP Allowed List",
                    "$ref": "#/definitions/viewsPrefixStringListType",
                    "x-displayname": "IP Allowed List"
                },
                "no_ip_allowed_list": {
                    "description": "Exclusive with [custom_ip_allowed_list ip_allowed_list]\n There is no ip allowed list for rate limiting, all clients go through rate limiting.",
                    "title": "No IP Allowed List",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No IP Allowed"
                },
                "no_policies": {
                    "description": "Exclusive with [policies]\n Do not apply additional rate limiter policies.",
                    "title": "no_policies",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No Rate Limiter Policies"
                },
                "policies": {
                    "description": "Exclusive with [no_policies]\n Apply rate limiter policies to requests that are not from the IP Allowed List.\n The policies are evaluated sequentially until a matching rule is identified. If there's a match, the rate limiting behavior is modified according\n to the action configured in the rule. If there's no match, the rate limiting configuration for the HTTP load balancer is honored.",
                    "title": "policies",
                    "$ref": "#/definitions/rate_limiter_policyPolicyList",
                    "x-displayname": "Rate Limiter Policies"
                },
                "rate_limiter": {
                    "description": " Requests to the virtual_host are rate limited based on the parameters specified in the rate_limiter.",
                    "title": "rate_limiter",
                    "$ref": "#/definitions/rate_limiterRateLimitValue",
                    "x-displayname": "Request Rate Limiter"
                }
            }
        },
        "common_wafReservedClaims": {
            "type": "object",
            "description": "Configurable Validation of reserved Claims",
            "title": "reserved claims",
            "x-displayname": "Reserved claims configuration",
            "x-ves-oneof-field-audience_validation": "[\"audience\",\"audience_disable\"]",
            "x-ves-oneof-field-issuer_validation": "[\"issuer\",\"issuer_disable\"]",
            "x-ves-oneof-field-validate_period": "[\"validate_period_disable\",\"validate_period_enable\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ReservedClaims",
            "properties": {
                "audience": {
                    "description": "Exclusive with [audience_disable]\n",
                    "title": "audience",
                    "$ref": "#/definitions/common_wafAudiences",
                    "x-displayname": "Exact Match"
                },
                "audience_disable": {
                    "description": "Exclusive with [audience]\n",
                    "title": "audience_disable",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "issuer": {
                    "type": "string",
                    "description": "Exclusive with [issuer_disable]\n",
                    "title": "issuer",
                    "x-displayname": "Exact Match"
                },
                "issuer_disable": {
                    "description": "Exclusive with [issuer]\n",
                    "title": "issuer_disable",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "validate_period_disable": {
                    "description": "Exclusive with [validate_period_enable]\n",
                    "title": "validate_period_disable",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "validate_period_enable": {
                    "description": "Exclusive with [validate_period_disable]\n",
                    "title": "validate_period_enable",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable"
                }
            }
        },
        "common_wafServerUrlRule": {
            "type": "object",
            "title": "ServerUrlRule",
            "x-displayname": "Server URLs and API Groups",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"specific_domain\"]",
            "x-ves-oneof-field-rate_limiter_choice": "[\"inline_rate_limiter\",\"ref_rate_limiter\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ServerUrlRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [specific_domain]\n The rule will apply for all domains.",
                    "title": "any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "api_group": {
                    "type": "string",
                    "description": " API groups derived from API Definition swaggers.\n For example oas-all-operations including all paths and methods from the swaggers, oas-base-urls covering all requests under base-paths from the swaggers.\n Custom groups can be created if user tags paths or operations with \"x-volterra-api-group\" extensions inside swaggers.\n\nExample: - \"oas-all-operations\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "api_group",
                    "maxLength": 128,
                    "x-displayname": "API Group",
                    "x-ves-example": "oas-all-operations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "base_path": {
                    "type": "string",
                    "description": " Prefix of the request path.\n\nExample: - \"/\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "base path",
                    "maxLength": 128,
                    "x-displayname": "Base Path",
                    "x-ves-example": "/",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "client_matcher": {
                    "description": " Conditions related to the origin of the request, such as client IP, TLS fingerprint, etc.",
                    "title": "client_matcher",
                    "$ref": "#/definitions/policyClientMatcher",
                    "x-displayname": "Clients"
                },
                "inline_rate_limiter": {
                    "description": "Exclusive with [ref_rate_limiter]\n Specify rate values for the rule.",
                    "title": "Inline Rate Limiter",
                    "$ref": "#/definitions/common_wafInlineRateLimiter",
                    "x-displayname": "Specific Values"
                },
                "ref_rate_limiter": {
                    "description": "Exclusive with [inline_rate_limiter]\n Use external rate limiter.",
                    "title": "External Rate Limiter",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "External Rate Limiter"
                },
                "request_matcher": {
                    "description": " Conditions related to the request, such as query parameters, headers, etc.",
                    "title": "request_matcher",
                    "$ref": "#/definitions/policyRequestMatcher",
                    "x-displayname": "Request"
                },
                "specific_domain": {
                    "type": "string",
                    "description": "Exclusive with [any_domain]\n The rule will apply for a specific domain.\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n  ves.io.schema.rules.string.vh_domain: true\n",
                    "title": "domain",
                    "maxLength": 128,
                    "x-displayname": "Specific Domain",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128",
                        "ves.io.schema.rules.string.vh_domain": "true"
                    }
                }
            }
        },
        "common_wafServicePolicyList": {
            "type": "object",
            "description": "List of service policies.",
            "title": "service policy list",
            "x-displayname": "Service Policy List",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ServicePolicyList",
            "properties": {
                "policies": {
                    "type": "array",
                    "description": " Service Policies is a sequential engine where policies (and rules within the policy) are evaluated one after the other. It's important to define the\n correct order (policies evaluated from top to bottom in the list) for service policies, to get the intended result.\n For each request, its characteristics are evaluated based on the match criteria in each service policy starting at the top. If there is a match in the\n current policy, then the policy takes effect, and no more policies are evaluated. Otherwise, the next policy is evaluated.\n If all policies are evaluated and none match, then the request will be denied by default.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "policies",
                    "minItems": 1,
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "Policies",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "common_wafSimpleClientSrcRule": {
            "type": "object",
            "description": "Simple client source rule specifies the sources to be blocked or trusted (skip WAF)",
            "title": "SimpleClientSrcRule",
            "x-displayname": "Client Rule",
            "x-ves-oneof-field-action_choice": "[\"bot_skip_processing\",\"skip_processing\",\"waf_skip_processing\"]",
            "x-ves-oneof-field-client_source_choice": "[\"as_number\",\"http_header\",\"ip_prefix\",\"user_identifier\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.SimpleClientSrcRule",
            "properties": {
                "actions": {
                    "type": "array",
                    "description": " Actions that should be taken when client identifier matches the rule\n\nValidation Rules:\n  ves.io.schema.rules.enum.defined_only: true\n  ves.io.schema.rules.repeated.max_items: 10\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "actions",
                    "maxItems": 10,
                    "items": {
                        "$ref": "#/definitions/common_wafClientSrcRuleAction"
                    },
                    "x-displayname": "Actions",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.max_items": "10",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "as_number": {
                    "type": "integer",
                    "description": "Exclusive with [http_header ip_prefix user_identifier]\n RFC 6793 defined 4-byte AS number\n\nExample: - \"4683\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 401308\n",
                    "title": "as number",
                    "format": "int64",
                    "x-displayname": "AS Number",
                    "x-ves-example": "4683",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "401308"
                    }
                },
                "bot_skip_processing": {
                    "description": "Exclusive with [skip_processing waf_skip_processing]\n Skip Bot Defense processing for clients matching this rule.",
                    "title": "Skip Bot Processing",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip Bot Defense Processing"
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": " The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\n the configuration but is not applied anymore.\n\nExample: - \"2019-12-31:44:34.171543432Z\"-\n\nValidation Rules:\n  ves.io.schema.rules.timestamp.within.seconds: 31536000\n",
                    "title": "expiration timestamp",
                    "format": "date-time",
                    "x-displayname": "Expiration Timestamp",
                    "x-ves-example": "2019-12-31:44:34.171543432Z",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.timestamp.within.seconds": "31536000"
                    }
                },
                "http_header": {
                    "description": "Exclusive with [as_number ip_prefix user_identifier]\n Request header name and value pairs",
                    "title": "HTTP Header",
                    "$ref": "#/definitions/common_wafHttpHeaderMatcherList",
                    "x-displayname": "HTTP Headers"
                },
                "ip_prefix": {
                    "type": "string",
                    "description": "Exclusive with [as_number http_header user_identifier]\n IPv4 prefix string.\n\nExample: - \"192.168.20.0/24\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.ipv4_prefix: true\n",
                    "title": "ip prefix",
                    "x-displayname": "IP Prefix",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.ipv4_prefix": "true"
                    }
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "skip_processing": {
                    "description": "Exclusive with [bot_skip_processing waf_skip_processing]\n Skip both WAF and Bot Defense processing for clients matching this rule.",
                    "title": "Skip Both",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip Both"
                },
                "user_identifier": {
                    "type": "string",
                    "description": "Exclusive with [as_number http_header ip_prefix]\n Identify user based on user identifier. User identifier value needs to be copied from security event.\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "user identifier",
                    "maxLength": 256,
                    "x-displayname": "User Identifier",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "waf_skip_processing": {
                    "description": "Exclusive with [bot_skip_processing skip_processing]\n Skip WAF processing for clients matching this rule.",
                    "title": "Skip WAF Processing",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip WAF Processing"
                }
            }
        },
        "common_wafTarget": {
            "type": "object",
            "description": "Define endpoints for which JWT token validation will be performed",
            "title": "target",
            "x-displayname": "Target",
            "x-ves-oneof-field-target": "[\"all_endpoint\",\"api_groups\",\"base_paths\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.Target",
            "properties": {
                "all_endpoint": {
                    "description": "Exclusive with [api_groups base_paths]\n Validation will be performed for all requests on this LB",
                    "title": "all_endpoint",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "API Inventory"
                },
                "api_groups": {
                    "description": "Exclusive with [all_endpoint base_paths]\n Validation will be performed for the endpoints mentioned in the API Groups",
                    "title": "api group",
                    "$ref": "#/definitions/common_wafAPIGroups",
                    "x-displayname": "API Groups"
                },
                "base_paths": {
                    "description": "Exclusive with [all_endpoint api_groups]\n Validation will be performed for selected path prefixes",
                    "title": "base paths",
                    "$ref": "#/definitions/common_wafBasePathsType",
                    "x-displayname": "Base Paths"
                }
            }
        },
        "common_wafTokenLocation": {
            "type": "object",
            "description": "Location of JWT in Http request",
            "title": "token location",
            "x-displayname": "Token Location",
            "x-ves-oneof-field-token_location": "[\"bearer_token\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.TokenLocation",
            "properties": {
                "bearer_token": {
                    "description": "Exclusive with []\n Token is found in Authorization HTTP header with Bearer authentication scheme",
                    "title": "bearer token",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Bearer Token"
                }
            }
        },
        "common_wafValidateApiBySpecRule": {
            "type": "object",
            "description": "Define API groups, base paths, or API endpoints and their OpenAPI validation modes.\n Any other api-endpoint not listed will act according to \"Fall Through Mode\".",
            "title": "ValidateApiBySpecRule",
            "x-displayname": "Custom List",
            "x-ves-oneof-field-oversized_body_choice": "[]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ValidateApiBySpecRule",
            "properties": {
                "fall_through_mode": {
                    "description": " Determine what to do with unprotected endpoints (not in the OpenAPI specification file (a.k.a. swagger) or doesn't have a specific rule in custom rules)\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Fall Through Mode",
                    "$ref": "#/definitions/common_wafOpenApiFallThroughMode",
                    "x-displayname": "Fall Through Mode",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "open_api_validation_rules": {
                    "type": "array",
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 15\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "title": "Validation List",
                    "maxItems": 15,
                    "items": {
                        "$ref": "#/definitions/common_wafOpenApiValidationRule"
                    },
                    "x-displayname": "Validation List",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "15",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "settings": {
                    "description": " OpenAPI specification validation settings relevant for \"API Inventory\" enforcement and for \"Custom list\" enforcement",
                    "title": "OpenAPI specification validation common settings",
                    "$ref": "#/definitions/common_wafOpenApiValidationCommonSettings",
                    "x-displayname": "OpenAPI specification validation settings"
                }
            }
        },
        "common_wafValidationPropertySetting": {
            "type": "object",
            "description": "Custom property validation settings",
            "title": "Validation Property settings",
            "x-displayname": "Validation Property Settings",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ValidationPropertySetting",
            "properties": {
                "queryParameters": {
                    "description": " Custom settings for query parameters validation",
                    "title": "Query parameters validation settings",
                    "$ref": "#/definitions/common_wafValidationSettingForQueryParameters",
                    "x-displayname": "Validation Settings For Query Parameters"
                }
            }
        },
        "common_wafValidationSettingForHeaders": {
            "type": "object",
            "description": "x-displayName: \"Validation Settings For Headers\"\nCustom settings for headers validation",
            "title": "Validation Settings For Headers",
            "properties": {
                "allow_additional_headers": {
                    "description": "x-displayName: \"Allow\"\nAllow extra headers (on top of what specified in the OAS documentation)",
                    "title": "Allow",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "disallow_additional_headers": {
                    "description": "x-displayName: \"Disallow\"\nDisallow extra headers (on top of what specified in the OAS documentation)",
                    "title": "Custom settings",
                    "$ref": "#/definitions/ioschemaEmpty"
                }
            }
        },
        "common_wafValidationSettingForQueryParameters": {
            "type": "object",
            "description": "Custom settings for query parameters validation",
            "title": "Validation Settings For Query Parameters",
            "x-displayname": "Validation Settings For Query Parameters",
            "x-ves-oneof-field-additional_parameters_choice": "[\"allow_additional_parameters\",\"disallow_additional_parameters\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.ValidationSettingForQueryParameters",
            "properties": {
                "allow_additional_parameters": {
                    "description": "Exclusive with [disallow_additional_parameters]\n Allow extra query parameters (on top of what specified in the OAS documentation)",
                    "title": "Allow",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Allow"
                },
                "disallow_additional_parameters": {
                    "description": "Exclusive with [allow_additional_parameters]\n Disallow extra query parameters (on top of what specified in the OAS documentation)",
                    "title": "Custom settings",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disallow"
                }
            }
        },
        "http_loadbalancerProxyTypeHttp": {
            "type": "object",
            "description": "Choice for selecting HTTP proxy",
            "title": "HTTP Choice",
            "x-displayname": "HTTP Choice",
            "x-ves-displayorder": "1,3",
            "x-ves-oneof-field-port_choice": "[\"port\",\"port_ranges\"]",
            "x-ves-proto-message": "ves.io.schema.views.http_loadbalancer.ProxyTypeHttp",
            "properties": {
                "dns_volterra_managed": {
                    "type": "boolean",
                    "description": " DNS records for domains will be managed automatically by F5 Distributed Cloud.\n As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature\n or a DNS CNAME record should be created in your DNS provider's portal.",
                    "title": "Manage DNS Domain",
                    "format": "boolean",
                    "x-displayname": "Automatically Manage DNS Records"
                },
                "port": {
                    "type": "integer",
                    "description": "Exclusive with [port_ranges]\n HTTP port to Listen.\n\nExample: - \"80\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 65535\n",
                    "title": "HTTP port to listen",
                    "format": "int64",
                    "x-displayname": "HTTP Listen Port",
                    "x-ves-example": "80",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "65535"
                    }
                },
                "port_ranges": {
                    "type": "string",
                    "description": "Exclusive with [port]\n A string containing a comma separated list of port ranges.\n Each port range consists of a single port or two ports separated by \"-\".\n\nExample: - \"80,443,8080-8191,9080\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 512\n  ves.io.schema.rules.string.max_ports: 64\n  ves.io.schema.rules.string.min_len: 1\n  ves.io.schema.rules.string.unique_port_range_list: true\n",
                    "title": "Port_ranges",
                    "minLength": 1,
                    "maxLength": 512,
                    "x-displayname": "Port Ranges",
                    "x-ves-example": "80,443,8080-8191,9080",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "512",
                        "ves.io.schema.rules.string.max_ports": "64",
                        "ves.io.schema.rules.string.min_len": "1",
                        "ves.io.schema.rules.string.unique_port_range_list": "true"
                    }
                }
            }
        },
        "ioschemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "ioschemaHeaderMatcherType": {
            "type": "object",
            "description": "Header match is done using the name of the header and its value.\nThe value match is done using one of the following\n    regex match on value\n    exact match of value\n    presence of header\n\nHeader Match can also be inverse of above, which be used to check\n    missing header or\n    non-matching value",
            "title": "HeaderMatcherType",
            "x-displayname": "Header to Match",
            "x-ves-oneof-field-value_match": "[\"exact\",\"presence\",\"regex\"]",
            "x-ves-proto-message": "ves.io.schema.HeaderMatcherType",
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "Exclusive with [presence regex]\n Header value to match exactly\n\nExample: - \"application/json\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.not_empty: true\n",
                    "title": "exact",
                    "maxLength": 256,
                    "x-displayname": "Exact",
                    "x-ves-example": "application/json",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.not_empty": "true"
                    }
                },
                "invert_match": {
                    "type": "boolean",
                    "description": " Invert the result of the match to detect missing header or non-matching value",
                    "title": "invert_match",
                    "format": "boolean",
                    "x-displayname": "NOT of match"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the header\n\nExample: - \"Content-Type\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_header_field: true\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "name",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Name",
                    "x-ves-example": "Content-Type",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_header_field": "true",
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "presence": {
                    "type": "boolean",
                    "description": "Exclusive with [exact regex]\n If true, check for presence of header",
                    "title": "presence",
                    "format": "boolean",
                    "x-displayname": "Presence"
                },
                "regex": {
                    "type": "string",
                    "description": "Exclusive with [exact presence]\n Regex match of the header value in re2 format\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.not_empty: true\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "regex",
                    "maxLength": 256,
                    "x-displayname": "Regex",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.not_empty": "true",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                }
            }
        },
        "ioschemaObjectRefType": {
            "type": "object",
            "description": "This type establishes a 'direct reference' from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name for public API and Uid for private API\nThis type of reference is called direct because the relation is explicit and concrete (as opposed\nto selector reference which builds a group based on labels of selectee objects)",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.ObjectRefType",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then kind will hold the referred object's kind (e.g. \"route\")\n\nExample: - \"virtual_site\"-",
                    "title": "kind",
                    "x-displayname": "Kind",
                    "x-ves-example": "virtual_site"
                },
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contactus-route\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contactus-route"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then uid will hold the referred object's(e.g. route's) uid.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "ioschemaPathMatcherType": {
            "type": "object",
            "description": "Path match of the URI can be either be, Prefix match or exact match or regular expression match",
            "title": "PathMatcherType",
            "x-displayname": "Path to Match",
            "x-ves-displayorder": "4",
            "x-ves-oneof-field-path_match": "[\"path\",\"prefix\",\"regex\"]",
            "x-ves-proto-message": "ves.io.schema.PathMatcherType",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Exclusive with [prefix regex]\n Exact path value to match\n\nExample: - \"/logout\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "path",
                    "maxLength": 256,
                    "x-displayname": "Path",
                    "x-ves-example": "/logout",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "prefix": {
                    "type": "string",
                    "description": "Exclusive with [path regex]\n Path prefix to match (e.g. the value / will match on all paths)\n\nExample: - \"/register/\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "prefix",
                    "maxLength": 256,
                    "x-displayname": "Prefix",
                    "x-ves-example": "/register/",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "regex": {
                    "type": "string",
                    "description": "Exclusive with [path prefix]\n Regular expression of path match (e.g. the value .* will match on all paths)\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "regex",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Regex",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                }
            }
        },
        "origin_poolOriginServerPublicIP": {
            "type": "object",
            "description": "Specify origin server with public IP address",
            "title": "OriginServerPublicIP",
            "x-displayname": "Public IP",
            "x-ves-displayorder": "2",
            "x-ves-oneof-field-public_ip_choice": "[\"ip\"]",
            "x-ves-proto-message": "ves.io.schema.views.origin_pool.OriginServerPublicIP",
            "properties": {
                "ip": {
                    "type": "string",
                    "description": "Exclusive with []\n Public IPV4 address\n\nExample: - \"8.8.8.8\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.ipv4: true\n",
                    "title": "IP",
                    "x-displayname": "Public IPV4",
                    "x-ves-example": "8.8.8.8",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.ipv4": "true"
                    }
                },
                "ipv6": {
                    "type": "string",
                    "description": " Public IPV6 address\n\nExample: - \"2001::1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.ipv6: true\n",
                    "title": "IPV6",
                    "x-displayname": "Public IPV6",
                    "x-ves-example": "2001::1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.ipv6": "true"
                    }
                }
            }
        },
        "origin_poolOriginServerPublicName": {
            "type": "object",
            "description": "Specify origin server with public DNS name",
            "title": "OriginServerPublicName",
            "x-displayname": "Public DNS Name",
            "x-ves-displayorder": "1,2",
            "x-ves-proto-message": "ves.io.schema.views.origin_pool.OriginServerPublicName",
            "properties": {
                "dns_name": {
                    "type": "string",
                    "description": " DNS Name\n\nExample: - \"value\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "DNS name",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "DNS Name",
                    "x-ves-example": "value",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                },
                "refresh_interval": {
                    "type": "integer",
                    "description": " Interval for DNS refresh in seconds.\n Max value is 7 days as per https://datatracker.ietf.org/doc/html/rfc8767\n\nExample: - \"20\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 604800\n",
                    "title": "refresh_interval",
                    "format": "int64",
                    "x-displayname": "DNS Refresh interval",
                    "x-ves-example": "20",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "604800"
                    }
                }
            }
        },
        "origin_poolTlsCertificatesType": {
            "type": "object",
            "description": "mTLS Client Certificate",
            "title": "TlsCertificatesType",
            "x-displayname": "mTLS Certificate",
            "x-ves-displayorder": "1",
            "x-ves-proto-message": "ves.io.schema.views.origin_pool.TlsCertificatesType",
            "properties": {
                "tls_certificates": {
                    "type": "array",
                    "description": " mTLS Client Certificate\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 1\n  ves.io.schema.rules.repeated.min_items: 1\n",
                    "title": "mTLS certificate",
                    "minItems": 1,
                    "maxItems": 1,
                    "items": {
                        "$ref": "#/definitions/schemaTlsCertificateType"
                    },
                    "x-displayname": "mTLS Client Certificate",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "1",
                        "ves.io.schema.rules.repeated.min_items": "1"
                    }
                }
            }
        },
        "origin_poolUpstreamTlsParameters": {
            "type": "object",
            "description": "Upstream TLS Parameters",
            "title": "UpstreamTlsParameters",
            "x-displayname": "TLS Parameters for Origin Servers",
            "x-ves-displayorder": "10,2,8,9,15",
            "x-ves-oneof-field-max_session_keys_type": "[\"default_session_key_caching\",\"disable_session_key_caching\",\"max_session_keys\"]",
            "x-ves-oneof-field-mtls_choice": "[\"no_mtls\",\"use_mtls\",\"use_mtls_obj\"]",
            "x-ves-oneof-field-server_validation_choice": "[\"skip_server_verification\",\"use_server_verification\",\"volterra_trusted_ca\"]",
            "x-ves-oneof-field-sni_choice": "[\"disable_sni\",\"sni\",\"use_host_header_as_sni\"]",
            "x-ves-proto-message": "ves.io.schema.views.origin_pool.UpstreamTlsParameters",
            "properties": {
                "default_session_key_caching": {
                    "description": "Exclusive with [disable_session_key_caching max_session_keys]\n Default session key caching. Only one session key will be cached.",
                    "title": "Default Session Key Caching",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default Session Key Caching"
                },
                "disable_session_key_caching": {
                    "description": "Exclusive with [default_session_key_caching max_session_keys]\n Disable session key caching. This will disable TLS session resumption.",
                    "title": "Disable Session Key Caching",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No Session Key Caching"
                },
                "disable_sni": {
                    "description": "Exclusive with [sni use_host_header_as_sni]\n Do not use SNI.",
                    "title": "disable_sni",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No SNI"
                },
                "max_session_keys": {
                    "type": "integer",
                    "description": "Exclusive with [default_session_key_caching disable_session_key_caching]\n x-example:\"25\"\n Number of session keys that are cached.\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 2\n  ves.io.schema.rules.uint32.lte: 64\n",
                    "title": "Max Session Keys Cached",
                    "format": "int64",
                    "x-displayname": "Max Session Keys Cached",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "2",
                        "ves.io.schema.rules.uint32.lte": "64"
                    }
                },
                "no_mtls": {
                    "description": "Exclusive with [use_mtls use_mtls_obj]\n",
                    "title": "No mTLS",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "skip_server_verification": {
                    "description": "Exclusive with [use_server_verification volterra_trusted_ca]\n Skip origin server verification",
                    "title": "Skip Server Verification",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip Verification"
                },
                "sni": {
                    "type": "string",
                    "description": "Exclusive with [disable_sni use_host_header_as_sni]\n SNI value to be used.\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "sni",
                    "maxLength": 256,
                    "x-displayname": "SNI Value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "tls_config": {
                    "description": " TLS parameters such as min/max TLS version and ciphers\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "TLS Config",
                    "$ref": "#/definitions/viewsTlsConfig",
                    "x-displayname": "TLS Configuration for Origin Servers",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "use_host_header_as_sni": {
                    "description": "Exclusive with [disable_sni sni]\n Use the host header as SNI. The host header value is extracted after any configured rewrites have been applied.",
                    "title": "use_host_header_as_sni",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Host Header"
                },
                "use_mtls": {
                    "description": "Exclusive with [no_mtls use_mtls_obj]\n",
                    "title": "Inline Certificate (legacy)",
                    "$ref": "#/definitions/origin_poolTlsCertificatesType",
                    "x-displayname": "Upload a client authentication certificate specifically for this Origin Pool"
                },
                "use_mtls_obj": {
                    "description": "Exclusive with [no_mtls use_mtls]\n",
                    "title": "Root CA Certificate",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Select/add a TLS Certificate object for client authentication"
                },
                "use_server_verification": {
                    "description": "Exclusive with [skip_server_verification volterra_trusted_ca]\n Perform origin server verification using the provided Root CA Certificate",
                    "title": "Use Server Verification",
                    "$ref": "#/definitions/origin_poolUpstreamTlsValidationContext",
                    "x-displayname": "Use Custom Root CA Certificate"
                },
                "volterra_trusted_ca": {
                    "description": "Exclusive with [skip_server_verification use_server_verification]\n Perform origin server verification using F5XC Default Root CA Certificate",
                    "title": "F5XC Root CA",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Use Default Root CA Certificate"
                }
            }
        },
        "origin_poolUpstreamTlsValidationContext": {
            "type": "object",
            "description": "Upstream TLS Validation Context",
            "title": "UpstreamTlsValidationContext",
            "x-displayname": "TLS Validation Context for Origin Servers",
            "x-ves-oneof-field-trusted_ca_choice": "[\"trusted_ca\",\"trusted_ca_url\"]",
            "x-ves-proto-message": "ves.io.schema.views.origin_pool.UpstreamTlsValidationContext",
            "properties": {
                "trusted_ca": {
                    "description": "Exclusive with [trusted_ca_url]\n Select/Add a Root CA Certificate object to associate with this Origin Pool for verification of server's certificate",
                    "title": "trusted_ca",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Root CA Certificate"
                },
                "trusted_ca_url": {
                    "type": "string",
                    "description": "Exclusive with [trusted_ca]\n Upload a Root CA Certificate specifically for this Origin Pool for verification of server's certificate\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 131072\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.truststore_url: true\n",
                    "title": "trusted_ca_url",
                    "minLength": 1,
                    "maxLength": 131072,
                    "x-displayname": "Inline Root CA Certificate (legacy)",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "131072",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.truststore_url": "true"
                    }
                }
            }
        },
        "policyAppFirewallAttackTypeContext": {
            "type": "object",
            "description": "App Firewall Attack Type context changes to be applied for this request",
            "title": "App Firewall Attack Type Context",
            "x-displayname": "App Firewall Attack Type Context",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallAttackTypeContext",
            "properties": {
                "context": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Context",
                    "$ref": "#/definitions/policyDetectionContext",
                    "x-displayname": "Context",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "context_name": {
                    "type": "string",
                    "description": " Relevant only for contexts: Header, Cookie and Parameter.\n Name of the Context that the WAF Exclusion Rules will check.\n Wildcard matching can be used by prefixing or suffixing the context name\n with an wildcard asterisk (*).\n\nExample: - \"exampleuser-agent for Header\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Context Name",
                    "maxLength": 128,
                    "x-displayname": "Context Name",
                    "x-ves-example": "example: user-agent for Header",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "exclude_attack_type": {
                    "description": "\nExample: - \"ATTACK_TYPE_SQL_INJECTION\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "AttackType",
                    "$ref": "#/definitions/app_firewallAttackType",
                    "x-displayname": "Attack Type",
                    "x-ves-example": "ATTACK_TYPE_SQL_INJECTION",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "policyAppFirewallDetectionControl": {
            "type": "object",
            "description": "Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.",
            "title": "App Firewall Detection Control",
            "x-displayname": "App Firewall Detection Control",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallDetectionControl",
            "properties": {
                "exclude_attack_type_contexts": {
                    "type": "array",
                    "description": " Attack Types to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Attack Types Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallAttackTypeContext"
                    },
                    "x-displayname": "Attack Types",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_bot_name_contexts": {
                    "type": "array",
                    "description": " Bot Names to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Bot Names Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyBotNameContext"
                    },
                    "x-displayname": "Bot Names",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_signature_contexts": {
                    "type": "array",
                    "description": " Signature IDs to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 1024\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Signature Contexts",
                    "maxItems": 1024,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallSignatureContext"
                    },
                    "x-displayname": "Signature IDs",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "1024",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_violation_contexts": {
                    "type": "array",
                    "description": " Violations to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Violation Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallViolationContext"
                    },
                    "x-displayname": "Violations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyAppFirewallSignatureContext": {
            "type": "object",
            "description": "App Firewall signature context changes to be applied for this request",
            "title": "App Firewall Signature Context",
            "x-displayname": "App Firewall Signature Context",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallSignatureContext",
            "properties": {
                "context": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Context",
                    "$ref": "#/definitions/policyDetectionContext",
                    "x-displayname": "Context",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "context_name": {
                    "type": "string",
                    "description": " Relevant only for contexts: Header, Cookie and Parameter.\n Name of the Context that the WAF Exclusion Rules will check.\n Wildcard matching can be used by prefixing or suffixing the context name\n with an wildcard asterisk (*).\n\nExample: - \"exampleuser-agent for Header\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Context Name",
                    "maxLength": 128,
                    "x-displayname": "Context Name",
                    "x-ves-example": "example: user-agent for Header",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "signature_id": {
                    "type": "integer",
                    "description": " The allowed values for signature id are 0 and in the range of 200000001-299999999.\n 0 implies that all signatures will be excluded for the specified context.\n\nExample: - \"10000001\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 299999999\n",
                    "title": "SignatureID",
                    "format": "int64",
                    "x-displayname": "SignatureID",
                    "x-ves-example": "10000001",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "299999999"
                    }
                }
            }
        },
        "policyAppFirewallViolationContext": {
            "type": "object",
            "description": "App Firewall violation context changes to be applied for this request",
            "title": "App Firewall Violation Context",
            "x-displayname": "App Firewall Violation Context",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallViolationContext",
            "properties": {
                "context": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Context",
                    "$ref": "#/definitions/policyDetectionContext",
                    "x-displayname": "Context",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "context_name": {
                    "type": "string",
                    "description": " Relevant only for contexts: Header, Cookie and Parameter.\n Name of the Context that the WAF Exclusion Rules will check.\n Wildcard matching can be used by prefixing or suffixing the context name\n with an wildcard asterisk (*).\n\nExample: - \"exampleuser-agent for Header\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Context Name",
                    "maxLength": 128,
                    "x-displayname": "Context Name",
                    "x-ves-example": "example: user-agent for Header",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "exclude_violation": {
                    "description": "\nExample: - \"VIOL_MANDATORY_HEADER\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "ViolationType",
                    "$ref": "#/definitions/app_firewallAppFirewallViolationType",
                    "x-displayname": "Violation Type",
                    "x-ves-example": "VIOL_MANDATORY_HEADER",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "policyArgMatcherType": {
            "type": "object",
            "description": "A argument matcher specifies the name of a single argument in the body and the criteria to match it.\nA argument matcher can check for one of the following:\n* Presence or absence of the argument\n* At least one of the values for the argument in the request satisfies the MatcherType item",
            "title": "ArgMatcherType",
            "x-displayname": "Argument Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.ArgMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the argument is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the argument is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert Match of the expression defined",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the Arg. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " x-example: \"phones[_]\"\n x-example: \"cars.make.toyota.models[1]\"\n x-example: \"cars.make.honda.models[_]\"\n x-example: \"cars.make[_].models[_]\"\n A case-sensitive JSON path in the HTTP request body.\n\nExample: - \"name\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.json_path: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Argument Name",
                    "x-ves-example": "name",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.json_path": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyAsnMatchList": {
            "type": "object",
            "description": "An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
            "title": "Asn Match List",
            "x-displayname": "ASN Match List",
            "x-ves-proto-message": "ves.io.schema.policy.AsnMatchList",
            "properties": {
                "as_numbers": {
                    "type": "array",
                    "description": " An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.\n\nExample: - \"[713, 7932, 847325, 4683, 15269, 1000001]\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "as numbers",
                    "minItems": 1,
                    "maxItems": 16,
                    "items": {
                        "type": "integer",
                        "format": "int64"
                    },
                    "x-displayname": "AS Numbers",
                    "x-ves-example": "[713, 7932, 847325, 4683, 15269, 1000001]",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyAsnMatcherType": {
            "type": "object",
            "description": "Match any AS number contained in the list of bgp_asn_sets.",
            "title": "asn matcher type",
            "x-displayname": "ASN Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.AsnMatcherType",
            "properties": {
                "asn_sets": {
                    "type": "array",
                    "description": " A list of references to bgp_asn_set objects.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 4\n",
                    "title": "asn_sets",
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "BGP ASN Sets",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "4"
                    }
                }
            }
        },
        "policyBotNameContext": {
            "type": "object",
            "description": "Specifies bot to be excluded by its name.",
            "title": "Bot Name Context",
            "x-displayname": "Bot Name",
            "x-ves-proto-message": "ves.io.schema.policy.BotNameContext",
            "properties": {
                "bot_name": {
                    "type": "string",
                    "description": "\nExample: - \"Hydra\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "BotName",
                    "x-displayname": "Bot Name",
                    "x-ves-example": "Hydra",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "policyClientMatcher": {
            "type": "object",
            "description": "Client conditions for matching a rule",
            "title": "Client Matcher",
            "x-displayname": "Client Matcher",
            "x-ves-oneof-field-client_choice": "[\"any_client\",\"client_selector\",\"ip_threat_category_list\"]",
            "x-ves-oneof-field-ip_asn_choice": "[\"any_ip\",\"asn_list\",\"asn_matcher\",\"ip_matcher\",\"ip_prefix_list\"]",
            "x-ves-proto-message": "ves.io.schema.policy.ClientMatcher",
            "properties": {
                "any_client": {
                    "description": "Exclusive with [client_selector ip_threat_category_list]\n Any Client",
                    "title": "any ip",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Client"
                },
                "any_ip": {
                    "description": "Exclusive with [asn_list asn_matcher ip_matcher ip_prefix_list]\n Any Source IP",
                    "title": "any ip",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Source IP"
                },
                "asn_list": {
                    "description": "Exclusive with [any_ip asn_matcher ip_matcher ip_prefix_list]\n List of 4-byte ASN values.\n The predicate evaluates to true if the origin ASN is present in the ASN list.",
                    "title": "asn list",
                    "$ref": "#/definitions/policyAsnMatchList",
                    "x-displayname": "ASN List"
                },
                "asn_matcher": {
                    "description": "Exclusive with [any_ip asn_list ip_matcher ip_prefix_list]\n List of references to BGP ASN Set objects.\n The predicate evaluates to true if the origin ASN is present in one of the BGP ASN Set objects.",
                    "title": "asn matcher",
                    "$ref": "#/definitions/policyAsnMatcherType",
                    "x-displayname": "BGP ASN Sets"
                },
                "client_selector": {
                    "description": "Exclusive with [any_client ip_threat_category_list]\n A label selector that describes the expected set of clients. The labels associated with the client making the API request are used to evaluate the label\n expressions in the selector. These labels can be derived from the client TLS certificate or from the volterra internal control plane.\n This is a more flexible and powerful version of the client name matcher predicate that allows a given rule to be applicable to a set of clients based on the\n client labels rather than being limited to relying on patterns in the client name.\n The predicate evaluates to true if the expressions in the label selector are true for the client labels.",
                    "title": "client selector",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Group of Clients by Label Selector"
                },
                "ip_matcher": {
                    "description": "Exclusive with [any_ip asn_list asn_matcher ip_prefix_list]\n List of references to IP Prefix Set objects.\n The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes in the IP Prefix Sets.",
                    "title": "ip matcher",
                    "$ref": "#/definitions/policyIpMatcherType",
                    "x-displayname": "IP Prefix Sets"
                },
                "ip_prefix_list": {
                    "description": "Exclusive with [any_ip asn_list asn_matcher ip_matcher]\n List of IP Prefixes values.\n The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes from the list.",
                    "title": "ip prefix list",
                    "$ref": "#/definitions/policyPrefixMatchList",
                    "x-displayname": "IP Prefix List"
                },
                "ip_threat_category_list": {
                    "description": "Exclusive with [any_client client_selector]\n IP threat categories to choose from",
                    "title": "IP Threat Category List",
                    "$ref": "#/definitions/schemapolicyIPThreatCategoryListType",
                    "x-displayname": "List of IP Threat Categories"
                },
                "tls_fingerprint_matcher": {
                    "description": " TLS JA3 fingerprints to be matched.\n The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.",
                    "title": "TLS JA3 fingerprint matcher",
                    "$ref": "#/definitions/policyTlsFingerprintMatcherType",
                    "x-displayname": "TLS Fingerprint Matcher"
                }
            }
        },
        "policyCookieMatcherType": {
            "type": "object",
            "description": "A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each\ncookie in the request.\nA cookie matcher can check for one of the following:\n* Presence or absence of the cookie\n* At least one of the values for the cookie in the request satisfies the MatcherType item",
            "title": "CookieMatcherType",
            "x-displayname": "Cookie Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.CookieMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the cookie is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the cookie is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert Match of the expression defined",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the cookie. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " A case-sensitive cookie name.\n\nExample: - \"Session\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Cookie Name",
                    "x-ves-example": "Session",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyCountryCode": {
            "type": "string",
            "description": "ISO 3166 Aplpha-2 country codes\n",
            "title": "CountryCode",
            "enum": [
                "COUNTRY_NONE",
                "COUNTRY_AD",
                "COUNTRY_AE",
                "COUNTRY_AF",
                "COUNTRY_AG",
                "COUNTRY_AI",
                "COUNTRY_AL",
                "COUNTRY_AM",
                "COUNTRY_AN",
                "COUNTRY_AO",
                "COUNTRY_AQ",
                "COUNTRY_AR",
                "COUNTRY_AS",
                "COUNTRY_AT",
                "COUNTRY_AU",
                "COUNTRY_AW",
                "COUNTRY_AX",
                "COUNTRY_AZ",
                "COUNTRY_BA",
                "COUNTRY_BB",
                "COUNTRY_BD",
                "COUNTRY_BE",
                "COUNTRY_BF",
                "COUNTRY_BG",
                "COUNTRY_BH",
                "COUNTRY_BI",
                "COUNTRY_BJ",
                "COUNTRY_BL",
                "COUNTRY_BM",
                "COUNTRY_BN",
                "COUNTRY_BO",
                "COUNTRY_BQ",
                "COUNTRY_BR",
                "COUNTRY_BS",
                "COUNTRY_BT",
                "COUNTRY_BV",
                "COUNTRY_BW",
                "COUNTRY_BY",
                "COUNTRY_BZ",
                "COUNTRY_CA",
                "COUNTRY_CC",
                "COUNTRY_CD",
                "COUNTRY_CF",
                "COUNTRY_CG",
                "COUNTRY_CH",
                "COUNTRY_CI",
                "COUNTRY_CK",
                "COUNTRY_CL",
                "COUNTRY_CM",
                "COUNTRY_CN",
                "COUNTRY_CO",
                "COUNTRY_CR",
                "COUNTRY_CS",
                "COUNTRY_CU",
                "COUNTRY_CV",
                "COUNTRY_CW",
                "COUNTRY_CX",
                "COUNTRY_CY",
                "COUNTRY_CZ",
                "COUNTRY_DE",
                "COUNTRY_DJ",
                "COUNTRY_DK",
                "COUNTRY_DM",
                "COUNTRY_DO",
                "COUNTRY_DZ",
                "COUNTRY_EC",
                "COUNTRY_EE",
                "COUNTRY_EG",
                "COUNTRY_EH",
                "COUNTRY_ER",
                "COUNTRY_ES",
                "COUNTRY_ET",
                "COUNTRY_FI",
                "COUNTRY_FJ",
                "COUNTRY_FK",
                "COUNTRY_FM",
                "COUNTRY_FO",
                "COUNTRY_FR",
                "COUNTRY_GA",
                "COUNTRY_GB",
                "COUNTRY_GD",
                "COUNTRY_GE",
                "COUNTRY_GF",
                "COUNTRY_GG",
                "COUNTRY_GH",
                "COUNTRY_GI",
                "COUNTRY_GL",
                "COUNTRY_GM",
                "COUNTRY_GN",
                "COUNTRY_GP",
                "COUNTRY_GQ",
                "COUNTRY_GR",
                "COUNTRY_GS",
                "COUNTRY_GT",
                "COUNTRY_GU",
                "COUNTRY_GW",
                "COUNTRY_GY",
                "COUNTRY_HK",
                "COUNTRY_HM",
                "COUNTRY_HN",
                "COUNTRY_HR",
                "COUNTRY_HT",
                "COUNTRY_HU",
                "COUNTRY_ID",
                "COUNTRY_IE",
                "COUNTRY_IL",
                "COUNTRY_IM",
                "COUNTRY_IN",
                "COUNTRY_IO",
                "COUNTRY_IQ",
                "COUNTRY_IR",
                "COUNTRY_IS",
                "COUNTRY_IT",
                "COUNTRY_JE",
                "COUNTRY_JM",
                "COUNTRY_JO",
                "COUNTRY_JP",
                "COUNTRY_KE",
                "COUNTRY_KG",
                "COUNTRY_KH",
                "COUNTRY_KI",
                "COUNTRY_KM",
                "COUNTRY_KN",
                "COUNTRY_KP",
                "COUNTRY_KR",
                "COUNTRY_KW",
                "COUNTRY_KY",
                "COUNTRY_KZ",
                "COUNTRY_LA",
                "COUNTRY_LB",
                "COUNTRY_LC",
                "COUNTRY_LI",
                "COUNTRY_LK",
                "COUNTRY_LR",
                "COUNTRY_LS",
                "COUNTRY_LT",
                "COUNTRY_LU",
                "COUNTRY_LV",
                "COUNTRY_LY",
                "COUNTRY_MA",
                "COUNTRY_MC",
                "COUNTRY_MD",
                "COUNTRY_ME",
                "COUNTRY_MF",
                "COUNTRY_MG",
                "COUNTRY_MH",
                "COUNTRY_MK",
                "COUNTRY_ML",
                "COUNTRY_MM",
                "COUNTRY_MN",
                "COUNTRY_MO",
                "COUNTRY_MP",
                "COUNTRY_MQ",
                "COUNTRY_MR",
                "COUNTRY_MS",
                "COUNTRY_MT",
                "COUNTRY_MU",
                "COUNTRY_MV",
                "COUNTRY_MW",
                "COUNTRY_MX",
                "COUNTRY_MY",
                "COUNTRY_MZ",
                "COUNTRY_NA",
                "COUNTRY_NC",
                "COUNTRY_NE",
                "COUNTRY_NF",
                "COUNTRY_NG",
                "COUNTRY_NI",
                "COUNTRY_NL",
                "COUNTRY_NO",
                "COUNTRY_NP",
                "COUNTRY_NR",
                "COUNTRY_NU",
                "COUNTRY_NZ",
                "COUNTRY_OM",
                "COUNTRY_PA",
                "COUNTRY_PE",
                "COUNTRY_PF",
                "COUNTRY_PG",
                "COUNTRY_PH",
                "COUNTRY_PK",
                "COUNTRY_PL",
                "COUNTRY_PM",
                "COUNTRY_PN",
                "COUNTRY_PR",
                "COUNTRY_PS",
                "COUNTRY_PT",
                "COUNTRY_PW",
                "COUNTRY_PY",
                "COUNTRY_QA",
                "COUNTRY_RE",
                "COUNTRY_RO",
                "COUNTRY_RS",
                "COUNTRY_RU",
                "COUNTRY_RW",
                "COUNTRY_SA",
                "COUNTRY_SB",
                "COUNTRY_SC",
                "COUNTRY_SD",
                "COUNTRY_SE",
                "COUNTRY_SG",
                "COUNTRY_SH",
                "COUNTRY_SI",
                "COUNTRY_SJ",
                "COUNTRY_SK",
                "COUNTRY_SL",
                "COUNTRY_SM",
                "COUNTRY_SN",
                "COUNTRY_SO",
                "COUNTRY_SR",
                "COUNTRY_SS",
                "COUNTRY_ST",
                "COUNTRY_SV",
                "COUNTRY_SX",
                "COUNTRY_SY",
                "COUNTRY_SZ",
                "COUNTRY_TC",
                "COUNTRY_TD",
                "COUNTRY_TF",
                "COUNTRY_TG",
                "COUNTRY_TH",
                "COUNTRY_TJ",
                "COUNTRY_TK",
                "COUNTRY_TL",
                "COUNTRY_TM",
                "COUNTRY_TN",
                "COUNTRY_TO",
                "COUNTRY_TR",
                "COUNTRY_TT",
                "COUNTRY_TV",
                "COUNTRY_TW",
                "COUNTRY_TZ",
                "COUNTRY_UA",
                "COUNTRY_UG",
                "COUNTRY_UM",
                "COUNTRY_US",
                "COUNTRY_UY",
                "COUNTRY_UZ",
                "COUNTRY_VA",
                "COUNTRY_VC",
                "COUNTRY_VE",
                "COUNTRY_VG",
                "COUNTRY_VI",
                "COUNTRY_VN",
                "COUNTRY_VU",
                "COUNTRY_WF",
                "COUNTRY_WS",
                "COUNTRY_XK",
                "COUNTRY_XT",
                "COUNTRY_YE",
                "COUNTRY_YT",
                "COUNTRY_ZA",
                "COUNTRY_ZM",
                "COUNTRY_ZW"
            ],
            "default": "COUNTRY_NONE",
            "x-displayname": "Country Code",
            "x-ves-proto-enum": "ves.io.schema.policy.CountryCode"
        },
        "policyCountryCodeList": {
            "type": "object",
            "description": "x-displayName: \"Country Codes List\"\nList of Country Codes to match against.",
            "title": "Country Code List",
            "properties": {
                "country_codes": {
                    "type": "array",
                    "description": "x-displayName: \"Country Codes List\"\nx-example: \"IN, DE\"\nx-required\nList of Country Codes",
                    "title": "country codes",
                    "items": {
                        "$ref": "#/definitions/policyCountryCode"
                    }
                },
                "invert_match": {
                    "type": "boolean",
                    "description": "x-displayName: \"Invert Match Result\"\nInvert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean"
                }
            }
        },
        "policyDetectionContext": {
            "type": "string",
            "description": "The available contexts for Exclusion rules.\n\n - CONTEXT_ANY: CONTEXT_ANY\n\nDetection will be excluded for all contexts.\n - CONTEXT_BODY: CONTEXT_BODY\n\nDetection will be excluded for the request body.\n - CONTEXT_REQUEST: CONTEXT_REQUEST\n\nDetection will be excluded for the request.\n - CONTEXT_RESPONSE: CONTEXT_RESPONSE\n\n - CONTEXT_PARAMETER: CONTEXT_PARAMETER\n\nDetection will be excluded for the parameters. The parameter name is required in the Context name field. If the field is left empty, the detection will be excluded for all parameters.\n - CONTEXT_HEADER: CONTEXT_HEADER\n\nDetection will be excluded for the headers. The header name is required in the Context name field. If the field is left empty, the detection will be excluded for all headers.\n - CONTEXT_COOKIE: CONTEXT_COOKIE\n\nDetection will be excluded for the cookies. The cookie name is required in the Context name field. If the field is left empty, the detection will be excluded for all cookies.\n - CONTEXT_URL: CONTEXT_URL\n\nDetection will be excluded for the request URL.\n - CONTEXT_URI: CONTEXT_URI\n",
            "title": "Detection Context",
            "enum": [
                "CONTEXT_ANY",
                "CONTEXT_BODY",
                "CONTEXT_REQUEST",
                "CONTEXT_RESPONSE",
                "CONTEXT_PARAMETER",
                "CONTEXT_HEADER",
                "CONTEXT_COOKIE",
                "CONTEXT_URL",
                "CONTEXT_URI"
            ],
            "default": "CONTEXT_ANY",
            "x-displayname": "WAF Exclusion Context Options",
            "x-ves-proto-enum": "ves.io.schema.policy.DetectionContext"
        },
        "policyGraphQLRule": {
            "type": "object",
            "description": "This section defines various configuration options for GraphQL inspection.",
            "title": "GraphQL Rule",
            "x-displayname": "GraphQL",
            "x-ves-displayorder": "1,2,6,8,7",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"exact_value\",\"suffix_value\"]",
            "x-ves-oneof-field-method_choice": "[\"method_get\",\"method_post\"]",
            "x-ves-proto-message": "ves.io.schema.policy.GraphQLRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [exact_value suffix_value]\n Enable GraphQL inspection for any domain",
                    "title": "Any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "exact_path": {
                    "type": "string",
                    "description": " Specifies the exact path to GraphQL endpoint. Default value is /graphql.\n\nExample: - \"/graphql\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "Path",
                    "maxLength": 256,
                    "x-displayname": "Path",
                    "x-ves-example": "/graphql",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "exact_value": {
                    "type": "string",
                    "description": "Exclusive with [any_domain suffix_value]\n Exact domain name\n\nExample: - \"abc.zyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "exact value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Exact Value",
                    "x-ves-example": "abc.zyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                },
                "graphql_settings": {
                    "description": " GraphQL configuration.",
                    "title": "GraphQL Settings",
                    "$ref": "#/definitions/policyGraphQLSettingsType",
                    "x-displayname": "GraphQL Settings"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "method_get": {
                    "description": "Exclusive with [method_post]\n",
                    "title": "Get",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "GET"
                },
                "method_post": {
                    "description": "Exclusive with [method_get]\n",
                    "title": "Post",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "POST"
                },
                "suffix_value": {
                    "type": "string",
                    "description": "Exclusive with [any_domain exact_value]\n Suffix of domain name e.g \"xyz.com\" will match \"*.xyz.com\" and \"xyz.com\"\n\nExample: - \"xyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "suffix value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Suffix Value",
                    "x-ves-example": "xyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                }
            }
        },
        "policyGraphQLSettingsType": {
            "type": "object",
            "description": "GraphQL configuration.",
            "title": "GraphQL Settings",
            "x-displayname": "GraphQL Settings",
            "x-ves-oneof-field-allow_introspection_queries_choice": "[\"disable_introspection\",\"enable_introspection\"]",
            "x-ves-proto-message": "ves.io.schema.policy.GraphQLSettingsType",
            "properties": {
                "disable_introspection": {
                    "description": "Exclusive with [enable_introspection]\n Disable introspection queries for the load balancer.",
                    "title": "Disable Introspection Queries",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "enable_introspection": {
                    "description": "Exclusive with [disable_introspection]\n Enable introspection queries for the load balancer.",
                    "title": "Enable Introspection Queries",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable"
                },
                "max_batched_queries": {
                    "type": "integer",
                    "description": " Specify maximum number of queries in a single batched request.\n\nExample: - \"10\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 20\n",
                    "title": "Max Batched Queries",
                    "format": "int64",
                    "x-displayname": "Maximum Batched Queries",
                    "x-ves-example": "10",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "20"
                    }
                },
                "max_depth": {
                    "type": "integer",
                    "description": " Specify maximum depth for the GraphQL query.\n\nExample: - \"10\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 20\n",
                    "title": "Max Depth",
                    "format": "int64",
                    "x-displayname": "Maximum Structure Depth",
                    "x-ves-example": "10",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "20"
                    }
                },
                "max_total_length": {
                    "type": "integer",
                    "description": " Specify maximum length in bytes for the GraphQL query.\n\nExample: - \"5000\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 16386\n",
                    "title": "Max Total Length",
                    "format": "int64",
                    "x-displayname": "Maximum Total Length",
                    "x-ves-example": "5000",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "16386"
                    }
                }
            }
        },
        "policyHeaderMatcherTypeBasic": {
            "type": "object",
            "description": "A header matcher specifies the name of a single HTTP header and the criteria for the input request to match it. The input has a list of actual values for each\nheader name in the original HTTP request.\nA header matcher can check for one of the following:\n* Presence or absence of the header in the input\n* At least one of the values for the header in the input satisfies the MatcherType item",
            "title": "HeaderMatcherTypeBasic",
            "x-displayname": "Header Matcher",
            "x-ves-displayorder": "1,6",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.HeaderMatcherTypeBasic",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the header is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the header is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the header. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " A case-insensitive HTTP header name.\n\nExample: - \"Accept-Encoding\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_header_field: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Header Name",
                    "x-ves-example": "Accept-Encoding",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_header_field": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyHttpCookieName": {
            "type": "object",
            "description": "x-displayName: \"Name of the cookie field\"\nSpecifies the name of the cookie field",
            "title": "HttpCookieName",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Cookie Name\"\nx-example: \"token\"\nx-required\nA case-insensitive cookie name.",
                    "title": "name"
                }
            }
        },
        "policyHttpHeaderName": {
            "type": "object",
            "description": "x-displayName: \"Name of the field\"\nSpecifies the name of the field",
            "title": "HttpHeaderName",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Header Name\"\nx-example: \"X-Token\"\nx-required\nA case-insensitive field header name.",
                    "title": "name"
                }
            }
        },
        "policyHttpMethodMatcherType": {
            "type": "object",
            "description": "A http method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list.\nThe result of the match based on the method list is inverted if invert_matcher is true.",
            "title": "HttpMethodMatcherType",
            "x-displayname": "HTTP Method Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.HttpMethodMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Method Matcher"
                },
                "methods": {
                    "type": "array",
                    "description": " List of methods values to match against.\n\nExample: - \"['GET', 'POST', 'DELETE']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "methods",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "Method List",
                    "x-ves-example": "['GET', 'POST', 'DELETE']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyHttpQueryParameterName": {
            "type": "object",
            "description": "x-displayName: \"Key name of the query parameter\"\nSpecifies the key name of the query parameter",
            "title": "HttpQueryParameterName",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "x-displayName: \"Query Parameter Name\"\nx-example: \"sourceid\"\nx-required\nA case-sensitive HTTP query parameter name.",
                    "title": "key"
                }
            }
        },
        "policyIPThreatCategory": {
            "type": "string",
            "description": "The IP threat categories to use when a policy based IP threat category is configured.\n\n - SPAM_SOURCES: SPAM_SOURCES\n\n - WINDOWS_EXPLOITS: WINDOWS_EXPLOITS\n\n - WEB_ATTACKS: WEB_ATTACKS\n\n - BOTNETS: BOTNETS\n\n - SCANNERS: SCANNERS\n\n - REPUTATION: REPUTATION\n\n - PHISHING: PHISHING\n\n - PROXY: PROXY\n\n - MOBILE_THREATS: MOBILE_THREATS\n\n - TOR_PROXY: TOR_PROXY\n\n - DENIAL_OF_SERVICE: DENIAL_OF_SERVICE\n\n - NETWORK: NETWORK\n",
            "title": "IP Threat Category",
            "enum": [
                "SPAM_SOURCES",
                "WINDOWS_EXPLOITS",
                "WEB_ATTACKS",
                "BOTNETS",
                "SCANNERS",
                "REPUTATION",
                "PHISHING",
                "PROXY",
                "MOBILE_THREATS",
                "TOR_PROXY",
                "DENIAL_OF_SERVICE",
                "NETWORK"
            ],
            "default": "SPAM_SOURCES",
            "x-displayname": "IP Threat Category",
            "x-ves-proto-enum": "ves.io.schema.policy.IPThreatCategory"
        },
        "policyIpMatcherType": {
            "type": "object",
            "description": "Match any ip prefix contained in the list of ip_prefix_sets.\nThe result of the match is inverted if invert_matcher is true.",
            "title": "ip matcher type",
            "x-displayname": "IP Prefix Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.IpMatcherType",
            "properties": {
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert IP Matcher"
                },
                "prefix_sets": {
                    "type": "array",
                    "description": " A list of references to ip_prefix_set objects.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 4\n",
                    "title": "prefix_sets",
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/ioschemaObjectRefType"
                    },
                    "x-displayname": "IP Prefix Sets",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "4"
                    }
                }
            }
        },
        "policyJA4TlsFingerprintMatcherType": {
            "type": "object",
            "description": "x-displayName: \"JA4 TLS Fingerprint Matcher\"\nJA4 TLS fingerprints to be matched",
            "title": "JA4TlsFingerprintMatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": "x-displayName: \"Exact Values\"\nA list of exact JA4 TLS fingerprint to match the input JA4 TLS fingerprint against",
                    "title": "exact values",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "policyJWTClaimMatcherType": {
            "type": "object",
            "description": "A JWT claim matcher specifies the name of a single JWT claim and the criteria for the input request to match it.\nThe input has a list of actual values for each JWT claim name in the JWT payload.\nA JWT claim matcher can check for one of the following:\n* Presence or absence of the JWT Claim in the input\n* At least one of the values for the JWT Claim in the input satisfies the MatcherType item",
            "title": "JWTClaimMatcherType",
            "x-displayname": "JWT Claim Matcher",
            "x-ves-displayorder": "1,2,6",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.JWTClaimMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the JWT Claim is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the JWT Claim is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the JWT Claim. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " JWT claim name.\n\nExample: - \"user_id\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "JWT Claim Name",
                    "x-ves-example": "user_id",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyJwtTokenAuthOptions": {
            "type": "object",
            "description": "x-displayName: \"JWT Token Authentication\"\nJWT token Authentication",
            "title": "JwtTokenAuthOptions",
            "properties": {
                "backup_key": {
                    "description": "x-displayName: \"Backup Key\"\nx-example: \"{!\u003c=,d_]b[UFX78T\"\nBackup JWT Key - If specified is also checked in addition to the primary secret key",
                    "title": "backup_key",
                    "$ref": "#/definitions/schemaSecretType"
                },
                "bearer_token": {
                    "description": "x-displayName: \"Bearer-Token\"\nToken is found in the Bearer-Token",
                    "title": "Bearer-Token",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "cookie": {
                    "description": "x-displayName: \"Cookie\"\nToken is found in the cookie",
                    "title": "Cookie",
                    "$ref": "#/definitions/policyHttpCookieName"
                },
                "header": {
                    "description": "x-displayName: \"Header\"\nToken is found in the header",
                    "title": "Header",
                    "$ref": "#/definitions/policyHttpHeaderName"
                },
                "query_param": {
                    "description": "x-displayName: \"Query-Param\"\nToken is found in the Query-Param",
                    "title": "Query-Param",
                    "$ref": "#/definitions/policyHttpQueryParameterName"
                },
                "secret_key": {
                    "description": "x-displayName: \"Secret Key\"\nx-required\nx-example: \"{!\u003c=,d_]b[UFX78T\"\nSecret Key for JWT",
                    "title": "secret_key",
                    "$ref": "#/definitions/schemaSecretType"
                }
            }
        },
        "policyKnownTlsFingerprintClass": {
            "type": "string",
            "description": "Specifies known TLS fingerprint classes\n\n - TLS_FINGERPRINT_NONE: TLS_FINGERPRINT_NONE\n\nNo TLS fingerprint\n - ANY_MALICIOUS_FINGERPRINT: ANY_MALICIOUS_FINGERPRINT\n\nTLS fingerprints known to be associated with malicious clients\n - ADWARE: ADWARE\n\nTLS fingerprints known to be associated with adware\n - ADWIND: ADWIND\n\nTLS fingerprints known to be associated with adwind\n - DRIDEX: DRIDEX\n\nTLS fingerprints known to be associated with dridex\n - GOOTKIT: GOOTKIT\n\nTLS fingerprints known to be associated with gootkit\n - GOZI: GOZI\n\nTLS fingerprints known to be associated with gozi\n - JBIFROST: JBIFROST\n\nTLS fingerprints known to be associated with jbifrost\n - QUAKBOT: QUAKBOT\n\nTLS fingerprints known to be associated with quakbot\n - RANSOMWARE: RANSOMWARE\n\nTLS fingerprints known to be associated with ransomware\n - TROLDESH: TROLDESH\n\nTLS fingerprints known to be associated with troldesh\n - TOFSEE: TOFSEE\n\nTLS fingerprints known to be associated with tofsee\n - TORRENTLOCKER: TORRENTLOCKER\n\nTLS fingerprints known to be associated with torrentlocker\n - TRICKBOT: TRICKBOT\n\nTLS fingerprints known to be associated with trickbot",
            "title": "TLS known fingerprint class",
            "enum": [
                "TLS_FINGERPRINT_NONE",
                "ANY_MALICIOUS_FINGERPRINT",
                "ADWARE",
                "ADWIND",
                "DRIDEX",
                "GOOTKIT",
                "GOZI",
                "JBIFROST",
                "QUAKBOT",
                "RANSOMWARE",
                "TROLDESH",
                "TOFSEE",
                "TORRENTLOCKER",
                "TRICKBOT"
            ],
            "default": "TLS_FINGERPRINT_NONE",
            "x-displayname": "TLS known fingerprint class",
            "x-ves-proto-enum": "ves.io.schema.policy.KnownTlsFingerprintClass"
        },
        "policyMatcherType": {
            "type": "object",
            "description": "A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of exact values and a list of regular expressions.",
            "title": "MatcherType",
            "x-displayname": "Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.MatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact values to match the input against.\n\nExample: - \"['new york', 'london', 'sydney', 'tokyo', 'cairo']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 64,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['new york', 'london', 'sydney', 'tokyo', 'cairo']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input against.\n\nExample: - \"['^new .*$', 'san f.*', '.* del .*']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "regex values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^new .*$', 'san f.*', '.* del .*']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "transformers": {
                    "type": "array",
                    "description": " An ordered list of transformers (starting from index 0) to be applied to the path before matching.\n\nExample: - \"[BASE64_DECODE, LOWER_CASE]-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 9\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "transformers",
                    "maxItems": 9,
                    "items": {
                        "$ref": "#/definitions/policyTransformer"
                    },
                    "x-displayname": "Transformers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "9",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyMatcherTypeBasic": {
            "type": "object",
            "description": "A matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of exact values and a list of regular expressions.",
            "title": "MatcherTypeBasic",
            "x-displayname": "Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.MatcherTypeBasic",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact values to match the input against.\n\nExample: - \"['new york', 'london', 'sydney', 'tokyo', 'cairo']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 64,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['new york', 'london', 'sydney', 'tokyo', 'cairo']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input against.\n\nExample: - \"['^new .*$', 'san f.*', '.* del .*']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "regex values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^new .*$', 'san f.*', '.* del .*']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyPrefixMatchList": {
            "type": "object",
            "description": "List of IP Prefix strings to match against.",
            "title": "IP Prefix Match List",
            "x-displayname": "IP Prefix Match List",
            "x-ves-proto-message": "ves.io.schema.policy.PrefixMatchList",
            "properties": {
                "invert_match": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Match Result"
                },
                "ip_prefixes": {
                    "type": "array",
                    "description": " List of IPv4 prefix strings.\n\nExample: - \"192.168.20.0/24\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv4_prefix: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ip prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Prefix List",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "ipv6_prefixes": {
                    "type": "array",
                    "description": " List of IPv6 prefix strings.\n\nExample: - \"fd48:fa09:d9d4::/48\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv6_prefix: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ipv6 prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Prefix List",
                    "x-ves-example": "fd48:fa09:d9d4::/48",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv6_prefix": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyRequestMatcher": {
            "type": "object",
            "description": "Request conditions for matching a rule",
            "title": "Request Matcher",
            "x-displayname": "Request Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.RequestMatcher",
            "properties": {
                "cookie_matchers": {
                    "type": "array",
                    "description": " A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances\n of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.\n Note that all specified cookie matcher predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "cookie matchers",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyCookieMatcherType"
                    },
                    "x-displayname": "Cookie Matchers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "headers": {
                    "type": "array",
                    "description": " A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType\n instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.\n Note that all specified header predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "headers",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemapolicyHeaderMatcherType"
                    },
                    "x-displayname": "HTTP Headers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "jwt_claims": {
                    "type": "array",
                    "description": " A list of predicates for various JWT claims that need to match. The criteria for matching each JWT claim are described in individual JWTClaimMatcherType\n instances. The actual JWT claims values are extracted from the JWT payload as a list of strings.\n Note that all specified JWT claim predicates must evaluate to true.\n Note that this feature only works on LBs with JWT Validation feature enabled.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "JWT claims",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyJWTClaimMatcherType"
                    },
                    "x-displayname": "JWT Claims",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "query_params": {
                    "type": "array",
                    "description": " A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances\n of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.\n Note that all specified query parameter predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "query params",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemapolicyQueryParameterMatcherType"
                    },
                    "x-displayname": "HTTP Query Parameters",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                }
            }
        },
        "policyShapeBotBlockMitigationActionType": {
            "type": "object",
            "description": "Block request and respond with custom content.",
            "title": "ShapeBotBlockMitigationActionType",
            "x-displayname": "Block bot mitigation",
            "x-ves-proto-message": "ves.io.schema.policy.ShapeBotBlockMitigationActionType",
            "properties": {
                "body": {
                    "type": "string",
                    "description": " Custom body message is of type uri_ref. Currently supported URL schemes is string:///.\n For string:/// scheme, message needs to be encoded in Base64 format.\n You can specify this message as base64 encoded plain text message e.g. \"Your request was blocked\"\n or it can be HTML paragraph or a body string encoded as base64 string\n E.g. \"\u003cp\u003e Your request was blocked \u003c/p\u003e\". Base64 encoded string for this html is \"LzxwPiBZb3VyIHJlcXVlc3Qgd2FzIGJsb2NrZWQgPC9wPg==\"\n\nExample: - \"string://LzxwPiBZb3VyIHJlcXVlc3Qgd2FzIGJsb2NrZWQgPC9wPg==\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 4096\n  ves.io.schema.rules.string.uri_ref: true\n",
                    "title": "body",
                    "maxLength": 4096,
                    "x-displayname": "Body",
                    "x-ves-example": "string://LzxwPiBZb3VyIHJlcXVlc3Qgd2FzIGJsb2NrZWQgPC9wPg==",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "4096",
                        "ves.io.schema.rules.string.uri_ref": "true"
                    }
                },
                "status": {
                    "description": " HTTP Status code to respond with\n\nValidation Rules:\n  ves.io.schema.rules.enum.defined_only: true\n  ves.io.schema.rules.enum.not_in: [0]\n",
                    "title": "Status",
                    "$ref": "#/definitions/schemaHttpStatusCode",
                    "x-displayname": "Status",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.defined_only": "true",
                        "ves.io.schema.rules.enum.not_in": "[0]"
                    }
                }
            }
        },
        "policyShapeBotFlagMitigationActionChoiceType": {
            "type": "object",
            "description": "Flag mitigation action.",
            "title": "ShapeBotFlagMitigationActionChoiceType",
            "x-displayname": "Select Flag Bot Mitigation Action",
            "x-ves-oneof-field-send_headers_choice": "[\"append_headers\",\"no_headers\"]",
            "x-ves-proto-message": "ves.io.schema.policy.ShapeBotFlagMitigationActionChoiceType",
            "properties": {
                "append_headers": {
                    "description": "Exclusive with [no_headers]\n Append mitigation headers.",
                    "title": "append_headers",
                    "$ref": "#/definitions/policyShapeBotFlagMitigationActionType",
                    "x-displayname": "Append Headers"
                },
                "no_headers": {
                    "description": "Exclusive with [append_headers]\n No mitigation headers.",
                    "title": "no_headers",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No Headers"
                }
            }
        },
        "policyShapeBotFlagMitigationActionType": {
            "type": "object",
            "description": "Append flag mitigation headers to forwarded request.",
            "title": "ShapeBotFlagMitigationActionType",
            "x-displayname": "Append Flag Mitigation Headers",
            "x-ves-proto-message": "ves.io.schema.policy.ShapeBotFlagMitigationActionType",
            "properties": {
                "auto_type_header_name": {
                    "type": "string",
                    "description": " A case-insensitive HTTP header name.\n\nExample: - \"Bot-Automation-Type\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_header_field: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "auto_type_header_name",
                    "maxLength": 256,
                    "x-displayname": "Automation Type Header Name",
                    "x-ves-example": "Bot-Automation-Type",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_header_field": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                },
                "inference_header_name": {
                    "type": "string",
                    "description": " A case-insensitive HTTP header name.\n\nExample: - \"Bot-Inference\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_header_field: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "inference_header_name",
                    "maxLength": 256,
                    "x-displayname": "Inference Header Name",
                    "x-ves-example": "Bot-Inference",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_header_field": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "policyShapeBotMitigationAction": {
            "type": "object",
            "description": "Modify Bot Defense behavior for a matching request.",
            "title": "ShapeBotMitigationAction",
            "x-displayname": "Bot Mitigation Action",
            "x-ves-oneof-field-action_type": "[\"block\",\"flag\",\"redirect\"]",
            "x-ves-proto-message": "ves.io.schema.policy.ShapeBotMitigationAction",
            "properties": {
                "block": {
                    "description": "Exclusive with [flag redirect]\n Block bot request and send response with custom content.",
                    "title": "Block",
                    "$ref": "#/definitions/policyShapeBotBlockMitigationActionType",
                    "x-displayname": "Block"
                },
                "flag": {
                    "description": "Exclusive with [block redirect]\n Flag the request while not taking any invasive actions.",
                    "title": "Flag",
                    "$ref": "#/definitions/policyShapeBotFlagMitigationActionChoiceType",
                    "x-displayname": "Flag"
                },
                "redirect": {
                    "description": "Exclusive with [block flag]\n Redirect bot request to a custom URI.",
                    "title": "Redirect",
                    "$ref": "#/definitions/policyShapeBotRedirectMitigationActionType",
                    "x-displayname": "Redirect"
                }
            }
        },
        "policyShapeBotRedirectMitigationActionType": {
            "type": "object",
            "description": "Redirect request to a custom URI.",
            "title": "ShapeBotRedirectMitigationTypeAction",
            "x-displayname": "Redirect bot mitigation",
            "x-ves-proto-message": "ves.io.schema.policy.ShapeBotRedirectMitigationActionType",
            "properties": {
                "uri": {
                    "type": "string",
                    "description": " URI location for redirect may be relative or absolute.\n\nExample: - \"Enter URI\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.url_or_uri_ref: true\n",
                    "title": "URI",
                    "x-displayname": "URI",
                    "x-ves-example": "Enter URI",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.url_or_uri_ref": "true"
                    }
                }
            }
        },
        "policySimpleDataGuardRule": {
            "type": "object",
            "description": "Simple Data Guard rule specifies a simple set of match conditions to enable data guard protection",
            "title": "SimpleDataGuardRule",
            "x-displayname": "Data Guard Rule Specification (Data Leakage Protection)",
            "x-ves-displayorder": "10,14,3,6",
            "x-ves-oneof-field-action_choice": "[\"apply_data_guard\",\"skip_data_guard\"]",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"exact_value\",\"suffix_value\"]",
            "x-ves-proto-message": "ves.io.schema.policy.SimpleDataGuardRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [exact_value suffix_value]\n Enable Data Guard for any domain",
                    "title": "Any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "apply_data_guard": {
                    "description": "Exclusive with [skip_data_guard]\n",
                    "title": "apply_data_guard",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Apply"
                },
                "exact_value": {
                    "type": "string",
                    "description": "Exclusive with [any_domain suffix_value]\n Exact domain name\n\nExample: - \"abc.zyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "exact value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Exact Value",
                    "x-ves-example": "abc.zyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "description": " URI path matcher.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Path",
                    "$ref": "#/definitions/ioschemaPathMatcherType",
                    "x-displayname": "Path",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "skip_data_guard": {
                    "description": "Exclusive with [apply_data_guard]\n",
                    "title": "skip_data_guard",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip"
                },
                "suffix_value": {
                    "type": "string",
                    "description": "Exclusive with [any_domain exact_value]\n Suffix of domain name e.g \"xyz.com\" will match \"*.xyz.com\" and \"xyz.com\"\n\nExample: - \"xyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "suffix value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Suffix Value",
                    "x-ves-example": "xyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                }
            }
        },
        "policySimpleWafExclusionRule": {
            "type": "object",
            "description": "Simple WAF exclusion rule specifies a simple set of match conditions to be matched to skip a list of WAF detections",
            "title": "SimpleWafExclusionRule",
            "x-displayname": "WAF Exclusion Rule",
            "x-ves-displayorder": "10,3,16,7,14,9",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"exact_value\",\"suffix_value\"]",
            "x-ves-oneof-field-path_choice": "[\"any_path\",\"path_prefix\",\"path_regex\"]",
            "x-ves-oneof-field-waf_advanced_configuration": "[\"app_firewall_detection_control\",\"waf_skip_processing\"]",
            "x-ves-proto-message": "ves.io.schema.policy.SimpleWafExclusionRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [exact_value suffix_value]\n Apply this WAF exclusion rule for any domain",
                    "title": "Any domain",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "any_path": {
                    "description": "Exclusive with [path_prefix path_regex]\n Match all paths",
                    "title": "Any path",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Any Path"
                },
                "app_firewall_detection_control": {
                    "description": "Exclusive with [waf_skip_processing]\n Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.\n\nValidation Rules:\n  ves.io.schema.rules.message.required_one_nonzero_field: true\n",
                    "title": "App Firewall Detection control",
                    "$ref": "#/definitions/policyAppFirewallDetectionControl",
                    "x-displayname": "App Firewall Detection Control",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required_one_nonzero_field": "true"
                    }
                },
                "exact_value": {
                    "type": "string",
                    "description": "Exclusive with [any_domain suffix_value]\n Exact domain name\n\nExample: - \"abc.zyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "exact value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Exact Value",
                    "x-ves-example": "abc.zyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": " The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\n the configuration but is not applied anymore.\n\nExample: - \"2019-12-31:44:34.171543432Z\"-",
                    "title": "expiration timestamp",
                    "format": "date-time",
                    "x-displayname": "Expiration Timestamp",
                    "x-ves-example": "2019-12-31:44:34.171543432Z"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "methods": {
                    "type": "array",
                    "description": " methods to be matched\n\nExample: - \"GET\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Methods",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "Methods",
                    "x-ves-example": "GET",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "path_prefix": {
                    "type": "string",
                    "description": "Exclusive with [any_path path_regex]\n Path prefix to match (e.g. the value / will match on all paths)\n\nExample: - \"/register/\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "prefix",
                    "maxLength": 256,
                    "x-displayname": "Prefix",
                    "x-ves-example": "/register/",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "path_regex": {
                    "type": "string",
                    "description": "Exclusive with [any_path path_prefix]\n Define the regex for the path. For example, the regex ^/.*$ will match on all paths\n\nExample: - \"/blog_id/.*\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "Path Regex",
                    "maxLength": 256,
                    "x-displayname": "Path Regex",
                    "x-ves-example": "/blog_id/.*",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                },
                "suffix_value": {
                    "type": "string",
                    "description": "Exclusive with [any_domain exact_value]\n Suffix of domain name e.g \"xyz.com\" will match \"*.xyz.com\" and \"xyz.com\"\n\nExample: - \"xyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "suffix value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Suffix Value",
                    "x-ves-example": "xyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                },
                "waf_skip_processing": {
                    "description": "Exclusive with [app_firewall_detection_control]\n Skip all App Firewall processing for this request",
                    "title": "Skip App Firewall Processing",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Skip App Firewall Processing"
                }
            }
        },
        "policyTlsFingerprintMatcherType": {
            "type": "object",
            "description": "A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known\nclasses of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input\nfingerprint is not one of the excluded values.",
            "title": "TlsFingerprintMatcherType",
            "x-displayname": "TLS Fingerprint Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.TlsFingerprintMatcherType",
            "properties": {
                "classes": {
                    "type": "array",
                    "description": " A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ADWARE', 'TRICKBOT']-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "classes",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyKnownTlsFingerprintClass"
                    },
                    "x-displayname": "TLS fingerprint classes",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 32\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "32",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "excluded_values": {
                    "type": "array",
                    "description": " A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one\n or more known TLS fingerprint classes in the enclosing matcher.\n\nExample: - \"['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 32\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "excluded values",
                    "maxItems": 32,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Excluded Values",
                    "x-ves-example": "['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "32",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyTransformer": {
            "type": "string",
            "description": "Transformers to be applied on the part of the request before matching.\n\n - TRANSFORMER_NONE: transformer none\n\nNo transformers enabled\n - LOWER_CASE: lower case\n\nConvert string to lower case\n - UPPER_CASE: upper case\n\nConvert string to upper case\n - BASE64_DECODE: base64 decode\n\nDecode string assuming base64 encoding\n - NORMALIZE_PATH: normalize path\n\nNormalize URL path so that /a/b/../c will be transformed to /a/c\n - REMOVE_WHITESPACE: remove whitespace\n\nRemove whitespaces\n - URL_DECODE: URL decode\n\nDecode string assuming URL encoding as per rfc1738\n - TRIM_LEFT: trim left\n\nRemove whitespace from the left side of the input string\n - TRIM_RIGHT: trim right\n\nRemove whitespace from the right side of the input string\n - TRIM: trim\n\nRemove whitespace from the both sides of the input string",
            "title": "Transformer",
            "enum": [
                "LOWER_CASE",
                "UPPER_CASE",
                "BASE64_DECODE",
                "NORMALIZE_PATH",
                "REMOVE_WHITESPACE",
                "URL_DECODE",
                "TRIM_LEFT",
                "TRIM_RIGHT",
                "TRIM"
            ],
            "default": "TRANSFORMER_NONE",
            "x-displayname": "Transformer",
            "x-ves-proto-enum": "ves.io.schema.policy.Transformer"
        },
        "protobufAny": {
            "type": "object",
            "description": "-Any- contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an -Any- value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field -@type- which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n-value- which holds the custom JSON in addition to the -@type-\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
            "properties": {
                "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n-path/google.protobuf.Duration-). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme -http-, -https-, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, -https- is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than -http-, -https- (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                }
            }
        },
        "rate_limiterRateLimitPeriodUnit": {
            "type": "string",
            "description": "Unit for the period per which the rate limit is applied.\n\n - SECOND: Second\n\nRate limit period is 1 second\n - MINUTE: Minute\n\nRate limit period is 1 minute\n - HOUR: Hour\n\nRate limit period is 1 hour\n - DAY: Day\n\nRate limit period is 1 day",
            "title": "RateLimitPeriodUnit",
            "enum": [
                "SECOND",
                "MINUTE",
                "HOUR"
            ],
            "default": "SECOND",
            "x-displayname": "Rate Limit Period Unit",
            "x-ves-proto-enum": "ves.io.schema.rate_limiter.RateLimitPeriodUnit"
        },
        "rate_limiterRateLimitValue": {
            "type": "object",
            "description": "A tuple consisting of a rate limit period unit and the total number of allowed requests for that period.",
            "title": "RateLimitValue",
            "x-displayname": "Rate Limit Value",
            "x-ves-displayorder": "2,1,3",
            "x-ves-proto-message": "ves.io.schema.rate_limiter.RateLimitValue",
            "properties": {
                "burst_multiplier": {
                    "type": "integer",
                    "description": " The maximum burst of requests to accommodate, expressed as a multiple of the rate.\n\nExample: - \"1\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gt: 0\n  ves.io.schema.rules.uint32.lte: 100\n",
                    "title": "burst_multiplier",
                    "format": "int64",
                    "x-displayname": "Burst Multiplier",
                    "x-ves-example": "1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gt": "0",
                        "ves.io.schema.rules.uint32.lte": "100"
                    }
                },
                "total_number": {
                    "type": "integer",
                    "description": " The total number of allowed requests for 1 unit (e.g. SECOND/MINUTE/HOUR etc.) of the specified period.\n\nExample: - \"1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gt: 0\n  ves.io.schema.rules.uint32.lte: 8192\n",
                    "title": "total_number",
                    "format": "int64",
                    "x-displayname": "Number",
                    "x-ves-example": "1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gt": "0",
                        "ves.io.schema.rules.uint32.lte": "8192"
                    }
                },
                "unit": {
                    "description": " Unit for the period per which the rate limit is applied.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "unit",
                    "$ref": "#/definitions/rate_limiterRateLimitPeriodUnit",
                    "x-displayname": "Per Period",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "rate_limiter_policyPolicyList": {
            "type": "object",
            "description": "List of rate limiter policies to be applied.",
            "title": "Rate Limiter Policy List",
            "x-displayname": "Rate Limiter Policy List",
            "x-ves-proto-message": "ves.io.schema.views.rate_limiter_policy.PolicyList",
            "properties": {
                "policies": {
                    "type": "array",
                    "description": " Ordered list of rate limiter policies.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 64\n",
                    "title": "Rate Limiter Policies",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "Rate Limiter Policies",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "64"
                    }
                }
            }
        },
        "schemaAction": {
            "type": "object",
            "title": "action",
            "x-displayname": "Action",
            "x-ves-oneof-field-action_choice": "[\"block\",\"report\"]",
            "x-ves-proto-message": "ves.io.schema.Action",
            "properties": {
                "block": {
                    "description": "Exclusive with [report]\n Block the request and report the issue",
                    "title": "block",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Block"
                },
                "report": {
                    "description": "Exclusive with [block]\n Allow the request and report the issue",
                    "title": "report",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Report"
                }
            }
        },
        "schemaBlindfoldSecretInfoType": {
            "type": "object",
            "description": "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
            "title": "BlindfoldSecretInfoType",
            "x-displayname": "Blindfold Secret",
            "x-ves-displayorder": "3,1,2",
            "x-ves-proto-message": "ves.io.schema.BlindfoldSecretInfoType",
            "properties": {
                "decryption_provider": {
                    "type": "string",
                    "description": " Name of the Secret Management Access object that contains information about the backend Secret Management service.\n\nExample: - \"value\"-",
                    "title": "Decryption Provider",
                    "x-displayname": "Decryption Provider",
                    "x-ves-example": "value"
                },
                "location": {
                    "type": "string",
                    "description": " Location is the uri_ref. It could be in url format for string:///\n Or it could be a path if the store provider is an http/https location\n\nExample: - \"string:///U2VjcmV0SW5mb3JtYXRpb24=\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.uri_ref: true\n",
                    "title": "Location",
                    "x-displayname": "Location",
                    "x-ves-example": "string:///U2VjcmV0SW5mb3JtYXRpb24=",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.uri_ref": "true"
                    }
                },
                "store_provider": {
                    "type": "string",
                    "description": " Name of the Secret Management Access object that contains information about the store to get encrypted bytes\n This field needs to be provided only if the url scheme is not string:///\n\nExample: - \"value\"-",
                    "title": "Store Provider",
                    "x-displayname": "Store Provider",
                    "x-ves-example": "value"
                }
            }
        },
        "schemaBotDefenseFlowLabelAccountManagementChoiceType": {
            "type": "object",
            "description": "Bot Defense Flow Label Account Management Category",
            "title": "BotDefenseFlowLabelAccountManagementChoiceType",
            "x-displayname": "Bot Defense Flow Label Account Management Category",
            "x-ves-oneof-field-label_choice": "[\"create\",\"password_reset\"]",
            "x-ves-proto-message": "ves.io.schema.BotDefenseFlowLabelAccountManagementChoiceType",
            "properties": {
                "create": {
                    "description": "Exclusive with [password_reset]\n",
                    "title": "Create",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Account Creation"
                },
                "password_reset": {
                    "description": "Exclusive with [create]\n",
                    "title": "Password Reset",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Password Reset"
                }
            }
        },
        "schemaBotDefenseFlowLabelAuthenticationChoiceType": {
            "type": "object",
            "description": "Bot Defense Flow Label Authentication Category",
            "title": "BotDefenseFlowLabelCategoryChoiceType",
            "x-displayname": "Bot Defense Flow Label Authentication Category",
            "x-ves-oneof-field-label_choice": "[\"login\",\"login_mfa\",\"login_partner\",\"logout\",\"token_refresh\"]",
            "x-ves-proto-message": "ves.io.schema.BotDefenseFlowLabelAuthenticationChoiceType",
            "properties": {
                "login": {
                    "description": "Exclusive with [login_mfa login_partner logout token_refresh]\n",
                    "title": "Login",
                    "$ref": "#/definitions/schemaBotDefenseTransactionResult",
                    "x-displayname": "Login"
                },
                "login_mfa": {
                    "description": "Exclusive with [login login_partner logout token_refresh]\n",
                    "title": "LoginMFA",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Login MFA"
                },
                "login_partner": {
                    "description": "Exclusive with [login login_mfa logout token_refresh]\n",
                    "title": "login_partner",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Login for a Channel Partner"
                },
                "logout": {
                    "description": "Exclusive with [login login_mfa login_partner token_refresh]\n",
                    "title": "logout",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Logout"
                },
                "token_refresh": {
                    "description": "Exclusive with [login login_mfa login_partner logout]\n",
                    "title": "token_refresh",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Token Refresh"
                }
            }
        },
        "schemaBotDefenseFlowLabelCategoriesChoiceType": {
            "type": "object",
            "description": "Bot Defense Flow Label Category allows to associate traffic with selected category",
            "title": "BotDefenseFlowLabelCategoryChoiceType",
            "x-displayname": "Bot Defense Flow Label Category",
            "x-ves-oneof-field-flow_label_choice": "[\"account_management\",\"authentication\",\"financial_services\",\"flight\",\"profile_management\",\"search\",\"shopping_gift_cards\"]",
            "x-ves-proto-message": "ves.io.schema.BotDefenseFlowLabelCategoriesChoiceType",
            "properties": {
                "account_management": {
                    "description": "Exclusive with [authentication financial_services flight profile_management search shopping_gift_cards]\n",
                    "title": "Account Management",
                    "$ref": "#/definitions/schemaBotDefenseFlowLabelAccountManagementChoiceType",
                    "x-displayname": "Account Management"
                },
                "authentication": {
                    "description": "Exclusive with [account_management financial_services flight profile_management search shopping_gift_cards]\n",
                    "title": "Authentication",
                    "$ref": "#/definitions/schemaBotDefenseFlowLabelAuthenticationChoiceType",
                    "x-displayname": "Authentication"
                },
                "financial_services": {
                    "description": "Exclusive with [account_management authentication flight profile_management search shopping_gift_cards]\n",
                    "title": "Financial Services",
                    "$ref": "#/definitions/schemaBotDefenseFlowLabelFinancialServicesChoiceType",
                    "x-displayname": "Financial Services"
                },
                "flight": {
                    "description": "Exclusive with [account_management authentication financial_services profile_management search shopping_gift_cards]\n",
                    "title": "Flight",
                    "$ref": "#/definitions/schemaBotDefenseFlowLabelFlightChoiceType",
                    "x-displayname": "Flight"
                },
                "profile_management": {
                    "description": "Exclusive with [account_management authentication financial_services flight search shopping_gift_cards]\n",
                    "title": "Profile Management",
                    "$ref": "#/definitions/schemaBotDefenseFlowLabelProfileManagementChoiceType",
                    "x-displayname": "Profile Management"
                },
                "search": {
                    "description": "Exclusive with [account_management authentication financial_services flight profile_management shopping_gift_cards]\n",
                    "title": "Search",
                    "$ref": "#/definitions/schemaBotDefenseFlowLabelSearchChoiceType",
                    "x-displayname": "Search"
                },
                "shopping_gift_cards": {
                    "description": "Exclusive with [account_management authentication financial_services flight profile_management search]\n",
                    "title": "Shopping",
                    "$ref": "#/definitions/schemaBotDefenseFlowLabelShoppingGiftCardsChoiceType",
                    "x-displayname": "Shopping \u0026 Gift Cards"
                }
            }
        },
        "schemaBotDefenseFlowLabelFinancialServicesChoiceType": {
            "type": "object",
            "description": "Bot Defense Flow Label Financial Services Category",
            "title": "BotDefenseFlowLabelFinancialServicesChoiceType",
            "x-displayname": "Bot Defense Flow Label Financial Services Category",
            "x-ves-oneof-field-label_choice": "[\"apply\",\"money_transfer\"]",
            "x-ves-proto-message": "ves.io.schema.BotDefenseFlowLabelFinancialServicesChoiceType",
            "properties": {
                "apply": {
                    "description": "Exclusive with [money_transfer]\n",
                    "title": "apply",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Apply for a Financial Service Account (e.g., credit card, banking, retirement account)"
                },
                "money_transfer": {
                    "description": "Exclusive with [apply]\n",
                    "title": "money_transfer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Money Transfer"
                }
            }
        },
        "schemaBotDefenseFlowLabelFlightChoiceType": {
            "type": "object",
            "description": "Bot Defense Flow Label Flight Category",
            "title": "BotDefenseFlowLabelFlightChoiceType",
            "x-displayname": "Bot Defense Flow Label Flight Category",
            "x-ves-oneof-field-label_choice": "[\"checkin\"]",
            "x-ves-proto-message": "ves.io.schema.BotDefenseFlowLabelFlightChoiceType",
            "properties": {
                "checkin": {
                    "description": "Exclusive with []\n",
                    "title": "flight_search",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Check into Flight"
                }
            }
        },
        "schemaBotDefenseFlowLabelProfileManagementChoiceType": {
            "type": "object",
            "description": "Bot Defense Flow Label Profile Management Category",
            "title": "BotDefenseFlowLabelProfileManagementChoiceType",
            "x-displayname": "Bot Defense Flow Label Profile Management Category",
            "x-ves-oneof-field-label_choice": "[\"create\",\"update\",\"view\"]",
            "x-ves-proto-message": "ves.io.schema.BotDefenseFlowLabelProfileManagementChoiceType",
            "properties": {
                "create": {
                    "description": "Exclusive with [update view]\n",
                    "title": "Create",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Profile Creation"
                },
                "update": {
                    "description": "Exclusive with [create view]\n",
                    "title": "update",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Profile Update"
                },
                "view": {
                    "description": "Exclusive with [create update]\n",
                    "title": "view",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Profile View"
                }
            }
        },
        "schemaBotDefenseFlowLabelSearchChoiceType": {
            "type": "object",
            "description": "Bot Defense Flow Label Search Category",
            "title": "BotDefenseFlowLabelSearchChoiceType",
            "x-displayname": "Bot Defense Flow Label Search Category",
            "x-ves-oneof-field-label_choice": "[\"flight_search\",\"product_search\",\"reservation_search\",\"room_search\"]",
            "x-ves-proto-message": "ves.io.schema.BotDefenseFlowLabelSearchChoiceType",
            "properties": {
                "flight_search": {
                    "description": "Exclusive with [product_search reservation_search room_search]\n",
                    "title": "flight_search",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Flight Search"
                },
                "product_search": {
                    "description": "Exclusive with [flight_search reservation_search room_search]\n",
                    "title": "product_search",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Product Search"
                },
                "reservation_search": {
                    "description": "Exclusive with [flight_search product_search room_search]\n",
                    "title": "reservation_search",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Reservation Search (e.g., sporting events, concerts)"
                },
                "room_search": {
                    "description": "Exclusive with [flight_search product_search reservation_search]\n",
                    "title": "room_search",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Room Search"
                }
            }
        },
        "schemaBotDefenseFlowLabelShoppingGiftCardsChoiceType": {
            "type": "object",
            "description": "Bot Defense Flow Label Shopping \u0026 Gift Cards Category",
            "title": "BotDefenseFlowLabelShoppingGiftCardsChoiceType",
            "x-displayname": "Bot Defense Flow Label Shopping \u0026 Gift Cards Category",
            "x-ves-oneof-field-label_choice": "[\"gift_card_make_purchase_with_gift_card\",\"gift_card_validation\",\"shop_add_to_cart\",\"shop_checkout\",\"shop_choose_seat\",\"shop_enter_drawing_submission\",\"shop_make_payment\",\"shop_order\",\"shop_price_inquiry\",\"shop_promo_code_validation\",\"shop_purchase_gift_card\",\"shop_update_quantity\"]",
            "x-ves-proto-message": "ves.io.schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType",
            "properties": {
                "gift_card_make_purchase_with_gift_card": {
                    "description": "Exclusive with [gift_card_validation shop_add_to_cart shop_checkout shop_choose_seat shop_enter_drawing_submission shop_make_payment shop_order shop_price_inquiry shop_promo_code_validation shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "Purchase with Gift Card",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Purchase with Gift Card"
                },
                "gift_card_validation": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card shop_add_to_cart shop_checkout shop_choose_seat shop_enter_drawing_submission shop_make_payment shop_order shop_price_inquiry shop_promo_code_validation shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "Gift Card Validation",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Gift Card Validation"
                },
                "shop_add_to_cart": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_checkout shop_choose_seat shop_enter_drawing_submission shop_make_payment shop_order shop_price_inquiry shop_promo_code_validation shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "add_to_cart",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Add to Cart"
                },
                "shop_checkout": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_add_to_cart shop_choose_seat shop_enter_drawing_submission shop_make_payment shop_order shop_price_inquiry shop_promo_code_validation shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "checkout",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Checkout"
                },
                "shop_choose_seat": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_add_to_cart shop_checkout shop_enter_drawing_submission shop_make_payment shop_order shop_price_inquiry shop_promo_code_validation shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "Select Seat(s)",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Select Seat(s)"
                },
                "shop_enter_drawing_submission": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_add_to_cart shop_checkout shop_choose_seat shop_make_payment shop_order shop_price_inquiry shop_promo_code_validation shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "Enter Drawing Submission",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enter Drawing Submission"
                },
                "shop_make_payment": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_add_to_cart shop_checkout shop_choose_seat shop_enter_drawing_submission shop_order shop_price_inquiry shop_promo_code_validation shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "make_payment",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Payment / Billing"
                },
                "shop_order": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_add_to_cart shop_checkout shop_choose_seat shop_enter_drawing_submission shop_make_payment shop_price_inquiry shop_promo_code_validation shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "order",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Order Submit"
                },
                "shop_price_inquiry": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_add_to_cart shop_checkout shop_choose_seat shop_enter_drawing_submission shop_make_payment shop_order shop_promo_code_validation shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "price_inquiry",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Price Inquiry"
                },
                "shop_promo_code_validation": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_add_to_cart shop_checkout shop_choose_seat shop_enter_drawing_submission shop_make_payment shop_order shop_price_inquiry shop_purchase_gift_card shop_update_quantity]\n",
                    "title": "promo_code_validation",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Promo Code Validation"
                },
                "shop_purchase_gift_card": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_add_to_cart shop_checkout shop_choose_seat shop_enter_drawing_submission shop_make_payment shop_order shop_price_inquiry shop_promo_code_validation shop_update_quantity]\n",
                    "title": "shop_purchase_gift_card",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Purchase a Gift Card"
                },
                "shop_update_quantity": {
                    "description": "Exclusive with [gift_card_make_purchase_with_gift_card gift_card_validation shop_add_to_cart shop_checkout shop_choose_seat shop_enter_drawing_submission shop_make_payment shop_order shop_price_inquiry shop_promo_code_validation shop_purchase_gift_card]\n",
                    "title": "Update Quantity",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Update Quantity"
                }
            }
        },
        "schemaBotDefenseTransactionResult": {
            "type": "object",
            "description": "Bot Defense Transaction Result",
            "title": "BotDefenseTransactionResult",
            "x-displayname": "Bot Defense Transaction Result",
            "x-ves-oneof-field-transaction_result_choice": "[\"disable_transaction_result\",\"transaction_result\"]",
            "x-ves-proto-message": "ves.io.schema.BotDefenseTransactionResult",
            "properties": {
                "disable_transaction_result": {
                    "description": "Exclusive with [transaction_result]\n Disable collection of transaction result.",
                    "title": "Disable",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "transaction_result": {
                    "description": "Exclusive with [disable_transaction_result]\n Collect transaction result.",
                    "title": "Transaction result",
                    "$ref": "#/definitions/schemaBotDefenseTransactionResultType",
                    "x-displayname": "Transaction result"
                }
            }
        },
        "schemaBotDefenseTransactionResultCondition": {
            "type": "object",
            "description": "Bot Defense Transaction Result Condition",
            "title": "BotDefenseTransactionResultCondition",
            "x-displayname": "Bot Defense Transaction Result Condition",
            "x-ves-displayorder": "3,1,2",
            "x-ves-proto-message": "ves.io.schema.BotDefenseTransactionResultCondition",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " A case-insensitive HTTP header name.\n\nExample: - \"Accept-Encoding\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_header_field: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Header Name",
                    "x-ves-example": "Accept-Encoding",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_header_field": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input against.\n\nExample: - \"['^new .*$', 'san f.*', '.* del .*']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "regex values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^new .*$', 'san f.*', '.* del .*']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "status": {
                    "description": " HTTP Status code\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.enum.defined_only: true\n  ves.io.schema.rules.message.required: true\n",
                    "title": "HTTP Status code for response",
                    "$ref": "#/definitions/schemaHttpStatusCode",
                    "x-displayname": "HTTP Status code",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.defined_only": "true",
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "schemaBotDefenseTransactionResultType": {
            "type": "object",
            "description": "Bot Defense Transaction ResultType",
            "title": "BotDefenseTransactionResultType",
            "x-displayname": "Bot Defense Transaction Result Type",
            "x-ves-displayorder": "4,3",
            "x-ves-proto-message": "ves.io.schema.BotDefenseTransactionResultType",
            "properties": {
                "failure_conditions": {
                    "type": "array",
                    "description": " Failure Conditions\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 3\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Failure Conditions",
                    "maxItems": 3,
                    "items": {
                        "$ref": "#/definitions/schemaBotDefenseTransactionResultCondition"
                    },
                    "x-displayname": "Failure Conditions",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "3",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "success_conditions": {
                    "type": "array",
                    "description": " Success Conditions\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 3\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Success Conditions",
                    "maxItems": 3,
                    "items": {
                        "$ref": "#/definitions/schemaBotDefenseTransactionResultCondition"
                    },
                    "x-displayname": "Success Conditions",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "3",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemaBotHttpMethod": {
            "type": "string",
            "description": "Specifies the HTTP method used to access a resource.\n\nAny HTTP Method\nGET method for XMLHttpRequest or Fetch\nPOST method\nPUT method\nPATCH method\nDELETE method\nGET method for HTML document",
            "title": "BotHttpMethod",
            "enum": [
                "METHOD_ANY",
                "METHOD_GET",
                "METHOD_POST",
                "METHOD_PUT",
                "METHOD_PATCH",
                "METHOD_DELETE",
                "METHOD_GET_DOCUMENT"
            ],
            "default": "METHOD_ANY",
            "x-displayname": "HTTP Method",
            "x-ves-proto-enum": "ves.io.schema.BotHttpMethod"
        },
        "schemaClearSecretInfoType": {
            "type": "object",
            "description": "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
            "title": "ClearSecretInfoType",
            "x-displayname": "In-Clear Secret",
            "x-ves-displayorder": "2,1",
            "x-ves-proto-message": "ves.io.schema.ClearSecretInfoType",
            "properties": {
                "provider": {
                    "type": "string",
                    "description": " Name of the Secret Management Access object that contains information about the store to get encrypted bytes\n This field needs to be provided only if the url scheme is not string:///\n\nExample: - \"box-provider\"-",
                    "title": "Provider",
                    "x-displayname": "Provider",
                    "x-ves-example": "box-provider"
                },
                "url": {
                    "type": "string",
                    "description": " URL of the secret. Currently supported URL schemes is string:///.\n For string:/// scheme, Secret needs to be encoded Base64 format.\n When asked for this secret, caller will get Secret bytes after Base64 decoding.\n\nExample: - \"string:///U2VjcmV0SW5mb3JtYXRpb24=\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 131072\n  ves.io.schema.rules.string.uri_ref: true\n",
                    "title": "URL",
                    "maxLength": 131072,
                    "x-displayname": "URL",
                    "x-ves-example": "string:///U2VjcmV0SW5mb3JtYXRpb24=",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "131072",
                        "ves.io.schema.rules.string.uri_ref": "true"
                    }
                }
            }
        },
        "schemaConditionType": {
            "type": "object",
            "description": "Conditions are used in the object status to describe the current state of the\nobject, e.g. Ready, Succeeded, etc.",
            "title": "ConditionType",
            "x-displayname": "Status Condition",
            "x-ves-proto-message": "ves.io.schema.ConditionType",
            "properties": {
                "hostname": {
                    "type": "string",
                    "description": " Hostname of the instance of the site that sent the status",
                    "title": "hostname",
                    "x-displayname": "Hostname"
                },
                "last_update_time": {
                    "type": "string",
                    "description": " Last time the condition was updated",
                    "title": "last_update_time",
                    "format": "date-time",
                    "x-displayname": "Last Updated"
                },
                "reason": {
                    "type": "string",
                    "description": " x-reason: \"Insufficient memory in data plane\"\n A human readable string explaining the reason for reaching this condition\n\nExample: - \"value\"-",
                    "title": "reason",
                    "x-displayname": "Reason",
                    "x-ves-example": "value"
                },
                "service_name": {
                    "type": "string",
                    "description": " Name of the service that sent the status",
                    "title": "service name",
                    "x-displayname": "Service Name"
                },
                "status": {
                    "type": "string",
                    "description": " Status of the condition\n \"Success\" Validtion has succeded. Requested operation was successful.\n \"Failed\"  Validation has failed.\n \"Incomplete\" Validation of configuration has failed due to missing configuration.\n \"Installed\" Validation has passed and configuration has been installed in data path or K8s\n \"Down\" Configuration is operationally down. e.g. down interface\n \"Disabled\" Configuration is administratively disabled i.e. ObjectMetaType.Disable = true.\n \"NotApplicable\" Configuration is not applicable e.g. tenant service_policy_set(s) in system namespace are not applicable on REs\n\nExample: - \"Failed\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.in: [\\\"Success\\\",\\\"Failed\\\",\\\"Incomplete\\\",\\\"Installed\\\",\\\"Down\\\",\\\"Disabled\\\",\\\"NotApplicable\\\"]\n",
                    "title": "status",
                    "x-displayname": "Status",
                    "x-ves-example": "Failed",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.in": "[\\\"Success\\\",\\\"Failed\\\",\\\"Incomplete\\\",\\\"Installed\\\",\\\"Down\\\",\\\"Disabled\\\",\\\"NotApplicable\\\"]"
                    }
                },
                "type": {
                    "type": "string",
                    "description": " Type of the condition\n \"Validation\" represents validation user given configuration object\n \"Operational\" represents operational status of a given configuration object\n\nExample: - \"Operational\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.in: [\\\"Validation\\\",\\\"Operational\\\"]\n",
                    "title": "type",
                    "x-displayname": "Type",
                    "x-ves-example": "Operational",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.in": "[\\\"Validation\\\",\\\"Operational\\\"]"
                    }
                }
            }
        },
        "schemaCookieManipulationOptionType": {
            "type": "object",
            "description": "Set Cookie protection attributes.",
            "title": "CookieManipulationOptionType",
            "x-displayname": "Cookie Protection",
            "x-ves-oneof-field-cookie_tampering": "[\"disable_tampering_protection\",\"enable_tampering_protection\"]",
            "x-ves-oneof-field-httponly": "[\"add_httponly\",\"ignore_httponly\"]",
            "x-ves-oneof-field-max_age": "[\"ignore_max_age\",\"max_age_value\"]",
            "x-ves-oneof-field-samesite": "[\"ignore_samesite\",\"samesite_lax\",\"samesite_none\",\"samesite_strict\"]",
            "x-ves-oneof-field-secure": "[\"add_secure\",\"ignore_secure\"]",
            "x-ves-proto-message": "ves.io.schema.CookieManipulationOptionType",
            "properties": {
                "add_httponly": {
                    "description": "Exclusive with [ignore_httponly]\n",
                    "title": "add_httponly",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Add"
                },
                "add_secure": {
                    "description": "Exclusive with [ignore_secure]\n",
                    "title": "add_secure",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Add"
                },
                "disable_tampering_protection": {
                    "description": "Exclusive with [enable_tampering_protection]\n",
                    "title": "disable",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "enable_tampering_protection": {
                    "description": "Exclusive with [disable_tampering_protection]\n",
                    "title": "enable",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable"
                },
                "ignore_httponly": {
                    "description": "Exclusive with [add_httponly]\n",
                    "title": "ignore_httponly",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Ignore"
                },
                "ignore_max_age": {
                    "description": "Exclusive with [max_age_value]\n Ignore max age attribute",
                    "title": "ignore_max_age",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Ignore Max Age"
                },
                "ignore_samesite": {
                    "description": "Exclusive with [samesite_lax samesite_none samesite_strict]\n Ignore Samesite attribute",
                    "title": "ignore_samesite",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Ignore"
                },
                "ignore_secure": {
                    "description": "Exclusive with [add_secure]\n",
                    "title": "ignore_secure",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Ignore"
                },
                "max_age_value": {
                    "type": "integer",
                    "description": "Exclusive with [ignore_max_age]\n Add max age attribute\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 34560000\n",
                    "title": "add_max_age",
                    "format": "int32",
                    "x-displayname": "Add Max Age",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "34560000"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " Name of the Cookie\n\nExample: - \"value\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.cookie_name: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Cookie Name",
                    "x-ves-example": "value",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.cookie_name": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "samesite_lax": {
                    "description": "Exclusive with [ignore_samesite samesite_none samesite_strict]\n Add Samesite attribute with Lax. Means that the cookie is not sent on cross-site requests",
                    "title": "lax",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Lax"
                },
                "samesite_none": {
                    "description": "Exclusive with [ignore_samesite samesite_lax samesite_strict]\n Add Samesite attribute with None. Means that the browser sends the cookie with both cross-site and same-site requests",
                    "title": "none",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "None"
                },
                "samesite_strict": {
                    "description": "Exclusive with [ignore_samesite samesite_lax samesite_none]\n Add Samesite attribute with Strict. Means that the browser sends the cookie only for same-site requests",
                    "title": "strict",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Strict"
                }
            }
        },
        "schemaCorsPolicy": {
            "type": "object",
            "description": "Cross-Origin Resource Sharing requests configuration specified at Virtual-host or\nRoute level. Route level configuration takes precedence.\n\nAn example of an Cross origin HTTP request\n    GET /resources/public-data/ HTTP/1.1\n    Host: bar.other\n    User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n    Accept-Language: en-us,en;q=0.5\n    Accept-Encoding: gzip,deflate\n    Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\n    Connection: keep-alive\n    Referrer: http://foo.example/examples/access-control/simpleXSInvocation.html\n    Origin: http://foo.example\n\n\n    HTTP/1.1 200 OK\n    Date: Mon, 01 Dec 2008 00:23:53 GMT\n    Server: Apache/2.0.61\n    Access-Control-Allow-Origin: *\n    Keep-Alive: timeout=2, max=100\n    Connection: Keep-Alive\n    Transfer-Encoding: chunked\n    Content-Type: application/xml\n\nAn example for cross origin HTTP OPTIONS request with Access-Control-Request-* header\n\n    OPTIONS /resources/post-here/ HTTP/1.1\n    Host: bar.other\n    User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n    Accept-Language: en-us,en;q=0.5\n    Accept-Encoding: gzip,deflate\n    Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\n    Connection: keep-alive\n    Origin: http://foo.example\n    Access-Control-Request-Method: POST\n    Access-Control-Request-Headers: X-PINGOTHER, Content-Type\n\n\n    HTTP/1.1 204 No Content\n    Date: Mon, 01 Dec 2008 01:15:39 GMT\n    Server: Apache/2.0.61 (Unix)\n    Access-Control-Allow-Origin: http://foo.example\n    Access-Control-Allow-Methods: POST, GET, OPTIONS\n    Access-Control-Allow-Headers: X-PINGOTHER, Content-Type\n    Access-Control-Max-Age: 86400\n    Vary: Accept-Encoding, Origin\n    Keep-Alive: timeout=2, max=100\n    Connection: Keep-Alive",
            "title": "CorsPolicy",
            "x-displayname": "CORS Policy",
            "x-ves-displayorder": "2,3,4,5,6,9,8,1",
            "x-ves-proto-message": "ves.io.schema.CorsPolicy",
            "properties": {
                "allow_credentials": {
                    "type": "boolean",
                    "description": " Specifies whether the resource allows credentials",
                    "title": "allow_credentials",
                    "format": "boolean",
                    "x-displayname": "Allow Credentials"
                },
                "allow_headers": {
                    "type": "string",
                    "description": " Specifies the content for the access-control-allow-headers header\n\nExample: - \"value\"-",
                    "title": "allow_headers",
                    "x-displayname": "Allow Headers",
                    "x-ves-example": "value"
                },
                "allow_methods": {
                    "type": "string",
                    "description": " Specifies the content for the access-control-allow-methods header\n\nExample: - \"GET\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_valid_methods: true\n",
                    "title": "allow_methods",
                    "x-displayname": "Allow Methods",
                    "x-ves-example": "GET",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_valid_methods": "true"
                    }
                },
                "allow_origin": {
                    "type": "array",
                    "description": " Specifies the origins that will be allowed to do CORS requests.\n An origin is allowed if either allow_origin or allow_origin_regex match\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_len: 256\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "allow_origin",
                    "maxItems": 128,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 256
                    },
                    "x-displayname": "Allow Origin",
                    "x-ves-example": "value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_len": "256",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "allow_origin_regex": {
                    "type": "array",
                    "description": " Specifies regex patterns that match allowed origins.\n An origin is allowed if either allow_origin or allow_origin_regex match\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.min_bytes: 1\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "allow_origin_regex",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 256
                    },
                    "x-displayname": "Allow Origin Regex",
                    "x-ves-example": "value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.min_bytes": "1",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": " Disable the CorsPolicy for a particular route. This is useful when\n virtual-host has CorsPolicy, but we need to disable it on a specific route.\n The value of this field is ignored for virtual-host",
                    "title": "disabled",
                    "format": "boolean",
                    "x-displayname": "Disabled"
                },
                "expose_headers": {
                    "type": "string",
                    "description": " Specifies the content for the access-control-expose-headers header\n\nExample: - \"value\"-",
                    "title": "expose_headers",
                    "x-displayname": "Expose Headers",
                    "x-ves-example": "value"
                },
                "maximum_age": {
                    "type": "integer",
                    "description": " Specifies the content for the access-control-max-age header in seconds.\n This indicates the maximum number of seconds the results can be cached\n A value of -1 will disable caching.\n Maximum permitted value is 86400 seconds (24 hours)\n\nExample: - \"-1\"-\n\nValidation Rules:\n  ves.io.schema.rules.int32.gte: -1\n  ves.io.schema.rules.int32.lte: 86400\n",
                    "title": "maximum_age",
                    "format": "int32",
                    "x-displayname": "Maximum Age",
                    "x-ves-example": "-1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.int32.gte": "-1",
                        "ves.io.schema.rules.int32.lte": "86400"
                    }
                }
            }
        },
        "schemaCsrfPolicy": {
            "type": "object",
            "description": "To mitigate CSRF attack , the policy checks where a request is coming from to determine if the request's origin is the same as its detination.The policy relies on two pieces of information used in determining if a request originated from the same host.\n\n1. The origin that caused the user agent to issue the request (source origin).\n2. The origin that the request is going to (target origin).\nWhen the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being if the source-origin has been added to they policy as valid.\nBecause CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).",
            "title": "CsrfPolicy",
            "x-displayname": "CSRF Policy",
            "x-ves-oneof-field-allowed_domains": "[\"all_load_balancer_domains\",\"custom_domain_list\",\"disabled\"]",
            "x-ves-proto-message": "ves.io.schema.CsrfPolicy",
            "properties": {
                "all_load_balancer_domains": {
                    "description": "Exclusive with [custom_domain_list disabled]\n Add All load balancer domains to source origin (allow) list.",
                    "title": "all_load_balancer_domains",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "All HTTP Loadbalancer Domains"
                },
                "custom_domain_list": {
                    "description": "Exclusive with [all_load_balancer_domains disabled]\n Add one or more domains to source origin (allow) list.\n\nExample: - \"abc.xyz.com\"-",
                    "title": "custom_domain_list",
                    "$ref": "#/definitions/schemaDomainNameList",
                    "x-displayname": "Specified domains",
                    "x-ves-example": "abc.xyz.com"
                },
                "disabled": {
                    "description": "Exclusive with [all_load_balancer_domains custom_domain_list]\n Allow all source origin domains.",
                    "title": "disabled",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disabled"
                }
            }
        },
        "schemaDomainNameList": {
            "type": "object",
            "description": "List of domain names used for Host header matching",
            "title": "List of Domain names",
            "x-displayname": "Domain name list",
            "x-ves-proto-message": "ves.io.schema.DomainNameList",
            "properties": {
                "domains": {
                    "type": "array",
                    "description": "\n A list of domain names that will be matched to loadbalancer.\n These domains are not used for SNI match.\n Wildcard names are supported in the suffix or prefix form.\n\nExample: - \"www.foo.com\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.max_len: 256\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.items.string.vh_domain: true\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Domains",
                    "minItems": 1,
                    "maxItems": 32,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 256
                    },
                    "x-displayname": "Domain names",
                    "x-ves-example": "www.foo.com",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "256",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.items.string.vh_domain": "true",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemaDomainType": {
            "type": "object",
            "description": "Domains names",
            "title": "Domains",
            "x-displayname": "Domains",
            "x-ves-oneof-field-domain_choice": "[\"exact_value\",\"regex_value\",\"suffix_value\"]",
            "x-ves-proto-message": "ves.io.schema.DomainType",
            "properties": {
                "exact_value": {
                    "type": "string",
                    "description": "Exclusive with [regex_value suffix_value]\n Exact domain name.\n\nExample: - \"abc.zyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "exact value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Exact Value",
                    "x-ves-example": "abc.zyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                },
                "regex_value": {
                    "type": "string",
                    "description": "Exclusive with [exact_value suffix_value]\n Regular Expression value for the domain name\n\nExample: - \"([a-z]([-a-z0-9]*[a-z0-9])?)\\.com$'\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "regex values of Domains",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Regex Values of Domains",
                    "x-ves-example": "([a-z]([-a-z0-9]*[a-z0-9])?)\\.com$'",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                },
                "suffix_value": {
                    "type": "string",
                    "description": "Exclusive with [exact_value regex_value]\n Suffix of domain name e.g \"xyz.com\" will match \"*.xyz.com\" and \"xyz.com\"\n\nExample: - \"xyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "suffix value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Suffix Value",
                    "x-ves-example": "xyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                }
            }
        },
        "schemaErrorCode": {
            "type": "string",
            "description": "Union of all possible error-codes from system\n\n - EOK: No error\n - EPERMS: Permissions error\n - EBADINPUT: Input is not correct\n - ENOTFOUND: Not found\n - EEXISTS: Already exists\n - EUNKNOWN: Unknown/catchall error\n - ESERIALIZE: Error in serializing/de-serializing\n - EINTERNAL: Server error\n - EPARTIAL: Partial error",
            "title": "ErrorCode",
            "enum": [
                "EOK",
                "EPERMS",
                "EBADINPUT",
                "ENOTFOUND",
                "EEXISTS",
                "EUNKNOWN",
                "ESERIALIZE",
                "EINTERNAL",
                "EPARTIAL"
            ],
            "default": "EOK",
            "x-displayname": "Error Code",
            "x-ves-proto-enum": "ves.io.schema.ErrorCode"
        },
        "schemaErrorType": {
            "type": "object",
            "description": "Information about a error in API operation",
            "title": "ErrorType",
            "x-displayname": "Error Type",
            "x-ves-proto-message": "ves.io.schema.ErrorType",
            "properties": {
                "code": {
                    "description": " A simple general code by category",
                    "title": "code",
                    "$ref": "#/definitions/schemaErrorCode",
                    "x-displayname": "Code"
                },
                "error_obj": {
                    "description": " A structured error object for machine parsing",
                    "title": "error_obj",
                    "$ref": "#/definitions/protobufAny",
                    "x-displayname": "Error Object"
                },
                "message": {
                    "type": "string",
                    "description": " A human readable string of the error\n\nExample: - \"value\"-",
                    "title": "message",
                    "x-displayname": "Message",
                    "x-ves-example": "value"
                }
            }
        },
        "schemaHashAlgorithm": {
            "type": "string",
            "description": "Specifies the Hash Algorithm to be used\n\nInvalid hash algorithm\nsha256 hash algorithm\nsha1 hash algorithm",
            "title": "HashAlgoritm",
            "enum": [
                "INVALID_HASH_ALGORITHM",
                "SHA256",
                "SHA1"
            ],
            "default": "INVALID_HASH_ALGORITHM",
            "x-displayname": "Hash Algorithm",
            "x-ves-proto-enum": "ves.io.schema.HashAlgorithm"
        },
        "schemaHashAlgorithms": {
            "type": "object",
            "description": "Specifies the hash algorithms to be used",
            "title": "HashAlgorithms",
            "x-displayname": "Hash Algorithms",
            "x-ves-proto-message": "ves.io.schema.HashAlgorithms",
            "properties": {
                "hash_algorithms": {
                    "type": "array",
                    "description": " Ordered list of hash algorithms to be used.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 4\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Hash Algorithms",
                    "minItems": 1,
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/schemaHashAlgorithm"
                    },
                    "x-displayname": "Hash Algorithms",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "4",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemaHeaderManipulationOptionType": {
            "type": "object",
            "description": "HTTP header is a key-value pair.\nThe name acts as key of HTTP header\nThe value acts as the data/value of HTTP header\nExample HTTP header\n    Host: user.volterra.com\nIn the above example, Host is the name or key of HTTP header\nIn the above example, user.volterra.com is the value of HTTP header",
            "title": "HeaderManipulationOptionType",
            "x-displayname": "Header Manipulation Option",
            "x-ves-oneof-field-value_choice": "[\"secret_value\",\"value\"]",
            "x-ves-proto-message": "ves.io.schema.HeaderManipulationOptionType",
            "properties": {
                "append": {
                    "type": "boolean",
                    "description": " Should the value be appended? If true, the value is appended to existing values.\n Default value is do not append",
                    "title": "append",
                    "format": "boolean",
                    "x-displayname": "Append"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the HTTP header.\n\nExample: - \"value\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Name",
                    "x-ves-example": "value",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "secret_value": {
                    "description": "Exclusive with [value]\n Secret Value of the HTTP header.",
                    "title": "Secret Value",
                    "$ref": "#/definitions/schemaSecretType",
                    "x-displayname": "Secret Value"
                },
                "value": {
                    "type": "string",
                    "description": "Exclusive with [secret_value]\n Value of the HTTP header.\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 8096\n",
                    "title": "value",
                    "maxLength": 8096,
                    "x-displayname": "Value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "8096"
                    }
                }
            }
        },
        "schemaHttpMethod": {
            "type": "string",
            "description": "Specifies the HTTP method used to access a resource.\n\nAny HTTP Method",
            "title": "HttpMethod",
            "enum": [
                "ANY",
                "GET",
                "HEAD",
                "POST",
                "PUT",
                "DELETE",
                "CONNECT",
                "OPTIONS",
                "TRACE",
                "PATCH",
                "COPY"
            ],
            "default": "ANY",
            "x-displayname": "HTTP Method",
            "x-ves-proto-enum": "ves.io.schema.HttpMethod"
        },
        "schemaHttpSections": {
            "type": "string",
            "description": "x-displayName: \"HTTP Sections\"\nRequest \u0026 Response Sections.\n\n - HTTP_SECTION_NONE: None\n\nALL_SECTIONS\nx-displayName: \"None\"\n - HTTP_SECTION_QUERY_PARAMS: QUERY_PARAMS\n\nx-displayName: \"Request Query Params\"\n - HTTP_SECTION_REQ_HEADERS: REQ_HEADERS\n\nx-displayName: \"Request Headers\"\n - HTTP_SECTION_RSP_HEADERS: RSP_HEADERS\n\nx-displayName: \"Response Headers\"\n - HTTP_SECTION_REQ_BODY: REQ_BODY\n\nx-displayName: \"Request Body\"\n - HTTP_SECTION_RSP_BODY: RSP_BODY\n\nx-displayName: \"Response Body\"",
            "title": "HTTPSections",
            "enum": [
                "HTTP_SECTION_NONE",
                "HTTP_SECTION_QUERY_PARAMS",
                "HTTP_SECTION_REQ_HEADERS",
                "HTTP_SECTION_RSP_HEADERS",
                "HTTP_SECTION_REQ_BODY",
                "HTTP_SECTION_RSP_BODY"
            ],
            "default": "HTTP_SECTION_NONE"
        },
        "schemaHttpStatusCode": {
            "type": "string",
            "description": "HTTP response status codes\n\nEmptyStatusCode response codes means it is not specified\nContinue status code\nOK status code\nCreated status code\nAccepted status code\nNon Authoritative Information status code\nNo Content status code\nReset Content status code\nPartial Content status code\nMulti Status status code\nAlready Reported status code\nIm Used status code\nMultiple Choices status code\nMoved Permanently status code\nFound status code\nSee Other status code\nNot Modified status code\nUse Proxy status code\nTemporary Redirect status code\nPermanent Redirect status code\nBad Request status code\nUnauthorized status code\nPayment Required status code\nForbidden status code\nNot Found status code\nMethod Not Allowed status code\nNot Acceptable status code\nProxy Authentication Required status code\nRequest Timeout status code\nConflict status code\nGone status code\nLength Required status code\nPrecondition Failed status code\nPayload Too Large status code\nUri Too Long status code\nUnsupported Media Type status code\nRange Not Satisfiable status code\nExpectation Failed status code\nMisdirected Request status code\nUnprocessable Entity status code\nLocked status code\nFailed Dependency status code\nUpgrade Required status code\nPrecondition Required status code\nToo Many Requests status code\nRequest Header Fields Too Large status code\nInternal Server Error status code\nNot Implemented status code\nBad Gateway status code\nService Unavailable status code\nGateway Timeout status code\nHttp Version Not Supported status code\nVariant Also Negotiates status code\nInsufficient Storage status code\nLoop Detected status code\nNot Extended status code\nNetwork Authentication Required status code",
            "title": "HttpStatusCode",
            "enum": [
                "EmptyStatusCode",
                "Continue",
                "OK",
                "Created",
                "Accepted",
                "NonAuthoritativeInformation",
                "NoContent",
                "ResetContent",
                "PartialContent",
                "MultiStatus",
                "AlreadyReported",
                "IMUsed",
                "MultipleChoices",
                "MovedPermanently",
                "Found",
                "SeeOther",
                "NotModified",
                "UseProxy",
                "TemporaryRedirect",
                "PermanentRedirect",
                "BadRequest",
                "Unauthorized",
                "PaymentRequired",
                "Forbidden",
                "NotFound",
                "MethodNotAllowed",
                "NotAcceptable",
                "ProxyAuthenticationRequired",
                "RequestTimeout",
                "Conflict",
                "Gone",
                "LengthRequired",
                "PreconditionFailed",
                "PayloadTooLarge",
                "URITooLong",
                "UnsupportedMediaType",
                "RangeNotSatisfiable",
                "ExpectationFailed",
                "MisdirectedRequest",
                "UnprocessableEntity",
                "Locked",
                "FailedDependency",
                "UpgradeRequired",
                "PreconditionRequired",
                "TooManyRequests",
                "RequestHeaderFieldsTooLarge",
                "InternalServerError",
                "NotImplemented",
                "BadGateway",
                "ServiceUnavailable",
                "GatewayTimeout",
                "HTTPVersionNotSupported",
                "VariantAlsoNegotiates",
                "InsufficientStorage",
                "LoopDetected",
                "NotExtended",
                "NetworkAuthenticationRequired"
            ],
            "default": "EmptyStatusCode",
            "x-displayname": "HTTP Status Code",
            "x-ves-proto-enum": "ves.io.schema.HttpStatusCode"
        },
        "schemaInitializerType": {
            "type": "object",
            "description": "Initializer is information about an initializer that has not yet completed.",
            "title": "InitializerType",
            "x-displayname": "Initializer",
            "x-ves-proto-message": "ves.io.schema.InitializerType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " name of the service that is responsible for initializing this object.",
                    "title": "name",
                    "x-displayname": "Name"
                }
            }
        },
        "schemaInitializersType": {
            "type": "object",
            "description": "Initializers tracks the progress of initialization of a configuration object",
            "title": "InitializersType",
            "x-displayname": "Initializers",
            "x-ves-proto-message": "ves.io.schema.InitializersType",
            "properties": {
                "pending": {
                    "type": "array",
                    "description": " Pending is a list of initializers that must execute in order before this object is initialized.\n When the last pending initializer is removed, and no failing result is set, the initializers\n struct will be set to nil and the object is considered as initialized and visible to all\n clients.",
                    "title": "pending",
                    "items": {
                        "$ref": "#/definitions/schemaInitializerType"
                    },
                    "x-displayname": "Pending"
                },
                "result": {
                    "description": " If result is set with the Failure field, the object will be persisted to storage and then deleted,\n ensuring that other clients can observe the deletion.",
                    "title": "result",
                    "$ref": "#/definitions/schemaStatusType",
                    "x-displayname": "Result"
                }
            }
        },
        "schemaJavaScriptMode": {
            "type": "string",
            "description": "Web Client JavaScript Mode.\n\nBot Defense JavaScript for telemetry collection is requested asynchronously, and it is non-cacheable\nBot Defense JavaScript for telemetry collection is requested asynchronously, and it is cacheable\nBot Defense JavaScript for telemetry collection is requested synchronously, and it is non-cacheable\nBot Defense JavaScript for telemetry collection is requested synchronously, and it is cacheable",
            "title": "JavaScript Mode",
            "enum": [
                "ASYNC_JS_NO_CACHING",
                "ASYNC_JS_CACHING",
                "SYNC_JS_NO_CACHING",
                "SYNC_JS_CACHING"
            ],
            "default": "ASYNC_JS_NO_CACHING",
            "x-displayname": "Web Client JavaScript Mode",
            "x-ves-proto-enum": "ves.io.schema.JavaScriptMode"
        },
        "schemaLabelSelectorType": {
            "type": "object",
            "description": "This type can be used to establish a 'selector reference' from one object(called selector) to\na set of other objects(called selectees) based on the value of expresssions.\nA label selector is a label query over a set of resources. An empty label selector matches all objects.\nA null label selector matches no objects. Label selector is immutable.\nexpressions is a list of strings of label selection expression.\nEach string has \",\" separated values which are \"AND\" and all strings are logically \"OR\".\nBNF for expression string\n\u003cselector-syntax\u003e         ::= \u003crequirement\u003e | \u003crequirement\u003e \",\" \u003cselector-syntax\u003e\n\u003crequirement\u003e             ::= [!] KEY [ \u003cset-based-restriction\u003e | \u003cexact-match-restriction\u003e ]\n\u003cset-based-restriction\u003e   ::= \"\" | \u003cinclusion-exclusion\u003e \u003cvalue-set\u003e\n\u003cinclusion-exclusion\u003e     ::= \u003cinclusion\u003e | \u003cexclusion\u003e\n\u003cexclusion\u003e               ::= \"notin\"\n\u003cinclusion\u003e               ::= \"in\"\n\u003cvalue-set\u003e               ::= \"(\" \u003cvalues\u003e \")\"\n\u003cvalues\u003e                  ::= VALUE | VALUE \",\" \u003cvalues\u003e\n\u003cexact-match-restriction\u003e ::= [\"=\"|\"==\"|\"!=\"] VALUE",
            "title": "LabelSelectorType",
            "x-displayname": "Label Selector",
            "x-ves-proto-message": "ves.io.schema.LabelSelectorType",
            "properties": {
                "expressions": {
                    "type": "array",
                    "description": " expressions contains the kubernetes style label expression for selections.\n\nExample: - \"region in (us-west1, us-west2),tier in (staging)\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.k8s_label_selector: true\n  ves.io.schema.rules.repeated.items.string.max_len: 4096\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.max_items: 1\n",
                    "title": "expressions",
                    "maxItems": 1,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 4096
                    },
                    "x-displayname": "Selector Expression",
                    "x-ves-example": "region in (us-west1, us-west2),tier in (staging)",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.k8s_label_selector": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "4096",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.max_items": "1"
                    }
                }
            }
        },
        "schemaMessageMetaType": {
            "type": "object",
            "description": "MessageMetaType is metadata (common attributes) of a message that only certain messages\nhave. This information is propagated to the metadata of a child object that gets created\nfrom the containing message during view processing.\nThe information in this type can be specified by user during create and replace APIs.",
            "title": "MessageMetaType",
            "x-displayname": "Message Metadata",
            "x-ves-proto-message": "ves.io.schema.MessageMetaType",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " Human readable description.\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "description",
                    "maxLength": 256,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of the message.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.min_len: 1\n  ves.io.schema.rules.string.ves_object_name: true\n",
                    "title": "name",
                    "minLength": 1,
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.min_len": "1",
                        "ves.io.schema.rules.string.ves_object_name": "true"
                    }
                }
            }
        },
        "schemaObjectCreateMetaType": {
            "type": "object",
            "description": "ObjectCreateMetaType is metadata that can be specified in Create request of an object.",
            "title": "ObjectCreateMetaType",
            "x-displayname": "Create Metadata",
            "x-ves-proto-message": "ves.io.schema.ObjectCreateMetaType",
            "properties": {
                "annotations": {
                    "type": "object",
                    "description": " Annotations is an unstructured key value map stored with a resource that may be\n set by external tools to store and retrieve arbitrary metadata. They are not\n queryable and should be preserved when modifying objects.\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 64\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.values.string.max_len: 1024\n  ves.io.schema.rules.map.values.string.min_len: 1\n",
                    "title": "annotations",
                    "x-displayname": "Annotation",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "64",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.values.string.max_len": "1024",
                        "ves.io.schema.rules.map.values.string.min_len": "1"
                    }
                },
                "description": {
                    "type": "string",
                    "description": " Human readable description for the object\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 1200\n",
                    "title": "description",
                    "maxLength": 1200,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "1200"
                    }
                },
                "disable": {
                    "type": "boolean",
                    "description": " A value of true will administratively disable the object\n\nExample: - \"true\"-",
                    "title": "disable",
                    "format": "boolean",
                    "x-displayname": "Disable"
                },
                "labels": {
                    "type": "object",
                    "description": " Map of string keys and values that can be used to organize and categorize\n (scope and select) objects as chosen by the user. Values specified here will be used\n by selector expression\n\nExample: - \"value\"-",
                    "title": "labels",
                    "x-displayname": "Labels"
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of configuration object. It has to be unique within the namespace.\n It can only be specified during create API and cannot be changed during replace API.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " This defines the workspace within which each the configuration object is to be created.\n Must be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"\n\nExample: - \"staging\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "staging"
                }
            }
        },
        "schemaObjectGetMetaType": {
            "type": "object",
            "description": "ObjectGetMetaType is metadata that can be specified in Get/Create response of an object.",
            "title": "ObjectGetMetaType",
            "x-displayname": "Get Metadata",
            "x-ves-proto-message": "ves.io.schema.ObjectGetMetaType",
            "properties": {
                "annotations": {
                    "type": "object",
                    "description": " Annotations is an unstructured key value map stored with a resource that may be\n set by external tools to store and retrieve arbitrary metadata. They are not\n queryable and should be preserved when modifying objects.\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 64\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.values.string.max_len: 1024\n  ves.io.schema.rules.map.values.string.min_len: 1\n",
                    "title": "annotations",
                    "x-displayname": "Annotation",
                    "x-ves-example": "value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "64",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.values.string.max_len": "1024",
                        "ves.io.schema.rules.map.values.string.min_len": "1"
                    }
                },
                "description": {
                    "type": "string",
                    "description": " Human readable description for the object\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 1200\n",
                    "title": "description",
                    "maxLength": 1200,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "1200"
                    }
                },
                "disable": {
                    "type": "boolean",
                    "description": " A value of true will administratively disable the object\n\nExample: - \"true\"-",
                    "title": "disable",
                    "format": "boolean",
                    "x-displayname": "Disable",
                    "x-ves-example": "true"
                },
                "labels": {
                    "type": "object",
                    "description": " Map of string keys and values that can be used to organize and categorize\n (scope and select) objects as chosen by the user. Values specified here will be used\n by selector expression\n\nExample: - \"value\"-",
                    "title": "labels",
                    "x-displayname": "Labels",
                    "x-ves-example": "value"
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of configuration object. It has to be unique within the namespace.\n It can only be specified during create API and cannot be changed during replace API.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " This defines the workspace within which each the configuration object is to be created.\n Must be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"\n\nExample: - \"staging\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "staging"
                }
            }
        },
        "schemaObjectReplaceMetaType": {
            "type": "object",
            "description": "ObjectReplaceMetaType is metadata that can be specified in Replace request of an object.",
            "title": "ObjectReplaceMetaType",
            "x-displayname": "Replace Metadata",
            "x-ves-proto-message": "ves.io.schema.ObjectReplaceMetaType",
            "properties": {
                "annotations": {
                    "type": "object",
                    "description": " Annotations is an unstructured key value map stored with a resource that may be\n set by external tools to store and retrieve arbitrary metadata. They are not\n queryable and should be preserved when modifying objects.\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 64\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.values.string.max_len: 1024\n  ves.io.schema.rules.map.values.string.min_len: 1\n",
                    "title": "annotations",
                    "x-displayname": "Annotations",
                    "x-ves-example": "value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "64",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.values.string.max_len": "1024",
                        "ves.io.schema.rules.map.values.string.min_len": "1"
                    }
                },
                "description": {
                    "type": "string",
                    "description": " Human readable description for the object\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 1200\n",
                    "title": "description",
                    "maxLength": 1200,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "1200"
                    }
                },
                "disable": {
                    "type": "boolean",
                    "description": " A value of true will administratively disable the object\n\nExample: - \"true\"-",
                    "title": "disable",
                    "format": "boolean",
                    "x-displayname": "Disable"
                },
                "labels": {
                    "type": "object",
                    "description": " Map of string keys and values that can be used to organize and categorize\n (scope and select) objects as chosen by the user. Values specified here will be used\n by selector expression\n\nExample: - \"value\"-",
                    "title": "labels",
                    "x-displayname": "Labels",
                    "x-ves-example": "value"
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of configuration object. It has to be unique within the namespace.\n It can only be specified during create API and cannot be changed during replace API.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " This defines the workspace within which each the configuration object is to be created.\n Must be a DNS_LABEL format. For a namespace object itself, namespace value will be \"\"\n\nExample: - \"staging\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "staging"
                }
            }
        },
        "schemaOpenApiValidationProperties": {
            "type": "string",
            "description": "List of required properties to validate against the OpenAPI spec\n\nValidate that all query parameters are according to the OpenAPI specification\nValidate that all path parameters are according to the OpenAPI specification\nValidate that the content type of the request is according to the OpenAPI specification\nValidate that all cookies are according to the OpenAPI specification\nValidate that all HTTP headers are according to the OpenAPI specification\nValidate that the body is according to the OpenAPI specification\nValidate that the security schema is according to the OpenAPI specification\nValidate that the response code is according to the OpenAPI specification",
            "title": "OpenApiValidationProperties",
            "enum": [
                "PROPERTY_QUERY_PARAMETERS",
                "PROPERTY_PATH_PARAMETERS",
                "PROPERTY_CONTENT_TYPE",
                "PROPERTY_COOKIE_PARAMETERS",
                "PROPERTY_HTTP_HEADERS",
                "PROPERTY_HTTP_BODY",
                "PROPERTY_SECURITY_SCHEMA",
                "PROPERTY_RESPONSE_CODE"
            ],
            "default": "PROPERTY_QUERY_PARAMETERS",
            "x-displayname": "OpenAPI Validation Properties",
            "x-ves-proto-enum": "ves.io.schema.OpenApiValidationProperties"
        },
        "schemaSecretEncodingType": {
            "type": "string",
            "description": "x-displayName: \"Secret Encoding\"\nSecretEncodingType defines the encoding type of the secret before handled by the Secret Management Service.\n\n - EncodingNone: x-displayName: \"None\"\nNo Encoding\n - EncodingBase64: Base64\n\nx-displayName: \"Base64\"\nBase64 encoding",
            "title": "SecretEncodingType",
            "enum": [
                "EncodingNone",
                "EncodingBase64"
            ],
            "default": "EncodingNone"
        },
        "schemaSecretType": {
            "type": "object",
            "description": "SecretType is used in an object to indicate a sensitive/confidential field",
            "title": "SecretType",
            "x-displayname": "Secret",
            "x-ves-oneof-field-secret_info_oneof": "[\"blindfold_secret_info\",\"clear_secret_info\"]",
            "x-ves-proto-message": "ves.io.schema.SecretType",
            "properties": {
                "blindfold_secret_info": {
                    "description": "Exclusive with [clear_secret_info]\n Blindfold Secret is used for the secrets managed by F5XC Secret Management Service",
                    "title": "Blindfold Secret",
                    "$ref": "#/definitions/schemaBlindfoldSecretInfoType",
                    "x-displayname": "Blindfold Secret"
                },
                "clear_secret_info": {
                    "description": "Exclusive with [blindfold_secret_info]\n Clear Secret is used for the secrets that are not encrypted",
                    "title": "Clear Secret",
                    "$ref": "#/definitions/schemaClearSecretInfoType",
                    "x-displayname": "Clear Secret"
                }
            }
        },
        "schemaStatusMetaType": {
            "type": "object",
            "description": "StatusMetaType is metadata that all status must have.",
            "title": "StatusMetaType",
            "x-displayname": "Metadata",
            "x-ves-proto-message": "ves.io.schema.StatusMetaType",
            "properties": {
                "creation_timestamp": {
                    "type": "string",
                    "description": " creation_timestamp is when the status object was created. It is used to find/tie-break\n for latest status object from same origin",
                    "title": "creation_timestamp",
                    "format": "date-time",
                    "x-displayname": "Creation Timestamp"
                },
                "creator_class": {
                    "type": "string",
                    "description": " Class of creator which created this StatusObject. This will be service's DNS FQDN.\n This will be set by the system based on client certificate information.\n\nExample: - \"ver.re1.int.ves.io\"-",
                    "title": "creator_class",
                    "x-displayname": "Creator Class",
                    "x-ves-example": "ver.re1.int.ves.io"
                },
                "creator_id": {
                    "type": "string",
                    "description": " ID of creator which created this StatusObject. This will be a concrete identifier for service (e.g.\n identifying the environment also). This will be set by the system based on client certificate\n information\n\nExample: - \"ver-instance-1\"-",
                    "title": "creator_id",
                    "x-displayname": "Creator ID",
                    "x-ves-example": "ver-instance-1"
                },
                "publish": {
                    "description": " Decides wether this status object will be propagated to user.",
                    "title": "publish",
                    "$ref": "#/definitions/schemaStatusPublishType",
                    "x-displayname": "Publish"
                },
                "status_id": {
                    "type": "string",
                    "description": " status_id is a field used by the generator to distinguish (if necessary) between two status\n objects for the same config object from the same site and same service and potentially same\n daemon(creator-id)",
                    "title": "status_id",
                    "x-displayname": "Status ID"
                },
                "uid": {
                    "type": "string",
                    "description": " uid is the unique in time and space value for a StatusObject.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                },
                "vtrp_id": {
                    "type": "string",
                    "description": " Origin of this status exchanged by VTRP.",
                    "title": "vtrp_id",
                    "x-displayname": "VTRP ID"
                },
                "vtrp_stale": {
                    "type": "boolean",
                    "description": " Indicate whether mars deems this object to be stale via graceful restart timer information",
                    "title": "vtrp_stale",
                    "format": "boolean",
                    "x-displayname": "VTRP Stale"
                }
            }
        },
        "schemaStatusPublishType": {
            "type": "string",
            "description": "StatusPublishType is all possible publish operations on a StatusObject\n\n - STATUS_DO_NOT_PUBLISH: Do Not Publish\n\nDo not propagate this status to user. This could be because status is only informational\n - STATUS_PUBLISH: Publish\n\nPropagate this status up to user as it might be actionable",
            "title": "StatusPublishType",
            "enum": [
                "STATUS_DO_NOT_PUBLISH",
                "STATUS_PUBLISH"
            ],
            "default": "STATUS_DO_NOT_PUBLISH",
            "x-displayname": "Status Publish Type",
            "x-ves-proto-enum": "ves.io.schema.StatusPublishType"
        },
        "schemaStatusType": {
            "type": "object",
            "description": "Status is a return value for calls that don't return other objects.",
            "title": "StatusType",
            "x-displayname": "Status",
            "x-ves-proto-message": "ves.io.schema.StatusType",
            "properties": {
                "code": {
                    "type": "integer",
                    "description": " Suggested HTTP return code for this status, 0 if not set.\n\nExample: - \"0\"-",
                    "title": "code",
                    "format": "int32",
                    "x-displayname": "Code",
                    "x-ves-example": "0"
                },
                "reason": {
                    "type": "string",
                    "description": " A human-readable description of why this operation is in the\n \"Failure\" status. If this value is empty there\n is no information available.\n\nExample: - \"value\"-",
                    "title": "reason",
                    "x-displayname": "Reason",
                    "x-ves-example": "value"
                },
                "status": {
                    "type": "string",
                    "description": " Status of the operation.\n One of: \"Success\" or \"Failure\".\n\nExample: - \"value\"-",
                    "title": "status",
                    "x-displayname": "Status",
                    "x-ves-example": "value"
                }
            }
        },
        "schemaSystemObjectGetMetaType": {
            "type": "object",
            "description": "SystemObjectGetMetaType is metadata generated or populated by the system for all persisted objects and\ncannot be updated directly by users.",
            "title": "SystemObjectGetMetaType",
            "x-displayname": "System Metadata",
            "x-ves-proto-message": "ves.io.schema.SystemObjectGetMetaType",
            "properties": {
                "creation_timestamp": {
                    "type": "string",
                    "description": " CreationTimestamp is a timestamp representing the server time when this object was\n created. It is not guaranteed to be set in happens-before order across separate operations.\n Clients may not set this value. It is represented in RFC3339 form and is in UTC.",
                    "title": "creation_timestamp",
                    "format": "date-time",
                    "x-displayname": "Creation Timestamp"
                },
                "creator_class": {
                    "type": "string",
                    "description": " A value identifying the class of the user or service which created this configuration object.\n\nExample: - \"value\"-",
                    "title": "creator_class",
                    "x-displayname": "Creator Class",
                    "x-ves-example": "prism"
                },
                "creator_id": {
                    "type": "string",
                    "description": " A value identifying the exact user or service that created this configuration object\n\nExample: - \"value\"-",
                    "title": "creator_id",
                    "x-displayname": "Creator ID",
                    "x-ves-example": "admin@acmecorp.com"
                },
                "deletion_timestamp": {
                    "type": "string",
                    "description": " DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This\n field is set by the server when a graceful deletion is requested by the user, and is not\n directly settable by a client. The resource is expected to be deleted (no longer visible\n from resource lists, and not reachable by name) after the time in this field, once the\n finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.\n Once the deletionTimestamp is set, this value may not be unset or be set further into the\n future, although it may be shortened or the resource may be deleted prior to this time.\n For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react\n by sending a graceful termination signal to the containers in the pod. After that 30 seconds,\n the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,\n remove the pod from the API. In the presence of network partitions, this object may still\n exist after this timestamp, until an administrator or automated process can determine the\n resource is fully terminated.\n If not set, graceful deletion of the object has not been requested.\n\n Populated by the system when a graceful deletion is requested.\n Read-only.",
                    "title": "deletion_timestamp",
                    "format": "date-time",
                    "x-displayname": "Deletion Timestamp"
                },
                "finalizers": {
                    "type": "array",
                    "description": " Must be empty before the object is deleted from the registry. Each entry\n is an identifier for the responsible component that will remove the entry\n from the list. If the deletionTimestamp of the object is non-nil, entries\n in this list can only be removed.\n\nExample: - \"value\"-",
                    "title": "finalizers",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Finalizers",
                    "x-ves-example": "value"
                },
                "initializers": {
                    "description": " An initializer is a controller which enforces some system invariant at object creation time.\n This field is a list of initializers that have not yet acted on this object. If nil or empty,\n this object has been completely initialized. Otherwise, the object is considered uninitialized\n and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to\n observe uninitialized objects.\n\n When an object is created, the system will populate this list with the current set of initializers.\n Only privileged users may set or modify this list. Once it is empty, it may not be modified further\n by any user.",
                    "title": "initializers",
                    "$ref": "#/definitions/schemaInitializersType",
                    "x-displayname": "Initializers"
                },
                "labels": {
                    "type": "object",
                    "description": " Map of string keys and values that can be used to organize and categorize\n (scope and select) objects as chosen by the operator or software. Values here can be interpreted\n by software(backend or frontend) to enable certain behavior e.g. things marked as soft-deleted(restorable).\n\nExample: - \"'ves.io/soft-deleted''true'\"-",
                    "title": "labels",
                    "x-displayname": "Labels",
                    "x-ves-example": "'ves.io/soft-deleted': 'true'"
                },
                "modification_timestamp": {
                    "type": "string",
                    "description": " ModificationTimestamp is a timestamp representing the server time when this object was\n last modified.",
                    "title": "modification_timestamp",
                    "format": "date-time",
                    "x-displayname": "Modification Timestamp"
                },
                "object_index": {
                    "type": "integer",
                    "description": " Unique index for the object. Some objects need a unique integer index to be allocated\n for each object type. This field will be populated for all objects that need it and will\n be zero otherwise.\n\nExample: - \"0\"-",
                    "title": "object_index",
                    "format": "int64",
                    "x-displayname": "Object Index",
                    "x-ves-example": "0"
                },
                "owner_view": {
                    "description": " Reference to the view object that owns this object.\n If there is no view owner, this field will be nil.\n If not nil, this object can only be edited/deleted through the view",
                    "title": "owner_view",
                    "$ref": "#/definitions/schemaViewRefType",
                    "x-displayname": "Owner View"
                },
                "tenant": {
                    "type": "string",
                    "description": " Tenant to which this configuration object belongs to. The value for this is found from\n presented credentials.\n\nExample: - \"acmecorp\"-",
                    "title": "tenant",
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp"
                },
                "uid": {
                    "type": "string",
                    "description": " uid is the unique in time and space value for this object. It is generated by\n the server on successful creation of an object and is not allowed to change on Replace\n API. The value of is taken from uid field of ObjectMetaType, if provided.\n\nExample: - \"d15f1fad-4d37-48c0-8706-df1824d76d31\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "d15f1fad-4d37-48c0-8706-df1824d76d31"
                }
            }
        },
        "schemaTlsCertificateType": {
            "type": "object",
            "description": "Handle to fetch certificate and key",
            "title": "TlsCertificateType",
            "x-displayname": "TLS Certificate",
            "x-ves-oneof-field-ocsp_stapling_choice": "[\"custom_hash_algorithms\",\"disable_ocsp_stapling\",\"use_system_defaults\"]",
            "x-ves-proto-message": "ves.io.schema.TlsCertificateType",
            "properties": {
                "certificate_url": {
                    "type": "string",
                    "description": " TLS certificate.\n Certificate or certificate chain in PEM format including the PEM headers.\n\nExample: - \"value\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.certificate_url: true\n  ves.io.schema.rules.string.max_bytes: 131072\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "certificate_url",
                    "minLength": 1,
                    "maxLength": 131072,
                    "x-displayname": "Certificate",
                    "x-ves-example": "value",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.certificate_url": "true",
                        "ves.io.schema.rules.string.max_bytes": "131072",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "custom_hash_algorithms": {
                    "description": "Exclusive with [disable_ocsp_stapling use_system_defaults]\n Use hash algorithms in the custom order. F5XC will try to fetch ocsp response from the CA in the given order. Additionally, LoadBalancer will not become active until ocspResponse cannot be fetched if the certificate has MustStaple extension set.",
                    "title": "Use Custom Order for Hash Algorithms",
                    "$ref": "#/definitions/schemaHashAlgorithms",
                    "x-displayname": "Use hash algorithms in custom order"
                },
                "description": {
                    "type": "string",
                    "description": " Description for the certificate\n\nExample: - \"Certificate used in production environment\"-",
                    "title": "description",
                    "x-displayname": "Description",
                    "x-ves-example": "Certificate used in production environment"
                },
                "disable_ocsp_stapling": {
                    "description": "Exclusive with [custom_hash_algorithms use_system_defaults]\n Disable OCSP Stapling. F5XC will not fetch and staple OCSP Response for this certificate.\n This is the default behavior if no choice is selected.",
                    "title": "Disable OCSP Stapling",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable OCSP Stapling"
                },
                "private_key": {
                    "description": " TLS Private Key data in unencrypted PEM format including the PEM headers. The data may be optionally secured using BlindFold. TLS key has to match the accompanying certificate.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "private_key",
                    "$ref": "#/definitions/schemaSecretType",
                    "x-displayname": "Private Key",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "use_system_defaults": {
                    "description": "Exclusive with [custom_hash_algorithms disable_ocsp_stapling]\n Use F5XC Default Settings to fetch and staple OCSP Response.\n OCSP Response will be stapled if it can be fetched. Additionally, LoadBalancer will not become active until ocspResponse cannot be fetched if the certificate has MustStaple extension set.\n F5XC will try to fetch OCSPResponse with sha256 and sha1 as HashAlgorithm, in that order.",
                    "title": "Fetch with F5XC default settings",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Fetch with F5XC default settings"
                }
            }
        },
        "schemaTlsProtocol": {
            "type": "string",
            "description": "TlsProtocol is enumeration of supported TLS versions\n\nF5 Distributed Cloud will choose the optimal TLS version.",
            "title": "TlsProtocol",
            "enum": [
                "TLS_AUTO",
                "TLSv1_0",
                "TLSv1_1",
                "TLSv1_2",
                "TLSv1_3"
            ],
            "default": "TLS_AUTO",
            "x-displayname": "TLS Protocol",
            "x-ves-proto-enum": "ves.io.schema.TlsProtocol"
        },
        "schemaVaultSecretInfoType": {
            "type": "object",
            "description": "x-displayName: \"Vault Secret\"\nVaultSecretInfoType specifies information about the Secret managed by Hashicorp Vault.",
            "title": "VaultSecretInfoType",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "x-displayName: \"Key\"\nx-example: \"key_pem\"\nKey of the individual secret. Vault Secrets are stored as key-value pair.\nIf user is only interested in one value from the map, this field should be set to the corresponding key.\nIf not provided entire secret will be returned.",
                    "title": "Key"
                },
                "location": {
                    "type": "string",
                    "description": "x-displayName: \"Location\"\nx-required\nx-example: \"v1/data/vhost_key\"\nPath to secret in Vault.",
                    "title": "Location"
                },
                "provider": {
                    "type": "string",
                    "description": "x-displayName: \"Provider\"\nx-required\nx-example: \"vault-vh-provider\"\nName of the Secret Management Access object that contains information about the backend Vault.",
                    "title": "Provider"
                },
                "secret_encoding": {
                    "description": "x-displayName: \"Secret Encoding\"\nThis field defines the encoding type of the secret BEFORE the secret is put into Hashicorp Vault.",
                    "title": "secret_encoding",
                    "$ref": "#/definitions/schemaSecretEncodingType"
                },
                "version": {
                    "type": "integer",
                    "description": "x-displayName: \"Version\"\nx-example: \"1\"\nVersion of the secret to be fetched. As vault secrets are versioned, user can specify this field to fetch specific version.\nIf not provided latest version will be returned.",
                    "title": "Version",
                    "format": "int64"
                }
            }
        },
        "schemaViewRefType": {
            "type": "object",
            "description": "ViewRefType represents a reference to a view",
            "title": "ViewRefType",
            "x-displayname": "View Reference",
            "x-ves-proto-message": "ves.io.schema.ViewRefType",
            "properties": {
                "kind": {
                    "type": "string",
                    "description": " Kind of the view object\n\nExample: - \"http_proxy\"-",
                    "title": "kind",
                    "x-displayname": "Kind",
                    "x-ves-example": "http_proxy"
                },
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contactus-route\"-",
                    "title": "name",
                    "x-displayname": "Name",
                    "x-ves-example": "contactus-route"
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1"
                },
                "uid": {
                    "type": "string",
                    "description": " UID of the view object\n\nExample: - \"f3744323-1adf-4aaa-a5dc-0707c1d1bd82\"-",
                    "title": "uid",
                    "x-displayname": "UID",
                    "x-ves-example": "f3744323-1adf-4aaa-a5dc-0707c1d1bd82"
                }
            }
        },
        "schemaWingmanSecretInfoType": {
            "type": "object",
            "description": "x-displayName: \"Wingman Secret\"\nWingmanSecretInfoType specifies the handle to the wingman secret",
            "title": "WingmanSecretInfoType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Name\"\nx-required\nx-example: \"ChargeBack-API-Key\"\nName of the secret.",
                    "title": "Name"
                }
            }
        },
        "schemaXfccElement": {
            "type": "string",
            "description": "X-Forwarded-Client-Cert custom cookie elements\n\nThe entire client certificate in URL encoded PEM format.\nThe entire client certificate chain (including the leaf certificate) in URL encoded PEM format.\nThe Subject field of the current client certificate. The value is always double-quoted.\nThe URI type Subject Alternative Name field of the current client certificate.\nA client certificate may contain multiple URI type Subject Alternative Names,\neach will be a separate key-value pair.\nThe DNS type Subject Alternative Name field of the current client certificate.\nA client certificate may contain multiple DNS type Subject Alternative Names,\neach will be a separate key-value pair.",
            "title": "XfccElement",
            "enum": [
                "XFCC_NONE",
                "XFCC_CERT",
                "XFCC_CHAIN",
                "XFCC_SUBJECT",
                "XFCC_URI",
                "XFCC_DNS"
            ],
            "default": "XFCC_NONE",
            "x-displayname": "XFCC Elements",
            "x-ves-proto-enum": "ves.io.schema.XfccElement"
        },
        "schemapolicyHeaderMatcherType": {
            "type": "object",
            "description": "A header matcher specifies the name of a single HTTP header and the criteria for the input request to match it. The input has a list of actual values for each\nheader name in the original HTTP request.\nA header matcher can check for one of the following:\n* Presence or absence of the header in the input\n* At least one of the values for the header in the input satisfies the MatcherType item",
            "title": "HeaderMatcherType",
            "x-displayname": "Header Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.HeaderMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the header is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the header is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Header Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the header. The match is successful if any of the values in the input satisfies the criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "name": {
                    "type": "string",
                    "description": " A case-insensitive HTTP header name.\n\nExample: - \"Accept-Encoding\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_header_field: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "name",
                    "maxLength": 256,
                    "x-displayname": "Header Name",
                    "x-ves-example": "Accept-Encoding",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_header_field": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "schemapolicyIPThreatCategoryListType": {
            "type": "object",
            "description": "List of ip threat categories",
            "title": "IP Threat Category List Type",
            "x-displayname": "IP Threat Category List Type",
            "x-ves-proto-message": "ves.io.schema.policy.IPThreatCategoryListType",
            "properties": {
                "ip_threat_categories": {
                    "type": "array",
                    "description": " The IP threat categories is obtained from the list and is used to auto-generate equivalent label selection expressions\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "IP Threat Categories",
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/policyIPThreatCategory"
                    },
                    "x-displayname": "List of IP Threat Categories to choose",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemapolicyPathMatcherType": {
            "type": "object",
            "description": "A path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set\nof supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.",
            "title": "PathMatcherType",
            "x-displayname": "Path Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.PathMatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact path values to match the input HTTP path against.\n\nExample: - \"['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.http_path: true\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.http_path": "true",
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Path Matcher"
                },
                "prefix_values": {
                    "type": "array",
                    "description": " A list of path prefix values to match the input HTTP path against.\n\nExample: - \"['/api/web/namespaces/project179/users/', '/api/config/namespaces/', '/api/data/namespaces/']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.http_path: true\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "prefix values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Prefix Values",
                    "x-ves-example": "['/api/web/namespaces/project179/users/', '/api/config/namespaces/', '/api/data/namespaces/']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.http_path": "true",
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "regex_values": {
                    "type": "array",
                    "description": " A list of regular expressions to match the input HTTP path against.\n\nExample: - \"['^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$', '/api/data/namespaces/proj404/virtual_hosts/([a-z]([-a-z0-9]*[a-z0-9])?)$']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 256\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.items.string.regex: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "regex values",
                    "maxItems": 16,
                    "items": {
                        "type": "string",
                        "maxLength": 256
                    },
                    "x-displayname": "Regex Values",
                    "x-ves-example": "['^/api/web/namespaces/abc/users/([a-z]([-a-z0-9]*[a-z0-9])?)$', '/api/data/namespaces/proj404/virtual_hosts/([a-z]([-a-z0-9]*[a-z0-9])?)$']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "256",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.items.string.regex": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "suffix_values": {
                    "type": "array",
                    "description": " A list of path suffix values to match the input HTTP path against.\n\nExample: - \"['.exe', '.shtml', '.wmz']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.max_bytes: 64\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Suffix values",
                    "maxItems": 64,
                    "items": {
                        "type": "string",
                        "maxLength": 64
                    },
                    "x-displayname": "Suffix Values",
                    "x-ves-example": "['.exe', '.shtml', '.wmz']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.max_bytes": "64",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "transformers": {
                    "type": "array",
                    "description": " An ordered list of transformers (starting from index 0) to be applied to the path before matching.\n\nExample: - \"[BASE64_DECODE, LOWER_CASE]-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 9\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "transformers",
                    "maxItems": 9,
                    "items": {
                        "$ref": "#/definitions/policyTransformer"
                    },
                    "x-displayname": "Transformers",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "9",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemapolicyQueryParameterMatcherType": {
            "type": "object",
            "description": "A query parameter matcher specifies the name of a single query parameter and the criteria for the input request to match it. The input has a list of actual\nvalues for each query parameter name in the original HTTP request.\nA query parameter matcher can check for one of the following:\n* Presence or absence of the query parameter in the input\n* At least one of the values for the query parameter in the input satisfies the MatcherType item",
            "title": "QueryParameterMatcherType",
            "x-displayname": "Query Parameter Matcher",
            "x-ves-displayorder": "1,6,4",
            "x-ves-oneof-field-match": "[\"check_not_present\",\"check_present\",\"item\"]",
            "x-ves-proto-message": "ves.io.schema.policy.QueryParameterMatcherType",
            "properties": {
                "check_not_present": {
                    "description": "Exclusive with [check_present item]\n Check that the query parameter is not present.",
                    "title": "check_not_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Not Present"
                },
                "check_present": {
                    "description": "Exclusive with [check_not_present item]\n Check that the query parameter is present.",
                    "title": "check_present",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Present"
                },
                "invert_matcher": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Query Parameter Matcher"
                },
                "item": {
                    "description": "Exclusive with [check_not_present check_present]\n Criteria for matching the values for the given query parameter. The match is successful if any of the values for the query parameter satisfies the\n criteria in the matcher.",
                    "title": "item",
                    "$ref": "#/definitions/policyMatcherType",
                    "x-displayname": "Match Values"
                },
                "key": {
                    "type": "string",
                    "description": " A case-sensitive HTTP query parameter name.\n\nExample: - \"sourceid\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 256\n",
                    "title": "key",
                    "maxLength": 256,
                    "x-displayname": "Query Parameter Name",
                    "x-ves-example": "sourceid",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "256"
                    }
                }
            }
        },
        "schemaviewsDownstreamTlsParamsType": {
            "type": "object",
            "description": "Inline TLS parameters",
            "title": "DownstreamTlsParamsType",
            "x-displayname": "Inline TLS Parameters",
            "x-ves-oneof-field-mtls_choice": "[\"no_mtls\",\"use_mtls\"]",
            "x-ves-proto-message": "ves.io.schema.views.DownstreamTlsParamsType",
            "properties": {
                "no_mtls": {
                    "description": "Exclusive with [use_mtls]\n",
                    "title": "No mTLS",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "tls_certificates": {
                    "type": "array",
                    "description": " Users can add one or more certificates that share the same set of domains.\n for example, domain.com and *.domain.com - but use different signature algorithms\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.min_items: 1\n",
                    "title": "tls_certificates",
                    "minItems": 1,
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaTlsCertificateType"
                    },
                    "x-displayname": "TLS Certificates",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.min_items": "1"
                    }
                },
                "tls_config": {
                    "description": " Configuration of TLS settings such as min/max TLS version and ciphersuites",
                    "title": "TLS Config",
                    "$ref": "#/definitions/viewsTlsConfig",
                    "x-displayname": "TLS"
                },
                "use_mtls": {
                    "description": "Exclusive with [no_mtls]\n",
                    "title": "Use mTLS",
                    "$ref": "#/definitions/viewsDownstreamTlsValidationContext",
                    "x-displayname": "Enable"
                }
            }
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "This type establishes a direct reference from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.views.ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contacts-route\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 128\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "name",
                    "minLength": 1,
                    "maxLength": 128,
                    "x-displayname": "Name",
                    "x-ves-example": "contacts-route",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "128",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "namespace",
                    "maxLength": 64,
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "tenant",
                    "maxLength": 64,
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                }
            }
        },
        "service_policy_ruleChallengeRuleSpec": {
            "type": "object",
            "description": "A Challenge Rule consists of an unordered list of predicates and an action. The predicates are evaluated against a set of input fields that are extracted from\nor derived from an L7 request API. A request API is considered to match the rule if all predicates in the rule evaluate to true for that request. Any\npredicates that are not specified in a rule are implicitly considered to be true. If a request API matches a challenge rule, the configured challenge is\nenforced.",
            "title": "Challenge Rule Spec",
            "x-displayname": "Challenge Rule Specification",
            "x-ves-oneof-field-asn_choice": "[\"any_asn\",\"asn_list\",\"asn_matcher\"]",
            "x-ves-oneof-field-challenge_action": "[\"disable_challenge\",\"enable_captcha_challenge\",\"enable_javascript_challenge\"]",
            "x-ves-oneof-field-client_choice": "[\"any_client\",\"client_selector\"]",
            "x-ves-oneof-field-ip_choice": "[\"any_ip\",\"ip_matcher\",\"ip_prefix_list\"]",
            "x-ves-oneof-field-tls_fingerprint_choice": "[\"tls_fingerprint_matcher\"]",
            "x-ves-proto-message": "ves.io.schema.service_policy_rule.ChallengeRuleSpec",
            "properties": {
                "any_asn": {
                    "description": "Exclusive with [asn_list asn_matcher]\n Any origin ASN.",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "any_client": {
                    "description": "Exclusive with [client_selector]\n Any Client",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "any_ip": {
                    "description": "Exclusive with [ip_matcher ip_prefix_list]\n Any Source IP",
                    "$ref": "#/definitions/ioschemaEmpty"
                },
                "arg_matchers": {
                    "type": "array",
                    "description": " A list of predicates for all POST args that need to be matched. The criteria for matching each arg are described in individual instances\n of ArgMatcherType. The actual arg values are extracted from the request API as a list of strings for each arg selector name.\n Note that all specified arg matcher predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyArgMatcherType"
                    },
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "asn_list": {
                    "description": "Exclusive with [any_asn asn_matcher]\n List of 4-byte ASN values.\n The predicate evaluates to true if the origin ASN is present in the ASN list.",
                    "$ref": "#/definitions/policyAsnMatchList"
                },
                "asn_matcher": {
                    "description": "Exclusive with [any_asn asn_list]\n List of references to BGP ASN Set objects.\n The predicate evaluates to true if the origin ASN is present in one of the BGP ASN Set objects.",
                    "$ref": "#/definitions/policyAsnMatcherType"
                },
                "body_matcher": {
                    "description": " Predicate for matching the request body string. The criteria for matching the request body is described in MatcherType.\n The actual request body value is extracted from the request API as a string.",
                    "$ref": "#/definitions/policyMatcherType"
                },
                "client_selector": {
                    "description": "Exclusive with [any_client]\n A label selector that describes the expected set of clients. The labels associated with the client making the API request are used to evaluate the label\n expressions in the selector. These labels can be derived from the client TLS certificate or from the volterra internal control plane.\n This is a more flexible and powerful version of the client name matcher predicate that allows a given rule to be applicable to a set of clients based on the\n client labels rather than being limited to relying on patterns in the client name.\n The predicate evaluates to true if the expressions in the label selector are true for the client labels.",
                    "$ref": "#/definitions/schemaLabelSelectorType"
                },
                "cookie_matchers": {
                    "type": "array",
                    "description": " A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances\n of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.\n Note that all specified cookie matcher predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyCookieMatcherType"
                    },
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "disable_challenge": {
                    "description": "Exclusive with [enable_captcha_challenge enable_javascript_challenge]\nDisable the challenge type selected in PolicyBasedChallenge",
                    "title": "Disable challenge",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable challenge"
                },
                "domain_matcher": {
                    "description": " A list of exact values and/or regular expressions for the expected name of the domain. The actual value of domain is the host component\n from the URL. The predicate evaluates to true if the domain value matches any of the exact values or regular expressions in the domain\n matcher.",
                    "$ref": "#/definitions/policyMatcherTypeBasic"
                },
                "enable_captcha_challenge": {
                    "description": "Exclusive with [disable_challenge enable_javascript_challenge]\nEnable captcha challenge",
                    "title": "Enable captcha challenge",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable captcha challenge"
                },
                "enable_javascript_challenge": {
                    "description": "Exclusive with [disable_challenge enable_captcha_challenge]\nEnable javascript challenge",
                    "title": "Enable javascript challenge",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable javascript challenge"
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": " The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\n the configuration but is not applied anymore.\n\nExample: - \"2019-12-31:44:34.171543432Z\"-",
                    "format": "date-time"
                },
                "headers": {
                    "type": "array",
                    "description": " A list of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType\n instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.\n Note that all specified header predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemapolicyHeaderMatcherType"
                    },
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "http_method": {
                    "description": " The list of expected values for the HTTP method in the request API. The actual value of the HTTP method is extracted from the HTTP request.\n The predicate evaluates to true if the actual HTTP method belongs is present in the list of expected values.",
                    "$ref": "#/definitions/policyHttpMethodMatcherType"
                },
                "ip_matcher": {
                    "description": "Exclusive with [any_ip ip_prefix_list]\n List of references to IP Prefix Set objects.\n The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes in the IP Prefix Sets.",
                    "$ref": "#/definitions/policyIpMatcherType"
                },
                "ip_prefix_list": {
                    "description": "Exclusive with [any_ip ip_matcher]\n List of IP Prefixes values.\n The predicate evaluates to true if the client IP Address is covered by one or more of the IP Prefixes from the list.",
                    "$ref": "#/definitions/policyPrefixMatchList"
                },
                "path": {
                    "description": " A list of exact values, prefixes and regular expressions for the expected value of the HTTP path. The actual value of the HTTP path is the unescaped path\n value extracted from the HTTP URL Resource, excluding any query and fragment information.\n The predicate evaluates to true if the actual path value matches any of the exact or prefix values or regular expressions in the path matcher.",
                    "$ref": "#/definitions/schemapolicyPathMatcherType"
                },
                "query_params": {
                    "type": "array",
                    "description": " A list of predicates for all query parameters that need to be matched. The criteria for matching each query parameter are described in individual instances\n of QueryParameterMatcherType. The actual query parameter values are extracted from the request API as a list of strings for each query parameter name.\n Note that all specified query parameter predicates must evaluate to true.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemapolicyQueryParameterMatcherType"
                    },
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                },
                "tls_fingerprint_matcher": {
                    "description": "Exclusive with []\n JA3 TLS fingerprints to be matched",
                    "$ref": "#/definitions/policyTlsFingerprintMatcherType"
                }
            }
        },
        "viewsCustomCiphers": {
            "type": "object",
            "description": "This defines TLS protocol config including min/max versions and allowed ciphers",
            "title": "CustomCiphers",
            "x-displayname": "Custom Ciphers",
            "x-ves-displayorder": "1,2,3",
            "x-ves-proto-message": "ves.io.schema.views.CustomCiphers",
            "properties": {
                "cipher_suites": {
                    "type": "array",
                    "description": " The TLS listener will only support the specified cipher list.\n\nExample: - \"TLS_AES_128_GCM_SHA256\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.in: [\\\"TLS_AES_128_GCM_SHA256\\\",\\\"TLS_AES_256_GCM_SHA384\\\",\\\"TLS_CHACHA20_POLY1305_SHA256\\\",\\\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\\\",\\\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\\\",\\\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\\\",\\\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\\\",\\\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\\\",\\\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\\\",\\\"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\\\",\\\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\\\",\\\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\\\",\\\"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\\\",\\\"TLS_RSA_WITH_AES_128_CBC_SHA\\\",\\\"TLS_RSA_WITH_AES_128_GCM_SHA256\\\",\\\"TLS_RSA_WITH_AES_256_CBC_SHA\\\",\\\"TLS_RSA_WITH_AES_256_GCM_SHA384\\\"]\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "cipher_suites",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Cipher Suites",
                    "x-ves-example": "TLS_AES_128_GCM_SHA256",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.in": "[\\\"TLS_AES_128_GCM_SHA256\\\",\\\"TLS_AES_256_GCM_SHA384\\\",\\\"TLS_CHACHA20_POLY1305_SHA256\\\",\\\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\\\",\\\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\\\",\\\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\\\",\\\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\\\",\\\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\\\",\\\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\\\",\\\"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\\\",\\\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\\\",\\\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\\\",\\\"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\\\",\\\"TLS_RSA_WITH_AES_128_CBC_SHA\\\",\\\"TLS_RSA_WITH_AES_128_GCM_SHA256\\\",\\\"TLS_RSA_WITH_AES_256_CBC_SHA\\\",\\\"TLS_RSA_WITH_AES_256_GCM_SHA384\\\"]",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "max_version": {
                    "description": " Maximum TLS protocol version.",
                    "title": "maximum_protocol_version",
                    "$ref": "#/definitions/schemaTlsProtocol",
                    "x-displayname": "Maximum TLS version"
                },
                "min_version": {
                    "description": " Minimum TLS protocol version.",
                    "title": "minimum_protocol_version",
                    "$ref": "#/definitions/schemaTlsProtocol",
                    "x-displayname": "Minimum TLS version"
                }
            }
        },
        "viewsDownstreamTLSCertsParams": {
            "type": "object",
            "description": "Select TLS Parameters and Certificates",
            "title": "DownstreamTLSCertsParams",
            "x-displayname": "TLS Parameters",
            "x-ves-oneof-field-mtls_choice": "[\"no_mtls\",\"use_mtls\"]",
            "x-ves-proto-message": "ves.io.schema.views.DownstreamTLSCertsParams",
            "properties": {
                "certificates": {
                    "type": "array",
                    "description": " Select one or more certificates with any domain names.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "certificates",
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/schemaviewsObjectRefType"
                    },
                    "x-displayname": "Certificates",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "no_mtls": {
                    "description": "Exclusive with [use_mtls]\n",
                    "title": "No mTLS",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "tls_config": {
                    "description": " Configuration of TLS settings such as min/max TLS version and ciphersuites",
                    "title": "TLS Config",
                    "$ref": "#/definitions/viewsTlsConfig",
                    "x-displayname": "TLS"
                },
                "use_mtls": {
                    "description": "Exclusive with [no_mtls]\n",
                    "title": "Use mTLS",
                    "$ref": "#/definitions/viewsDownstreamTlsValidationContext",
                    "x-displayname": "Enable"
                }
            }
        },
        "viewsDownstreamTlsValidationContext": {
            "type": "object",
            "description": "Validation context for downstream client TLS connections",
            "title": "DownstreamTlsValidationContext",
            "x-displayname": "Clients TLS validation context",
            "x-ves-oneof-field-crl_choice": "[\"crl\",\"no_crl\"]",
            "x-ves-oneof-field-trusted_ca_choice": "[\"trusted_ca\",\"trusted_ca_url\"]",
            "x-ves-oneof-field-xfcc_header": "[\"xfcc_disabled\",\"xfcc_options\"]",
            "x-ves-proto-message": "ves.io.schema.views.DownstreamTlsValidationContext",
            "properties": {
                "client_certificate_optional": {
                    "type": "boolean",
                    "description": " Client certificate is optional. If the client has provided a certificate,\n the load balancer will verify it. If certification verification fails,\n the connection will be terminated. If the client does not provide a certificate,\n the connection will be accepted.",
                    "title": "client_certificate_optional",
                    "format": "boolean",
                    "x-displayname": "Client Certificate Optional"
                },
                "crl": {
                    "description": "Exclusive with [no_crl]\n\n Client certificate is verified against CRL.\n Specify the CRL server information to download the certificate revocation list",
                    "title": "Verify client certificate with CRL",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "CRL"
                },
                "no_crl": {
                    "description": "Exclusive with [crl]\n Client certificate revocation status is not verified",
                    "title": "No client certificate verification with CRL",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No CRL"
                },
                "trusted_ca": {
                    "description": "Exclusive with [trusted_ca_url]\n Select/Add a Root CA Certificate object to associate with this Load Balancer",
                    "title": "trusted_ca",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Root CA Certificate"
                },
                "trusted_ca_url": {
                    "type": "string",
                    "description": "Exclusive with [trusted_ca]\n Upload a Root CA Certificate specifically for this Load Balancer\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 131072\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.truststore_url: true\n",
                    "title": "trusted_ca_url",
                    "minLength": 1,
                    "maxLength": 131072,
                    "x-displayname": "Inline Root CA Certificate (legacy)",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "131072",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.truststore_url": "true"
                    }
                },
                "xfcc_disabled": {
                    "description": "Exclusive with [xfcc_options]\n No X-Forwarded-Client-Cert header will be added",
                    "title": "No XFCC header",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disabled"
                },
                "xfcc_options": {
                    "description": "Exclusive with [xfcc_disabled]\n X-Forwarded-Client-Cert header will be added with the configured fields",
                    "title": "Add XFCC header",
                    "$ref": "#/definitions/viewsXfccHeaderKeys",
                    "x-displayname": "Enabled"
                }
            }
        },
        "viewsPrefixStringListType": {
            "type": "object",
            "description": "x-example: \"192.168.20.0/24\"\nList of IPv4 prefixes that represent an endpoint",
            "title": "ipv4 prefix list",
            "x-displayname": "IPv4 Prefix List",
            "x-ves-proto-message": "ves.io.schema.views.PrefixStringListType",
            "properties": {
                "ipv6_prefixes": {
                    "type": "array",
                    "description": " List of IPv6 prefix strings.\n\nExample: - \"fd48:fa09:d9d4::/48\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv6_prefix: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ipv6 prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Prefix List",
                    "x-ves-example": "fd48:fa09:d9d4::/48",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv6_prefix": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "prefixes": {
                    "type": "array",
                    "description": " List of IPv4 prefixes that represent an endpoint\n\nExample: - \"192.168.20.0/24\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv4_prefix: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ipv4 prefix list",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Prefix List",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "viewsTlsConfig": {
            "type": "object",
            "description": "This defines various options to configure TLS configuration parameters",
            "title": "TlsConfig",
            "x-displayname": "TLS Config",
            "x-ves-displayorder": "5",
            "x-ves-oneof-field-choice": "[\"custom_security\",\"default_security\",\"low_security\",\"medium_security\"]",
            "x-ves-proto-message": "ves.io.schema.views.TlsConfig",
            "properties": {
                "custom_security": {
                    "description": "Exclusive with [default_security low_security medium_security]\n Custom selection of TLS versions and cipher suites",
                    "title": "Custom Security",
                    "$ref": "#/definitions/viewsCustomCiphers",
                    "x-displayname": "Custom"
                },
                "default_security": {
                    "description": "Exclusive with [custom_security low_security medium_security]\n TLS v1.2+ with PFS ciphers and strong crypto algorithms.",
                    "title": "Default Security",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "High"
                },
                "low_security": {
                    "description": "Exclusive with [custom_security default_security medium_security]\n TLS v1.0+ including non-PFS ciphers and weak crypto algorithms.",
                    "title": "Low Security",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Low"
                },
                "medium_security": {
                    "description": "Exclusive with [custom_security default_security low_security]\n TLS v1.0+ with PFS ciphers and medium strength crypto algorithms.",
                    "title": "Medium Security",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Medium"
                }
            }
        },
        "viewsXfccHeaderKeys": {
            "type": "object",
            "description": "X-Forwarded-Client-Cert header elements to be added to requests",
            "title": "XfccHeaderKeys",
            "x-displayname": "XFCC Header Elements",
            "x-ves-proto-message": "ves.io.schema.views.XfccHeaderKeys",
            "properties": {
                "xfcc_header_elements": {
                    "type": "array",
                    "description": " X-Forwarded-Client-Cert header elements to be added to requests\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.not_in: [0]\n",
                    "title": "XFCC Header",
                    "items": {
                        "$ref": "#/definitions/schemaXfccElement"
                    },
                    "x-displayname": "XFCC Header Elements",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.not_in": "[0]"
                    }
                }
            }
        },
        "viewscdn_loadbalancerAdvancedOptionsType": {
            "type": "object",
            "description": "x-displayName: \"Advanced Options\"\nThis defines various options to define a route",
            "title": "Advanced options",
            "properties": {
                "cache_options": {
                    "description": "x-displayName: \"Cache Options\"\nCache Options",
                    "title": "Cache Options",
                    "$ref": "#/definitions/cdn_loadbalancerCacheOptions"
                },
                "cache_ttl_options": {
                    "description": "x-displayName: \"Cache Options\"\nCache Options",
                    "title": "Cache Options",
                    "$ref": "#/definitions/cdn_loadbalancerCacheTTLOptionsType"
                },
                "header_options": {
                    "description": "x-displayName: \"Header Control\"\nRequest/Response header related options",
                    "title": "Header Control",
                    "$ref": "#/definitions/cdn_loadbalancerHeaderControlType"
                },
                "logging_options": {
                    "description": "x-displayName: \"Logging Options\"\nLogging related options",
                    "title": "Logging Options",
                    "$ref": "#/definitions/cdn_loadbalancerLoggingOptionsType"
                },
                "security_options": {
                    "description": "x-displayName: \"Security Options\"\nSecurity related options",
                    "title": "Security Options",
                    "$ref": "#/definitions/cdn_loadbalancerSecurityOptionsType"
                }
            }
        },
        "viewscdn_loadbalancerCreateSpecType": {
            "type": "object",
            "description": "Shape of the CDN loadbalancer specification",
            "title": "CreateSpecType",
            "x-displayname": "Create CDN Loadbalancer",
            "x-ves-oneof-field-api_definition_choice": "[\"api_specification\",\"disable_api_definition\"]",
            "x-ves-oneof-field-api_discovery_choice": "[\"disable_api_discovery\",\"enable_api_discovery\"]",
            "x-ves-oneof-field-bot_defense_choice": "[\"bot_defense\"]",
            "x-ves-oneof-field-challenge_type": "[\"captcha_challenge\",\"enable_challenge\",\"js_challenge\",\"no_challenge\",\"policy_based_challenge\"]",
            "x-ves-oneof-field-client_side_defense_choice": "[\"client_side_defense\",\"disable_client_side_defense\"]",
            "x-ves-oneof-field-ip_reputation_choice": "[\"disable_ip_reputation\",\"enable_ip_reputation\"]",
            "x-ves-oneof-field-l7_ddos_auto_mitigation_action": "[\"l7_ddos_action_block\",\"l7_ddos_action_default\",\"l7_ddos_action_js_challenge\"]",
            "x-ves-oneof-field-loadbalancer_type": "[\"http\",\"https\",\"https_auto_cert\"]",
            "x-ves-oneof-field-malicious_user_detection_choice": "[\"disable_malicious_user_detection\",\"enable_malicious_user_detection\"]",
            "x-ves-oneof-field-rate_limit_choice": "[\"api_rate_limit\",\"disable_rate_limit\",\"rate_limit\"]",
            "x-ves-oneof-field-sensitive_data_policy_choice": "[\"default_sensitive_data_policy\",\"sensitive_data_policy\"]",
            "x-ves-oneof-field-service_policy_choice": "[\"active_service_policies\",\"no_service_policies\",\"service_policies_from_namespace\"]",
            "x-ves-oneof-field-slow_ddos_mitigation_choice": "[\"slow_ddos_mitigation\",\"system_default_timeouts\"]",
            "x-ves-oneof-field-threat_mesh_choice": "[\"disable_threat_mesh\",\"enable_threat_mesh\"]",
            "x-ves-oneof-field-user_id_choice": "[\"user_id_client_ip\",\"user_identification\"]",
            "x-ves-oneof-field-waf_choice": "[\"app_firewall\",\"disable_waf\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.CreateSpecType",
            "properties": {
                "active_service_policies": {
                    "description": "Exclusive with [no_service_policies service_policies_from_namespace]\n Apply the specified list of service policies and bypass the namespace service policy set",
                    "$ref": "#/definitions/common_wafServicePolicyList",
                    "x-displayname": "Apply Specified Service Policies"
                },
                "api_rate_limit": {
                    "description": "Exclusive with [disable_rate_limit rate_limit]\n Define rate limiting for one or more API endpoints",
                    "$ref": "#/definitions/common_wafAPIRateLimit",
                    "x-displayname": "API Rate Limit"
                },
                "api_specification": {
                    "description": "Exclusive with [disable_api_definition]\n Specify API definition and OpenAPI Validation",
                    "$ref": "#/definitions/common_wafAPISpecificationSettings",
                    "x-displayname": "Enable for All Requests"
                },
                "app_firewall": {
                    "description": "Exclusive with [disable_waf]\n Enable WAF configuration for all requests in this distribution",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Enable for All Requests"
                },
                "blocked_clients": {
                    "type": "array",
                    "description": " Define rules to block IP Prefixes or AS numbers.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/common_wafSimpleClientSrcRule"
                    },
                    "x-displayname": "Client Blocking Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "bot_defense": {
                    "description": "Exclusive with []\n Select Bot Defense Standard",
                    "$ref": "#/definitions/common_securityShapeBotDefenseType",
                    "x-displayname": "Enable Bot Defense Standard"
                },
                "cache_rules": {
                    "type": "array",
                    "description": " Rules are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 8\n  ves.io.schema.rules.repeated.unique: true\n",
                    "maxItems": 8,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCDNCacheRule"
                    },
                    "x-displayname": "Cache Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "8",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "captcha_challenge": {
                    "description": "Exclusive with [enable_challenge js_challenge no_challenge policy_based_challenge]\n Configure Captcha challenge on this load balancer",
                    "$ref": "#/definitions/virtual_hostCaptchaChallengeType",
                    "x-displayname": "Captcha Challenge"
                },
                "client_side_defense": {
                    "description": "Exclusive with [disable_client_side_defense]\n Client-Side Defense configuration for JavaScript insertion",
                    "$ref": "#/definitions/common_securityClientSideDefenseType",
                    "x-displayname": "Enable"
                },
                "cors_policy": {
                    "description": " Cross-Origin Resource Sharing requests configuration\n\n CORS is a mechanism that uses additional HTTP headers to tell a browser to let\n a web application running at one origin (domain) have permission to access selected\n resources from a server at a different origin",
                    "$ref": "#/definitions/schemaCorsPolicy",
                    "x-displayname": "CORS Policy"
                },
                "csrf_policy": {
                    "description": " Cross-Site Request Forgery (CSRF) is an attack that occurs when a malicious third-party website exploits a vulnerability thats allows them to submit an undesired request on user's behalf.\n\n The policy checks where a request is coming from to determine if the request's origin is the same as its destination. The policy relies on two pieces of information used in determining if a request originated from the same host.\n\n 1. The origin that caused the user agent to issue the request (source origin).\n 2. The origin that the request is going to (target origin).\n When the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being the source-origin has been added to the policy as valid.\n Because CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).",
                    "$ref": "#/definitions/schemaCsrfPolicy",
                    "x-displayname": "Cross-Site Request Forgery Protection"
                },
                "data_guard_rules": {
                    "type": "array",
                    "description": " Data Guard prevents responses from exposing sensitive information by masking the data.\n The system masks credit card numbers and social security numbers leaked from the application from within the http response with a string of asterisks (*).\n Note: App Firewall should be enabled, to use Data Guard feature.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policySimpleDataGuardRule"
                    },
                    "x-displayname": "Data Guard Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "ddos_mitigation_rules": {
                    "type": "array",
                    "description": " Define manual mitigation rules to block L7 DDoS attacks.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/common_securityDDoSMitigationRule"
                    },
                    "x-displayname": "DDoS Mitigation Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "default_cache_action": {
                    "description": " Default value for Cache action.",
                    "$ref": "#/definitions/cdn_loadbalancerDefaultCacheAction",
                    "x-displayname": "Default Cache Action"
                },
                "default_sensitive_data_policy": {
                    "description": "Exclusive with [sensitive_data_policy]\n Apply system default sensitive data discovery",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "disable_api_definition": {
                    "description": "Exclusive with [api_specification]\n API Definition is not currently used for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_api_discovery": {
                    "description": "Exclusive with [enable_api_discovery]\n Disable api discovery for this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_client_side_defense": {
                    "description": "Exclusive with [client_side_defense]\n No Client-Side Defense configuration for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_ip_reputation": {
                    "description": "Exclusive with [enable_ip_reputation]\n No IP reputation configured this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_malicious_user_detection": {
                    "description": "Exclusive with [enable_malicious_user_detection]\n Disable malicious user detection for this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_rate_limit": {
                    "description": "Exclusive with [api_rate_limit rate_limit]\n Rate limiting is not currently enabled for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_threat_mesh": {
                    "description": "Exclusive with [enable_threat_mesh]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_waf": {
                    "description": "Exclusive with [app_firewall]\n No WAF configuration for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "domains": {
                    "type": "array",
                    "description": " A list of fully qualified domain names.\n The CDN Distribution will be setup for these FQDN name(s).\n [This can be a domain or a sub-domain]\n\nExample: - \"www.foo.com\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.hostname: true\n  ves.io.schema.rules.repeated.items.string.max_len: 256\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.items.string.pattern: [\\\\.]+[A-Za-z]+\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "minItems": 1,
                    "maxItems": 32,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 256
                    },
                    "x-displayname": "Domains",
                    "x-ves-example": "www.foo.com",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.hostname": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "256",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.items.string.pattern": "[\\\\.]+[A-Za-z]+",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "enable_api_discovery": {
                    "description": "Exclusive with [disable_api_discovery]\n Enable api discovery for all requests in this distribution",
                    "$ref": "#/definitions/common_wafApiDiscoverySetting",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_challenge": {
                    "description": "Exclusive with [captcha_challenge js_challenge no_challenge policy_based_challenge]\n Configure auto mitigation i.e risk based challenges for malicious users for this load balancer",
                    "$ref": "#/definitions/common_wafEnableChallenge",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_ip_reputation": {
                    "description": "Exclusive with [disable_ip_reputation]\n Enable IP reputation for all requests in this distribution",
                    "$ref": "#/definitions/viewscommon_wafIPThreatCategoryListType",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_malicious_user_detection": {
                    "description": "Exclusive with [disable_malicious_user_detection]\n Enable malicious user detection for all requests in this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_threat_mesh": {
                    "description": "Exclusive with [disable_threat_mesh]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable"
                },
                "graphql_rules": {
                    "type": "array",
                    "description": " GraphQL is a query language and server-side runtime for APIs which provides a complete and understandable\n description of the data in API. GraphQL gives clients the power to ask for exactly what they need, makes it\n easier to evolve APIs over time, and enables powerful developer tools. Policy configuration to analyze GraphQL\n queries and prevent GraphQL tailored attacks.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyGraphQLRule"
                    },
                    "x-displayname": "GraphQL Inspection",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "http": {
                    "description": "Exclusive with [https https_auto_cert]\n CDN Distribution serving content over HTTP",
                    "$ref": "#/definitions/http_loadbalancerProxyTypeHttp",
                    "x-displayname": "HTTP"
                },
                "https": {
                    "description": "Exclusive with [http https_auto_cert]\n CDN Distribution with a custom public/private certificate.\n This is also known as BYOC (Bring Your Own Certificate).\n User is responsible for managing DNS.",
                    "$ref": "#/definitions/cdn_loadbalancerCDNHTTPSCustomCertsType",
                    "x-displayname": "HTTPS with Custom Certificate"
                },
                "https_auto_cert": {
                    "description": "Exclusive with [http https]\n HTTPS based CDN Distribution serving with automatic public certificate provisioning.\n This requires the domains to be delegated to F5XC using Delegated Domain feature.\n DNS records will be managed by Volterra.",
                    "$ref": "#/definitions/cdn_loadbalancerCDNHTTPSAutoCertsType",
                    "x-displayname": "HTTPS with Automatic Certificate"
                },
                "js_challenge": {
                    "description": "Exclusive with [captcha_challenge enable_challenge no_challenge policy_based_challenge]\n Configure JavaScript challenge on this load balancer",
                    "$ref": "#/definitions/virtual_hostJavascriptChallengeType",
                    "x-displayname": "JavaScript Challenge"
                },
                "jwt_validation": {
                    "description": " JWT Validation stops JWT replay attacks and JWT tampering by cryptographically verifying incoming\n JWTs before they are passed to origin APIs. JWT Validation will also stop requests with expired\n tokens or tokens that are not yet valid.",
                    "$ref": "#/definitions/common_wafJWTValidation",
                    "x-displayname": "JWT Validation"
                },
                "l7_ddos_action_block": {
                    "description": "Exclusive with [l7_ddos_action_default l7_ddos_action_js_challenge]\n Block suspicious sources",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Block"
                },
                "l7_ddos_action_default": {
                    "description": "Exclusive with [l7_ddos_action_block l7_ddos_action_js_challenge]\n Block suspicious sources",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "l7_ddos_action_js_challenge": {
                    "description": "Exclusive with [l7_ddos_action_block l7_ddos_action_default]\n Serve JavaScript challenge to suspicious sources",
                    "$ref": "#/definitions/virtual_hostJavascriptChallengeType",
                    "x-displayname": "JavaScript Challenge"
                },
                "no_challenge": {
                    "description": "Exclusive with [captcha_challenge enable_challenge js_challenge policy_based_challenge]\n No challenge is enabled for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "no_service_policies": {
                    "description": "Exclusive with [active_service_policies service_policies_from_namespace]\n Do not apply any service policies i.e. bypass the namespace service policy set",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Do Not Apply Service Policies"
                },
                "origin_pool": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Origin Pool",
                    "$ref": "#/definitions/cdn_loadbalancerCdnOriginPoolType",
                    "x-displayname": "CDN Origin Pool",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "other_settings": {
                    "$ref": "#/definitions/cdn_loadbalancerOtherSettings",
                    "x-displayname": "Other Settings"
                },
                "policy_based_challenge": {
                    "description": "Exclusive with [captcha_challenge enable_challenge js_challenge no_challenge]\n Specifies the settings for policy rule based challenge",
                    "$ref": "#/definitions/viewscommon_wafPolicyBasedChallenge",
                    "x-displayname": "Policy Based Challenge"
                },
                "protected_cookies": {
                    "type": "array",
                    "description": " Allows setting attributes (SameSite, Secure, and HttpOnly) on cookies in responses.\n Cookie Tampering Protection prevents attackers from modifying the value of session cookies.\n For Cookie Tampering Protection, enabling a web app firewall (WAF) is a prerequisite.\n The configured mode of WAF (monitoring or blocking) will be enforced on the request when cookie tampering is identified.\n Note: We recommend enabling Secure and HttpOnly attributes along with cookie tampering protection.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaCookieManipulationOptionType"
                    },
                    "x-displayname": "Cookie Protection",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "rate_limit": {
                    "description": "Exclusive with [api_rate_limit disable_rate_limit]\n Define custom rate limiting parameters for this load balancer",
                    "$ref": "#/definitions/common_wafRateLimitConfigType",
                    "x-displayname": "Custom Rate Limiting Parameters"
                },
                "sensitive_data_policy": {
                    "description": "Exclusive with [default_sensitive_data_policy]\n Apply custom sensitive data discovery",
                    "$ref": "#/definitions/common_securitySensitiveDataPolicySettings",
                    "x-displayname": "Custom"
                },
                "service_policies_from_namespace": {
                    "description": "Exclusive with [active_service_policies no_service_policies]\n Apply the active service policies configured as part of the namespace service policy set",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Apply Namespace Service Policies"
                },
                "slow_ddos_mitigation": {
                    "description": "Exclusive with [system_default_timeouts]\n Custom Settings for Slow DDoS Mitigation",
                    "$ref": "#/definitions/virtual_hostSlowDDoSMitigation",
                    "x-displayname": "Custom"
                },
                "system_default_timeouts": {
                    "description": "Exclusive with [slow_ddos_mitigation]\n Default Settings for Slow DDoS Mitigation",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "trusted_clients": {
                    "type": "array",
                    "description": " Define rules to skip processing of one or more features such as WAF, Bot Defense etc. for clients.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/common_wafSimpleClientSrcRule"
                    },
                    "x-displayname": "Trusted Client Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "user_id_client_ip": {
                    "description": "Exclusive with [user_identification]\n Use the Client IP address as the user identifier.",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Client IP Address"
                },
                "user_identification": {
                    "description": "Exclusive with [user_id_client_ip]\n A reference to user_identification object.\n The rules in the user_identification object are evaluated to determine the user identifier.",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "User Identification Policy"
                },
                "waf_exclusion_rules": {
                    "type": "array",
                    "description": " Define the Signature IDs, Violations, Attack Types and Bot Names that should be excluded from WAF processing on specific match criteria.\n The match criteria include domain, path and method.\n WAF Exclusion rules is a sequential engine where rules are evaluated one after the other.\n It's important to define the correct order for WAF exclusion rules to get the intended result, rules are evaluated from top to bottom in the list.\n For each request, its characteristics are evaluated based on the match criteria in each WAF exclusion rule, starting from the top.\n When an exclusion rule is matched, then this exclusion rule takes effect and no more rules are evaluated.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/policySimpleWafExclusionRule"
                    },
                    "x-displayname": "WAF Exclusion Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                }
            }
        },
        "viewscdn_loadbalancerGetSpecType": {
            "type": "object",
            "description": "Shape of the CDN loadbalancer specification",
            "title": "GetSpecType",
            "x-displayname": "Get CDN Loadbalancer",
            "x-ves-oneof-field-api_definition_choice": "[\"api_specification\",\"disable_api_definition\"]",
            "x-ves-oneof-field-api_discovery_choice": "[\"disable_api_discovery\",\"enable_api_discovery\"]",
            "x-ves-oneof-field-bot_defense_choice": "[\"bot_defense\"]",
            "x-ves-oneof-field-challenge_type": "[\"captcha_challenge\",\"enable_challenge\",\"js_challenge\",\"no_challenge\",\"policy_based_challenge\"]",
            "x-ves-oneof-field-client_side_defense_choice": "[\"client_side_defense\",\"disable_client_side_defense\"]",
            "x-ves-oneof-field-ip_reputation_choice": "[\"disable_ip_reputation\",\"enable_ip_reputation\"]",
            "x-ves-oneof-field-l7_ddos_auto_mitigation_action": "[\"l7_ddos_action_block\",\"l7_ddos_action_default\",\"l7_ddos_action_js_challenge\"]",
            "x-ves-oneof-field-loadbalancer_type": "[\"http\",\"https\",\"https_auto_cert\"]",
            "x-ves-oneof-field-malicious_user_detection_choice": "[\"disable_malicious_user_detection\",\"enable_malicious_user_detection\"]",
            "x-ves-oneof-field-rate_limit_choice": "[\"api_rate_limit\",\"disable_rate_limit\",\"rate_limit\"]",
            "x-ves-oneof-field-sensitive_data_policy_choice": "[\"default_sensitive_data_policy\",\"sensitive_data_policy\"]",
            "x-ves-oneof-field-service_policy_choice": "[\"active_service_policies\",\"no_service_policies\",\"service_policies_from_namespace\"]",
            "x-ves-oneof-field-slow_ddos_mitigation_choice": "[\"slow_ddos_mitigation\",\"system_default_timeouts\"]",
            "x-ves-oneof-field-threat_mesh_choice": "[\"disable_threat_mesh\",\"enable_threat_mesh\"]",
            "x-ves-oneof-field-user_id_choice": "[\"user_id_client_ip\",\"user_identification\"]",
            "x-ves-oneof-field-waf_choice": "[\"app_firewall\",\"disable_waf\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.GetSpecType",
            "properties": {
                "active_service_policies": {
                    "description": "Exclusive with [no_service_policies service_policies_from_namespace]\n Apply the specified list of service policies and bypass the namespace service policy set",
                    "$ref": "#/definitions/common_wafServicePolicyList",
                    "x-displayname": "Apply Specified Service Policies"
                },
                "api_rate_limit": {
                    "description": "Exclusive with [disable_rate_limit rate_limit]\n Define rate limiting for one or more API endpoints",
                    "$ref": "#/definitions/common_wafAPIRateLimit",
                    "x-displayname": "API Rate Limit"
                },
                "api_specification": {
                    "description": "Exclusive with [disable_api_definition]\n Specify API definition and OpenAPI Validation",
                    "$ref": "#/definitions/common_wafAPISpecificationSettings",
                    "x-displayname": "Enable for All Requests"
                },
                "app_firewall": {
                    "description": "Exclusive with [disable_waf]\n Enable WAF configuration for all requests in this distribution",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Enable for All Requests"
                },
                "auto_cert_info": {
                    "description": " Auto certificate related information",
                    "$ref": "#/definitions/virtual_hostAutoCertInfoType",
                    "x-displayname": "Auto Cert Information"
                },
                "blocked_clients": {
                    "type": "array",
                    "description": " Define rules to block IP Prefixes or AS numbers.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/common_wafSimpleClientSrcRule"
                    },
                    "x-displayname": "Client Blocking Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "bot_defense": {
                    "description": "Exclusive with []\n Select Bot Defense Standard",
                    "$ref": "#/definitions/common_securityShapeBotDefenseType",
                    "x-displayname": "Enable Bot Defense Standard"
                },
                "cache_rules": {
                    "type": "array",
                    "description": " Rules are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 8\n  ves.io.schema.rules.repeated.unique: true\n",
                    "maxItems": 8,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCDNCacheRule"
                    },
                    "x-displayname": "Cache Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "8",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "captcha_challenge": {
                    "description": "Exclusive with [enable_challenge js_challenge no_challenge policy_based_challenge]\n Configure Captcha challenge on this load balancer",
                    "$ref": "#/definitions/virtual_hostCaptchaChallengeType",
                    "x-displayname": "Captcha Challenge"
                },
                "cert_state": {
                    "description": " State of Custom certificate or Auto certificate generation.",
                    "$ref": "#/definitions/virtual_hostCertificationState",
                    "x-displayname": "Cert State"
                },
                "client_side_defense": {
                    "description": "Exclusive with [disable_client_side_defense]\n Client-Side Defense configuration for JavaScript insertion",
                    "$ref": "#/definitions/common_securityClientSideDefenseType",
                    "x-displayname": "Enable"
                },
                "cors_policy": {
                    "description": " Cross-Origin Resource Sharing requests configuration\n\n CORS is a mechanism that uses additional HTTP headers to tell a browser to let\n a web application running at one origin (domain) have permission to access selected\n resources from a server at a different origin",
                    "$ref": "#/definitions/schemaCorsPolicy",
                    "x-displayname": "CORS Policy"
                },
                "csrf_policy": {
                    "description": " Cross-Site Request Forgery (CSRF) is an attack that occurs when a malicious third-party website exploits a vulnerability thats allows them to submit an undesired request on user's behalf.\n\n The policy checks where a request is coming from to determine if the request's origin is the same as its destination. The policy relies on two pieces of information used in determining if a request originated from the same host.\n\n 1. The origin that caused the user agent to issue the request (source origin).\n 2. The origin that the request is going to (target origin).\n When the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being the source-origin has been added to the policy as valid.\n Because CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).",
                    "$ref": "#/definitions/schemaCsrfPolicy",
                    "x-displayname": "Cross-Site Request Forgery Protection"
                },
                "data_guard_rules": {
                    "type": "array",
                    "description": " Data Guard prevents responses from exposing sensitive information by masking the data.\n The system masks credit card numbers and social security numbers leaked from the application from within the http response with a string of asterisks (*).\n Note: App Firewall should be enabled, to use Data Guard feature.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policySimpleDataGuardRule"
                    },
                    "x-displayname": "Data Guard Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "ddos_mitigation_rules": {
                    "type": "array",
                    "description": " Define manual mitigation rules to block L7 DDoS attacks.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/common_securityDDoSMitigationRule"
                    },
                    "x-displayname": "DDoS Mitigation Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "default_cache_action": {
                    "description": " Default value for Cache action.",
                    "$ref": "#/definitions/cdn_loadbalancerDefaultCacheAction",
                    "x-displayname": "Default Cache Action"
                },
                "default_sensitive_data_policy": {
                    "description": "Exclusive with [sensitive_data_policy]\n Apply system default sensitive data discovery",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "disable_api_definition": {
                    "description": "Exclusive with [api_specification]\n API Definition is not currently used for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_api_discovery": {
                    "description": "Exclusive with [enable_api_discovery]\n Disable api discovery for this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_client_side_defense": {
                    "description": "Exclusive with [client_side_defense]\n No Client-Side Defense configuration for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_ip_reputation": {
                    "description": "Exclusive with [enable_ip_reputation]\n No IP reputation configured this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_malicious_user_detection": {
                    "description": "Exclusive with [enable_malicious_user_detection]\n Disable malicious user detection for this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_rate_limit": {
                    "description": "Exclusive with [api_rate_limit rate_limit]\n Rate limiting is not currently enabled for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_threat_mesh": {
                    "description": "Exclusive with [enable_threat_mesh]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_waf": {
                    "description": "Exclusive with [app_firewall]\n No WAF configuration for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "dns_info": {
                    "type": "array",
                    "description": " DNS information for this virtual host",
                    "items": {
                        "$ref": "#/definitions/virtual_host_dns_infoDnsInfo"
                    },
                    "x-displayname": "DNS Information"
                },
                "domains": {
                    "type": "array",
                    "description": " A list of fully qualified domain names.\n The CDN Distribution will be setup for these FQDN name(s).\n [This can be a domain or a sub-domain]\n\nExample: - \"www.foo.com\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.hostname: true\n  ves.io.schema.rules.repeated.items.string.max_len: 256\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.items.string.pattern: [\\\\.]+[A-Za-z]+\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "minItems": 1,
                    "maxItems": 32,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 256
                    },
                    "x-displayname": "Domains",
                    "x-ves-example": "www.foo.com",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.hostname": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "256",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.items.string.pattern": "[\\\\.]+[A-Za-z]+",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "enable_api_discovery": {
                    "description": "Exclusive with [disable_api_discovery]\n Enable api discovery for all requests in this distribution",
                    "$ref": "#/definitions/common_wafApiDiscoverySetting",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_challenge": {
                    "description": "Exclusive with [captcha_challenge js_challenge no_challenge policy_based_challenge]\n Configure auto mitigation i.e risk based challenges for malicious users for this load balancer",
                    "$ref": "#/definitions/common_wafEnableChallenge",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_ip_reputation": {
                    "description": "Exclusive with [disable_ip_reputation]\n Enable IP reputation for all requests in this distribution",
                    "$ref": "#/definitions/viewscommon_wafIPThreatCategoryListType",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_malicious_user_detection": {
                    "description": "Exclusive with [disable_malicious_user_detection]\n Enable malicious user detection for all requests in this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_threat_mesh": {
                    "description": "Exclusive with [disable_threat_mesh]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable"
                },
                "graphql_rules": {
                    "type": "array",
                    "description": " GraphQL is a query language and server-side runtime for APIs which provides a complete and understandable\n description of the data in API. GraphQL gives clients the power to ask for exactly what they need, makes it\n easier to evolve APIs over time, and enables powerful developer tools. Policy configuration to analyze GraphQL\n queries and prevent GraphQL tailored attacks.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyGraphQLRule"
                    },
                    "x-displayname": "GraphQL Inspection",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "host_name": {
                    "type": "string",
                    "description": " Internally generated host name to be used for the virtual host\n\nExample: - \"ves-io-cf8684b9-a18f-4843-a24f-1f9ee8ea2776.ac.vh.ves.io\"-",
                    "x-displayname": "Host Name",
                    "x-ves-example": "ves-io-cf8684b9-a18f-4843-a24f-1f9ee8ea2776.ac.vh.ves.io"
                },
                "http": {
                    "description": "Exclusive with [https https_auto_cert]\n CDN Distribution serving content over HTTP",
                    "$ref": "#/definitions/http_loadbalancerProxyTypeHttp",
                    "x-displayname": "HTTP"
                },
                "https": {
                    "description": "Exclusive with [http https_auto_cert]\n CDN Distribution with a custom public/private certificate.\n This is also known as BYOC (Bring Your Own Certificate).\n User is responsible for managing DNS.",
                    "$ref": "#/definitions/cdn_loadbalancerCDNHTTPSCustomCertsType",
                    "x-displayname": "HTTPS with Custom Certificate"
                },
                "https_auto_cert": {
                    "description": "Exclusive with [http https]\n HTTPS based CDN Distribution serving with automatic public certificate provisioning.\n This requires the domains to be delegated to F5XC using Delegated Domain feature.\n DNS records will be managed by Volterra.",
                    "$ref": "#/definitions/cdn_loadbalancerCDNHTTPSAutoCertsType",
                    "x-displayname": "HTTPS with Automatic Certificate"
                },
                "js_challenge": {
                    "description": "Exclusive with [captcha_challenge enable_challenge no_challenge policy_based_challenge]\n Configure JavaScript challenge on this load balancer",
                    "$ref": "#/definitions/virtual_hostJavascriptChallengeType",
                    "x-displayname": "JavaScript Challenge"
                },
                "jwt_validation": {
                    "description": " JWT Validation stops JWT replay attacks and JWT tampering by cryptographically verifying incoming\n JWTs before they are passed to origin APIs. JWT Validation will also stop requests with expired\n tokens or tokens that are not yet valid.",
                    "$ref": "#/definitions/common_wafJWTValidation",
                    "x-displayname": "JWT Validation"
                },
                "l7_ddos_action_block": {
                    "description": "Exclusive with [l7_ddos_action_default l7_ddos_action_js_challenge]\n Block suspicious sources",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Block"
                },
                "l7_ddos_action_default": {
                    "description": "Exclusive with [l7_ddos_action_block l7_ddos_action_js_challenge]\n Block suspicious sources",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "l7_ddos_action_js_challenge": {
                    "description": "Exclusive with [l7_ddos_action_block l7_ddos_action_default]\n Serve JavaScript challenge to suspicious sources",
                    "$ref": "#/definitions/virtual_hostJavascriptChallengeType",
                    "x-displayname": "JavaScript Challenge"
                },
                "no_challenge": {
                    "description": "Exclusive with [captcha_challenge enable_challenge js_challenge policy_based_challenge]\n No challenge is enabled for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "no_service_policies": {
                    "description": "Exclusive with [active_service_policies service_policies_from_namespace]\n Do not apply any service policies i.e. bypass the namespace service policy set",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Do Not Apply Service Policies"
                },
                "origin_pool": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "$ref": "#/definitions/cdn_loadbalancerCdnOriginPoolType",
                    "x-displayname": "CDN Origin Pool",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "other_settings": {
                    "$ref": "#/definitions/cdn_loadbalancerOtherSettings",
                    "x-displayname": "Other Settings"
                },
                "policy_based_challenge": {
                    "description": "Exclusive with [captcha_challenge enable_challenge js_challenge no_challenge]\n Specifies the settings for policy rule based challenge",
                    "$ref": "#/definitions/viewscommon_wafPolicyBasedChallenge",
                    "x-displayname": "Policy Based Challenge"
                },
                "protected_cookies": {
                    "type": "array",
                    "description": " Allows setting attributes (SameSite, Secure, and HttpOnly) on cookies in responses.\n Cookie Tampering Protection prevents attackers from modifying the value of session cookies.\n For Cookie Tampering Protection, enabling a web app firewall (WAF) is a prerequisite.\n The configured mode of WAF (monitoring or blocking) will be enforced on the request when cookie tampering is identified.\n Note: We recommend enabling Secure and HttpOnly attributes along with cookie tampering protection.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaCookieManipulationOptionType"
                    },
                    "x-displayname": "Cookie Protection",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "rate_limit": {
                    "description": "Exclusive with [api_rate_limit disable_rate_limit]\n Define custom rate limiting parameters for this load balancer",
                    "$ref": "#/definitions/common_wafRateLimitConfigType",
                    "x-displayname": "Custom Rate Limiting Parameters"
                },
                "sensitive_data_policy": {
                    "description": "Exclusive with [default_sensitive_data_policy]\n Apply custom sensitive data discovery",
                    "$ref": "#/definitions/common_securitySensitiveDataPolicySettings",
                    "x-displayname": "Custom"
                },
                "service_domains": {
                    "type": "array",
                    "description": " CNAME provided from service per domain",
                    "items": {
                        "$ref": "#/definitions/virtual_hostServiceDomain"
                    },
                    "x-displayname": "Service Domains"
                },
                "service_policies_from_namespace": {
                    "description": "Exclusive with [active_service_policies no_service_policies]\n Apply the active service policies configured as part of the namespace service policy set",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Apply Namespace Service Policies"
                },
                "slow_ddos_mitigation": {
                    "description": "Exclusive with [system_default_timeouts]\n Custom Settings for Slow DDoS Mitigation",
                    "$ref": "#/definitions/virtual_hostSlowDDoSMitigation",
                    "x-displayname": "Custom"
                },
                "state": {
                    "description": " State of the virtual host",
                    "$ref": "#/definitions/virtual_hostVirtualHostState",
                    "x-displayname": "Virtual Host State"
                },
                "system_default_timeouts": {
                    "description": "Exclusive with [slow_ddos_mitigation]\n Default Settings for Slow DDoS Mitigation",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "trusted_clients": {
                    "type": "array",
                    "description": " Define rules to skip processing of one or more features such as WAF, Bot Defense etc. for clients.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/common_wafSimpleClientSrcRule"
                    },
                    "x-displayname": "Trusted Client Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "user_id_client_ip": {
                    "description": "Exclusive with [user_identification]\n Use the Client IP address as the user identifier.",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Client IP Address"
                },
                "user_identification": {
                    "description": "Exclusive with [user_id_client_ip]\n A reference to user_identification object.\n The rules in the user_identification object are evaluated to determine the user identifier.",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "User Identification Policy"
                },
                "waf_exclusion_rules": {
                    "type": "array",
                    "description": " Define the Signature IDs, Violations, Attack Types and Bot Names that should be excluded from WAF processing on specific match criteria.\n The match criteria include domain, path and method.\n WAF Exclusion rules is a sequential engine where rules are evaluated one after the other.\n It's important to define the correct order for WAF exclusion rules to get the intended result, rules are evaluated from top to bottom in the list.\n For each request, its characteristics are evaluated based on the match criteria in each WAF exclusion rule, starting from the top.\n When an exclusion rule is matched, then this exclusion rule takes effect and no more rules are evaluated.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/policySimpleWafExclusionRule"
                    },
                    "x-displayname": "WAF Exclusion Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                }
            }
        },
        "viewscdn_loadbalancerReplaceSpecType": {
            "type": "object",
            "description": "Shape of the CDN loadbalancer specification",
            "title": "ReplaceSpecType",
            "x-displayname": "Replace CDN Loadbalancer",
            "x-ves-oneof-field-api_definition_choice": "[\"api_specification\",\"disable_api_definition\"]",
            "x-ves-oneof-field-api_discovery_choice": "[\"disable_api_discovery\",\"enable_api_discovery\"]",
            "x-ves-oneof-field-bot_defense_choice": "[\"bot_defense\"]",
            "x-ves-oneof-field-challenge_type": "[\"captcha_challenge\",\"enable_challenge\",\"js_challenge\",\"no_challenge\",\"policy_based_challenge\"]",
            "x-ves-oneof-field-client_side_defense_choice": "[\"client_side_defense\",\"disable_client_side_defense\"]",
            "x-ves-oneof-field-ip_reputation_choice": "[\"disable_ip_reputation\",\"enable_ip_reputation\"]",
            "x-ves-oneof-field-l7_ddos_auto_mitigation_action": "[\"l7_ddos_action_block\",\"l7_ddos_action_default\",\"l7_ddos_action_js_challenge\"]",
            "x-ves-oneof-field-loadbalancer_type": "[\"http\",\"https\",\"https_auto_cert\"]",
            "x-ves-oneof-field-malicious_user_detection_choice": "[\"disable_malicious_user_detection\",\"enable_malicious_user_detection\"]",
            "x-ves-oneof-field-rate_limit_choice": "[\"api_rate_limit\",\"disable_rate_limit\",\"rate_limit\"]",
            "x-ves-oneof-field-sensitive_data_policy_choice": "[\"default_sensitive_data_policy\",\"sensitive_data_policy\"]",
            "x-ves-oneof-field-service_policy_choice": "[\"active_service_policies\",\"no_service_policies\",\"service_policies_from_namespace\"]",
            "x-ves-oneof-field-slow_ddos_mitigation_choice": "[\"slow_ddos_mitigation\",\"system_default_timeouts\"]",
            "x-ves-oneof-field-threat_mesh_choice": "[\"disable_threat_mesh\",\"enable_threat_mesh\"]",
            "x-ves-oneof-field-user_id_choice": "[\"user_id_client_ip\",\"user_identification\"]",
            "x-ves-oneof-field-waf_choice": "[\"app_firewall\",\"disable_waf\"]",
            "x-ves-proto-message": "ves.io.schema.views.cdn_loadbalancer.ReplaceSpecType",
            "properties": {
                "active_service_policies": {
                    "description": "Exclusive with [no_service_policies service_policies_from_namespace]\n Apply the specified list of service policies and bypass the namespace service policy set",
                    "$ref": "#/definitions/common_wafServicePolicyList",
                    "x-displayname": "Apply Specified Service Policies"
                },
                "api_rate_limit": {
                    "description": "Exclusive with [disable_rate_limit rate_limit]\n Define rate limiting for one or more API endpoints",
                    "$ref": "#/definitions/common_wafAPIRateLimit",
                    "x-displayname": "API Rate Limit"
                },
                "api_specification": {
                    "description": "Exclusive with [disable_api_definition]\n Specify API definition and OpenAPI Validation",
                    "$ref": "#/definitions/common_wafAPISpecificationSettings",
                    "x-displayname": "Enable for All Requests"
                },
                "app_firewall": {
                    "description": "Exclusive with [disable_waf]\n Enable WAF configuration for all requests in this distribution",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Enable for All Requests"
                },
                "blocked_clients": {
                    "type": "array",
                    "description": " Define rules to block IP Prefixes or AS numbers.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/common_wafSimpleClientSrcRule"
                    },
                    "x-displayname": "Client Blocking Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "bot_defense": {
                    "description": "Exclusive with []\n Select Bot Defense Standard",
                    "$ref": "#/definitions/common_securityShapeBotDefenseType",
                    "x-displayname": "Enable Bot Defense Standard"
                },
                "cache_rules": {
                    "type": "array",
                    "description": " Rules are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 8\n  ves.io.schema.rules.repeated.unique: true\n",
                    "maxItems": 8,
                    "items": {
                        "$ref": "#/definitions/cdn_loadbalancerCDNCacheRule"
                    },
                    "x-displayname": "Cache Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "8",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "captcha_challenge": {
                    "description": "Exclusive with [enable_challenge js_challenge no_challenge policy_based_challenge]\n Configure Captcha challenge on this load balancer",
                    "$ref": "#/definitions/virtual_hostCaptchaChallengeType",
                    "x-displayname": "Captcha Challenge"
                },
                "client_side_defense": {
                    "description": "Exclusive with [disable_client_side_defense]\n Client-Side Defense configuration for JavaScript insertion",
                    "$ref": "#/definitions/common_securityClientSideDefenseType",
                    "x-displayname": "Enable"
                },
                "cors_policy": {
                    "description": " Cross-Origin Resource Sharing requests configuration\n\n CORS is a mechanism that uses additional HTTP headers to tell a browser to let\n a web application running at one origin (domain) have permission to access selected\n resources from a server at a different origin",
                    "$ref": "#/definitions/schemaCorsPolicy",
                    "x-displayname": "CORS Policy"
                },
                "csrf_policy": {
                    "description": " Cross-Site Request Forgery (CSRF) is an attack that occurs when a malicious third-party website exploits a vulnerability thats allows them to submit an undesired request on user's behalf.\n\n The policy checks where a request is coming from to determine if the request's origin is the same as its destination. The policy relies on two pieces of information used in determining if a request originated from the same host.\n\n 1. The origin that caused the user agent to issue the request (source origin).\n 2. The origin that the request is going to (target origin).\n When the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being the source-origin has been added to the policy as valid.\n Because CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).",
                    "$ref": "#/definitions/schemaCsrfPolicy",
                    "x-displayname": "Cross-Site Request Forgery Protection"
                },
                "data_guard_rules": {
                    "type": "array",
                    "description": " Data Guard prevents responses from exposing sensitive information by masking the data.\n The system masks credit card numbers and social security numbers leaked from the application from within the http response with a string of asterisks (*).\n Note: App Firewall should be enabled, to use Data Guard feature.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policySimpleDataGuardRule"
                    },
                    "x-displayname": "Data Guard Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "ddos_mitigation_rules": {
                    "type": "array",
                    "description": " Define manual mitigation rules to block L7 DDoS attacks.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/common_securityDDoSMitigationRule"
                    },
                    "x-displayname": "DDoS Mitigation Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "default_cache_action": {
                    "description": " Default value for Cache action.",
                    "$ref": "#/definitions/cdn_loadbalancerDefaultCacheAction",
                    "x-displayname": "Default Cache Action"
                },
                "default_sensitive_data_policy": {
                    "description": "Exclusive with [sensitive_data_policy]\n Apply system default sensitive data discovery",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "disable_api_definition": {
                    "description": "Exclusive with [api_specification]\n API Definition is not currently used for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_api_discovery": {
                    "description": "Exclusive with [enable_api_discovery]\n Disable api discovery for this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_client_side_defense": {
                    "description": "Exclusive with [client_side_defense]\n No Client-Side Defense configuration for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_ip_reputation": {
                    "description": "Exclusive with [enable_ip_reputation]\n No IP reputation configured this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_malicious_user_detection": {
                    "description": "Exclusive with [enable_malicious_user_detection]\n Disable malicious user detection for this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_rate_limit": {
                    "description": "Exclusive with [api_rate_limit rate_limit]\n Rate limiting is not currently enabled for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_threat_mesh": {
                    "description": "Exclusive with [enable_threat_mesh]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "disable_waf": {
                    "description": "Exclusive with [app_firewall]\n No WAF configuration for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "domains": {
                    "type": "array",
                    "description": " A list of fully qualified domain names.\n The CDN Distribution will be setup for these FQDN name(s).\n [This can be a domain or a sub-domain]\n\nExample: - \"www.foo.com\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.hostname: true\n  ves.io.schema.rules.repeated.items.string.max_len: 256\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.items.string.pattern: [\\\\.]+[A-Za-z]+\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "minItems": 1,
                    "maxItems": 32,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 256
                    },
                    "x-displayname": "Domains",
                    "x-ves-example": "www.foo.com",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.hostname": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "256",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.items.string.pattern": "[\\\\.]+[A-Za-z]+",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "enable_api_discovery": {
                    "description": "Exclusive with [disable_api_discovery]\n Enable api discovery for all requests in this distribution",
                    "$ref": "#/definitions/common_wafApiDiscoverySetting",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_challenge": {
                    "description": "Exclusive with [captcha_challenge js_challenge no_challenge policy_based_challenge]\n Configure auto mitigation i.e risk based challenges for malicious users for this load balancer",
                    "$ref": "#/definitions/common_wafEnableChallenge",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_ip_reputation": {
                    "description": "Exclusive with [disable_ip_reputation]\n Enable IP reputation for all requests in this distribution",
                    "$ref": "#/definitions/viewscommon_wafIPThreatCategoryListType",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_malicious_user_detection": {
                    "description": "Exclusive with [disable_malicious_user_detection]\n Enable malicious user detection for all requests in this distribution",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable for All Requests"
                },
                "enable_threat_mesh": {
                    "description": "Exclusive with [disable_threat_mesh]\n",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Enable"
                },
                "graphql_rules": {
                    "type": "array",
                    "description": " GraphQL is a query language and server-side runtime for APIs which provides a complete and understandable\n description of the data in API. GraphQL gives clients the power to ask for exactly what they need, makes it\n easier to evolve APIs over time, and enables powerful developer tools. Policy configuration to analyze GraphQL\n queries and prevent GraphQL tailored attacks.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyGraphQLRule"
                    },
                    "x-displayname": "GraphQL Inspection",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "http": {
                    "description": "Exclusive with [https https_auto_cert]\n CDN Distribution serving content over HTTP",
                    "$ref": "#/definitions/http_loadbalancerProxyTypeHttp",
                    "x-displayname": "HTTP"
                },
                "https": {
                    "description": "Exclusive with [http https_auto_cert]\n CDN Distribution with a custom public/private certificate.\n This is also known as BYOC (Bring Your Own Certificate).\n User is responsible for managing DNS.",
                    "$ref": "#/definitions/cdn_loadbalancerCDNHTTPSCustomCertsType",
                    "x-displayname": "HTTPS with Custom Certificate"
                },
                "https_auto_cert": {
                    "description": "Exclusive with [http https]\n HTTPS based CDN Distribution serving with automatic public certificate provisioning.\n This requires the domains to be delegated to F5XC using Delegated Domain feature.\n DNS records will be managed by Volterra.",
                    "$ref": "#/definitions/cdn_loadbalancerCDNHTTPSAutoCertsType",
                    "x-displayname": "HTTPS with Automatic Certificate"
                },
                "js_challenge": {
                    "description": "Exclusive with [captcha_challenge enable_challenge no_challenge policy_based_challenge]\n Configure JavaScript challenge on this load balancer",
                    "$ref": "#/definitions/virtual_hostJavascriptChallengeType",
                    "x-displayname": "JavaScript Challenge"
                },
                "jwt_validation": {
                    "description": " JWT Validation stops JWT replay attacks and JWT tampering by cryptographically verifying incoming\n JWTs before they are passed to origin APIs. JWT Validation will also stop requests with expired\n tokens or tokens that are not yet valid.",
                    "$ref": "#/definitions/common_wafJWTValidation",
                    "x-displayname": "JWT Validation"
                },
                "l7_ddos_action_block": {
                    "description": "Exclusive with [l7_ddos_action_default l7_ddos_action_js_challenge]\n Block suspicious sources",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Block"
                },
                "l7_ddos_action_default": {
                    "description": "Exclusive with [l7_ddos_action_block l7_ddos_action_js_challenge]\n Block suspicious sources",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "l7_ddos_action_js_challenge": {
                    "description": "Exclusive with [l7_ddos_action_block l7_ddos_action_default]\n Serve JavaScript challenge to suspicious sources",
                    "$ref": "#/definitions/virtual_hostJavascriptChallengeType",
                    "x-displayname": "JavaScript Challenge"
                },
                "no_challenge": {
                    "description": "Exclusive with [captcha_challenge enable_challenge js_challenge policy_based_challenge]\n No challenge is enabled for this load balancer",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Disable"
                },
                "no_service_policies": {
                    "description": "Exclusive with [active_service_policies service_policies_from_namespace]\n Do not apply any service policies i.e. bypass the namespace service policy set",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Do Not Apply Service Policies"
                },
                "origin_pool": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Origin Pool",
                    "$ref": "#/definitions/cdn_loadbalancerCdnOriginPoolType",
                    "x-displayname": "CDN Origin Pool",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "other_settings": {
                    "$ref": "#/definitions/cdn_loadbalancerOtherSettings",
                    "x-displayname": "Other Settings"
                },
                "policy_based_challenge": {
                    "description": "Exclusive with [captcha_challenge enable_challenge js_challenge no_challenge]\n Specifies the settings for policy rule based challenge",
                    "$ref": "#/definitions/viewscommon_wafPolicyBasedChallenge",
                    "x-displayname": "Policy Based Challenge"
                },
                "protected_cookies": {
                    "type": "array",
                    "description": " Allows setting attributes (SameSite, Secure, and HttpOnly) on cookies in responses.\n Cookie Tampering Protection prevents attackers from modifying the value of session cookies.\n For Cookie Tampering Protection, enabling a web app firewall (WAF) is a prerequisite.\n The configured mode of WAF (monitoring or blocking) will be enforced on the request when cookie tampering is identified.\n Note: We recommend enabling Secure and HttpOnly attributes along with cookie tampering protection.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaCookieManipulationOptionType"
                    },
                    "x-displayname": "Cookie Protection",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "rate_limit": {
                    "description": "Exclusive with [api_rate_limit disable_rate_limit]\n Define custom rate limiting parameters for this load balancer",
                    "$ref": "#/definitions/common_wafRateLimitConfigType",
                    "x-displayname": "Custom Rate Limiting Parameters"
                },
                "sensitive_data_policy": {
                    "description": "Exclusive with [default_sensitive_data_policy]\n Apply custom sensitive data discovery",
                    "$ref": "#/definitions/common_securitySensitiveDataPolicySettings",
                    "x-displayname": "Custom"
                },
                "service_policies_from_namespace": {
                    "description": "Exclusive with [active_service_policies no_service_policies]\n Apply the active service policies configured as part of the namespace service policy set",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Apply Namespace Service Policies"
                },
                "slow_ddos_mitigation": {
                    "description": "Exclusive with [system_default_timeouts]\n Custom Settings for Slow DDoS Mitigation",
                    "$ref": "#/definitions/virtual_hostSlowDDoSMitigation",
                    "x-displayname": "Custom"
                },
                "system_default_timeouts": {
                    "description": "Exclusive with [slow_ddos_mitigation]\n Default Settings for Slow DDoS Mitigation",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "trusted_clients": {
                    "type": "array",
                    "description": " Define rules to skip processing of one or more features such as WAF, Bot Defense etc. for clients.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/common_wafSimpleClientSrcRule"
                    },
                    "x-displayname": "Trusted Client Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                },
                "user_id_client_ip": {
                    "description": "Exclusive with [user_identification]\n Use the Client IP address as the user identifier.",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Client IP Address"
                },
                "user_identification": {
                    "description": "Exclusive with [user_id_client_ip]\n A reference to user_identification object.\n The rules in the user_identification object are evaluated to determine the user identifier.",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "User Identification Policy"
                },
                "waf_exclusion_rules": {
                    "type": "array",
                    "description": " Define the Signature IDs, Violations, Attack Types and Bot Names that should be excluded from WAF processing on specific match criteria.\n The match criteria include domain, path and method.\n WAF Exclusion rules is a sequential engine where rules are evaluated one after the other.\n It's important to define the correct order for WAF exclusion rules to get the intended result, rules are evaluated from top to bottom in the list.\n For each request, its characteristics are evaluated based on the match criteria in each WAF exclusion rule, starting from the top.\n When an exclusion rule is matched, then this exclusion rule takes effect and no more rules are evaluated.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 256\n  ves.io.schema.rules.repeated.unique_metadata_name: true\n",
                    "maxItems": 256,
                    "items": {
                        "$ref": "#/definitions/policySimpleWafExclusionRule"
                    },
                    "x-displayname": "WAF Exclusion Rules",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "256",
                        "ves.io.schema.rules.repeated.unique_metadata_name": "true"
                    }
                }
            }
        },
        "viewscommon_securityJavaScriptLocation": {
            "type": "string",
            "description": "All inside networks.\n\nInsert JavaScript after \u003chead\u003e tag\nInsert JavaScript after \u003c/title\u003e tag.\nInsert JavaScript before first \u003cscript\u003e tag",
            "title": "JavaScriptLocation",
            "enum": [
                "AFTER_HEAD",
                "AFTER_TITLE_END",
                "BEFORE_SCRIPT"
            ],
            "default": "AFTER_HEAD",
            "x-displayname": "JavaScript Location",
            "x-ves-proto-enum": "ves.io.schema.views.common_security.JavaScriptLocation"
        },
        "viewscommon_wafIPThreatCategoryListType": {
            "type": "object",
            "description": "List of ip threat categories",
            "title": "IP Threat Category List Type",
            "x-displayname": "IP Threat Category List",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.IPThreatCategoryListType",
            "properties": {
                "ip_threat_categories": {
                    "type": "array",
                    "description": " If the source IP matches on atleast one of the enabled IP threat categories, the request will be denied.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "IP Threat Categories",
                    "maxItems": 32,
                    "items": {
                        "$ref": "#/definitions/policyIPThreatCategory"
                    },
                    "x-displayname": "List of IP Threat Categories to choose",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "viewscommon_wafPolicyBasedChallenge": {
            "type": "object",
            "description": "Specifies the settings for policy rule based challenge",
            "title": "policy based challenge",
            "x-displayname": "Policy Based Challenge",
            "x-ves-oneof-field-captcha_challenge_parameters_choice": "[\"captcha_challenge_parameters\",\"default_captcha_challenge_parameters\"]",
            "x-ves-oneof-field-challenge_choice": "[\"always_enable_captcha_challenge\",\"always_enable_js_challenge\",\"no_challenge\"]",
            "x-ves-oneof-field-js_challenge_parameters_choice": "[\"default_js_challenge_parameters\",\"js_challenge_parameters\"]",
            "x-ves-oneof-field-malicious_user_mitigation_choice": "[\"default_mitigation_settings\",\"malicious_user_mitigation\"]",
            "x-ves-oneof-field-temporary_blocking_parameters_choice": "[\"default_temporary_blocking_parameters\",\"temporary_user_blocking\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.PolicyBasedChallenge",
            "properties": {
                "always_enable_captcha_challenge": {
                    "description": "Exclusive with [always_enable_js_challenge no_challenge]\n Enable Captcha challenge for all requests.\n Challenge rules can be used to selectively disable Captcha challenge or enable JavaScript challenge for some requests.",
                    "title": "always enable captcha challenge",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Always enable Captcha Challenge"
                },
                "always_enable_js_challenge": {
                    "description": "Exclusive with [always_enable_captcha_challenge no_challenge]\n Enable JavaScript challenge for all requests.\n Challenge rules can be used to selectively disable JavaScript challenge or enable Captcha challenge for some requests.",
                    "title": "always enable JS challenge",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Always enable JS Challenge"
                },
                "captcha_challenge_parameters": {
                    "description": "Exclusive with [default_captcha_challenge_parameters]\n Configure captcha challenge parameters",
                    "title": "Captcha Challenge",
                    "$ref": "#/definitions/virtual_hostCaptchaChallengeType",
                    "x-displayname": "Captcha Challenge Parameters"
                },
                "default_captcha_challenge_parameters": {
                    "description": "Exclusive with [captcha_challenge_parameters]\n Use default parameters",
                    "title": "default parameters",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Use Default Parameters"
                },
                "default_js_challenge_parameters": {
                    "description": "Exclusive with [js_challenge_parameters]\n Use default parameters",
                    "title": "default parameters",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Use Default Parameters"
                },
                "default_mitigation_settings": {
                    "description": "Exclusive with [malicious_user_mitigation]\n For low threat level, JavaScript Challenge will be applied. For medium threat level, Captcha Challenge will be applied.\n For high level, users will be temporarily blocked.",
                    "title": "default parameters",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Default"
                },
                "default_temporary_blocking_parameters": {
                    "description": "Exclusive with [temporary_user_blocking]\n Use default parameters",
                    "title": "default parameters",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "Use Default Parameters"
                },
                "js_challenge_parameters": {
                    "description": "Exclusive with [default_js_challenge_parameters]\n Configure JavaScript challenge parameters",
                    "title": "JavaScript Challenge",
                    "$ref": "#/definitions/virtual_hostJavascriptChallengeType",
                    "x-displayname": "JavaScript Challenge Parameters"
                },
                "malicious_user_mitigation": {
                    "description": "Exclusive with [default_mitigation_settings]\n Define the mitigation actions to be taken for different threat levels",
                    "title": "Malicious User Mitigation",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "Custom"
                },
                "no_challenge": {
                    "description": "Exclusive with [always_enable_captcha_challenge always_enable_js_challenge]\n Disable JavaScript and Captcha challenge for all requests.\n Challenge rules can be used to selectively enable JavaScript or Captcha challenge for some requests.",
                    "title": "no_challenge",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "None"
                },
                "rule_list": {
                    "description": " list challenge rules to be used in policy based challenge",
                    "title": "Challenge rule list",
                    "$ref": "#/definitions/common_wafChallengeRuleList",
                    "x-displayname": "Challenge rule list"
                },
                "temporary_user_blocking": {
                    "description": "Exclusive with [default_temporary_blocking_parameters]\n Specifies configuration for temporary user blocking resulting from malicious user detection",
                    "title": "Temporary User Blocking",
                    "$ref": "#/definitions/virtual_hostTemporaryUserBlockingType",
                    "x-displayname": "Temporary User Blocking Parameters"
                }
            }
        },
        "virtual_hostAutoCertInfoType": {
            "type": "object",
            "description": "Information related to auto certificate",
            "title": "AutoCertInfoType",
            "x-displayname": "Auto Cert Information",
            "x-ves-proto-message": "ves.io.schema.virtual_host.AutoCertInfoType",
            "properties": {
                "auto_cert_expiry": {
                    "type": "string",
                    "description": " Auto certificate expiry timestamp",
                    "title": "Auto Cert Expiry Timestamp",
                    "format": "date-time",
                    "x-displayname": "Auto Cert Expiry Timestamp"
                },
                "auto_cert_issuer": {
                    "type": "string",
                    "description": " Issuer of the auto certificate",
                    "title": "Auto Cert Issuer",
                    "x-displayname": "Auto Cert Issuer"
                },
                "auto_cert_state": {
                    "description": " State of auto certificate generation.",
                    "title": "Auto Cert State",
                    "$ref": "#/definitions/virtual_hostCertificationState",
                    "x-displayname": "Auto Cert State"
                },
                "auto_cert_subject": {
                    "type": "string",
                    "description": " Subject of the auto certificate",
                    "title": "Auto Cert Subject",
                    "x-displayname": "Auto Cert Subject"
                },
                "dns_records": {
                    "type": "array",
                    "description": " DNS Records that are to be added by user in their DNS domain.\n Currently, this will be populated when auto certificates are\n desired but DNS delegation is not enabled.",
                    "title": "DNS Records",
                    "items": {
                        "$ref": "#/definitions/virtual_hostDNSRecord"
                    },
                    "x-displayname": "DNS Records"
                }
            }
        },
        "virtual_hostCaptchaChallengeType": {
            "type": "object",
            "description": "\nEnables loadbalancer to perform captcha challenge\n\nCaptcha challenge will be based on Google Recaptcha.\n\nWith this feature enabled, only clients that pass the captcha challenge will be allowed to\ncomplete the HTTP request.\n\nWhen loadbalancer is configured to do Captcha Challenge, it will redirect the browser to an\nHTML page on every new HTTP request. This HTML page will have captcha challenge embedded in it.\nClient will be allowed to make the request only if the captcha challenge is successful.\nLoadbalancer will tag response header with a cookie to avoid Captcha challenge for subsequent requests.\n\nCAPTCHA is mainly used as a security check to ensure only human users can pass through.\nGenerally, computers or bots are not capable of solving a captcha.\n\nYou can enable either Javascript challenge or Captcha challenge on a virtual host",
            "title": "CaptchaChallengeType",
            "x-displayname": "Captcha Challenge Parameters",
            "x-ves-proto-message": "ves.io.schema.virtual_host.CaptchaChallengeType",
            "properties": {
                "cookie_expiry": {
                    "type": "integer",
                    "description": " Cookie expiration period, in seconds.\n An expired cookie causes the loadbalancer to issue a new challenge.\n\nExample: - \"1000\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 86400\n",
                    "title": "cookie_expiry",
                    "format": "int64",
                    "x-displayname": "Cookie Expiration Period",
                    "x-ves-example": "1000",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "86400"
                    }
                },
                "custom_page": {
                    "type": "string",
                    "description": " Custom message is of type uri_ref. Currently supported URL schemes is string:///.\n For string:/// scheme, message needs to be encoded in Base64 format.\n You can specify this message as base64 encoded plain text message e.g. \"Please Wait..\"\n or it can be HTML paragraph or a body string encoded as base64 string\n E.g. \"\u003cp\u003e Please Wait \u003c/p\u003e\". Base64 encoded string for this html is \"PHA+IFBsZWFzZSBXYWl0IDwvcD4=\"\n\nExample: - \"string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4=\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 65536\n  ves.io.schema.rules.string.uri_ref: true\n",
                    "title": "custom_page",
                    "maxLength": 65536,
                    "x-displayname": "Custom message for Captcha Challenge",
                    "x-ves-example": "string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4=",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "65536",
                        "ves.io.schema.rules.string.uri_ref": "true"
                    }
                }
            }
        },
        "virtual_hostCertificationState": {
            "type": "string",
            "description": "State of auto certification generation for the virtual host\n\n - AutoCertDisabled: Auto Cert Disabled\n\nAuto Certification is disabled.\n - DnsDomainVerification: Dns Domain Verification\n\nAuto Certification is waiting for domain verification.\n - AutoCertStarted: Auto Cert Started\n\nAuto Certificate generation action has started.\n - PreDomainChallengePending: Pre Domain Challenge Pending\n\nThe domains in the virtual host configuration are not still verified. This requires\nthe _acme-challenge TXT record in the domain to have the correct TXT.\n - DomainChallengeStarted: Domain Challenge Started\n\nDomain challenge process started.\n - DomainChallengePending: Domain Challenge Pending\n\nThe domains in the virtual host configuration are being verified. This requires\nthe _acme-challenge TXT record in the domain to have the correct TXT.\n - DomainChallengeVerified: Domain Challenge Verified\n\nAll the domains in the virtual host have been verified.\n - AutoCertFinalize: Auto Cert Finalize\n\nCertificate generation order is Ready and Finalized.\n - CertificateInvalid: Certificate Invalid\n\nCertificate is invalid\n - CertificateValid: Certificate Valid\n\nValid certificate generated and tls_parameters are updated\n - AutoCertNotApplicable: Auto Cert Not Applicable\n\nAuto certificate not applicable because virtual host does not use TLS\n - AutoCertRateLimited: Auto Cert Rate Limited\n\nAuto certificate not available because CA has rate limited the request\n - AutoCertGenerationRetry: Auto Cert Generation Retry\n\nAuto certificate generate failed in the previous attempt, will be retried automatically\n - AutoCertError: Auto Cert Error\n\nError in Certificate generation\nDefault State for Vhost State with Auto Certificate\n - AutoCertAccountRateLimited: Auto Cert Account Rate Limited\n\nAuto certificate not available because CA has rate limited the request\n - AutoCertDomainRateLimited: Auto Cert Domain Rate Limited\n\nAuto certificate not available because CA has rate limited the request\n - CertificateExpired: Certificate Expired\n\nCertificate has expired",
            "title": "Certification State",
            "enum": [
                "AutoCertDisabled",
                "DnsDomainVerification",
                "AutoCertStarted",
                "DomainChallengePending",
                "DomainChallengeVerified",
                "AutoCertFinalize",
                "CertificateInvalid",
                "CertificateValid",
                "AutoCertNotApplicable",
                "AutoCertRateLimited",
                "AutoCertGenerationRetry",
                "AutoCertError",
                "PreDomainChallengePending",
                "DomainChallengeStarted",
                "AutoCertInitialize",
                "AutoCertAccountRateLimited",
                "AutoCertDomainRateLimited",
                "CertificateExpired"
            ],
            "default": "AutoCertDisabled",
            "x-displayname": "Certification State",
            "x-ves-proto-enum": "ves.io.schema.virtual_host.CertificationState"
        },
        "virtual_hostDNSRecord": {
            "type": "object",
            "description": "Defines a DNS record",
            "title": "DNSRecord",
            "x-displayname": "DNS Record",
            "x-ves-proto-message": "ves.io.schema.virtual_host.DNSRecord",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " Name of the DNS record",
                    "title": "Name",
                    "x-displayname": "Name"
                },
                "type": {
                    "type": "string",
                    "description": " Type of the DNS record\n\nExample: - \"CNAME\"-",
                    "title": "Type",
                    "x-displayname": "Type",
                    "x-ves-example": "CNAME"
                },
                "value": {
                    "type": "string",
                    "description": " DNS record Value",
                    "title": "Value",
                    "x-displayname": "Value"
                }
            }
        },
        "virtual_hostDNSVHostStatusType": {
            "type": "object",
            "description": "DNS related Virtual Host status",
            "title": "DNS Virtual Host Status Type",
            "x-displayname": "DNS Virtual Host Status",
            "x-ves-proto-message": "ves.io.schema.virtual_host.DNSVHostStatusType",
            "properties": {
                "error_description": {
                    "type": "string",
                    "description": " Description of error during DNS configuration\n\nExample: - \"value\"-",
                    "title": "Error Description",
                    "x-displayname": "Error Description",
                    "x-ves-example": "value"
                },
                "existing_certificate_state": {
                    "type": "string",
                    "description": " Status of Existing Auto Certficate\n\nExample: - \"Certificate Valid or Certificate Expired or Certificate Invalid\"-",
                    "title": "Existing Certificate Status",
                    "x-displayname": "Existing Certificate Status",
                    "x-ves-example": "Certificate Valid or Certificate Expired or Certificate Invalid"
                },
                "renew_certificate_state": {
                    "description": " State of auto certificate generation.",
                    "title": "Certificate Renewal Status",
                    "$ref": "#/definitions/virtual_hostCertificationState",
                    "x-displayname": "Certificate Renewal Status"
                },
                "state": {
                    "description": " State of the virtual host",
                    "title": "Virtual Host state",
                    "$ref": "#/definitions/virtual_hostVirtualHostState",
                    "x-displayname": "Virtual Host State"
                },
                "suggested_action": {
                    "type": "string",
                    "description": " Suggested action for customer on error\n\nExample: - \"value\"-",
                    "title": "Suggested Action",
                    "x-displayname": "Suggested Action",
                    "x-ves-example": "value"
                }
            }
        },
        "virtual_hostJavascriptChallengeType": {
            "type": "object",
            "description": "\nEnables loadbalancer to perform client browser compatibility test by redirecting to a page\nwith Javascript.\n\nWith this feature enabled, only clients that are capable of executing Javascript(mostly browsers)\nwill be allowed to complete the HTTP request.\n\nWhen loadbalancer is configured to do Javascript Challenge, it will redirect the browser to an\nHTML page on every new HTTP request. This HTML page will have Javascript embedded in it.\nLoadbalancer chooses a set of random numbers for every new client and sends these numbers along with an\nencrypted answer with the request such that it embed these numbers as input in the Javascript.\nJavascript will run on the requestor browser and perform a complex Math operation.\nScript will submit the answer to loadbalancer. Loadbalancer will validate the answer by comparing the calculated\nanswer with the decrypted answer (which was encrypted when it was sent back as reply) and allow\nthe request to the upstream server only if the answer is correct.\nLoadbalancer will tag response header with a cookie to avoid Javascript challenge for subsequent requests.\n\nJavascript challenge serves following purposes\n   * Validate that the request is coming via a browser that is capable for running Javascript\n   * Force the browser to run a complex operation, f(X), that requires it to spend a large number\n     of CPU cycles. This is to slow down a potential DoS attacker by making it difficult to launch\n   a large request flood without having to spend even larger CPU cost at their end.\n\nYou can enable either Javascript challenge or Captcha challenge on a virtual host",
            "title": "JavascriptChallengeType",
            "x-displayname": "Javascript Challenge Parameters",
            "x-ves-proto-message": "ves.io.schema.virtual_host.JavascriptChallengeType",
            "properties": {
                "cookie_expiry": {
                    "type": "integer",
                    "description": " Cookie expiration period, in seconds.\n An expired cookie causes the loadbalancer to issue a new challenge.\n\nExample: - \"1000\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 86400\n",
                    "title": "cookie_expiry",
                    "format": "int64",
                    "x-displayname": "Cookie Expiration Period",
                    "x-ves-example": "1000",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "86400"
                    }
                },
                "custom_page": {
                    "type": "string",
                    "description": " Custom message is of type uri_ref. Currently supported URL schemes is string:///.\n For string:/// scheme, message needs to be encoded in Base64 format.\n You can specify this message as base64 encoded plain text message e.g. \"Please Wait..\"\n or it can be HTML paragraph or a body string encoded as base64 string\n E.g. \"\u003cp\u003e Please Wait \u003c/p\u003e\". Base64 encoded string for this html is \"PHA+IFBsZWFzZSBXYWl0IDwvcD4=\"\n\nExample: - \"string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4=\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 65536\n  ves.io.schema.rules.string.uri_ref: true\n",
                    "title": "custom_page",
                    "maxLength": 65536,
                    "x-displayname": "Custom Message for Javascript Challenge",
                    "x-ves-example": "string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4=",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "65536",
                        "ves.io.schema.rules.string.uri_ref": "true"
                    }
                },
                "js_script_delay": {
                    "type": "integer",
                    "description": " Delay introduced by Javascript, in milliseconds.\n\nExample: - \"1000\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1000\n  ves.io.schema.rules.uint32.lte: 60000\n",
                    "title": "js_script_delay",
                    "format": "int64",
                    "x-displayname": "Javascript Delay",
                    "x-ves-example": "1000",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1000",
                        "ves.io.schema.rules.uint32.lte": "60000"
                    }
                }
            }
        },
        "virtual_hostServiceDomain": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.virtual_host.ServiceDomain",
            "properties": {
                "domain": {
                    "type": "string",
                    "description": " Domain Name\n\nExample: - \"cdn.acmecorp.com\"-",
                    "title": "Domain Name",
                    "x-displayname": "Domain Name",
                    "x-ves-example": "cdn.acmecorp.com"
                },
                "service_domain": {
                    "type": "string",
                    "description": " Service Domain\n\nExample: - \"ves-io-cdn-cdn-acmecorp-com.demo1.ac.vh.volterra.us\"-",
                    "title": "Service Domain",
                    "x-displayname": "Service Domain",
                    "x-ves-example": "ves-io-cdn-cdn-acmecorp-com.demo1.ac.vh.volterra.us"
                }
            }
        },
        "virtual_hostSlowDDoSMitigation": {
            "type": "object",
            "description": "\"Slow and low\" attacks tie up server resources, leaving none available for servicing\nrequests from actual users.",
            "title": "Slow DDoS Mitigation",
            "x-displayname": "Slow DDoS Mitigation",
            "x-ves-oneof-field-request_timeout_choice": "[\"disable_request_timeout\",\"request_timeout\"]",
            "x-ves-proto-message": "ves.io.schema.virtual_host.SlowDDoSMitigation",
            "properties": {
                "disable_request_timeout": {
                    "description": "Exclusive with [request_timeout]\n",
                    "title": "No Timeout",
                    "$ref": "#/definitions/ioschemaEmpty",
                    "x-displayname": "No Timeout"
                },
                "request_headers_timeout": {
                    "type": "integer",
                    "description": " The amount of time the client has to send only the headers on the request stream before\n the stream is cancelled. The default value is 10000 milliseconds. This setting\n provides protection against Slowloris attacks.\n\nExample: - \"60000\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 2000\n  ves.io.schema.rules.uint32.lte: 30000\n",
                    "title": "Request Headers Timeout",
                    "format": "int64",
                    "x-displayname": "Request Headers Timeout",
                    "x-ves-example": "60000",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "2000",
                        "ves.io.schema.rules.uint32.lte": "30000"
                    }
                },
                "request_timeout": {
                    "type": "integer",
                    "description": "Exclusive with [disable_request_timeout]\n\n\nExample: - \"60000\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 2000\n  ves.io.schema.rules.uint32.lte: 300000\n",
                    "title": "Custom Timeout",
                    "format": "int64",
                    "x-displayname": "Custom Timeout",
                    "x-ves-example": "60000",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "2000",
                        "ves.io.schema.rules.uint32.lte": "300000"
                    }
                }
            }
        },
        "virtual_hostTemporaryUserBlockingType": {
            "type": "object",
            "description": "\nSpecifies configuration for temporary user blocking resulting from user behavior analysis.\n\nWhen Malicious User Mitigation is enabled from service policy rules, users' accessing the application will be analyzed for\nmalicious activity and the configured mitigation actions will be taken on identified malicious users.\nThese mitigation actions include setting up temporary blocking on that user.\nThis configuration specifies settings on how that blocking should be done by the loadbalancer.",
            "title": "TemporaryUserBlockingType",
            "x-displayname": "Temporary User Blocking",
            "x-ves-proto-message": "ves.io.schema.virtual_host.TemporaryUserBlockingType",
            "properties": {
                "custom_page": {
                    "type": "string",
                    "description": " Custom message is of type -uri_ref-. Currently supported URL schemes is -string:///-.\n For -string:///- scheme, message needs to be encoded in Base64 format.\n You can specify this message as base64 encoded plain text message e.g. \"Blocked..\"\n or it can be HTML paragraph or a body string encoded as base64 string\n E.g. \"\u003cp\u003e Blocked \u003c/p\u003e\". Base64 encoded string for this html is \"PHA+IFBsZWFzZSBXYWl0IDwvcD4=\"\n\nExample: - \"string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4=\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 65536\n  ves.io.schema.rules.string.uri_ref: true\n",
                    "title": "custom_page",
                    "maxLength": 65536,
                    "x-displayname": "Custom Message for Temporary Blocking",
                    "x-ves-example": "string:///PHA+IFBsZWFzZSBXYWl0IDwvcD4=",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "65536",
                        "ves.io.schema.rules.string.uri_ref": "true"
                    }
                }
            }
        },
        "virtual_hostVirtualHostState": {
            "type": "string",
            "description": "State of the virtual host\n\n - VIRTUAL_HOST_READY: VIRTUAL_HOST_READY\n\nVirtual host is ready to install\n - VIRTUAL_HOST_PENDING_VERIFICATION: VIRTUAL_HOST_PENDING_VERIFICATION\n\nVirtual host is verfication pending for some or all of its domains\n - VIRTUAL_HOST_VERIFICATION_FAILED: VIRTUAL_HOST_VERIFICATION_FAILED\n\nVirtual host has one or more domains for which verification failed\n - VIRTUAL_HOST_PENDING_DNS_DELEGATION: VIRTUAL_HOST_PENDING_DNS_DELEGATION\n\nVirtual host is pending DNS delegation\n - VIRTUAL_HOST_PENDING_A_RECORD: VIRTUAL_HOST_PENDING_A_RECORD\n\nVirtual host is waiting for one or more A records to be created\n - VIRTUAL_HOST_DNS_A_RECORD_ADDED: VIRTUAL_HOST_DNS_A_RECORD_ADDED\n\nDNS A record has been added for this Virtual host\n - VIRTUAL_HOST_INTERNET_NLB_PENDING_CREATION: VIRTUAL_HOST_INTERNET_NLB_PENDING_CREATION\n\nInternet facing NLB, is being created on the site/sites belonging to the virtual site\n - VIRTUAL_HOST_INTERNET_NLB_CREATION_FAILED: VIRTUAL_HOST_INTERNET_NLB_CREATION_FAILED\n\nInternet NLB creation failed on the site/sites. InternetNLBVIPStatus will have more information.",
            "title": "VirtualHostState",
            "enum": [
                "VIRTUAL_HOST_READY",
                "VIRTUAL_HOST_PENDING_VERIFICATION",
                "VIRTUAL_HOST_VERIFICATION_FAILED",
                "VIRTUAL_HOST_PENDING_DNS_DELEGATION",
                "VIRTUAL_HOST_PENDING_A_RECORD",
                "VIRTUAL_HOST_DNS_A_RECORD_ADDED",
                "VIRTUAL_HOST_INTERNET_NLB_PENDING_CREATION",
                "VIRTUAL_HOST_INTERNET_NLB_CREATION_FAILED"
            ],
            "default": "VIRTUAL_HOST_READY",
            "x-displayname": "Virtual Host State",
            "x-ves-proto-enum": "ves.io.schema.virtual_host.VirtualHostState"
        },
        "virtual_host_dns_infoDnsInfo": {
            "type": "object",
            "description": "A message that contains DNS information for a given IP address",
            "title": "DNS information",
            "x-displayname": "DNS Information",
            "x-ves-proto-message": "ves.io.schema.virtual_host_dns_info.DnsInfo",
            "properties": {
                "ip_address": {
                    "type": "string",
                    "description": " IP address associated with virtual host\n\nValidation Rules:\n  ves.io.schema.rules.string.ip: true\n",
                    "title": "IP address",
                    "x-displayname": "IP Address",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.ip": "true"
                    }
                }
            }
        }
    },
    "x-displayname": "CDN Loadbalancer",
    "x-ves-proto-file": "ves.io/schema/views/cdn_loadbalancer/public_crudapi.proto"
}`
