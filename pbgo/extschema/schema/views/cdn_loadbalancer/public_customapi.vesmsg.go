// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package cdn_loadbalancer

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log"
	ves_io_schema_views_cdn_loadbalancer_access_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/cdn_loadbalancer/access_log"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CDNAccessLogAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNAccessLogAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNAccessLogAggregationRequest) DeepCopy() *CDNAccessLogAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNAccessLogAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNAccessLogAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNAccessLogAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNAccessLogAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCDNAccessLogAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNAccessLogAggregationRequest) AggsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for aggs")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*CDNAggregationRequest, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := CDNAggregationRequestValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for aggs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*CDNAggregationRequest)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*CDNAggregationRequest, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map aggs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items aggs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNAccessLogAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNAccessLogAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {
		vOpts := append(opts, db.WithValidateField("aggs"))
		if err := fv(ctx, m.GetAggs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		for idx, item := range m.GetQuery() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNAccessLogAggregationRequestValidator = func() *ValidateCDNAccessLogAggregationRequest {
	v := &ValidateCDNAccessLogAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAggs := v.AggsValidationRuleHandler
	rulesAggs := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "64",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "16",
	}
	vFn, err = vrhAggs(rulesAggs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogAggregationRequest.aggs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aggs"] = vFn

	v.FldValidators["query"] = CDNAccessLogFilterValidator().Validate

	return v
}()

func CDNAccessLogAggregationRequestValidator() db.Validator {
	return DefaultCDNAccessLogAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNAccessLogFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNAccessLogFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNAccessLogFilter) DeepCopy() *CDNAccessLogFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNAccessLogFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNAccessLogFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNAccessLogFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNAccessLogFilterValidator().Validate(ctx, m, opts...)
}

type ValidateCDNAccessLogFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNAccessLogFilter) TagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag)
		return int32(i)
	}
	// ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tag")
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogFilter) ValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogFilter) OperatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(CDNAccessLogOperatorType)
		return int32(i)
	}
	// CDNAccessLogOperatorType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, CDNAccessLogOperatorType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operator")
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNAccessLogFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNAccessLogFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tag"]; exists {

		vOpts := append(opts, db.WithValidateField("tag"))
		if err := fv(ctx, m.GetTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["values"]; exists {
		vOpts := append(opts, db.WithValidateField("values"))
		if err := fv(ctx, m.GetValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNAccessLogFilterValidator = func() *ValidateCDNAccessLogFilter {
	v := &ValidateCDNAccessLogFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTag := v.TagValidationRuleHandler
	rulesTag := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTag(rulesTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogFilter.tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tag"] = vFn

	vrhValues := v.ValuesValidationRuleHandler
	rulesValues := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "128",
		"ves.io.schema.rules.repeated.max_items":            "32",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhValues(rulesValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogFilter.values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["values"] = vFn

	vrhOperator := v.OperatorValidationRuleHandler
	rulesOperator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOperator(rulesOperator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogFilter.operator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operator"] = vFn

	return v
}()

func CDNAccessLogFilterValidator() db.Validator {
	return DefaultCDNAccessLogFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNAccessLogRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNAccessLogRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNAccessLogRequest) DeepCopy() *CDNAccessLogRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNAccessLogRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNAccessLogRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNAccessLogRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNAccessLogRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCDNAccessLogRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNAccessLogRequest) QueryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for query")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CDNAccessLogFilter, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CDNAccessLogFilterValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CDNAccessLogFilter)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CDNAccessLogFilter, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogRequest) LimitValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for limit")
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogRequest) AggsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for aggs")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*CDNAggregationRequest, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := CDNAggregationRequestValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for aggs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*CDNAggregationRequest)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*CDNAggregationRequest, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map aggs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items aggs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNAccessLogRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNAccessLogRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {
		vOpts := append(opts, db.WithValidateField("aggs"))
		if err := fv(ctx, m.GetAggs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {
		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNAccessLogRequestValidator = func() *ValidateCDNAccessLogRequest {
	v := &ValidateCDNAccessLogRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQuery := v.QueryValidationRuleHandler
	rulesQuery := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhQuery(rulesQuery)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogRequest.query: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query"] = vFn

	vrhLimit := v.LimitValidationRuleHandler
	rulesLimit := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "500",
	}
	vFn, err = vrhLimit(rulesLimit)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogRequest.limit: %s", err)
		panic(errMsg)
	}
	v.FldValidators["limit"] = vFn

	vrhAggs := v.AggsValidationRuleHandler
	rulesAggs := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "64",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "16",
	}
	vFn, err = vrhAggs(rulesAggs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogRequest.aggs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aggs"] = vFn

	return v
}()

func CDNAccessLogRequestValidator() db.Validator {
	return DefaultCDNAccessLogRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNAggregationRequest) DeepCopy() *CDNAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCDNAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAggregationType().(type) {
	case *CDNAggregationRequest_DateAggregation:
		if fv, exists := v.FldValidators["aggregation_type.date_aggregation"]; exists {
			val := m.GetAggregationType().(*CDNAggregationRequest_DateAggregation).DateAggregation
			vOpts := append(opts,
				db.WithValidateField("aggregation_type"),
				db.WithValidateField("date_aggregation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CDNAggregationRequest_FieldAggregation:
		if fv, exists := v.FldValidators["aggregation_type.field_aggregation"]; exists {
			val := m.GetAggregationType().(*CDNAggregationRequest_FieldAggregation).FieldAggregation
			vOpts := append(opts,
				db.WithValidateField("aggregation_type"),
				db.WithValidateField("field_aggregation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNAggregationRequestValidator = func() *ValidateCDNAggregationRequest {
	v := &ValidateCDNAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggregation_type.date_aggregation"] = CDNDateAggregationValidator().Validate
	v.FldValidators["aggregation_type.field_aggregation"] = CDNFieldAggregationValidator().Validate

	return v
}()

func CDNAggregationRequestValidator() db.Validator {
	return DefaultCDNAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNDateAggregation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNDateAggregation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNDateAggregation) DeepCopy() *CDNDateAggregation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNDateAggregation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNDateAggregation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNDateAggregation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNDateAggregationValidator().Validate(ctx, m, opts...)
}

type ValidateCDNDateAggregation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNDateAggregation) StepValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for step")
	}

	return validatorFn, nil
}

func (v *ValidateCDNDateAggregation) SubAggsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for sub_aggs")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*CDNDateSubAggregation, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := CDNDateSubAggregationValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for sub_aggs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*CDNDateSubAggregation)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*CDNDateSubAggregation, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map sub_aggs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items sub_aggs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNDateAggregation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNDateAggregation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNDateAggregation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_aggs"]; exists {
		vOpts := append(opts, db.WithValidateField("sub_aggs"))
		if err := fv(ctx, m.GetSubAggs(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNDateAggregationValidator = func() *ValidateCDNDateAggregation {
	v := &ValidateCDNDateAggregation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStep := v.StepValidationRuleHandler
	rulesStep := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStep(rulesStep)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNDateAggregation.step: %s", err)
		panic(errMsg)
	}
	v.FldValidators["step"] = vFn

	vrhSubAggs := v.SubAggsValidationRuleHandler
	rulesSubAggs := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "64",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "16",
	}
	vFn, err = vrhSubAggs(rulesSubAggs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNDateAggregation.sub_aggs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sub_aggs"] = vFn

	return v
}()

func CDNDateAggregationValidator() db.Validator {
	return DefaultCDNDateAggregationValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNDateSubAggregation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNDateSubAggregation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNDateSubAggregation) DeepCopy() *CDNDateSubAggregation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNDateSubAggregation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNDateSubAggregation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNDateSubAggregation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNDateSubAggregationValidator().Validate(ctx, m, opts...)
}

type ValidateCDNDateSubAggregation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNDateSubAggregation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNDateSubAggregation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNDateSubAggregation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAggregationType().(type) {
	case *CDNDateSubAggregation_FieldAggregation:
		if fv, exists := v.FldValidators["aggregation_type.field_aggregation"]; exists {
			val := m.GetAggregationType().(*CDNDateSubAggregation_FieldAggregation).FieldAggregation
			vOpts := append(opts,
				db.WithValidateField("aggregation_type"),
				db.WithValidateField("field_aggregation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNDateSubAggregationValidator = func() *ValidateCDNDateSubAggregation {
	v := &ValidateCDNDateSubAggregation{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggregation_type.field_aggregation"] = CDNFieldAggregationValidator().Validate

	return v
}()

func CDNDateSubAggregationValidator() db.Validator {
	return DefaultCDNDateSubAggregationValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNFieldAggregation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNFieldAggregation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNFieldAggregation) DeepCopy() *CDNFieldAggregation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNFieldAggregation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNFieldAggregation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNFieldAggregation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNFieldAggregationValidator().Validate(ctx, m, opts...)
}

type ValidateCDNFieldAggregation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNFieldAggregation) FieldValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag)
		return int32(i)
	}
	// ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for field")
	}

	return validatorFn, nil
}

func (v *ValidateCDNFieldAggregation) TopkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for topk")
	}

	return validatorFn, nil
}

func (v *ValidateCDNFieldAggregation) SubAggsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for sub_aggs")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*CDNFieldSubAggregation, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := CDNFieldSubAggregationValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for sub_aggs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*CDNFieldSubAggregation)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*CDNFieldSubAggregation, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map sub_aggs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items sub_aggs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNFieldAggregation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNFieldAggregation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNFieldAggregation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["field"]; exists {

		vOpts := append(opts, db.WithValidateField("field"))
		if err := fv(ctx, m.GetField(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_aggs"]; exists {
		vOpts := append(opts, db.WithValidateField("sub_aggs"))
		if err := fv(ctx, m.GetSubAggs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["topk"]; exists {

		vOpts := append(opts, db.WithValidateField("topk"))
		if err := fv(ctx, m.GetTopk(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNFieldAggregationValidator = func() *ValidateCDNFieldAggregation {
	v := &ValidateCDNFieldAggregation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhField := v.FieldValidationRuleHandler
	rulesField := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhField(rulesField)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNFieldAggregation.field: %s", err)
		panic(errMsg)
	}
	v.FldValidators["field"] = vFn

	vrhTopk := v.TopkValidationRuleHandler
	rulesTopk := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFn, err = vrhTopk(rulesTopk)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNFieldAggregation.topk: %s", err)
		panic(errMsg)
	}
	v.FldValidators["topk"] = vFn

	vrhSubAggs := v.SubAggsValidationRuleHandler
	rulesSubAggs := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "64",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "16",
	}
	vFn, err = vrhSubAggs(rulesSubAggs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNFieldAggregation.sub_aggs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sub_aggs"] = vFn

	return v
}()

func CDNFieldAggregationValidator() db.Validator {
	return DefaultCDNFieldAggregationValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNFieldSubAggregation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNFieldSubAggregation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNFieldSubAggregation) DeepCopy() *CDNFieldSubAggregation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNFieldSubAggregation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNFieldSubAggregation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNFieldSubAggregation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNFieldSubAggregationValidator().Validate(ctx, m, opts...)
}

type ValidateCDNFieldSubAggregation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNFieldSubAggregation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNFieldSubAggregation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNFieldSubAggregation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAggregationType().(type) {
	case *CDNFieldSubAggregation_FieldAggregation:
		if fv, exists := v.FldValidators["aggregation_type.field_aggregation"]; exists {
			val := m.GetAggregationType().(*CDNFieldSubAggregation_FieldAggregation).FieldAggregation
			vOpts := append(opts,
				db.WithValidateField("aggregation_type"),
				db.WithValidateField("field_aggregation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNFieldSubAggregationValidator = func() *ValidateCDNFieldSubAggregation {
	v := &ValidateCDNFieldSubAggregation{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggregation_type.field_aggregation"] = FieldAggregationValidator().Validate

	return v
}()

func CDNFieldSubAggregationValidator() db.Validator {
	return DefaultCDNFieldSubAggregationValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNLogAggregationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNLogAggregationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNLogAggregationResponse) DeepCopy() *CDNLogAggregationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNLogAggregationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNLogAggregationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNLogAggregationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNLogAggregationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCDNLogAggregationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNLogAggregationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNLogAggregationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNLogAggregationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNLogAggregationResponseValidator = func() *ValidateCDNLogAggregationResponse {
	v := &ValidateCDNLogAggregationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func CDNLogAggregationResponseValidator() db.Validator {
	return DefaultCDNLogAggregationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNLogResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNLogResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNLogResponse) DeepCopy() *CDNLogResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNLogResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNLogResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNLogResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNLogResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCDNLogResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNLogResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNLogResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNLogResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["logs"]; exists {

		vOpts := append(opts, db.WithValidateField("logs"))
		for idx, item := range m.GetLogs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNLogResponseValidator = func() *ValidateCDNLogResponse {
	v := &ValidateCDNLogResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["logs"] = LilacCDNAccessLogsResponseDataValidator().Validate

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func CDNLogResponseValidator() db.Validator {
	return DefaultCDNLogResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *FieldAggregation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FieldAggregation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FieldAggregation) DeepCopy() *FieldAggregation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FieldAggregation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FieldAggregation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FieldAggregation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FieldAggregationValidator().Validate(ctx, m, opts...)
}

type ValidateFieldAggregation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFieldAggregation) FieldValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag)
		return int32(i)
	}
	// ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for field")
	}

	return validatorFn, nil
}

func (v *ValidateFieldAggregation) TopkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for topk")
	}

	return validatorFn, nil
}

func (v *ValidateFieldAggregation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FieldAggregation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FieldAggregation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["field"]; exists {

		vOpts := append(opts, db.WithValidateField("field"))
		if err := fv(ctx, m.GetField(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["topk"]; exists {

		vOpts := append(opts, db.WithValidateField("topk"))
		if err := fv(ctx, m.GetTopk(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFieldAggregationValidator = func() *ValidateFieldAggregation {
	v := &ValidateFieldAggregation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhField := v.FieldValidationRuleHandler
	rulesField := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhField(rulesField)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FieldAggregation.field: %s", err)
		panic(errMsg)
	}
	v.FldValidators["field"] = vFn

	vrhTopk := v.TopkValidationRuleHandler
	rulesTopk := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFn, err = vrhTopk(rulesTopk)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FieldAggregation.topk: %s", err)
		panic(errMsg)
	}
	v.FldValidators["topk"] = vFn

	return v
}()

func FieldAggregationValidator() db.Validator {
	return DefaultFieldAggregationValidator
}

// augmented methods on protoc/std generated struct

func (m *GetServiceOperationReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetServiceOperationReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetServiceOperationReq) DeepCopy() *GetServiceOperationReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetServiceOperationReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetServiceOperationReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetServiceOperationReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetServiceOperationReqValidator().Validate(ctx, m, opts...)
}

type ValidateGetServiceOperationReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetServiceOperationReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateGetServiceOperationReq) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGetServiceOperationReq) ServiceOpIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_op_id")
	}

	return validatorFn, nil
}

func (v *ValidateGetServiceOperationReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetServiceOperationReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetServiceOperationReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_op_id"]; exists {

		vOpts := append(opts, db.WithValidateField("service_op_id"))
		if err := fv(ctx, m.GetServiceOpId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetServiceOperationReqValidator = func() *ValidateGetServiceOperationReq {
	v := &ValidateGetServiceOperationReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetServiceOperationReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetServiceOperationReq.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhServiceOpId := v.ServiceOpIdValidationRuleHandler
	rulesServiceOpId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhServiceOpId(rulesServiceOpId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetServiceOperationReq.service_op_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_op_id"] = vFn

	return v
}()

func GetServiceOperationReqValidator() db.Validator {
	return DefaultGetServiceOperationReqValidator
}

// augmented methods on protoc/std generated struct

func (m *GetServiceOperationRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetServiceOperationRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetServiceOperationRsp) DeepCopy() *GetServiceOperationRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetServiceOperationRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetServiceOperationRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetServiceOperationRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetServiceOperationRspValidator().Validate(ctx, m, opts...)
}

type ValidateGetServiceOperationRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetServiceOperationRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetServiceOperationRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetServiceOperationRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error"]; exists {

		vOpts := append(opts, db.WithValidateField("error"))
		if err := fv(ctx, m.GetError(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetServiceOperationRspValidator = func() *ValidateGetServiceOperationRsp {
	v := &ValidateGetServiceOperationRsp{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ServiceOperationItemValidator().Validate

	return v
}()

func GetServiceOperationRspValidator() db.Validator {
	return DefaultGetServiceOperationRspValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNAccessLogsResponseData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNAccessLogsResponseData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNAccessLogsResponseData) DeepCopy() *LilacCDNAccessLogsResponseData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNAccessLogsResponseData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNAccessLogsResponseData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNAccessLogsResponseData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNAccessLogsResponseDataValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNAccessLogsResponseData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNAccessLogsResponseData) TimestampValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for timestamp")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNAccessLogsResponseData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNAccessLogsResponseData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNAccessLogsResponseData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_status"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_status"))
		if err := fv(ctx, m.GetCacheStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cdn_name"]; exists {

		vOpts := append(opts, db.WithValidateField("cdn_name"))
		if err := fv(ctx, m.GetCdnName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["city_id"]; exists {

		vOpts := append(opts, db.WithValidateField("city_id"))
		if err := fv(ctx, m.GetCityId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["city_name"]; exists {

		vOpts := append(opts, db.WithValidateField("city_name"))
		if err := fv(ctx, m.GetCityName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_port"]; exists {

		vOpts := append(opts, db.WithValidateField("client_port"))
		if err := fv(ctx, m.GetClientPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["country"]; exists {

		vOpts := append(opts, db.WithValidateField("country"))
		if err := fv(ctx, m.GetCountry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["geo_location"]; exists {

		vOpts := append(opts, db.WithValidateField("geo_location"))
		if err := fv(ctx, m.GetGeoLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host"]; exists {

		vOpts := append(opts, db.WithValidateField("host"))
		if err := fv(ctx, m.GetHost(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_header"]; exists {

		vOpts := append(opts, db.WithValidateField("host_header"))
		if err := fv(ctx, m.GetHostHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_version"]; exists {

		vOpts := append(opts, db.WithValidateField("http_version"))
		if err := fv(ctx, m.GetHttpVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["method"]; exists {

		vOpts := append(opts, db.WithValidateField("method"))
		if err := fv(ctx, m.GetMethod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["referer"]; exists {

		vOpts := append(opts, db.WithValidateField("referer"))
		if err := fv(ctx, m.GetReferer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["req_content_type"]; exists {

		vOpts := append(opts, db.WithValidateField("req_content_type"))
		if err := fv(ctx, m.GetReqContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["req_path"]; exists {

		vOpts := append(opts, db.WithValidateField("req_path"))
		if err := fv(ctx, m.GetReqPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["req_size"]; exists {

		vOpts := append(opts, db.WithValidateField("req_size"))
		if err := fv(ctx, m.GetReqSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_time"]; exists {

		vOpts := append(opts, db.WithValidateField("request_time"))
		if err := fv(ctx, m.GetRequestTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsp_code"]; exists {

		vOpts := append(opts, db.WithValidateField("rsp_code"))
		if err := fv(ctx, m.GetRspCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsp_code_class"]; exists {

		vOpts := append(opts, db.WithValidateField("rsp_code_class"))
		if err := fv(ctx, m.GetRspCodeClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsp_content_type"]; exists {

		vOpts := append(opts, db.WithValidateField("rsp_content_type"))
		if err := fv(ctx, m.GetRspContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsp_size"]; exists {

		vOpts := append(opts, db.WithValidateField("rsp_size"))
		if err := fv(ctx, m.GetRspSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scheme"]; exists {

		vOpts := append(opts, db.WithValidateField("scheme"))
		if err := fv(ctx, m.GetScheme(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_name"]; exists {

		vOpts := append(opts, db.WithValidateField("site_name"))
		if err := fv(ctx, m.GetSiteName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["src_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("src_ip"))
		if err := fv(ctx, m.GetSrcIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("timestamp"))
		if err := fv(ctx, m.GetTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_sni"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_sni"))
		if err := fv(ctx, m.GetTlsSni(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_version"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_version"))
		if err := fv(ctx, m.GetTlsVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upstream_addr"]; exists {

		vOpts := append(opts, db.WithValidateField("upstream_addr"))
		if err := fv(ctx, m.GetUpstreamAddr(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upstream_connect_time"]; exists {

		vOpts := append(opts, db.WithValidateField("upstream_connect_time"))
		if err := fv(ctx, m.GetUpstreamConnectTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upstream_response_time"]; exists {

		vOpts := append(opts, db.WithValidateField("upstream_response_time"))
		if err := fv(ctx, m.GetUpstreamResponseTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upstream_status"]; exists {

		vOpts := append(opts, db.WithValidateField("upstream_status"))
		if err := fv(ctx, m.GetUpstreamStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user"]; exists {

		vOpts := append(opts, db.WithValidateField("user"))
		if err := fv(ctx, m.GetUser(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_agent"]; exists {

		vOpts := append(opts, db.WithValidateField("user_agent"))
		if err := fv(ctx, m.GetUserAgent(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNAccessLogsResponseDataValidator = func() *ValidateLilacCDNAccessLogsResponseData {
	v := &ValidateLilacCDNAccessLogsResponseData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTimestamp := v.TimestampValidationRuleHandler
	rulesTimestamp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTimestamp(rulesTimestamp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNAccessLogsResponseData.timestamp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["timestamp"] = vFn

	return v
}()

func LilacCDNAccessLogsResponseDataValidator() db.Validator {
	return DefaultLilacCDNAccessLogsResponseDataValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNCachePurgeRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNCachePurgeRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNCachePurgeRequest) DeepCopy() *LilacCDNCachePurgeRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNCachePurgeRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNCachePurgeRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNCachePurgeRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNCachePurgeRequestValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNCachePurgeRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNCachePurgeRequest) PatternTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pattern_type")
	}
	return validatorFn, nil
}

func (v *ValidateLilacCDNCachePurgeRequest) PatternTypePatternValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Pattern, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pattern")
	}
	return oValidatorFn_Pattern, nil
}
func (v *ValidateLilacCDNCachePurgeRequest) PatternTypeHostnameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Hostname, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for hostname")
	}
	return oValidatorFn_Hostname, nil
}

func (v *ValidateLilacCDNCachePurgeRequest) PurgeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for purge_type")
	}
	return validatorFn, nil
}

func (v *ValidateLilacCDNCachePurgeRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNCachePurgeRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNCachePurgeRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNCachePurgeRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNCachePurgeRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pattern_type"]; exists {
		val := m.GetPatternType()
		vOpts := append(opts,
			db.WithValidateField("pattern_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPatternType().(type) {
	case *LilacCDNCachePurgeRequest_Pattern:
		if fv, exists := v.FldValidators["pattern_type.pattern"]; exists {
			val := m.GetPatternType().(*LilacCDNCachePurgeRequest_Pattern).Pattern
			vOpts := append(opts,
				db.WithValidateField("pattern_type"),
				db.WithValidateField("pattern"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LilacCDNCachePurgeRequest_PurgeAll:
		if fv, exists := v.FldValidators["pattern_type.purge_all"]; exists {
			val := m.GetPatternType().(*LilacCDNCachePurgeRequest_PurgeAll).PurgeAll
			vOpts := append(opts,
				db.WithValidateField("pattern_type"),
				db.WithValidateField("purge_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LilacCDNCachePurgeRequest_Url:
		if fv, exists := v.FldValidators["pattern_type.url"]; exists {
			val := m.GetPatternType().(*LilacCDNCachePurgeRequest_Url).Url
			vOpts := append(opts,
				db.WithValidateField("pattern_type"),
				db.WithValidateField("url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LilacCDNCachePurgeRequest_Hostname:
		if fv, exists := v.FldValidators["pattern_type.hostname"]; exists {
			val := m.GetPatternType().(*LilacCDNCachePurgeRequest_Hostname).Hostname
			vOpts := append(opts,
				db.WithValidateField("pattern_type"),
				db.WithValidateField("hostname"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["purge_epoch_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("purge_epoch_timestamp"))
		if err := fv(ctx, m.GetPurgeEpochTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["purge_type"]; exists {
		val := m.GetPurgeType()
		vOpts := append(opts,
			db.WithValidateField("purge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPurgeType().(type) {
	case *LilacCDNCachePurgeRequest_SoftPurge:
		if fv, exists := v.FldValidators["purge_type.soft_purge"]; exists {
			val := m.GetPurgeType().(*LilacCDNCachePurgeRequest_SoftPurge).SoftPurge
			vOpts := append(opts,
				db.WithValidateField("purge_type"),
				db.WithValidateField("soft_purge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LilacCDNCachePurgeRequest_HardPurge:
		if fv, exists := v.FldValidators["purge_type.hard_purge"]; exists {
			val := m.GetPurgeType().(*LilacCDNCachePurgeRequest_HardPurge).HardPurge
			vOpts := append(opts,
				db.WithValidateField("purge_type"),
				db.WithValidateField("hard_purge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNCachePurgeRequestValidator = func() *ValidateLilacCDNCachePurgeRequest {
	v := &ValidateLilacCDNCachePurgeRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPatternType := v.PatternTypeValidationRuleHandler
	rulesPatternType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPatternType(rulesPatternType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNCachePurgeRequest.pattern_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pattern_type"] = vFn

	vrhPatternTypePattern := v.PatternTypePatternValidationRuleHandler
	rulesPatternTypePattern := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFnMap["pattern_type.pattern"], err = vrhPatternTypePattern(rulesPatternTypePattern)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field LilacCDNCachePurgeRequest.pattern_type_pattern: %s", err)
		panic(errMsg)
	}
	vrhPatternTypeHostname := v.PatternTypeHostnameValidationRuleHandler
	rulesPatternTypeHostname := map[string]string{
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFnMap["pattern_type.hostname"], err = vrhPatternTypeHostname(rulesPatternTypeHostname)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field LilacCDNCachePurgeRequest.pattern_type_hostname: %s", err)
		panic(errMsg)
	}

	v.FldValidators["pattern_type.pattern"] = vFnMap["pattern_type.pattern"]
	v.FldValidators["pattern_type.hostname"] = vFnMap["pattern_type.hostname"]

	vrhPurgeType := v.PurgeTypeValidationRuleHandler
	rulesPurgeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPurgeType(rulesPurgeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNCachePurgeRequest.purge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["purge_type"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNCachePurgeRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNCachePurgeRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func LilacCDNCachePurgeRequestValidator() db.Validator {
	return DefaultLilacCDNCachePurgeRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNCachePurgeResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNCachePurgeResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNCachePurgeResponse) DeepCopy() *LilacCDNCachePurgeResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNCachePurgeResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNCachePurgeResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNCachePurgeResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNCachePurgeResponseValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNCachePurgeResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNCachePurgeResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNCachePurgeResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNCachePurgeResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["purge_request_id"]; exists {

		vOpts := append(opts, db.WithValidateField("purge_request_id"))
		if err := fv(ctx, m.GetPurgeRequestId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNCachePurgeResponseValidator = func() *ValidateLilacCDNCachePurgeResponse {
	v := &ValidateLilacCDNCachePurgeResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LilacCDNCachePurgeResponseValidator() db.Validator {
	return DefaultLilacCDNCachePurgeResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNMetricsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNMetricsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNMetricsRequest) DeepCopy() *LilacCDNMetricsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNMetricsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNMetricsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNMetricsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNMetricsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNMetricsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNMetricsRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsRequest) FieldSelectorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(LilacCDNMetricsFieldSelector)
		return int32(i)
	}
	// LilacCDNMetricsFieldSelector_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, LilacCDNMetricsFieldSelector_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for field_selector")
	}
	itemsValidatorFn := func(ctx context.Context, elems []LilacCDNMetricsFieldSelector, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for field_selector")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]LilacCDNMetricsFieldSelector)
		if !ok {
			return fmt.Errorf("Repeated validation expected []LilacCDNMetricsFieldSelector, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated field_selector")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items field_selector")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNMetricsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNMetricsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["field_selector"]; exists {
		vOpts := append(opts, db.WithValidateField("field_selector"))
		if err := fv(ctx, m.GetFieldSelector(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filter"]; exists {

		vOpts := append(opts, db.WithValidateField("filter"))
		for idx, item := range m.GetFilter() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["group_by"]; exists {

		vOpts := append(opts, db.WithValidateField("group_by"))
		for idx, item := range m.GetGroupBy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNMetricsRequestValidator = func() *ValidateLilacCDNMetricsRequest {
	v := &ValidateLilacCDNMetricsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	vrhFieldSelector := v.FieldSelectorValidationRuleHandler
	rulesFieldSelector := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "10",
	}
	vFn, err = vrhFieldSelector(rulesFieldSelector)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsRequest.field_selector: %s", err)
		panic(errMsg)
	}
	v.FldValidators["field_selector"] = vFn

	v.FldValidators["filter"] = LilacCDNMetricsFilterValidator().Validate

	return v
}()

func LilacCDNMetricsRequestValidator() db.Validator {
	return DefaultLilacCDNMetricsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNMetricsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNMetricsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNMetricsResponse) DeepCopy() *LilacCDNMetricsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNMetricsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNMetricsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNMetricsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNMetricsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNMetricsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNMetricsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNMetricsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNMetricsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNMetricsResponseValidator = func() *ValidateLilacCDNMetricsResponse {
	v := &ValidateLilacCDNMetricsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LilacCDNMetricsResponseValidator() db.Validator {
	return DefaultLilacCDNMetricsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ListServiceOperationsReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListServiceOperationsReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListServiceOperationsReq) DeepCopy() *ListServiceOperationsReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListServiceOperationsReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListServiceOperationsReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListServiceOperationsReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListServiceOperationsReqValidator().Validate(ctx, m, opts...)
}

type ValidateListServiceOperationsReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListServiceOperationsReq) OptionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for options")
	}
	return validatorFn, nil
}

func (v *ValidateListServiceOperationsReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateListServiceOperationsReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListServiceOperationsReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListServiceOperationsReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["options"]; exists {
		val := m.GetOptions()
		vOpts := append(opts,
			db.WithValidateField("options"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOptions().(type) {
	case *ListServiceOperationsReq_TimeRange:
		if fv, exists := v.FldValidators["options.time_range"]; exists {
			val := m.GetOptions().(*ListServiceOperationsReq_TimeRange).TimeRange
			vOpts := append(opts,
				db.WithValidateField("options"),
				db.WithValidateField("time_range"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ListServiceOperationsReq_Lastn:
		if fv, exists := v.FldValidators["options.lastn"]; exists {
			val := m.GetOptions().(*ListServiceOperationsReq_Lastn).Lastn
			vOpts := append(opts,
				db.WithValidateField("options"),
				db.WithValidateField("lastn"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListServiceOperationsReqValidator = func() *ValidateListServiceOperationsReq {
	v := &ValidateListServiceOperationsReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOptions := v.OptionsValidationRuleHandler
	rulesOptions := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhOptions(rulesOptions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListServiceOperationsReq.options: %s", err)
		panic(errMsg)
	}
	v.FldValidators["options"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListServiceOperationsReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	v.FldValidators["options.time_range"] = ServiceOperationsTimeRangeValidator().Validate

	return v
}()

func ListServiceOperationsReqValidator() db.Validator {
	return DefaultListServiceOperationsReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ListServiceOperationsRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListServiceOperationsRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListServiceOperationsRsp) DeepCopy() *ListServiceOperationsRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListServiceOperationsRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListServiceOperationsRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListServiceOperationsRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListServiceOperationsRspValidator().Validate(ctx, m, opts...)
}

type ValidateListServiceOperationsRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListServiceOperationsRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListServiceOperationsRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListServiceOperationsRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error"]; exists {

		vOpts := append(opts, db.WithValidateField("error"))
		if err := fv(ctx, m.GetError(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListServiceOperationsRspValidator = func() *ValidateListServiceOperationsRsp {
	v := &ValidateListServiceOperationsRsp{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ServiceOperationsItemValidator().Validate

	return v
}()

func ListServiceOperationsRspValidator() db.Validator {
	return DefaultListServiceOperationsRspValidator
}

// augmented methods on protoc/std generated struct

func (m *PurgeOperationItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PurgeOperationItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PurgeOperationItem) DeepCopy() *PurgeOperationItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PurgeOperationItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PurgeOperationItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PurgeOperationItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PurgeOperationItemValidator().Validate(ctx, m, opts...)
}

type ValidatePurgeOperationItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePurgeOperationItem) PurgeTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for purge_time")
	}

	return validatorFn, nil
}

func (v *ValidatePurgeOperationItem) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidatePurgeOperationItem) FinishTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for finish_time")
	}

	return validatorFn, nil
}

func (v *ValidatePurgeOperationItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PurgeOperationItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PurgeOperationItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bytes_not_purged"]; exists {

		vOpts := append(opts, db.WithValidateField("bytes_not_purged"))
		if err := fv(ctx, m.GetBytesNotPurged(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bytes_purged"]; exists {

		vOpts := append(opts, db.WithValidateField("bytes_purged"))
		if err := fv(ctx, m.GetBytesPurged(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["finish_time"]; exists {

		vOpts := append(opts, db.WithValidateField("finish_time"))
		if err := fv(ctx, m.GetFinishTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["hard_purge"]; exists {

		vOpts := append(opts, db.WithValidateField("hard_purge"))
		if err := fv(ctx, m.GetHardPurge(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["purge_time"]; exists {

		vOpts := append(opts, db.WithValidateField("purge_time"))
		if err := fv(ctx, m.GetPurgeTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regexp"]; exists {

		vOpts := append(opts, db.WithValidateField("regexp"))
		if err := fv(ctx, m.GetRegexp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPurgeOperationItemValidator = func() *ValidatePurgeOperationItem {
	v := &ValidatePurgeOperationItem{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPurgeTime := v.PurgeTimeValidationRuleHandler
	rulesPurgeTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhPurgeTime(rulesPurgeTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PurgeOperationItem.purge_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["purge_time"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PurgeOperationItem.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhFinishTime := v.FinishTimeValidationRuleHandler
	rulesFinishTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhFinishTime(rulesFinishTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PurgeOperationItem.finish_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["finish_time"] = vFn

	return v
}()

func PurgeOperationItemValidator() db.Validator {
	return DefaultPurgeOperationItemValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceOperationItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceOperationItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceOperationItem) DeepCopy() *ServiceOperationItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceOperationItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceOperationItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceOperationItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceOperationItemValidator().Validate(ctx, m, opts...)
}

type ValidateServiceOperationItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceOperationItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceOperationItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceOperationItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOpStatus().(type) {
	case *ServiceOperationItem_Purge:
		if fv, exists := v.FldValidators["op_status.purge"]; exists {
			val := m.GetOpStatus().(*ServiceOperationItem_Purge).Purge
			vOpts := append(opts,
				db.WithValidateField("op_status"),
				db.WithValidateField("purge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_op_id"]; exists {

		vOpts := append(opts, db.WithValidateField("service_op_id"))
		if err := fv(ctx, m.GetServiceOpId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceOperationItemValidator = func() *ValidateServiceOperationItem {
	v := &ValidateServiceOperationItem{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["op_status.purge"] = PurgeOperationItemValidator().Validate

	return v
}()

func ServiceOperationItemValidator() db.Validator {
	return DefaultServiceOperationItemValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceOperationsItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceOperationsItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceOperationsItem) DeepCopy() *ServiceOperationsItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceOperationsItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceOperationsItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceOperationsItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceOperationsItemValidator().Validate(ctx, m, opts...)
}

type ValidateServiceOperationsItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceOperationsItem) CreatedTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for created_time")
	}

	return validatorFn, nil
}

func (v *ValidateServiceOperationsItem) ModifiedTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for modified_time")
	}

	return validatorFn, nil
}

func (v *ValidateServiceOperationsItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceOperationsItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceOperationsItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["created_time"]; exists {

		vOpts := append(opts, db.WithValidateField("created_time"))
		if err := fv(ctx, m.GetCreatedTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["modified_time"]; exists {

		vOpts := append(opts, db.WithValidateField("modified_time"))
		if err := fv(ctx, m.GetModifiedTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_op_id"]; exists {

		vOpts := append(opts, db.WithValidateField("service_op_id"))
		if err := fv(ctx, m.GetServiceOpId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["svc_version"]; exists {

		vOpts := append(opts, db.WithValidateField("svc_version"))
		if err := fv(ctx, m.GetSvcVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceOperationsItemValidator = func() *ValidateServiceOperationsItem {
	v := &ValidateServiceOperationsItem{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCreatedTime := v.CreatedTimeValidationRuleHandler
	rulesCreatedTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhCreatedTime(rulesCreatedTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceOperationsItem.created_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["created_time"] = vFn

	vrhModifiedTime := v.ModifiedTimeValidationRuleHandler
	rulesModifiedTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhModifiedTime(rulesModifiedTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceOperationsItem.modified_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["modified_time"] = vFn

	return v
}()

func ServiceOperationsItemValidator() db.Validator {
	return DefaultServiceOperationsItemValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceOperationsTimeRange) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceOperationsTimeRange) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceOperationsTimeRange) DeepCopy() *ServiceOperationsTimeRange {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceOperationsTimeRange{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceOperationsTimeRange) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceOperationsTimeRange) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceOperationsTimeRangeValidator().Validate(ctx, m, opts...)
}

type ValidateServiceOperationsTimeRange struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceOperationsTimeRange) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateServiceOperationsTimeRange) FinishTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for finish_time")
	}

	return validatorFn, nil
}

func (v *ValidateServiceOperationsTimeRange) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceOperationsTimeRange)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceOperationsTimeRange got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["finish_time"]; exists {

		vOpts := append(opts, db.WithValidateField("finish_time"))
		if err := fv(ctx, m.GetFinishTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceOperationsTimeRangeValidator = func() *ValidateServiceOperationsTimeRange {
	v := &ValidateServiceOperationsTimeRange{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required":  "true",
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceOperationsTimeRange.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhFinishTime := v.FinishTimeValidationRuleHandler
	rulesFinishTime := map[string]string{
		"ves.io.schema.rules.message.required":  "true",
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhFinishTime(rulesFinishTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServiceOperationsTimeRange.finish_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["finish_time"] = vFn

	return v
}()

func ServiceOperationsTimeRangeValidator() db.Validator {
	return DefaultServiceOperationsTimeRangeValidator
}

// augmented methods on protoc/std generated struct

func (m *SubscribeRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubscribeRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubscribeRequest) DeepCopy() *SubscribeRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubscribeRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubscribeRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubscribeRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubscribeRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSubscribeRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubscribeRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubscribeRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubscribeRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubscribeRequestValidator = func() *ValidateSubscribeRequest {
	v := &ValidateSubscribeRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubscribeRequestValidator() db.Validator {
	return DefaultSubscribeRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SubscribeResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubscribeResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubscribeResponse) DeepCopy() *SubscribeResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubscribeResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubscribeResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubscribeResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubscribeResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSubscribeResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubscribeResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubscribeResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubscribeResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubscribeResponseValidator = func() *ValidateSubscribeResponse {
	v := &ValidateSubscribeResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubscribeResponseValidator() db.Validator {
	return DefaultSubscribeResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UnsubscribeRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UnsubscribeRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UnsubscribeRequest) DeepCopy() *UnsubscribeRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UnsubscribeRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UnsubscribeRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UnsubscribeRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UnsubscribeRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUnsubscribeRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUnsubscribeRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UnsubscribeRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UnsubscribeRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUnsubscribeRequestValidator = func() *ValidateUnsubscribeRequest {
	v := &ValidateUnsubscribeRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UnsubscribeRequestValidator() db.Validator {
	return DefaultUnsubscribeRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UnsubscribeResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UnsubscribeResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UnsubscribeResponse) DeepCopy() *UnsubscribeResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UnsubscribeResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UnsubscribeResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UnsubscribeResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UnsubscribeResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUnsubscribeResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUnsubscribeResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UnsubscribeResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UnsubscribeResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUnsubscribeResponseValidator = func() *ValidateUnsubscribeResponse {
	v := &ValidateUnsubscribeResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UnsubscribeResponseValidator() db.Validator {
	return DefaultUnsubscribeResponseValidator
}
