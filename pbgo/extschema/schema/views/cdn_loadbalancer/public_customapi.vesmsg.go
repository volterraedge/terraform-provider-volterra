// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
package cdn_loadbalancer

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log"
	ves_io_schema_views_cdn_loadbalancer_access_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/cdn_loadbalancer/access_log"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CDNAccessLogAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNAccessLogAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNAccessLogAggregationRequest) DeepCopy() *CDNAccessLogAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNAccessLogAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNAccessLogAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNAccessLogAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNAccessLogAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCDNAccessLogAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNAccessLogAggregationRequest) AggsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for aggs")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*CDNAggregationRequest, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := CDNAggregationRequestValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for aggs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*CDNAggregationRequest)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*CDNAggregationRequest, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map aggs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items aggs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNAccessLogAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNAccessLogAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {
		vOpts := append(opts, db.WithValidateField("aggs"))
		if err := fv(ctx, m.GetAggs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		for idx, item := range m.GetQuery() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNAccessLogAggregationRequestValidator = func() *ValidateCDNAccessLogAggregationRequest {
	v := &ValidateCDNAccessLogAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAggs := v.AggsValidationRuleHandler
	rulesAggs := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "64",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "16",
	}
	vFn, err = vrhAggs(rulesAggs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogAggregationRequest.aggs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aggs"] = vFn

	v.FldValidators["query"] = CDNAccessLogFilterValidator().Validate

	return v
}()

func CDNAccessLogAggregationRequestValidator() db.Validator {
	return DefaultCDNAccessLogAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNAccessLogFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNAccessLogFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNAccessLogFilter) DeepCopy() *CDNAccessLogFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNAccessLogFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNAccessLogFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNAccessLogFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNAccessLogFilterValidator().Validate(ctx, m, opts...)
}

type ValidateCDNAccessLogFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNAccessLogFilter) TagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag)
		return int32(i)
	}
	// ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tag")
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogFilter) ValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogFilter) OperatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(CDNAccessLogOperatorType)
		return int32(i)
	}
	// CDNAccessLogOperatorType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, CDNAccessLogOperatorType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operator")
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNAccessLogFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNAccessLogFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tag"]; exists {

		vOpts := append(opts, db.WithValidateField("tag"))
		if err := fv(ctx, m.GetTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["values"]; exists {
		vOpts := append(opts, db.WithValidateField("values"))
		if err := fv(ctx, m.GetValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNAccessLogFilterValidator = func() *ValidateCDNAccessLogFilter {
	v := &ValidateCDNAccessLogFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTag := v.TagValidationRuleHandler
	rulesTag := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTag(rulesTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogFilter.tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tag"] = vFn

	vrhValues := v.ValuesValidationRuleHandler
	rulesValues := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.items.string.max_len": "128",
		"ves.io.schema.rules.repeated.max_items":            "32",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhValues(rulesValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogFilter.values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["values"] = vFn

	vrhOperator := v.OperatorValidationRuleHandler
	rulesOperator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOperator(rulesOperator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogFilter.operator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operator"] = vFn

	return v
}()

func CDNAccessLogFilterValidator() db.Validator {
	return DefaultCDNAccessLogFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNAccessLogRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNAccessLogRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNAccessLogRequest) DeepCopy() *CDNAccessLogRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNAccessLogRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNAccessLogRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNAccessLogRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNAccessLogRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCDNAccessLogRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNAccessLogRequest) QueryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for query")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CDNAccessLogFilter, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CDNAccessLogFilterValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CDNAccessLogFilter)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CDNAccessLogFilter, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogRequest) LimitValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for limit")
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogRequest) AggsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for aggs")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*CDNAggregationRequest, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := CDNAggregationRequestValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for aggs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*CDNAggregationRequest)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*CDNAggregationRequest, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map aggs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items aggs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNAccessLogRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNAccessLogRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNAccessLogRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {
		vOpts := append(opts, db.WithValidateField("aggs"))
		if err := fv(ctx, m.GetAggs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {
		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNAccessLogRequestValidator = func() *ValidateCDNAccessLogRequest {
	v := &ValidateCDNAccessLogRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQuery := v.QueryValidationRuleHandler
	rulesQuery := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhQuery(rulesQuery)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogRequest.query: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query"] = vFn

	vrhLimit := v.LimitValidationRuleHandler
	rulesLimit := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "500",
	}
	vFn, err = vrhLimit(rulesLimit)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogRequest.limit: %s", err)
		panic(errMsg)
	}
	v.FldValidators["limit"] = vFn

	vrhAggs := v.AggsValidationRuleHandler
	rulesAggs := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "64",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "16",
	}
	vFn, err = vrhAggs(rulesAggs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNAccessLogRequest.aggs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aggs"] = vFn

	return v
}()

func CDNAccessLogRequestValidator() db.Validator {
	return DefaultCDNAccessLogRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNAggregationRequest) DeepCopy() *CDNAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCDNAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAggregationType().(type) {
	case *CDNAggregationRequest_DateAggregation:
		if fv, exists := v.FldValidators["aggregation_type.date_aggregation"]; exists {
			val := m.GetAggregationType().(*CDNAggregationRequest_DateAggregation).DateAggregation
			vOpts := append(opts,
				db.WithValidateField("aggregation_type"),
				db.WithValidateField("date_aggregation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CDNAggregationRequest_FieldAggregation:
		if fv, exists := v.FldValidators["aggregation_type.field_aggregation"]; exists {
			val := m.GetAggregationType().(*CDNAggregationRequest_FieldAggregation).FieldAggregation
			vOpts := append(opts,
				db.WithValidateField("aggregation_type"),
				db.WithValidateField("field_aggregation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNAggregationRequestValidator = func() *ValidateCDNAggregationRequest {
	v := &ValidateCDNAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggregation_type.date_aggregation"] = CDNDateAggregationValidator().Validate
	v.FldValidators["aggregation_type.field_aggregation"] = CDNFieldAggregationValidator().Validate

	return v
}()

func CDNAggregationRequestValidator() db.Validator {
	return DefaultCDNAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNDateAggregation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNDateAggregation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNDateAggregation) DeepCopy() *CDNDateAggregation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNDateAggregation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNDateAggregation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNDateAggregation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNDateAggregationValidator().Validate(ctx, m, opts...)
}

type ValidateCDNDateAggregation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNDateAggregation) StepValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for step")
	}

	return validatorFn, nil
}

func (v *ValidateCDNDateAggregation) SubAggsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for sub_aggs")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*CDNDateSubAggregation, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := CDNDateSubAggregationValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for sub_aggs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*CDNDateSubAggregation)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*CDNDateSubAggregation, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map sub_aggs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items sub_aggs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNDateAggregation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNDateAggregation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNDateAggregation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sub_aggs"]; exists {
		vOpts := append(opts, db.WithValidateField("sub_aggs"))
		if err := fv(ctx, m.GetSubAggs(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNDateAggregationValidator = func() *ValidateCDNDateAggregation {
	v := &ValidateCDNDateAggregation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStep := v.StepValidationRuleHandler
	rulesStep := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStep(rulesStep)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNDateAggregation.step: %s", err)
		panic(errMsg)
	}
	v.FldValidators["step"] = vFn

	vrhSubAggs := v.SubAggsValidationRuleHandler
	rulesSubAggs := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "64",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "16",
	}
	vFn, err = vrhSubAggs(rulesSubAggs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNDateAggregation.sub_aggs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sub_aggs"] = vFn

	return v
}()

func CDNDateAggregationValidator() db.Validator {
	return DefaultCDNDateAggregationValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNDateSubAggregation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNDateSubAggregation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNDateSubAggregation) DeepCopy() *CDNDateSubAggregation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNDateSubAggregation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNDateSubAggregation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNDateSubAggregation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNDateSubAggregationValidator().Validate(ctx, m, opts...)
}

type ValidateCDNDateSubAggregation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNDateSubAggregation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNDateSubAggregation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNDateSubAggregation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAggregationType().(type) {
	case *CDNDateSubAggregation_FieldAggregation:
		if fv, exists := v.FldValidators["aggregation_type.field_aggregation"]; exists {
			val := m.GetAggregationType().(*CDNDateSubAggregation_FieldAggregation).FieldAggregation
			vOpts := append(opts,
				db.WithValidateField("aggregation_type"),
				db.WithValidateField("field_aggregation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNDateSubAggregationValidator = func() *ValidateCDNDateSubAggregation {
	v := &ValidateCDNDateSubAggregation{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggregation_type.field_aggregation"] = CDNFieldAggregationValidator().Validate

	return v
}()

func CDNDateSubAggregationValidator() db.Validator {
	return DefaultCDNDateSubAggregationValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNFieldAggregation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNFieldAggregation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNFieldAggregation) DeepCopy() *CDNFieldAggregation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNFieldAggregation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNFieldAggregation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNFieldAggregation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNFieldAggregationValidator().Validate(ctx, m, opts...)
}

type ValidateCDNFieldAggregation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNFieldAggregation) FieldValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag)
		return int32(i)
	}
	// ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_views_cdn_loadbalancer_access_log.CDNAccessLogTag_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for field")
	}

	return validatorFn, nil
}

func (v *ValidateCDNFieldAggregation) TopkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for topk")
	}

	return validatorFn, nil
}

func (v *ValidateCDNFieldAggregation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNFieldAggregation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNFieldAggregation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["field"]; exists {

		vOpts := append(opts, db.WithValidateField("field"))
		if err := fv(ctx, m.GetField(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["topk"]; exists {

		vOpts := append(opts, db.WithValidateField("topk"))
		if err := fv(ctx, m.GetTopk(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNFieldAggregationValidator = func() *ValidateCDNFieldAggregation {
	v := &ValidateCDNFieldAggregation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhField := v.FieldValidationRuleHandler
	rulesField := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhField(rulesField)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNFieldAggregation.field: %s", err)
		panic(errMsg)
	}
	v.FldValidators["field"] = vFn

	vrhTopk := v.TopkValidationRuleHandler
	rulesTopk := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFn, err = vrhTopk(rulesTopk)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNFieldAggregation.topk: %s", err)
		panic(errMsg)
	}
	v.FldValidators["topk"] = vFn

	return v
}()

func CDNFieldAggregationValidator() db.Validator {
	return DefaultCDNFieldAggregationValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNLogAggregationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNLogAggregationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNLogAggregationResponse) DeepCopy() *CDNLogAggregationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNLogAggregationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNLogAggregationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNLogAggregationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNLogAggregationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCDNLogAggregationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNLogAggregationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNLogAggregationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNLogAggregationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNLogAggregationResponseValidator = func() *ValidateCDNLogAggregationResponse {
	v := &ValidateCDNLogAggregationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func CDNLogAggregationResponseValidator() db.Validator {
	return DefaultCDNLogAggregationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNLogResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNLogResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNLogResponse) DeepCopy() *CDNLogResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNLogResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNLogResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNLogResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNLogResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCDNLogResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNLogResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNLogResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNLogResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["logs"]; exists {

		vOpts := append(opts, db.WithValidateField("logs"))
		for idx, item := range m.GetLogs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNLogResponseValidator = func() *ValidateCDNLogResponse {
	v := &ValidateCDNLogResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["logs"] = LilacCDNAccessLogsResponseDataValidator().Validate

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func CDNLogResponseValidator() db.Validator {
	return DefaultCDNLogResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNAccessLogsResponseData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNAccessLogsResponseData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNAccessLogsResponseData) DeepCopy() *LilacCDNAccessLogsResponseData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNAccessLogsResponseData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNAccessLogsResponseData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNAccessLogsResponseData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNAccessLogsResponseDataValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNAccessLogsResponseData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNAccessLogsResponseData) TimestampValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for timestamp")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNAccessLogsResponseData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNAccessLogsResponseData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNAccessLogsResponseData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_status"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_status"))
		if err := fv(ctx, m.GetCacheStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cdn_name"]; exists {

		vOpts := append(opts, db.WithValidateField("cdn_name"))
		if err := fv(ctx, m.GetCdnName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["city_id"]; exists {

		vOpts := append(opts, db.WithValidateField("city_id"))
		if err := fv(ctx, m.GetCityId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["city_name"]; exists {

		vOpts := append(opts, db.WithValidateField("city_name"))
		if err := fv(ctx, m.GetCityName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_port"]; exists {

		vOpts := append(opts, db.WithValidateField("client_port"))
		if err := fv(ctx, m.GetClientPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["country"]; exists {

		vOpts := append(opts, db.WithValidateField("country"))
		if err := fv(ctx, m.GetCountry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["geo_location"]; exists {

		vOpts := append(opts, db.WithValidateField("geo_location"))
		if err := fv(ctx, m.GetGeoLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host"]; exists {

		vOpts := append(opts, db.WithValidateField("host"))
		if err := fv(ctx, m.GetHost(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_header"]; exists {

		vOpts := append(opts, db.WithValidateField("host_header"))
		if err := fv(ctx, m.GetHostHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_version"]; exists {

		vOpts := append(opts, db.WithValidateField("http_version"))
		if err := fv(ctx, m.GetHttpVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["method"]; exists {

		vOpts := append(opts, db.WithValidateField("method"))
		if err := fv(ctx, m.GetMethod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["referer"]; exists {

		vOpts := append(opts, db.WithValidateField("referer"))
		if err := fv(ctx, m.GetReferer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["req_content_type"]; exists {

		vOpts := append(opts, db.WithValidateField("req_content_type"))
		if err := fv(ctx, m.GetReqContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["req_path"]; exists {

		vOpts := append(opts, db.WithValidateField("req_path"))
		if err := fv(ctx, m.GetReqPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["req_size"]; exists {

		vOpts := append(opts, db.WithValidateField("req_size"))
		if err := fv(ctx, m.GetReqSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_time"]; exists {

		vOpts := append(opts, db.WithValidateField("request_time"))
		if err := fv(ctx, m.GetRequestTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsp_code"]; exists {

		vOpts := append(opts, db.WithValidateField("rsp_code"))
		if err := fv(ctx, m.GetRspCode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsp_code_class"]; exists {

		vOpts := append(opts, db.WithValidateField("rsp_code_class"))
		if err := fv(ctx, m.GetRspCodeClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsp_content_type"]; exists {

		vOpts := append(opts, db.WithValidateField("rsp_content_type"))
		if err := fv(ctx, m.GetRspContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rsp_size"]; exists {

		vOpts := append(opts, db.WithValidateField("rsp_size"))
		if err := fv(ctx, m.GetRspSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scheme"]; exists {

		vOpts := append(opts, db.WithValidateField("scheme"))
		if err := fv(ctx, m.GetScheme(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_name"]; exists {

		vOpts := append(opts, db.WithValidateField("site_name"))
		if err := fv(ctx, m.GetSiteName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["src_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("src_ip"))
		if err := fv(ctx, m.GetSrcIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("timestamp"))
		if err := fv(ctx, m.GetTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_sni"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_sni"))
		if err := fv(ctx, m.GetTlsSni(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_version"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_version"))
		if err := fv(ctx, m.GetTlsVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upstream_addr"]; exists {

		vOpts := append(opts, db.WithValidateField("upstream_addr"))
		if err := fv(ctx, m.GetUpstreamAddr(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upstream_connect_time"]; exists {

		vOpts := append(opts, db.WithValidateField("upstream_connect_time"))
		if err := fv(ctx, m.GetUpstreamConnectTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upstream_response_time"]; exists {

		vOpts := append(opts, db.WithValidateField("upstream_response_time"))
		if err := fv(ctx, m.GetUpstreamResponseTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upstream_status"]; exists {

		vOpts := append(opts, db.WithValidateField("upstream_status"))
		if err := fv(ctx, m.GetUpstreamStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user"]; exists {

		vOpts := append(opts, db.WithValidateField("user"))
		if err := fv(ctx, m.GetUser(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_agent"]; exists {

		vOpts := append(opts, db.WithValidateField("user_agent"))
		if err := fv(ctx, m.GetUserAgent(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNAccessLogsResponseDataValidator = func() *ValidateLilacCDNAccessLogsResponseData {
	v := &ValidateLilacCDNAccessLogsResponseData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTimestamp := v.TimestampValidationRuleHandler
	rulesTimestamp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTimestamp(rulesTimestamp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNAccessLogsResponseData.timestamp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["timestamp"] = vFn

	return v
}()

func LilacCDNAccessLogsResponseDataValidator() db.Validator {
	return DefaultLilacCDNAccessLogsResponseDataValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNCachePurgeRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNCachePurgeRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNCachePurgeRequest) DeepCopy() *LilacCDNCachePurgeRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNCachePurgeRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNCachePurgeRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNCachePurgeRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNCachePurgeRequestValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNCachePurgeRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNCachePurgeRequest) PurgeTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for purge_type")
	}
	return validatorFn, nil
}

func (v *ValidateLilacCDNCachePurgeRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNCachePurgeRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNCachePurgeRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNCachePurgeRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNCachePurgeRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pattern"]; exists {

		vOpts := append(opts, db.WithValidateField("pattern"))
		if err := fv(ctx, m.GetPattern(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["purge_epoch_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("purge_epoch_timestamp"))
		if err := fv(ctx, m.GetPurgeEpochTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["purge_type"]; exists {
		val := m.GetPurgeType()
		vOpts := append(opts,
			db.WithValidateField("purge_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPurgeType().(type) {
	case *LilacCDNCachePurgeRequest_SoftPurge:
		if fv, exists := v.FldValidators["purge_type.soft_purge"]; exists {
			val := m.GetPurgeType().(*LilacCDNCachePurgeRequest_SoftPurge).SoftPurge
			vOpts := append(opts,
				db.WithValidateField("purge_type"),
				db.WithValidateField("soft_purge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LilacCDNCachePurgeRequest_HardPurge:
		if fv, exists := v.FldValidators["purge_type.hard_purge"]; exists {
			val := m.GetPurgeType().(*LilacCDNCachePurgeRequest_HardPurge).HardPurge
			vOpts := append(opts,
				db.WithValidateField("purge_type"),
				db.WithValidateField("hard_purge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNCachePurgeRequestValidator = func() *ValidateLilacCDNCachePurgeRequest {
	v := &ValidateLilacCDNCachePurgeRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPurgeType := v.PurgeTypeValidationRuleHandler
	rulesPurgeType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPurgeType(rulesPurgeType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNCachePurgeRequest.purge_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["purge_type"] = vFn

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNCachePurgeRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNCachePurgeRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func LilacCDNCachePurgeRequestValidator() db.Validator {
	return DefaultLilacCDNCachePurgeRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNCachePurgeResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNCachePurgeResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNCachePurgeResponse) DeepCopy() *LilacCDNCachePurgeResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNCachePurgeResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNCachePurgeResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNCachePurgeResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNCachePurgeResponseValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNCachePurgeResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNCachePurgeResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNCachePurgeResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNCachePurgeResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["purge_request_id"]; exists {

		vOpts := append(opts, db.WithValidateField("purge_request_id"))
		if err := fv(ctx, m.GetPurgeRequestId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNCachePurgeResponseValidator = func() *ValidateLilacCDNCachePurgeResponse {
	v := &ValidateLilacCDNCachePurgeResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LilacCDNCachePurgeResponseValidator() db.Validator {
	return DefaultLilacCDNCachePurgeResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNMetricsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNMetricsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNMetricsRequest) DeepCopy() *LilacCDNMetricsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNMetricsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNMetricsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNMetricsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNMetricsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNMetricsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNMetricsRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsRequest) FieldSelectorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(LilacCDNMetricsFieldSelector)
		return int32(i)
	}
	// LilacCDNMetricsFieldSelector_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, LilacCDNMetricsFieldSelector_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for field_selector")
	}
	itemsValidatorFn := func(ctx context.Context, elems []LilacCDNMetricsFieldSelector, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for field_selector")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]LilacCDNMetricsFieldSelector)
		if !ok {
			return fmt.Errorf("Repeated validation expected []LilacCDNMetricsFieldSelector, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated field_selector")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items field_selector")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNMetricsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNMetricsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["field_selector"]; exists {
		vOpts := append(opts, db.WithValidateField("field_selector"))
		if err := fv(ctx, m.GetFieldSelector(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filter"]; exists {

		vOpts := append(opts, db.WithValidateField("filter"))
		for idx, item := range m.GetFilter() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["group_by"]; exists {

		vOpts := append(opts, db.WithValidateField("group_by"))
		for idx, item := range m.GetGroupBy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNMetricsRequestValidator = func() *ValidateLilacCDNMetricsRequest {
	v := &ValidateLilacCDNMetricsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	vrhFieldSelector := v.FieldSelectorValidationRuleHandler
	rulesFieldSelector := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "10",
	}
	vFn, err = vrhFieldSelector(rulesFieldSelector)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsRequest.field_selector: %s", err)
		panic(errMsg)
	}
	v.FldValidators["field_selector"] = vFn

	v.FldValidators["filter"] = LilacCDNMetricsFilterValidator().Validate

	return v
}()

func LilacCDNMetricsRequestValidator() db.Validator {
	return DefaultLilacCDNMetricsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNMetricsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNMetricsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNMetricsResponse) DeepCopy() *LilacCDNMetricsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNMetricsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNMetricsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNMetricsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNMetricsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNMetricsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNMetricsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNMetricsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNMetricsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNMetricsResponseValidator = func() *ValidateLilacCDNMetricsResponse {
	v := &ValidateLilacCDNMetricsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LilacCDNMetricsResponseValidator() db.Validator {
	return DefaultLilacCDNMetricsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SubscribeRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubscribeRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubscribeRequest) DeepCopy() *SubscribeRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubscribeRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubscribeRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubscribeRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubscribeRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSubscribeRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubscribeRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubscribeRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubscribeRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubscribeRequestValidator = func() *ValidateSubscribeRequest {
	v := &ValidateSubscribeRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubscribeRequestValidator() db.Validator {
	return DefaultSubscribeRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SubscribeResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubscribeResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubscribeResponse) DeepCopy() *SubscribeResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubscribeResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubscribeResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubscribeResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubscribeResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSubscribeResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubscribeResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubscribeResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubscribeResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubscribeResponseValidator = func() *ValidateSubscribeResponse {
	v := &ValidateSubscribeResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubscribeResponseValidator() db.Validator {
	return DefaultSubscribeResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UnsubscribeRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UnsubscribeRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UnsubscribeRequest) DeepCopy() *UnsubscribeRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UnsubscribeRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UnsubscribeRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UnsubscribeRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UnsubscribeRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUnsubscribeRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUnsubscribeRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UnsubscribeRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UnsubscribeRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUnsubscribeRequestValidator = func() *ValidateUnsubscribeRequest {
	v := &ValidateUnsubscribeRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UnsubscribeRequestValidator() db.Validator {
	return DefaultUnsubscribeRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UnsubscribeResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UnsubscribeResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UnsubscribeResponse) DeepCopy() *UnsubscribeResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UnsubscribeResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UnsubscribeResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UnsubscribeResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UnsubscribeResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUnsubscribeResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUnsubscribeResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UnsubscribeResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UnsubscribeResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUnsubscribeResponseValidator = func() *ValidateUnsubscribeResponse {
	v := &ValidateUnsubscribeResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UnsubscribeResponseValidator() db.Validator {
	return DefaultUnsubscribeResponseValidator
}
