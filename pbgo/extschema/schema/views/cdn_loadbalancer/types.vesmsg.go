// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package cdn_loadbalancer

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_http_loadbalancer "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/http_loadbalancer"
	ves_io_schema_views_origin_pool "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/origin_pool"
	ves_io_schema_virtual_host_dns_info "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host_dns_info"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AdvancedOptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AdvancedOptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AdvancedOptionsType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetHeaderOptions().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AdvancedOptionsType.header_options")
	}

	if err := m.GetSecurityOptions().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AdvancedOptionsType.security_options")
	}

	return nil
}

func (m *AdvancedOptionsType) DeepCopy() *AdvancedOptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AdvancedOptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AdvancedOptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AdvancedOptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AdvancedOptionsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAdvancedOptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAdvancedOptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AdvancedOptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AdvancedOptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_options"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_options"))
		if err := fv(ctx, m.GetCacheOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cache_ttl_options"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_ttl_options"))
		if err := fv(ctx, m.GetCacheTtlOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_options"]; exists {

		vOpts := append(opts, db.WithValidateField("header_options"))
		if err := fv(ctx, m.GetHeaderOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logging_options"]; exists {

		vOpts := append(opts, db.WithValidateField("logging_options"))
		if err := fv(ctx, m.GetLoggingOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["security_options"]; exists {

		vOpts := append(opts, db.WithValidateField("security_options"))
		if err := fv(ctx, m.GetSecurityOptions(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAdvancedOptionsTypeValidator = func() *ValidateAdvancedOptionsType {
	v := &ValidateAdvancedOptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["header_options"] = HeaderControlTypeValidator().Validate

	v.FldValidators["security_options"] = SecurityOptionsTypeValidator().Validate

	v.FldValidators["logging_options"] = LoggingOptionsTypeValidator().Validate

	v.FldValidators["cache_ttl_options"] = CacheTTLOptionsTypeValidator().Validate

	v.FldValidators["cache_options"] = CacheOptionsValidator().Validate

	return v
}()

func AdvancedOptionsTypeValidator() db.Validator {
	return DefaultAdvancedOptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AuthenticationOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AuthenticationOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AuthenticationOptions) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetJwt().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AuthenticationOptions.jwt")
	}

	return nil
}

func (m *AuthenticationOptions) DeepCopy() *AuthenticationOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AuthenticationOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AuthenticationOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AuthenticationOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AuthenticationOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateAuthenticationOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAuthenticationOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AuthenticationOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AuthenticationOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetAuthOptions().(type) {
	case *AuthenticationOptions_DisableAuth:
		if fv, exists := v.FldValidators["auth_options.disable_auth"]; exists {
			val := m.GetAuthOptions().(*AuthenticationOptions_DisableAuth).DisableAuth
			vOpts := append(opts,
				db.WithValidateField("auth_options"),
				db.WithValidateField("disable_auth"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AuthenticationOptions_Jwt:
		if fv, exists := v.FldValidators["auth_options.jwt"]; exists {
			val := m.GetAuthOptions().(*AuthenticationOptions_Jwt).Jwt
			vOpts := append(opts,
				db.WithValidateField("auth_options"),
				db.WithValidateField("jwt"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AuthenticationOptions_Custom:
		if fv, exists := v.FldValidators["auth_options.custom"]; exists {
			val := m.GetAuthOptions().(*AuthenticationOptions_Custom).Custom
			vOpts := append(opts,
				db.WithValidateField("auth_options"),
				db.WithValidateField("custom"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAuthenticationOptionsValidator = func() *ValidateAuthenticationOptions {
	v := &ValidateAuthenticationOptions{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["auth_options.jwt"] = ves_io_schema_policy.JwtTokenAuthOptionsValidator().Validate
	v.FldValidators["auth_options.custom"] = CDNCustomAuthenticationValidator().Validate

	return v
}()

func AuthenticationOptionsValidator() db.Validator {
	return DefaultAuthenticationOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNCacheRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNCacheRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNCacheRule) DeepCopy() *CDNCacheRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNCacheRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNCacheRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNCacheRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNCacheRuleValidator().Validate(ctx, m, opts...)
}

type ValidateCDNCacheRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNCacheRule) CacheActionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_actions")
	}
	return validatorFn, nil
}

func (v *ValidateCDNCacheRule) RuleNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for rule_name")
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRule) RuleExpressionListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rule_expression_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CDNCacheRuleExpressionList, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CDNCacheRuleExpressionListValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rule_expression_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CDNCacheRuleExpressionList)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CDNCacheRuleExpressionList, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rule_expression_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rule_expression_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNCacheRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNCacheRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_actions"]; exists {
		val := m.GetCacheActions()
		vOpts := append(opts,
			db.WithValidateField("cache_actions"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCacheActions().(type) {
	case *CDNCacheRule_CacheBypass:
		if fv, exists := v.FldValidators["cache_actions.cache_bypass"]; exists {
			val := m.GetCacheActions().(*CDNCacheRule_CacheBypass).CacheBypass
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("cache_bypass"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CDNCacheRule_EligibleForCache:
		if fv, exists := v.FldValidators["cache_actions.eligible_for_cache"]; exists {
			val := m.GetCacheActions().(*CDNCacheRule_EligibleForCache).EligibleForCache
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("eligible_for_cache"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rule_expression_list"]; exists {
		vOpts := append(opts, db.WithValidateField("rule_expression_list"))
		if err := fv(ctx, m.GetRuleExpressionList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rule_name"]; exists {

		vOpts := append(opts, db.WithValidateField("rule_name"))
		if err := fv(ctx, m.GetRuleName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNCacheRuleValidator = func() *ValidateCDNCacheRule {
	v := &ValidateCDNCacheRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheActions := v.CacheActionsValidationRuleHandler
	rulesCacheActions := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCacheActions(rulesCacheActions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRule.cache_actions: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_actions"] = vFn

	vrhRuleName := v.RuleNameValidationRuleHandler
	rulesRuleName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFn, err = vrhRuleName(rulesRuleName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRule.rule_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule_name"] = vFn

	vrhRuleExpressionList := v.RuleExpressionListValidationRuleHandler
	rulesRuleExpressionList := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRuleExpressionList(rulesRuleExpressionList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRule.rule_expression_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule_expression_list"] = vFn

	v.FldValidators["cache_actions.eligible_for_cache"] = CacheEligibleOptionsValidator().Validate

	return v
}()

func CDNCacheRuleValidator() db.Validator {
	return DefaultCDNCacheRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNCacheRuleExpression) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNCacheRuleExpression) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNCacheRuleExpression) DeepCopy() *CDNCacheRuleExpression {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNCacheRuleExpression{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNCacheRuleExpression) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNCacheRuleExpression) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNCacheRuleExpressionValidator().Validate(ctx, m, opts...)
}

type ValidateCDNCacheRuleExpression struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNCacheRuleExpression) CacheHeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cache_headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CacheHeaderMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CacheHeaderMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cache_headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CacheHeaderMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CacheHeaderMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cache_headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cache_headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpression) QueryParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for query_parameters")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CacheQueryParameterMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CacheQueryParameterMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query_parameters")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CacheQueryParameterMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CacheQueryParameterMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query_parameters")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query_parameters")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpression) CookieMatcherValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookie_matcher")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CacheCookieMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CacheCookieMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookie_matcher")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CacheCookieMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CacheCookieMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookie_matcher")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookie_matcher")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpression) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNCacheRuleExpression)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNCacheRuleExpression got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_headers"]; exists {
		vOpts := append(opts, db.WithValidateField("cache_headers"))
		if err := fv(ctx, m.GetCacheHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookie_matcher"]; exists {
		vOpts := append(opts, db.WithValidateField("cookie_matcher"))
		if err := fv(ctx, m.GetCookieMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_match"]; exists {

		vOpts := append(opts, db.WithValidateField("path_match"))
		if err := fv(ctx, m.GetPathMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query_parameters"]; exists {
		vOpts := append(opts, db.WithValidateField("query_parameters"))
		if err := fv(ctx, m.GetQueryParameters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNCacheRuleExpressionValidator = func() *ValidateCDNCacheRuleExpression {
	v := &ValidateCDNCacheRuleExpression{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheHeaders := v.CacheHeadersValidationRuleHandler
	rulesCacheHeaders := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCacheHeaders(rulesCacheHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpression.cache_headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_headers"] = vFn

	vrhQueryParameters := v.QueryParametersValidationRuleHandler
	rulesQueryParameters := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhQueryParameters(rulesQueryParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpression.query_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_parameters"] = vFn

	vrhCookieMatcher := v.CookieMatcherValidationRuleHandler
	rulesCookieMatcher := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCookieMatcher(rulesCookieMatcher)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpression.cookie_matcher: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_matcher"] = vFn

	return v
}()

func CDNCacheRuleExpressionValidator() db.Validator {
	return DefaultCDNCacheRuleExpressionValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNCacheRuleExpressionList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNCacheRuleExpressionList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNCacheRuleExpressionList) DeepCopy() *CDNCacheRuleExpressionList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNCacheRuleExpressionList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNCacheRuleExpressionList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNCacheRuleExpressionList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNCacheRuleExpressionListValidator().Validate(ctx, m, opts...)
}

type ValidateCDNCacheRuleExpressionList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNCacheRuleExpressionList) ExpressionNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for expression_name")
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpressionList) CacheRuleExpressionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cache_rule_expression")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CDNCacheRuleExpression, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CDNCacheRuleExpressionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cache_rule_expression")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CDNCacheRuleExpression)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CDNCacheRuleExpression, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cache_rule_expression")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cache_rule_expression")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpressionList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNCacheRuleExpressionList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNCacheRuleExpressionList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_rule_expression"]; exists {
		vOpts := append(opts, db.WithValidateField("cache_rule_expression"))
		if err := fv(ctx, m.GetCacheRuleExpression(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["expression_name"]; exists {

		vOpts := append(opts, db.WithValidateField("expression_name"))
		if err := fv(ctx, m.GetExpressionName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNCacheRuleExpressionListValidator = func() *ValidateCDNCacheRuleExpressionList {
	v := &ValidateCDNCacheRuleExpressionList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExpressionName := v.ExpressionNameValidationRuleHandler
	rulesExpressionName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFn, err = vrhExpressionName(rulesExpressionName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpressionList.expression_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["expression_name"] = vFn

	vrhCacheRuleExpression := v.CacheRuleExpressionValidationRuleHandler
	rulesCacheRuleExpression := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCacheRuleExpression(rulesCacheRuleExpression)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpressionList.cache_rule_expression: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_rule_expression"] = vFn

	return v
}()

func CDNCacheRuleExpressionListValidator() db.Validator {
	return DefaultCDNCacheRuleExpressionListValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNCustomAuthentication) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNCustomAuthentication) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNCustomAuthentication) DeepCopy() *CDNCustomAuthentication {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNCustomAuthentication{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNCustomAuthentication) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNCustomAuthentication) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNCustomAuthenticationValidator().Validate(ctx, m, opts...)
}

type ValidateCDNCustomAuthentication struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNCustomAuthentication) CustomAuthConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_auth_config")
	}

	return validatorFn, nil
}

func (v *ValidateCDNCustomAuthentication) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNCustomAuthentication)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNCustomAuthentication got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["custom_auth_config"]; exists {

		vOpts := append(opts, db.WithValidateField("custom_auth_config"))
		if err := fv(ctx, m.GetCustomAuthConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNCustomAuthenticationValidator = func() *ValidateCDNCustomAuthentication {
	v := &ValidateCDNCustomAuthentication{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCustomAuthConfig := v.CustomAuthConfigValidationRuleHandler
	rulesCustomAuthConfig := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
	}
	vFn, err = vrhCustomAuthConfig(rulesCustomAuthConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCustomAuthentication.custom_auth_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["custom_auth_config"] = vFn

	return v
}()

func CDNCustomAuthenticationValidator() db.Validator {
	return DefaultCDNCustomAuthenticationValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNDownstreamTlsParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNDownstreamTlsParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CDNDownstreamTlsParamsType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetTlsCertificates() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting CDNDownstreamTlsParamsType.tls_certificates idx %v", idx)
		}
	}

	return nil
}

func (m *CDNDownstreamTlsParamsType) DeepCopy() *CDNDownstreamTlsParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNDownstreamTlsParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNDownstreamTlsParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNDownstreamTlsParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNDownstreamTlsParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCDNDownstreamTlsParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNDownstreamTlsParamsType) TlsCertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for tls_certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.TlsCertificateType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.TlsCertificateTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tls_certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.TlsCertificateType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.TlsCertificateType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tls_certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tls_certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNDownstreamTlsParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNDownstreamTlsParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNDownstreamTlsParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tls_certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("tls_certificates"))
		if err := fv(ctx, m.GetTlsCertificates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_config"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_config"))
		if err := fv(ctx, m.GetTlsConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNDownstreamTlsParamsTypeValidator = func() *ValidateCDNDownstreamTlsParamsType {
	v := &ValidateCDNDownstreamTlsParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTlsCertificates := v.TlsCertificatesValidationRuleHandler
	rulesTlsCertificates := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhTlsCertificates(rulesTlsCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNDownstreamTlsParamsType.tls_certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_certificates"] = vFn

	v.FldValidators["tls_config"] = CDNTLSConfigValidator().Validate

	return v
}()

func CDNDownstreamTlsParamsTypeValidator() db.Validator {
	return DefaultCDNDownstreamTlsParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNHTTPSAutoCertsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNHTTPSAutoCertsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNHTTPSAutoCertsType) DeepCopy() *CDNHTTPSAutoCertsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNHTTPSAutoCertsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNHTTPSAutoCertsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNHTTPSAutoCertsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNHTTPSAutoCertsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCDNHTTPSAutoCertsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNHTTPSAutoCertsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNHTTPSAutoCertsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNHTTPSAutoCertsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_hsts"]; exists {

		vOpts := append(opts, db.WithValidateField("add_hsts"))
		if err := fv(ctx, m.GetAddHsts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("http_redirect"))
		if err := fv(ctx, m.GetHttpRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_config"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_config"))
		if err := fv(ctx, m.GetTlsConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNHTTPSAutoCertsTypeValidator = func() *ValidateCDNHTTPSAutoCertsType {
	v := &ValidateCDNHTTPSAutoCertsType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["tls_config"] = CDNTLSConfigValidator().Validate

	return v
}()

func CDNHTTPSAutoCertsTypeValidator() db.Validator {
	return DefaultCDNHTTPSAutoCertsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNHTTPSCustomCertsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNHTTPSCustomCertsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CDNHTTPSCustomCertsType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTlsParameters().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CDNHTTPSCustomCertsType.tls_parameters")
	}

	return nil
}

func (m *CDNHTTPSCustomCertsType) DeepCopy() *CDNHTTPSCustomCertsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNHTTPSCustomCertsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNHTTPSCustomCertsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNHTTPSCustomCertsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNHTTPSCustomCertsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCDNHTTPSCustomCertsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNHTTPSCustomCertsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNHTTPSCustomCertsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNHTTPSCustomCertsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_hsts"]; exists {

		vOpts := append(opts, db.WithValidateField("add_hsts"))
		if err := fv(ctx, m.GetAddHsts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("http_redirect"))
		if err := fv(ctx, m.GetHttpRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_parameters"))
		if err := fv(ctx, m.GetTlsParameters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNHTTPSCustomCertsTypeValidator = func() *ValidateCDNHTTPSCustomCertsType {
	v := &ValidateCDNHTTPSCustomCertsType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["tls_parameters"] = CDNDownstreamTlsParamsTypeValidator().Validate

	return v
}()

func CDNHTTPSCustomCertsTypeValidator() db.Validator {
	return DefaultCDNHTTPSCustomCertsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNOriginServerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNOriginServerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNOriginServerType) DeepCopy() *CDNOriginServerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNOriginServerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNOriginServerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNOriginServerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNOriginServerTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCDNOriginServerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNOriginServerType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateCDNOriginServerType) PortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}

	return validatorFn, nil
}

func (v *ValidateCDNOriginServerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNOriginServerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNOriginServerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *CDNOriginServerType_PublicIp:
		if fv, exists := v.FldValidators["choice.public_ip"]; exists {
			val := m.GetChoice().(*CDNOriginServerType_PublicIp).PublicIp
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("public_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CDNOriginServerType_PublicName:
		if fv, exists := v.FldValidators["choice.public_name"]; exists {
			val := m.GetChoice().(*CDNOriginServerType_PublicName).PublicName
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("public_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNOriginServerTypeValidator = func() *ValidateCDNOriginServerType {
	v := &ValidateCDNOriginServerType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNOriginServerType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhPort := v.PortValidationRuleHandler
	rulesPort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhPort(rulesPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNOriginServerType.port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port"] = vFn

	v.FldValidators["choice.public_ip"] = ves_io_schema_views_origin_pool.OriginServerPublicIPValidator().Validate
	v.FldValidators["choice.public_name"] = ves_io_schema_views_origin_pool.OriginServerPublicNameValidator().Validate

	return v
}()

func CDNOriginServerTypeValidator() db.Validator {
	return DefaultCDNOriginServerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNPathMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNPathMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNPathMatcherType) DeepCopy() *CDNPathMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNPathMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNPathMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNPathMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNPathMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCDNPathMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNPathMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNPathMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNPathMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNPathMatcherTypeValidator = func() *ValidateCDNPathMatcherType {
	v := &ValidateCDNPathMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CDNPathMatcherTypeValidator() db.Validator {
	return DefaultCDNPathMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNTLSConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNTLSConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNTLSConfig) DeepCopy() *CDNTLSConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNTLSConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNTLSConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNTLSConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNTLSConfigValidator().Validate(ctx, m, opts...)
}

type ValidateCDNTLSConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNTLSConfig) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateCDNTLSConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNTLSConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNTLSConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *CDNTLSConfig_Tls_12Plus:
		if fv, exists := v.FldValidators["choice.tls_12_plus"]; exists {
			val := m.GetChoice().(*CDNTLSConfig_Tls_12Plus).Tls_12Plus
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("tls_12_plus"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CDNTLSConfig_Tls_11Plus:
		if fv, exists := v.FldValidators["choice.tls_11_plus"]; exists {
			val := m.GetChoice().(*CDNTLSConfig_Tls_11Plus).Tls_11Plus
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("tls_11_plus"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNTLSConfigValidator = func() *ValidateCDNTLSConfig {
	v := &ValidateCDNTLSConfig{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNTLSConfig.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	return v
}()

func CDNTLSConfigValidator() db.Validator {
	return DefaultCDNTLSConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheCookieMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheCookieMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheCookieMatcherType) DeepCopy() *CacheCookieMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheCookieMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheCookieMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheCookieMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheCookieMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCacheCookieMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheCookieMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCacheCookieMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheCookieMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheCookieMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheCookieMatcherTypeValidator = func() *ValidateCacheCookieMatcherType {
	v := &ValidateCacheCookieMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheCookieMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func CacheCookieMatcherTypeValidator() db.Validator {
	return DefaultCacheCookieMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheEligibleOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheEligibleOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheEligibleOptions) DeepCopy() *CacheEligibleOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheEligibleOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheEligibleOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheEligibleOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheEligibleOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateCacheEligibleOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheEligibleOptions) EligibleForCacheValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for eligible_for_cache")
	}
	return validatorFn, nil
}

func (v *ValidateCacheEligibleOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheEligibleOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheEligibleOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["eligible_for_cache"]; exists {
		val := m.GetEligibleForCache()
		vOpts := append(opts,
			db.WithValidateField("eligible_for_cache"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEligibleForCache().(type) {
	case *CacheEligibleOptions_SchemeHostnameUri:
		if fv, exists := v.FldValidators["eligible_for_cache.scheme_hostname_uri"]; exists {
			val := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeHostnameUri).SchemeHostnameUri
			vOpts := append(opts,
				db.WithValidateField("eligible_for_cache"),
				db.WithValidateField("scheme_hostname_uri"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheEligibleOptions_SchemeHostnameRequestUri:
		if fv, exists := v.FldValidators["eligible_for_cache.scheme_hostname_request_uri"]; exists {
			val := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeHostnameRequestUri).SchemeHostnameRequestUri
			vOpts := append(opts,
				db.WithValidateField("eligible_for_cache"),
				db.WithValidateField("scheme_hostname_request_uri"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheEligibleOptions_HostnameUri:
		if fv, exists := v.FldValidators["eligible_for_cache.hostname_uri"]; exists {
			val := m.GetEligibleForCache().(*CacheEligibleOptions_HostnameUri).HostnameUri
			vOpts := append(opts,
				db.WithValidateField("eligible_for_cache"),
				db.WithValidateField("hostname_uri"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheEligibleOptions_SchemeHostnameUriQuery:
		if fv, exists := v.FldValidators["eligible_for_cache.scheme_hostname_uri_query"]; exists {
			val := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeHostnameUriQuery).SchemeHostnameUriQuery
			vOpts := append(opts,
				db.WithValidateField("eligible_for_cache"),
				db.WithValidateField("scheme_hostname_uri_query"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheEligibleOptions_SchemeProxyHostUri:
		if fv, exists := v.FldValidators["eligible_for_cache.scheme_proxy_host_uri"]; exists {
			val := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeProxyHostUri).SchemeProxyHostUri
			vOpts := append(opts,
				db.WithValidateField("eligible_for_cache"),
				db.WithValidateField("scheme_proxy_host_uri"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheEligibleOptions_SchemeProxyHostRequestUri:
		if fv, exists := v.FldValidators["eligible_for_cache.scheme_proxy_host_request_uri"]; exists {
			val := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeProxyHostRequestUri).SchemeProxyHostRequestUri
			vOpts := append(opts,
				db.WithValidateField("eligible_for_cache"),
				db.WithValidateField("scheme_proxy_host_request_uri"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheEligibleOptionsValidator = func() *ValidateCacheEligibleOptions {
	v := &ValidateCacheEligibleOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEligibleForCache := v.EligibleForCacheValidationRuleHandler
	rulesEligibleForCache := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEligibleForCache(rulesEligibleForCache)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheEligibleOptions.eligible_for_cache: %s", err)
		panic(errMsg)
	}
	v.FldValidators["eligible_for_cache"] = vFn

	v.FldValidators["eligible_for_cache.scheme_hostname_uri"] = CacheTTLEnablePropsValidator().Validate
	v.FldValidators["eligible_for_cache.scheme_hostname_request_uri"] = CacheTTLEnablePropsValidator().Validate
	v.FldValidators["eligible_for_cache.hostname_uri"] = CacheTTLEnablePropsValidator().Validate
	v.FldValidators["eligible_for_cache.scheme_hostname_uri_query"] = CacheTTLEnablePropsValidator().Validate
	v.FldValidators["eligible_for_cache.scheme_proxy_host_uri"] = CacheTTLEnablePropsValidator().Validate
	v.FldValidators["eligible_for_cache.scheme_proxy_host_request_uri"] = CacheTTLEnablePropsValidator().Validate

	return v
}()

func CacheEligibleOptionsValidator() db.Validator {
	return DefaultCacheEligibleOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheHeaderMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheHeaderMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheHeaderMatcherType) DeepCopy() *CacheHeaderMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheHeaderMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheHeaderMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheHeaderMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheHeaderMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCacheHeaderMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheHeaderMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheHeaderMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheHeaderMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheHeaderMatcherTypeValidator = func() *ValidateCacheHeaderMatcherType {
	v := &ValidateCacheHeaderMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CacheHeaderMatcherTypeValidator() db.Validator {
	return DefaultCacheHeaderMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheOperator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheOperator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheOperator) DeepCopy() *CacheOperator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheOperator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheOperator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheOperator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheOperatorValidator().Validate(ctx, m, opts...)
}

type ValidateCacheOperator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheOperator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheOperator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheOperator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetCacheOperator().(type) {
	case *CacheOperator_Equals:
		if fv, exists := v.FldValidators["cache_operator.Equals"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_Equals).Equals
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("Equals"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_DoesNotEqual:
		if fv, exists := v.FldValidators["cache_operator.DoesNotEqual"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_DoesNotEqual).DoesNotEqual
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("DoesNotEqual"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_Contains:
		if fv, exists := v.FldValidators["cache_operator.Contains"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_Contains).Contains
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("Contains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_DoesNotContain:
		if fv, exists := v.FldValidators["cache_operator.DoesNotContain"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_DoesNotContain).DoesNotContain
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("DoesNotContain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_Startswith:
		if fv, exists := v.FldValidators["cache_operator.Startswith"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_Startswith).Startswith
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("Startswith"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_DoesNotStartWith:
		if fv, exists := v.FldValidators["cache_operator.DoesNotStartWith"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_DoesNotStartWith).DoesNotStartWith
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("DoesNotStartWith"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_Endswith:
		if fv, exists := v.FldValidators["cache_operator.Endswith"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_Endswith).Endswith
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("Endswith"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_DoesNotEndWith:
		if fv, exists := v.FldValidators["cache_operator.DoesNotEndWith"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_DoesNotEndWith).DoesNotEndWith
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("DoesNotEndWith"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_MatchRegex:
		if fv, exists := v.FldValidators["cache_operator.MatchRegex"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_MatchRegex).MatchRegex
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("MatchRegex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheOperatorValidator = func() *ValidateCacheOperator {
	v := &ValidateCacheOperator{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CacheOperatorValidator() db.Validator {
	return DefaultCacheOperatorValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheOptions) DeepCopy() *CacheOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateCacheOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheOptions) DefaultCacheActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for default_cache_action")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := DefaultCacheActionValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCacheOptions) CacheRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cache_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CDNCacheRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CDNCacheRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cache_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CDNCacheRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CDNCacheRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cache_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cache_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCacheOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("cache_rules"))
		if err := fv(ctx, m.GetCacheRules(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_cache_action"]; exists {

		vOpts := append(opts, db.WithValidateField("default_cache_action"))
		if err := fv(ctx, m.GetDefaultCacheAction(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheOptionsValidator = func() *ValidateCacheOptions {
	v := &ValidateCacheOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDefaultCacheAction := v.DefaultCacheActionValidationRuleHandler
	rulesDefaultCacheAction := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDefaultCacheAction(rulesDefaultCacheAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheOptions.default_cache_action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_cache_action"] = vFn

	vrhCacheRules := v.CacheRulesValidationRuleHandler
	rulesCacheRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCacheRules(rulesCacheRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheOptions.cache_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_rules"] = vFn

	return v
}()

func CacheOptionsValidator() db.Validator {
	return DefaultCacheOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheQueryParameterMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheQueryParameterMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheQueryParameterMatcherType) DeepCopy() *CacheQueryParameterMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheQueryParameterMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheQueryParameterMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheQueryParameterMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheQueryParameterMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCacheQueryParameterMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheQueryParameterMatcherType) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateCacheQueryParameterMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheQueryParameterMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheQueryParameterMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheQueryParameterMatcherTypeValidator = func() *ValidateCacheQueryParameterMatcherType {
	v := &ValidateCacheQueryParameterMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheQueryParameterMatcherType.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	return v
}()

func CacheQueryParameterMatcherTypeValidator() db.Validator {
	return DefaultCacheQueryParameterMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheTTLEnableProps) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheTTLEnableProps) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheTTLEnableProps) DeepCopy() *CacheTTLEnableProps {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheTTLEnableProps{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheTTLEnableProps) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheTTLEnableProps) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheTTLEnablePropsValidator().Validate(ctx, m, opts...)
}

type ValidateCacheTTLEnableProps struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheTTLEnableProps) CacheTtlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl")
	}

	return validatorFn, nil
}

func (v *ValidateCacheTTLEnableProps) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheTTLEnableProps)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheTTLEnableProps got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_override"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_override"))
		if err := fv(ctx, m.GetCacheOverride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cache_ttl"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_ttl"))
		if err := fv(ctx, m.GetCacheTtl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ignore_response_cookie"]; exists {

		vOpts := append(opts, db.WithValidateField("ignore_response_cookie"))
		if err := fv(ctx, m.GetIgnoreResponseCookie(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheTTLEnablePropsValidator = func() *ValidateCacheTTLEnableProps {
	v := &ValidateCacheTTLEnableProps{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheTtl := v.CacheTtlValidationRuleHandler
	rulesCacheTtl := map[string]string{
		"ves.io.schema.rules.message.required":     "true",
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFn, err = vrhCacheTtl(rulesCacheTtl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheTTLEnableProps.cache_ttl: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_ttl"] = vFn

	return v
}()

func CacheTTLEnablePropsValidator() db.Validator {
	return DefaultCacheTTLEnablePropsValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheTTLOptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheTTLOptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheTTLOptionsType) DeepCopy() *CacheTTLOptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheTTLOptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheTTLOptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheTTLOptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheTTLOptionsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCacheTTLOptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheTTLOptionsType) TtlOptionsCacheTtlDefaultValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CacheTtlDefault, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl_default")
	}
	return oValidatorFn_CacheTtlDefault, nil
}
func (v *ValidateCacheTTLOptionsType) TtlOptionsCacheTtlOverrideValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CacheTtlOverride, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl_override")
	}
	return oValidatorFn_CacheTtlOverride, nil
}

func (v *ValidateCacheTTLOptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheTTLOptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheTTLOptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetTtlOptions().(type) {
	case *CacheTTLOptionsType_CacheTtlDefault:
		if fv, exists := v.FldValidators["ttl_options.cache_ttl_default"]; exists {
			val := m.GetTtlOptions().(*CacheTTLOptionsType_CacheTtlDefault).CacheTtlDefault
			vOpts := append(opts,
				db.WithValidateField("ttl_options"),
				db.WithValidateField("cache_ttl_default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheTTLOptionsType_CacheTtlOverride:
		if fv, exists := v.FldValidators["ttl_options.cache_ttl_override"]; exists {
			val := m.GetTtlOptions().(*CacheTTLOptionsType_CacheTtlOverride).CacheTtlOverride
			vOpts := append(opts,
				db.WithValidateField("ttl_options"),
				db.WithValidateField("cache_ttl_override"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheTTLOptionsType_CacheDisabled:
		if fv, exists := v.FldValidators["ttl_options.cache_disabled"]; exists {
			val := m.GetTtlOptions().(*CacheTTLOptionsType_CacheDisabled).CacheDisabled
			vOpts := append(opts,
				db.WithValidateField("ttl_options"),
				db.WithValidateField("cache_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheTTLOptionsTypeValidator = func() *ValidateCacheTTLOptionsType {
	v := &ValidateCacheTTLOptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTtlOptionsCacheTtlDefault := v.TtlOptionsCacheTtlDefaultValidationRuleHandler
	rulesTtlOptionsCacheTtlDefault := map[string]string{
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFnMap["ttl_options.cache_ttl_default"], err = vrhTtlOptionsCacheTtlDefault(rulesTtlOptionsCacheTtlDefault)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CacheTTLOptionsType.ttl_options_cache_ttl_default: %s", err)
		panic(errMsg)
	}
	vrhTtlOptionsCacheTtlOverride := v.TtlOptionsCacheTtlOverrideValidationRuleHandler
	rulesTtlOptionsCacheTtlOverride := map[string]string{
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFnMap["ttl_options.cache_ttl_override"], err = vrhTtlOptionsCacheTtlOverride(rulesTtlOptionsCacheTtlOverride)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CacheTTLOptionsType.ttl_options_cache_ttl_override: %s", err)
		panic(errMsg)
	}

	v.FldValidators["ttl_options.cache_ttl_default"] = vFnMap["ttl_options.cache_ttl_default"]
	v.FldValidators["ttl_options.cache_ttl_override"] = vFnMap["ttl_options.cache_ttl_override"]

	return v
}()

func CacheTTLOptionsTypeValidator() db.Validator {
	return DefaultCacheTTLOptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CdnOriginPoolType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CdnOriginPoolType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CdnOriginPoolType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetUseTls().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CdnOriginPoolType.use_tls")
	}

	return nil
}

func (m *CdnOriginPoolType) DeepCopy() *CdnOriginPoolType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CdnOriginPoolType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CdnOriginPoolType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CdnOriginPoolType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CdnOriginPoolTypeValidator().Validate(ctx, m, opts...)
}

func (m *CdnOriginPoolType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetTlsChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CdnOriginPoolType) GetTlsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsChoice().(type) {
	case *CdnOriginPoolType_NoTls:

		return nil, nil

	case *CdnOriginPoolType_UseTls:
		drInfos, err := m.GetUseTls().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetUseTls().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "use_tls." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateCdnOriginPoolType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCdnOriginPoolType) TlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCdnOriginPoolType) PublicNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for public_name")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views_origin_pool.OriginServerPublicNameValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCdnOriginPoolType) OriginServersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for origin_servers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CDNOriginServerType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CDNOriginServerTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for origin_servers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CDNOriginServerType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CDNOriginServerType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated origin_servers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items origin_servers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCdnOriginPoolType) OriginRequestTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for origin_request_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCdnOriginPoolType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CdnOriginPoolType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CdnOriginPoolType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["follow_origin_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("follow_origin_redirect"))
		if err := fv(ctx, m.GetFollowOriginRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["more_origin_options"]; exists {

		vOpts := append(opts, db.WithValidateField("more_origin_options"))
		if err := fv(ctx, m.GetMoreOriginOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_request_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("origin_request_timeout"))
		if err := fv(ctx, m.GetOriginRequestTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_servers"]; exists {
		vOpts := append(opts, db.WithValidateField("origin_servers"))
		if err := fv(ctx, m.GetOriginServers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_name"]; exists {

		vOpts := append(opts, db.WithValidateField("public_name"))
		if err := fv(ctx, m.GetPublicName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_choice"]; exists {
		val := m.GetTlsChoice()
		vOpts := append(opts,
			db.WithValidateField("tls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTlsChoice().(type) {
	case *CdnOriginPoolType_NoTls:
		if fv, exists := v.FldValidators["tls_choice.no_tls"]; exists {
			val := m.GetTlsChoice().(*CdnOriginPoolType_NoTls).NoTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("no_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CdnOriginPoolType_UseTls:
		if fv, exists := v.FldValidators["tls_choice.use_tls"]; exists {
			val := m.GetTlsChoice().(*CdnOriginPoolType_UseTls).UseTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("use_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCdnOriginPoolTypeValidator = func() *ValidateCdnOriginPoolType {
	v := &ValidateCdnOriginPoolType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTlsChoice := v.TlsChoiceValidationRuleHandler
	rulesTlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTlsChoice(rulesTlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CdnOriginPoolType.tls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_choice"] = vFn

	vrhPublicName := v.PublicNameValidationRuleHandler
	rulesPublicName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPublicName(rulesPublicName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CdnOriginPoolType.public_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_name"] = vFn

	vrhOriginServers := v.OriginServersValidationRuleHandler
	rulesOriginServers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhOriginServers(rulesOriginServers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CdnOriginPoolType.origin_servers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_servers"] = vFn

	vrhOriginRequestTimeout := v.OriginRequestTimeoutValidationRuleHandler
	rulesOriginRequestTimeout := map[string]string{
		"ves.io.schema.rules.string.max_time_interval": "10m",
		"ves.io.schema.rules.string.min_time_interval": "10s",
		"ves.io.schema.rules.string.time_interval":     "true",
	}
	vFn, err = vrhOriginRequestTimeout(rulesOriginRequestTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CdnOriginPoolType.origin_request_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_request_timeout"] = vFn

	v.FldValidators["tls_choice.use_tls"] = ves_io_schema_views_origin_pool.UpstreamTlsParametersValidator().Validate

	return v
}()

func CdnOriginPoolTypeValidator() db.Validator {
	return DefaultCdnOriginPoolTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetMoreOption().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.more_option")
	}

	if err := m.GetOriginPool().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.origin_pool")
	}

	if err := m.GetHttps().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.https")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOriginPoolDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetOriginPoolDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOriginPool() == nil {
		return nil, nil
	}

	drInfos, err := m.GetOriginPool().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetOriginPool().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "origin_pool." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) LoadbalancerTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_type")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OriginPoolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for origin_pool")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := CdnOriginPoolTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_type"]; exists {
		val := m.GetLoadbalancerType()
		vOpts := append(opts,
			db.WithValidateField("loadbalancer_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLoadbalancerType().(type) {
	case *CreateSpecType_Http:
		if fv, exists := v.FldValidators["loadbalancer_type.http"]; exists {
			val := m.GetLoadbalancerType().(*CreateSpecType_Http).Http
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("http"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_HttpsAutoCert:
		if fv, exists := v.FldValidators["loadbalancer_type.https_auto_cert"]; exists {
			val := m.GetLoadbalancerType().(*CreateSpecType_HttpsAutoCert).HttpsAutoCert
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https_auto_cert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Https:
		if fv, exists := v.FldValidators["loadbalancer_type.https"]; exists {
			val := m.GetLoadbalancerType().(*CreateSpecType_Https).Https
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["more_option"]; exists {

		vOpts := append(opts, db.WithValidateField("more_option"))
		if err := fv(ctx, m.GetMoreOption(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_pool"]; exists {

		vOpts := append(opts, db.WithValidateField("origin_pool"))
		if err := fv(ctx, m.GetOriginPool(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLoadbalancerType := v.LoadbalancerTypeValidationRuleHandler
	rulesLoadbalancerType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLoadbalancerType(rulesLoadbalancerType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.loadbalancer_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_type"] = vFn

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.message.required":               "true",
		"ves.io.schema.rules.repeated.items.string.hostname": "true",
		"ves.io.schema.rules.repeated.items.string.max_len":  "256",
		"ves.io.schema.rules.repeated.items.string.min_len":  "1",
		"ves.io.schema.rules.repeated.items.string.pattern":  "[\\.]+[A-Za-z]+",
		"ves.io.schema.rules.repeated.max_items":             "32",
		"ves.io.schema.rules.repeated.min_items":             "1",
		"ves.io.schema.rules.repeated.unique":                "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhOriginPool := v.OriginPoolValidationRuleHandler
	rulesOriginPool := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOriginPool(rulesOriginPool)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.origin_pool: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_pool"] = vFn

	v.FldValidators["loadbalancer_type.http"] = ves_io_schema_views_http_loadbalancer.ProxyTypeHttpValidator().Validate
	v.FldValidators["loadbalancer_type.https_auto_cert"] = CDNHTTPSAutoCertsTypeValidator().Validate
	v.FldValidators["loadbalancer_type.https"] = CDNHTTPSCustomCertsTypeValidator().Validate

	v.FldValidators["more_option"] = AdvancedOptionsTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DefaultCacheAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DefaultCacheAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DefaultCacheAction) DeepCopy() *DefaultCacheAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DefaultCacheAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DefaultCacheAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DefaultCacheAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DefaultCacheActionValidator().Validate(ctx, m, opts...)
}

type ValidateDefaultCacheAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDefaultCacheAction) CacheActionsCacheTtlDefaultValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CacheTtlDefault, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl_default")
	}
	return oValidatorFn_CacheTtlDefault, nil
}
func (v *ValidateDefaultCacheAction) CacheActionsCacheTtlOverrideValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CacheTtlOverride, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl_override")
	}
	return oValidatorFn_CacheTtlOverride, nil
}

func (v *ValidateDefaultCacheAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DefaultCacheAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DefaultCacheAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetCacheActions().(type) {
	case *DefaultCacheAction_EligibleForCache:
		if fv, exists := v.FldValidators["cache_actions.eligible_for_cache"]; exists {
			val := m.GetCacheActions().(*DefaultCacheAction_EligibleForCache).EligibleForCache
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("eligible_for_cache"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DefaultCacheAction_CacheTtlDefault:
		if fv, exists := v.FldValidators["cache_actions.cache_ttl_default"]; exists {
			val := m.GetCacheActions().(*DefaultCacheAction_CacheTtlDefault).CacheTtlDefault
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("cache_ttl_default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DefaultCacheAction_CacheTtlOverride:
		if fv, exists := v.FldValidators["cache_actions.cache_ttl_override"]; exists {
			val := m.GetCacheActions().(*DefaultCacheAction_CacheTtlOverride).CacheTtlOverride
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("cache_ttl_override"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DefaultCacheAction_CacheDisabled:
		if fv, exists := v.FldValidators["cache_actions.cache_disabled"]; exists {
			val := m.GetCacheActions().(*DefaultCacheAction_CacheDisabled).CacheDisabled
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("cache_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDefaultCacheActionValidator = func() *ValidateDefaultCacheAction {
	v := &ValidateDefaultCacheAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheActionsCacheTtlDefault := v.CacheActionsCacheTtlDefaultValidationRuleHandler
	rulesCacheActionsCacheTtlDefault := map[string]string{
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFnMap["cache_actions.cache_ttl_default"], err = vrhCacheActionsCacheTtlDefault(rulesCacheActionsCacheTtlDefault)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DefaultCacheAction.cache_actions_cache_ttl_default: %s", err)
		panic(errMsg)
	}
	vrhCacheActionsCacheTtlOverride := v.CacheActionsCacheTtlOverrideValidationRuleHandler
	rulesCacheActionsCacheTtlOverride := map[string]string{
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFnMap["cache_actions.cache_ttl_override"], err = vrhCacheActionsCacheTtlOverride(rulesCacheActionsCacheTtlOverride)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DefaultCacheAction.cache_actions_cache_ttl_override: %s", err)
		panic(errMsg)
	}

	v.FldValidators["cache_actions.cache_ttl_default"] = vFnMap["cache_actions.cache_ttl_default"]
	v.FldValidators["cache_actions.cache_ttl_override"] = vFnMap["cache_actions.cache_ttl_override"]

	v.FldValidators["cache_actions.eligible_for_cache"] = DefaultCacheTTLPropsValidator().Validate

	return v
}()

func DefaultCacheActionValidator() db.Validator {
	return DefaultDefaultCacheActionValidator
}

// augmented methods on protoc/std generated struct

func (m *DefaultCacheTTLProps) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DefaultCacheTTLProps) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DefaultCacheTTLProps) DeepCopy() *DefaultCacheTTLProps {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DefaultCacheTTLProps{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DefaultCacheTTLProps) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DefaultCacheTTLProps) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DefaultCacheTTLPropsValidator().Validate(ctx, m, opts...)
}

type ValidateDefaultCacheTTLProps struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDefaultCacheTTLProps) CacheTtlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl")
	}

	return validatorFn, nil
}

func (v *ValidateDefaultCacheTTLProps) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DefaultCacheTTLProps)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DefaultCacheTTLProps got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_ttl"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_ttl"))
		if err := fv(ctx, m.GetCacheTtl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDefaultCacheTTLPropsValidator = func() *ValidateDefaultCacheTTLProps {
	v := &ValidateDefaultCacheTTLProps{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheTtl := v.CacheTtlValidationRuleHandler
	rulesCacheTtl := map[string]string{
		"ves.io.schema.rules.message.required":     "true",
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFn, err = vrhCacheTtl(rulesCacheTtl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DefaultCacheTTLProps.cache_ttl: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_ttl"] = vFn

	return v
}()

func DefaultCacheTTLPropsValidator() db.Validator {
	return DefaultDefaultCacheTTLPropsValidator
}

// augmented methods on protoc/std generated struct

func (m *GeoFilteringOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GeoFilteringOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GeoFilteringOptions) DeepCopy() *GeoFilteringOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GeoFilteringOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GeoFilteringOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GeoFilteringOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GeoFilteringOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateGeoFilteringOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGeoFilteringOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GeoFilteringOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GeoFilteringOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetGeoFilteringType().(type) {
	case *GeoFilteringOptions_AllowList:
		if fv, exists := v.FldValidators["geo_filtering_type.allow_list"]; exists {
			val := m.GetGeoFilteringType().(*GeoFilteringOptions_AllowList).AllowList
			vOpts := append(opts,
				db.WithValidateField("geo_filtering_type"),
				db.WithValidateField("allow_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GeoFilteringOptions_BlockList:
		if fv, exists := v.FldValidators["geo_filtering_type.block_list"]; exists {
			val := m.GetGeoFilteringType().(*GeoFilteringOptions_BlockList).BlockList
			vOpts := append(opts,
				db.WithValidateField("geo_filtering_type"),
				db.WithValidateField("block_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGeoFilteringOptionsValidator = func() *ValidateGeoFilteringOptions {
	v := &ValidateGeoFilteringOptions{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["geo_filtering_type.allow_list"] = ves_io_schema_policy.CountryCodeListValidator().Validate
	v.FldValidators["geo_filtering_type.block_list"] = ves_io_schema_policy.CountryCodeListValidator().Validate

	return v
}()

func GeoFilteringOptionsValidator() db.Validator {
	return DefaultGeoFilteringOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetMoreOption().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.more_option")
	}

	if err := m.GetOriginPool().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.origin_pool")
	}

	if err := m.GetHttps().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.https")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOriginPoolDRefInfo()

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetOriginPoolDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOriginPool() == nil {
		return nil, nil
	}

	drInfos, err := m.GetOriginPool().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetOriginPool().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "origin_pool." + dri.DRField
	}
	return drInfos, err

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) LoadbalancerTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_type")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OriginPoolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for origin_pool")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := CdnOriginPoolTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_info"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_info"))
		if err := fv(ctx, m.GetAutoCertInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_info"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_info"))
		for idx, item := range m.GetDnsInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_type"]; exists {
		val := m.GetLoadbalancerType()
		vOpts := append(opts,
			db.WithValidateField("loadbalancer_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLoadbalancerType().(type) {
	case *GetSpecType_Http:
		if fv, exists := v.FldValidators["loadbalancer_type.http"]; exists {
			val := m.GetLoadbalancerType().(*GetSpecType_Http).Http
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("http"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_HttpsAutoCert:
		if fv, exists := v.FldValidators["loadbalancer_type.https_auto_cert"]; exists {
			val := m.GetLoadbalancerType().(*GetSpecType_HttpsAutoCert).HttpsAutoCert
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https_auto_cert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Https:
		if fv, exists := v.FldValidators["loadbalancer_type.https"]; exists {
			val := m.GetLoadbalancerType().(*GetSpecType_Https).Https
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["more_option"]; exists {

		vOpts := append(opts, db.WithValidateField("more_option"))
		if err := fv(ctx, m.GetMoreOption(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_pool"]; exists {

		vOpts := append(opts, db.WithValidateField("origin_pool"))
		if err := fv(ctx, m.GetOriginPool(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_domains"]; exists {

		vOpts := append(opts, db.WithValidateField("service_domains"))
		for idx, item := range m.GetServiceDomains() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLoadbalancerType := v.LoadbalancerTypeValidationRuleHandler
	rulesLoadbalancerType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLoadbalancerType(rulesLoadbalancerType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.loadbalancer_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_type"] = vFn

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.message.required":               "true",
		"ves.io.schema.rules.repeated.items.string.hostname": "true",
		"ves.io.schema.rules.repeated.items.string.max_len":  "256",
		"ves.io.schema.rules.repeated.items.string.min_len":  "1",
		"ves.io.schema.rules.repeated.items.string.pattern":  "[\\.]+[A-Za-z]+",
		"ves.io.schema.rules.repeated.max_items":             "32",
		"ves.io.schema.rules.repeated.min_items":             "1",
		"ves.io.schema.rules.repeated.unique":                "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhOriginPool := v.OriginPoolValidationRuleHandler
	rulesOriginPool := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOriginPool(rulesOriginPool)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.origin_pool: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_pool"] = vFn

	v.FldValidators["loadbalancer_type.http"] = ves_io_schema_views_http_loadbalancer.ProxyTypeHttpValidator().Validate
	v.FldValidators["loadbalancer_type.https_auto_cert"] = CDNHTTPSAutoCertsTypeValidator().Validate
	v.FldValidators["loadbalancer_type.https"] = CDNHTTPSCustomCertsTypeValidator().Validate

	v.FldValidators["more_option"] = AdvancedOptionsTypeValidator().Validate

	v.FldValidators["dns_info"] = ves_io_schema_virtual_host_dns_info.DnsInfoValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetMoreOption().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.more_option")
	}

	if err := m.GetOriginPool().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.origin_pool")
	}

	if err := m.GetHttps().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.https")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetOriginPoolDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetOriginPoolDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetViewInternalDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetViewInternalDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetOriginPoolDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOriginPool() == nil {
		return nil, nil
	}

	drInfos, err := m.GetOriginPool().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetOriginPool().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "origin_pool." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetViewInternalDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("view_internal.Object")
	dri := db.DRefInfo{
		RefdType:   "view_internal.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "view_internal",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetViewInternalDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetViewInternalDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "view_internal.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: view_internal")
	}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "view_internal.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) LoadbalancerTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_type")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OriginPoolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for origin_pool")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := CdnOriginPoolTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_info"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_info"))
		if err := fv(ctx, m.GetAutoCertInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auto_cert_state"]; exists {

		vOpts := append(opts, db.WithValidateField("auto_cert_state"))
		if err := fv(ctx, m.GetAutoCertState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_info"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_info"))
		for idx, item := range m.GetDnsInfo() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_name"]; exists {

		vOpts := append(opts, db.WithValidateField("host_name"))
		if err := fv(ctx, m.GetHostName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_type"]; exists {
		val := m.GetLoadbalancerType()
		vOpts := append(opts,
			db.WithValidateField("loadbalancer_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLoadbalancerType().(type) {
	case *GlobalSpecType_Http:
		if fv, exists := v.FldValidators["loadbalancer_type.http"]; exists {
			val := m.GetLoadbalancerType().(*GlobalSpecType_Http).Http
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("http"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_HttpsAutoCert:
		if fv, exists := v.FldValidators["loadbalancer_type.https_auto_cert"]; exists {
			val := m.GetLoadbalancerType().(*GlobalSpecType_HttpsAutoCert).HttpsAutoCert
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https_auto_cert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Https:
		if fv, exists := v.FldValidators["loadbalancer_type.https"]; exists {
			val := m.GetLoadbalancerType().(*GlobalSpecType_Https).Https
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["more_option"]; exists {

		vOpts := append(opts, db.WithValidateField("more_option"))
		if err := fv(ctx, m.GetMoreOption(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_pool"]; exists {

		vOpts := append(opts, db.WithValidateField("origin_pool"))
		if err := fv(ctx, m.GetOriginPool(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_domains"]; exists {

		vOpts := append(opts, db.WithValidateField("service_domains"))
		for idx, item := range m.GetServiceDomains() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["view_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("view_internal"))
		if err := fv(ctx, m.GetViewInternal(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLoadbalancerType := v.LoadbalancerTypeValidationRuleHandler
	rulesLoadbalancerType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLoadbalancerType(rulesLoadbalancerType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.loadbalancer_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_type"] = vFn

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.message.required":               "true",
		"ves.io.schema.rules.repeated.items.string.hostname": "true",
		"ves.io.schema.rules.repeated.items.string.max_len":  "256",
		"ves.io.schema.rules.repeated.items.string.min_len":  "1",
		"ves.io.schema.rules.repeated.items.string.pattern":  "[\\.]+[A-Za-z]+",
		"ves.io.schema.rules.repeated.max_items":             "32",
		"ves.io.schema.rules.repeated.min_items":             "1",
		"ves.io.schema.rules.repeated.unique":                "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhOriginPool := v.OriginPoolValidationRuleHandler
	rulesOriginPool := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOriginPool(rulesOriginPool)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.origin_pool: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_pool"] = vFn

	v.FldValidators["loadbalancer_type.http"] = ves_io_schema_views_http_loadbalancer.ProxyTypeHttpValidator().Validate
	v.FldValidators["loadbalancer_type.https_auto_cert"] = CDNHTTPSAutoCertsTypeValidator().Validate
	v.FldValidators["loadbalancer_type.https"] = CDNHTTPSCustomCertsTypeValidator().Validate

	v.FldValidators["more_option"] = AdvancedOptionsTypeValidator().Validate

	v.FldValidators["view_internal"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["dns_info"] = ves_io_schema_virtual_host_dns_info.DnsInfoValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HeaderControlType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HeaderControlType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *HeaderControlType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetRequestHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting HeaderControlType.request_headers_to_add idx %v", idx)
		}
	}

	for idx, e := range m.GetResponseHeadersToAdd() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting HeaderControlType.response_headers_to_add idx %v", idx)
		}
	}

	return nil
}

func (m *HeaderControlType) DeepCopy() *HeaderControlType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HeaderControlType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HeaderControlType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HeaderControlType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HeaderControlTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHeaderControlType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHeaderControlType) RequestHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for request_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHeaderControlType) RequestHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for request_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHeaderControlType) ResponseHeadersToAddValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for response_headers_to_add")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderManipulationOptionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderManipulationOptionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_add")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderManipulationOptionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderManipulationOptionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_add")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_add")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHeaderControlType) ResponseHeadersToRemoveValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_headers_to_remove")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_headers_to_remove")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_headers_to_remove")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_headers_to_remove")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHeaderControlType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HeaderControlType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HeaderControlType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["request_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_add"))
		if err := fv(ctx, m.GetRequestHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("request_headers_to_remove"))
		if err := fv(ctx, m.GetRequestHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_add"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_add"))
		if err := fv(ctx, m.GetResponseHeadersToAdd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_headers_to_remove"]; exists {
		vOpts := append(opts, db.WithValidateField("response_headers_to_remove"))
		if err := fv(ctx, m.GetResponseHeadersToRemove(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHeaderControlTypeValidator = func() *ValidateHeaderControlType {
	v := &ValidateHeaderControlType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRequestHeadersToAdd := v.RequestHeadersToAddValidationRuleHandler
	rulesRequestHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRequestHeadersToAdd(rulesRequestHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderControlType.request_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_add"] = vFn

	vrhRequestHeadersToRemove := v.RequestHeadersToRemoveValidationRuleHandler
	rulesRequestHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "256",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.items.string.pattern":   "^[0-9A-Za-z_\\-\\.]+$",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhRequestHeadersToRemove(rulesRequestHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderControlType.request_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_headers_to_remove"] = vFn

	vrhResponseHeadersToAdd := v.ResponseHeadersToAddValidationRuleHandler
	rulesResponseHeadersToAdd := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhResponseHeadersToAdd(rulesResponseHeadersToAdd)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderControlType.response_headers_to_add: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_add"] = vFn

	vrhResponseHeadersToRemove := v.ResponseHeadersToRemoveValidationRuleHandler
	rulesResponseHeadersToRemove := map[string]string{
		"ves.io.schema.rules.repeated.items.string.pattern": "^[0-9A-Za-z_\\-\\.]+$",
		"ves.io.schema.rules.repeated.max_items":            "32",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhResponseHeadersToRemove(rulesResponseHeadersToRemove)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HeaderControlType.response_headers_to_remove: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_headers_to_remove"] = vFn

	return v
}()

func HeaderControlTypeValidator() db.Validator {
	return DefaultHeaderControlTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IpFilteringOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IpFilteringOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IpFilteringOptions) DeepCopy() *IpFilteringOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IpFilteringOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IpFilteringOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IpFilteringOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IpFilteringOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateIpFilteringOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIpFilteringOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IpFilteringOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IpFilteringOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetIpFilteringType().(type) {
	case *IpFilteringOptions_AllowList:
		if fv, exists := v.FldValidators["ip_filtering_type.allow_list"]; exists {
			val := m.GetIpFilteringType().(*IpFilteringOptions_AllowList).AllowList
			vOpts := append(opts,
				db.WithValidateField("ip_filtering_type"),
				db.WithValidateField("allow_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IpFilteringOptions_BlockList:
		if fv, exists := v.FldValidators["ip_filtering_type.block_list"]; exists {
			val := m.GetIpFilteringType().(*IpFilteringOptions_BlockList).BlockList
			vOpts := append(opts,
				db.WithValidateField("ip_filtering_type"),
				db.WithValidateField("block_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIpFilteringOptionsValidator = func() *ValidateIpFilteringOptions {
	v := &ValidateIpFilteringOptions{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["ip_filtering_type.allow_list"] = ves_io_schema_policy.PrefixMatchListValidator().Validate
	v.FldValidators["ip_filtering_type.block_list"] = ves_io_schema_policy.PrefixMatchListValidator().Validate

	return v
}()

func IpFilteringOptionsValidator() db.Validator {
	return DefaultIpFilteringOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNMetricsFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNMetricsFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNMetricsFilter) DeepCopy() *LilacCDNMetricsFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNMetricsFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNMetricsFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNMetricsFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNMetricsFilterValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNMetricsFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNMetricsFilter) TagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(LilacCDNMetricsTag)
		return int32(i)
	}
	// LilacCDNMetricsTag_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, LilacCDNMetricsTag_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tag")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsFilter) ValuesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for values")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for values")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated values")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items values")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsFilter) OperatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(LilacCDNMetricsOperatorType)
		return int32(i)
	}
	// LilacCDNMetricsOperatorType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, LilacCDNMetricsOperatorType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operator")
	}

	return validatorFn, nil
}

func (v *ValidateLilacCDNMetricsFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNMetricsFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNMetricsFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tag"]; exists {

		vOpts := append(opts, db.WithValidateField("tag"))
		if err := fv(ctx, m.GetTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["values"]; exists {
		vOpts := append(opts, db.WithValidateField("values"))
		if err := fv(ctx, m.GetValues(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNMetricsFilterValidator = func() *ValidateLilacCDNMetricsFilter {
	v := &ValidateLilacCDNMetricsFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTag := v.TagValidationRuleHandler
	rulesTag := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTag(rulesTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsFilter.tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tag"] = vFn

	vrhValues := v.ValuesValidationRuleHandler
	rulesValues := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhValues(rulesValues)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsFilter.values: %s", err)
		panic(errMsg)
	}
	v.FldValidators["values"] = vFn

	vrhOperator := v.OperatorValidationRuleHandler
	rulesOperator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOperator(rulesOperator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LilacCDNMetricsFilter.operator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operator"] = vFn

	return v
}()

func LilacCDNMetricsFilterValidator() db.Validator {
	return DefaultLilacCDNMetricsFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNMetricsResponseData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNMetricsResponseData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNMetricsResponseData) DeepCopy() *LilacCDNMetricsResponseData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNMetricsResponseData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNMetricsResponseData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNMetricsResponseData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNMetricsResponseDataValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNMetricsResponseData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNMetricsResponseData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNMetricsResponseData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNMetricsResponseData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["series"]; exists {

		vOpts := append(opts, db.WithValidateField("series"))
		for idx, item := range m.GetSeries() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unit"]; exists {

		vOpts := append(opts, db.WithValidateField("unit"))
		if err := fv(ctx, m.GetUnit(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNMetricsResponseDataValidator = func() *ValidateLilacCDNMetricsResponseData {
	v := &ValidateLilacCDNMetricsResponseData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LilacCDNMetricsResponseDataValidator() db.Validator {
	return DefaultLilacCDNMetricsResponseDataValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNMetricsResponseGroupBy) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNMetricsResponseGroupBy) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNMetricsResponseGroupBy) DeepCopy() *LilacCDNMetricsResponseGroupBy {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNMetricsResponseGroupBy{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNMetricsResponseGroupBy) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNMetricsResponseGroupBy) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNMetricsResponseGroupByValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNMetricsResponseGroupBy struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNMetricsResponseGroupBy) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNMetricsResponseGroupBy)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNMetricsResponseGroupBy got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNMetricsResponseGroupByValidator = func() *ValidateLilacCDNMetricsResponseGroupBy {
	v := &ValidateLilacCDNMetricsResponseGroupBy{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LilacCDNMetricsResponseGroupByValidator() db.Validator {
	return DefaultLilacCDNMetricsResponseGroupByValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNMetricsResponseSeries) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNMetricsResponseSeries) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNMetricsResponseSeries) DeepCopy() *LilacCDNMetricsResponseSeries {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNMetricsResponseSeries{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNMetricsResponseSeries) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNMetricsResponseSeries) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNMetricsResponseSeriesValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNMetricsResponseSeries struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNMetricsResponseSeries) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNMetricsResponseSeries)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNMetricsResponseSeries got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["group_by"]; exists {

		vOpts := append(opts, db.WithValidateField("group_by"))
		for idx, item := range m.GetGroupBy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		for idx, item := range m.GetValue() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNMetricsResponseSeriesValidator = func() *ValidateLilacCDNMetricsResponseSeries {
	v := &ValidateLilacCDNMetricsResponseSeries{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LilacCDNMetricsResponseSeriesValidator() db.Validator {
	return DefaultLilacCDNMetricsResponseSeriesValidator
}

// augmented methods on protoc/std generated struct

func (m *LilacCDNMetricsResponseValue) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LilacCDNMetricsResponseValue) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LilacCDNMetricsResponseValue) DeepCopy() *LilacCDNMetricsResponseValue {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LilacCDNMetricsResponseValue{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LilacCDNMetricsResponseValue) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LilacCDNMetricsResponseValue) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LilacCDNMetricsResponseValueValidator().Validate(ctx, m, opts...)
}

type ValidateLilacCDNMetricsResponseValue struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLilacCDNMetricsResponseValue) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LilacCDNMetricsResponseValue)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LilacCDNMetricsResponseValue got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("timestamp"))
		if err := fv(ctx, m.GetTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLilacCDNMetricsResponseValueValidator = func() *ValidateLilacCDNMetricsResponseValue {
	v := &ValidateLilacCDNMetricsResponseValue{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LilacCDNMetricsResponseValueValidator() db.Validator {
	return DefaultLilacCDNMetricsResponseValueValidator
}

// augmented methods on protoc/std generated struct

func (m *LogHeaderOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LogHeaderOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LogHeaderOptions) DeepCopy() *LogHeaderOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LogHeaderOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LogHeaderOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LogHeaderOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LogHeaderOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateLogHeaderOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLogHeaderOptions) HeaderListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for header_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for header_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated header_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items header_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLogHeaderOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LogHeaderOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LogHeaderOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header_list"]; exists {
		vOpts := append(opts, db.WithValidateField("header_list"))
		if err := fv(ctx, m.GetHeaderList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLogHeaderOptionsValidator = func() *ValidateLogHeaderOptions {
	v := &ValidateLogHeaderOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaderList := v.HeaderListValidationRuleHandler
	rulesHeaderList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhHeaderList(rulesHeaderList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LogHeaderOptions.header_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header_list"] = vFn

	return v
}()

func LogHeaderOptionsValidator() db.Validator {
	return DefaultLogHeaderOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *LoggingOptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoggingOptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoggingOptionsType) DeepCopy() *LoggingOptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoggingOptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoggingOptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoggingOptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoggingOptionsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLoggingOptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoggingOptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoggingOptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoggingOptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_log_options"]; exists {

		vOpts := append(opts, db.WithValidateField("client_log_options"))
		if err := fv(ctx, m.GetClientLogOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_log_options"]; exists {

		vOpts := append(opts, db.WithValidateField("origin_log_options"))
		if err := fv(ctx, m.GetOriginLogOptions(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoggingOptionsTypeValidator = func() *ValidateLoggingOptionsType {
	v := &ValidateLoggingOptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["client_log_options"] = LogHeaderOptionsValidator().Validate

	v.FldValidators["origin_log_options"] = LogHeaderOptionsValidator().Validate

	return v
}()

func LoggingOptionsTypeValidator() db.Validator {
	return DefaultLoggingOptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginAdvancedConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginAdvancedConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginAdvancedConfiguration) DeepCopy() *OriginAdvancedConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginAdvancedConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginAdvancedConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginAdvancedConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginAdvancedConfigurationValidator().Validate(ctx, m, opts...)
}

type ValidateOriginAdvancedConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginAdvancedConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginAdvancedConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginAdvancedConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["disable_byte_range_request"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_byte_range_request"))
		if err := fv(ctx, m.GetDisableByteRangeRequest(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["websocket_proxy"]; exists {

		vOpts := append(opts, db.WithValidateField("websocket_proxy"))
		if err := fv(ctx, m.GetWebsocketProxy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginAdvancedConfigurationValidator = func() *ValidateOriginAdvancedConfiguration {
	v := &ValidateOriginAdvancedConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OriginAdvancedConfigurationValidator() db.Validator {
	return DefaultOriginAdvancedConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *ProxyTypeHttpsAutoCerts) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProxyTypeHttpsAutoCerts) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProxyTypeHttpsAutoCerts) DeepCopy() *ProxyTypeHttpsAutoCerts {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProxyTypeHttpsAutoCerts{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProxyTypeHttpsAutoCerts) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProxyTypeHttpsAutoCerts) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProxyTypeHttpsAutoCertsValidator().Validate(ctx, m, opts...)
}

type ValidateProxyTypeHttpsAutoCerts struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProxyTypeHttpsAutoCerts) ServerHeaderChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_header_choice")
	}
	return validatorFn, nil
}

func (v *ValidateProxyTypeHttpsAutoCerts) ServerHeaderChoiceServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_name")
	}
	return oValidatorFn_ServerName, nil
}
func (v *ValidateProxyTypeHttpsAutoCerts) ServerHeaderChoiceAppendServerNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AppendServerName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for append_server_name")
	}
	return oValidatorFn_AppendServerName, nil
}

func (v *ValidateProxyTypeHttpsAutoCerts) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProxyTypeHttpsAutoCerts)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProxyTypeHttpsAutoCerts got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_hsts"]; exists {

		vOpts := append(opts, db.WithValidateField("add_hsts"))
		if err := fv(ctx, m.GetAddHsts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_redirect"]; exists {

		vOpts := append(opts, db.WithValidateField("http_redirect"))
		if err := fv(ctx, m.GetHttpRedirect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["server_header_choice"]; exists {
		val := m.GetServerHeaderChoice()
		vOpts := append(opts,
			db.WithValidateField("server_header_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServerHeaderChoice().(type) {
	case *ProxyTypeHttpsAutoCerts_DefaultHeader:
		if fv, exists := v.FldValidators["server_header_choice.default_header"]; exists {
			val := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_DefaultHeader).DefaultHeader
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("default_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProxyTypeHttpsAutoCerts_ServerName:
		if fv, exists := v.FldValidators["server_header_choice.server_name"]; exists {
			val := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_ServerName).ServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProxyTypeHttpsAutoCerts_AppendServerName:
		if fv, exists := v.FldValidators["server_header_choice.append_server_name"]; exists {
			val := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_AppendServerName).AppendServerName
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("append_server_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProxyTypeHttpsAutoCerts_PassThrough:
		if fv, exists := v.FldValidators["server_header_choice.pass_through"]; exists {
			val := m.GetServerHeaderChoice().(*ProxyTypeHttpsAutoCerts_PassThrough).PassThrough
			vOpts := append(opts,
				db.WithValidateField("server_header_choice"),
				db.WithValidateField("pass_through"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_config"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_config"))
		if err := fv(ctx, m.GetTlsConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProxyTypeHttpsAutoCertsValidator = func() *ValidateProxyTypeHttpsAutoCerts {
	v := &ValidateProxyTypeHttpsAutoCerts{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServerHeaderChoice := v.ServerHeaderChoiceValidationRuleHandler
	rulesServerHeaderChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServerHeaderChoice(rulesServerHeaderChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProxyTypeHttpsAutoCerts.server_header_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_header_choice"] = vFn

	vrhServerHeaderChoiceServerName := v.ServerHeaderChoiceServerNameValidationRuleHandler
	rulesServerHeaderChoiceServerName := map[string]string{
		"ves.io.schema.rules.string.hostname_or_ip": "true",
	}
	vFnMap["server_header_choice.server_name"], err = vrhServerHeaderChoiceServerName(rulesServerHeaderChoiceServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ProxyTypeHttpsAutoCerts.server_header_choice_server_name: %s", err)
		panic(errMsg)
	}
	vrhServerHeaderChoiceAppendServerName := v.ServerHeaderChoiceAppendServerNameValidationRuleHandler
	rulesServerHeaderChoiceAppendServerName := map[string]string{
		"ves.io.schema.rules.string.hostname_or_ip": "true",
	}
	vFnMap["server_header_choice.append_server_name"], err = vrhServerHeaderChoiceAppendServerName(rulesServerHeaderChoiceAppendServerName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ProxyTypeHttpsAutoCerts.server_header_choice_append_server_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["server_header_choice.server_name"] = vFnMap["server_header_choice.server_name"]
	v.FldValidators["server_header_choice.append_server_name"] = vFnMap["server_header_choice.append_server_name"]

	v.FldValidators["tls_config"] = ves_io_schema_views.TlsConfigValidator().Validate

	return v
}()

func ProxyTypeHttpsAutoCertsValidator() db.Validator {
	return DefaultProxyTypeHttpsAutoCertsValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetMoreOption().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.more_option")
	}

	if err := m.GetOriginPool().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.origin_pool")
	}

	if err := m.GetHttps().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.https")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOriginPoolDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetOriginPoolDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOriginPool() == nil {
		return nil, nil
	}

	drInfos, err := m.GetOriginPool().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetOriginPool().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "origin_pool." + dri.DRField
	}
	return drInfos, err

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) LoadbalancerTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_type")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OriginPoolValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for origin_pool")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := CdnOriginPoolTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["add_location"]; exists {

		vOpts := append(opts, db.WithValidateField("add_location"))
		if err := fv(ctx, m.GetAddLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_type"]; exists {
		val := m.GetLoadbalancerType()
		vOpts := append(opts,
			db.WithValidateField("loadbalancer_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLoadbalancerType().(type) {
	case *ReplaceSpecType_Http:
		if fv, exists := v.FldValidators["loadbalancer_type.http"]; exists {
			val := m.GetLoadbalancerType().(*ReplaceSpecType_Http).Http
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("http"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_HttpsAutoCert:
		if fv, exists := v.FldValidators["loadbalancer_type.https_auto_cert"]; exists {
			val := m.GetLoadbalancerType().(*ReplaceSpecType_HttpsAutoCert).HttpsAutoCert
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https_auto_cert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Https:
		if fv, exists := v.FldValidators["loadbalancer_type.https"]; exists {
			val := m.GetLoadbalancerType().(*ReplaceSpecType_Https).Https
			vOpts := append(opts,
				db.WithValidateField("loadbalancer_type"),
				db.WithValidateField("https"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["more_option"]; exists {

		vOpts := append(opts, db.WithValidateField("more_option"))
		if err := fv(ctx, m.GetMoreOption(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_pool"]; exists {

		vOpts := append(opts, db.WithValidateField("origin_pool"))
		if err := fv(ctx, m.GetOriginPool(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLoadbalancerType := v.LoadbalancerTypeValidationRuleHandler
	rulesLoadbalancerType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLoadbalancerType(rulesLoadbalancerType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.loadbalancer_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_type"] = vFn

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.message.required":               "true",
		"ves.io.schema.rules.repeated.items.string.hostname": "true",
		"ves.io.schema.rules.repeated.items.string.max_len":  "256",
		"ves.io.schema.rules.repeated.items.string.min_len":  "1",
		"ves.io.schema.rules.repeated.items.string.pattern":  "[\\.]+[A-Za-z]+",
		"ves.io.schema.rules.repeated.max_items":             "32",
		"ves.io.schema.rules.repeated.min_items":             "1",
		"ves.io.schema.rules.repeated.unique":                "true",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	vrhOriginPool := v.OriginPoolValidationRuleHandler
	rulesOriginPool := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOriginPool(rulesOriginPool)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.origin_pool: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_pool"] = vFn

	v.FldValidators["loadbalancer_type.http"] = ves_io_schema_views_http_loadbalancer.ProxyTypeHttpValidator().Validate
	v.FldValidators["loadbalancer_type.https_auto_cert"] = CDNHTTPSAutoCertsTypeValidator().Validate
	v.FldValidators["loadbalancer_type.https"] = CDNHTTPSCustomCertsTypeValidator().Validate

	v.FldValidators["more_option"] = AdvancedOptionsTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityOptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityOptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *SecurityOptionsType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAuthOptions().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting SecurityOptionsType.auth_options")
	}

	return nil
}

func (m *SecurityOptionsType) DeepCopy() *SecurityOptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityOptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityOptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityOptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityOptionsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityOptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityOptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityOptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityOptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auth_options"]; exists {

		vOpts := append(opts, db.WithValidateField("auth_options"))
		if err := fv(ctx, m.GetAuthOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["geo_filtering"]; exists {

		vOpts := append(opts, db.WithValidateField("geo_filtering"))
		if err := fv(ctx, m.GetGeoFiltering(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_filtering"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_filtering"))
		if err := fv(ctx, m.GetIpFiltering(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityOptionsTypeValidator = func() *ValidateSecurityOptionsType {
	v := &ValidateSecurityOptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["ip_filtering"] = IpFilteringOptionsValidator().Validate

	v.FldValidators["geo_filtering"] = GeoFilteringOptionsValidator().Validate

	v.FldValidators["auth_options"] = AuthenticationOptionsValidator().Validate

	return v
}()

func SecurityOptionsTypeValidator() db.Validator {
	return DefaultSecurityOptionsTypeValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetLoadbalancerTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LoadbalancerType.(type) {
	case nil:
		o.LoadbalancerType = nil

	case *CreateSpecType_Http:
		o.LoadbalancerType = &GlobalSpecType_Http{Http: of.Http}

	case *CreateSpecType_Https:
		o.LoadbalancerType = &GlobalSpecType_Https{Https: of.Https}

	case *CreateSpecType_HttpsAutoCert:
		o.LoadbalancerType = &GlobalSpecType_HttpsAutoCert{HttpsAutoCert: of.HttpsAutoCert}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetLoadbalancerTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LoadbalancerType.(type) {
	case nil:
		r.LoadbalancerType = nil

	case *GlobalSpecType_Http:
		r.LoadbalancerType = &CreateSpecType_Http{Http: of.Http}

	case *GlobalSpecType_Https:
		r.LoadbalancerType = &CreateSpecType_Https{Https: of.Https}

	case *GlobalSpecType_HttpsAutoCert:
		r.LoadbalancerType = &CreateSpecType_HttpsAutoCert{HttpsAutoCert: of.HttpsAutoCert}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.Domains = f.GetDomains()
	m.GetLoadbalancerTypeFromGlobalSpecType(f)
	m.MoreOption = f.GetMoreOption()
	m.OriginPool = f.GetOriginPool()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AddLocation = m1.AddLocation
	f.Domains = m1.Domains
	m1.SetLoadbalancerTypeToGlobalSpecType(f)
	f.MoreOption = m1.MoreOption
	f.OriginPool = m1.OriginPool
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetLoadbalancerTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LoadbalancerType.(type) {
	case nil:
		o.LoadbalancerType = nil

	case *GetSpecType_Http:
		o.LoadbalancerType = &GlobalSpecType_Http{Http: of.Http}

	case *GetSpecType_Https:
		o.LoadbalancerType = &GlobalSpecType_Https{Https: of.Https}

	case *GetSpecType_HttpsAutoCert:
		o.LoadbalancerType = &GlobalSpecType_HttpsAutoCert{HttpsAutoCert: of.HttpsAutoCert}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetLoadbalancerTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LoadbalancerType.(type) {
	case nil:
		r.LoadbalancerType = nil

	case *GlobalSpecType_Http:
		r.LoadbalancerType = &GetSpecType_Http{Http: of.Http}

	case *GlobalSpecType_Https:
		r.LoadbalancerType = &GetSpecType_Https{Https: of.Https}

	case *GlobalSpecType_HttpsAutoCert:
		r.LoadbalancerType = &GetSpecType_HttpsAutoCert{HttpsAutoCert: of.HttpsAutoCert}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.AutoCertInfo = f.GetAutoCertInfo()
	m.DnsInfo = f.GetDnsInfo()
	m.Domains = f.GetDomains()
	m.HostName = f.GetHostName()
	m.GetLoadbalancerTypeFromGlobalSpecType(f)
	m.MoreOption = f.GetMoreOption()
	m.OriginPool = f.GetOriginPool()
	m.ServiceDomains = f.GetServiceDomains()
	m.State = f.GetState()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AddLocation = m1.AddLocation
	f.AutoCertInfo = m1.AutoCertInfo
	f.DnsInfo = m1.DnsInfo
	f.Domains = m1.Domains
	f.HostName = m1.HostName
	m1.SetLoadbalancerTypeToGlobalSpecType(f)
	f.MoreOption = m1.MoreOption
	f.OriginPool = m1.OriginPool
	f.ServiceDomains = m1.ServiceDomains
	f.State = m1.State
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetLoadbalancerTypeToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LoadbalancerType.(type) {
	case nil:
		o.LoadbalancerType = nil

	case *ReplaceSpecType_Http:
		o.LoadbalancerType = &GlobalSpecType_Http{Http: of.Http}

	case *ReplaceSpecType_Https:
		o.LoadbalancerType = &GlobalSpecType_Https{Https: of.Https}

	case *ReplaceSpecType_HttpsAutoCert:
		o.LoadbalancerType = &GlobalSpecType_HttpsAutoCert{HttpsAutoCert: of.HttpsAutoCert}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetLoadbalancerTypeFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LoadbalancerType.(type) {
	case nil:
		r.LoadbalancerType = nil

	case *GlobalSpecType_Http:
		r.LoadbalancerType = &ReplaceSpecType_Http{Http: of.Http}

	case *GlobalSpecType_Https:
		r.LoadbalancerType = &ReplaceSpecType_Https{Https: of.Https}

	case *GlobalSpecType_HttpsAutoCert:
		r.LoadbalancerType = &ReplaceSpecType_HttpsAutoCert{HttpsAutoCert: of.HttpsAutoCert}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AddLocation = f.GetAddLocation()
	m.Domains = f.GetDomains()
	m.GetLoadbalancerTypeFromGlobalSpecType(f)
	m.MoreOption = f.GetMoreOption()
	m.OriginPool = f.GetOriginPool()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AddLocation = m1.AddLocation
	f.Domains = m1.Domains
	m1.SetLoadbalancerTypeToGlobalSpecType(f)
	f.MoreOption = m1.MoreOption
	f.OriginPool = m1.OriginPool
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
