//
// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//

package app_api_group

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAPI GRPC Client satisfying server.CustomClient
type CustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAPIGrpcClient) doRPCEvaluateApiGroup(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &EvaluateApiGroupReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.app_api_group.EvaluateApiGroupReq", yamlReq)
	}
	rsp, err := c.grpcClient.EvaluateApiGroup(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetApiGroupsStats(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetApiGroupsStatsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.app_api_group.GetApiGroupsStatsReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetApiGroupsStats(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["EvaluateApiGroup"] = ccl.doRPCEvaluateApiGroup

	rpcFns["GetApiGroupsStats"] = ccl.doRPCGetApiGroupsStats

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPI REST Client satisfying server.CustomClient
type CustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAPIRestClient) doRPCEvaluateApiGroup(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &EvaluateApiGroupReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.app_api_group.EvaluateApiGroupReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("api_group", fmt.Sprintf("%v", req.ApiGroup))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &EvaluateApiGroupRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.app_api_group.EvaluateApiGroupRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetApiGroupsStats(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetApiGroupsStatsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.app_api_group.GetApiGroupsStatsReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetApiGroupsStatsRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.app_api_group.GetApiGroupsStatsRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["EvaluateApiGroup"] = ccl.doRPCEvaluateApiGroup

	rpcFns["GetApiGroupsStats"] = ccl.doRPCGetApiGroupsStats

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customAPIInprocClient

// INPROC Client (satisfying CustomAPIClient interface)
type customAPIInprocClient struct {
	CustomAPIServer
}

func (c *customAPIInprocClient) EvaluateApiGroup(ctx context.Context, in *EvaluateApiGroupReq, opts ...grpc.CallOption) (*EvaluateApiGroupRsp, error) {
	return c.CustomAPIServer.EvaluateApiGroup(ctx, in)
}
func (c *customAPIInprocClient) GetApiGroupsStats(ctx context.Context, in *GetApiGroupsStatsReq, opts ...grpc.CallOption) (*GetApiGroupsStatsRsp, error) {
	return c.CustomAPIServer.GetApiGroupsStats(ctx, in)
}

func NewCustomAPIInprocClient(svc svcfw.Service) CustomAPIClient {
	return &customAPIInprocClient{CustomAPIServer: NewCustomAPIServer(svc)}
}

// RegisterGwCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAPIHandlerClient(ctx, mux, NewCustomAPIInprocClient(s))
}

// Create customAPISrv

// SERVER (satisfying CustomAPIServer interface)
type customAPISrv struct {
	svc svcfw.Service
}

func (s *customAPISrv) EvaluateApiGroup(ctx context.Context, in *EvaluateApiGroupReq) (*EvaluateApiGroupRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.app_api_group.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *EvaluateApiGroupRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.app_api_group.EvaluateApiGroupReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.EvaluateApiGroup' operation on 'app_api_group'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()
	if err := s.svc.CustomAPIProcessDRef(ctx, in); err != nil {
		return nil, err
	}

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.app_api_group.CustomAPI.EvaluateApiGroup"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.EvaluateApiGroup(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.app_api_group.EvaluateApiGroupRsp", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetApiGroupsStats(ctx context.Context, in *GetApiGroupsStatsReq) (*GetApiGroupsStatsRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.app_api_group.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *GetApiGroupsStatsRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.app_api_group.GetApiGroupsStatsReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetApiGroupsStats' operation on 'app_api_group'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.app_api_group.CustomAPI.GetApiGroupsStats"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetApiGroupsStats(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.app_api_group.GetApiGroupsStatsRsp", rsp)...)

	return rsp, nil
}

func NewCustomAPIServer(svc svcfw.Service) CustomAPIServer {
	return &customAPISrv{svc: svc}
}

var CustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "app_api_group object",
        "description": "The app_api_group construct provides a mechanism to classify the universal set of request APIs into a much smaller number of logical groups in order\nto make it easier to author and maintain API level access control policies. The app_api_group holds api_group child object with the same content for\ninternal use by data path and other services.\n\nAn app_api_group object consists of an unordered list of api group elements. The method and path from the input request API are matched against all\nelements in an app_api_group to determine if the request API belongs to the api group in question. The request API belongs to an api group if it\nmatches at least one element in the api group.\n\nThe App API Group may be created using API Group Builder which defines path filter and label selectors to match\nAPI Endpoints from a referenced object, like HTTP Loadbalancer. For example, if there is a HTTP LB with API Discovery enabled\nthen all discovered API Endpoints serve as a base set and filters define which API Endpoints would be the group members.\n\n The view creates the following child objects:\n * api_group",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{namespace}/app_api_groups/evaluate": {
            "post": {
                "summary": "Evaluate API Group",
                "description": "Evaluate API Group Builder against all API endpoints associated with the referenced object and return the resulting API Group.\nFor example, if the referenced object is an HTTP LB then all discovered and imported endpoints are associated with it.",
                "operationId": "ves.io.schema.views.app_api_group.CustomAPI.EvaluateApiGroup",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_api_groupEvaluateApiGroupRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the API Group for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_api_groupEvaluateApiGroupReq"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-app_api_group-customapi-evaluateapigroup"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.app_api_group.CustomAPI.EvaluateApiGroup"
            },
            "x-displayname": "Custom API Group Custom API",
            "x-ves-proto-service": "ves.io.schema.views.app_api_group.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_api_groups/stats": {
            "post": {
                "summary": "Evaluate API Group",
                "description": "Check if there are any changes happened to the API Groups, and return number of API Endpoints updated for each API Group.",
                "operationId": "ves.io.schema.views.app_api_group.CustomAPI.GetApiGroupsStats",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_api_groupGetApiGroupsStatsRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the API Group for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_api_groupGetApiGroupsStatsReq"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-app_api_group-customapi-getapigroupsstats"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.app_api_group.CustomAPI.GetApiGroupsStats"
            },
            "x-displayname": "Custom API Group Custom API",
            "x-ves-proto-service": "ves.io.schema.views.app_api_group.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "api_definitionApiGroupBuilder": {
            "type": "object",
            "description": "x-displayName: \"API Group Builder\"\nDefine a group of application operations using path matching and label filtering.",
            "title": "ApiGroupBuilder",
            "properties": {
                "excluded_operations": {
                    "type": "array",
                    "description": "x-displayName: \"Excluded Operations\"\nList of operations matched by the filters to be excluded from a group.\nThe list should only include operations matched by the filters.\nThe paths appear here with parameters as defined in OpenAPI spec file.",
                    "title": "excluded_operations",
                    "items": {
                        "$ref": "#/definitions/api_definitionApiOperation"
                    }
                },
                "included_operations": {
                    "type": "array",
                    "description": "x-displayName: \"Included Operations\"\nList of operations not matched by the filters to be included in a group.\nThe list should not include operations matched by the filters.\nThe paths appear here with parameters as defined in OpenAPI spec file.",
                    "title": "included_operations",
                    "items": {
                        "$ref": "#/definitions/api_definitionApiOperation"
                    }
                },
                "label_filter": {
                    "description": "x-displayName: \"Label Filter\"\nx-example: \"method in (POST, DELETE), tag in (web, db)\"\nA group builder should include only labels selected by expression.\nIn the current context a label is a property of an OpenAPI operation or path.",
                    "title": "label_filter",
                    "$ref": "#/definitions/schemaLabelSelectorType"
                },
                "metadata": {
                    "description": "x-displayName: \"Metadata\"\nCommon attributes for the rule including name and description.",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType"
                },
                "path_filter": {
                    "type": "string",
                    "description": "x-displayName: \"Path Filter\"\nx-example: \"/api/config/.*/path[123]/$\"\nRegular expression to match the input request API path against.\nThe match is considered to succeed if the input request API path matches the specified path regex.",
                    "title": "path_filter"
                }
            }
        },
        "api_definitionApiOperation": {
            "type": "object",
            "description": "x-displayName: \"API Operation\"\nAPI operation according to OpenAPI specification.",
            "title": "ApiOperation",
            "properties": {
                "method": {
                    "description": "x-displayName: \"HTTP Method\"\nx-required\nx-example: 'POST'\nMethod to match the input request API method against.",
                    "title": "method",
                    "$ref": "#/definitions/schemaHttpMethod"
                },
                "path": {
                    "type": "string",
                    "description": "x-displayName: \"Path\"\nx-required\nx-example: \"/api/users/{userid}\"\nAn endpoint path, as specified in OpenAPI, including parameters.\nThe path should comply with RFC 3986 and may have parameters according to OpenAPI specification",
                    "title": "path"
                }
            }
        },
        "app_api_groupApiEndpoint": {
            "type": "object",
            "description": "The API Endpoint according to OpenAPI specification.",
            "title": "Api Endpoint",
            "x-displayname": "API Endpoint",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.ApiEndpoint",
            "properties": {
                "method": {
                    "description": " Method to match the input request API method against.\n\nExample: - 'POST'-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "method",
                    "$ref": "#/definitions/schemaHttpMethod",
                    "x-displayname": "HTTP Method",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "type": "string",
                    "description": " An endpoint path, as specified in OpenAPI, including parameters.\n The path should comply with RFC 3986 and may have parameters according to OpenAPI specification\n\nExample: - \"/api/users/{userid}\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 1024\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "path",
                    "minLength": 1,
                    "maxLength": 1024,
                    "x-displayname": "Path",
                    "x-ves-example": "/api/users/{userid}",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "1024",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                }
            }
        },
        "app_api_groupApiGroupId": {
            "type": "object",
            "description": "The API Group ID for the API Groups stats response",
            "title": "API Group ID",
            "x-displayname": "API Group ID",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.ApiGroupId",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " Name of the API Group\n\nExample: - \"sensitive\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "sensitive"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the API Group\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                }
            }
        },
        "app_api_groupApiGroupScopeApiDefinition": {
            "type": "object",
            "description": "x-displayName: \"API Group Scope API Definition\"\nSet the scope of the API Group to a specific API Definition",
            "title": "ApiGroupScopeApiDefinition",
            "properties": {
                "api_definition": {
                    "description": "x-displayName: \"API Definition\"\nx-required\nReference to an API Definition object which defines a superset of API Endpoints for the API Group",
                    "title": "API Definition Reference",
                    "$ref": "#/definitions/schemaviewsObjectRefType"
                }
            }
        },
        "app_api_groupApiGroupScopeHttpLoadbalancer": {
            "type": "object",
            "description": "Set the scope of the API Group to a specific HTTP Loadbalancer",
            "title": "ApiGroupScopeHttpLoadbalancer",
            "x-displayname": "API Group Scope HTTP Loadbalancer",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.ApiGroupScopeHttpLoadbalancer",
            "properties": {
                "http_loadbalancer": {
                    "description": " Reference to an HTTP Loadbalancer object which defines a superset of API Endpoints for the API Group\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "HTTP Loadbalancer Reference",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "HTTP Loadbalancer",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "app_api_groupApiGroupStats": {
            "type": "object",
            "description": "The API Group Stats for the API Groups stats response",
            "title": "API Group Stats",
            "x-displayname": "API Group Stats",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.ApiGroupStats",
            "properties": {
                "outdated_api_endpoints_count": {
                    "type": "integer",
                    "description": " Number of outdated API Endpoints is the difference in the stored API Group contents and\n the contents if it be evaluated against current state\n\nExample: - \"5\"-",
                    "title": "outdated_api_endpoints_count",
                    "format": "int64",
                    "x-displayname": "Outdated API Endpoints Count",
                    "x-ves-example": "5"
                }
            }
        },
        "app_api_groupApiGroupsStatsItem": {
            "type": "object",
            "description": "API Groups Stats Item",
            "title": "API Groups Stats Item",
            "x-displayname": "API Groups Stats Item",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.ApiGroupsStatsItem",
            "properties": {
                "id": {
                    "description": " The API Group ID for unique identification of the API Group",
                    "title": "id",
                    "$ref": "#/definitions/app_api_groupApiGroupId",
                    "x-displayname": "API Group ID"
                },
                "stats": {
                    "description": " The API Group stats",
                    "title": "stats",
                    "$ref": "#/definitions/app_api_groupApiGroupStats",
                    "x-displayname": "API Group Stats"
                }
            }
        },
        "app_api_groupEvaluateApiGroupReq": {
            "type": "object",
            "description": "Request shape for Evaluate API Group",
            "title": "Evaluate API Group Request",
            "x-displayname": "Evaluate API Group Request",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.EvaluateApiGroupReq",
            "properties": {
                "api_group": {
                    "description": " API Group for the current request",
                    "title": "API Group",
                    "$ref": "#/definitions/viewsapp_api_groupGlobalSpecType",
                    "x-displayname": "API Group"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the API Group for the current request\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                }
            }
        },
        "app_api_groupEvaluateApiGroupRsp": {
            "type": "object",
            "description": "Response for the Evaluate API Group request",
            "title": "Evaluate API Group Response",
            "x-displayname": "Evaluate API Group Response",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.EvaluateApiGroupRsp",
            "properties": {
                "api_group": {
                    "description": " The API group as a result of evaluating API group builder against all API endpoints associated with the referenced object",
                    "title": "API Group",
                    "$ref": "#/definitions/viewsapp_api_groupGlobalSpecType",
                    "x-displayname": "API Group"
                },
                "apieps_timestamp": {
                    "type": "string",
                    "description": " The API endpoints timestamp indicates when the most recent update of API endpoints happened\n For example, if the referenced object is HTTP LB then the API Discovery periodically updates\n the API endpoints list based on application's traffic",
                    "title": "apieps_timestamp",
                    "format": "date-time",
                    "x-displayname": "API Endpoints Timestamp"
                },
                "matching_api_endpoints": {
                    "type": "array",
                    "description": " List of API Endpoints matched by the query expression.\n The paths appear here with parameters as defined in OpenAPI spec file.",
                    "title": "matching_api_endpoints",
                    "items": {
                        "$ref": "#/definitions/app_api_groupApiEndpoint"
                    },
                    "x-displayname": "Matching API Endpoints"
                }
            }
        },
        "app_api_groupGetApiGroupsStatsReq": {
            "type": "object",
            "description": "Request shape for API Groups Stats",
            "title": "API Groups Stats Request",
            "x-displayname": "API Groups Stats Request",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.GetApiGroupsStatsReq",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the API Group for the current request\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                }
            }
        },
        "app_api_groupGetApiGroupsStatsRsp": {
            "type": "object",
            "description": "Response for the API Groups Stats request",
            "title": "API Groups Stats Response",
            "x-displayname": "API Groups Stats Response",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.GetApiGroupsStatsRsp",
            "properties": {
                "items": {
                    "type": "array",
                    "description": " A list of API Groups stats, where each item contains an API Group ID and stats",
                    "title": "items",
                    "items": {
                        "$ref": "#/definitions/app_api_groupApiGroupsStatsItem"
                    },
                    "x-displayname": "API Groups Stats"
                }
            }
        },
        "ioschemaEmpty": {
            "type": "object",
            "description": "x-displayName: \"Empty\"\nThis can be used for messages where no values are needed",
            "title": "Empty"
        },
        "schemaHttpMethod": {
            "type": "string",
            "description": "Specifies the HTTP method used to access a resource.\n\nAny HTTP Method",
            "title": "HttpMethod",
            "enum": [
                "ANY",
                "GET",
                "HEAD",
                "POST",
                "PUT",
                "DELETE",
                "CONNECT",
                "OPTIONS",
                "TRACE",
                "PATCH"
            ],
            "default": "ANY",
            "x-displayname": "HTTP Method",
            "x-ves-proto-enum": "ves.io.schema.HttpMethod"
        },
        "schemaLabelSelectorType": {
            "type": "object",
            "description": "x-displayName: \"Label Selector\"\nThis type can be used to establish a 'selector reference' from one object(called selector) to\na set of other objects(called selectees) based on the value of expresssions.\nA label selector is a label query over a set of resources. An empty label selector matches all objects.\nA null label selector matches no objects. Label selector is immutable.\nexpressions is a list of strings of label selection expression.\nEach string has \",\" separated values which are \"AND\" and all strings are logically \"OR\".\nBNF for expression string\n\u003cselector-syntax\u003e         ::= \u003crequirement\u003e | \u003crequirement\u003e \",\" \u003cselector-syntax\u003e\n\u003crequirement\u003e             ::= [!] KEY [ \u003cset-based-restriction\u003e | \u003cexact-match-restriction\u003e ]\n\u003cset-based-restriction\u003e   ::= \"\" | \u003cinclusion-exclusion\u003e \u003cvalue-set\u003e\n\u003cinclusion-exclusion\u003e     ::= \u003cinclusion\u003e | \u003cexclusion\u003e\n\u003cexclusion\u003e               ::= \"notin\"\n\u003cinclusion\u003e               ::= \"in\"\n\u003cvalue-set\u003e               ::= \"(\" \u003cvalues\u003e \")\"\n\u003cvalues\u003e                  ::= VALUE | VALUE \",\" \u003cvalues\u003e\n\u003cexact-match-restriction\u003e ::= [\"=\"|\"==\"|\"!=\"] VALUE",
            "title": "LabelSelectorType",
            "properties": {
                "expressions": {
                    "type": "array",
                    "description": "x-displayName: \"Selector Expression\"\nx-required\nx-example: \"region in (us-west1, us-west2),tier in (staging)\"\nexpressions contains the kubernetes style label expression for selections.",
                    "title": "expressions",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schemaMessageMetaType": {
            "type": "object",
            "description": "x-displayName: \"Message Metadata\"\nMessageMetaType is metadata (common attributes) of a message that only certain messages\nhave. This information is propagated to the metadata of a child object that gets created\nfrom the containing message during view processing.\nThe information in this type can be specified by user during create and replace APIs.",
            "title": "MessageMetaType",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "x-displayName: \"Description\"\nx-example: \"Virtual Host for acmecorp website\"\nHuman readable description.",
                    "title": "description"
                },
                "disable": {
                    "type": "boolean",
                    "description": "x-displayName: \"Disable\"\nx-example: \"true\"\nA value of true will administratively disable the object that corresponds to the containing message.",
                    "title": "disable",
                    "format": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Name\"\nx-example: \"acmecorp-web\"\nx-required\nThis is the name of the message.\nThe value of name has to follow DNS-1035 format.",
                    "title": "name"
                }
            }
        },
        "schemaapi_group_elementGlobalSpecType": {
            "type": "object",
            "description": "Shape of api_group_element in the storage backend.",
            "title": "GlobalSpecType",
            "x-displayname": "Specification",
            "x-ves-proto-message": "ves.io.schema.api_group_element.GlobalSpecType",
            "properties": {
                "methods": {
                    "type": "array",
                    "description": " List of method values to match the input request API method against.\n The match is considered to succeed if the input request API method is a member of the list.\n\nExample: - \"['PUT', 'POST', 'DELETE']\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.not_in: 0\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "methods",
                    "minItems": 1,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "HTTP Methods",
                    "x-ves-example": "['PUT', 'POST', 'DELETE']",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.not_in": "0",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "path_regex": {
                    "type": "string",
                    "description": " Regular expression to match the input request API path against.\n The match is considered to succeed if the input request API path matches the specified path regex.\n\nExample: - \"/api/config/.*/path[123]/$\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 1024\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "path regex",
                    "minLength": 1,
                    "maxLength": 1024,
                    "x-displayname": "Path Regex",
                    "x-ves-example": "/api/config/.*/path[123]/$",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "1024",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                }
            }
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "This type establishes a direct reference from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.views.ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contacts-route\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 64\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "name",
                    "minLength": 1,
                    "maxLength": 64,
                    "x-displayname": "Name",
                    "x-ves-example": "contacts-route",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "64",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "namespace",
                    "maxLength": 64,
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "tenant",
                    "maxLength": 64,
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                }
            }
        },
        "viewsapp_api_groupGlobalSpecType": {
            "type": "object",
            "description": "Shape of app_api_group in the storage backend.",
            "title": "GlobalSpecType",
            "x-displayname": "Specification",
            "x-ves-oneof-field-scope_choice": "[\"http_loadbalancer\"]",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.GlobalSpecType",
            "properties": {
                "api_endpoints_count": {
                    "type": "integer",
                    "description": " Number of API Endpoints in the actual API Group.\n If the lists included, matched, excluded are disjoint then the length is\n len(included) + len(matched) - excluded\n\nExample: - \"25\"-",
                    "title": "api_endpoints_count",
                    "format": "int64",
                    "x-displayname": "API Endpoints Count",
                    "x-ves-example": "25"
                },
                "elements": {
                    "type": "array",
                    "description": " List of API group elements with methods and path regex for matching requests.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 1000\n",
                    "title": "elements",
                    "maxItems": 1000,
                    "items": {
                        "$ref": "#/definitions/schemaapi_group_elementGlobalSpecType"
                    },
                    "x-displayname": "API Group Elements",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "1000"
                    }
                },
                "http_loadbalancer": {
                    "description": "Exclusive with []\n Set scope to an HTTP Loadbalancer object to define the API endpoints list for API groups management",
                    "title": "HTTP Loadbalancer Scope",
                    "$ref": "#/definitions/app_api_groupApiGroupScopeHttpLoadbalancer",
                    "x-displayname": "HTTP Loadbalancer"
                }
            }
        }
    },
    "x-displayname": "App API Group",
    "x-ves-proto-file": "ves.io/schema/views/app_api_group/public_customapi.proto"
}`
