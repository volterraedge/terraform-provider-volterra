//
// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//

package api_inventory

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAPI GRPC Client satisfying server.CustomClient
type CustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAPIGrpcClient) doRPCEvaluateApiGroup(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &EvaluateApiGroupReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.EvaluateApiGroupReq", yamlReq)
	}
	rsp, err := c.grpcClient.EvaluateApiGroup(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetContent(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetContentReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.GetContentReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetContent(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["EvaluateApiGroup"] = ccl.doRPCEvaluateApiGroup

	rpcFns["GetContent"] = ccl.doRPCGetContent

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPI REST Client satisfying server.CustomClient
type CustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAPIRestClient) doRPCEvaluateApiGroup(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &EvaluateApiGroupReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.EvaluateApiGroupReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("api_group_builder", fmt.Sprintf("%v", req.ApiGroupBuilder))
		q.Add("group_name", fmt.Sprintf("%v", req.GroupName))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &EvaluateApiGroupRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.api_inventory.EvaluateApiGroupRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetContent(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetContentReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.api_inventory.GetContentReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetContentRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.api_inventory.GetContentRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["EvaluateApiGroup"] = ccl.doRPCEvaluateApiGroup

	rpcFns["GetContent"] = ccl.doRPCGetContent

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customAPIInprocClient

// INPROC Client (satisfying CustomAPIClient interface)
type customAPIInprocClient struct {
	CustomAPIServer
}

func (c *customAPIInprocClient) EvaluateApiGroup(ctx context.Context, in *EvaluateApiGroupReq, opts ...grpc.CallOption) (*EvaluateApiGroupRsp, error) {
	return c.CustomAPIServer.EvaluateApiGroup(ctx, in)
}
func (c *customAPIInprocClient) GetContent(ctx context.Context, in *GetContentReq, opts ...grpc.CallOption) (*GetContentRsp, error) {
	return c.CustomAPIServer.GetContent(ctx, in)
}

func NewCustomAPIInprocClient(svc svcfw.Service) CustomAPIClient {
	return &customAPIInprocClient{CustomAPIServer: NewCustomAPIServer(svc)}
}

// RegisterGwCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAPIHandlerClient(ctx, mux, NewCustomAPIInprocClient(s))
}

// Create customAPISrv

// SERVER (satisfying CustomAPIServer interface)
type customAPISrv struct {
	svc svcfw.Service
}

func (s *customAPISrv) EvaluateApiGroup(ctx context.Context, in *EvaluateApiGroupReq) (*EvaluateApiGroupRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.api_inventory.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *EvaluateApiGroupRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.EvaluateApiGroupReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.EvaluateApiGroup' operation on 'api_inventory'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.api_inventory.CustomAPI.EvaluateApiGroup"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.EvaluateApiGroup(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.EvaluateApiGroupRsp", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetContent(ctx context.Context, in *GetContentReq) (*GetContentRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.views.api_inventory.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *GetContentRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.GetContentReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetContent' operation on 'api_inventory'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.views.api_inventory.CustomAPI.GetContent"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetContent(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.api_inventory.GetContentRsp", rsp)...)

	return rsp, nil
}

func NewCustomAPIServer(svc svcfw.Service) CustomAPIServer {
	return &customAPISrv{svc: svc}
}

var CustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "api inventory object",
        "description": "The API Inventory manages an approved set of endpoints of an application per HTTP Load Balancer,\nand it's actually an internal object of the HTTP Load Balancer with custom API defined to reflect this.\nThe endpoints are stored in a swagger file and manipulated by the asterix service,\nthus operations on the inventory are proxied to the asterix service.\nInventory's content is automatically synced with API Definition specified for HTTP Load Balancer.\nIn addition, API Inventory maintains custom API groups as child objects, and provides methods to\nevaluate a custom group builder without updating groups. Custom api groups are defined by\napi group builders which contain selection expressions, explicit include list, and explicit exclude list.\n\n The view creates the following child objects:\n * app_api_group",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{namespace}/http_loadbalancers/{name}/api_inventory": {
            "get": {
                "summary": "Get Content of the API Inventory",
                "description": "Get list of all API Endpoints in the API Inventory\nNOTE: The method is mainly used for custom api groups management.",
                "operationId": "ves.io.schema.views.api_inventory.CustomAPI.GetContent",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/api_inventoryGetContentRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the Http LoadBalancer for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Http LoadBalancer Name\n\nx-example: \"blogging-app\"\nHttp LoadBalancer for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Http LoadBalancer Name"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-api_inventory-customapi-getcontent"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.api_inventory.CustomAPI.GetContent"
            },
            "x-displayname": "API Inventory Custom API",
            "x-ves-proto-service": "ves.io.schema.views.api_inventory.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/http_loadbalancers/{name}/api_inventory/api_groups/{group_name}/evaluate": {
            "post": {
                "summary": "Evaluate Api Group",
                "description": "Evaluate Api Group Builder against the API Inventory and return the resulting API Group.\nNOTE: This operation does not modify any object.",
                "operationId": "ves.io.schema.views.api_inventory.CustomAPI.EvaluateApiGroup",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/api_inventoryEvaluateApiGroupRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the Http LoadBalancer for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Http LoadBalancer Name\n\nx-example: \"blogging-app\"\nHttp LoadBalancer for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Http LoadBalancer Name"
                    },
                    {
                        "name": "group_name",
                        "description": "API Group Name\n\nx-example: \"sensitive\"\nAPI Group name for the current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "API Group Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/api_inventoryEvaluateApiGroupReq"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-views-api_inventory-customapi-evaluateapigroup"
                },
                "x-ves-proto-rpc": "ves.io.schema.views.api_inventory.CustomAPI.EvaluateApiGroup"
            },
            "x-displayname": "API Inventory Custom API",
            "x-ves-proto-service": "ves.io.schema.views.api_inventory.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "api_definitionApiGroupBuilder": {
            "type": "object",
            "description": "Define a group of application operations using path matching and label filtering.",
            "title": "ApiGroupBuilder",
            "x-displayname": "API Group Builder",
            "x-ves-proto-message": "ves.io.schema.views.api_definition.ApiGroupBuilder",
            "properties": {
                "excluded_operations": {
                    "type": "array",
                    "description": " List of operations matched by the filters to be excluded from a group.\n The list should only include operations matched by the filters.\n The paths appear here with parameters as defined in OpenAPI spec file.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 100\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "excluded_operations",
                    "maxItems": 100,
                    "items": {
                        "$ref": "#/definitions/api_definitionApiOperation"
                    },
                    "x-displayname": "Excluded Operations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "100",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "included_operations": {
                    "type": "array",
                    "description": " List of operations not matched by the filters to be included in a group.\n The list should not include operations matched by the filters.\n The paths appear here with parameters as defined in OpenAPI spec file.\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 100\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "included_operations",
                    "maxItems": 100,
                    "items": {
                        "$ref": "#/definitions/api_definitionApiOperation"
                    },
                    "x-displayname": "Included Operations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "100",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "label_filter": {
                    "description": " A group builder should include only labels selected by expression.\n In the current context a label is a property of an OpenAPI operation or path.\n\nExample: - \"method in (POST, DELETE), tag in (web, db)\"-",
                    "title": "label_filter",
                    "$ref": "#/definitions/schemaLabelSelectorType",
                    "x-displayname": "Label Filter",
                    "x-ves-example": "method in (POST, DELETE), tag in (web, db)"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path_filter": {
                    "type": "string",
                    "description": " Regular expression to match the input request API path against.\n The match is considered to succeed if the input request API path matches the specified path regex.\n\nExample: - \"/api/config/.*/path[123]/$\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 1024\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "path_filter",
                    "maxLength": 1024,
                    "x-displayname": "Path Filter",
                    "x-ves-example": "/api/config/.*/path[123]/$",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "1024",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                }
            }
        },
        "api_definitionApiOperation": {
            "type": "object",
            "description": "API operation according to OpenAPI specification.",
            "title": "ApiOperation",
            "x-displayname": "API Operation",
            "x-ves-proto-message": "ves.io.schema.views.api_definition.ApiOperation",
            "properties": {
                "method": {
                    "description": " Method to match the input request API method against.\n\nExample: - 'POST'-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "method",
                    "$ref": "#/definitions/schemaHttpMethod",
                    "x-displayname": "HTTP Method",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "path": {
                    "type": "string",
                    "description": " An endpoint path, as specified in OpenAPI, including parameters.\n The path should comply with RFC 3986 and may have parameters according to OpenAPI specification\n\nExample: - \"/api/users/{userid}\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 1024\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.pattern: ^/[\\\\w/{}\\\\-._~%!$\u0026'()*+,;=:]*$\n",
                    "title": "path",
                    "minLength": 1,
                    "maxLength": 1024,
                    "x-displayname": "Path",
                    "x-ves-example": "/api/users/{userid}",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "1024",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.pattern": "^/[\\\\w/{}\\\\-._~%!$\u0026'()*+,;=:]*$"
                    }
                }
            }
        },
        "api_inventoryApiEndpoint": {
            "type": "object",
            "description": "The API Endpoint is the item of the API Inventory",
            "title": "Api Endpoint",
            "x-displayname": "API Endpoint",
            "x-ves-proto-message": "ves.io.schema.views.api_inventory.ApiEndpoint",
            "properties": {
                "method": {
                    "description": " Method to match the input request API method against.\n\nExample: - 'POST'-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "method",
                    "$ref": "#/definitions/schemaHttpMethod",
                    "x-displayname": "HTTP Method",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "origin": {
                    "description": " The origin of an endpoint in the API Inventory.\n\nExample: - 'ORIGIN_SWAGGER'-",
                    "title": "origin",
                    "$ref": "#/definitions/api_inventoryApiEndpointOrigin",
                    "x-displayname": "API Endpoint Origin"
                },
                "path": {
                    "type": "string",
                    "description": " An endpoint path, as specified in OpenAPI, including parameters.\n The path should comply with RFC 3986 and may have parameters according to OpenAPI specification\n\nExample: - \"/api/users/{userid}\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 1024\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.templated_http_path: true\n",
                    "title": "path",
                    "minLength": 1,
                    "maxLength": 1024,
                    "x-displayname": "Path",
                    "x-ves-example": "/api/users/{userid}",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "1024",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.templated_http_path": "true"
                    }
                }
            }
        },
        "api_inventoryApiEndpointOrigin": {
            "type": "string",
            "description": "The origin of an endpoint in the API Inventory.\n\nORIGIN UNKNOWN is the default origin for an endpoint in the API Inventory.\nORIGIN SWAGGER marks an endpoint which was imported from swagger.\nORIGIN DISCOVERED marks an endpoint which was discovered.",
            "title": "ApiEndpointOrigin",
            "enum": [
                "ORIGIN_UNKNOWN",
                "ORIGIN_SWAGGER",
                "ORIGIN_DISCOVERED"
            ],
            "default": "ORIGIN_UNKNOWN",
            "x-displayname": "API Endpoint Origin",
            "x-ves-proto-enum": "ves.io.schema.views.api_inventory.ApiEndpointOrigin"
        },
        "api_inventoryEvaluateApiGroupReq": {
            "type": "object",
            "description": "Request shape for Evaluate Api Group Builders",
            "title": "Evaluate API Group Builders Request",
            "x-displayname": "Evaluate Api Group Builders Request",
            "x-ves-proto-message": "ves.io.schema.views.api_inventory.EvaluateApiGroupReq",
            "properties": {
                "api_group_builder": {
                    "description": " An Api Group Builder to evaluate against the API Inventory.",
                    "title": "API Group Builder",
                    "$ref": "#/definitions/api_definitionApiGroupBuilder",
                    "x-displayname": "API Group Builder"
                },
                "group_name": {
                    "type": "string",
                    "description": " API Group name for the current request\n\nExample: - \"sensitive\"-",
                    "title": "API Group Name",
                    "x-displayname": "API Group Name",
                    "x-ves-example": "sensitive"
                },
                "name": {
                    "type": "string",
                    "description": " Http LoadBalancer for the current request\n\nExample: - \"blogging-app\"-",
                    "title": "Http LoadBalancer Name",
                    "x-displayname": "Http LoadBalancer Name",
                    "x-ves-example": "blogging-app"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the Http LoadBalancer for the current request\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                }
            }
        },
        "api_inventoryEvaluateApiGroupRsp": {
            "type": "object",
            "description": "Response for the Evaluate Api Group Builder request",
            "title": "Evaluate Api Group Builder Response",
            "x-displayname": "Evaluate Api Group Builder Response",
            "x-ves-proto-message": "ves.io.schema.views.api_inventory.EvaluateApiGroupRsp",
            "properties": {
                "api_group": {
                    "description": " The API group as a result of evaluating API group builder against the API inventory",
                    "title": "Api Group",
                    "$ref": "#/definitions/viewsapp_api_groupGlobalSpecType",
                    "x-displayname": "Api Group"
                }
            }
        },
        "api_inventoryGetContentRsp": {
            "type": "object",
            "description": "Response shape for Get API Endpoints request",
            "title": "Get API Endpoints Response",
            "x-displayname": "Get API Endpoints Response",
            "x-ves-proto-message": "ves.io.schema.views.api_inventory.GetContentRsp",
            "properties": {
                "api_endpoints": {
                    "type": "array",
                    "description": " A list of API endpoints of the API Inventory",
                    "title": "API Endpoints",
                    "items": {
                        "$ref": "#/definitions/api_inventoryApiEndpoint"
                    },
                    "x-displayname": "API Endpoints"
                }
            }
        },
        "schemaHttpMethod": {
            "type": "string",
            "description": "Specifies the HTTP method used to access a resource.\n\nAny HTTP Method\nGET method\nHEAD method\nPOST method\nPUT method\nDELETE method\nCONNECT method\nOPTIONS method\nTRACE method\nPATCH method",
            "title": "HttpMethod",
            "enum": [
                "ANY",
                "GET",
                "HEAD",
                "POST",
                "PUT",
                "DELETE",
                "CONNECT",
                "OPTIONS",
                "TRACE",
                "PATCH"
            ],
            "default": "ANY",
            "x-displayname": "HTTP Method",
            "x-ves-proto-enum": "ves.io.schema.HttpMethod"
        },
        "schemaLabelSelectorType": {
            "type": "object",
            "description": "This type can be used to establish a 'selector reference' from one object(called selector) to\na set of other objects(called selectees) based on the value of expresssions.\nA label selector is a label query over a set of resources. An empty label selector matches all objects.\nA null label selector matches no objects. Label selector is immutable.\nexpressions is a list of strings of label selection expression.\nEach string has \",\" separated values which are \"AND\" and all strings are logically \"OR\".\nBNF for expression string\n\u003cselector-syntax\u003e         ::= \u003crequirement\u003e | \u003crequirement\u003e \",\" \u003cselector-syntax\u003e\n\u003crequirement\u003e             ::= [!] KEY [ \u003cset-based-restriction\u003e | \u003cexact-match-restriction\u003e ]\n\u003cset-based-restriction\u003e   ::= \"\" | \u003cinclusion-exclusion\u003e \u003cvalue-set\u003e\n\u003cinclusion-exclusion\u003e     ::= \u003cinclusion\u003e | \u003cexclusion\u003e\n\u003cexclusion\u003e               ::= \"notin\"\n\u003cinclusion\u003e               ::= \"in\"\n\u003cvalue-set\u003e               ::= \"(\" \u003cvalues\u003e \")\"\n\u003cvalues\u003e                  ::= VALUE | VALUE \",\" \u003cvalues\u003e\n\u003cexact-match-restriction\u003e ::= [\"=\"|\"==\"|\"!=\"] VALUE",
            "title": "LabelSelectorType",
            "x-displayname": "Label Selector",
            "x-ves-proto-message": "ves.io.schema.LabelSelectorType",
            "properties": {
                "expressions": {
                    "type": "array",
                    "description": " expressions contains the kubernetes style label expression for selections.\n\nExample: - \"region in (us-west1, us-west2),tier in (staging)\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.string.k8s_label_selector: true\n  ves.io.schema.rules.repeated.items.string.max_len: 4096\n  ves.io.schema.rules.repeated.items.string.min_len: 1\n  ves.io.schema.rules.repeated.max_items: 1\n",
                    "title": "expressions",
                    "maxItems": 1,
                    "items": {
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 4096
                    },
                    "x-displayname": "Selector Expression",
                    "x-ves-example": "region in (us-west1, us-west2),tier in (staging)",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.string.k8s_label_selector": "true",
                        "ves.io.schema.rules.repeated.items.string.max_len": "4096",
                        "ves.io.schema.rules.repeated.items.string.min_len": "1",
                        "ves.io.schema.rules.repeated.max_items": "1"
                    }
                }
            }
        },
        "schemaMessageMetaType": {
            "type": "object",
            "description": "MessageMetaType is metadata (common attributes) of a message that only certain messages\nhave. This information is propagated to the metadata of a child object that gets created\nfrom the containing message during view processing.\nThe information in this type can be specified by user during create and replace APIs.",
            "title": "MessageMetaType",
            "x-displayname": "Message Metadata",
            "x-ves-proto-message": "ves.io.schema.MessageMetaType",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " Human readable description.\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "description",
                    "maxLength": 256,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of the message.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.min_len: 1\n  ves.io.schema.rules.string.ves_object_name: true\n",
                    "title": "name",
                    "minLength": 1,
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.min_len": "1",
                        "ves.io.schema.rules.string.ves_object_name": "true"
                    }
                }
            }
        },
        "schemaapi_group_elementGlobalSpecType": {
            "type": "object",
            "description": "Shape of api_group_element in the storage backend.",
            "title": "GlobalSpecType",
            "x-displayname": "Specification",
            "x-ves-proto-message": "ves.io.schema.api_group_element.GlobalSpecType",
            "properties": {
                "methods": {
                    "type": "array",
                    "description": " List of method values to match the input request API method against.\n The match is considered to succeed if the input request API method is a member of the list.\n\nExample: - \"['PUT', 'POST', 'DELETE']\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.not_in: 0\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "methods",
                    "minItems": 1,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "HTTP Methods",
                    "x-ves-example": "['PUT', 'POST', 'DELETE']",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.not_in": "0",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "path_regex": {
                    "type": "string",
                    "description": " Regular expression to match the input request API path against.\n The match is considered to succeed if the input request API path matches the specified path regex.\n\nExample: - \"/api/config/.*/path[123]/$\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 1024\n  ves.io.schema.rules.string.min_bytes: 1\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "path regex",
                    "minLength": 1,
                    "maxLength": 1024,
                    "x-displayname": "Path Regex",
                    "x-ves-example": "/api/config/.*/path[123]/$",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "1024",
                        "ves.io.schema.rules.string.min_bytes": "1",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                }
            }
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "x-displayName: \"Object reference\"\nThis type establishes a direct reference from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "x-displayName: \"Name\"\nx-example: \"contacts-route\"\nx-required\nWhen a configuration object(e.g. virtual_host) refers to another(e.g route)\nthen name will hold the referred object's(e.g. route's) name.",
                    "title": "name"
                },
                "namespace": {
                    "type": "string",
                    "description": "x-displayName: \"Namespace\"\nx-example: \"ns1\"\nWhen a configuration object(e.g. virtual_host) refers to another(e.g route)\nthen namespace will hold the referred object's(e.g. route's) namespace.",
                    "title": "namespace"
                },
                "tenant": {
                    "type": "string",
                    "description": "x-displayName: \"Tenant\"\nx-example: \"acmecorp\"\nWhen a configuration object(e.g. virtual_host) refers to another(e.g route)\nthen tenant will hold the referred object's(e.g. route's) tenant.",
                    "title": "tenant"
                }
            }
        },
        "viewsapp_api_groupGlobalSpecType": {
            "type": "object",
            "description": "Shape of app_api_group in the storage backend.",
            "title": "GlobalSpecType",
            "x-displayname": "Specification",
            "x-ves-proto-message": "ves.io.schema.views.app_api_group.GlobalSpecType",
            "properties": {
                "elements": {
                    "type": "array",
                    "description": " List of API group elements with methods and path regex for matching requests.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 1000\n",
                    "title": "elements",
                    "maxItems": 1000,
                    "items": {
                        "$ref": "#/definitions/schemaapi_group_elementGlobalSpecType"
                    },
                    "x-displayname": "API Group Elements",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "1000"
                    }
                }
            }
        }
    },
    "x-displayname": "API Inventory",
    "x-ves-proto-file": "ves.io/schema/views/api_inventory/public_customapi.proto"
}`
