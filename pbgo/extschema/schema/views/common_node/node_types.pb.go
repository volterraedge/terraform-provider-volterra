// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/common_node/node_types.proto

package common_node

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	network_interface "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Ethernet Interface
//
// x-displayName: "Ethernet Interface"
type EthernetInterfaceType struct {
	// Device
	//
	// x-displayName: "Ethernet Device"
	// x-example: "ver1"
	// x-required
	// Select an Ethernet device from the discovered interfaces to configure.
	// Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Mac Address
	//
	// x-displayName: "MAC Address"
	// x-example: "01:10:20:0a:bb:1c"
	Mac string `protobuf:"bytes,2,opt,name=mac,proto3" json:"mac,omitempty"`
}

func (m *EthernetInterfaceType) Reset()      { *m = EthernetInterfaceType{} }
func (*EthernetInterfaceType) ProtoMessage() {}
func (*EthernetInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ea4045582a648f2, []int{0}
}
func (m *EthernetInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EthernetInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EthernetInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthernetInterfaceType.Merge(m, src)
}
func (m *EthernetInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *EthernetInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_EthernetInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_EthernetInterfaceType proto.InternalMessageInfo

func (m *EthernetInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *EthernetInterfaceType) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

// Vlan Interface
//
// x-displayName: "Vlan Interface"
type VlanInterfaceType struct {
	// parent
	//
	// x-displayName: "Parent Interface"
	// x-example: "eth0"
	// x-required
	// Select a parent interface from the dropdown.
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// VLAN Id
	//
	// x-displayName: "VLAN ID"
	// Configure the VLAN tag for this interface.
	VlanId uint32 `protobuf:"varint,2,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
}

func (m *VlanInterfaceType) Reset()      { *m = VlanInterfaceType{} }
func (*VlanInterfaceType) ProtoMessage() {}
func (*VlanInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ea4045582a648f2, []int{1}
}
func (m *VlanInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VlanInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VlanInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VlanInterfaceType.Merge(m, src)
}
func (m *VlanInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *VlanInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_VlanInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_VlanInterfaceType proto.InternalMessageInfo

func (m *VlanInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *VlanInterfaceType) GetVlanId() uint32 {
	if m != nil {
		return m.VlanId
	}
	return 0
}

// NetworkSelectType
//
// x-displayName: "Network Select"
// x-required
// Select virtual network (VRF) for this interface.
// There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites.
// A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional.
// Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).
type NetworkSelectType struct {
	// Select VRF
	//
	// x-displayName: "Select VRF"
	// Select virtual network (VRF) for this interface.
	// There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites.
	// A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional.
	// Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).
	//
	// Types that are valid to be assigned to NetworkChoice:
	//	*NetworkSelectType_SiteLocalNetwork
	//	*NetworkSelectType_SiteLocalInsideNetwork
	//	*NetworkSelectType_SegmentNetwork
	NetworkChoice isNetworkSelectType_NetworkChoice `protobuf_oneof:"network_choice"`
}

func (m *NetworkSelectType) Reset()      { *m = NetworkSelectType{} }
func (*NetworkSelectType) ProtoMessage() {}
func (*NetworkSelectType) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ea4045582a648f2, []int{2}
}
func (m *NetworkSelectType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkSelectType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkSelectType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkSelectType.Merge(m, src)
}
func (m *NetworkSelectType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkSelectType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkSelectType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkSelectType proto.InternalMessageInfo

type isNetworkSelectType_NetworkChoice interface {
	isNetworkSelectType_NetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NetworkSelectType_SiteLocalNetwork struct {
	SiteLocalNetwork *schema.Empty `protobuf:"bytes,2,opt,name=site_local_network,json=siteLocalNetwork,proto3,oneof" json:"site_local_network,omitempty"`
}
type NetworkSelectType_SiteLocalInsideNetwork struct {
	SiteLocalInsideNetwork *schema.Empty `protobuf:"bytes,3,opt,name=site_local_inside_network,json=siteLocalInsideNetwork,proto3,oneof" json:"site_local_inside_network,omitempty"`
}
type NetworkSelectType_SegmentNetwork struct {
	SegmentNetwork *views.ObjectRefType `protobuf:"bytes,4,opt,name=segment_network,json=segmentNetwork,proto3,oneof" json:"segment_network,omitempty"`
}

func (*NetworkSelectType_SiteLocalNetwork) isNetworkSelectType_NetworkChoice()       {}
func (*NetworkSelectType_SiteLocalInsideNetwork) isNetworkSelectType_NetworkChoice() {}
func (*NetworkSelectType_SegmentNetwork) isNetworkSelectType_NetworkChoice()         {}

func (m *NetworkSelectType) GetNetworkChoice() isNetworkSelectType_NetworkChoice {
	if m != nil {
		return m.NetworkChoice
	}
	return nil
}

func (m *NetworkSelectType) GetSiteLocalNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*NetworkSelectType_SiteLocalNetwork); ok {
		return x.SiteLocalNetwork
	}
	return nil
}

func (m *NetworkSelectType) GetSiteLocalInsideNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*NetworkSelectType_SiteLocalInsideNetwork); ok {
		return x.SiteLocalInsideNetwork
	}
	return nil
}

func (m *NetworkSelectType) GetSegmentNetwork() *views.ObjectRefType {
	if x, ok := m.GetNetworkChoice().(*NetworkSelectType_SegmentNetwork); ok {
		return x.SegmentNetwork
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NetworkSelectType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NetworkSelectType_SiteLocalNetwork)(nil),
		(*NetworkSelectType_SiteLocalInsideNetwork)(nil),
		(*NetworkSelectType_SegmentNetwork)(nil),
	}
}

// Interface
//
// x-displayName: "Interface"
// Interface definition
type Interface struct {
	// Interface Description
	//
	// x-displayName: "Interface Description"
	// x-example: "value"
	// Description for this Interface
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// Interface labels
	//
	// x-displayName: "Interface Labels"
	// x-example: "value"
	// Add Labels for this Interface, these labels can be used in firewall policy
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Interface Config Type
	//
	// x-displayName: "Interface Type"
	// x-required
	// Select the appropriate interface type.
	// For sites with F5 rSeries as the provider, the 1st interface will be an Ethernet interface mapped to the Site Local Outside (SLO) local VRF. Configure any additional interfaces required as VLAN interfaces.
	// For sites with Bond interfaces, Bond for Site Local Outside (SLO) local VRF will be configured on the node itself during provisioning. After the node registers, this bond interface can be managed from here.
	// Any additional Bond interfaces can be configured from here.
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*Interface_EthernetInterface
	//	*Interface_VlanInterface
	//	*Interface_BondInterface
	InterfaceChoice isInterface_InterfaceChoice `protobuf_oneof:"interface_choice"`
	// Interface Addressing
	//
	// x-displayName: "IPv4 Interface Address Method"
	// x-required
	// Select how ipv4 address will be assigned to this interface.
	//
	// Types that are valid to be assigned to AddressChoice:
	//	*Interface_DhcpClient
	//	*Interface_StaticIp
	//	*Interface_DhcpServer
	//	*Interface_NoIpv4Address
	AddressChoice isInterface_AddressChoice `protobuf_oneof:"address_choice"`
	// Interface Name
	//
	// x-displayName: "Interface Name"
	// x-example: "value"
	// Name of this Interface
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,11,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Select VRF
	//
	// x-displayName: "Select VRF"
	// x-required
	// Select virtual network (VRF) for this interface.
	// There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites.
	// A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional.
	// Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).
	NetworkOption *NetworkSelectType `protobuf:"bytes,12,opt,name=network_option,json=networkOption,proto3" json:"network_option,omitempty"`
	// Select Link Quality Monitoring configuration
	//
	// x-displayName: "Link Quality Monitoring"
	// When enabled, probes will be sent on the network interface to monitor quality of the link.
	// Links are assigned a score based on the result of probes.
	//
	// Types that are valid to be assigned to MonitoringChoice:
	//	*Interface_MonitorDisabled
	//	*Interface_Monitor
	MonitoringChoice isInterface_MonitoringChoice `protobuf_oneof:"monitoring_choice"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active
	// and interfaces with lower priority will be used as backup.
	// If multiple interfaces have the same priority, ECMP will be used.
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,19,opt,name=priority,proto3" json:"priority,omitempty"`
	// Use for Site to Site Connectivity
	//
	// x-displayName: "Use for Site to Site Connectivity"
	// Interface with this field enabled will be used to connect to other sites.
	// This setting is useful if a node has multiple interfaces configured in a VRF.
	// Only one interface in a VRF can have this field enabled.
	//
	// Types that are valid to be assigned to SiteToSiteConnectivityInterfaceChoice:
	//	*Interface_SiteToSiteConnectivityInterfaceDisabled
	//	*Interface_SiteToSiteConnectivityInterfaceEnabled
	SiteToSiteConnectivityInterfaceChoice isInterface_SiteToSiteConnectivityInterfaceChoice `protobuf_oneof:"site_to_site_connectivity_interface_choice"`
	// Use for Primary Interface
	//
	// x-displayName: "Use for Primary Interface"
	// Use for Primary Interface
	IsPrimary bool `protobuf:"varint,23,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
	// Management Interface
	//
	// x-displayName: "Management Interface"
	// To be used internally to set an interface as management interface
	IsManagement bool `protobuf:"varint,26,opt,name=is_management,json=isManagement,proto3" json:"is_management,omitempty"`
	// IPv6 Interface Addressing
	//
	// x-displayName: "IPv6 Interface Address Method"
	// Optional, select how ipv6 address will be assigned to this interface.
	//
	// Types that are valid to be assigned to Ipv6AddressChoice:
	//	*Interface_NoIpv6Address
	//	*Interface_StaticIpv6Address
	//	*Interface_Ipv6AutoConfig
	Ipv6AddressChoice isInterface_Ipv6AddressChoice `protobuf_oneof:"ipv6_address_choice"`
}

func (m *Interface) Reset()      { *m = Interface{} }
func (*Interface) ProtoMessage() {}
func (*Interface) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ea4045582a648f2, []int{3}
}
func (m *Interface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Interface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Interface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Interface.Merge(m, src)
}
func (m *Interface) XXX_Size() int {
	return m.Size()
}
func (m *Interface) XXX_DiscardUnknown() {
	xxx_messageInfo_Interface.DiscardUnknown(m)
}

var xxx_messageInfo_Interface proto.InternalMessageInfo

type isInterface_InterfaceChoice interface {
	isInterface_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isInterface_AddressChoice interface {
	isInterface_AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isInterface_MonitoringChoice interface {
	isInterface_MonitoringChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isInterface_SiteToSiteConnectivityInterfaceChoice interface {
	isInterface_SiteToSiteConnectivityInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isInterface_Ipv6AddressChoice interface {
	isInterface_Ipv6AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Interface_EthernetInterface struct {
	EthernetInterface *EthernetInterfaceType `protobuf:"bytes,4,opt,name=ethernet_interface,json=ethernetInterface,proto3,oneof" json:"ethernet_interface,omitempty"`
}
type Interface_VlanInterface struct {
	VlanInterface *VlanInterfaceType `protobuf:"bytes,5,opt,name=vlan_interface,json=vlanInterface,proto3,oneof" json:"vlan_interface,omitempty"`
}
type Interface_BondInterface struct {
	BondInterface *fleet.FleetBondDeviceType `protobuf:"bytes,6,opt,name=bond_interface,json=bondInterface,proto3,oneof" json:"bond_interface,omitempty"`
}
type Interface_DhcpClient struct {
	DhcpClient *schema.Empty `protobuf:"bytes,8,opt,name=dhcp_client,json=dhcpClient,proto3,oneof" json:"dhcp_client,omitempty"`
}
type Interface_StaticIp struct {
	StaticIp *network_interface.StaticIpParametersNodeType `protobuf:"bytes,9,opt,name=static_ip,json=staticIp,proto3,oneof" json:"static_ip,omitempty"`
}
type Interface_DhcpServer struct {
	DhcpServer *network_interface.DHCPServerParametersType `protobuf:"bytes,27,opt,name=dhcp_server,json=dhcpServer,proto3,oneof" json:"dhcp_server,omitempty"`
}
type Interface_NoIpv4Address struct {
	NoIpv4Address *schema.Empty `protobuf:"bytes,32,opt,name=no_ipv4_address,json=noIpv4Address,proto3,oneof" json:"no_ipv4_address,omitempty"`
}
type Interface_MonitorDisabled struct {
	MonitorDisabled *schema.Empty `protobuf:"bytes,17,opt,name=monitor_disabled,json=monitorDisabled,proto3,oneof" json:"monitor_disabled,omitempty"`
}
type Interface_Monitor struct {
	Monitor *network_interface.LinkQualityMonitorConfig `protobuf:"bytes,18,opt,name=monitor,proto3,oneof" json:"monitor,omitempty"`
}
type Interface_SiteToSiteConnectivityInterfaceDisabled struct {
	SiteToSiteConnectivityInterfaceDisabled *schema.Empty `protobuf:"bytes,21,opt,name=site_to_site_connectivity_interface_disabled,json=siteToSiteConnectivityInterfaceDisabled,proto3,oneof" json:"site_to_site_connectivity_interface_disabled,omitempty"`
}
type Interface_SiteToSiteConnectivityInterfaceEnabled struct {
	SiteToSiteConnectivityInterfaceEnabled *schema.Empty `protobuf:"bytes,22,opt,name=site_to_site_connectivity_interface_enabled,json=siteToSiteConnectivityInterfaceEnabled,proto3,oneof" json:"site_to_site_connectivity_interface_enabled,omitempty"`
}
type Interface_NoIpv6Address struct {
	NoIpv6Address *schema.Empty `protobuf:"bytes,29,opt,name=no_ipv6_address,json=noIpv6Address,proto3,oneof" json:"no_ipv6_address,omitempty"`
}
type Interface_StaticIpv6Address struct {
	StaticIpv6Address *network_interface.StaticIPParametersType `protobuf:"bytes,30,opt,name=static_ipv6_address,json=staticIpv6Address,proto3,oneof" json:"static_ipv6_address,omitempty"`
}
type Interface_Ipv6AutoConfig struct {
	Ipv6AutoConfig *network_interface.IPV6AutoConfigType `protobuf:"bytes,31,opt,name=ipv6_auto_config,json=ipv6AutoConfig,proto3,oneof" json:"ipv6_auto_config,omitempty"`
}

func (*Interface_EthernetInterface) isInterface_InterfaceChoice() {}
func (*Interface_VlanInterface) isInterface_InterfaceChoice()     {}
func (*Interface_BondInterface) isInterface_InterfaceChoice()     {}
func (*Interface_DhcpClient) isInterface_AddressChoice()          {}
func (*Interface_StaticIp) isInterface_AddressChoice()            {}
func (*Interface_DhcpServer) isInterface_AddressChoice()          {}
func (*Interface_NoIpv4Address) isInterface_AddressChoice()       {}
func (*Interface_MonitorDisabled) isInterface_MonitoringChoice()  {}
func (*Interface_Monitor) isInterface_MonitoringChoice()          {}
func (*Interface_SiteToSiteConnectivityInterfaceDisabled) isInterface_SiteToSiteConnectivityInterfaceChoice() {
}
func (*Interface_SiteToSiteConnectivityInterfaceEnabled) isInterface_SiteToSiteConnectivityInterfaceChoice() {
}
func (*Interface_NoIpv6Address) isInterface_Ipv6AddressChoice()     {}
func (*Interface_StaticIpv6Address) isInterface_Ipv6AddressChoice() {}
func (*Interface_Ipv6AutoConfig) isInterface_Ipv6AddressChoice()    {}

func (m *Interface) GetInterfaceChoice() isInterface_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}
func (m *Interface) GetAddressChoice() isInterface_AddressChoice {
	if m != nil {
		return m.AddressChoice
	}
	return nil
}
func (m *Interface) GetMonitoringChoice() isInterface_MonitoringChoice {
	if m != nil {
		return m.MonitoringChoice
	}
	return nil
}
func (m *Interface) GetSiteToSiteConnectivityInterfaceChoice() isInterface_SiteToSiteConnectivityInterfaceChoice {
	if m != nil {
		return m.SiteToSiteConnectivityInterfaceChoice
	}
	return nil
}
func (m *Interface) GetIpv6AddressChoice() isInterface_Ipv6AddressChoice {
	if m != nil {
		return m.Ipv6AddressChoice
	}
	return nil
}

func (m *Interface) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Interface) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Interface) GetEthernetInterface() *EthernetInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*Interface_EthernetInterface); ok {
		return x.EthernetInterface
	}
	return nil
}

func (m *Interface) GetVlanInterface() *VlanInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*Interface_VlanInterface); ok {
		return x.VlanInterface
	}
	return nil
}

func (m *Interface) GetBondInterface() *fleet.FleetBondDeviceType {
	if x, ok := m.GetInterfaceChoice().(*Interface_BondInterface); ok {
		return x.BondInterface
	}
	return nil
}

func (m *Interface) GetDhcpClient() *schema.Empty {
	if x, ok := m.GetAddressChoice().(*Interface_DhcpClient); ok {
		return x.DhcpClient
	}
	return nil
}

func (m *Interface) GetStaticIp() *network_interface.StaticIpParametersNodeType {
	if x, ok := m.GetAddressChoice().(*Interface_StaticIp); ok {
		return x.StaticIp
	}
	return nil
}

func (m *Interface) GetDhcpServer() *network_interface.DHCPServerParametersType {
	if x, ok := m.GetAddressChoice().(*Interface_DhcpServer); ok {
		return x.DhcpServer
	}
	return nil
}

func (m *Interface) GetNoIpv4Address() *schema.Empty {
	if x, ok := m.GetAddressChoice().(*Interface_NoIpv4Address); ok {
		return x.NoIpv4Address
	}
	return nil
}

func (m *Interface) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Interface) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *Interface) GetNetworkOption() *NetworkSelectType {
	if m != nil {
		return m.NetworkOption
	}
	return nil
}

func (m *Interface) GetMonitorDisabled() *schema.Empty {
	if x, ok := m.GetMonitoringChoice().(*Interface_MonitorDisabled); ok {
		return x.MonitorDisabled
	}
	return nil
}

func (m *Interface) GetMonitor() *network_interface.LinkQualityMonitorConfig {
	if x, ok := m.GetMonitoringChoice().(*Interface_Monitor); ok {
		return x.Monitor
	}
	return nil
}

func (m *Interface) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Interface) GetSiteToSiteConnectivityInterfaceDisabled() *schema.Empty {
	if x, ok := m.GetSiteToSiteConnectivityInterfaceChoice().(*Interface_SiteToSiteConnectivityInterfaceDisabled); ok {
		return x.SiteToSiteConnectivityInterfaceDisabled
	}
	return nil
}

func (m *Interface) GetSiteToSiteConnectivityInterfaceEnabled() *schema.Empty {
	if x, ok := m.GetSiteToSiteConnectivityInterfaceChoice().(*Interface_SiteToSiteConnectivityInterfaceEnabled); ok {
		return x.SiteToSiteConnectivityInterfaceEnabled
	}
	return nil
}

func (m *Interface) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *Interface) GetIsManagement() bool {
	if m != nil {
		return m.IsManagement
	}
	return false
}

func (m *Interface) GetNoIpv6Address() *schema.Empty {
	if x, ok := m.GetIpv6AddressChoice().(*Interface_NoIpv6Address); ok {
		return x.NoIpv6Address
	}
	return nil
}

func (m *Interface) GetStaticIpv6Address() *network_interface.StaticIPParametersType {
	if x, ok := m.GetIpv6AddressChoice().(*Interface_StaticIpv6Address); ok {
		return x.StaticIpv6Address
	}
	return nil
}

func (m *Interface) GetIpv6AutoConfig() *network_interface.IPV6AutoConfigType {
	if x, ok := m.GetIpv6AddressChoice().(*Interface_Ipv6AutoConfig); ok {
		return x.Ipv6AutoConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Interface) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Interface_EthernetInterface)(nil),
		(*Interface_VlanInterface)(nil),
		(*Interface_BondInterface)(nil),
		(*Interface_DhcpClient)(nil),
		(*Interface_StaticIp)(nil),
		(*Interface_DhcpServer)(nil),
		(*Interface_NoIpv4Address)(nil),
		(*Interface_MonitorDisabled)(nil),
		(*Interface_Monitor)(nil),
		(*Interface_SiteToSiteConnectivityInterfaceDisabled)(nil),
		(*Interface_SiteToSiteConnectivityInterfaceEnabled)(nil),
		(*Interface_NoIpv6Address)(nil),
		(*Interface_StaticIpv6Address)(nil),
		(*Interface_Ipv6AutoConfig)(nil),
	}
}

// Node
//
// x-displayName: "Nodes"
// Nodes definition
type Node struct {
	// Type
	//
	// x-displayName: "Type"
	// x-example: "Control"
	// Type for this Node, can be Control or Worker
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Hostname
	//
	// x-displayName: "Hostname"
	// x-example: "Control"
	// Hostname for this Node
	Hostname string `protobuf:"bytes,3,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Public IP
	//
	// x-displayName: "Public IP"
	// x-example: "1.1.1.1"
	// Public IP for this Node
	PublicIp string `protobuf:"bytes,6,opt,name=public_ip,json=publicIp,proto3" json:"public_ip,omitempty"`
	// Interfaces
	//
	// x-displayName: "Interfaces"
	// Manage interfaces belonging to this node
	InterfaceList []*Interface `protobuf:"bytes,7,rep,name=interface_list,json=interfaceList,proto3" json:"interface_list,omitempty"`
}

func (m *Node) Reset()      { *m = Node{} }
func (*Node) ProtoMessage() {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ea4045582a648f2, []int{4}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Node) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Node) GetPublicIp() string {
	if m != nil {
		return m.PublicIp
	}
	return ""
}

func (m *Node) GetInterfaceList() []*Interface {
	if m != nil {
		return m.InterfaceList
	}
	return nil
}

func init() {
	proto.RegisterType((*EthernetInterfaceType)(nil), "ves.io.schema.views.common_node.EthernetInterfaceType")
	golang_proto.RegisterType((*EthernetInterfaceType)(nil), "ves.io.schema.views.common_node.EthernetInterfaceType")
	proto.RegisterType((*VlanInterfaceType)(nil), "ves.io.schema.views.common_node.VlanInterfaceType")
	golang_proto.RegisterType((*VlanInterfaceType)(nil), "ves.io.schema.views.common_node.VlanInterfaceType")
	proto.RegisterType((*NetworkSelectType)(nil), "ves.io.schema.views.common_node.NetworkSelectType")
	golang_proto.RegisterType((*NetworkSelectType)(nil), "ves.io.schema.views.common_node.NetworkSelectType")
	proto.RegisterType((*Interface)(nil), "ves.io.schema.views.common_node.Interface")
	golang_proto.RegisterType((*Interface)(nil), "ves.io.schema.views.common_node.Interface")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.common_node.Interface.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.common_node.Interface.LabelsEntry")
	proto.RegisterType((*Node)(nil), "ves.io.schema.views.common_node.Node")
	golang_proto.RegisterType((*Node)(nil), "ves.io.schema.views.common_node.Node")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/common_node/node_types.proto", fileDescriptor_7ea4045582a648f2)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/common_node/node_types.proto", fileDescriptor_7ea4045582a648f2)
}

var fileDescriptor_7ea4045582a648f2 = []byte{
	// 1947 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0xe6, 0x90, 0x2b, 0x72, 0xf5, 0x64, 0x51, 0xe4, 0xca, 0xb2, 0x56, 0xb2, 0x4d, 0x31, 0x0a,
	0x6a, 0xcb, 0xf4, 0x8a, 0x14, 0x97, 0xb2, 0xfe, 0x8a, 0xb6, 0x11, 0x25, 0x07, 0xa2, 0x20, 0xd9,
	0xf2, 0x2a, 0x71, 0x50, 0xb7, 0x00, 0xb1, 0xe4, 0x8e, 0xa8, 0xa9, 0xc8, 0x1d, 0x62, 0x77, 0xc8,
	0x54, 0x87, 0x00, 0xbe, 0x34, 0x40, 0x8d, 0x16, 0x28, 0xd2, 0x9b, 0x81, 0xde, 0x8b, 0x9c, 0x7a,
	0x2c, 0x42, 0x1d, 0x84, 0x00, 0x05, 0x8a, 0x9c, 0x74, 0x34, 0x7a, 0xb2, 0xe9, 0x43, 0x93, 0x9e,
	0x72, 0x29, 0x50, 0xf4, 0x92, 0x62, 0x67, 0x97, 0xff, 0xb2, 0xa4, 0x43, 0x2f, 0xd4, 0xee, 0xbc,
	0xf7, 0xbe, 0xef, 0xbd, 0x99, 0xf7, 0xde, 0xbc, 0x15, 0x2c, 0xd4, 0xb1, 0x9d, 0x24, 0x34, 0x65,
	0x17, 0x0f, 0x71, 0x45, 0x4f, 0xd5, 0x09, 0xfe, 0xd4, 0x4e, 0x15, 0x69, 0xa5, 0x42, 0xcd, 0xbc,
	0x49, 0x0d, 0x9c, 0x72, 0x7e, 0xf2, 0xec, 0xb8, 0x8a, 0xed, 0x64, 0xd5, 0xa2, 0x8c, 0x4a, 0x33,
	0xae, 0x45, 0xd2, 0xb5, 0x48, 0x72, 0x8b, 0x64, 0x97, 0xc5, 0xf4, 0x7c, 0x89, 0xb0, 0xc3, 0x5a,
	0xc1, 0x59, 0x4b, 0x95, 0x68, 0x89, 0xa6, 0xb8, 0x5d, 0xa1, 0x76, 0xc0, 0xdf, 0xf8, 0x0b, 0x7f,
	0x72, 0xf1, 0xa6, 0x67, 0x7a, 0x3d, 0x38, 0x28, 0x63, 0xcc, 0x52, 0x5d, 0x84, 0xd3, 0x93, 0xbd,
	0x0a, 0x26, 0x66, 0x9e, 0xe0, 0xfe, 0x80, 0xe0, 0x53, 0x6a, 0x1d, 0xe5, 0x89, 0xc9, 0xb0, 0x75,
	0xa0, 0x17, 0x71, 0x0f, 0xca, 0xcd, 0x5e, 0x65, 0x5a, 0x65, 0x84, 0x9a, 0x2d, 0xe1, 0x54, 0xaf,
	0xb0, 0xdb, 0xee, 0x56, 0xdf, 0x06, 0xe9, 0x65, 0x62, 0xe8, 0x0c, 0x7b, 0xd2, 0xf8, 0xe0, 0xf6,
	0xe5, 0x7b, 0xa1, 0x67, 0xce, 0xdb, 0xe0, 0x2e, 0x82, 0x59, 0x06, 0x13, 0x0f, 0xd9, 0x21, 0xb6,
	0x4c, 0xcc, 0x72, 0x2d, 0xcf, 0x3f, 0x3a, 0xae, 0x62, 0x69, 0x15, 0x82, 0x06, 0xae, 0x93, 0x22,
	0x96, 0x51, 0x1c, 0xcd, 0x0d, 0x67, 0xdf, 0xfb, 0x4f, 0x03, 0xf9, 0xbe, 0x3a, 0x41, 0x61, 0xd1,
	0xbf, 0x80, 0xd6, 0x44, 0x0b, 0x97, 0x88, 0xcd, 0xb0, 0xf5, 0xd5, 0x77, 0xa7, 0x81, 0xa0, 0x25,
	0x44, 0x90, 0xfc, 0x81, 0xe6, 0x19, 0x48, 0x71, 0x08, 0x54, 0xf4, 0xa2, 0xec, 0xe7, 0x76, 0x61,
	0x6e, 0xf7, 0xdd, 0x69, 0x60, 0xc8, 0x0a, 0xfc, 0x15, 0x21, 0xcd, 0x11, 0xcd, 0xd6, 0x20, 0xfa,
	0xb4, 0xac, 0x9b, 0xff, 0x37, 0xc6, 0x1f, 0x41, 0xa8, 0x5e, 0xd6, 0xcd, 0x3c, 0x31, 0x38, 0xeb,
	0x68, 0xf6, 0x9a, 0xa3, 0x15, 0x4a, 0x0c, 0xc9, 0x3f, 0xcc, 0xcc, 0x21, 0x2d, 0xe8, 0x08, 0x73,
	0xc6, 0xec, 0x6b, 0x3f, 0x44, 0x1f, 0xb9, 0xe7, 0xb4, 0x8f, 0xcb, 0xb8, 0xc8, 0x38, 0xef, 0x26,
	0x48, 0x36, 0x61, 0x38, 0x5f, 0xa6, 0x45, 0xbd, 0x9c, 0xf7, 0xce, 0x91, 0xe3, 0x8c, 0xa8, 0xd7,
	0x93, 0xbd, 0xf9, 0xf6, 0xb0, 0x52, 0x65, 0xc7, 0x5b, 0x3e, 0x2d, 0xe2, 0x58, 0xec, 0x38, 0x06,
	0x1e, 0x9e, 0xf4, 0x04, 0xa6, 0xba, 0x50, 0x88, 0x69, 0x13, 0x03, 0xb7, 0xc1, 0x02, 0x17, 0x82,
	0xdd, 0x68, 0x83, 0xe5, 0xb8, 0x59, 0x0b, 0xf2, 0x73, 0x04, 0x63, 0x36, 0x2e, 0x55, 0xb0, 0xc9,
	0xda, 0x48, 0x02, 0x47, 0x9a, 0x4d, 0x9e, 0x57, 0x06, 0x8f, 0x0b, 0xbf, 0xc2, 0x45, 0xa6, 0xe1,
	0x03, 0x27, 0xac, 0xec, 0xf2, 0x97, 0x9f, 0x85, 0x3c, 0xeb, 0x2f, 0x4f, 0xd0, 0x64, 0xe2, 0x9a,
	0x4d, 0x0f, 0x58, 0x41, 0x37, 0x8f, 0xf2, 0x15, 0x5c, 0x4c, 0x84, 0x0e, 0xb0, 0x61, 0xe9, 0x95,
	0x2a, 0xdf, 0x5f, 0x34, 0x87, 0x16, 0xd0, 0x5a, 0xb0, 0x48, 0xcd, 0x03, 0x52, 0xda, 0xf2, 0x69,
	0x61, 0xcf, 0xce, 0x73, 0x24, 0xfb, 0x3e, 0x84, 0x5b, 0xe9, 0x5d, 0x3c, 0xa4, 0xce, 0x86, 0x47,
	0x4f, 0x1b, 0xc8, 0x7f, 0xd6, 0x40, 0xa8, 0xd9, 0x40, 0x43, 0xaa, 0x92, 0x51, 0x16, 0xb7, 0x05,
	0x11, 0x45, 0xfc, 0xb3, 0xff, 0x9e, 0x80, 0xe1, 0xf6, 0xb1, 0x4a, 0x0a, 0x8c, 0x18, 0xd8, 0x2e,
	0x5a, 0x84, 0x27, 0xa5, 0x77, 0xae, 0xe0, 0x65, 0x83, 0xfc, 0xdc, 0xaf, 0x75, 0x8b, 0xa5, 0xdf,
	0x23, 0x08, 0x96, 0xf5, 0x02, 0x2e, 0xdb, 0xb2, 0x3f, 0x1e, 0x98, 0x1b, 0x51, 0x97, 0x92, 0x97,
	0x54, 0x7b, 0xb2, 0x4d, 0x95, 0xdc, 0xe1, 0x86, 0x0f, 0x4d, 0x66, 0x1d, 0x67, 0x7f, 0xf2, 0xf2,
	0x04, 0x09, 0xe0, 0x77, 0xf3, 0x6e, 0xe4, 0x25, 0x12, 0x67, 0xbd, 0x84, 0xe1, 0xcc, 0x2f, 0x91,
	0x3f, 0x12, 0x69, 0x49, 0x12, 0x9e, 0xa4, 0xf9, 0xfa, 0x6f, 0x81, 0xe0, 0x8b, 0x13, 0xe4, 0x17,
	0x7d, 0x9a, 0xe7, 0x84, 0x54, 0x02, 0x09, 0x7b, 0xb5, 0xd1, 0x29, 0x6b, 0xef, 0x04, 0x2e, 0x77,
	0xed, 0xdc, 0xb2, 0xda, 0xf2, 0x69, 0x51, 0xdc, 0x2f, 0x90, 0x7e, 0x01, 0x61, 0x37, 0x7d, 0xdb,
	0x24, 0x43, 0x9c, 0x44, 0xbd, 0x94, 0x64, 0xa0, 0x8a, 0xb6, 0x7c, 0xda, 0x68, 0xbd, 0x7b, 0x51,
	0x7a, 0x02, 0xe1, 0x02, 0x35, 0x8d, 0x2e, 0xf0, 0x20, 0x07, 0x9f, 0xeb, 0x03, 0xe7, 0xad, 0x2f,
	0xf9, 0xa1, 0xf3, 0x9b, 0xa5, 0xa6, 0xb1, 0xc9, 0x2b, 0xab, 0x05, 0xe9, 0x20, 0x74, 0x20, 0x97,
	0x61, 0xc4, 0x38, 0x2c, 0x56, 0xf3, 0xc5, 0x32, 0xc1, 0x26, 0x93, 0xc5, 0x0b, 0xb2, 0x1b, 0x69,
	0xe0, 0xa8, 0x6e, 0x70, 0x4d, 0xe9, 0x19, 0x0c, 0xdb, 0x4c, 0x67, 0xa4, 0x98, 0x27, 0x55, 0x79,
	0x98, 0x9b, 0xfd, 0xb8, 0xcf, 0x6c, 0xa0, 0x8f, 0x26, 0xf7, 0xb9, 0x45, 0xae, 0xba, 0xa7, 0x5b,
	0x7a, 0x05, 0x33, 0x6c, 0xd9, 0x8f, 0xa8, 0xe1, 0x7a, 0x86, 0x34, 0xd1, 0xf6, 0xa4, 0xd2, 0x2f,
	0x3d, 0xa7, 0x6c, 0x6c, 0xd5, 0xb1, 0x25, 0xdf, 0xe4, 0xe8, 0xab, 0x97, 0xa2, 0x6f, 0x6e, 0x6d,
	0xec, 0xed, 0x73, 0x93, 0x0e, 0xbe, 0x87, 0xcd, 0x3d, 0x77, 0x65, 0xd2, 0x4f, 0x61, 0xcc, 0xa4,
	0x79, 0x52, 0xad, 0x2f, 0xe6, 0x75, 0xc3, 0xb0, 0xb0, 0x6d, 0xcb, 0xf1, 0x0b, 0xc3, 0x1e, 0x35,
	0x69, 0xae, 0x5a, 0x5f, 0x5c, 0x77, 0x95, 0xa5, 0x18, 0x08, 0xa6, 0x5e, 0xc1, 0x32, 0x0c, 0x94,
	0x00, 0x5f, 0x97, 0x92, 0x10, 0xa8, 0xb0, 0x9a, 0x3c, 0xc2, 0xbb, 0xd7, 0xad, 0x7f, 0x34, 0x90,
	0x90, 0x7e, 0xb0, 0xb0, 0xe0, 0xa8, 0x8d, 0x25, 0x46, 0xb3, 0x23, 0x0b, 0xca, 0x83, 0xb4, 0x3a,
	0x9f, 0x5e, 0xca, 0xac, 0x2c, 0x6a, 0x8e, 0xa2, 0x94, 0xef, 0x94, 0xa4, 0xdb, 0xf1, 0xe5, 0x6b,
	0x57, 0x4c, 0x99, 0x81, 0x06, 0x98, 0x15, 0xfe, 0x72, 0x82, 0x1c, 0x87, 0x5d, 0xc1, 0x63, 0xb7,
	0x18, 0xd7, 0x21, 0x52, 0xa1, 0x26, 0x61, 0xd4, 0xca, 0x1b, 0xc4, 0xd6, 0x0b, 0x65, 0x6c, 0xc8,
	0xd1, 0x0b, 0x22, 0xf6, 0x6b, 0x63, 0x9e, 0xfe, 0xa6, 0xa7, 0x2e, 0x7d, 0x0c, 0x21, 0x6f, 0x49,
	0x96, 0xae, 0x78, 0x1a, 0x3b, 0xc4, 0x3c, 0x7a, 0x52, 0xd3, 0xcb, 0x84, 0x1d, 0xef, 0xba, 0xa6,
	0x1b, 0x6e, 0x53, 0xf2, 0x6b, 0x2d, 0x2c, 0xe9, 0x0e, 0x88, 0x55, 0x8b, 0x50, 0x8b, 0xb0, 0x63,
	0x79, 0x9c, 0xef, 0x97, 0xbb, 0x9d, 0x89, 0x80, 0xfc, 0x03, 0xd2, 0xda, 0x32, 0xa9, 0x06, 0x0a,
	0xef, 0xc8, 0x8c, 0xe6, 0xf9, 0xdf, 0x22, 0x35, 0x4d, 0x5c, 0x64, 0xa4, 0x4e, 0xd8, 0x71, 0x87,
	0xb2, 0x13, 0xdd, 0xc4, 0x05, 0xd1, 0x05, 0xb4, 0xbb, 0x0e, 0xc6, 0x47, 0x74, 0x9f, 0x30, 0xbc,
	0xd1, 0x05, 0xd4, 0x2e, 0x8a, 0x76, 0xd4, 0x36, 0xdc, 0xbf, 0x0a, 0x2d, 0x36, 0x5d, 0xd6, 0x1b,
	0x17, 0xb2, 0xde, 0xb9, 0x84, 0xf5, 0xa1, 0x8b, 0x22, 0xbd, 0x0f, 0x40, 0xec, 0x7c, 0xd5, 0x22,
	0x15, 0xdd, 0x3a, 0x96, 0x27, 0xe3, 0x68, 0x4e, 0xcc, 0x0a, 0xdf, 0x36, 0x10, 0xd2, 0x86, 0x89,
	0xbd, 0xe7, 0x2e, 0x4b, 0xf7, 0x60, 0x94, 0xd8, 0xf9, 0x8a, 0x6e, 0xea, 0x25, 0xec, 0xb4, 0x77,
	0x79, 0xba, 0x4b, 0xef, 0x1a, 0xb1, 0x77, 0xdb, 0x92, 0x4e, 0xba, 0x2f, 0xb5, 0xd3, 0xfd, 0xf6,
	0x05, 0x8e, 0x0a, 0x5e, 0xba, 0x2f, 0xb5, 0xd2, 0x9d, 0xc0, 0x78, 0xbb, 0xd0, 0xbb, 0x30, 0x62,
	0x1c, 0x63, 0xf9, 0xaa, 0x25, 0xbf, 0xd7, 0x57, 0x92, 0x82, 0x16, 0x6d, 0x95, 0x7b, 0x87, 0xea,
	0x77, 0x08, 0x22, 0x2e, 0x49, 0x8d, 0xd1, 0xbc, 0x7b, 0x87, 0xc9, 0x33, 0x9c, 0x28, 0x73, 0x29,
	0x51, 0x6e, 0xef, 0xe9, 0xd2, 0x7a, 0x8d, 0x51, 0x37, 0xcb, 0x78, 0x35, 0xdc, 0xff, 0xd7, 0x67,
	0x73, 0x06, 0xae, 0xd0, 0xb4, 0xc2, 0xb0, 0xcd, 0x94, 0xa2, 0xc5, 0x14, 0x9b, 0xe9, 0x25, 0x62,
	0x96, 0x94, 0xee, 0x1b, 0x54, 0xa9, 0x5a, 0xd4, 0xd8, 0x12, 0xb4, 0xb0, 0xc3, 0xdd, 0x81, 0x98,
	0x5e, 0x85, 0x91, 0xae, 0xab, 0x48, 0x8a, 0x40, 0xe0, 0x08, 0x1f, 0xbb, 0x37, 0x9f, 0xe6, 0x3c,
	0x4a, 0xd7, 0x61, 0xa8, 0xae, 0x97, 0x6b, 0xd8, 0x9d, 0x8f, 0x34, 0xf7, 0x65, 0xcd, 0xbf, 0x82,
	0xd6, 0x7e, 0x33, 0xf4, 0x75, 0x03, 0x59, 0x20, 0x81, 0xb8, 0x8b, 0x99, 0x6e, 0xe8, 0x4c, 0x97,
	0x82, 0xe9, 0x05, 0x25, 0xad, 0xa8, 0x30, 0x05, 0xd7, 0xdd, 0x86, 0x1c, 0x77, 0x69, 0x6a, 0x96,
	0xce, 0xab, 0x14, 0x65, 0x40, 0x86, 0x48, 0x6e, 0xaf, 0x6f, 0x59, 0x58, 0x56, 0xd4, 0x15, 0xb8,
	0x0b, 0x52, 0x3b, 0x51, 0xe2, 0xfb, 0x98, 0x31, 0x62, 0x96, 0x6c, 0x29, 0x9a, 0x56, 0x95, 0x74,
	0x5a, 0x49, 0x2f, 0x29, 0xe9, 0x55, 0x45, 0x5d, 0x50, 0xd4, 0xcc, 0x37, 0x0d, 0xf4, 0x42, 0x80,
	0x30, 0x08, 0x8f, 0xf4, 0x0a, 0x9e, 0x0e, 0xba, 0x9d, 0x0a, 0x9e, 0x81, 0xe0, 0xec, 0x47, 0x42,
	0x83, 0x3d, 0x88, 0x9d, 0x77, 0x13, 0xaa, 0x62, 0xeb, 0x8a, 0x83, 0x1b, 0xfd, 0x17, 0x98, 0x2a,
	0x3c, 0xdd, 0x59, 0x7f, 0xe4, 0xac, 0xf7, 0xde, 0x3d, 0xaa, 0xe0, 0xdc, 0x2d, 0xf0, 0x73, 0x08,
	0xba, 0xe1, 0x24, 0x1e, 0xc3, 0x2e, 0xdc, 0x84, 0xa9, 0x41, 0xf4, 0xa4, 0x3b, 0xda, 0xc1, 0x24,
	0x4c, 0xf4, 0x42, 0xb7, 0x04, 0x13, 0x30, 0xde, 0x8b, 0x9d, 0xe4, 0x6e, 0xef, 0x42, 0x60, 0x77,
	0x7d, 0x23, 0xf1, 0x21, 0x6c, 0x82, 0x0c, 0x37, 0xce, 0xc1, 0xad, 0xe8, 0x45, 0x18, 0x1f, 0xf0,
	0x17, 0xcd, 0x3b, 0x8b, 0x7d, 0xce, 0xa2, 0x79, 0xd0, 0x80, 0x47, 0x92, 0xd8, 0x86, 0x2d, 0x07,
	0xaf, 0xcf, 0x15, 0x6f, 0xe8, 0x84, 0xc9, 0x73, 0xf7, 0xe7, 0x5d, 0x98, 0x7f, 0x42, 0x30, 0xf6,
	0x94, 0x58, 0xac, 0xa6, 0x97, 0xe3, 0x5e, 0x37, 0x4e, 0xfc, 0x16, 0xc1, 0xe7, 0x08, 0xe6, 0xe0,
	0xbd, 0xde, 0xae, 0x9e, 0x1c, 0x9c, 0x4c, 0xd5, 0xc0, 0xfe, 0xce, 0x63, 0x48, 0xc1, 0xdc, 0xbb,
	0x35, 0x7b, 0xa7, 0x4f, 0xc7, 0x20, 0x07, 0xf7, 0x20, 0xd6, 0x6f, 0xd0, 0x3b, 0x5a, 0xaa, 0xa1,
	0x7d, 0x77, 0x21, 0x7b, 0x0f, 0x22, 0x9d, 0x3e, 0xe5, 0x0d, 0x7c, 0x13, 0xa7, 0x0d, 0x24, 0x9c,
	0x35, 0x50, 0xc0, 0x19, 0xf8, 0x16, 0x95, 0x07, 0xca, 0x92, 0xd3, 0x35, 0xb2, 0x77, 0x21, 0xec,
	0xd5, 0x76, 0xb7, 0xa2, 0x78, 0xd6, 0x40, 0xa1, 0x66, 0x03, 0x0d, 0xaf, 0x28, 0xab, 0x8a, 0xba,
	0xac, 0x64, 0xd4, 0xec, 0x1d, 0x88, 0x7a, 0xfd, 0x9b, 0x98, 0xa5, 0xee, 0x29, 0x32, 0x7a, 0xd6,
	0x40, 0x11, 0x07, 0x34, 0xbd, 0xac, 0xa4, 0x57, 0xb2, 0x3f, 0x83, 0xc4, 0x55, 0xba, 0x67, 0x17,
	0xc0, 0xc4, 0x59, 0x03, 0x5d, 0xe7, 0x63, 0x68, 0x5a, 0x51, 0xd5, 0xec, 0x27, 0x30, 0xde, 0xdd,
	0x72, 0x5a, 0x9a, 0x1f, 0x9c, 0x36, 0xd0, 0xed, 0xb3, 0x06, 0xba, 0xd5, 0x6c, 0x20, 0x51, 0x5d,
	0x55, 0x32, 0x0b, 0x4a, 0x26, 0xfd, 0xe2, 0xbf, 0xe8, 0xca, 0xa5, 0xbe, 0x2d, 0x88, 0x81, 0x88,
	0xb0, 0x2d, 0x88, 0xa1, 0x88, 0xb8, 0x2d, 0x88, 0x91, 0x48, 0x74, 0x5b, 0x10, 0xaf, 0x47, 0x26,
	0xb6, 0x05, 0xf1, 0x56, 0xe4, 0xf6, 0xec, 0x3f, 0xfd, 0x20, 0x38, 0x63, 0x89, 0xa4, 0x80, 0xe0,
	0x7c, 0x5f, 0x79, 0xb3, 0xae, 0xec, 0xdc, 0x4c, 0xe3, 0x56, 0x54, 0x0b, 0x6d, 0x50, 0x93, 0x59,
	0xb4, 0xac, 0x05, 0x3f, 0xa1, 0xd6, 0x11, 0xb6, 0x34, 0xae, 0xe5, 0xdc, 0x65, 0x87, 0xd4, 0x66,
	0x7c, 0x34, 0x08, 0x0c, 0x8c, 0x06, 0x6d, 0x99, 0x74, 0x17, 0x86, 0xab, 0xb5, 0x42, 0xd9, 0x1d,
	0x9c, 0x82, 0x83, 0x8a, 0xae, 0x30, 0x57, 0x95, 0x0e, 0x21, 0xdc, 0xd9, 0xa5, 0x32, 0xb1, 0x99,
	0x1c, 0xe2, 0xa3, 0x74, 0xe2, 0xea, 0xa3, 0x74, 0x76, 0x82, 0x7f, 0x62, 0x7d, 0x81, 0x02, 0x91,
	0xe7, 0x88, 0x93, 0x7c, 0x81, 0xfc, 0x32, 0xd2, 0x46, 0xdb, 0xc0, 0x3b, 0xc4, 0x66, 0x6b, 0xf5,
	0xaf, 0x1b, 0x48, 0x81, 0x29, 0x88, 0x38, 0x61, 0xc7, 0x73, 0xe6, 0x01, 0xb5, 0x2a, 0x6e, 0xf7,
	0x19, 0xca, 0x28, 0x69, 0x65, 0x09, 0xc6, 0x00, 0xda, 0x98, 0xb6, 0x84, 0x96, 0xbf, 0x69, 0xa0,
	0x2c, 0xdc, 0x00, 0x71, 0xcb, 0x0b, 0x6a, 0x1a, 0x3a, 0xc1, 0x3b, 0xdd, 0xc7, 0xe9, 0x36, 0x4e,
	0xf7, 0x71, 0x36, 0x06, 0x64, 0x18, 0xde, 0xe3, 0x31, 0xc5, 0x73, 0x7b, 0xd3, 0x23, 0x5d, 0xd1,
	0x67, 0xff, 0x88, 0xce, 0xde, 0xc4, 0x7c, 0xaf, 0xde, 0xc4, 0x7c, 0xdf, 0xbf, 0x89, 0xa1, 0xe7,
	0xcd, 0x18, 0xfa, 0x73, 0x33, 0x86, 0xfe, 0xde, 0x8c, 0xa1, 0xb3, 0x66, 0x0c, 0xbd, 0x6a, 0xc6,
	0xd0, 0xeb, 0x66, 0x0c, 0x7d, 0xdb, 0x8c, 0xf9, 0xbe, 0x6f, 0xc6, 0xd0, 0x1f, 0xde, 0xc6, 0x7c,
	0xa7, 0x6f, 0x63, 0xe8, 0xec, 0x6d, 0xcc, 0xf7, 0xea, 0x6d, 0xcc, 0xf7, 0xec, 0xe3, 0x12, 0xad,
	0x1e, 0x95, 0x92, 0x75, 0x5a, 0x66, 0xd8, 0xb2, 0xf4, 0x64, 0xcd, 0x4e, 0xf1, 0x07, 0xc7, 0xfd,
	0xf9, 0xaa, 0x45, 0xeb, 0xc4, 0xc0, 0xd6, 0x7c, 0x4b, 0x9c, 0xaa, 0x16, 0x4a, 0x34, 0x85, 0x7f,
	0xcd, 0xbc, 0x0f, 0xe8, 0x77, 0xfd, 0xa3, 0xa2, 0x10, 0xe4, 0x9f, 0xd3, 0x99, 0xff, 0x05, 0x00,
	0x00, 0xff, 0xff, 0x6a, 0xb6, 0xf2, 0x4b, 0xd2, 0x10, 0x00, 0x00,
}

func (this *EthernetInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType)
	if !ok {
		that2, ok := that.(EthernetInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if this.Mac != that1.Mac {
		return false
	}
	return true
}
func (this *VlanInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VlanInterfaceType)
	if !ok {
		that2, ok := that.(VlanInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if this.VlanId != that1.VlanId {
		return false
	}
	return true
}
func (this *NetworkSelectType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSelectType)
	if !ok {
		that2, ok := that.(NetworkSelectType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NetworkChoice == nil {
		if this.NetworkChoice != nil {
			return false
		}
	} else if this.NetworkChoice == nil {
		return false
	} else if !this.NetworkChoice.Equal(that1.NetworkChoice) {
		return false
	}
	return true
}
func (this *NetworkSelectType_SiteLocalNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSelectType_SiteLocalNetwork)
	if !ok {
		that2, ok := that.(NetworkSelectType_SiteLocalNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalNetwork.Equal(that1.SiteLocalNetwork) {
		return false
	}
	return true
}
func (this *NetworkSelectType_SiteLocalInsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSelectType_SiteLocalInsideNetwork)
	if !ok {
		that2, ok := that.(NetworkSelectType_SiteLocalInsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInsideNetwork.Equal(that1.SiteLocalInsideNetwork) {
		return false
	}
	return true
}
func (this *NetworkSelectType_SegmentNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSelectType_SegmentNetwork)
	if !ok {
		that2, ok := that.(NetworkSelectType_SegmentNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SegmentNetwork.Equal(that1.SegmentNetwork) {
		return false
	}
	return true
}
func (this *Interface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface)
	if !ok {
		that2, ok := that.(Interface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	if that1.AddressChoice == nil {
		if this.AddressChoice != nil {
			return false
		}
	} else if this.AddressChoice == nil {
		return false
	} else if !this.AddressChoice.Equal(that1.AddressChoice) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if !this.NetworkOption.Equal(that1.NetworkOption) {
		return false
	}
	if that1.MonitoringChoice == nil {
		if this.MonitoringChoice != nil {
			return false
		}
	} else if this.MonitoringChoice == nil {
		return false
	} else if !this.MonitoringChoice.Equal(that1.MonitoringChoice) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if that1.SiteToSiteConnectivityInterfaceChoice == nil {
		if this.SiteToSiteConnectivityInterfaceChoice != nil {
			return false
		}
	} else if this.SiteToSiteConnectivityInterfaceChoice == nil {
		return false
	} else if !this.SiteToSiteConnectivityInterfaceChoice.Equal(that1.SiteToSiteConnectivityInterfaceChoice) {
		return false
	}
	if this.IsPrimary != that1.IsPrimary {
		return false
	}
	if this.IsManagement != that1.IsManagement {
		return false
	}
	if that1.Ipv6AddressChoice == nil {
		if this.Ipv6AddressChoice != nil {
			return false
		}
	} else if this.Ipv6AddressChoice == nil {
		return false
	} else if !this.Ipv6AddressChoice.Equal(that1.Ipv6AddressChoice) {
		return false
	}
	return true
}
func (this *Interface_EthernetInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_EthernetInterface)
	if !ok {
		that2, ok := that.(Interface_EthernetInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EthernetInterface.Equal(that1.EthernetInterface) {
		return false
	}
	return true
}
func (this *Interface_VlanInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_VlanInterface)
	if !ok {
		that2, ok := that.(Interface_VlanInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VlanInterface.Equal(that1.VlanInterface) {
		return false
	}
	return true
}
func (this *Interface_BondInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_BondInterface)
	if !ok {
		that2, ok := that.(Interface_BondInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BondInterface.Equal(that1.BondInterface) {
		return false
	}
	return true
}
func (this *Interface_DhcpClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_DhcpClient)
	if !ok {
		that2, ok := that.(Interface_DhcpClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhcpClient.Equal(that1.DhcpClient) {
		return false
	}
	return true
}
func (this *Interface_StaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_StaticIp)
	if !ok {
		that2, ok := that.(Interface_StaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StaticIp.Equal(that1.StaticIp) {
		return false
	}
	return true
}
func (this *Interface_DhcpServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_DhcpServer)
	if !ok {
		that2, ok := that.(Interface_DhcpServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhcpServer.Equal(that1.DhcpServer) {
		return false
	}
	return true
}
func (this *Interface_NoIpv4Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_NoIpv4Address)
	if !ok {
		that2, ok := that.(Interface_NoIpv4Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoIpv4Address.Equal(that1.NoIpv4Address) {
		return false
	}
	return true
}
func (this *Interface_MonitorDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_MonitorDisabled)
	if !ok {
		that2, ok := that.(Interface_MonitorDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MonitorDisabled.Equal(that1.MonitorDisabled) {
		return false
	}
	return true
}
func (this *Interface_Monitor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_Monitor)
	if !ok {
		that2, ok := that.(Interface_Monitor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	return true
}
func (this *Interface_SiteToSiteConnectivityInterfaceDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_SiteToSiteConnectivityInterfaceDisabled)
	if !ok {
		that2, ok := that.(Interface_SiteToSiteConnectivityInterfaceDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteToSiteConnectivityInterfaceDisabled.Equal(that1.SiteToSiteConnectivityInterfaceDisabled) {
		return false
	}
	return true
}
func (this *Interface_SiteToSiteConnectivityInterfaceEnabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_SiteToSiteConnectivityInterfaceEnabled)
	if !ok {
		that2, ok := that.(Interface_SiteToSiteConnectivityInterfaceEnabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteToSiteConnectivityInterfaceEnabled.Equal(that1.SiteToSiteConnectivityInterfaceEnabled) {
		return false
	}
	return true
}
func (this *Interface_NoIpv6Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_NoIpv6Address)
	if !ok {
		that2, ok := that.(Interface_NoIpv6Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoIpv6Address.Equal(that1.NoIpv6Address) {
		return false
	}
	return true
}
func (this *Interface_StaticIpv6Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_StaticIpv6Address)
	if !ok {
		that2, ok := that.(Interface_StaticIpv6Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StaticIpv6Address.Equal(that1.StaticIpv6Address) {
		return false
	}
	return true
}
func (this *Interface_Ipv6AutoConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Interface_Ipv6AutoConfig)
	if !ok {
		that2, ok := that.(Interface_Ipv6AutoConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv6AutoConfig.Equal(that1.Ipv6AutoConfig) {
		return false
	}
	return true
}
func (this *Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node)
	if !ok {
		that2, ok := that.(Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.PublicIp != that1.PublicIp {
		return false
	}
	if len(this.InterfaceList) != len(that1.InterfaceList) {
		return false
	}
	for i := range this.InterfaceList {
		if !this.InterfaceList[i].Equal(that1.InterfaceList[i]) {
			return false
		}
	}
	return true
}
func (this *EthernetInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&common_node.EthernetInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	s = append(s, "Mac: "+fmt.Sprintf("%#v", this.Mac)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VlanInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&common_node.VlanInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	s = append(s, "VlanId: "+fmt.Sprintf("%#v", this.VlanId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkSelectType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&common_node.NetworkSelectType{")
	if this.NetworkChoice != nil {
		s = append(s, "NetworkChoice: "+fmt.Sprintf("%#v", this.NetworkChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkSelectType_SiteLocalNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.NetworkSelectType_SiteLocalNetwork{` +
		`SiteLocalNetwork:` + fmt.Sprintf("%#v", this.SiteLocalNetwork) + `}`}, ", ")
	return s
}
func (this *NetworkSelectType_SiteLocalInsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.NetworkSelectType_SiteLocalInsideNetwork{` +
		`SiteLocalInsideNetwork:` + fmt.Sprintf("%#v", this.SiteLocalInsideNetwork) + `}`}, ", ")
	return s
}
func (this *NetworkSelectType_SegmentNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.NetworkSelectType_SegmentNetwork{` +
		`SegmentNetwork:` + fmt.Sprintf("%#v", this.SegmentNetwork) + `}`}, ", ")
	return s
}
func (this *Interface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 26)
	s = append(s, "&common_node.Interface{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	if this.AddressChoice != nil {
		s = append(s, "AddressChoice: "+fmt.Sprintf("%#v", this.AddressChoice)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	if this.NetworkOption != nil {
		s = append(s, "NetworkOption: "+fmt.Sprintf("%#v", this.NetworkOption)+",\n")
	}
	if this.MonitoringChoice != nil {
		s = append(s, "MonitoringChoice: "+fmt.Sprintf("%#v", this.MonitoringChoice)+",\n")
	}
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.SiteToSiteConnectivityInterfaceChoice != nil {
		s = append(s, "SiteToSiteConnectivityInterfaceChoice: "+fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceChoice)+",\n")
	}
	s = append(s, "IsPrimary: "+fmt.Sprintf("%#v", this.IsPrimary)+",\n")
	s = append(s, "IsManagement: "+fmt.Sprintf("%#v", this.IsManagement)+",\n")
	if this.Ipv6AddressChoice != nil {
		s = append(s, "Ipv6AddressChoice: "+fmt.Sprintf("%#v", this.Ipv6AddressChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Interface_EthernetInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_EthernetInterface{` +
		`EthernetInterface:` + fmt.Sprintf("%#v", this.EthernetInterface) + `}`}, ", ")
	return s
}
func (this *Interface_VlanInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_VlanInterface{` +
		`VlanInterface:` + fmt.Sprintf("%#v", this.VlanInterface) + `}`}, ", ")
	return s
}
func (this *Interface_BondInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_BondInterface{` +
		`BondInterface:` + fmt.Sprintf("%#v", this.BondInterface) + `}`}, ", ")
	return s
}
func (this *Interface_DhcpClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_DhcpClient{` +
		`DhcpClient:` + fmt.Sprintf("%#v", this.DhcpClient) + `}`}, ", ")
	return s
}
func (this *Interface_StaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_StaticIp{` +
		`StaticIp:` + fmt.Sprintf("%#v", this.StaticIp) + `}`}, ", ")
	return s
}
func (this *Interface_DhcpServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_DhcpServer{` +
		`DhcpServer:` + fmt.Sprintf("%#v", this.DhcpServer) + `}`}, ", ")
	return s
}
func (this *Interface_NoIpv4Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_NoIpv4Address{` +
		`NoIpv4Address:` + fmt.Sprintf("%#v", this.NoIpv4Address) + `}`}, ", ")
	return s
}
func (this *Interface_MonitorDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_MonitorDisabled{` +
		`MonitorDisabled:` + fmt.Sprintf("%#v", this.MonitorDisabled) + `}`}, ", ")
	return s
}
func (this *Interface_Monitor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_Monitor{` +
		`Monitor:` + fmt.Sprintf("%#v", this.Monitor) + `}`}, ", ")
	return s
}
func (this *Interface_SiteToSiteConnectivityInterfaceDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_SiteToSiteConnectivityInterfaceDisabled{` +
		`SiteToSiteConnectivityInterfaceDisabled:` + fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceDisabled) + `}`}, ", ")
	return s
}
func (this *Interface_SiteToSiteConnectivityInterfaceEnabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_SiteToSiteConnectivityInterfaceEnabled{` +
		`SiteToSiteConnectivityInterfaceEnabled:` + fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceEnabled) + `}`}, ", ")
	return s
}
func (this *Interface_NoIpv6Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_NoIpv6Address{` +
		`NoIpv6Address:` + fmt.Sprintf("%#v", this.NoIpv6Address) + `}`}, ", ")
	return s
}
func (this *Interface_StaticIpv6Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_StaticIpv6Address{` +
		`StaticIpv6Address:` + fmt.Sprintf("%#v", this.StaticIpv6Address) + `}`}, ", ")
	return s
}
func (this *Interface_Ipv6AutoConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_node.Interface_Ipv6AutoConfig{` +
		`Ipv6AutoConfig:` + fmt.Sprintf("%#v", this.Ipv6AutoConfig) + `}`}, ", ")
	return s
}
func (this *Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&common_node.Node{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "PublicIp: "+fmt.Sprintf("%#v", this.PublicIp)+",\n")
	if this.InterfaceList != nil {
		s = append(s, "InterfaceList: "+fmt.Sprintf("%#v", this.InterfaceList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringNodeTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *EthernetInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthernetInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintNodeTypes(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintNodeTypes(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VlanInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VlanInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VlanInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VlanId != 0 {
		i = encodeVarintNodeTypes(dAtA, i, uint64(m.VlanId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintNodeTypes(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkSelectType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSelectType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSelectType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NetworkChoice != nil {
		{
			size := m.NetworkChoice.Size()
			i -= size
			if _, err := m.NetworkChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkSelectType_SiteLocalNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSelectType_SiteLocalNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalNetwork != nil {
		{
			size, err := m.SiteLocalNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NetworkSelectType_SiteLocalInsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSelectType_SiteLocalInsideNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalInsideNetwork != nil {
		{
			size, err := m.SiteLocalInsideNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkSelectType_SegmentNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSelectType_SegmentNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SegmentNetwork != nil {
		{
			size, err := m.SegmentNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AddressChoice != nil {
		{
			size := m.AddressChoice.Size()
			i -= size
			if _, err := m.AddressChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Ipv6AddressChoice != nil {
		{
			size := m.Ipv6AddressChoice.Size()
			i -= size
			if _, err := m.Ipv6AddressChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IsManagement {
		i--
		if m.IsManagement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.IsPrimary {
		i--
		if m.IsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.SiteToSiteConnectivityInterfaceChoice != nil {
		{
			size := m.SiteToSiteConnectivityInterfaceChoice.Size()
			i -= size
			if _, err := m.SiteToSiteConnectivityInterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Priority != 0 {
		i = encodeVarintNodeTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.MonitoringChoice != nil {
		{
			size := m.MonitoringChoice.Size()
			i -= size
			if _, err := m.MonitoringChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NetworkOption != nil {
		{
			size, err := m.NetworkOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Mtu != 0 {
		i = encodeVarintNodeTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNodeTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNodeTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintNodeTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintNodeTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNodeTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Interface_EthernetInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_EthernetInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EthernetInterface != nil {
		{
			size, err := m.EthernetInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Interface_VlanInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_VlanInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VlanInterface != nil {
		{
			size, err := m.VlanInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Interface_BondInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_BondInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BondInterface != nil {
		{
			size, err := m.BondInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Interface_DhcpClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_DhcpClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhcpClient != nil {
		{
			size, err := m.DhcpClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Interface_StaticIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_StaticIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StaticIp != nil {
		{
			size, err := m.StaticIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Interface_MonitorDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_MonitorDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MonitorDisabled != nil {
		{
			size, err := m.MonitorDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Interface_Monitor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_Monitor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Monitor != nil {
		{
			size, err := m.Monitor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Interface_SiteToSiteConnectivityInterfaceDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_SiteToSiteConnectivityInterfaceDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteToSiteConnectivityInterfaceDisabled != nil {
		{
			size, err := m.SiteToSiteConnectivityInterfaceDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Interface_SiteToSiteConnectivityInterfaceEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_SiteToSiteConnectivityInterfaceEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteToSiteConnectivityInterfaceEnabled != nil {
		{
			size, err := m.SiteToSiteConnectivityInterfaceEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Interface_DhcpServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_DhcpServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhcpServer != nil {
		{
			size, err := m.DhcpServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *Interface_NoIpv6Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_NoIpv6Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoIpv6Address != nil {
		{
			size, err := m.NoIpv6Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *Interface_StaticIpv6Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_StaticIpv6Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StaticIpv6Address != nil {
		{
			size, err := m.StaticIpv6Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *Interface_Ipv6AutoConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_Ipv6AutoConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv6AutoConfig != nil {
		{
			size, err := m.Ipv6AutoConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *Interface_NoIpv4Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interface_NoIpv4Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoIpv4Address != nil {
		{
			size, err := m.NoIpv4Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNodeTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceList) > 0 {
		for iNdEx := len(m.InterfaceList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNodeTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PublicIp) > 0 {
		i -= len(m.PublicIp)
		copy(dAtA[i:], m.PublicIp)
		i = encodeVarintNodeTypes(dAtA, i, uint64(len(m.PublicIp)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintNodeTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintNodeTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNodeTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovNodeTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EthernetInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	return n
}

func (m *VlanInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	if m.VlanId != 0 {
		n += 1 + sovNodeTypes(uint64(m.VlanId))
	}
	return n
}

func (m *NetworkSelectType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkChoice != nil {
		n += m.NetworkChoice.Size()
	}
	return n
}

func (m *NetworkSelectType_SiteLocalNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalNetwork != nil {
		l = m.SiteLocalNetwork.Size()
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *NetworkSelectType_SiteLocalInsideNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalInsideNetwork != nil {
		l = m.SiteLocalInsideNetwork.Size()
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *NetworkSelectType_SegmentNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SegmentNetwork != nil {
		l = m.SegmentNetwork.Size()
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNodeTypes(uint64(len(k))) + 1 + len(v) + sovNodeTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovNodeTypes(uint64(mapEntrySize))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if m.AddressChoice != nil {
		n += m.AddressChoice.Size()
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	if m.Mtu != 0 {
		n += 1 + sovNodeTypes(uint64(m.Mtu))
	}
	if m.NetworkOption != nil {
		l = m.NetworkOption.Size()
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	if m.MonitoringChoice != nil {
		n += m.MonitoringChoice.Size()
	}
	if m.Priority != 0 {
		n += 2 + sovNodeTypes(uint64(m.Priority))
	}
	if m.SiteToSiteConnectivityInterfaceChoice != nil {
		n += m.SiteToSiteConnectivityInterfaceChoice.Size()
	}
	if m.IsPrimary {
		n += 3
	}
	if m.IsManagement {
		n += 3
	}
	if m.Ipv6AddressChoice != nil {
		n += m.Ipv6AddressChoice.Size()
	}
	return n
}

func (m *Interface_EthernetInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EthernetInterface != nil {
		l = m.EthernetInterface.Size()
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_VlanInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VlanInterface != nil {
		l = m.VlanInterface.Size()
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_BondInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BondInterface != nil {
		l = m.BondInterface.Size()
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_DhcpClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhcpClient != nil {
		l = m.DhcpClient.Size()
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_StaticIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaticIp != nil {
		l = m.StaticIp.Size()
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_MonitorDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonitorDisabled != nil {
		l = m.MonitorDisabled.Size()
		n += 2 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_Monitor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Monitor != nil {
		l = m.Monitor.Size()
		n += 2 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_SiteToSiteConnectivityInterfaceDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceDisabled != nil {
		l = m.SiteToSiteConnectivityInterfaceDisabled.Size()
		n += 2 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_SiteToSiteConnectivityInterfaceEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceEnabled != nil {
		l = m.SiteToSiteConnectivityInterfaceEnabled.Size()
		n += 2 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_DhcpServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhcpServer != nil {
		l = m.DhcpServer.Size()
		n += 2 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_NoIpv6Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoIpv6Address != nil {
		l = m.NoIpv6Address.Size()
		n += 2 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_StaticIpv6Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaticIpv6Address != nil {
		l = m.StaticIpv6Address.Size()
		n += 2 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_Ipv6AutoConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv6AutoConfig != nil {
		l = m.Ipv6AutoConfig.Size()
		n += 2 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Interface_NoIpv4Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoIpv4Address != nil {
		l = m.NoIpv4Address.Size()
		n += 2 + l + sovNodeTypes(uint64(l))
	}
	return n
}
func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	l = len(m.PublicIp)
	if l > 0 {
		n += 1 + l + sovNodeTypes(uint64(l))
	}
	if len(m.InterfaceList) > 0 {
		for _, e := range m.InterfaceList {
			l = e.Size()
			n += 1 + l + sovNodeTypes(uint64(l))
		}
	}
	return n
}

func sovNodeTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNodeTypes(x uint64) (n int) {
	return sovNodeTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *EthernetInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`Mac:` + fmt.Sprintf("%v", this.Mac) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VlanInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VlanInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`VlanId:` + fmt.Sprintf("%v", this.VlanId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSelectType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSelectType{`,
		`NetworkChoice:` + fmt.Sprintf("%v", this.NetworkChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSelectType_SiteLocalNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSelectType_SiteLocalNetwork{`,
		`SiteLocalNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSelectType_SiteLocalInsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSelectType_SiteLocalInsideNetwork{`,
		`SiteLocalInsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInsideNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSelectType_SegmentNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSelectType_SegmentNetwork{`,
		`SegmentNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SegmentNetwork), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&Interface{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`AddressChoice:` + fmt.Sprintf("%v", this.AddressChoice) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`NetworkOption:` + strings.Replace(this.NetworkOption.String(), "NetworkSelectType", "NetworkSelectType", 1) + `,`,
		`MonitoringChoice:` + fmt.Sprintf("%v", this.MonitoringChoice) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`SiteToSiteConnectivityInterfaceChoice:` + fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceChoice) + `,`,
		`IsPrimary:` + fmt.Sprintf("%v", this.IsPrimary) + `,`,
		`IsManagement:` + fmt.Sprintf("%v", this.IsManagement) + `,`,
		`Ipv6AddressChoice:` + fmt.Sprintf("%v", this.Ipv6AddressChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_EthernetInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_EthernetInterface{`,
		`EthernetInterface:` + strings.Replace(fmt.Sprintf("%v", this.EthernetInterface), "EthernetInterfaceType", "EthernetInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_VlanInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_VlanInterface{`,
		`VlanInterface:` + strings.Replace(fmt.Sprintf("%v", this.VlanInterface), "VlanInterfaceType", "VlanInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_BondInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_BondInterface{`,
		`BondInterface:` + strings.Replace(fmt.Sprintf("%v", this.BondInterface), "FleetBondDeviceType", "fleet.FleetBondDeviceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_DhcpClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_DhcpClient{`,
		`DhcpClient:` + strings.Replace(fmt.Sprintf("%v", this.DhcpClient), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_StaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_StaticIp{`,
		`StaticIp:` + strings.Replace(fmt.Sprintf("%v", this.StaticIp), "StaticIpParametersNodeType", "network_interface.StaticIpParametersNodeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_MonitorDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_MonitorDisabled{`,
		`MonitorDisabled:` + strings.Replace(fmt.Sprintf("%v", this.MonitorDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_Monitor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_Monitor{`,
		`Monitor:` + strings.Replace(fmt.Sprintf("%v", this.Monitor), "LinkQualityMonitorConfig", "network_interface.LinkQualityMonitorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_SiteToSiteConnectivityInterfaceDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_SiteToSiteConnectivityInterfaceDisabled{`,
		`SiteToSiteConnectivityInterfaceDisabled:` + strings.Replace(fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_SiteToSiteConnectivityInterfaceEnabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_SiteToSiteConnectivityInterfaceEnabled{`,
		`SiteToSiteConnectivityInterfaceEnabled:` + strings.Replace(fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceEnabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_DhcpServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_DhcpServer{`,
		`DhcpServer:` + strings.Replace(fmt.Sprintf("%v", this.DhcpServer), "DHCPServerParametersType", "network_interface.DHCPServerParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_NoIpv6Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_NoIpv6Address{`,
		`NoIpv6Address:` + strings.Replace(fmt.Sprintf("%v", this.NoIpv6Address), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_StaticIpv6Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_StaticIpv6Address{`,
		`StaticIpv6Address:` + strings.Replace(fmt.Sprintf("%v", this.StaticIpv6Address), "StaticIPParametersType", "network_interface.StaticIPParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_Ipv6AutoConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_Ipv6AutoConfig{`,
		`Ipv6AutoConfig:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6AutoConfig), "IPV6AutoConfigType", "network_interface.IPV6AutoConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Interface_NoIpv4Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Interface_NoIpv4Address{`,
		`NoIpv4Address:` + strings.Replace(fmt.Sprintf("%v", this.NoIpv4Address), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterfaceList := "[]*Interface{"
	for _, f := range this.InterfaceList {
		repeatedStringForInterfaceList += strings.Replace(f.String(), "Interface", "Interface", 1) + ","
	}
	repeatedStringForInterfaceList += "}"
	s := strings.Join([]string{`&Node{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`PublicIp:` + fmt.Sprintf("%v", this.PublicIp) + `,`,
		`InterfaceList:` + repeatedStringForInterfaceList + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringNodeTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *EthernetInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNodeTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthernetInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthernetInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNodeTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VlanInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNodeTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VlanInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VlanInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			m.VlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNodeTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSelectType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNodeTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSelectType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSelectType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &NetworkSelectType_SiteLocalNetwork{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &NetworkSelectType_SiteLocalInsideNetwork{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &NetworkSelectType_SegmentNetwork{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNodeTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNodeTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNodeTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNodeTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthNodeTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthNodeTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNodeTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNodeTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNodeTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNodeTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNodeTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthernetInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &Interface_EthernetInterface{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VlanInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &Interface_VlanInterface{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &fleet.FleetBondDeviceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &Interface_BondInterface{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &Interface_DhcpClient{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &network_interface.StaticIpParametersNodeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &Interface_StaticIp{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkOption == nil {
				m.NetworkOption = &NetworkSelectType{}
			}
			if err := m.NetworkOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &Interface_MonitorDisabled{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &network_interface.LinkQualityMonitorConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &Interface_Monitor{v}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteConnectivityInterfaceDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteToSiteConnectivityInterfaceChoice = &Interface_SiteToSiteConnectivityInterfaceDisabled{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteConnectivityInterfaceEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteToSiteConnectivityInterfaceChoice = &Interface_SiteToSiteConnectivityInterfaceEnabled{v}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimary = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsManagement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsManagement = bool(v != 0)
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &network_interface.DHCPServerParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &Interface_DhcpServer{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoIpv6Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipv6AddressChoice = &Interface_NoIpv6Address{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIpv6Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &network_interface.StaticIPParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipv6AddressChoice = &Interface_StaticIpv6Address{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6AutoConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &network_interface.IPV6AutoConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipv6AddressChoice = &Interface_Ipv6AutoConfig{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoIpv4Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &Interface_NoIpv4Address{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNodeTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNodeTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNodeTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceList = append(m.InterfaceList, &Interface{})
			if err := m.InterfaceList[len(m.InterfaceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNodeTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNodeTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNodeTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNodeTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNodeTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNodeTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNodeTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNodeTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNodeTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNodeTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNodeTypes = fmt.Errorf("proto: unexpected end of group")
)
