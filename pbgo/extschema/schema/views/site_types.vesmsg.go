// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package views

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AWSNATGatewaychoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSNATGatewaychoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSNATGatewaychoiceType) DeepCopy() *AWSNATGatewaychoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSNATGatewaychoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSNATGatewaychoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSNATGatewaychoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSNATGatewaychoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSNATGatewaychoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSNATGatewaychoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAWSNATGatewaychoiceType) ChoiceNatGwIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NatGwId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nat_gw_id")
	}
	return oValidatorFn_NatGwId, nil
}

func (v *ValidateAWSNATGatewaychoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSNATGatewaychoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSNATGatewaychoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AWSNATGatewaychoiceType_NatGwId:
		if fv, exists := v.FldValidators["choice.nat_gw_id"]; exists {
			val := m.GetChoice().(*AWSNATGatewaychoiceType_NatGwId).NatGwId
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("nat_gw_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSNATGatewaychoiceTypeValidator = func() *ValidateAWSNATGatewaychoiceType {
	v := &ValidateAWSNATGatewaychoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSNATGatewaychoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoiceNatGwId := v.ChoiceNatGwIdValidationRuleHandler
	rulesChoiceNatGwId := map[string]string{
		"ves.io.schema.rules.string.max_len": "21",
		"ves.io.schema.rules.string.pattern": "^(nat-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFnMap["choice.nat_gw_id"], err = vrhChoiceNatGwId(rulesChoiceNatGwId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AWSNATGatewaychoiceType.choice_nat_gw_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.nat_gw_id"] = vFnMap["choice.nat_gw_id"]

	return v
}()

func AWSNATGatewaychoiceTypeValidator() db.Validator {
	return DefaultAWSNATGatewaychoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSSubnetIdsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSSubnetIdsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSSubnetIdsType) DeepCopy() *AWSSubnetIdsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSSubnetIdsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSSubnetIdsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSSubnetIdsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSSubnetIdsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSSubnetIdsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSSubnetIdsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSSubnetIdsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSSubnetIdsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("az_name"))
		if err := fv(ctx, m.GetAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_subnet"))
		if err := fv(ctx, m.GetInsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_subnet_id"))
		if err := fv(ctx, m.GetInsideSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_subnet"))
		if err := fv(ctx, m.GetOutsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_subnet_id"))
		if err := fv(ctx, m.GetOutsideSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["workload_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("workload_subnet"))
		if err := fv(ctx, m.GetWorkloadSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["workload_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("workload_subnet_id"))
		if err := fv(ctx, m.GetWorkloadSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSSubnetIdsTypeValidator = func() *ValidateAWSSubnetIdsType {
	v := &ValidateAWSSubnetIdsType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["outside_subnet"] = AWSSubnetInfoTypeValidator().Validate

	v.FldValidators["inside_subnet"] = AWSSubnetInfoTypeValidator().Validate

	v.FldValidators["workload_subnet"] = AWSSubnetInfoTypeValidator().Validate

	return v
}()

func AWSSubnetIdsTypeValidator() db.Validator {
	return DefaultAWSSubnetIdsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSSubnetInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSSubnetInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSSubnetInfoType) DeepCopy() *AWSSubnetInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSSubnetInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSSubnetInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSSubnetInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSSubnetInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSSubnetInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSSubnetInfoType) AzNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for az_name")
	}

	return validatorFn, nil
}

func (v *ValidateAWSSubnetInfoType) IdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for id")
	}

	return validatorFn, nil
}

func (v *ValidateAWSSubnetInfoType) Ipv4PrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv4_prefix")
	}

	return validatorFn, nil
}

func (v *ValidateAWSSubnetInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSSubnetInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSSubnetInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("az_name"))
		if err := fv(ctx, m.GetAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv4_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv4_prefix"))
		if err := fv(ctx, m.GetIpv4Prefix(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSSubnetInfoTypeValidator = func() *ValidateAWSSubnetInfoType {
	v := &ValidateAWSSubnetInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAzName := v.AzNameValidationRuleHandler
	rulesAzName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.pattern":   "^([a-z]{2})-?(gov-)?([a-z0-9]{4,20})-([a-z0-9]{2})$",
	}
	vFn, err = vrhAzName(rulesAzName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSSubnetInfoType.az_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["az_name"] = vFn

	vrhId := v.IdValidationRuleHandler
	rulesId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(subnet-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhId(rulesId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSSubnetInfoType.id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id"] = vFn

	vrhIpv4Prefix := v.Ipv4PrefixValidationRuleHandler
	rulesIpv4Prefix := map[string]string{
		"ves.io.schema.rules.message.required":            "true",
		"ves.io.schema.rules.string.ipv4_prefix":          "true",
		"ves.io.schema.rules.string.max_ip_prefix_length": "28",
		"ves.io.schema.rules.string.min_ip_prefix_length": "8",
	}
	vFn, err = vrhIpv4Prefix(rulesIpv4Prefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSSubnetInfoType.ipv4_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv4_prefix"] = vFn

	return v
}()

func AWSSubnetInfoTypeValidator() db.Validator {
	return DefaultAWSSubnetInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCOneInterfaceNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCOneInterfaceNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCOneInterfaceNodeType) DeepCopy() *AWSVPCOneInterfaceNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCOneInterfaceNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCOneInterfaceNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCOneInterfaceNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCOneInterfaceNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCOneInterfaceNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCOneInterfaceNodeType) AwsAzNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_az_name")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCOneInterfaceNodeType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCOneInterfaceNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCOneInterfaceNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCOneInterfaceNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_az_name"))
		if err := fv(ctx, m.GetAwsAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("local_subnet"))
		if err := fv(ctx, m.GetLocalSubnet(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCOneInterfaceNodeTypeValidator = func() *ValidateAWSVPCOneInterfaceNodeType {
	v := &ValidateAWSVPCOneInterfaceNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAwsAzName := v.AwsAzNameValidationRuleHandler
	rulesAwsAzName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsAzName(rulesAwsAzName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCOneInterfaceNodeType.aws_az_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_az_name"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "2048",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCOneInterfaceNodeType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["local_subnet"] = CloudSubnetTypeValidator().Validate

	return v
}()

func AWSVPCOneInterfaceNodeTypeValidator() db.Validator {
	return DefaultAWSVPCOneInterfaceNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCParamsType) DeepCopy() *AWSVPCParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCParamsType) NameChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAWSVPCParamsType) NameChoiceNameTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NameTag, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name_tag")
	}
	return oValidatorFn_NameTag, nil
}

func (v *ValidateAWSVPCParamsType) PrimaryIpv4ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_ipv4")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allocate_ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("allocate_ipv6"))
		if err := fv(ctx, m.GetAllocateIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name_choice"]; exists {
		val := m.GetNameChoice()
		vOpts := append(opts,
			db.WithValidateField("name_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNameChoice().(type) {
	case *AWSVPCParamsType_NameTag:
		if fv, exists := v.FldValidators["name_choice.name_tag"]; exists {
			val := m.GetNameChoice().(*AWSVPCParamsType_NameTag).NameTag
			vOpts := append(opts,
				db.WithValidateField("name_choice"),
				db.WithValidateField("name_tag"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AWSVPCParamsType_Autogenerate:
		if fv, exists := v.FldValidators["name_choice.autogenerate"]; exists {
			val := m.GetNameChoice().(*AWSVPCParamsType_Autogenerate).Autogenerate
			vOpts := append(opts,
				db.WithValidateField("name_choice"),
				db.WithValidateField("autogenerate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["primary_ipv4"]; exists {

		vOpts := append(opts, db.WithValidateField("primary_ipv4"))
		if err := fv(ctx, m.GetPrimaryIpv4(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCParamsTypeValidator = func() *ValidateAWSVPCParamsType {
	v := &ValidateAWSVPCParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNameChoice := v.NameChoiceValidationRuleHandler
	rulesNameChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNameChoice(rulesNameChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCParamsType.name_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name_choice"] = vFn

	vrhNameChoiceNameTag := v.NameChoiceNameTagValidationRuleHandler
	rulesNameChoiceNameTag := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFnMap["name_choice.name_tag"], err = vrhNameChoiceNameTag(rulesNameChoiceNameTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AWSVPCParamsType.name_choice_name_tag: %s", err)
		panic(errMsg)
	}

	v.FldValidators["name_choice.name_tag"] = vFnMap["name_choice.name_tag"]

	vrhPrimaryIpv4 := v.PrimaryIpv4ValidationRuleHandler
	rulesPrimaryIpv4 := map[string]string{
		"ves.io.schema.rules.message.required":            "true",
		"ves.io.schema.rules.string.ipv4_prefix":          "true",
		"ves.io.schema.rules.string.max_ip_prefix_length": "28",
		"ves.io.schema.rules.string.min_ip_prefix_length": "16",
	}
	vFn, err = vrhPrimaryIpv4(rulesPrimaryIpv4)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCParamsType.primary_ipv4: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_ipv4"] = vFn

	return v
}()

func AWSVPCParamsTypeValidator() db.Validator {
	return DefaultAWSVPCParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCTwoInterfaceNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCTwoInterfaceNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCTwoInterfaceNodeType) DeepCopy() *AWSVPCTwoInterfaceNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCTwoInterfaceNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCTwoInterfaceNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCTwoInterfaceNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCTwoInterfaceNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCTwoInterfaceNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCTwoInterfaceNodeType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAWSVPCTwoInterfaceNodeType) AwsAzNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_az_name")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCTwoInterfaceNodeType) OutsideSubnetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for outside_subnet")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := CloudSubnetTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCTwoInterfaceNodeType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPCTwoInterfaceNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCTwoInterfaceNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCTwoInterfaceNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_az_name"))
		if err := fv(ctx, m.GetAwsAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AWSVPCTwoInterfaceNodeType_InsideSubnet:
		if fv, exists := v.FldValidators["choice.inside_subnet"]; exists {
			val := m.GetChoice().(*AWSVPCTwoInterfaceNodeType_InsideSubnet).InsideSubnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("inside_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet:
		if fv, exists := v.FldValidators["choice.reserved_inside_subnet"]; exists {
			val := m.GetChoice().(*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet).ReservedInsideSubnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("reserved_inside_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_subnet"))
		if err := fv(ctx, m.GetOutsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["workload_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("workload_subnet"))
		if err := fv(ctx, m.GetWorkloadSubnet(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCTwoInterfaceNodeTypeValidator = func() *ValidateAWSVPCTwoInterfaceNodeType {
	v := &ValidateAWSVPCTwoInterfaceNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCTwoInterfaceNodeType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhAwsAzName := v.AwsAzNameValidationRuleHandler
	rulesAwsAzName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsAzName(rulesAwsAzName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCTwoInterfaceNodeType.aws_az_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_az_name"] = vFn

	vrhOutsideSubnet := v.OutsideSubnetValidationRuleHandler
	rulesOutsideSubnet := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhOutsideSubnet(rulesOutsideSubnet)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCTwoInterfaceNodeType.outside_subnet: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_subnet"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "2048",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCTwoInterfaceNodeType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["choice.inside_subnet"] = CloudSubnetTypeValidator().Validate

	v.FldValidators["workload_subnet"] = CloudSubnetTypeValidator().Validate

	return v
}()

func AWSVPCTwoInterfaceNodeTypeValidator() db.Validator {
	return DefaultAWSVPCTwoInterfaceNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCchoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCchoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCchoiceType) DeepCopy() *AWSVPCchoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCchoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCchoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCchoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCchoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCchoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCchoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAWSVPCchoiceType) ChoiceVpcIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VpcId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vpc_id")
	}
	return oValidatorFn_VpcId, nil
}

func (v *ValidateAWSVPCchoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCchoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCchoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AWSVPCchoiceType_NewVpc:
		if fv, exists := v.FldValidators["choice.new_vpc"]; exists {
			val := m.GetChoice().(*AWSVPCchoiceType_NewVpc).NewVpc
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_vpc"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AWSVPCchoiceType_VpcId:
		if fv, exists := v.FldValidators["choice.vpc_id"]; exists {
			val := m.GetChoice().(*AWSVPCchoiceType_VpcId).VpcId
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("vpc_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCchoiceTypeValidator = func() *ValidateAWSVPCchoiceType {
	v := &ValidateAWSVPCchoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPCchoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoiceVpcId := v.ChoiceVpcIdValidationRuleHandler
	rulesChoiceVpcId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(vpc-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFnMap["choice.vpc_id"], err = vrhChoiceVpcId(rulesChoiceVpcId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AWSVPCchoiceType.choice_vpc_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.vpc_id"] = vFnMap["choice.vpc_id"]

	v.FldValidators["choice.new_vpc"] = AWSVPCParamsTypeValidator().Validate

	return v
}()

func AWSVPCchoiceTypeValidator() db.Validator {
	return DefaultAWSVPCchoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVirtualPrivateGatewaychoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVirtualPrivateGatewaychoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVirtualPrivateGatewaychoiceType) DeepCopy() *AWSVirtualPrivateGatewaychoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVirtualPrivateGatewaychoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVirtualPrivateGatewaychoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVirtualPrivateGatewaychoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVirtualPrivateGatewaychoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVirtualPrivateGatewaychoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVirtualPrivateGatewaychoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAWSVirtualPrivateGatewaychoiceType) ChoiceVgwIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VgwId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vgw_id")
	}
	return oValidatorFn_VgwId, nil
}

func (v *ValidateAWSVirtualPrivateGatewaychoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVirtualPrivateGatewaychoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVirtualPrivateGatewaychoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AWSVirtualPrivateGatewaychoiceType_VgwId:
		if fv, exists := v.FldValidators["choice.vgw_id"]; exists {
			val := m.GetChoice().(*AWSVirtualPrivateGatewaychoiceType_VgwId).VgwId
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("vgw_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVirtualPrivateGatewaychoiceTypeValidator = func() *ValidateAWSVirtualPrivateGatewaychoiceType {
	v := &ValidateAWSVirtualPrivateGatewaychoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVirtualPrivateGatewaychoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoiceVgwId := v.ChoiceVgwIdValidationRuleHandler
	rulesChoiceVgwId := map[string]string{
		"ves.io.schema.rules.string.max_len": "21",
		"ves.io.schema.rules.string.pattern": "^(vgw-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFnMap["choice.vgw_id"], err = vrhChoiceVgwId(rulesChoiceVgwId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AWSVirtualPrivateGatewaychoiceType.choice_vgw_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.vgw_id"] = vFnMap["choice.vgw_id"]

	return v
}()

func AWSVirtualPrivateGatewaychoiceTypeValidator() db.Validator {
	return DefaultAWSVirtualPrivateGatewaychoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AllowedVIPPorts) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AllowedVIPPorts) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AllowedVIPPorts) DeepCopy() *AllowedVIPPorts {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AllowedVIPPorts{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AllowedVIPPorts) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AllowedVIPPorts) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AllowedVIPPortsValidator().Validate(ctx, m, opts...)
}

type ValidateAllowedVIPPorts struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAllowedVIPPorts) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AllowedVIPPorts)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AllowedVIPPorts got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetPortChoice().(type) {
	case *AllowedVIPPorts_UseHttpPort:
		if fv, exists := v.FldValidators["port_choice.use_http_port"]; exists {
			val := m.GetPortChoice().(*AllowedVIPPorts_UseHttpPort).UseHttpPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("use_http_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AllowedVIPPorts_UseHttpsPort:
		if fv, exists := v.FldValidators["port_choice.use_https_port"]; exists {
			val := m.GetPortChoice().(*AllowedVIPPorts_UseHttpsPort).UseHttpsPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("use_https_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AllowedVIPPorts_UseHttpHttpsPort:
		if fv, exists := v.FldValidators["port_choice.use_http_https_port"]; exists {
			val := m.GetPortChoice().(*AllowedVIPPorts_UseHttpHttpsPort).UseHttpHttpsPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("use_http_https_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AllowedVIPPorts_CustomPorts:
		if fv, exists := v.FldValidators["port_choice.custom_ports"]; exists {
			val := m.GetPortChoice().(*AllowedVIPPorts_CustomPorts).CustomPorts
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("custom_ports"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AllowedVIPPorts_DisableAllowedVipPort:
		if fv, exists := v.FldValidators["port_choice.disable_allowed_vip_port"]; exists {
			val := m.GetPortChoice().(*AllowedVIPPorts_DisableAllowedVipPort).DisableAllowedVipPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("disable_allowed_vip_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAllowedVIPPortsValidator = func() *ValidateAllowedVIPPorts {
	v := &ValidateAllowedVIPPorts{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["port_choice.custom_ports"] = CustomPortsValidator().Validate

	return v
}()

func AllowedVIPPortsValidator() db.Validator {
	return DefaultAllowedVIPPortsValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureSpecialSubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureSpecialSubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureSpecialSubnetType) DeepCopy() *AzureSpecialSubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureSpecialSubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureSpecialSubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureSpecialSubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureSpecialSubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureSpecialSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureSpecialSubnetType) ResourceGroupChoiceSubnetResourceGrpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SubnetResourceGrp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subnet_resource_grp")
	}
	return oValidatorFn_SubnetResourceGrp, nil
}

func (v *ValidateAzureSpecialSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureSpecialSubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureSpecialSubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetResourceGroupChoice().(type) {
	case *AzureSpecialSubnetType_SubnetResourceGrp:
		if fv, exists := v.FldValidators["resource_group_choice.subnet_resource_grp"]; exists {
			val := m.GetResourceGroupChoice().(*AzureSpecialSubnetType_SubnetResourceGrp).SubnetResourceGrp
			vOpts := append(opts,
				db.WithValidateField("resource_group_choice"),
				db.WithValidateField("subnet_resource_grp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureSpecialSubnetType_VnetResourceGroup:
		if fv, exists := v.FldValidators["resource_group_choice.vnet_resource_group"]; exists {
			val := m.GetResourceGroupChoice().(*AzureSpecialSubnetType_VnetResourceGroup).VnetResourceGroup
			vOpts := append(opts,
				db.WithValidateField("resource_group_choice"),
				db.WithValidateField("vnet_resource_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureSpecialSubnetTypeValidator = func() *ValidateAzureSpecialSubnetType {
	v := &ValidateAzureSpecialSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResourceGroupChoiceSubnetResourceGrp := v.ResourceGroupChoiceSubnetResourceGrpValidationRuleHandler
	rulesResourceGroupChoiceSubnetResourceGrp := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFnMap["resource_group_choice.subnet_resource_grp"], err = vrhResourceGroupChoiceSubnetResourceGrp(rulesResourceGroupChoiceSubnetResourceGrp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AzureSpecialSubnetType.resource_group_choice_subnet_resource_grp: %s", err)
		panic(errMsg)
	}

	v.FldValidators["resource_group_choice.subnet_resource_grp"] = vFnMap["resource_group_choice.subnet_resource_grp"]

	return v
}()

func AzureSpecialSubnetTypeValidator() db.Validator {
	return DefaultAzureSpecialSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureSubnetChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureSubnetChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureSubnetChoiceType) DeepCopy() *AzureSubnetChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureSubnetChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureSubnetChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureSubnetChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureSubnetChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureSubnetChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureSubnetChoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAzureSubnetChoiceType) ChoiceSubnetParamValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return CloudSubnetParamTypeValidator().Validate, nil
}
func (v *ValidateAzureSubnetChoiceType) ChoiceSubnetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return AzureSubnetTypeValidator().Validate, nil
}

func (v *ValidateAzureSubnetChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureSubnetChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureSubnetChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AzureSubnetChoiceType_SubnetParam:
		if fv, exists := v.FldValidators["choice.subnet_param"]; exists {
			val := m.GetChoice().(*AzureSubnetChoiceType_SubnetParam).SubnetParam
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("subnet_param"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureSubnetChoiceType_Subnet:
		if fv, exists := v.FldValidators["choice.subnet"]; exists {
			val := m.GetChoice().(*AzureSubnetChoiceType_Subnet).Subnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureSubnetChoiceTypeValidator = func() *ValidateAzureSubnetChoiceType {
	v := &ValidateAzureSubnetChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureSubnetChoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoiceSubnetParam := v.ChoiceSubnetParamValidationRuleHandler
	rulesChoiceSubnetParam := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["choice.subnet_param"], err = vrhChoiceSubnetParam(rulesChoiceSubnetParam)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AzureSubnetChoiceType.choice_subnet_param: %s", err)
		panic(errMsg)
	}
	vrhChoiceSubnet := v.ChoiceSubnetValidationRuleHandler
	rulesChoiceSubnet := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["choice.subnet"], err = vrhChoiceSubnet(rulesChoiceSubnet)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AzureSubnetChoiceType.choice_subnet: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.subnet_param"] = vFnMap["choice.subnet_param"]
	v.FldValidators["choice.subnet"] = vFnMap["choice.subnet"]

	return v
}()

func AzureSubnetChoiceTypeValidator() db.Validator {
	return DefaultAzureSubnetChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureSubnetChoiceWithAutoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureSubnetChoiceWithAutoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureSubnetChoiceWithAutoType) DeepCopy() *AzureSubnetChoiceWithAutoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureSubnetChoiceWithAutoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureSubnetChoiceWithAutoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureSubnetChoiceWithAutoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureSubnetChoiceWithAutoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureSubnetChoiceWithAutoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureSubnetChoiceWithAutoType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAzureSubnetChoiceWithAutoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureSubnetChoiceWithAutoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureSubnetChoiceWithAutoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AzureSubnetChoiceWithAutoType_Auto:
		if fv, exists := v.FldValidators["choice.auto"]; exists {
			val := m.GetChoice().(*AzureSubnetChoiceWithAutoType_Auto).Auto
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("auto"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureSubnetChoiceWithAutoType_SubnetParam:
		if fv, exists := v.FldValidators["choice.subnet_param"]; exists {
			val := m.GetChoice().(*AzureSubnetChoiceWithAutoType_SubnetParam).SubnetParam
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("subnet_param"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureSubnetChoiceWithAutoType_Subnet:
		if fv, exists := v.FldValidators["choice.subnet"]; exists {
			val := m.GetChoice().(*AzureSubnetChoiceWithAutoType_Subnet).Subnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureSubnetChoiceWithAutoTypeValidator = func() *ValidateAzureSubnetChoiceWithAutoType {
	v := &ValidateAzureSubnetChoiceWithAutoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureSubnetChoiceWithAutoType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.subnet_param"] = CloudSubnetParamTypeValidator().Validate
	v.FldValidators["choice.subnet"] = AzureSpecialSubnetTypeValidator().Validate

	return v
}()

func AzureSubnetChoiceWithAutoTypeValidator() db.Validator {
	return DefaultAzureSubnetChoiceWithAutoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureSubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureSubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureSubnetType) DeepCopy() *AzureSubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureSubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureSubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureSubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureSubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureSubnetType) ResourceGroupChoiceSubnetResourceGrpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SubnetResourceGrp, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subnet_resource_grp")
	}
	return oValidatorFn_SubnetResourceGrp, nil
}

func (v *ValidateAzureSubnetType) SubnetNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subnet_name")
	}

	return validatorFn, nil
}

func (v *ValidateAzureSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureSubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureSubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetResourceGroupChoice().(type) {
	case *AzureSubnetType_SubnetResourceGrp:
		if fv, exists := v.FldValidators["resource_group_choice.subnet_resource_grp"]; exists {
			val := m.GetResourceGroupChoice().(*AzureSubnetType_SubnetResourceGrp).SubnetResourceGrp
			vOpts := append(opts,
				db.WithValidateField("resource_group_choice"),
				db.WithValidateField("subnet_resource_grp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureSubnetType_VnetResourceGroup:
		if fv, exists := v.FldValidators["resource_group_choice.vnet_resource_group"]; exists {
			val := m.GetResourceGroupChoice().(*AzureSubnetType_VnetResourceGroup).VnetResourceGroup
			vOpts := append(opts,
				db.WithValidateField("resource_group_choice"),
				db.WithValidateField("vnet_resource_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["subnet_name"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet_name"))
		if err := fv(ctx, m.GetSubnetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureSubnetTypeValidator = func() *ValidateAzureSubnetType {
	v := &ValidateAzureSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResourceGroupChoiceSubnetResourceGrp := v.ResourceGroupChoiceSubnetResourceGrpValidationRuleHandler
	rulesResourceGroupChoiceSubnetResourceGrp := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFnMap["resource_group_choice.subnet_resource_grp"], err = vrhResourceGroupChoiceSubnetResourceGrp(rulesResourceGroupChoiceSubnetResourceGrp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AzureSubnetType.resource_group_choice_subnet_resource_grp: %s", err)
		panic(errMsg)
	}

	v.FldValidators["resource_group_choice.subnet_resource_grp"] = vFnMap["resource_group_choice.subnet_resource_grp"]

	vrhSubnetName := v.SubnetNameValidationRuleHandler
	rulesSubnetName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhSubnetName(rulesSubnetName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureSubnetType.subnet_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subnet_name"] = vFn

	return v
}()

func AzureSubnetTypeValidator() db.Validator {
	return DefaultAzureSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetChoiceType) DeepCopy() *AzureVnetChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetChoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateAzureVnetChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *AzureVnetChoiceType_NewVnet:
		if fv, exists := v.FldValidators["choice.new_vnet"]; exists {
			val := m.GetChoice().(*AzureVnetChoiceType_NewVnet).NewVnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_vnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureVnetChoiceType_ExistingVnet:
		if fv, exists := v.FldValidators["choice.existing_vnet"]; exists {
			val := m.GetChoice().(*AzureVnetChoiceType_ExistingVnet).ExistingVnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("existing_vnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetChoiceTypeValidator = func() *ValidateAzureVnetChoiceType {
	v := &ValidateAzureVnetChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetChoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.new_vnet"] = AzureVnetParamsTypeValidator().Validate
	v.FldValidators["choice.existing_vnet"] = AzureVnetTypeValidator().Validate

	return v
}()

func AzureVnetChoiceTypeValidator() db.Validator {
	return DefaultAzureVnetChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetOneInterfaceNodeARType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetOneInterfaceNodeARType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetOneInterfaceNodeARType) DeepCopy() *AzureVnetOneInterfaceNodeARType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetOneInterfaceNodeARType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetOneInterfaceNodeARType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetOneInterfaceNodeARType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetOneInterfaceNodeARTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetOneInterfaceNodeARType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetOneInterfaceNodeARType) NodeNumberValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_number")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetOneInterfaceNodeARType) FaultDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fault_domain")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetOneInterfaceNodeARType) UpdateDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for update_domain")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetOneInterfaceNodeARType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetOneInterfaceNodeARType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetOneInterfaceNodeARType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fault_domain"]; exists {

		vOpts := append(opts, db.WithValidateField("fault_domain"))
		if err := fv(ctx, m.GetFaultDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("local_subnet"))
		if err := fv(ctx, m.GetLocalSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_number"]; exists {

		vOpts := append(opts, db.WithValidateField("node_number"))
		if err := fv(ctx, m.GetNodeNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["update_domain"]; exists {

		vOpts := append(opts, db.WithValidateField("update_domain"))
		if err := fv(ctx, m.GetUpdateDomain(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetOneInterfaceNodeARTypeValidator = func() *ValidateAzureVnetOneInterfaceNodeARType {
	v := &ValidateAzureVnetOneInterfaceNodeARType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeNumber := v.NodeNumberValidationRuleHandler
	rulesNodeNumber := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.in":        "[1,3]",
	}
	vFn, err = vrhNodeNumber(rulesNodeNumber)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetOneInterfaceNodeARType.node_number: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_number"] = vFn

	vrhFaultDomain := v.FaultDomainValidationRuleHandler
	rulesFaultDomain := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "3",
	}
	vFn, err = vrhFaultDomain(rulesFaultDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetOneInterfaceNodeARType.fault_domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fault_domain"] = vFn

	vrhUpdateDomain := v.UpdateDomainValidationRuleHandler
	rulesUpdateDomain := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "20",
	}
	vFn, err = vrhUpdateDomain(rulesUpdateDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetOneInterfaceNodeARType.update_domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["update_domain"] = vFn

	v.FldValidators["local_subnet"] = AzureSubnetChoiceTypeValidator().Validate

	return v
}()

func AzureVnetOneInterfaceNodeARTypeValidator() db.Validator {
	return DefaultAzureVnetOneInterfaceNodeARTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetOneInterfaceNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetOneInterfaceNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetOneInterfaceNodeType) DeepCopy() *AzureVnetOneInterfaceNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetOneInterfaceNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetOneInterfaceNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetOneInterfaceNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetOneInterfaceNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetOneInterfaceNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetOneInterfaceNodeType) AzureAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for azure_az")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetOneInterfaceNodeType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetOneInterfaceNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetOneInterfaceNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetOneInterfaceNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["azure_az"]; exists {

		vOpts := append(opts, db.WithValidateField("azure_az"))
		if err := fv(ctx, m.GetAzureAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("local_subnet"))
		if err := fv(ctx, m.GetLocalSubnet(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetOneInterfaceNodeTypeValidator = func() *ValidateAzureVnetOneInterfaceNodeType {
	v := &ValidateAzureVnetOneInterfaceNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAzureAz := v.AzureAzValidationRuleHandler
	rulesAzureAz := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"1\",\"2\",\"3\"]",
	}
	vFn, err = vrhAzureAz(rulesAzureAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetOneInterfaceNodeType.azure_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["azure_az"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "4095",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetOneInterfaceNodeType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["local_subnet"] = AzureSubnetChoiceTypeValidator().Validate

	return v
}()

func AzureVnetOneInterfaceNodeTypeValidator() db.Validator {
	return DefaultAzureVnetOneInterfaceNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetParamsType) DeepCopy() *AzureVnetParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetParamsType) NameChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAzureVnetParamsType) NameChoiceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Name, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}
	return oValidatorFn_Name, nil
}

func (v *ValidateAzureVnetParamsType) PrimaryIpv4ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_ipv4")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name_choice"]; exists {
		val := m.GetNameChoice()
		vOpts := append(opts,
			db.WithValidateField("name_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNameChoice().(type) {
	case *AzureVnetParamsType_Name:
		if fv, exists := v.FldValidators["name_choice.name"]; exists {
			val := m.GetNameChoice().(*AzureVnetParamsType_Name).Name
			vOpts := append(opts,
				db.WithValidateField("name_choice"),
				db.WithValidateField("name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureVnetParamsType_Autogenerate:
		if fv, exists := v.FldValidators["name_choice.autogenerate"]; exists {
			val := m.GetNameChoice().(*AzureVnetParamsType_Autogenerate).Autogenerate
			vOpts := append(opts,
				db.WithValidateField("name_choice"),
				db.WithValidateField("autogenerate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["primary_ipv4"]; exists {

		vOpts := append(opts, db.WithValidateField("primary_ipv4"))
		if err := fv(ctx, m.GetPrimaryIpv4(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetParamsTypeValidator = func() *ValidateAzureVnetParamsType {
	v := &ValidateAzureVnetParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNameChoice := v.NameChoiceValidationRuleHandler
	rulesNameChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNameChoice(rulesNameChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetParamsType.name_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name_choice"] = vFn

	vrhNameChoiceName := v.NameChoiceNameValidationRuleHandler
	rulesNameChoiceName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["name_choice.name"], err = vrhNameChoiceName(rulesNameChoiceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field AzureVnetParamsType.name_choice_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["name_choice.name"] = vFnMap["name_choice.name"]

	vrhPrimaryIpv4 := v.PrimaryIpv4ValidationRuleHandler
	rulesPrimaryIpv4 := map[string]string{
		"ves.io.schema.rules.message.required":            "true",
		"ves.io.schema.rules.string.ipv4_prefix":          "true",
		"ves.io.schema.rules.string.max_ip_prefix_length": "28",
		"ves.io.schema.rules.string.min_ip_prefix_length": "8",
	}
	vFn, err = vrhPrimaryIpv4(rulesPrimaryIpv4)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetParamsType.primary_ipv4: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_ipv4"] = vFn

	return v
}()

func AzureVnetParamsTypeValidator() db.Validator {
	return DefaultAzureVnetParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetTwoInterfaceNodeARType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetTwoInterfaceNodeARType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetTwoInterfaceNodeARType) DeepCopy() *AzureVnetTwoInterfaceNodeARType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetTwoInterfaceNodeARType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetTwoInterfaceNodeARType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetTwoInterfaceNodeARType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetTwoInterfaceNodeARTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetTwoInterfaceNodeARType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetTwoInterfaceNodeARType) NodeNumberValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_number")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetTwoInterfaceNodeARType) FaultDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fault_domain")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetTwoInterfaceNodeARType) UpdateDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for update_domain")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetTwoInterfaceNodeARType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetTwoInterfaceNodeARType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetTwoInterfaceNodeARType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fault_domain"]; exists {

		vOpts := append(opts, db.WithValidateField("fault_domain"))
		if err := fv(ctx, m.GetFaultDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_subnet"))
		if err := fv(ctx, m.GetInsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_number"]; exists {

		vOpts := append(opts, db.WithValidateField("node_number"))
		if err := fv(ctx, m.GetNodeNumber(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_subnet"))
		if err := fv(ctx, m.GetOutsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["update_domain"]; exists {

		vOpts := append(opts, db.WithValidateField("update_domain"))
		if err := fv(ctx, m.GetUpdateDomain(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetTwoInterfaceNodeARTypeValidator = func() *ValidateAzureVnetTwoInterfaceNodeARType {
	v := &ValidateAzureVnetTwoInterfaceNodeARType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeNumber := v.NodeNumberValidationRuleHandler
	rulesNodeNumber := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.in":        "[1,3]",
	}
	vFn, err = vrhNodeNumber(rulesNodeNumber)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetTwoInterfaceNodeARType.node_number: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_number"] = vFn

	vrhFaultDomain := v.FaultDomainValidationRuleHandler
	rulesFaultDomain := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "3",
	}
	vFn, err = vrhFaultDomain(rulesFaultDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetTwoInterfaceNodeARType.fault_domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fault_domain"] = vFn

	vrhUpdateDomain := v.UpdateDomainValidationRuleHandler
	rulesUpdateDomain := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "20",
	}
	vFn, err = vrhUpdateDomain(rulesUpdateDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetTwoInterfaceNodeARType.update_domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["update_domain"] = vFn

	v.FldValidators["inside_subnet"] = AzureSubnetChoiceTypeValidator().Validate

	v.FldValidators["outside_subnet"] = AzureSubnetChoiceTypeValidator().Validate

	return v
}()

func AzureVnetTwoInterfaceNodeARTypeValidator() db.Validator {
	return DefaultAzureVnetTwoInterfaceNodeARTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetTwoInterfaceNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetTwoInterfaceNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetTwoInterfaceNodeType) DeepCopy() *AzureVnetTwoInterfaceNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetTwoInterfaceNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetTwoInterfaceNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetTwoInterfaceNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetTwoInterfaceNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetTwoInterfaceNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetTwoInterfaceNodeType) AzureAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for azure_az")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetTwoInterfaceNodeType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetTwoInterfaceNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetTwoInterfaceNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetTwoInterfaceNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["azure_az"]; exists {

		vOpts := append(opts, db.WithValidateField("azure_az"))
		if err := fv(ctx, m.GetAzureAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_subnet"))
		if err := fv(ctx, m.GetInsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_subnet"))
		if err := fv(ctx, m.GetOutsideSubnet(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetTwoInterfaceNodeTypeValidator = func() *ValidateAzureVnetTwoInterfaceNodeType {
	v := &ValidateAzureVnetTwoInterfaceNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAzureAz := v.AzureAzValidationRuleHandler
	rulesAzureAz := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"1\",\"2\",\"3\"]",
	}
	vFn, err = vrhAzureAz(rulesAzureAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetTwoInterfaceNodeType.azure_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["azure_az"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "4095",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetTwoInterfaceNodeType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["inside_subnet"] = AzureSubnetChoiceTypeValidator().Validate

	v.FldValidators["outside_subnet"] = AzureSubnetChoiceTypeValidator().Validate

	return v
}()

func AzureVnetTwoInterfaceNodeTypeValidator() db.Validator {
	return DefaultAzureVnetTwoInterfaceNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetType) DeepCopy() *AzureVnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetType) RoutingTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for routing_type")
	}
	return validatorFn, nil
}

func (v *ValidateAzureVnetType) ResourceGroupValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for resource_group")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetType) VnetNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vnet_name")
	}

	return validatorFn, nil
}

func (v *ValidateAzureVnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["resource_group"]; exists {

		vOpts := append(opts, db.WithValidateField("resource_group"))
		if err := fv(ctx, m.GetResourceGroup(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["routing_type"]; exists {
		val := m.GetRoutingType()
		vOpts := append(opts,
			db.WithValidateField("routing_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRoutingType().(type) {
	case *AzureVnetType_F5OrchestratedRouting:
		if fv, exists := v.FldValidators["routing_type.f5_orchestrated_routing"]; exists {
			val := m.GetRoutingType().(*AzureVnetType_F5OrchestratedRouting).F5OrchestratedRouting
			vOpts := append(opts,
				db.WithValidateField("routing_type"),
				db.WithValidateField("f5_orchestrated_routing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AzureVnetType_ManualRouting:
		if fv, exists := v.FldValidators["routing_type.manual_routing"]; exists {
			val := m.GetRoutingType().(*AzureVnetType_ManualRouting).ManualRouting
			vOpts := append(opts,
				db.WithValidateField("routing_type"),
				db.WithValidateField("manual_routing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vnet_name"]; exists {

		vOpts := append(opts, db.WithValidateField("vnet_name"))
		if err := fv(ctx, m.GetVnetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetTypeValidator = func() *ValidateAzureVnetType {
	v := &ValidateAzureVnetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRoutingType := v.RoutingTypeValidationRuleHandler
	rulesRoutingType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRoutingType(rulesRoutingType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetType.routing_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["routing_type"] = vFn

	vrhResourceGroup := v.ResourceGroupValidationRuleHandler
	rulesResourceGroup := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhResourceGroup(rulesResourceGroup)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetType.resource_group: %s", err)
		panic(errMsg)
	}
	v.FldValidators["resource_group"] = vFn

	vrhVnetName := v.VnetNameValidationRuleHandler
	rulesVnetName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhVnetName(rulesVnetName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AzureVnetType.vnet_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vnet_name"] = vFn

	return v
}()

func AzureVnetTypeValidator() db.Validator {
	return DefaultAzureVnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CloudLinkADNType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloudLinkADNType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloudLinkADNType) DeepCopy() *CloudLinkADNType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloudLinkADNType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloudLinkADNType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloudLinkADNType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloudLinkADNTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCloudLinkADNType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloudLinkADNType) CloudlinkNetworkNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cloudlink_network_name")
	}

	return validatorFn, nil
}

func (v *ValidateCloudLinkADNType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloudLinkADNType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloudLinkADNType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloudlink_network_name"]; exists {

		vOpts := append(opts, db.WithValidateField("cloudlink_network_name"))
		if err := fv(ctx, m.GetCloudlinkNetworkName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloudLinkADNTypeValidator = func() *ValidateCloudLinkADNType {
	v := &ValidateCloudLinkADNType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCloudlinkNetworkName := v.CloudlinkNetworkNameValidationRuleHandler
	rulesCloudlinkNetworkName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
	}
	vFn, err = vrhCloudlinkNetworkName(rulesCloudlinkNetworkName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudLinkADNType.cloudlink_network_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cloudlink_network_name"] = vFn

	return v
}()

func CloudLinkADNTypeValidator() db.Validator {
	return DefaultCloudLinkADNTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CloudSubnetParamType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloudSubnetParamType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloudSubnetParamType) DeepCopy() *CloudSubnetParamType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloudSubnetParamType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloudSubnetParamType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloudSubnetParamType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloudSubnetParamTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCloudSubnetParamType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloudSubnetParamType) Ipv4ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv4")
	}

	return validatorFn, nil
}

func (v *ValidateCloudSubnetParamType) Ipv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}

	return validatorFn, nil
}

func (v *ValidateCloudSubnetParamType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloudSubnetParamType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloudSubnetParamType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ipv4"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv4"))
		if err := fv(ctx, m.GetIpv4(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6"))
		if err := fv(ctx, m.GetIpv6(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloudSubnetParamTypeValidator = func() *ValidateCloudSubnetParamType {
	v := &ValidateCloudSubnetParamType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpv4 := v.Ipv4ValidationRuleHandler
	rulesIpv4 := map[string]string{
		"ves.io.schema.rules.message.required":            "true",
		"ves.io.schema.rules.string.ipv4_prefix":          "true",
		"ves.io.schema.rules.string.max_ip_prefix_length": "28",
	}
	vFn, err = vrhIpv4(rulesIpv4)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudSubnetParamType.ipv4: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv4"] = vFn

	vrhIpv6 := v.Ipv6ValidationRuleHandler
	rulesIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6_prefix": "true",
	}
	vFn, err = vrhIpv6(rulesIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudSubnetParamType.ipv6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipv6"] = vFn

	return v
}()

func CloudSubnetParamTypeValidator() db.Validator {
	return DefaultCloudSubnetParamTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CloudSubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloudSubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloudSubnetType) DeepCopy() *CloudSubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloudSubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloudSubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloudSubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloudSubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCloudSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloudSubnetType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateCloudSubnetType) ChoiceExistingSubnetIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExistingSubnetId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for existing_subnet_id")
	}
	return oValidatorFn_ExistingSubnetId, nil
}

func (v *ValidateCloudSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloudSubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloudSubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *CloudSubnetType_SubnetParam:
		if fv, exists := v.FldValidators["choice.subnet_param"]; exists {
			val := m.GetChoice().(*CloudSubnetType_SubnetParam).SubnetParam
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("subnet_param"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CloudSubnetType_ExistingSubnetId:
		if fv, exists := v.FldValidators["choice.existing_subnet_id"]; exists {
			val := m.GetChoice().(*CloudSubnetType_ExistingSubnetId).ExistingSubnetId
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("existing_subnet_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloudSubnetTypeValidator = func() *ValidateCloudSubnetType {
	v := &ValidateCloudSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CloudSubnetType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	vrhChoiceExistingSubnetId := v.ChoiceExistingSubnetIdValidationRuleHandler
	rulesChoiceExistingSubnetId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(subnet-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFnMap["choice.existing_subnet_id"], err = vrhChoiceExistingSubnetId(rulesChoiceExistingSubnetId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CloudSubnetType.choice_existing_subnet_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["choice.existing_subnet_id"] = vFnMap["choice.existing_subnet_id"]

	v.FldValidators["choice.subnet_param"] = CloudSubnetParamTypeValidator().Validate

	return v
}()

func CloudSubnetTypeValidator() db.Validator {
	return DefaultCloudSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomPorts) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomPorts) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomPorts) DeepCopy() *CustomPorts {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomPorts{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomPorts) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomPorts) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomPortsValidator().Validate(ctx, m, opts...)
}

type ValidateCustomPorts struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomPorts) PortRangesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_ranges")
	}

	return validatorFn, nil
}

func (v *ValidateCustomPorts) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomPorts)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomPorts got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["port_ranges"]; exists {

		vOpts := append(opts, db.WithValidateField("port_ranges"))
		if err := fv(ctx, m.GetPortRanges(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomPortsValidator = func() *ValidateCustomPorts {
	v := &ValidateCustomPorts{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPortRanges := v.PortRangesValidationRuleHandler
	rulesPortRanges := map[string]string{
		"ves.io.schema.rules.message.required":       "true",
		"ves.io.schema.rules.string.max_len":         "512",
		"ves.io.schema.rules.string.min_len":         "1",
		"ves.io.schema.rules.string.port_range_list": "true",
	}
	vFn, err = vrhPortRanges(rulesPortRanges)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomPorts.port_ranges: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_ranges"] = vFn

	return v
}()

func CustomPortsValidator() db.Validator {
	return DefaultCustomPortsValidator
}

// augmented methods on protoc/std generated struct

func (m *DCGWBGPPeerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DCGWBGPPeerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *DCGWBGPPeerType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAuthKey().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting DCGWBGPPeerType.auth_key")
	}

	return nil
}

func (m *DCGWBGPPeerType) DeepCopy() *DCGWBGPPeerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DCGWBGPPeerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DCGWBGPPeerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DCGWBGPPeerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DCGWBGPPeerTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDCGWBGPPeerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDCGWBGPPeerType) AmazonAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for amazon_address")
	}

	return validatorFn, nil
}

func (v *ValidateDCGWBGPPeerType) CustomerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for customer_address")
	}

	return validatorFn, nil
}

func (v *ValidateDCGWBGPPeerType) AsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for asn")
	}

	return validatorFn, nil
}

func (v *ValidateDCGWBGPPeerType) AuthKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for auth_key")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.SecretTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDCGWBGPPeerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DCGWBGPPeerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DCGWBGPPeerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["amazon_address"]; exists {

		vOpts := append(opts, db.WithValidateField("amazon_address"))
		if err := fv(ctx, m.GetAmazonAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["asn"]; exists {

		vOpts := append(opts, db.WithValidateField("asn"))
		if err := fv(ctx, m.GetAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["auth_key"]; exists {

		vOpts := append(opts, db.WithValidateField("auth_key"))
		if err := fv(ctx, m.GetAuthKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["customer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("customer_address"))
		if err := fv(ctx, m.GetCustomerAddress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDCGWBGPPeerTypeValidator = func() *ValidateDCGWBGPPeerType {
	v := &ValidateDCGWBGPPeerType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAmazonAddress := v.AmazonAddressValidationRuleHandler
	rulesAmazonAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ip":        "true",
	}
	vFn, err = vrhAmazonAddress(rulesAmazonAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DCGWBGPPeerType.amazon_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["amazon_address"] = vFn

	vrhCustomerAddress := v.CustomerAddressValidationRuleHandler
	rulesCustomerAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ip":        "true",
	}
	vFn, err = vrhCustomerAddress(rulesCustomerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DCGWBGPPeerType.customer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["customer_address"] = vFn

	vrhAsn := v.AsnValidationRuleHandler
	rulesAsn := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "2147483647",
	}
	vFn, err = vrhAsn(rulesAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DCGWBGPPeerType.asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn"] = vFn

	vrhAuthKey := v.AuthKeyValidationRuleHandler
	rulesAuthKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAuthKey(rulesAuthKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DCGWBGPPeerType.auth_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["auth_key"] = vFn

	return v
}()

func DCGWBGPPeerTypeValidator() db.Validator {
	return DefaultDCGWBGPPeerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DirectConnectConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DirectConnectConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DirectConnectConfigType) DeepCopy() *DirectConnectConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DirectConnectConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DirectConnectConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DirectConnectConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DirectConnectConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDirectConnectConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDirectConnectConfigType) AsnChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for asn_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDirectConnectConfigType) AsnChoiceCustomAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_CustomAsn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for custom_asn")
	}
	return oValidatorFn_CustomAsn, nil
}

func (v *ValidateDirectConnectConfigType) VifChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vif_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDirectConnectConfigType) CloudAggregatedPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for cloud_aggregated_prefix")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cloud_aggregated_prefix")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cloud_aggregated_prefix")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cloud_aggregated_prefix")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDirectConnectConfigType) DcConnectAggregatedPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for dc_connect_aggregated_prefix")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dc_connect_aggregated_prefix")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dc_connect_aggregated_prefix")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dc_connect_aggregated_prefix")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDirectConnectConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DirectConnectConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DirectConnectConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn_choice"]; exists {
		val := m.GetAsnChoice()
		vOpts := append(opts,
			db.WithValidateField("asn_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAsnChoice().(type) {
	case *DirectConnectConfigType_AutoAsn:
		if fv, exists := v.FldValidators["asn_choice.auto_asn"]; exists {
			val := m.GetAsnChoice().(*DirectConnectConfigType_AutoAsn).AutoAsn
			vOpts := append(opts,
				db.WithValidateField("asn_choice"),
				db.WithValidateField("auto_asn"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DirectConnectConfigType_CustomAsn:
		if fv, exists := v.FldValidators["asn_choice.custom_asn"]; exists {
			val := m.GetAsnChoice().(*DirectConnectConfigType_CustomAsn).CustomAsn
			vOpts := append(opts,
				db.WithValidateField("asn_choice"),
				db.WithValidateField("custom_asn"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["cloud_aggregated_prefix"]; exists {
		vOpts := append(opts, db.WithValidateField("cloud_aggregated_prefix"))
		if err := fv(ctx, m.GetCloudAggregatedPrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dc_connect_aggregated_prefix"]; exists {
		vOpts := append(opts, db.WithValidateField("dc_connect_aggregated_prefix"))
		if err := fv(ctx, m.GetDcConnectAggregatedPrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vif_choice"]; exists {
		val := m.GetVifChoice()
		vOpts := append(opts,
			db.WithValidateField("vif_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVifChoice().(type) {
	case *DirectConnectConfigType_HostedVifs:
		if fv, exists := v.FldValidators["vif_choice.hosted_vifs"]; exists {
			val := m.GetVifChoice().(*DirectConnectConfigType_HostedVifs).HostedVifs
			vOpts := append(opts,
				db.WithValidateField("vif_choice"),
				db.WithValidateField("hosted_vifs"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DirectConnectConfigType_StandardVifs:
		if fv, exists := v.FldValidators["vif_choice.standard_vifs"]; exists {
			val := m.GetVifChoice().(*DirectConnectConfigType_StandardVifs).StandardVifs
			vOpts := append(opts,
				db.WithValidateField("vif_choice"),
				db.WithValidateField("standard_vifs"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DirectConnectConfigType_ManualGw:
		if fv, exists := v.FldValidators["vif_choice.manual_gw"]; exists {
			val := m.GetVifChoice().(*DirectConnectConfigType_ManualGw).ManualGw
			vOpts := append(opts,
				db.WithValidateField("vif_choice"),
				db.WithValidateField("manual_gw"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDirectConnectConfigTypeValidator = func() *ValidateDirectConnectConfigType {
	v := &ValidateDirectConnectConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsnChoice := v.AsnChoiceValidationRuleHandler
	rulesAsnChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAsnChoice(rulesAsnChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DirectConnectConfigType.asn_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn_choice"] = vFn

	vrhAsnChoiceCustomAsn := v.AsnChoiceCustomAsnValidationRuleHandler
	rulesAsnChoiceCustomAsn := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
	}
	vFnMap["asn_choice.custom_asn"], err = vrhAsnChoiceCustomAsn(rulesAsnChoiceCustomAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DirectConnectConfigType.asn_choice_custom_asn: %s", err)
		panic(errMsg)
	}

	v.FldValidators["asn_choice.custom_asn"] = vFnMap["asn_choice.custom_asn"]

	vrhVifChoice := v.VifChoiceValidationRuleHandler
	rulesVifChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVifChoice(rulesVifChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DirectConnectConfigType.vif_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vif_choice"] = vFn

	vrhCloudAggregatedPrefix := v.CloudAggregatedPrefixValidationRuleHandler
	rulesCloudAggregatedPrefix := map[string]string{
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "16",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhCloudAggregatedPrefix(rulesCloudAggregatedPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DirectConnectConfigType.cloud_aggregated_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cloud_aggregated_prefix"] = vFn

	vrhDcConnectAggregatedPrefix := v.DcConnectAggregatedPrefixValidationRuleHandler
	rulesDcConnectAggregatedPrefix := map[string]string{
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "16",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhDcConnectAggregatedPrefix(rulesDcConnectAggregatedPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DirectConnectConfigType.dc_connect_aggregated_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dc_connect_aggregated_prefix"] = vFn

	v.FldValidators["vif_choice.hosted_vifs"] = HostedVIFConfigTypeValidator().Validate

	return v
}()

func DirectConnectConfigTypeValidator() db.Validator {
	return DefaultDirectConnectConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DirectConnectInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DirectConnectInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DirectConnectInfo) DeepCopy() *DirectConnectInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DirectConnectInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DirectConnectInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DirectConnectInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DirectConnectInfoValidator().Validate(ctx, m, opts...)
}

type ValidateDirectConnectInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDirectConnectInfo) DirectConnectGatewayIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for direct_connect_gateway_id")
	}

	return validatorFn, nil
}

func (v *ValidateDirectConnectInfo) VgwIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vgw_id")
	}

	return validatorFn, nil
}

func (v *ValidateDirectConnectInfo) AsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for asn")
	}

	return validatorFn, nil
}

func (v *ValidateDirectConnectInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DirectConnectInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DirectConnectInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn"]; exists {

		vOpts := append(opts, db.WithValidateField("asn"))
		if err := fv(ctx, m.GetAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["direct_connect_gateway_id"]; exists {

		vOpts := append(opts, db.WithValidateField("direct_connect_gateway_id"))
		if err := fv(ctx, m.GetDirectConnectGatewayId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vgw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vgw_id"))
		if err := fv(ctx, m.GetVgwId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDirectConnectInfoValidator = func() *ValidateDirectConnectInfo {
	v := &ValidateDirectConnectInfo{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDirectConnectGatewayId := v.DirectConnectGatewayIdValidationRuleHandler
	rulesDirectConnectGatewayId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDirectConnectGatewayId(rulesDirectConnectGatewayId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DirectConnectInfo.direct_connect_gateway_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["direct_connect_gateway_id"] = vFn

	vrhVgwId := v.VgwIdValidationRuleHandler
	rulesVgwId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.pattern":   "^(vgw-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhVgwId(rulesVgwId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DirectConnectInfo.vgw_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vgw_id"] = vFn

	vrhAsn := v.AsnValidationRuleHandler
	rulesAsn := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "4294967294",
	}
	vFn, err = vrhAsn(rulesAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DirectConnectInfo.asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn"] = vFn

	return v
}()

func DirectConnectInfoValidator() db.Validator {
	return DefaultDirectConnectInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPSubnetParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPSubnetParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPSubnetParamsType) DeepCopy() *GCPSubnetParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPSubnetParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPSubnetParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPSubnetParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPSubnetParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPSubnetParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPSubnetParamsType) SubnetNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subnet_name")
	}

	return validatorFn, nil
}

func (v *ValidateGCPSubnetParamsType) PrimaryIpv4ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_ipv4")
	}

	return validatorFn, nil
}

func (v *ValidateGCPSubnetParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPSubnetParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPSubnetParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["primary_ipv4"]; exists {

		vOpts := append(opts, db.WithValidateField("primary_ipv4"))
		if err := fv(ctx, m.GetPrimaryIpv4(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnet_name"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet_name"))
		if err := fv(ctx, m.GetSubnetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPSubnetParamsTypeValidator = func() *ValidateGCPSubnetParamsType {
	v := &ValidateGCPSubnetParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSubnetName := v.SubnetNameValidationRuleHandler
	rulesSubnetName := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhSubnetName(rulesSubnetName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPSubnetParamsType.subnet_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subnet_name"] = vFn

	vrhPrimaryIpv4 := v.PrimaryIpv4ValidationRuleHandler
	rulesPrimaryIpv4 := map[string]string{
		"ves.io.schema.rules.message.required":            "true",
		"ves.io.schema.rules.string.ipv4_prefix":          "true",
		"ves.io.schema.rules.string.max_ip_prefix_length": "28",
		"ves.io.schema.rules.string.min_ip_prefix_length": "8",
	}
	vFn, err = vrhPrimaryIpv4(rulesPrimaryIpv4)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPSubnetParamsType.primary_ipv4: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_ipv4"] = vFn

	return v
}()

func GCPSubnetParamsTypeValidator() db.Validator {
	return DefaultGCPSubnetParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPSubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPSubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPSubnetType) DeepCopy() *GCPSubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPSubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPSubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPSubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPSubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPSubnetType) SubnetNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subnet_name")
	}

	return validatorFn, nil
}

func (v *ValidateGCPSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPSubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPSubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["subnet_name"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet_name"))
		if err := fv(ctx, m.GetSubnetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPSubnetTypeValidator = func() *ValidateGCPSubnetType {
	v := &ValidateGCPSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSubnetName := v.SubnetNameValidationRuleHandler
	rulesSubnetName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhSubnetName(rulesSubnetName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPSubnetType.subnet_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subnet_name"] = vFn

	return v
}()

func GCPSubnetTypeValidator() db.Validator {
	return DefaultGCPSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCNetworkAutogenerateParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCNetworkAutogenerateParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCNetworkAutogenerateParamsType) DeepCopy() *GCPVPCNetworkAutogenerateParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCNetworkAutogenerateParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCNetworkAutogenerateParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCNetworkAutogenerateParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCNetworkAutogenerateParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCNetworkAutogenerateParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCNetworkAutogenerateParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCNetworkAutogenerateParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCNetworkAutogenerateParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["autogenerate"]; exists {

		vOpts := append(opts, db.WithValidateField("autogenerate"))
		if err := fv(ctx, m.GetAutogenerate(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCNetworkAutogenerateParamsTypeValidator = func() *ValidateGCPVPCNetworkAutogenerateParamsType {
	v := &ValidateGCPVPCNetworkAutogenerateParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GCPVPCNetworkAutogenerateParamsTypeValidator() db.Validator {
	return DefaultGCPVPCNetworkAutogenerateParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCNetworkChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCNetworkChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCNetworkChoiceType) DeepCopy() *GCPVPCNetworkChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCNetworkChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCNetworkChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCNetworkChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCNetworkChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCNetworkChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCNetworkChoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateGCPVPCNetworkChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCNetworkChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCNetworkChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *GCPVPCNetworkChoiceType_NewNetwork:
		if fv, exists := v.FldValidators["choice.new_network"]; exists {
			val := m.GetChoice().(*GCPVPCNetworkChoiceType_NewNetwork).NewNetwork
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GCPVPCNetworkChoiceType_ExistingNetwork:
		if fv, exists := v.FldValidators["choice.existing_network"]; exists {
			val := m.GetChoice().(*GCPVPCNetworkChoiceType_ExistingNetwork).ExistingNetwork
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("existing_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GCPVPCNetworkChoiceType_NewNetworkAutogenerate:
		if fv, exists := v.FldValidators["choice.new_network_autogenerate"]; exists {
			val := m.GetChoice().(*GCPVPCNetworkChoiceType_NewNetworkAutogenerate).NewNetworkAutogenerate
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_network_autogenerate"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCNetworkChoiceTypeValidator = func() *ValidateGCPVPCNetworkChoiceType {
	v := &ValidateGCPVPCNetworkChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPVPCNetworkChoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.new_network"] = GCPVPCNetworkParamsTypeValidator().Validate
	v.FldValidators["choice.existing_network"] = GCPVPCNetworkTypeValidator().Validate

	return v
}()

func GCPVPCNetworkChoiceTypeValidator() db.Validator {
	return DefaultGCPVPCNetworkChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCNetworkParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCNetworkParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCNetworkParamsType) DeepCopy() *GCPVPCNetworkParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCNetworkParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCNetworkParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCNetworkParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCNetworkParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCNetworkParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCNetworkParamsType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGCPVPCNetworkParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCNetworkParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCNetworkParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCNetworkParamsTypeValidator = func() *ValidateGCPVPCNetworkParamsType {
	v := &ValidateGCPVPCNetworkParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPVPCNetworkParamsType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func GCPVPCNetworkParamsTypeValidator() db.Validator {
	return DefaultGCPVPCNetworkParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCNetworkType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCNetworkType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCNetworkType) DeepCopy() *GCPVPCNetworkType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCNetworkType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCNetworkType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCNetworkType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCNetworkTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCNetworkType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCNetworkType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGCPVPCNetworkType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCNetworkType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCNetworkType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCNetworkTypeValidator = func() *ValidateGCPVPCNetworkType {
	v := &ValidateGCPVPCNetworkType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPVPCNetworkType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func GCPVPCNetworkTypeValidator() db.Validator {
	return DefaultGCPVPCNetworkTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPVPCSubnetChoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPVPCSubnetChoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPVPCSubnetChoiceType) DeepCopy() *GCPVPCSubnetChoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPVPCSubnetChoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPVPCSubnetChoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPVPCSubnetChoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPVPCSubnetChoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGCPVPCSubnetChoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPVPCSubnetChoiceType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateGCPVPCSubnetChoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPVPCSubnetChoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPVPCSubnetChoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *GCPVPCSubnetChoiceType_NewSubnet:
		if fv, exists := v.FldValidators["choice.new_subnet"]; exists {
			val := m.GetChoice().(*GCPVPCSubnetChoiceType_NewSubnet).NewSubnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("new_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GCPVPCSubnetChoiceType_ExistingSubnet:
		if fv, exists := v.FldValidators["choice.existing_subnet"]; exists {
			val := m.GetChoice().(*GCPVPCSubnetChoiceType_ExistingSubnet).ExistingSubnet
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("existing_subnet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPVPCSubnetChoiceTypeValidator = func() *ValidateGCPVPCSubnetChoiceType {
	v := &ValidateGCPVPCSubnetChoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GCPVPCSubnetChoiceType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.new_subnet"] = GCPSubnetParamsTypeValidator().Validate
	v.FldValidators["choice.existing_subnet"] = GCPSubnetTypeValidator().Validate

	return v
}()

func GCPVPCSubnetChoiceTypeValidator() db.Validator {
	return DefaultGCPVPCSubnetChoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalNetworkConnectionListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalNetworkConnectionListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalNetworkConnectionListType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetGlobalNetworkConnections() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting GlobalNetworkConnectionListType.global_network_connections idx %v", idx)
		}
	}

	return nil
}

func (m *GlobalNetworkConnectionListType) DeepCopy() *GlobalNetworkConnectionListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalNetworkConnectionListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalNetworkConnectionListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalNetworkConnectionListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalNetworkConnectionListTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalNetworkConnectionListType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetGlobalNetworkConnectionsDRefInfo()

}

// GetDRefInfo for the field's type
func (m *GlobalNetworkConnectionListType) GetGlobalNetworkConnectionsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetGlobalNetworkConnections() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetGlobalNetworkConnections() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetGlobalNetworkConnections() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("global_network_connections[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateGlobalNetworkConnectionListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalNetworkConnectionListType) GlobalNetworkConnectionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for global_network_connections")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*GlobalNetworkConnectionType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := GlobalNetworkConnectionTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for global_network_connections")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*GlobalNetworkConnectionType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*GlobalNetworkConnectionType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated global_network_connections")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items global_network_connections")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalNetworkConnectionListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalNetworkConnectionListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalNetworkConnectionListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["global_network_connections"]; exists {
		vOpts := append(opts, db.WithValidateField("global_network_connections"))
		if err := fv(ctx, m.GetGlobalNetworkConnections(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalNetworkConnectionListTypeValidator = func() *ValidateGlobalNetworkConnectionListType {
	v := &ValidateGlobalNetworkConnectionListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhGlobalNetworkConnections := v.GlobalNetworkConnectionsValidationRuleHandler
	rulesGlobalNetworkConnections := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhGlobalNetworkConnections(rulesGlobalNetworkConnections)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalNetworkConnectionListType.global_network_connections: %s", err)
		panic(errMsg)
	}
	v.FldValidators["global_network_connections"] = vFn

	return v
}()

func GlobalNetworkConnectionListTypeValidator() db.Validator {
	return DefaultGlobalNetworkConnectionListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalNetworkConnectionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalNetworkConnectionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalNetworkConnectionType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetEnableForwardProxy().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalNetworkConnectionType.enable_forward_proxy")
	}

	return nil
}

func (m *GlobalNetworkConnectionType) DeepCopy() *GlobalNetworkConnectionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalNetworkConnectionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalNetworkConnectionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalNetworkConnectionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalNetworkConnectionTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalNetworkConnectionType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetConnectionChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *GlobalNetworkConnectionType) GetConnectionChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetConnectionChoice() == nil {
		return nil, nil
	}
	switch m.GetConnectionChoice().(type) {
	case *GlobalNetworkConnectionType_SliToGlobalDr:

		drInfos, err := m.GetSliToGlobalDr().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSliToGlobalDr().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "sli_to_global_dr." + dri.DRField
		}
		return drInfos, err

	case *GlobalNetworkConnectionType_SloToGlobalDr:

		drInfos, err := m.GetSloToGlobalDr().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSloToGlobalDr().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "slo_to_global_dr." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateGlobalNetworkConnectionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalNetworkConnectionType) ConnectionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalNetworkConnectionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalNetworkConnectionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalNetworkConnectionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_choice"]; exists {
		val := m.GetConnectionChoice()
		vOpts := append(opts,
			db.WithValidateField("connection_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConnectionChoice().(type) {
	case *GlobalNetworkConnectionType_SliToGlobalDr:
		if fv, exists := v.FldValidators["connection_choice.sli_to_global_dr"]; exists {
			val := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SliToGlobalDr).SliToGlobalDr
			vOpts := append(opts,
				db.WithValidateField("connection_choice"),
				db.WithValidateField("sli_to_global_dr"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalNetworkConnectionType_SloToGlobalDr:
		if fv, exists := v.FldValidators["connection_choice.slo_to_global_dr"]; exists {
			val := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SloToGlobalDr).SloToGlobalDr
			vOpts := append(opts,
				db.WithValidateField("connection_choice"),
				db.WithValidateField("slo_to_global_dr"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetForwardProxyChoice().(type) {
	case *GlobalNetworkConnectionType_DisableForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.disable_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_DisableForwardProxy).DisableForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("disable_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalNetworkConnectionType_EnableForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.enable_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_EnableForwardProxy).EnableForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("enable_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalNetworkConnectionTypeValidator = func() *ValidateGlobalNetworkConnectionType {
	v := &ValidateGlobalNetworkConnectionType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConnectionChoice := v.ConnectionChoiceValidationRuleHandler
	rulesConnectionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhConnectionChoice(rulesConnectionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalNetworkConnectionType.connection_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_choice"] = vFn

	v.FldValidators["connection_choice.sli_to_global_dr"] = GlobalConnectorTypeValidator().Validate
	v.FldValidators["connection_choice.slo_to_global_dr"] = GlobalConnectorTypeValidator().Validate

	v.FldValidators["forward_proxy_choice.enable_forward_proxy"] = ves_io_schema.ForwardProxyConfigTypeValidator().Validate

	return v
}()

func GlobalNetworkConnectionTypeValidator() db.Validator {
	return DefaultGlobalNetworkConnectionTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HostedVIFConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HostedVIFConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HostedVIFConfigType) DeepCopy() *HostedVIFConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HostedVIFConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HostedVIFConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HostedVIFConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HostedVIFConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHostedVIFConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHostedVIFConfigType) VifsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for vifs")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vifs")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vifs")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vifs")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHostedVIFConfigType) VifListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for vif_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*VifRegionConfig, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := VifRegionConfigValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vif_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*VifRegionConfig)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*VifRegionConfig, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vif_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vif_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHostedVIFConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HostedVIFConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HostedVIFConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetConnectivityOptions().(type) {
	case *HostedVIFConfigType_SiteRegistrationOverInternet:
		if fv, exists := v.FldValidators["connectivity_options.site_registration_over_internet"]; exists {
			val := m.GetConnectivityOptions().(*HostedVIFConfigType_SiteRegistrationOverInternet).SiteRegistrationOverInternet
			vOpts := append(opts,
				db.WithValidateField("connectivity_options"),
				db.WithValidateField("site_registration_over_internet"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *HostedVIFConfigType_SiteRegistrationOverDirectConnect:
		if fv, exists := v.FldValidators["connectivity_options.site_registration_over_direct_connect"]; exists {
			val := m.GetConnectivityOptions().(*HostedVIFConfigType_SiteRegistrationOverDirectConnect).SiteRegistrationOverDirectConnect
			vOpts := append(opts,
				db.WithValidateField("connectivity_options"),
				db.WithValidateField("site_registration_over_direct_connect"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vif_list"]; exists {
		vOpts := append(opts, db.WithValidateField("vif_list"))
		if err := fv(ctx, m.GetVifList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vifs"]; exists {
		vOpts := append(opts, db.WithValidateField("vifs"))
		if err := fv(ctx, m.GetVifs(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHostedVIFConfigTypeValidator = func() *ValidateHostedVIFConfigType {
	v := &ValidateHostedVIFConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVifs := v.VifsValidationRuleHandler
	rulesVifs := map[string]string{
		"ves.io.schema.rules.repeated.items.string.pattern": "^(dxvif-)([a-z0-9]{8}|[a-z0-9]{17})$",
		"ves.io.schema.rules.repeated.max_items":            "30",
		"ves.io.schema.rules.repeated.unique":               "true",
	}
	vFn, err = vrhVifs(rulesVifs)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HostedVIFConfigType.vifs: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vifs"] = vFn

	vrhVifList := v.VifListValidationRuleHandler
	rulesVifList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "30",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhVifList(rulesVifList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HostedVIFConfigType.vif_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vif_list"] = vFn

	v.FldValidators["connectivity_options.site_registration_over_direct_connect"] = CloudLinkADNTypeValidator().Validate

	return v
}()

func HostedVIFConfigTypeValidator() db.Validator {
	return DefaultHostedVIFConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OfflineSurvivabilityModeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OfflineSurvivabilityModeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OfflineSurvivabilityModeType) DeepCopy() *OfflineSurvivabilityModeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OfflineSurvivabilityModeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OfflineSurvivabilityModeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OfflineSurvivabilityModeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OfflineSurvivabilityModeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateOfflineSurvivabilityModeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOfflineSurvivabilityModeType) OfflineSurvivabilityModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for offline_survivability_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOfflineSurvivabilityModeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OfflineSurvivabilityModeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OfflineSurvivabilityModeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["offline_survivability_mode_choice"]; exists {
		val := m.GetOfflineSurvivabilityModeChoice()
		vOpts := append(opts,
			db.WithValidateField("offline_survivability_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOfflineSurvivabilityModeChoice().(type) {
	case *OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode:
		if fv, exists := v.FldValidators["offline_survivability_mode_choice.no_offline_survivability_mode"]; exists {
			val := m.GetOfflineSurvivabilityModeChoice().(*OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode).NoOfflineSurvivabilityMode
			vOpts := append(opts,
				db.WithValidateField("offline_survivability_mode_choice"),
				db.WithValidateField("no_offline_survivability_mode"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode:
		if fv, exists := v.FldValidators["offline_survivability_mode_choice.enable_offline_survivability_mode"]; exists {
			val := m.GetOfflineSurvivabilityModeChoice().(*OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode).EnableOfflineSurvivabilityMode
			vOpts := append(opts,
				db.WithValidateField("offline_survivability_mode_choice"),
				db.WithValidateField("enable_offline_survivability_mode"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOfflineSurvivabilityModeTypeValidator = func() *ValidateOfflineSurvivabilityModeType {
	v := &ValidateOfflineSurvivabilityModeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOfflineSurvivabilityModeChoice := v.OfflineSurvivabilityModeChoiceValidationRuleHandler
	rulesOfflineSurvivabilityModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhOfflineSurvivabilityModeChoice(rulesOfflineSurvivabilityModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OfflineSurvivabilityModeType.offline_survivability_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["offline_survivability_mode_choice"] = vFn

	return v
}()

func OfflineSurvivabilityModeTypeValidator() db.Validator {
	return DefaultOfflineSurvivabilityModeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PrivateConnectConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PrivateConnectConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PrivateConnectConfigType) DeepCopy() *PrivateConnectConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PrivateConnectConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PrivateConnectConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PrivateConnectConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PrivateConnectConfigTypeValidator().Validate(ctx, m, opts...)
}

func (m *PrivateConnectConfigType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCloudLinkDRefInfo()

}

func (m *PrivateConnectConfigType) GetCloudLinkDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetCloudLink()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("cloud_link.Object")
	dri := db.DRefInfo{
		RefdType:   "cloud_link.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "cloud_link",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetCloudLinkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *PrivateConnectConfigType) GetCloudLinkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "cloud_link.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: cloud_link")
	}

	vref := m.GetCloudLink()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "cloud_link.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidatePrivateConnectConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePrivateConnectConfigType) CloudLinkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for cloud_link")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePrivateConnectConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PrivateConnectConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PrivateConnectConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloud_link"]; exists {

		vOpts := append(opts, db.WithValidateField("cloud_link"))
		if err := fv(ctx, m.GetCloudLink(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetNetworkOptions().(type) {
	case *PrivateConnectConfigType_Outside:
		if fv, exists := v.FldValidators["network_options.outside"]; exists {
			val := m.GetNetworkOptions().(*PrivateConnectConfigType_Outside).Outside
			vOpts := append(opts,
				db.WithValidateField("network_options"),
				db.WithValidateField("outside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PrivateConnectConfigType_Inside:
		if fv, exists := v.FldValidators["network_options.inside"]; exists {
			val := m.GetNetworkOptions().(*PrivateConnectConfigType_Inside).Inside
			vOpts := append(opts,
				db.WithValidateField("network_options"),
				db.WithValidateField("inside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPrivateConnectConfigTypeValidator = func() *ValidatePrivateConnectConfigType {
	v := &ValidatePrivateConnectConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCloudLink := v.CloudLinkValidationRuleHandler
	rulesCloudLink := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCloudLink(rulesCloudLink)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PrivateConnectConfigType.cloud_link: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cloud_link"] = vFn

	return v
}()

func PrivateConnectConfigTypeValidator() db.Validator {
	return DefaultPrivateConnectConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PrivateConnectivityType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PrivateConnectivityType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PrivateConnectivityType) DeepCopy() *PrivateConnectivityType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PrivateConnectivityType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PrivateConnectivityType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PrivateConnectivityType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PrivateConnectivityTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePrivateConnectivityType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePrivateConnectivityType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PrivateConnectivityType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PrivateConnectivityType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cloud_link"]; exists {

		vOpts := append(opts, db.WithValidateField("cloud_link"))
		if err := fv(ctx, m.GetCloudLink(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_network_name"]; exists {

		vOpts := append(opts, db.WithValidateField("private_network_name"))
		if err := fv(ctx, m.GetPrivateNetworkName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPrivateConnectivityTypeValidator = func() *ValidatePrivateConnectivityType {
	v := &ValidatePrivateConnectivityType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PrivateConnectivityTypeValidator() db.Validator {
	return DefaultPrivateConnectivityTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityGroupType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityGroupType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityGroupType) DeepCopy() *SecurityGroupType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityGroupType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityGroupType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityGroupType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityGroupTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityGroupType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityGroupType) OutsideSecurityGroupIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_security_group_id")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityGroupType) InsideSecurityGroupIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_security_group_id")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityGroupType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityGroupType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityGroupType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["inside_security_group_id"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_security_group_id"))
		if err := fv(ctx, m.GetInsideSecurityGroupId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_security_group_id"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_security_group_id"))
		if err := fv(ctx, m.GetOutsideSecurityGroupId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityGroupTypeValidator = func() *ValidateSecurityGroupType {
	v := &ValidateSecurityGroupType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOutsideSecurityGroupId := v.OutsideSecurityGroupIdValidationRuleHandler
	rulesOutsideSecurityGroupId := map[string]string{
		"ves.io.schema.rules.string.max_len": "20",
		"ves.io.schema.rules.string.pattern": "^(sg-)([a-z0-9]{8}|[a-z0-9]{17})$|^$",
	}
	vFn, err = vrhOutsideSecurityGroupId(rulesOutsideSecurityGroupId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityGroupType.outside_security_group_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_security_group_id"] = vFn

	vrhInsideSecurityGroupId := v.InsideSecurityGroupIdValidationRuleHandler
	rulesInsideSecurityGroupId := map[string]string{
		"ves.io.schema.rules.string.max_len": "20",
		"ves.io.schema.rules.string.pattern": "^(sg-)([a-z0-9]{8}|[a-z0-9]{17})$|^$",
	}
	vFn, err = vrhInsideSecurityGroupId(rulesInsideSecurityGroupId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityGroupType.inside_security_group_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_security_group_id"] = vFn

	return v
}()

func SecurityGroupTypeValidator() db.Validator {
	return DefaultSecurityGroupTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteCloudLinkType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteCloudLinkType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteCloudLinkType) DeepCopy() *SiteCloudLinkType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteCloudLinkType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteCloudLinkType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteCloudLinkType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteCloudLinkTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSiteCloudLinkType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteCloudLinkType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteCloudLinkType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteCloudLinkType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteCloudLinkTypeValidator = func() *ValidateSiteCloudLinkType {
	v := &ValidateSiteCloudLinkType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteCloudLinkTypeValidator() db.Validator {
	return DefaultSiteCloudLinkTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteError) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteError) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteError) DeepCopy() *SiteError {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteError{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteError) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteError) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteErrorValidator().Validate(ctx, m, opts...)
}

type ValidateSiteError struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteError) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteError)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteError got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error_description"]; exists {

		vOpts := append(opts, db.WithValidateField("error_description"))
		if err := fv(ctx, m.GetErrorDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["suggested_action"]; exists {

		vOpts := append(opts, db.WithValidateField("suggested_action"))
		if err := fv(ctx, m.GetSuggestedAction(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteErrorValidator = func() *ValidateSiteError {
	v := &ValidateSiteError{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteErrorValidator() db.Validator {
	return DefaultSiteErrorValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStaticRoutesListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStaticRoutesListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStaticRoutesListType) DeepCopy() *SiteStaticRoutesListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStaticRoutesListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStaticRoutesListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStaticRoutesListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStaticRoutesListTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteStaticRoutesListType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetStaticRouteListDRefInfo()

}

// GetDRefInfo for the field's type
func (m *SiteStaticRoutesListType) GetStaticRouteListDRefInfo() ([]db.DRefInfo, error) {
	if m.GetStaticRouteList() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetStaticRouteList() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStaticRouteList() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("static_route_list[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateSiteStaticRoutesListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStaticRoutesListType) StaticRouteListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for static_route_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*SiteStaticRoutesType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := SiteStaticRoutesTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_route_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*SiteStaticRoutesType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*SiteStaticRoutesType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_route_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_route_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSiteStaticRoutesListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStaticRoutesListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStaticRoutesListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["static_route_list"]; exists {
		vOpts := append(opts, db.WithValidateField("static_route_list"))
		if err := fv(ctx, m.GetStaticRouteList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStaticRoutesListTypeValidator = func() *ValidateSiteStaticRoutesListType {
	v := &ValidateSiteStaticRoutesListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStaticRouteList := v.StaticRouteListValidationRuleHandler
	rulesStaticRouteList := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhStaticRouteList(rulesStaticRouteList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteStaticRoutesListType.static_route_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_route_list"] = vFn

	return v
}()

func SiteStaticRoutesListTypeValidator() db.Validator {
	return DefaultSiteStaticRoutesListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStaticRoutesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStaticRoutesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStaticRoutesType) DeepCopy() *SiteStaticRoutesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStaticRoutesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStaticRoutesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStaticRoutesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStaticRoutesTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteStaticRoutesType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetConfigModeChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *SiteStaticRoutesType) GetConfigModeChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetConfigModeChoice() == nil {
		return nil, nil
	}
	switch m.GetConfigModeChoice().(type) {
	case *SiteStaticRoutesType_CustomStaticRoute:

		drInfos, err := m.GetCustomStaticRoute().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCustomStaticRoute().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "custom_static_route." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateSiteStaticRoutesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStaticRoutesType) ConfigModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for config_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSiteStaticRoutesType) ConfigModeChoiceSimpleStaticRouteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SimpleStaticRoute, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for simple_static_route")
	}
	return oValidatorFn_SimpleStaticRoute, nil
}

func (v *ValidateSiteStaticRoutesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStaticRoutesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStaticRoutesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["config_mode_choice"]; exists {
		val := m.GetConfigModeChoice()
		vOpts := append(opts,
			db.WithValidateField("config_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConfigModeChoice().(type) {
	case *SiteStaticRoutesType_SimpleStaticRoute:
		if fv, exists := v.FldValidators["config_mode_choice.simple_static_route"]; exists {
			val := m.GetConfigModeChoice().(*SiteStaticRoutesType_SimpleStaticRoute).SimpleStaticRoute
			vOpts := append(opts,
				db.WithValidateField("config_mode_choice"),
				db.WithValidateField("simple_static_route"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteStaticRoutesType_CustomStaticRoute:
		if fv, exists := v.FldValidators["config_mode_choice.custom_static_route"]; exists {
			val := m.GetConfigModeChoice().(*SiteStaticRoutesType_CustomStaticRoute).CustomStaticRoute
			vOpts := append(opts,
				db.WithValidateField("config_mode_choice"),
				db.WithValidateField("custom_static_route"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStaticRoutesTypeValidator = func() *ValidateSiteStaticRoutesType {
	v := &ValidateSiteStaticRoutesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConfigModeChoice := v.ConfigModeChoiceValidationRuleHandler
	rulesConfigModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhConfigModeChoice(rulesConfigModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteStaticRoutesType.config_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["config_mode_choice"] = vFn

	vrhConfigModeChoiceSimpleStaticRoute := v.ConfigModeChoiceSimpleStaticRouteValidationRuleHandler
	rulesConfigModeChoiceSimpleStaticRoute := map[string]string{
		"ves.io.schema.rules.string.ipv4_prefix": "true",
	}
	vFnMap["config_mode_choice.simple_static_route"], err = vrhConfigModeChoiceSimpleStaticRoute(rulesConfigModeChoiceSimpleStaticRoute)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SiteStaticRoutesType.config_mode_choice_simple_static_route: %s", err)
		panic(errMsg)
	}

	v.FldValidators["config_mode_choice.simple_static_route"] = vFnMap["config_mode_choice.simple_static_route"]

	v.FldValidators["config_mode_choice.custom_static_route"] = ves_io_schema.StaticRouteTypeValidator().Validate

	return v
}()

func SiteStaticRoutesTypeValidator() db.Validator {
	return DefaultSiteStaticRoutesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateSiteErrorRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateSiteErrorRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateSiteErrorRequest) DeepCopy() *UpdateSiteErrorRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateSiteErrorRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateSiteErrorRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateSiteErrorRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateSiteErrorRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateSiteErrorRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateSiteErrorRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateSiteErrorRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateSiteErrorRequest) TenantValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tenant")
	}

	return validatorFn, nil
}

func (v *ValidateUpdateSiteErrorRequest) SiteErrorsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for site_errors")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*SiteError, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := SiteErrorValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for site_errors")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*SiteError)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*SiteError, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated site_errors")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items site_errors")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateUpdateSiteErrorRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateSiteErrorRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateSiteErrorRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_errors"]; exists {
		vOpts := append(opts, db.WithValidateField("site_errors"))
		if err := fv(ctx, m.GetSiteErrors(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant"))
		if err := fv(ctx, m.GetTenant(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateSiteErrorRequestValidator = func() *ValidateUpdateSiteErrorRequest {
	v := &ValidateUpdateSiteErrorRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateSiteErrorRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateSiteErrorRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhTenant := v.TenantValidationRuleHandler
	rulesTenant := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTenant(rulesTenant)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateSiteErrorRequest.tenant: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tenant"] = vFn

	vrhSiteErrors := v.SiteErrorsValidationRuleHandler
	rulesSiteErrors := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSiteErrors(rulesSiteErrors)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpdateSiteErrorRequest.site_errors: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_errors"] = vFn

	return v
}()

func UpdateSiteErrorRequestValidator() db.Validator {
	return DefaultUpdateSiteErrorRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateSiteErrorResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateSiteErrorResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateSiteErrorResponse) DeepCopy() *UpdateSiteErrorResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateSiteErrorResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateSiteErrorResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateSiteErrorResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateSiteErrorResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateSiteErrorResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateSiteErrorResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateSiteErrorResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateSiteErrorResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateSiteErrorResponseValidator = func() *ValidateUpdateSiteErrorResponse {
	v := &ValidateUpdateSiteErrorResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateSiteErrorResponseValidator() db.Validator {
	return DefaultUpdateSiteErrorResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidateConfigRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidateConfigRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidateConfigRequest) DeepCopy() *ValidateConfigRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidateConfigRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidateConfigRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidateConfigRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidateConfigRequestValidator().Validate(ctx, m, opts...)
}

type ValidateValidateConfigRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidateConfigRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidateConfigRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidateConfigRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidateConfigRequestValidator = func() *ValidateValidateConfigRequest {
	v := &ValidateValidateConfigRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidateConfigRequestValidator() db.Validator {
	return DefaultValidateConfigRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidateConfigResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidateConfigResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidateConfigResponse) DeepCopy() *ValidateConfigResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidateConfigResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidateConfigResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidateConfigResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidateConfigResponseValidator().Validate(ctx, m, opts...)
}

type ValidateValidateConfigResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidateConfigResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidateConfigResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidateConfigResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidateConfigResponseValidator = func() *ValidateValidateConfigResponse {
	v := &ValidateValidateConfigResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidateConfigResponseValidator() db.Validator {
	return DefaultValidateConfigResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *VifRegionConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VifRegionConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VifRegionConfig) DeepCopy() *VifRegionConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VifRegionConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VifRegionConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VifRegionConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VifRegionConfigValidator().Validate(ctx, m, opts...)
}

type ValidateVifRegionConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVifRegionConfig) VifRegionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vif_region_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVifRegionConfig) VifRegionChoiceOtherRegionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_OtherRegion, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for other_region")
	}
	return oValidatorFn_OtherRegion, nil
}

func (v *ValidateVifRegionConfig) VifIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vif_id")
	}

	return validatorFn, nil
}

func (v *ValidateVifRegionConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VifRegionConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VifRegionConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["vif_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vif_id"))
		if err := fv(ctx, m.GetVifId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vif_region_choice"]; exists {
		val := m.GetVifRegionChoice()
		vOpts := append(opts,
			db.WithValidateField("vif_region_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVifRegionChoice().(type) {
	case *VifRegionConfig_SameAsSiteRegion:
		if fv, exists := v.FldValidators["vif_region_choice.same_as_site_region"]; exists {
			val := m.GetVifRegionChoice().(*VifRegionConfig_SameAsSiteRegion).SameAsSiteRegion
			vOpts := append(opts,
				db.WithValidateField("vif_region_choice"),
				db.WithValidateField("same_as_site_region"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VifRegionConfig_OtherRegion:
		if fv, exists := v.FldValidators["vif_region_choice.other_region"]; exists {
			val := m.GetVifRegionChoice().(*VifRegionConfig_OtherRegion).OtherRegion
			vOpts := append(opts,
				db.WithValidateField("vif_region_choice"),
				db.WithValidateField("other_region"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVifRegionConfigValidator = func() *ValidateVifRegionConfig {
	v := &ValidateVifRegionConfig{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVifRegionChoice := v.VifRegionChoiceValidationRuleHandler
	rulesVifRegionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVifRegionChoice(rulesVifRegionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VifRegionConfig.vif_region_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vif_region_choice"] = vFn

	vrhVifRegionChoiceOtherRegion := v.VifRegionChoiceOtherRegionValidationRuleHandler
	rulesVifRegionChoiceOtherRegion := map[string]string{
		"ves.io.schema.rules.string.in": "[\"af-south-1\",\"ap-east-1\",\"ap-northeast-1\",\"ap-northeast-2\",\"ap-south-1\",\"ap-southeast-1\",\"ap-southeast-2\",\"ap-southeast-3\",\"ca-central-1\",\"eu-central-1\",\"eu-north-1\",\"eu-south-1\",\"eu-west-1\",\"eu-west-2\",\"eu-west-3\",\"me-south-1\",\"sa-east-1\",\"us-east-1\",\"us-east-2\",\"us-west-1\",\"us-west-2\"]",
	}
	vFnMap["vif_region_choice.other_region"], err = vrhVifRegionChoiceOtherRegion(rulesVifRegionChoiceOtherRegion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field VifRegionConfig.vif_region_choice_other_region: %s", err)
		panic(errMsg)
	}

	v.FldValidators["vif_region_choice.other_region"] = vFnMap["vif_region_choice.other_region"]

	vrhVifId := v.VifIdValidationRuleHandler
	rulesVifId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.pattern":   "^(dxvif-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhVifId(rulesVifId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VifRegionConfig.vif_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vif_id"] = vFn

	return v
}()

func VifRegionConfigValidator() db.Validator {
	return DefaultVifRegionConfigValidator
}
