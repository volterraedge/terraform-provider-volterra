// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/securemesh_site_v2/aws_types.proto

package securemesh_site_v2

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AWSManagedMode
//
// x-displayName: "Managed By F5XC"
// F5 Distributed Cloud will automate provisioning (ex: node bringup) for this AWS site.
type AWSManagedMode struct {
	// AWS Region
	//
	// x-displayName: "AWS Region"
	// x-example: "us-east-1"
	// x-required
	// AWS Region of your services vpc, where F5XC site will be deployed.
	AwsRegion string `protobuf:"bytes,1,opt,name=aws_region,json=awsRegion,proto3" json:"aws_region,omitempty"`
	// New/Existing Services VPC
	//
	// x-displayName: "New/Existing Services VPC"
	// x-required
	// Services VPC where F5XC site will be deployed can be an existing VPC
	// or F5XC can orchestrate a new VPC and create required cloud resources within that VPC.
	//
	// Types that are valid to be assigned to ServiceVpcChoice:
	//	*AWSManagedMode_NewVpc
	//	*AWSManagedMode_VpcId
	ServiceVpcChoice isAWSManagedMode_ServiceVpcChoice `protobuf_oneof:"service_vpc_choice"`
	// Automatic Deployment
	//
	// x-displayName: "Credential Reference"
	// x-required
	// Reference to AWS cloud credential object used to deploy cloud resources
	AwsCred *views.ObjectRefType `protobuf:"bytes,6,opt,name=aws_cred,json=awsCred,proto3" json:"aws_cred,omitempty"`
	// AWS Tags
	//
	// x-displayName: "AWS Tags"
	// x-example: "dev: staging"
	// AWS Tags is a label consisting of a user-defined key and value.
	// It helps to manage, identify, organize, search for, and filter resources in AWS console.
	Tags map[string]string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AWS Instance Type
	//
	// x-displayName: "AWS Instance Type for Node"
	// x-example: "a1.xlarge"
	// x-required
	// Instance size based on the performance.
	InstanceType string `protobuf:"bytes,8,opt,name=instance_type,json=instanceType,proto3" json:"instance_type,omitempty"`
	// Node Disk size
	//
	// x-displayName: "Node Disk Size"
	// x-example: "80"
	// Node disk size for all node in the F5XC site. Unit is GiB
	DiskSize uint32 `protobuf:"varint,11,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// Security Group
	//
	// x-displayName: "Security Group"
	// Select the security group for slo and sli interfaces.
	//
	// Types that are valid to be assigned to SecurityGroupChoice:
	//	*AWSManagedMode_F5XcSecurityGroup
	//	*AWSManagedMode_CustomSecurityGroup
	SecurityGroupChoice isAWSManagedMode_SecurityGroupChoice `protobuf_oneof:"security_group_choice"`
	// Cloud Egress Gateway Selection
	//
	// x-displayName: "Cloud Egress Gateway Selection"
	// Select the egress cloud gateway that will handle the node traffic to the internet. This configuration determines the path your data will take.
	//
	// Types that are valid to be assigned to EgressGatewayChoice:
	//	*AWSManagedMode_EgressGatewayDefault
	//	*AWSManagedMode_EgressNatGw
	//	*AWSManagedMode_EgressVirtualPrivateGateway
	EgressGatewayChoice isAWSManagedMode_EgressGatewayChoice `protobuf_oneof:"egress_gateway_choice"`
	// Private Connectivity To Site
	//
	// x-displayName: "Private Connectivity To Site"
	// Select Private Connectivity To Site
	//
	// Types that are valid to be assigned to PrivateConnectivityChoice:
	//	*AWSManagedMode_PrivateConnectivityDisabled
	//	*AWSManagedMode_PrivateConnectivity
	PrivateConnectivityChoice isAWSManagedMode_PrivateConnectivityChoice `protobuf_oneof:"private_connectivity_choice"`
	// Number of interfaces on CE
	//
	// x-displayName: "Select Node Settings"
	// x-required
	// Choice of deploying one interface or multiple interface site
	//
	// Types that are valid to be assigned to SiteType:
	//	*AWSManagedMode_SingleInterface
	//	*AWSManagedMode_MultipleInterface
	SiteType isAWSManagedMode_SiteType `protobuf_oneof:"site_type"`
	// Configure Cloud Connect for this site
	//
	// x-displayName: "Cloud Connect Configuration"
	// x-required
	// Configure Cloud Connect for this site.
	//
	// Types that are valid to be assigned to CloudConnectAttachments:
	//	*AWSManagedMode_Disabled
	//	*AWSManagedMode_Tgw
	CloudConnectAttachments isAWSManagedMode_CloudConnectAttachments `protobuf_oneof:"cloud_connect_attachments"`
}

func (m *AWSManagedMode) Reset()      { *m = AWSManagedMode{} }
func (*AWSManagedMode) ProtoMessage() {}
func (*AWSManagedMode) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f46c75610d719ed, []int{0}
}
func (m *AWSManagedMode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSManagedMode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSManagedMode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSManagedMode.Merge(m, src)
}
func (m *AWSManagedMode) XXX_Size() int {
	return m.Size()
}
func (m *AWSManagedMode) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSManagedMode.DiscardUnknown(m)
}

var xxx_messageInfo_AWSManagedMode proto.InternalMessageInfo

type isAWSManagedMode_ServiceVpcChoice interface {
	isAWSManagedMode_ServiceVpcChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAWSManagedMode_SecurityGroupChoice interface {
	isAWSManagedMode_SecurityGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAWSManagedMode_EgressGatewayChoice interface {
	isAWSManagedMode_EgressGatewayChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAWSManagedMode_PrivateConnectivityChoice interface {
	isAWSManagedMode_PrivateConnectivityChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAWSManagedMode_SiteType interface {
	isAWSManagedMode_SiteType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAWSManagedMode_CloudConnectAttachments interface {
	isAWSManagedMode_CloudConnectAttachments()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSManagedMode_NewVpc struct {
	NewVpc *views.AWSVPCParamsType `protobuf:"bytes,3,opt,name=new_vpc,json=newVpc,proto3,oneof" json:"new_vpc,omitempty"`
}
type AWSManagedMode_VpcId struct {
	VpcId string `protobuf:"bytes,4,opt,name=vpc_id,json=vpcId,proto3,oneof" json:"vpc_id,omitempty"`
}
type AWSManagedMode_F5XcSecurityGroup struct {
	F5XcSecurityGroup *schema.Empty `protobuf:"bytes,13,opt,name=f5xc_security_group,json=f5xcSecurityGroup,proto3,oneof" json:"f5xc_security_group,omitempty"`
}
type AWSManagedMode_CustomSecurityGroup struct {
	CustomSecurityGroup *views.SecurityGroupType `protobuf:"bytes,14,opt,name=custom_security_group,json=customSecurityGroup,proto3,oneof" json:"custom_security_group,omitempty"`
}
type AWSManagedMode_EgressGatewayDefault struct {
	EgressGatewayDefault *schema.Empty `protobuf:"bytes,16,opt,name=egress_gateway_default,json=egressGatewayDefault,proto3,oneof" json:"egress_gateway_default,omitempty"`
}
type AWSManagedMode_EgressNatGw struct {
	EgressNatGw *views.AWSNATGatewaychoiceType `protobuf:"bytes,17,opt,name=egress_nat_gw,json=egressNatGw,proto3,oneof" json:"egress_nat_gw,omitempty"`
}
type AWSManagedMode_EgressVirtualPrivateGateway struct {
	EgressVirtualPrivateGateway *views.AWSVirtualPrivateGatewaychoiceType `protobuf:"bytes,18,opt,name=egress_virtual_private_gateway,json=egressVirtualPrivateGateway,proto3,oneof" json:"egress_virtual_private_gateway,omitempty"`
}
type AWSManagedMode_PrivateConnectivityDisabled struct {
	PrivateConnectivityDisabled *schema.Empty `protobuf:"bytes,23,opt,name=private_connectivity_disabled,json=privateConnectivityDisabled,proto3,oneof" json:"private_connectivity_disabled,omitempty"`
}
type AWSManagedMode_PrivateConnectivity struct {
	PrivateConnectivity *views.PrivateConnectConfigType `protobuf:"bytes,24,opt,name=private_connectivity,json=privateConnectivity,proto3,oneof" json:"private_connectivity,omitempty"`
}
type AWSManagedMode_SingleInterface struct {
	SingleInterface *SingleInterface `protobuf:"bytes,27,opt,name=single_interface,json=singleInterface,proto3,oneof" json:"single_interface,omitempty"`
}
type AWSManagedMode_MultipleInterface struct {
	MultipleInterface *MultipleInterface `protobuf:"bytes,28,opt,name=multiple_interface,json=multipleInterface,proto3,oneof" json:"multiple_interface,omitempty"`
}
type AWSManagedMode_Disabled struct {
	Disabled *schema.Empty `protobuf:"bytes,33,opt,name=disabled,proto3,oneof" json:"disabled,omitempty"`
}
type AWSManagedMode_Tgw struct {
	Tgw *TGWType `protobuf:"bytes,34,opt,name=tgw,proto3,oneof" json:"tgw,omitempty"`
}

func (*AWSManagedMode_NewVpc) isAWSManagedMode_ServiceVpcChoice()                               {}
func (*AWSManagedMode_VpcId) isAWSManagedMode_ServiceVpcChoice()                                {}
func (*AWSManagedMode_F5XcSecurityGroup) isAWSManagedMode_SecurityGroupChoice()                 {}
func (*AWSManagedMode_CustomSecurityGroup) isAWSManagedMode_SecurityGroupChoice()               {}
func (*AWSManagedMode_EgressGatewayDefault) isAWSManagedMode_EgressGatewayChoice()              {}
func (*AWSManagedMode_EgressNatGw) isAWSManagedMode_EgressGatewayChoice()                       {}
func (*AWSManagedMode_EgressVirtualPrivateGateway) isAWSManagedMode_EgressGatewayChoice()       {}
func (*AWSManagedMode_PrivateConnectivityDisabled) isAWSManagedMode_PrivateConnectivityChoice() {}
func (*AWSManagedMode_PrivateConnectivity) isAWSManagedMode_PrivateConnectivityChoice()         {}
func (*AWSManagedMode_SingleInterface) isAWSManagedMode_SiteType()                              {}
func (*AWSManagedMode_MultipleInterface) isAWSManagedMode_SiteType()                            {}
func (*AWSManagedMode_Disabled) isAWSManagedMode_CloudConnectAttachments()                      {}
func (*AWSManagedMode_Tgw) isAWSManagedMode_CloudConnectAttachments()                           {}

func (m *AWSManagedMode) GetServiceVpcChoice() isAWSManagedMode_ServiceVpcChoice {
	if m != nil {
		return m.ServiceVpcChoice
	}
	return nil
}
func (m *AWSManagedMode) GetSecurityGroupChoice() isAWSManagedMode_SecurityGroupChoice {
	if m != nil {
		return m.SecurityGroupChoice
	}
	return nil
}
func (m *AWSManagedMode) GetEgressGatewayChoice() isAWSManagedMode_EgressGatewayChoice {
	if m != nil {
		return m.EgressGatewayChoice
	}
	return nil
}
func (m *AWSManagedMode) GetPrivateConnectivityChoice() isAWSManagedMode_PrivateConnectivityChoice {
	if m != nil {
		return m.PrivateConnectivityChoice
	}
	return nil
}
func (m *AWSManagedMode) GetSiteType() isAWSManagedMode_SiteType {
	if m != nil {
		return m.SiteType
	}
	return nil
}
func (m *AWSManagedMode) GetCloudConnectAttachments() isAWSManagedMode_CloudConnectAttachments {
	if m != nil {
		return m.CloudConnectAttachments
	}
	return nil
}

func (m *AWSManagedMode) GetAwsRegion() string {
	if m != nil {
		return m.AwsRegion
	}
	return ""
}

func (m *AWSManagedMode) GetNewVpc() *views.AWSVPCParamsType {
	if x, ok := m.GetServiceVpcChoice().(*AWSManagedMode_NewVpc); ok {
		return x.NewVpc
	}
	return nil
}

func (m *AWSManagedMode) GetVpcId() string {
	if x, ok := m.GetServiceVpcChoice().(*AWSManagedMode_VpcId); ok {
		return x.VpcId
	}
	return ""
}

func (m *AWSManagedMode) GetAwsCred() *views.ObjectRefType {
	if m != nil {
		return m.AwsCred
	}
	return nil
}

func (m *AWSManagedMode) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AWSManagedMode) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

func (m *AWSManagedMode) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

func (m *AWSManagedMode) GetF5XcSecurityGroup() *schema.Empty {
	if x, ok := m.GetSecurityGroupChoice().(*AWSManagedMode_F5XcSecurityGroup); ok {
		return x.F5XcSecurityGroup
	}
	return nil
}

func (m *AWSManagedMode) GetCustomSecurityGroup() *views.SecurityGroupType {
	if x, ok := m.GetSecurityGroupChoice().(*AWSManagedMode_CustomSecurityGroup); ok {
		return x.CustomSecurityGroup
	}
	return nil
}

func (m *AWSManagedMode) GetEgressGatewayDefault() *schema.Empty {
	if x, ok := m.GetEgressGatewayChoice().(*AWSManagedMode_EgressGatewayDefault); ok {
		return x.EgressGatewayDefault
	}
	return nil
}

func (m *AWSManagedMode) GetEgressNatGw() *views.AWSNATGatewaychoiceType {
	if x, ok := m.GetEgressGatewayChoice().(*AWSManagedMode_EgressNatGw); ok {
		return x.EgressNatGw
	}
	return nil
}

func (m *AWSManagedMode) GetEgressVirtualPrivateGateway() *views.AWSVirtualPrivateGatewaychoiceType {
	if x, ok := m.GetEgressGatewayChoice().(*AWSManagedMode_EgressVirtualPrivateGateway); ok {
		return x.EgressVirtualPrivateGateway
	}
	return nil
}

func (m *AWSManagedMode) GetPrivateConnectivityDisabled() *schema.Empty {
	if x, ok := m.GetPrivateConnectivityChoice().(*AWSManagedMode_PrivateConnectivityDisabled); ok {
		return x.PrivateConnectivityDisabled
	}
	return nil
}

func (m *AWSManagedMode) GetPrivateConnectivity() *views.PrivateConnectConfigType {
	if x, ok := m.GetPrivateConnectivityChoice().(*AWSManagedMode_PrivateConnectivity); ok {
		return x.PrivateConnectivity
	}
	return nil
}

func (m *AWSManagedMode) GetSingleInterface() *SingleInterface {
	if x, ok := m.GetSiteType().(*AWSManagedMode_SingleInterface); ok {
		return x.SingleInterface
	}
	return nil
}

func (m *AWSManagedMode) GetMultipleInterface() *MultipleInterface {
	if x, ok := m.GetSiteType().(*AWSManagedMode_MultipleInterface); ok {
		return x.MultipleInterface
	}
	return nil
}

func (m *AWSManagedMode) GetDisabled() *schema.Empty {
	if x, ok := m.GetCloudConnectAttachments().(*AWSManagedMode_Disabled); ok {
		return x.Disabled
	}
	return nil
}

func (m *AWSManagedMode) GetTgw() *TGWType {
	if x, ok := m.GetCloudConnectAttachments().(*AWSManagedMode_Tgw); ok {
		return x.Tgw
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSManagedMode) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSManagedMode_NewVpc)(nil),
		(*AWSManagedMode_VpcId)(nil),
		(*AWSManagedMode_F5XcSecurityGroup)(nil),
		(*AWSManagedMode_CustomSecurityGroup)(nil),
		(*AWSManagedMode_EgressGatewayDefault)(nil),
		(*AWSManagedMode_EgressNatGw)(nil),
		(*AWSManagedMode_EgressVirtualPrivateGateway)(nil),
		(*AWSManagedMode_PrivateConnectivityDisabled)(nil),
		(*AWSManagedMode_PrivateConnectivity)(nil),
		(*AWSManagedMode_SingleInterface)(nil),
		(*AWSManagedMode_MultipleInterface)(nil),
		(*AWSManagedMode_Disabled)(nil),
		(*AWSManagedMode_Tgw)(nil),
	}
}

// Transit Gateway for Cloud Connect
//
// x-displayName: "Transit Gateway Configuration"
// Configure Transit Gateway to be used with Cloud Connect
type TGWType struct {
	// New/Existing Transit Gateway
	//
	// x-displayName: "New/Existing Transit Gateway"
	// x-required
	// F5XC Site can work with an existing Transit Gateway(TGW) and orchestrate attachments, TGW routing and propagation
	// or F5XC can orchestrate new TGW, attachments, TGW routing and propagation
	//
	// Types that are valid to be assigned to TgwChoice:
	//	*TGWType_NewTgw
	//	*TGWType_ExistingTgw
	TgwChoice isTGWType_TgwChoice `protobuf_oneof:"tgw_choice"`
	// Transit gateway CIDR Block
	//
	// x-displayName: "Transit gateway CIDR Block"
	// x-required
	// CIDR block for AWS Transit Gateway GRE connectivity. Defines the IP address range for GRE tunnel traffic over Transit Gateway.
	//
	// Types that are valid to be assigned to TgwCidrChoice:
	//	*TGWType_ReservedTgwCidr
	//	*TGWType_TgwCidr
	TgwCidrChoice isTGWType_TgwCidrChoice `protobuf_oneof:"tgw_cidr_choice"`
}

func (m *TGWType) Reset()      { *m = TGWType{} }
func (*TGWType) ProtoMessage() {}
func (*TGWType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f46c75610d719ed, []int{1}
}
func (m *TGWType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TGWType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TGWType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TGWType.Merge(m, src)
}
func (m *TGWType) XXX_Size() int {
	return m.Size()
}
func (m *TGWType) XXX_DiscardUnknown() {
	xxx_messageInfo_TGWType.DiscardUnknown(m)
}

var xxx_messageInfo_TGWType proto.InternalMessageInfo

type isTGWType_TgwChoice interface {
	isTGWType_TgwChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTGWType_TgwCidrChoice interface {
	isTGWType_TgwCidrChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TGWType_NewTgw struct {
	NewTgw *views.TGWParamsType `protobuf:"bytes,2,opt,name=new_tgw,json=newTgw,proto3,oneof" json:"new_tgw,omitempty"`
}
type TGWType_ExistingTgw struct {
	ExistingTgw *views.ExistingTGWType `protobuf:"bytes,3,opt,name=existing_tgw,json=existingTgw,proto3,oneof" json:"existing_tgw,omitempty"`
}
type TGWType_ReservedTgwCidr struct {
	ReservedTgwCidr *schema.Empty `protobuf:"bytes,5,opt,name=reserved_tgw_cidr,json=reservedTgwCidr,proto3,oneof" json:"reserved_tgw_cidr,omitempty"`
}
type TGWType_TgwCidr struct {
	TgwCidr *views.CloudSubnetParamType `protobuf:"bytes,6,opt,name=tgw_cidr,json=tgwCidr,proto3,oneof" json:"tgw_cidr,omitempty"`
}

func (*TGWType_NewTgw) isTGWType_TgwChoice()              {}
func (*TGWType_ExistingTgw) isTGWType_TgwChoice()         {}
func (*TGWType_ReservedTgwCidr) isTGWType_TgwCidrChoice() {}
func (*TGWType_TgwCidr) isTGWType_TgwCidrChoice()         {}

func (m *TGWType) GetTgwChoice() isTGWType_TgwChoice {
	if m != nil {
		return m.TgwChoice
	}
	return nil
}
func (m *TGWType) GetTgwCidrChoice() isTGWType_TgwCidrChoice {
	if m != nil {
		return m.TgwCidrChoice
	}
	return nil
}

func (m *TGWType) GetNewTgw() *views.TGWParamsType {
	if x, ok := m.GetTgwChoice().(*TGWType_NewTgw); ok {
		return x.NewTgw
	}
	return nil
}

func (m *TGWType) GetExistingTgw() *views.ExistingTGWType {
	if x, ok := m.GetTgwChoice().(*TGWType_ExistingTgw); ok {
		return x.ExistingTgw
	}
	return nil
}

func (m *TGWType) GetReservedTgwCidr() *schema.Empty {
	if x, ok := m.GetTgwCidrChoice().(*TGWType_ReservedTgwCidr); ok {
		return x.ReservedTgwCidr
	}
	return nil
}

func (m *TGWType) GetTgwCidr() *views.CloudSubnetParamType {
	if x, ok := m.GetTgwCidrChoice().(*TGWType_TgwCidr); ok {
		return x.TgwCidr
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TGWType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TGWType_NewTgw)(nil),
		(*TGWType_ExistingTgw)(nil),
		(*TGWType_ReservedTgwCidr)(nil),
		(*TGWType_TgwCidr)(nil),
	}
}

// One Interface
//
// x-displayName: "One Interface"
// One interface site is useful when site is only used as ingress gateway to the VPC.
type SingleInterface struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// This section will show nodes associated with this site.
	NodeList *AWSManagedNodeList `protobuf:"bytes,1,opt,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
}

func (m *SingleInterface) Reset()      { *m = SingleInterface{} }
func (*SingleInterface) ProtoMessage() {}
func (*SingleInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f46c75610d719ed, []int{2}
}
func (m *SingleInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SingleInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleInterface.Merge(m, src)
}
func (m *SingleInterface) XXX_Size() int {
	return m.Size()
}
func (m *SingleInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleInterface.DiscardUnknown(m)
}

var xxx_messageInfo_SingleInterface proto.InternalMessageInfo

func (m *SingleInterface) GetNodeList() *AWSManagedNodeList {
	if m != nil {
		return m.NodeList
	}
	return nil
}

// Multiple Interface Site
//
// x-displayName: "Multiple Interface"
// Multiple interface site is useful when site is used as ingress/egress gateway to the VPC.
type MultipleInterface struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// This section will show nodes associated with this site.
	NodeList *AWSManagedNodeList `protobuf:"bytes,1,opt,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
}

func (m *MultipleInterface) Reset()      { *m = MultipleInterface{} }
func (*MultipleInterface) ProtoMessage() {}
func (*MultipleInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f46c75610d719ed, []int{3}
}
func (m *MultipleInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultipleInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MultipleInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultipleInterface.Merge(m, src)
}
func (m *MultipleInterface) XXX_Size() int {
	return m.Size()
}
func (m *MultipleInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_MultipleInterface.DiscardUnknown(m)
}

var xxx_messageInfo_MultipleInterface proto.InternalMessageInfo

func (m *MultipleInterface) GetNodeList() *AWSManagedNodeList {
	if m != nil {
		return m.NodeList
	}
	return nil
}

// AWSManagedNodeList
//
// x-displayName: "List of Nodes"
// This section will show nodes associated with this site.
type AWSManagedNodeList struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// x-required
	// This section will show nodes associated with this site.
	NodeList []*AWSManagedNode `protobuf:"bytes,1,rep,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
}

func (m *AWSManagedNodeList) Reset()      { *m = AWSManagedNodeList{} }
func (*AWSManagedNodeList) ProtoMessage() {}
func (*AWSManagedNodeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f46c75610d719ed, []int{4}
}
func (m *AWSManagedNodeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSManagedNodeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSManagedNodeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSManagedNodeList.Merge(m, src)
}
func (m *AWSManagedNodeList) XXX_Size() int {
	return m.Size()
}
func (m *AWSManagedNodeList) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSManagedNodeList.DiscardUnknown(m)
}

var xxx_messageInfo_AWSManagedNodeList proto.InternalMessageInfo

func (m *AWSManagedNodeList) GetNodeList() []*AWSManagedNode {
	if m != nil {
		return m.NodeList
	}
	return nil
}

// AWSManagedNode
//
// x-displayName: "Nodes"
// This section will show nodes associated with this site.
type AWSManagedNode struct {
	// Type
	//
	// x-displayName: "Type"
	// x-required
	// x-example: "Control"
	// Type for this Node, can be Control
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Hostname
	//
	// x-displayName: "Hostname"
	// Hostname for this Node
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// AWS AZ
	//
	// x-displayName: "AWS AZ Name"
	// x-required
	// x-example: "us-west-2a"
	// AWS availability zone, must be consistent with the selected AWS region.
	AwsAzName string `protobuf:"bytes,3,opt,name=aws_az_name,json=awsAzName,proto3" json:"aws_az_name,omitempty"`
	// AWSOrchestratedInterface
	//
	// x-displayName: "Interfaces"
	// x-required
	// Interfaces belonging to this node
	InterfaceList []*AWSOrchestratedInterface `protobuf:"bytes,4,rep,name=interface_list,json=interfaceList,proto3" json:"interface_list,omitempty"`
}

func (m *AWSManagedNode) Reset()      { *m = AWSManagedNode{} }
func (*AWSManagedNode) ProtoMessage() {}
func (*AWSManagedNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f46c75610d719ed, []int{5}
}
func (m *AWSManagedNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSManagedNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSManagedNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSManagedNode.Merge(m, src)
}
func (m *AWSManagedNode) XXX_Size() int {
	return m.Size()
}
func (m *AWSManagedNode) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSManagedNode.DiscardUnknown(m)
}

var xxx_messageInfo_AWSManagedNode proto.InternalMessageInfo

func (m *AWSManagedNode) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AWSManagedNode) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AWSManagedNode) GetAwsAzName() string {
	if m != nil {
		return m.AwsAzName
	}
	return ""
}

func (m *AWSManagedNode) GetInterfaceList() []*AWSOrchestratedInterface {
	if m != nil {
		return m.InterfaceList
	}
	return nil
}

// AWSOrchestratedInterface
//
// x-displayName: "Interfaces"
// Interfaces belonging to this node
type AWSOrchestratedInterface struct {
	// Subnet Choice
	//
	// x-displayName: "Specify Subnet"
	// Select Existing Subnet or Create New
	Subnet *AWSSubnetChoiceType `protobuf:"bytes,1,opt,name=subnet,proto3" json:"subnet,omitempty"`
	// Select VRF
	//
	// x-displayName: "Select VRF"
	// x-required
	// Select virtual network (VRF) for this interface.
	// There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites.
	// A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional.
	// Global VRFs are configured via Networking > Segments. A site can have multiple Network Segments (global VRFs).
	NetworkOption *views.NetworkSelectType `protobuf:"bytes,2,opt,name=network_option,json=networkOption,proto3" json:"network_option,omitempty"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Use for Site to Site Connectivity
	//
	// x-displayName: "Use for Site to Site Connectivity"
	// Interface with this field enabled will be used to connect to other sites.
	// This setting is useful if a node has multiple interfaces configured in a VRF.
	// Only one interface in a VRF can have this field enabled.
	//
	// Types that are valid to be assigned to SiteToSiteConnectivityInterfaceChoice:
	//	*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled
	//	*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled
	SiteToSiteConnectivityInterfaceChoice isAWSOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice `protobuf_oneof:"site_to_site_connectivity_interface_choice"`
}

func (m *AWSOrchestratedInterface) Reset()      { *m = AWSOrchestratedInterface{} }
func (*AWSOrchestratedInterface) ProtoMessage() {}
func (*AWSOrchestratedInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f46c75610d719ed, []int{6}
}
func (m *AWSOrchestratedInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSOrchestratedInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSOrchestratedInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSOrchestratedInterface.Merge(m, src)
}
func (m *AWSOrchestratedInterface) XXX_Size() int {
	return m.Size()
}
func (m *AWSOrchestratedInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSOrchestratedInterface.DiscardUnknown(m)
}

var xxx_messageInfo_AWSOrchestratedInterface proto.InternalMessageInfo

type isAWSOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice interface {
	isAWSOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled struct {
	SiteToSiteConnectivityInterfaceDisabled *schema.Empty `protobuf:"bytes,9,opt,name=site_to_site_connectivity_interface_disabled,json=siteToSiteConnectivityInterfaceDisabled,proto3,oneof" json:"site_to_site_connectivity_interface_disabled,omitempty"`
}
type AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled struct {
	SiteToSiteConnectivityInterfaceEnabled *schema.Empty `protobuf:"bytes,10,opt,name=site_to_site_connectivity_interface_enabled,json=siteToSiteConnectivityInterfaceEnabled,proto3,oneof" json:"site_to_site_connectivity_interface_enabled,omitempty"`
}

func (*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) isAWSOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice() {
}
func (*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) isAWSOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice() {
}

func (m *AWSOrchestratedInterface) GetSiteToSiteConnectivityInterfaceChoice() isAWSOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice {
	if m != nil {
		return m.SiteToSiteConnectivityInterfaceChoice
	}
	return nil
}

func (m *AWSOrchestratedInterface) GetSubnet() *AWSSubnetChoiceType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *AWSOrchestratedInterface) GetNetworkOption() *views.NetworkSelectType {
	if m != nil {
		return m.NetworkOption
	}
	return nil
}

func (m *AWSOrchestratedInterface) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *AWSOrchestratedInterface) GetSiteToSiteConnectivityInterfaceDisabled() *schema.Empty {
	if x, ok := m.GetSiteToSiteConnectivityInterfaceChoice().(*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled); ok {
		return x.SiteToSiteConnectivityInterfaceDisabled
	}
	return nil
}

func (m *AWSOrchestratedInterface) GetSiteToSiteConnectivityInterfaceEnabled() *schema.Empty {
	if x, ok := m.GetSiteToSiteConnectivityInterfaceChoice().(*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled); ok {
		return x.SiteToSiteConnectivityInterfaceEnabled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSOrchestratedInterface) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled)(nil),
		(*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled)(nil),
	}
}

// AWS Subnet
//
// x-displayName: "AWS Subnet"
// Parameters for subnet
type AWSSubnetChoiceType struct {
	// Choice of subnet
	//
	// x-displayName: "Select Existing Subnet or Create New"
	// x-required
	// Subnet for the Single interface of the site
	//
	// Types that are valid to be assigned to Choice:
	//	*AWSSubnetChoiceType_SubnetParam
	//	*AWSSubnetChoiceType_ExistingSubnetId
	Choice isAWSSubnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AWSSubnetChoiceType) Reset()      { *m = AWSSubnetChoiceType{} }
func (*AWSSubnetChoiceType) ProtoMessage() {}
func (*AWSSubnetChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f46c75610d719ed, []int{7}
}
func (m *AWSSubnetChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSubnetChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSSubnetChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSubnetChoiceType.Merge(m, src)
}
func (m *AWSSubnetChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *AWSSubnetChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSubnetChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSubnetChoiceType proto.InternalMessageInfo

type isAWSSubnetChoiceType_Choice interface {
	isAWSSubnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSSubnetChoiceType_SubnetParam struct {
	SubnetParam *AWSCloudSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam,proto3,oneof" json:"subnet_param,omitempty"`
}
type AWSSubnetChoiceType_ExistingSubnetId struct {
	ExistingSubnetId string `protobuf:"bytes,2,opt,name=existing_subnet_id,json=existingSubnetId,proto3,oneof" json:"existing_subnet_id,omitempty"`
}

func (*AWSSubnetChoiceType_SubnetParam) isAWSSubnetChoiceType_Choice()      {}
func (*AWSSubnetChoiceType_ExistingSubnetId) isAWSSubnetChoiceType_Choice() {}

func (m *AWSSubnetChoiceType) GetChoice() isAWSSubnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AWSSubnetChoiceType) GetSubnetParam() *AWSCloudSubnetParamType {
	if x, ok := m.GetChoice().(*AWSSubnetChoiceType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *AWSSubnetChoiceType) GetExistingSubnetId() string {
	if x, ok := m.GetChoice().(*AWSSubnetChoiceType_ExistingSubnetId); ok {
		return x.ExistingSubnetId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSSubnetChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSSubnetChoiceType_SubnetParam)(nil),
		(*AWSSubnetChoiceType_ExistingSubnetId)(nil),
	}
}

// Cloud Subnet Param
//
// x-displayName: "New Cloud Subnet Parameters"
// Parameters for creating a new cloud subnet
type AWSCloudSubnetParamType struct {
	// Subnet Name
	//
	// x-displayName: "Subnet Name"
	// x-example: "subnet-a"
	// Name for your Subnet
	//
	// Types that are valid to be assigned to NameChoice:
	//	*AWSCloudSubnetParamType_Name
	//	*AWSCloudSubnetParamType_Autogenerate
	NameChoice isAWSCloudSubnetParamType_NameChoice `protobuf_oneof:"name_choice"`
	// IPv4 Subnet
	//
	// x-displayName: "IPv4 Subnet"
	// x-required
	// x-example: "10.1.2.0/24"
	// IPv4 subnet prefix for this subnet
	Ipv4 string `protobuf:"bytes,4,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	// IPv6 Subnet
	//
	// x-displayName: "IPv6 Subnet"
	// x-example: "1234:568:abcd:9100::/64"
	// IPv6 subnet prefix for this subnet
	Ipv6 string `protobuf:"bytes,5,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
}

func (m *AWSCloudSubnetParamType) Reset()      { *m = AWSCloudSubnetParamType{} }
func (*AWSCloudSubnetParamType) ProtoMessage() {}
func (*AWSCloudSubnetParamType) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f46c75610d719ed, []int{8}
}
func (m *AWSCloudSubnetParamType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSCloudSubnetParamType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSCloudSubnetParamType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSCloudSubnetParamType.Merge(m, src)
}
func (m *AWSCloudSubnetParamType) XXX_Size() int {
	return m.Size()
}
func (m *AWSCloudSubnetParamType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSCloudSubnetParamType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSCloudSubnetParamType proto.InternalMessageInfo

type isAWSCloudSubnetParamType_NameChoice interface {
	isAWSCloudSubnetParamType_NameChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSCloudSubnetParamType_Name struct {
	Name string `protobuf:"bytes,2,opt,name=name,proto3,oneof" json:"name,omitempty"`
}
type AWSCloudSubnetParamType_Autogenerate struct {
	Autogenerate *schema.Empty `protobuf:"bytes,3,opt,name=autogenerate,proto3,oneof" json:"autogenerate,omitempty"`
}

func (*AWSCloudSubnetParamType_Name) isAWSCloudSubnetParamType_NameChoice()         {}
func (*AWSCloudSubnetParamType_Autogenerate) isAWSCloudSubnetParamType_NameChoice() {}

func (m *AWSCloudSubnetParamType) GetNameChoice() isAWSCloudSubnetParamType_NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

func (m *AWSCloudSubnetParamType) GetName() string {
	if x, ok := m.GetNameChoice().(*AWSCloudSubnetParamType_Name); ok {
		return x.Name
	}
	return ""
}

func (m *AWSCloudSubnetParamType) GetAutogenerate() *schema.Empty {
	if x, ok := m.GetNameChoice().(*AWSCloudSubnetParamType_Autogenerate); ok {
		return x.Autogenerate
	}
	return nil
}

func (m *AWSCloudSubnetParamType) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

func (m *AWSCloudSubnetParamType) GetIpv6() string {
	if m != nil {
		return m.Ipv6
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSCloudSubnetParamType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSCloudSubnetParamType_Name)(nil),
		(*AWSCloudSubnetParamType_Autogenerate)(nil),
	}
}

func init() {
	proto.RegisterType((*AWSManagedMode)(nil), "ves.io.schema.views.securemesh_site_v2.AWSManagedMode")
	golang_proto.RegisterType((*AWSManagedMode)(nil), "ves.io.schema.views.securemesh_site_v2.AWSManagedMode")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.securemesh_site_v2.AWSManagedMode.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.securemesh_site_v2.AWSManagedMode.TagsEntry")
	proto.RegisterType((*TGWType)(nil), "ves.io.schema.views.securemesh_site_v2.TGWType")
	golang_proto.RegisterType((*TGWType)(nil), "ves.io.schema.views.securemesh_site_v2.TGWType")
	proto.RegisterType((*SingleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.SingleInterface")
	golang_proto.RegisterType((*SingleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.SingleInterface")
	proto.RegisterType((*MultipleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.MultipleInterface")
	golang_proto.RegisterType((*MultipleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.MultipleInterface")
	proto.RegisterType((*AWSManagedNodeList)(nil), "ves.io.schema.views.securemesh_site_v2.AWSManagedNodeList")
	golang_proto.RegisterType((*AWSManagedNodeList)(nil), "ves.io.schema.views.securemesh_site_v2.AWSManagedNodeList")
	proto.RegisterType((*AWSManagedNode)(nil), "ves.io.schema.views.securemesh_site_v2.AWSManagedNode")
	golang_proto.RegisterType((*AWSManagedNode)(nil), "ves.io.schema.views.securemesh_site_v2.AWSManagedNode")
	proto.RegisterType((*AWSOrchestratedInterface)(nil), "ves.io.schema.views.securemesh_site_v2.AWSOrchestratedInterface")
	golang_proto.RegisterType((*AWSOrchestratedInterface)(nil), "ves.io.schema.views.securemesh_site_v2.AWSOrchestratedInterface")
	proto.RegisterType((*AWSSubnetChoiceType)(nil), "ves.io.schema.views.securemesh_site_v2.AWSSubnetChoiceType")
	golang_proto.RegisterType((*AWSSubnetChoiceType)(nil), "ves.io.schema.views.securemesh_site_v2.AWSSubnetChoiceType")
	proto.RegisterType((*AWSCloudSubnetParamType)(nil), "ves.io.schema.views.securemesh_site_v2.AWSCloudSubnetParamType")
	golang_proto.RegisterType((*AWSCloudSubnetParamType)(nil), "ves.io.schema.views.securemesh_site_v2.AWSCloudSubnetParamType")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/securemesh_site_v2/aws_types.proto", fileDescriptor_1f46c75610d719ed)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/securemesh_site_v2/aws_types.proto", fileDescriptor_1f46c75610d719ed)
}

var fileDescriptor_1f46c75610d719ed = []byte{
	// 2513 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x5d, 0x6c, 0xdb, 0xd6,
	0xf5, 0xf7, 0x95, 0x28, 0x99, 0x3a, 0xfe, 0xa2, 0x6f, 0xe2, 0x84, 0xb1, 0x53, 0x55, 0x31, 0x12,
	0x47, 0x76, 0x69, 0xd9, 0xa2, 0xfc, 0x15, 0x17, 0xed, 0xbf, 0x96, 0x9b, 0xc6, 0x11, 0xf2, 0xe1,
	0xd2, 0xfe, 0x27, 0x58, 0xd6, 0x56, 0xa0, 0xc9, 0x6b, 0x9a, 0x8d, 0x44, 0x6a, 0x24, 0x25, 0xc7,
	0xd9, 0xb2, 0x05, 0x7b, 0xd8, 0xd6, 0x3d, 0x15, 0xc5, 0x1e, 0x86, 0x00, 0x7b, 0x2f, 0xf6, 0xb4,
	0xe7, 0x32, 0x05, 0x8c, 0x02, 0x03, 0x86, 0x3e, 0xe9, 0xb1, 0xeb, 0x53, 0xab, 0x3c, 0xac, 0xdd,
	0xcb, 0x8a, 0x61, 0x0f, 0x7d, 0x18, 0xb0, 0xe1, 0x5e, 0x52, 0xb2, 0x64, 0x2b, 0x4e, 0x52, 0x60,
	0x4f, 0xa2, 0x78, 0xcf, 0xef, 0x77, 0x0e, 0xcf, 0x39, 0xf7, 0x9e, 0x1f, 0x09, 0x0b, 0x35, 0xe2,
	0x66, 0x4c, 0x7b, 0xc6, 0xd5, 0x76, 0x48, 0x59, 0x9d, 0xa9, 0x99, 0x64, 0xd7, 0x9d, 0x71, 0x89,
	0x56, 0x75, 0x48, 0x99, 0xb8, 0x3b, 0x45, 0xd7, 0xf4, 0x48, 0xb1, 0x26, 0xcf, 0xa8, 0xbb, 0x6e,
	0xd1, 0xdb, 0xab, 0x10, 0x37, 0x53, 0x71, 0x6c, 0xcf, 0xc6, 0x13, 0x01, 0x2e, 0x13, 0xe0, 0x32,
	0x0c, 0x97, 0x39, 0x8a, 0x1b, 0x9d, 0x36, 0x4c, 0x6f, 0xa7, 0xba, 0x95, 0xd1, 0xec, 0xf2, 0x8c,
	0x61, 0x1b, 0xf6, 0x0c, 0x83, 0x6f, 0x55, 0xb7, 0xd9, 0x3f, 0xf6, 0x87, 0x5d, 0x05, 0xb4, 0xa3,
	0xa7, 0x3b, 0xc3, 0xb1, 0x88, 0x17, 0x2e, 0xbc, 0x72, 0x64, 0x61, 0xd7, 0x76, 0xee, 0x16, 0x4d,
	0xcb, 0x23, 0xce, 0xb6, 0xaa, 0x91, 0x99, 0xb6, 0xe0, 0x46, 0xc7, 0x3a, 0x8d, 0xed, 0x8a, 0x67,
	0xda, 0x56, 0x73, 0xf1, 0x4c, 0xe7, 0x62, 0x3b, 0xee, 0xec, 0xa1, 0x64, 0xa8, 0x25, 0x53, 0x57,
	0x3d, 0x12, 0xae, 0xa6, 0x8e, 0xa6, 0xaa, 0xd8, 0x49, 0x7d, 0xbe, 0x6b, 0x32, 0x69, 0x26, 0xda,
	0xbd, 0xbc, 0xdc, 0xcd, 0xaa, 0xcd, 0x60, 0xfc, 0x77, 0x18, 0x06, 0x57, 0x6e, 0x6f, 0x5c, 0x57,
	0x2d, 0xd5, 0x20, 0xfa, 0x75, 0x5b, 0x27, 0x38, 0x07, 0x40, 0x2b, 0xe0, 0x10, 0xc3, 0xb4, 0x2d,
	0x11, 0xa5, 0x50, 0x3a, 0x91, 0x3f, 0xf9, 0xbd, 0x8f, 0x7a, 0x3e, 0x79, 0x8c, 0xfa, 0xd3, 0x68,
	0x16, 0x2d, 0xc7, 0x35, 0xdb, 0xda, 0x36, 0x0d, 0x25, 0xa1, 0xee, 0xba, 0x0a, 0x33, 0xc3, 0x6f,
	0x41, 0xaf, 0x45, 0x76, 0x8b, 0xb5, 0x8a, 0x26, 0x46, 0x53, 0x28, 0xdd, 0x27, 0x5f, 0xc8, 0x74,
	0xab, 0xda, 0xca, 0xed, 0x8d, 0x5b, 0xeb, 0xab, 0xeb, 0xaa, 0xa3, 0x96, 0xdd, 0xcd, 0xbd, 0x0a,
	0xc9, 0x73, 0x7f, 0x7a, 0x8c, 0xd0, 0x5a, 0x8f, 0x12, 0xb7, 0xc8, 0xee, 0xad, 0x8a, 0x86, 0x35,
	0x88, 0xd7, 0x2a, 0x5a, 0xd1, 0xd4, 0x45, 0x8e, 0x39, 0x2e, 0x84, 0x8e, 0x07, 0x67, 0xd1, 0x32,
	0x68, 0x25, 0xbb, 0xaa, 0x4f, 0xeb, 0xaa, 0xa7, 0x7e, 0xf2, 0xed, 0x7e, 0x94, 0x73, 0x22, 0xe2,
	0x1b, 0xf4, 0x62, 0xc2, 0x39, 0x2f, 0x8f, 0xbf, 0x97, 0xae, 0x55, 0xb4, 0xe9, 0xc9, 0xf4, 0x8f,
	0xd5, 0xe9, 0xfb, 0xb3, 0xd3, 0x97, 0xde, 0xfd, 0xe9, 0xd2, 0x83, 0x9f, 0xb5, 0xae, 0xb3, 0x8b,
	0x0f, 0x26, 0xcf, 0xaf, 0xf5, 0x28, 0xb1, 0x5a, 0x45, 0xbb, 0xaa, 0x63, 0x02, 0x3c, 0x7d, 0x42,
	0xcd, 0x21, 0xba, 0x18, 0x67, 0xd1, 0x8e, 0x77, 0x8d, 0xf6, 0xe6, 0xd6, 0xfb, 0x44, 0xf3, 0x14,
	0xb2, 0xcd, 0x42, 0x9d, 0xf8, 0xe3, 0x83, 0x61, 0x16, 0x01, 0x03, 0x12, 0xcb, 0x33, 0xd5, 0x92,
	0x4b, 0x43, 0xe3, 0x51, 0x47, 0x56, 0x7a, 0xd5, 0x5d, 0x77, 0xd5, 0x21, 0x3a, 0xfe, 0x0d, 0x02,
	0xce, 0x53, 0x0d, 0x57, 0xec, 0x4d, 0x45, 0xd3, 0x7d, 0xf2, 0x1b, 0x99, 0xe7, 0xeb, 0xe3, 0x4c,
	0x67, 0x3d, 0x32, 0x9b, 0xaa, 0xe1, 0x5e, 0xb6, 0x3c, 0x67, 0x2f, 0x2f, 0xd3, 0xa7, 0x4d, 0x3c,
	0x42, 0xf1, 0x71, 0xfa, 0xec, 0xbf, 0xa0, 0xff, 0x62, 0x8f, 0x50, 0x44, 0x48, 0xd3, 0x2b, 0x78,
	0x84, 0x7a, 0xa7, 0x62, 0x4e, 0x54, 0xfc, 0x0f, 0x6a, 0x7c, 0xf5, 0xe7, 0x68, 0xfc, 0xb7, 0x8f,
	0x51, 0x84, 0xef, 0x51, 0x58, 0x04, 0xf8, 0xe3, 0x08, 0x0c, 0x98, 0x96, 0xeb, 0xa9, 0x96, 0x16,
	0x34, 0x88, 0xc8, 0xb3, 0xf4, 0xfe, 0x32, 0xf2, 0xa5, 0x8f, 0x12, 0x5e, 0x2e, 0x73, 0xaf, 0xa4,
	0x3a, 0x06, 0xa1, 0xc9, 0xfe, 0xe8, 0x31, 0x7a, 0x82, 0x60, 0x0e, 0x0e, 0xee, 0xe2, 0x8b, 0xe9,
	0xb9, 0xd4, 0xbd, 0x54, 0x6d, 0x75, 0xfd, 0xff, 0xa5, 0x54, 0x76, 0xe1, 0x4a, 0x3e, 0xa5, 0xac,
	0x5c, 0x9f, 0x4c, 0x95, 0x89, 0x6e, 0x56, 0xcb, 0xa9, 0x0a, 0x71, 0xb6, 0x6d, 0xa7, 0x4c, 0x99,
	0x21, 0x07, 0xe0, 0xe5, 0x32, 0x72, 0x08, 0xbb, 0x90, 0x5e, 0x6a, 0xc1, 0x72, 0x72, 0x13, 0xb6,
	0x63, 0x1a, 0x3b, 0x1d, 0xa0, 0x4b, 0x00, 0xe5, 0xf9, 0xcc, 0x5c, 0x08, 0x7a, 0x25, 0x9d, 0x5d,
	0x68, 0xa1, 0x16, 0xe6, 0x9a, 0xa8, 0x1a, 0x71, 0xf6, 0x8e, 0x42, 0x5f, 0x65, 0xd0, 0xa5, 0x10,
	0x3a, 0x9d, 0xce, 0xc9, 0x0c, 0xe8, 0xa6, 0xee, 0xa5, 0xb2, 0xf2, 0x52, 0xea, 0x58, 0x70, 0xab,
	0x85, 0x94, 0xfe, 0x66, 0x66, 0x68, 0x99, 0xb1, 0x0c, 0x09, 0xdd, 0x74, 0xef, 0x16, 0x5d, 0xf3,
	0x3e, 0x11, 0xfb, 0x52, 0x28, 0x3d, 0x90, 0x1f, 0xf9, 0xd2, 0x47, 0x91, 0xa5, 0x59, 0xd6, 0x8a,
	0xdf, 0xee, 0x47, 0xe3, 0x53, 0x9c, 0xf8, 0xf0, 0x5f, 0x51, 0x85, 0xa7, 0x76, 0x1b, 0xe6, 0x7d,
	0x82, 0xdf, 0x82, 0x13, 0xdb, 0xf3, 0xf7, 0xb4, 0x22, 0x2b, 0xa6, 0xe9, 0xed, 0x15, 0x0d, 0xc7,
	0xae, 0x56, 0xc4, 0x01, 0xd6, 0x5b, 0x27, 0x0f, 0xd5, 0xfd, 0x72, 0xb9, 0xe2, 0xed, 0xad, 0x21,
	0x65, 0x98, 0x42, 0x36, 0x42, 0xc4, 0x15, 0x0a, 0xc0, 0xef, 0xc0, 0x88, 0x56, 0x75, 0x3d, 0xbb,
	0x7c, 0x98, 0x69, 0x90, 0x31, 0x4d, 0x74, 0xed, 0xa0, 0x0e, 0x0a, 0xfa, 0x08, 0x6b, 0x48, 0x39,
	0x11, 0xd0, 0x74, 0xb2, 0x5f, 0x83, 0x53, 0xc4, 0x70, 0x88, 0xeb, 0x16, 0x0d, 0xd5, 0x23, 0xbb,
	0xea, 0x5e, 0x51, 0x27, 0xdb, 0x6a, 0xb5, 0xe4, 0x89, 0xc2, 0x31, 0x81, 0x46, 0x94, 0x93, 0x01,
	0xea, 0x4a, 0x00, 0x7a, 0x33, 0xc0, 0x60, 0x05, 0x06, 0x42, 0x36, 0x4b, 0xf5, 0x8a, 0xc6, 0xae,
	0x38, 0xcc, 0x48, 0xa4, 0xa7, 0xed, 0xfb, 0x1b, 0x2b, 0x9b, 0x21, 0x83, 0xb6, 0x63, 0x9b, 0x41,
	0xb2, 0xd7, 0x22, 0x4a, 0x5f, 0x40, 0x72, 0x43, 0xf5, 0xae, 0xec, 0xe2, 0x9f, 0x43, 0x32, 0xe4,
	0xac, 0x99, 0x8e, 0x57, 0x55, 0x4b, 0xc5, 0x8a, 0x63, 0xd6, 0x54, 0x8f, 0x34, 0x23, 0x16, 0x31,
	0x73, 0xb2, 0xf8, 0xd4, 0xc3, 0x25, 0x80, 0xad, 0x07, 0xa8, 0x6e, 0xfe, 0xc6, 0x02, 0x07, 0x5d,
	0x0d, 0xf1, 0x1d, 0x78, 0xa9, 0xe9, 0x50, 0xb3, 0x2d, 0x8b, 0x68, 0x9e, 0x59, 0xa3, 0x45, 0xd0,
	0x4d, 0x57, 0xdd, 0x2a, 0x11, 0x5d, 0x3c, 0x7d, 0x4c, 0xa2, 0xa2, 0xca, 0x58, 0x08, 0x5e, 0x6d,
	0xc3, 0xbe, 0x19, 0x42, 0xf1, 0x16, 0x9c, 0xec, 0xc6, 0x2d, 0x8a, 0x8c, 0x72, 0xba, 0xeb, 0x13,
	0xad, 0x77, 0xf0, 0xad, 0xb2, 0xf3, 0x85, 0x3d, 0x47, 0x54, 0x39, 0xd1, 0xc5, 0x17, 0xd6, 0x41,
	0x70, 0x4d, 0xcb, 0x28, 0x91, 0x83, 0x61, 0x25, 0x8e, 0x1d, 0x93, 0xb1, 0x2e, 0x87, 0xcf, 0x06,
	0xc3, 0x5f, 0x6d, 0xc2, 0xd7, 0x38, 0x65, 0xc8, 0xed, 0xbc, 0x85, 0xdf, 0x07, 0x5c, 0xae, 0x96,
	0x3c, 0xb3, 0xd2, 0xe1, 0xe7, 0x2c, 0xf3, 0x73, 0xe9, 0x79, 0xfd, 0x5c, 0x0f, 0x19, 0xda, 0x3d,
	0x0d, 0x97, 0x0f, 0xdf, 0xc4, 0x32, 0xf0, 0xad, 0xe4, 0x9f, 0x3b, 0x26, 0xf9, 0x31, 0xa5, 0x65,
	0x87, 0x57, 0x21, 0xea, 0x19, 0xbb, 0xe2, 0x38, 0x33, 0x9f, 0x79, 0xde, 0x80, 0x36, 0xaf, 0xdc,
	0x66, 0xa9, 0x8d, 0x29, 0x14, 0x3d, 0xba, 0x08, 0x89, 0xd6, 0xc1, 0x8b, 0x05, 0x88, 0xde, 0x25,
	0x7b, 0xc1, 0x2c, 0x54, 0xe8, 0x25, 0x3e, 0x09, 0xb1, 0x9a, 0x5a, 0xaa, 0x12, 0x31, 0xc2, 0xee,
	0x05, 0x7f, 0x96, 0x23, 0x4b, 0x68, 0xb9, 0xfa, 0x99, 0x8f, 0x7e, 0x02, 0x29, 0x18, 0x59, 0xb9,
	0xbd, 0x91, 0x5a, 0x3d, 0x98, 0x14, 0xa9, 0x89, 0xd4, 0xad, 0xf5, 0x55, 0xdc, 0xbb, 0x20, 0x65,
	0x25, 0x59, 0x5a, 0x84, 0x51, 0x18, 0xba, 0x61, 0xeb, 0x24, 0xb5, 0xee, 0xd8, 0x15, 0xe2, 0x78,
	0x26, 0x71, 0x71, 0xef, 0x92, 0x94, 0xcd, 0x4a, 0xf2, 0x02, 0x9c, 0x05, 0x61, 0x95, 0x4e, 0x9a,
	0xd4, 0x8d, 0x40, 0x7b, 0x98, 0x96, 0x81, 0xf9, 0xac, 0x2c, 0x65, 0xe7, 0x25, 0x59, 0x86, 0x13,
	0x30, 0x10, 0xac, 0x86, 0xb5, 0xc7, 0x91, 0x9c, 0x9c, 0xbf, 0x00, 0xd8, 0x25, 0x4e, 0xcd, 0xd4,
	0x08, 0x1d, 0xc2, 0xc5, 0xa0, 0xe7, 0xf1, 0xd0, 0xbe, 0x8f, 0xa2, 0x75, 0x1f, 0x45, 0x1a, 0x3e,
	0x8a, 0xe6, 0xa4, 0xb9, 0xfc, 0x14, 0x8c, 0x74, 0x1e, 0x2d, 0x4d, 0xcb, 0xe1, 0x7d, 0x1f, 0x0d,
	0xd4, 0x7d, 0xd4, 0xdf, 0xf0, 0x51, 0x2c, 0x9b, 0x93, 0xb2, 0x73, 0xf9, 0x2c, 0x8c, 0x1c, 0x3a,
	0x2f, 0x42, 0x5b, 0x71, 0xdf, 0x47, 0x42, 0xdd, 0x47, 0x43, 0x0d, 0x1f, 0xf1, 0xd9, 0x05, 0x29,
	0xbb, 0x28, 0x65, 0x97, 0xbe, 0xf1, 0x11, 0xca, 0xcf, 0xc2, 0x58, 0xd7, 0x0d, 0xd4, 0xe6, 0xe4,
	0x74, 0xdd, 0x47, 0xa7, 0xa8, 0x13, 0x39, 0x27, 0xc9, 0x73, 0xf9, 0x71, 0x48, 0xb4, 0x54, 0x0b,
	0x1e, 0xd9, 0xf7, 0xd1, 0x58, 0xdd, 0x47, 0xa3, 0x6c, 0x7d, 0x51, 0x92, 0x03, 0xd6, 0x0c, 0x9c,
	0x09, 0x07, 0x6f, 0xc0, 0x59, 0x54, 0x3d, 0x4f, 0xd5, 0x76, 0xca, 0xc4, 0xf2, 0x5c, 0xc6, 0x79,
	0xae, 0xee, 0xa3, 0x14, 0xc5, 0xe4, 0x72, 0x52, 0x6e, 0xae, 0xc0, 0xf1, 0x11, 0x21, 0x5a, 0xe0,
	0xf8, 0x84, 0x00, 0x05, 0x8e, 0xef, 0x17, 0x06, 0x0a, 0x1c, 0x3f, 0x24, 0x08, 0x05, 0x8e, 0x3f,
	0x25, 0x9c, 0x2e, 0x70, 0xfc, 0x19, 0x61, 0xb4, 0xc0, 0xf1, 0xa3, 0xc2, 0x58, 0x81, 0xe3, 0x5f,
	0x12, 0x92, 0x05, 0x8e, 0x4f, 0x0a, 0x2f, 0x17, 0x38, 0xfe, 0x65, 0x21, 0x55, 0xe0, 0xf8, 0x94,
	0x70, 0x6e, 0xfc, 0xdf, 0x11, 0xe8, 0x0d, 0x1b, 0x02, 0xbf, 0x16, 0x48, 0x1b, 0xda, 0x52, 0x91,
	0x63, 0xc4, 0xc2, 0xe6, 0x95, 0xdb, 0x07, 0xba, 0x26, 0x54, 0x34, 0x9b, 0xc6, 0x2e, 0xbe, 0x0a,
	0xfd, 0xe4, 0x9e, 0xe9, 0x7a, 0xa6, 0x65, 0x30, 0x8e, 0x40, 0x1e, 0x9d, 0xef, 0xca, 0x71, 0x39,
	0x34, 0x6c, 0xf6, 0x62, 0x8f, 0xd2, 0xd7, 0xc4, 0x52, 0xaa, 0x3c, 0x0c, 0x3b, 0x84, 0x56, 0x99,
	0xe8, 0x94, 0xaa, 0xa8, 0x99, 0xba, 0x23, 0xc6, 0x8e, 0x1d, 0x32, 0x43, 0x4d, 0xc0, 0xa6, 0xb1,
	0xbb, 0x6a, 0xea, 0x0e, 0xbe, 0x06, 0x7c, 0x0b, 0x1a, 0x68, 0x9f, 0xc9, 0xae, 0xa1, 0xb0, 0x0e,
	0xdb, 0xa8, 0x6e, 0x59, 0xc4, 0x63, 0x8f, 0xd5, 0xa6, 0xd6, 0x90, 0xd2, 0xeb, 0x05, 0x6c, 0xf9,
	0x73, 0x00, 0x8c, 0x2d, 0x28, 0xef, 0x89, 0x7d, 0x1f, 0x45, 0xea, 0x3e, 0x42, 0xb4, 0xdb, 0x64,
	0x29, 0xc7, 0x8a, 0x37, 0x01, 0x43, 0x4d, 0x87, 0xed, 0x76, 0xb1, 0xba, 0x8f, 0x38, 0x6a, 0x37,
	0x2f, 0x2d, 0x50, 0xbb, 0x02, 0xc7, 0x23, 0x21, 0x52, 0xe0, 0x78, 0x4e, 0x88, 0x8d, 0x57, 0x60,
	0xe8, 0xd0, 0x39, 0x84, 0xdf, 0x85, 0x84, 0x65, 0xeb, 0xa4, 0x58, 0x32, 0x5d, 0x8f, 0x6d, 0xc4,
	0x3e, 0x79, 0xf9, 0xc5, 0x05, 0x15, 0xdd, 0x71, 0xd7, 0x4c, 0xd7, 0xcb, 0x73, 0xdf, 0xf9, 0x08,
	0x29, 0xbc, 0x15, 0xfe, 0x1f, 0x77, 0x60, 0xf8, 0xc8, 0x89, 0xf4, 0xbf, 0xf6, 0xf9, 0x10, 0x01,
	0x3e, 0x6a, 0x86, 0xdf, 0xef, 0xf4, 0x4a, 0xa5, 0xe3, 0xc2, 0x0f, 0xf3, 0x9a, 0x1f, 0x61, 0x72,
	0xe5, 0x23, 0x14, 0x15, 0x1e, 0x22, 0xa6, 0x16, 0x3f, 0x42, 0x11, 0xb1, 0x3d, 0x84, 0x4f, 0xa3,
	0xed, 0xf2, 0x9f, 0x62, 0x70, 0x1a, 0x38, 0x26, 0x10, 0x43, 0xe1, 0xff, 0xe1, 0xa7, 0x88, 0x41,
	0xfb, 0x9c, 0x84, 0xd2, 0xbb, 0x6a, 0x5b, 0x9e, 0x63, 0x97, 0x14, 0x66, 0x81, 0xa7, 0x80, 0xdf,
	0xb1, 0x5d, 0xcf, 0x52, 0xcb, 0xe1, 0x31, 0x98, 0x1f, 0x6c, 0x5a, 0x53, 0x1d, 0xfa, 0x90, 0x53,
	0x5a, 0xeb, 0x78, 0x09, 0xfa, 0xa8, 0xe4, 0x56, 0xef, 0x17, 0x99, 0x79, 0x94, 0x99, 0x8b, 0xa1,
	0xb8, 0x17, 0x78, 0xd4, 0x29, 0xef, 0xd9, 0x9b, 0xc5, 0xca, 0xfd, 0x1b, 0x14, 0xf9, 0x6b, 0x04,
	0x83, 0xad, 0x29, 0x13, 0x24, 0x85, 0x7b, 0x61, 0x3d, 0x7d, 0xd3, 0xd1, 0x76, 0x88, 0xeb, 0x39,
	0xaa, 0x47, 0xf4, 0x56, 0x7d, 0xf3, 0xc9, 0x66, 0x4e, 0x84, 0x48, 0xf3, 0x8a, 0x6f, 0xcf, 0xd3,
	0x40, 0xcb, 0x2f, 0x4d, 0xd6, 0xf2, 0x87, 0xe8, 0x33, 0x1f, 0x2d, 0xc2, 0x19, 0x10, 0xd8, 0xc1,
	0x7d, 0xd5, 0x62, 0x52, 0x92, 0xbe, 0x94, 0xe1, 0x18, 0x3d, 0xd3, 0x73, 0x30, 0x0a, 0x23, 0x2d,
	0xf6, 0x8e, 0x75, 0x34, 0xf7, 0xb9, 0x8f, 0xde, 0x86, 0x53, 0xc0, 0xaf, 0x85, 0x19, 0x19, 0x85,
	0x83, 0xec, 0xc1, 0x45, 0x38, 0xb5, 0x52, 0x53, 0xcd, 0x92, 0xba, 0x65, 0x96, 0x4c, 0x6f, 0x2f,
	0x75, 0xc7, 0xb6, 0x48, 0x2a, 0xbd, 0x72, 0x67, 0x72, 0x74, 0xa0, 0x23, 0x6f, 0x30, 0x08, 0x1c,
	0xdd, 0x88, 0xa3, 0xf1, 0xa0, 0x48, 0xe3, 0xff, 0x88, 0x83, 0xf8, 0xb4, 0xc7, 0xc3, 0x3f, 0x82,
	0xb8, 0xcb, 0x36, 0x70, 0xd8, 0xbb, 0xaf, 0xbe, 0x40, 0xc2, 0x82, 0x9d, 0xbf, 0xda, 0x52, 0x4e,
	0xc1, 0xd6, 0x57, 0x42, 0x42, 0xbc, 0x01, 0x83, 0xcd, 0xd7, 0xe2, 0xe0, 0xb5, 0x34, 0x3c, 0x1a,
	0xbb, 0x2b, 0xd4, 0x70, 0x8a, 0x6d, 0x90, 0x12, 0xd1, 0xbc, 0x36, 0xb6, 0x81, 0x90, 0xe3, 0x26,
	0xa3, 0xc0, 0x19, 0x88, 0x96, 0xbd, 0x2a, 0xeb, 0x8d, 0x81, 0xfc, 0xd9, 0x2f, 0x7d, 0xc4, 0x65,
	0xe7, 0x67, 0x67, 0x69, 0x3d, 0x86, 0xa6, 0x06, 0xf2, 0x7d, 0xb3, 0xd2, 0x7c, 0x56, 0x9e, 0xce,
	0x2e, 0xe4, 0x96, 0xe6, 0x14, 0x6a, 0x88, 0xab, 0x20, 0x05, 0xa3, 0xc3, 0x0e, 0x22, 0xef, 0x98,
	0x38, 0x07, 0x2d, 0xd3, 0xd2, 0x0f, 0x89, 0x63, 0x4e, 0xca, 0x1e, 0xe5, 0x22, 0xe5, 0xd8, 0xb4,
	0x37, 0xcc, 0x4e, 0x4d, 0xd5, 0x4a, 0x67, 0x4b, 0xc8, 0xb9, 0xf0, 0xca, 0xf3, 0xb8, 0x25, 0x56,
	0xe0, 0x15, 0x8e, 0xf5, 0x3a, 0xf1, 0x0c, 0xaf, 0x97, 0x03, 0x96, 0xe5, 0x8f, 0x23, 0x9f, 0xf9,
	0x68, 0x09, 0x4e, 0x03, 0x0e, 0x2a, 0xd3, 0xd9, 0x5d, 0x59, 0x78, 0x09, 0x4e, 0x1e, 0x74, 0x5e,
	0x9b, 0xa4, 0x88, 0xc9, 0x52, 0x4e, 0x5a, 0xfa, 0xdc, 0x47, 0x7f, 0x43, 0x70, 0x19, 0xfa, 0x43,
	0xf0, 0x2d, 0xaa, 0x56, 0xe4, 0x79, 0x10, 0x83, 0x72, 0x66, 0x82, 0x9f, 0x62, 0x85, 0x1e, 0xf4,
	0x19, 0xb3, 0x52, 0x9b, 0x83, 0x33, 0xe1, 0x4a, 0x6b, 0x74, 0x85, 0x26, 0xa6, 0x0e, 0x7f, 0x40,
	0x30, 0x14, 0xca, 0xe7, 0xa6, 0x3e, 0x99, 0xfa, 0x00, 0xc1, 0xaf, 0x10, 0xa4, 0xe1, 0x5c, 0x67,
	0x57, 0x64, 0x58, 0x82, 0x4a, 0xb6, 0xa6, 0x96, 0x8a, 0xe1, 0x8a, 0x1c, 0xdd, 0xb8, 0x76, 0x13,
	0x66, 0x20, 0xfd, 0x74, 0x4b, 0xd3, 0x72, 0x4d, 0x9d, 0xb4, 0x03, 0xae, 0xc2, 0x24, 0x24, 0x0f,
	0x03, 0x88, 0x41, 0x05, 0x40, 0xcb, 0xac, 0x77, 0x23, 0xb8, 0x91, 0x7f, 0x1d, 0xa6, 0x9e, 0xa7,
	0x3e, 0xe1, 0x2c, 0x12, 0xf6, 0x7d, 0x94, 0xa8, 0xfb, 0x88, 0x6f, 0xf8, 0x88, 0xbb, 0x24, 0x65,
	0x67, 0x83, 0x11, 0x54, 0xe0, 0xf8, 0x98, 0x10, 0x2f, 0x70, 0x7c, 0x5c, 0xe8, 0x2d, 0x70, 0x7c,
	0xaf, 0xc0, 0x17, 0x38, 0x9e, 0x17, 0x12, 0xe3, 0x1f, 0x44, 0xe0, 0x44, 0x97, 0xfd, 0x81, 0x75,
	0xe8, 0x6f, 0xcf, 0x62, 0xb8, 0xe5, 0xfe, 0xef, 0x05, 0xb6, 0x5c, 0xb7, 0x89, 0x4b, 0x15, 0x80,
	0x7b, 0x70, 0x0b, 0xdf, 0x05, 0x7c, 0xb4, 0x22, 0xe1, 0xe1, 0xfb, 0x6a, 0xf3, 0xfd, 0xb4, 0xf5,
	0x61, 0x64, 0xd2, 0xb9, 0x28, 0x5f, 0x78, 0x2f, 0x1d, 0x18, 0x3e, 0xeb, 0xdb, 0x88, 0xd0, 0x24,
	0x0e, 0x42, 0xb8, 0xaa, 0xe7, 0xcf, 0x40, 0xbc, 0x4d, 0x46, 0xa2, 0xba, 0x8f, 0xa2, 0x74, 0x60,
	0x67, 0x25, 0xb9, 0xc0, 0xf1, 0x51, 0x81, 0x1b, 0xff, 0x6b, 0x04, 0x4e, 0x3f, 0x25, 0x70, 0xbc,
	0x01, 0x5c, 0xdb, 0x60, 0x78, 0xad, 0xf5, 0xee, 0xec, 0x70, 0x02, 0xfa, 0x01, 0xd1, 0x31, 0x32,
	0xbc, 0x0c, 0xfd, 0x6a, 0xd5, 0xb3, 0x0d, 0x62, 0x11, 0x7a, 0xd6, 0x85, 0x5a, 0xea, 0x69, 0x7b,
	0xab, 0xc3, 0x16, 0x4b, 0xc0, 0xd1, 0xce, 0x0e, 0xbf, 0x2b, 0x89, 0xcd, 0x80, 0x62, 0x4e, 0xf4,
	0xfb, 0xd6, 0xcc, 0xfa, 0x7d, 0xe4, 0xac, 0xc2, 0xac, 0xf0, 0xdb, 0xcc, 0x7a, 0x81, 0xa9, 0xab,
	0x44, 0xfe, 0xb5, 0xbf, 0x3f, 0x48, 0xeb, 0xa4, 0x6c, 0x67, 0x25, 0x8f, 0xb8, 0x9e, 0xa4, 0x39,
	0x9e, 0xe4, 0x7a, 0xaa, 0x61, 0x5a, 0x86, 0xe4, 0xda, 0xdb, 0xde, 0x96, 0x6a, 0xdd, 0x2d, 0x96,
	0x89, 0x26, 0x55, 0x1c, 0x5b, 0xa7, 0x62, 0xa6, 0x8d, 0xfc, 0x61, 0x04, 0x31, 0xca, 0x85, 0xe5,
	0xf8, 0x3f, 0x5f, 0xa7, 0xb9, 0xcb, 0x27, 0xa1, 0x8f, 0x3e, 0xcc, 0x61, 0x89, 0x8e, 0x02, 0x89,
	0x2e, 0x07, 0x42, 0x28, 0xff, 0x08, 0xd5, 0xbf, 0x4e, 0xf6, 0x7c, 0xf1, 0x75, 0xb2, 0xe7, 0xbb,
	0xaf, 0x93, 0xe8, 0x61, 0x23, 0x89, 0x3e, 0x6e, 0x24, 0xd1, 0x5f, 0x1a, 0x49, 0x54, 0x6f, 0x24,
	0xd1, 0x17, 0x8d, 0x24, 0xfa, 0xaa, 0x91, 0x44, 0xdf, 0x34, 0x92, 0x3d, 0xdf, 0x35, 0x92, 0xe8,
	0xc3, 0x27, 0xc9, 0x9e, 0xfd, 0x27, 0x49, 0x54, 0x7f, 0x92, 0xec, 0xf9, 0xe2, 0x49, 0xb2, 0xe7,
	0xce, 0x3b, 0x86, 0x5d, 0xb9, 0x6b, 0x64, 0x6a, 0x76, 0xc9, 0x23, 0x8e, 0xa3, 0x66, 0xaa, 0xee,
	0x0c, 0xbb, 0xa0, 0x87, 0xc6, 0x74, 0xc5, 0xb1, 0x6b, 0xa6, 0x4e, 0x9c, 0xe9, 0xe6, 0xf2, 0x4c,
	0x65, 0xcb, 0xb0, 0x67, 0xc8, 0x3d, 0x2f, 0xfc, 0x4e, 0xf8, 0x8c, 0x2f, 0xb4, 0x5b, 0x71, 0xf6,
	0xf1, 0x30, 0xf7, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xed, 0x44, 0x43, 0x34, 0xd2, 0x15, 0x00,
	0x00,
}

func (this *AWSManagedMode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode)
	if !ok {
		that2, ok := that.(AWSManagedMode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AwsRegion != that1.AwsRegion {
		return false
	}
	if that1.ServiceVpcChoice == nil {
		if this.ServiceVpcChoice != nil {
			return false
		}
	} else if this.ServiceVpcChoice == nil {
		return false
	} else if !this.ServiceVpcChoice.Equal(that1.ServiceVpcChoice) {
		return false
	}
	if !this.AwsCred.Equal(that1.AwsCred) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.InstanceType != that1.InstanceType {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	if that1.SecurityGroupChoice == nil {
		if this.SecurityGroupChoice != nil {
			return false
		}
	} else if this.SecurityGroupChoice == nil {
		return false
	} else if !this.SecurityGroupChoice.Equal(that1.SecurityGroupChoice) {
		return false
	}
	if that1.EgressGatewayChoice == nil {
		if this.EgressGatewayChoice != nil {
			return false
		}
	} else if this.EgressGatewayChoice == nil {
		return false
	} else if !this.EgressGatewayChoice.Equal(that1.EgressGatewayChoice) {
		return false
	}
	if that1.PrivateConnectivityChoice == nil {
		if this.PrivateConnectivityChoice != nil {
			return false
		}
	} else if this.PrivateConnectivityChoice == nil {
		return false
	} else if !this.PrivateConnectivityChoice.Equal(that1.PrivateConnectivityChoice) {
		return false
	}
	if that1.SiteType == nil {
		if this.SiteType != nil {
			return false
		}
	} else if this.SiteType == nil {
		return false
	} else if !this.SiteType.Equal(that1.SiteType) {
		return false
	}
	if that1.CloudConnectAttachments == nil {
		if this.CloudConnectAttachments != nil {
			return false
		}
	} else if this.CloudConnectAttachments == nil {
		return false
	} else if !this.CloudConnectAttachments.Equal(that1.CloudConnectAttachments) {
		return false
	}
	return true
}
func (this *AWSManagedMode_NewVpc) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_NewVpc)
	if !ok {
		that2, ok := that.(AWSManagedMode_NewVpc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVpc.Equal(that1.NewVpc) {
		return false
	}
	return true
}
func (this *AWSManagedMode_VpcId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_VpcId)
	if !ok {
		that2, ok := that.(AWSManagedMode_VpcId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	return true
}
func (this *AWSManagedMode_F5XcSecurityGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_F5XcSecurityGroup)
	if !ok {
		that2, ok := that.(AWSManagedMode_F5XcSecurityGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.F5XcSecurityGroup.Equal(that1.F5XcSecurityGroup) {
		return false
	}
	return true
}
func (this *AWSManagedMode_CustomSecurityGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_CustomSecurityGroup)
	if !ok {
		that2, ok := that.(AWSManagedMode_CustomSecurityGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomSecurityGroup.Equal(that1.CustomSecurityGroup) {
		return false
	}
	return true
}
func (this *AWSManagedMode_EgressGatewayDefault) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_EgressGatewayDefault)
	if !ok {
		that2, ok := that.(AWSManagedMode_EgressGatewayDefault)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EgressGatewayDefault.Equal(that1.EgressGatewayDefault) {
		return false
	}
	return true
}
func (this *AWSManagedMode_EgressNatGw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_EgressNatGw)
	if !ok {
		that2, ok := that.(AWSManagedMode_EgressNatGw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EgressNatGw.Equal(that1.EgressNatGw) {
		return false
	}
	return true
}
func (this *AWSManagedMode_EgressVirtualPrivateGateway) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_EgressVirtualPrivateGateway)
	if !ok {
		that2, ok := that.(AWSManagedMode_EgressVirtualPrivateGateway)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EgressVirtualPrivateGateway.Equal(that1.EgressVirtualPrivateGateway) {
		return false
	}
	return true
}
func (this *AWSManagedMode_PrivateConnectivityDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_PrivateConnectivityDisabled)
	if !ok {
		that2, ok := that.(AWSManagedMode_PrivateConnectivityDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrivateConnectivityDisabled.Equal(that1.PrivateConnectivityDisabled) {
		return false
	}
	return true
}
func (this *AWSManagedMode_PrivateConnectivity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_PrivateConnectivity)
	if !ok {
		that2, ok := that.(AWSManagedMode_PrivateConnectivity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrivateConnectivity.Equal(that1.PrivateConnectivity) {
		return false
	}
	return true
}
func (this *AWSManagedMode_SingleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_SingleInterface)
	if !ok {
		that2, ok := that.(AWSManagedMode_SingleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SingleInterface.Equal(that1.SingleInterface) {
		return false
	}
	return true
}
func (this *AWSManagedMode_MultipleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_MultipleInterface)
	if !ok {
		that2, ok := that.(AWSManagedMode_MultipleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MultipleInterface.Equal(that1.MultipleInterface) {
		return false
	}
	return true
}
func (this *AWSManagedMode_Disabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_Disabled)
	if !ok {
		that2, ok := that.(AWSManagedMode_Disabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disabled.Equal(that1.Disabled) {
		return false
	}
	return true
}
func (this *AWSManagedMode_Tgw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedMode_Tgw)
	if !ok {
		that2, ok := that.(AWSManagedMode_Tgw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Tgw.Equal(that1.Tgw) {
		return false
	}
	return true
}
func (this *TGWType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TGWType)
	if !ok {
		that2, ok := that.(TGWType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.TgwChoice == nil {
		if this.TgwChoice != nil {
			return false
		}
	} else if this.TgwChoice == nil {
		return false
	} else if !this.TgwChoice.Equal(that1.TgwChoice) {
		return false
	}
	if that1.TgwCidrChoice == nil {
		if this.TgwCidrChoice != nil {
			return false
		}
	} else if this.TgwCidrChoice == nil {
		return false
	} else if !this.TgwCidrChoice.Equal(that1.TgwCidrChoice) {
		return false
	}
	return true
}
func (this *TGWType_NewTgw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TGWType_NewTgw)
	if !ok {
		that2, ok := that.(TGWType_NewTgw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewTgw.Equal(that1.NewTgw) {
		return false
	}
	return true
}
func (this *TGWType_ExistingTgw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TGWType_ExistingTgw)
	if !ok {
		that2, ok := that.(TGWType_ExistingTgw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingTgw.Equal(that1.ExistingTgw) {
		return false
	}
	return true
}
func (this *TGWType_ReservedTgwCidr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TGWType_ReservedTgwCidr)
	if !ok {
		that2, ok := that.(TGWType_ReservedTgwCidr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ReservedTgwCidr.Equal(that1.ReservedTgwCidr) {
		return false
	}
	return true
}
func (this *TGWType_TgwCidr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TGWType_TgwCidr)
	if !ok {
		that2, ok := that.(TGWType_TgwCidr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TgwCidr.Equal(that1.TgwCidr) {
		return false
	}
	return true
}
func (this *SingleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SingleInterface)
	if !ok {
		that2, ok := that.(SingleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeList.Equal(that1.NodeList) {
		return false
	}
	return true
}
func (this *MultipleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultipleInterface)
	if !ok {
		that2, ok := that.(MultipleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeList.Equal(that1.NodeList) {
		return false
	}
	return true
}
func (this *AWSManagedNodeList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedNodeList)
	if !ok {
		that2, ok := that.(AWSManagedNodeList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.NodeList) != len(that1.NodeList) {
		return false
	}
	for i := range this.NodeList {
		if !this.NodeList[i].Equal(that1.NodeList[i]) {
			return false
		}
	}
	return true
}
func (this *AWSManagedNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSManagedNode)
	if !ok {
		that2, ok := that.(AWSManagedNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.AwsAzName != that1.AwsAzName {
		return false
	}
	if len(this.InterfaceList) != len(that1.InterfaceList) {
		return false
	}
	for i := range this.InterfaceList {
		if !this.InterfaceList[i].Equal(that1.InterfaceList[i]) {
			return false
		}
	}
	return true
}
func (this *AWSOrchestratedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSOrchestratedInterface)
	if !ok {
		that2, ok := that.(AWSOrchestratedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	if !this.NetworkOption.Equal(that1.NetworkOption) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if that1.SiteToSiteConnectivityInterfaceChoice == nil {
		if this.SiteToSiteConnectivityInterfaceChoice != nil {
			return false
		}
	} else if this.SiteToSiteConnectivityInterfaceChoice == nil {
		return false
	} else if !this.SiteToSiteConnectivityInterfaceChoice.Equal(that1.SiteToSiteConnectivityInterfaceChoice) {
		return false
	}
	return true
}
func (this *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled)
	if !ok {
		that2, ok := that.(AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteToSiteConnectivityInterfaceDisabled.Equal(that1.SiteToSiteConnectivityInterfaceDisabled) {
		return false
	}
	return true
}
func (this *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled)
	if !ok {
		that2, ok := that.(AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteToSiteConnectivityInterfaceEnabled.Equal(that1.SiteToSiteConnectivityInterfaceEnabled) {
		return false
	}
	return true
}
func (this *AWSSubnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSSubnetChoiceType)
	if !ok {
		that2, ok := that.(AWSSubnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AWSSubnetChoiceType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSSubnetChoiceType_SubnetParam)
	if !ok {
		that2, ok := that.(AWSSubnetChoiceType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *AWSSubnetChoiceType_ExistingSubnetId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSSubnetChoiceType_ExistingSubnetId)
	if !ok {
		that2, ok := that.(AWSSubnetChoiceType_ExistingSubnetId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExistingSubnetId != that1.ExistingSubnetId {
		return false
	}
	return true
}
func (this *AWSCloudSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSCloudSubnetParamType)
	if !ok {
		that2, ok := that.(AWSCloudSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NameChoice == nil {
		if this.NameChoice != nil {
			return false
		}
	} else if this.NameChoice == nil {
		return false
	} else if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	if this.Ipv4 != that1.Ipv4 {
		return false
	}
	if this.Ipv6 != that1.Ipv6 {
		return false
	}
	return true
}
func (this *AWSCloudSubnetParamType_Name) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSCloudSubnetParamType_Name)
	if !ok {
		that2, ok := that.(AWSCloudSubnetParamType_Name)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *AWSCloudSubnetParamType_Autogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSCloudSubnetParamType_Autogenerate)
	if !ok {
		that2, ok := that.(AWSCloudSubnetParamType_Autogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Autogenerate.Equal(that1.Autogenerate) {
		return false
	}
	return true
}
func (this *AWSManagedMode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&securemesh_site_v2.AWSManagedMode{")
	s = append(s, "AwsRegion: "+fmt.Sprintf("%#v", this.AwsRegion)+",\n")
	if this.ServiceVpcChoice != nil {
		s = append(s, "ServiceVpcChoice: "+fmt.Sprintf("%#v", this.ServiceVpcChoice)+",\n")
	}
	if this.AwsCred != nil {
		s = append(s, "AwsCred: "+fmt.Sprintf("%#v", this.AwsCred)+",\n")
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "InstanceType: "+fmt.Sprintf("%#v", this.InstanceType)+",\n")
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	if this.SecurityGroupChoice != nil {
		s = append(s, "SecurityGroupChoice: "+fmt.Sprintf("%#v", this.SecurityGroupChoice)+",\n")
	}
	if this.EgressGatewayChoice != nil {
		s = append(s, "EgressGatewayChoice: "+fmt.Sprintf("%#v", this.EgressGatewayChoice)+",\n")
	}
	if this.PrivateConnectivityChoice != nil {
		s = append(s, "PrivateConnectivityChoice: "+fmt.Sprintf("%#v", this.PrivateConnectivityChoice)+",\n")
	}
	if this.SiteType != nil {
		s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	}
	if this.CloudConnectAttachments != nil {
		s = append(s, "CloudConnectAttachments: "+fmt.Sprintf("%#v", this.CloudConnectAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSManagedMode_NewVpc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_NewVpc{` +
		`NewVpc:` + fmt.Sprintf("%#v", this.NewVpc) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_VpcId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_VpcId{` +
		`VpcId:` + fmt.Sprintf("%#v", this.VpcId) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_F5XcSecurityGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_F5XcSecurityGroup{` +
		`F5XcSecurityGroup:` + fmt.Sprintf("%#v", this.F5XcSecurityGroup) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_CustomSecurityGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_CustomSecurityGroup{` +
		`CustomSecurityGroup:` + fmt.Sprintf("%#v", this.CustomSecurityGroup) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_EgressGatewayDefault) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_EgressGatewayDefault{` +
		`EgressGatewayDefault:` + fmt.Sprintf("%#v", this.EgressGatewayDefault) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_EgressNatGw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_EgressNatGw{` +
		`EgressNatGw:` + fmt.Sprintf("%#v", this.EgressNatGw) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_EgressVirtualPrivateGateway) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_EgressVirtualPrivateGateway{` +
		`EgressVirtualPrivateGateway:` + fmt.Sprintf("%#v", this.EgressVirtualPrivateGateway) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_PrivateConnectivityDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_PrivateConnectivityDisabled{` +
		`PrivateConnectivityDisabled:` + fmt.Sprintf("%#v", this.PrivateConnectivityDisabled) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_PrivateConnectivity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_PrivateConnectivity{` +
		`PrivateConnectivity:` + fmt.Sprintf("%#v", this.PrivateConnectivity) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_SingleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_SingleInterface{` +
		`SingleInterface:` + fmt.Sprintf("%#v", this.SingleInterface) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_MultipleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_MultipleInterface{` +
		`MultipleInterface:` + fmt.Sprintf("%#v", this.MultipleInterface) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_Disabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_Disabled{` +
		`Disabled:` + fmt.Sprintf("%#v", this.Disabled) + `}`}, ", ")
	return s
}
func (this *AWSManagedMode_Tgw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSManagedMode_Tgw{` +
		`Tgw:` + fmt.Sprintf("%#v", this.Tgw) + `}`}, ", ")
	return s
}
func (this *TGWType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&securemesh_site_v2.TGWType{")
	if this.TgwChoice != nil {
		s = append(s, "TgwChoice: "+fmt.Sprintf("%#v", this.TgwChoice)+",\n")
	}
	if this.TgwCidrChoice != nil {
		s = append(s, "TgwCidrChoice: "+fmt.Sprintf("%#v", this.TgwCidrChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TGWType_NewTgw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.TGWType_NewTgw{` +
		`NewTgw:` + fmt.Sprintf("%#v", this.NewTgw) + `}`}, ", ")
	return s
}
func (this *TGWType_ExistingTgw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.TGWType_ExistingTgw{` +
		`ExistingTgw:` + fmt.Sprintf("%#v", this.ExistingTgw) + `}`}, ", ")
	return s
}
func (this *TGWType_ReservedTgwCidr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.TGWType_ReservedTgwCidr{` +
		`ReservedTgwCidr:` + fmt.Sprintf("%#v", this.ReservedTgwCidr) + `}`}, ", ")
	return s
}
func (this *TGWType_TgwCidr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.TGWType_TgwCidr{` +
		`TgwCidr:` + fmt.Sprintf("%#v", this.TgwCidr) + `}`}, ", ")
	return s
}
func (this *SingleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&securemesh_site_v2.SingleInterface{")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MultipleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&securemesh_site_v2.MultipleInterface{")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSManagedNodeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&securemesh_site_v2.AWSManagedNodeList{")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSManagedNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&securemesh_site_v2.AWSManagedNode{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "AwsAzName: "+fmt.Sprintf("%#v", this.AwsAzName)+",\n")
	if this.InterfaceList != nil {
		s = append(s, "InterfaceList: "+fmt.Sprintf("%#v", this.InterfaceList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSOrchestratedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&securemesh_site_v2.AWSOrchestratedInterface{")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	if this.NetworkOption != nil {
		s = append(s, "NetworkOption: "+fmt.Sprintf("%#v", this.NetworkOption)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	if this.SiteToSiteConnectivityInterfaceChoice != nil {
		s = append(s, "SiteToSiteConnectivityInterfaceChoice: "+fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled{` +
		`SiteToSiteConnectivityInterfaceDisabled:` + fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceDisabled) + `}`}, ", ")
	return s
}
func (this *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled{` +
		`SiteToSiteConnectivityInterfaceEnabled:` + fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceEnabled) + `}`}, ", ")
	return s
}
func (this *AWSSubnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&securemesh_site_v2.AWSSubnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSSubnetChoiceType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSSubnetChoiceType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *AWSSubnetChoiceType_ExistingSubnetId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSSubnetChoiceType_ExistingSubnetId{` +
		`ExistingSubnetId:` + fmt.Sprintf("%#v", this.ExistingSubnetId) + `}`}, ", ")
	return s
}
func (this *AWSCloudSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&securemesh_site_v2.AWSCloudSubnetParamType{")
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "Ipv4: "+fmt.Sprintf("%#v", this.Ipv4)+",\n")
	s = append(s, "Ipv6: "+fmt.Sprintf("%#v", this.Ipv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSCloudSubnetParamType_Name) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSCloudSubnetParamType_Name{` +
		`Name:` + fmt.Sprintf("%#v", this.Name) + `}`}, ", ")
	return s
}
func (this *AWSCloudSubnetParamType_Autogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AWSCloudSubnetParamType_Autogenerate{` +
		`Autogenerate:` + fmt.Sprintf("%#v", this.Autogenerate) + `}`}, ", ")
	return s
}
func valueToGoStringAwsTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSManagedMode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSManagedMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudConnectAttachments != nil {
		{
			size := m.CloudConnectAttachments.Size()
			i -= size
			if _, err := m.CloudConnectAttachments.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SiteType != nil {
		{
			size := m.SiteType.Size()
			i -= size
			if _, err := m.SiteType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PrivateConnectivityChoice != nil {
		{
			size := m.PrivateConnectivityChoice.Size()
			i -= size
			if _, err := m.PrivateConnectivityChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EgressGatewayChoice != nil {
		{
			size := m.EgressGatewayChoice.Size()
			i -= size
			if _, err := m.EgressGatewayChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SecurityGroupChoice != nil {
		{
			size := m.SecurityGroupChoice.Size()
			i -= size
			if _, err := m.SecurityGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DiskSize != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.DiskSize))
		i--
		dAtA[i] = 0x58
	}
	if len(m.InstanceType) > 0 {
		i -= len(m.InstanceType)
		copy(dAtA[i:], m.InstanceType)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.InstanceType)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAwsTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintAwsTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAwsTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.AwsCred != nil {
		{
			size, err := m.AwsCred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ServiceVpcChoice != nil {
		{
			size := m.ServiceVpcChoice.Size()
			i -= size
			if _, err := m.ServiceVpcChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AwsRegion) > 0 {
		i -= len(m.AwsRegion)
		copy(dAtA[i:], m.AwsRegion)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.AwsRegion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSManagedMode_NewVpc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_NewVpc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewVpc != nil {
		{
			size, err := m.NewVpc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_VpcId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_VpcId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.VpcId)
	copy(dAtA[i:], m.VpcId)
	i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.VpcId)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_F5XcSecurityGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_F5XcSecurityGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F5XcSecurityGroup != nil {
		{
			size, err := m.F5XcSecurityGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_CustomSecurityGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_CustomSecurityGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomSecurityGroup != nil {
		{
			size, err := m.CustomSecurityGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_EgressGatewayDefault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_EgressGatewayDefault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EgressGatewayDefault != nil {
		{
			size, err := m.EgressGatewayDefault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_EgressNatGw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_EgressNatGw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EgressNatGw != nil {
		{
			size, err := m.EgressNatGw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_EgressVirtualPrivateGateway) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_EgressVirtualPrivateGateway) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EgressVirtualPrivateGateway != nil {
		{
			size, err := m.EgressVirtualPrivateGateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_PrivateConnectivityDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_PrivateConnectivityDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrivateConnectivityDisabled != nil {
		{
			size, err := m.PrivateConnectivityDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_PrivateConnectivity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_PrivateConnectivity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrivateConnectivity != nil {
		{
			size, err := m.PrivateConnectivity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_SingleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_SingleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SingleInterface != nil {
		{
			size, err := m.SingleInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_MultipleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_MultipleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultipleInterface != nil {
		{
			size, err := m.MultipleInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_Disabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_Disabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disabled != nil {
		{
			size, err := m.Disabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *AWSManagedMode_Tgw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedMode_Tgw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tgw != nil {
		{
			size, err := m.Tgw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *TGWType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TGWType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGWType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TgwCidrChoice != nil {
		{
			size := m.TgwCidrChoice.Size()
			i -= size
			if _, err := m.TgwCidrChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TgwChoice != nil {
		{
			size := m.TgwChoice.Size()
			i -= size
			if _, err := m.TgwChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TGWType_NewTgw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGWType_NewTgw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewTgw != nil {
		{
			size, err := m.NewTgw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TGWType_ExistingTgw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGWType_ExistingTgw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExistingTgw != nil {
		{
			size, err := m.ExistingTgw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TGWType_ReservedTgwCidr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGWType_ReservedTgwCidr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReservedTgwCidr != nil {
		{
			size, err := m.ReservedTgwCidr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *TGWType_TgwCidr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TGWType_TgwCidr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TgwCidr != nil {
		{
			size, err := m.TgwCidr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SingleInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeList != nil {
		{
			size, err := m.NodeList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultipleInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultipleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultipleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeList != nil {
		{
			size, err := m.NodeList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSManagedNodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSManagedNodeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedNodeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeList) > 0 {
		for iNdEx := len(m.NodeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSManagedNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSManagedNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSManagedNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceList) > 0 {
		for iNdEx := len(m.InterfaceList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAwsTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AwsAzName) > 0 {
		i -= len(m.AwsAzName)
		copy(dAtA[i:], m.AwsAzName)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.AwsAzName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSOrchestratedInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSOrchestratedInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSOrchestratedInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceChoice != nil {
		{
			size := m.SiteToSiteConnectivityInterfaceChoice.Size()
			i -= size
			if _, err := m.SiteToSiteConnectivityInterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Mtu != 0 {
		i = encodeVarintAwsTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x18
	}
	if m.NetworkOption != nil {
		{
			size, err := m.NetworkOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteToSiteConnectivityInterfaceDisabled != nil {
		{
			size, err := m.SiteToSiteConnectivityInterfaceDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteToSiteConnectivityInterfaceEnabled != nil {
		{
			size, err := m.SiteToSiteConnectivityInterfaceEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *AWSSubnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSubnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSubnetChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSSubnetChoiceType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSubnetChoiceType_SubnetParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AWSSubnetChoiceType_ExistingSubnetId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSubnetChoiceType_ExistingSubnetId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExistingSubnetId)
	copy(dAtA[i:], m.ExistingSubnetId)
	i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.ExistingSubnetId)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *AWSCloudSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSCloudSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSCloudSubnetParamType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6) > 0 {
		i -= len(m.Ipv6)
		copy(dAtA[i:], m.Ipv6)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.Ipv6)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ipv4) > 0 {
		i -= len(m.Ipv4)
		copy(dAtA[i:], m.Ipv4)
		i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.Ipv4)))
		i--
		dAtA[i] = 0x22
	}
	if m.NameChoice != nil {
		{
			size := m.NameChoice.Size()
			i -= size
			if _, err := m.NameChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSCloudSubnetParamType_Name) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSCloudSubnetParamType_Name) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintAwsTypes(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *AWSCloudSubnetParamType_Autogenerate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSCloudSubnetParamType_Autogenerate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Autogenerate != nil {
		{
			size, err := m.Autogenerate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAwsTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func encodeVarintAwsTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovAwsTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AWSManagedMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AwsRegion)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.ServiceVpcChoice != nil {
		n += m.ServiceVpcChoice.Size()
	}
	if m.AwsCred != nil {
		l = m.AwsCred.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAwsTypes(uint64(len(k))) + 1 + len(v) + sovAwsTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAwsTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.InstanceType)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovAwsTypes(uint64(m.DiskSize))
	}
	if m.SecurityGroupChoice != nil {
		n += m.SecurityGroupChoice.Size()
	}
	if m.EgressGatewayChoice != nil {
		n += m.EgressGatewayChoice.Size()
	}
	if m.PrivateConnectivityChoice != nil {
		n += m.PrivateConnectivityChoice.Size()
	}
	if m.SiteType != nil {
		n += m.SiteType.Size()
	}
	if m.CloudConnectAttachments != nil {
		n += m.CloudConnectAttachments.Size()
	}
	return n
}

func (m *AWSManagedMode_NewVpc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewVpc != nil {
		l = m.NewVpc.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_VpcId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VpcId)
	n += 1 + l + sovAwsTypes(uint64(l))
	return n
}
func (m *AWSManagedMode_F5XcSecurityGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F5XcSecurityGroup != nil {
		l = m.F5XcSecurityGroup.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_CustomSecurityGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomSecurityGroup != nil {
		l = m.CustomSecurityGroup.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_EgressGatewayDefault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EgressGatewayDefault != nil {
		l = m.EgressGatewayDefault.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_EgressNatGw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EgressNatGw != nil {
		l = m.EgressNatGw.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_EgressVirtualPrivateGateway) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EgressVirtualPrivateGateway != nil {
		l = m.EgressVirtualPrivateGateway.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_PrivateConnectivityDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrivateConnectivityDisabled != nil {
		l = m.PrivateConnectivityDisabled.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_PrivateConnectivity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrivateConnectivity != nil {
		l = m.PrivateConnectivity.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_SingleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SingleInterface != nil {
		l = m.SingleInterface.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_MultipleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultipleInterface != nil {
		l = m.MultipleInterface.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_Disabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled != nil {
		l = m.Disabled.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSManagedMode_Tgw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tgw != nil {
		l = m.Tgw.Size()
		n += 2 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *TGWType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TgwChoice != nil {
		n += m.TgwChoice.Size()
	}
	if m.TgwCidrChoice != nil {
		n += m.TgwCidrChoice.Size()
	}
	return n
}

func (m *TGWType_NewTgw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewTgw != nil {
		l = m.NewTgw.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *TGWType_ExistingTgw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExistingTgw != nil {
		l = m.ExistingTgw.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *TGWType_ReservedTgwCidr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReservedTgwCidr != nil {
		l = m.ReservedTgwCidr.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *TGWType_TgwCidr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TgwCidr != nil {
		l = m.TgwCidr.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *SingleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeList != nil {
		l = m.NodeList.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}

func (m *MultipleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeList != nil {
		l = m.NodeList.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}

func (m *AWSManagedNodeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeList) > 0 {
		for _, e := range m.NodeList {
			l = e.Size()
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSManagedNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.AwsAzName)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if len(m.InterfaceList) > 0 {
		for _, e := range m.InterfaceList {
			l = e.Size()
			n += 1 + l + sovAwsTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSOrchestratedInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.NetworkOption != nil {
		l = m.NetworkOption.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	if m.Mtu != 0 {
		n += 1 + sovAwsTypes(uint64(m.Mtu))
	}
	if m.SiteToSiteConnectivityInterfaceChoice != nil {
		n += m.SiteToSiteConnectivityInterfaceChoice.Size()
	}
	return n
}

func (m *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceDisabled != nil {
		l = m.SiteToSiteConnectivityInterfaceDisabled.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceEnabled != nil {
		l = m.SiteToSiteConnectivityInterfaceEnabled.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSSubnetChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AWSSubnetChoiceType_SubnetParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}
func (m *AWSSubnetChoiceType_ExistingSubnetId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExistingSubnetId)
	n += 1 + l + sovAwsTypes(uint64(l))
	return n
}
func (m *AWSCloudSubnetParamType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NameChoice != nil {
		n += m.NameChoice.Size()
	}
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	l = len(m.Ipv6)
	if l > 0 {
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}

func (m *AWSCloudSubnetParamType_Name) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovAwsTypes(uint64(l))
	return n
}
func (m *AWSCloudSubnetParamType_Autogenerate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Autogenerate != nil {
		l = m.Autogenerate.Size()
		n += 1 + l + sovAwsTypes(uint64(l))
	}
	return n
}

func sovAwsTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAwsTypes(x uint64) (n int) {
	return sovAwsTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSManagedMode) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AWSManagedMode{`,
		`AwsRegion:` + fmt.Sprintf("%v", this.AwsRegion) + `,`,
		`ServiceVpcChoice:` + fmt.Sprintf("%v", this.ServiceVpcChoice) + `,`,
		`AwsCred:` + strings.Replace(fmt.Sprintf("%v", this.AwsCred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`InstanceType:` + fmt.Sprintf("%v", this.InstanceType) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`SecurityGroupChoice:` + fmt.Sprintf("%v", this.SecurityGroupChoice) + `,`,
		`EgressGatewayChoice:` + fmt.Sprintf("%v", this.EgressGatewayChoice) + `,`,
		`PrivateConnectivityChoice:` + fmt.Sprintf("%v", this.PrivateConnectivityChoice) + `,`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`CloudConnectAttachments:` + fmt.Sprintf("%v", this.CloudConnectAttachments) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_NewVpc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_NewVpc{`,
		`NewVpc:` + strings.Replace(fmt.Sprintf("%v", this.NewVpc), "AWSVPCParamsType", "views.AWSVPCParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_VpcId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_VpcId{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_F5XcSecurityGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_F5XcSecurityGroup{`,
		`F5XcSecurityGroup:` + strings.Replace(fmt.Sprintf("%v", this.F5XcSecurityGroup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_CustomSecurityGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_CustomSecurityGroup{`,
		`CustomSecurityGroup:` + strings.Replace(fmt.Sprintf("%v", this.CustomSecurityGroup), "SecurityGroupType", "views.SecurityGroupType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_EgressGatewayDefault) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_EgressGatewayDefault{`,
		`EgressGatewayDefault:` + strings.Replace(fmt.Sprintf("%v", this.EgressGatewayDefault), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_EgressNatGw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_EgressNatGw{`,
		`EgressNatGw:` + strings.Replace(fmt.Sprintf("%v", this.EgressNatGw), "AWSNATGatewaychoiceType", "views.AWSNATGatewaychoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_EgressVirtualPrivateGateway) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_EgressVirtualPrivateGateway{`,
		`EgressVirtualPrivateGateway:` + strings.Replace(fmt.Sprintf("%v", this.EgressVirtualPrivateGateway), "AWSVirtualPrivateGatewaychoiceType", "views.AWSVirtualPrivateGatewaychoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_PrivateConnectivityDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_PrivateConnectivityDisabled{`,
		`PrivateConnectivityDisabled:` + strings.Replace(fmt.Sprintf("%v", this.PrivateConnectivityDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_PrivateConnectivity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_PrivateConnectivity{`,
		`PrivateConnectivity:` + strings.Replace(fmt.Sprintf("%v", this.PrivateConnectivity), "PrivateConnectConfigType", "views.PrivateConnectConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_SingleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_SingleInterface{`,
		`SingleInterface:` + strings.Replace(fmt.Sprintf("%v", this.SingleInterface), "SingleInterface", "SingleInterface", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_MultipleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_MultipleInterface{`,
		`MultipleInterface:` + strings.Replace(fmt.Sprintf("%v", this.MultipleInterface), "MultipleInterface", "MultipleInterface", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_Disabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_Disabled{`,
		`Disabled:` + strings.Replace(fmt.Sprintf("%v", this.Disabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedMode_Tgw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSManagedMode_Tgw{`,
		`Tgw:` + strings.Replace(fmt.Sprintf("%v", this.Tgw), "TGWType", "TGWType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TGWType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TGWType{`,
		`TgwChoice:` + fmt.Sprintf("%v", this.TgwChoice) + `,`,
		`TgwCidrChoice:` + fmt.Sprintf("%v", this.TgwCidrChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TGWType_NewTgw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TGWType_NewTgw{`,
		`NewTgw:` + strings.Replace(fmt.Sprintf("%v", this.NewTgw), "TGWParamsType", "views.TGWParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TGWType_ExistingTgw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TGWType_ExistingTgw{`,
		`ExistingTgw:` + strings.Replace(fmt.Sprintf("%v", this.ExistingTgw), "ExistingTGWType", "views.ExistingTGWType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TGWType_ReservedTgwCidr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TGWType_ReservedTgwCidr{`,
		`ReservedTgwCidr:` + strings.Replace(fmt.Sprintf("%v", this.ReservedTgwCidr), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TGWType_TgwCidr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TGWType_TgwCidr{`,
		`TgwCidr:` + strings.Replace(fmt.Sprintf("%v", this.TgwCidr), "CloudSubnetParamType", "views.CloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SingleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SingleInterface{`,
		`NodeList:` + strings.Replace(this.NodeList.String(), "AWSManagedNodeList", "AWSManagedNodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultipleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MultipleInterface{`,
		`NodeList:` + strings.Replace(this.NodeList.String(), "AWSManagedNodeList", "AWSManagedNodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedNodeList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodeList := "[]*AWSManagedNode{"
	for _, f := range this.NodeList {
		repeatedStringForNodeList += strings.Replace(f.String(), "AWSManagedNode", "AWSManagedNode", 1) + ","
	}
	repeatedStringForNodeList += "}"
	s := strings.Join([]string{`&AWSManagedNodeList{`,
		`NodeList:` + repeatedStringForNodeList + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSManagedNode) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterfaceList := "[]*AWSOrchestratedInterface{"
	for _, f := range this.InterfaceList {
		repeatedStringForInterfaceList += strings.Replace(f.String(), "AWSOrchestratedInterface", "AWSOrchestratedInterface", 1) + ","
	}
	repeatedStringForInterfaceList += "}"
	s := strings.Join([]string{`&AWSManagedNode{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`AwsAzName:` + fmt.Sprintf("%v", this.AwsAzName) + `,`,
		`InterfaceList:` + repeatedStringForInterfaceList + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSOrchestratedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSOrchestratedInterface{`,
		`Subnet:` + strings.Replace(this.Subnet.String(), "AWSSubnetChoiceType", "AWSSubnetChoiceType", 1) + `,`,
		`NetworkOption:` + strings.Replace(fmt.Sprintf("%v", this.NetworkOption), "NetworkSelectType", "views.NetworkSelectType", 1) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`SiteToSiteConnectivityInterfaceChoice:` + fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled{`,
		`SiteToSiteConnectivityInterfaceDisabled:` + strings.Replace(fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled{`,
		`SiteToSiteConnectivityInterfaceEnabled:` + strings.Replace(fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceEnabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSSubnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSSubnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSSubnetChoiceType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSSubnetChoiceType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "AWSCloudSubnetParamType", "AWSCloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSSubnetChoiceType_ExistingSubnetId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSSubnetChoiceType_ExistingSubnetId{`,
		`ExistingSubnetId:` + fmt.Sprintf("%v", this.ExistingSubnetId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSCloudSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSCloudSubnetParamType{`,
		`NameChoice:` + fmt.Sprintf("%v", this.NameChoice) + `,`,
		`Ipv4:` + fmt.Sprintf("%v", this.Ipv4) + `,`,
		`Ipv6:` + fmt.Sprintf("%v", this.Ipv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSCloudSubnetParamType_Name) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSCloudSubnetParamType_Name{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSCloudSubnetParamType_Autogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSCloudSubnetParamType_Autogenerate{`,
		`Autogenerate:` + strings.Replace(fmt.Sprintf("%v", this.Autogenerate), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAwsTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSManagedMode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSManagedMode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSManagedMode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.AWSVPCParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServiceVpcChoice = &AWSManagedMode_NewVpc{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceVpcChoice = &AWSManagedMode_VpcId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsCred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AwsCred == nil {
				m.AwsCred = &views.ObjectRefType{}
			}
			if err := m.AwsCred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAwsTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAwsTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAwsTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAwsTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAwsTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAwsTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAwsTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAwsTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAwsTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F5XcSecurityGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecurityGroupChoice = &AWSManagedMode_F5XcSecurityGroup{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomSecurityGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.SecurityGroupType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecurityGroupChoice = &AWSManagedMode_CustomSecurityGroup{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressGatewayDefault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EgressGatewayChoice = &AWSManagedMode_EgressGatewayDefault{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressNatGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.AWSNATGatewaychoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EgressGatewayChoice = &AWSManagedMode_EgressNatGw{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressVirtualPrivateGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.AWSVirtualPrivateGatewaychoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EgressGatewayChoice = &AWSManagedMode_EgressVirtualPrivateGateway{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateConnectivityDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrivateConnectivityChoice = &AWSManagedMode_PrivateConnectivityDisabled{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateConnectivity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.PrivateConnectConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrivateConnectivityChoice = &AWSManagedMode_PrivateConnectivity{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SingleInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteType = &AWSManagedMode_SingleInterface{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MultipleInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteType = &AWSManagedMode_MultipleInterface{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudConnectAttachments = &AWSManagedMode_Disabled{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TGWType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudConnectAttachments = &AWSManagedMode_Tgw{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TGWType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TGWType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TGWType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.TGWParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TgwChoice = &TGWType_NewTgw{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingTgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ExistingTGWType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TgwChoice = &TGWType_ExistingTgw{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedTgwCidr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TgwCidrChoice = &TGWType_ReservedTgwCidr{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwCidr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.CloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TgwCidrChoice = &TGWType_TgwCidr{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeList == nil {
				m.NodeList = &AWSManagedNodeList{}
			}
			if err := m.NodeList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultipleInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultipleInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultipleInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeList == nil {
				m.NodeList = &AWSManagedNodeList{}
			}
			if err := m.NodeList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSManagedNodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSManagedNodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSManagedNodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeList = append(m.NodeList, &AWSManagedNode{})
			if err := m.NodeList[len(m.NodeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSManagedNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSManagedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSManagedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceList = append(m.InterfaceList, &AWSOrchestratedInterface{})
			if err := m.InterfaceList[len(m.InterfaceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSOrchestratedInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSOrchestratedInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSOrchestratedInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &AWSSubnetChoiceType{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkOption == nil {
				m.NetworkOption = &views.NetworkSelectType{}
			}
			if err := m.NetworkOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteConnectivityInterfaceDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteToSiteConnectivityInterfaceChoice = &AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteConnectivityInterfaceEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteToSiteConnectivityInterfaceChoice = &AWSOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSubnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSubnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSubnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSCloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AWSSubnetChoiceType_SubnetParam{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &AWSSubnetChoiceType_ExistingSubnetId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSCloudSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSCloudSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSCloudSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameChoice = &AWSCloudSubnetParamType_Name{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NameChoice = &AWSCloudSubnetParamType_Autogenerate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAwsTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAwsTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAwsTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAwsTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAwsTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAwsTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAwsTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAwsTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAwsTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAwsTypes = fmt.Errorf("proto: unexpected end of group")
)
