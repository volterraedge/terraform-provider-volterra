// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/securemesh_site_v2/gcp_types.proto

package securemesh_site_v2

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GCPManagedMode
//
// x-displayName: "Managed By F5XC"
// F5 Distributed Cloud will automate all provisioning (ex: node bringup, cloud route table addition) for this site.
type GCPManagedMode struct {
	// GCP Region
	//
	// x-displayName: "GCP Region"
	// x-example: "us-east-1"
	// x-required
	// Select the GCP Region where you want to deploy F5 Distributed Cloud Customer Edge site.
	GcpRegion string `protobuf:"bytes,1,opt,name=gcp_region,json=gcpRegion,proto3" json:"gcp_region,omitempty"`
	// Automatic Deployment
	//
	// x-displayName: "Credential Reference"
	// x-required
	// Select the GCP cloud credential object using which GCP cloud resources are to be deployed.
	GcpCred *views.ObjectRefType `protobuf:"bytes,2,opt,name=gcp_cred,json=gcpCred,proto3" json:"gcp_cred,omitempty"`
	// GCP Tags
	//
	// x-displayName: "GCP Tags"
	// x-example: "dev: staging"
	// GCP Tags is a label consisting of a user-defined key and value.
	// It helps to manage, identify, organize, search for, and filter resources in GCP console.
	Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// GCP Instance Type
	//
	// x-displayName: "GCP Instance Type"
	// x-example: "a1.xlarge"
	// x-required
	// Select the GCP instance type for deploying nodes of CE (customer edge) site.
	InstanceType string `protobuf:"bytes,4,opt,name=instance_type,json=instanceType,proto3" json:"instance_type,omitempty"`
	// Node Disk size
	//
	// x-displayName: "Node Disk Size"
	// x-example: "80"
	// Select the disk size of the node. The default value is 80GB.
	DiskSize uint32 `protobuf:"varint,5,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// Private Connectivity To Site
	//
	// x-displayName: "Private Connectivity"
	// Select Private Connectivity option. When enabled, site Connectivity is provided using Cloudlink for this CE (Customer Edge) site.
	// When disabled, site connectivity is over Internet.
	//
	// Types that are valid to be assigned to PrivateConnectivityChoice:
	//	*GCPManagedMode_PrivateConnectivityDisabled
	//	*GCPManagedMode_PrivateConnectivity
	PrivateConnectivityChoice isGCPManagedMode_PrivateConnectivityChoice `protobuf_oneof:"private_connectivity_choice"`
	// Number of interfaces on CE
	//
	// x-displayName: "Customer Edge Site Settings"
	// x-required
	// Select if you want to deploy a single interface or multiple interface CE (Customer Edge) Site.
	//
	// Types that are valid to be assigned to SiteType:
	//	*GCPManagedMode_SingleInterface
	//	*GCPManagedMode_MultipleInterface
	SiteType isGCPManagedMode_SiteType `protobuf_oneof:"site_type"`
}

func (m *GCPManagedMode) Reset()      { *m = GCPManagedMode{} }
func (*GCPManagedMode) ProtoMessage() {}
func (*GCPManagedMode) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{0}
}
func (m *GCPManagedMode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPManagedMode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPManagedMode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPManagedMode.Merge(m, src)
}
func (m *GCPManagedMode) XXX_Size() int {
	return m.Size()
}
func (m *GCPManagedMode) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPManagedMode.DiscardUnknown(m)
}

var xxx_messageInfo_GCPManagedMode proto.InternalMessageInfo

type isGCPManagedMode_PrivateConnectivityChoice interface {
	isGCPManagedMode_PrivateConnectivityChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGCPManagedMode_SiteType interface {
	isGCPManagedMode_SiteType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPManagedMode_PrivateConnectivityDisabled struct {
	PrivateConnectivityDisabled *schema.Empty `protobuf:"bytes,7,opt,name=private_connectivity_disabled,json=privateConnectivityDisabled,proto3,oneof" json:"private_connectivity_disabled,omitempty"`
}
type GCPManagedMode_PrivateConnectivity struct {
	PrivateConnectivity *views.PrivateConnectConfigType `protobuf:"bytes,8,opt,name=private_connectivity,json=privateConnectivity,proto3,oneof" json:"private_connectivity,omitempty"`
}
type GCPManagedMode_SingleInterface struct {
	SingleInterface *GCPSingleInterface `protobuf:"bytes,10,opt,name=single_interface,json=singleInterface,proto3,oneof" json:"single_interface,omitempty"`
}
type GCPManagedMode_MultipleInterface struct {
	MultipleInterface *GCPMultipleInterface `protobuf:"bytes,11,opt,name=multiple_interface,json=multipleInterface,proto3,oneof" json:"multiple_interface,omitempty"`
}

func (*GCPManagedMode_PrivateConnectivityDisabled) isGCPManagedMode_PrivateConnectivityChoice() {}
func (*GCPManagedMode_PrivateConnectivity) isGCPManagedMode_PrivateConnectivityChoice()         {}
func (*GCPManagedMode_SingleInterface) isGCPManagedMode_SiteType()                              {}
func (*GCPManagedMode_MultipleInterface) isGCPManagedMode_SiteType()                            {}

func (m *GCPManagedMode) GetPrivateConnectivityChoice() isGCPManagedMode_PrivateConnectivityChoice {
	if m != nil {
		return m.PrivateConnectivityChoice
	}
	return nil
}
func (m *GCPManagedMode) GetSiteType() isGCPManagedMode_SiteType {
	if m != nil {
		return m.SiteType
	}
	return nil
}

func (m *GCPManagedMode) GetGcpRegion() string {
	if m != nil {
		return m.GcpRegion
	}
	return ""
}

func (m *GCPManagedMode) GetGcpCred() *views.ObjectRefType {
	if m != nil {
		return m.GcpCred
	}
	return nil
}

func (m *GCPManagedMode) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GCPManagedMode) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

func (m *GCPManagedMode) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

func (m *GCPManagedMode) GetPrivateConnectivityDisabled() *schema.Empty {
	if x, ok := m.GetPrivateConnectivityChoice().(*GCPManagedMode_PrivateConnectivityDisabled); ok {
		return x.PrivateConnectivityDisabled
	}
	return nil
}

func (m *GCPManagedMode) GetPrivateConnectivity() *views.PrivateConnectConfigType {
	if x, ok := m.GetPrivateConnectivityChoice().(*GCPManagedMode_PrivateConnectivity); ok {
		return x.PrivateConnectivity
	}
	return nil
}

func (m *GCPManagedMode) GetSingleInterface() *GCPSingleInterface {
	if x, ok := m.GetSiteType().(*GCPManagedMode_SingleInterface); ok {
		return x.SingleInterface
	}
	return nil
}

func (m *GCPManagedMode) GetMultipleInterface() *GCPMultipleInterface {
	if x, ok := m.GetSiteType().(*GCPManagedMode_MultipleInterface); ok {
		return x.MultipleInterface
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GCPManagedMode) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GCPManagedMode_PrivateConnectivityDisabled)(nil),
		(*GCPManagedMode_PrivateConnectivity)(nil),
		(*GCPManagedMode_SingleInterface)(nil),
		(*GCPManagedMode_MultipleInterface)(nil),
	}
}

// One Interface
//
// x-displayName: "One Interface"
// This option deploys the CE (Customer Edge) Site as an ingress gateway.
type GCPSingleInterface struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// This section will show nodes associated with this site
	NodeList *GCPManagedNodeList `protobuf:"bytes,1,opt,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
}

func (m *GCPSingleInterface) Reset()      { *m = GCPSingleInterface{} }
func (*GCPSingleInterface) ProtoMessage() {}
func (*GCPSingleInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{1}
}
func (m *GCPSingleInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPSingleInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPSingleInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPSingleInterface.Merge(m, src)
}
func (m *GCPSingleInterface) XXX_Size() int {
	return m.Size()
}
func (m *GCPSingleInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPSingleInterface.DiscardUnknown(m)
}

var xxx_messageInfo_GCPSingleInterface proto.InternalMessageInfo

func (m *GCPSingleInterface) GetNodeList() *GCPManagedNodeList {
	if m != nil {
		return m.NodeList
	}
	return nil
}

// Multiple Interface Site
//
// x-displayName: "Multiple Interfaces"
// This option deploys the CE (Customer Edge) Site as an ingress/egress gateway.
type GCPMultipleInterface struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// This section will show nodes associated with this site.
	NodeList *GCPManagedNodeList `protobuf:"bytes,1,opt,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
}

func (m *GCPMultipleInterface) Reset()      { *m = GCPMultipleInterface{} }
func (*GCPMultipleInterface) ProtoMessage() {}
func (*GCPMultipleInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{2}
}
func (m *GCPMultipleInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPMultipleInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPMultipleInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPMultipleInterface.Merge(m, src)
}
func (m *GCPMultipleInterface) XXX_Size() int {
	return m.Size()
}
func (m *GCPMultipleInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPMultipleInterface.DiscardUnknown(m)
}

var xxx_messageInfo_GCPMultipleInterface proto.InternalMessageInfo

func (m *GCPMultipleInterface) GetNodeList() *GCPManagedNodeList {
	if m != nil {
		return m.NodeList
	}
	return nil
}

// GCPManagedNodeList
//
// x-displayName: "List of Nodes"
// This section will show nodes associated with this site.
type GCPManagedNodeList struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// x-required
	// This section will show nodes associated with this site.
	NodeList []*GCPManagedNode `protobuf:"bytes,1,rep,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
}

func (m *GCPManagedNodeList) Reset()      { *m = GCPManagedNodeList{} }
func (*GCPManagedNodeList) ProtoMessage() {}
func (*GCPManagedNodeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{3}
}
func (m *GCPManagedNodeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPManagedNodeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPManagedNodeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPManagedNodeList.Merge(m, src)
}
func (m *GCPManagedNodeList) XXX_Size() int {
	return m.Size()
}
func (m *GCPManagedNodeList) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPManagedNodeList.DiscardUnknown(m)
}

var xxx_messageInfo_GCPManagedNodeList proto.InternalMessageInfo

func (m *GCPManagedNodeList) GetNodeList() []*GCPManagedNode {
	if m != nil {
		return m.NodeList
	}
	return nil
}

// GCPManagedNode
//
// x-displayName: "Nodes"
// This section will show nodes associated with this site.
type GCPManagedNode struct {
	// Hostname
	//
	// x-displayName: "Hostname"
	// Hostname for this Node
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// GCP AZ
	//
	// x-displayName: "GCP Availability Zone"
	// x-required
	// x-example: "us-west-2a"
	// Select the GCP availability zone. This must be consistent with the selected GCP region.
	GcpAzName string `protobuf:"bytes,3,opt,name=gcp_az_name,json=gcpAzName,proto3" json:"gcp_az_name,omitempty"`
	// GCPOrchestratedInterface
	//
	// x-displayName: "Interfaces"
	// x-required
	// Configure Interfaces for this node
	InterfaceList []*GCPOrchestratedInterface `protobuf:"bytes,4,rep,name=interface_list,json=interfaceList,proto3" json:"interface_list,omitempty"`
}

func (m *GCPManagedNode) Reset()      { *m = GCPManagedNode{} }
func (*GCPManagedNode) ProtoMessage() {}
func (*GCPManagedNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{4}
}
func (m *GCPManagedNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPManagedNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPManagedNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPManagedNode.Merge(m, src)
}
func (m *GCPManagedNode) XXX_Size() int {
	return m.Size()
}
func (m *GCPManagedNode) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPManagedNode.DiscardUnknown(m)
}

var xxx_messageInfo_GCPManagedNode proto.InternalMessageInfo

func (m *GCPManagedNode) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *GCPManagedNode) GetGcpAzName() string {
	if m != nil {
		return m.GcpAzName
	}
	return ""
}

func (m *GCPManagedNode) GetInterfaceList() []*GCPOrchestratedInterface {
	if m != nil {
		return m.InterfaceList
	}
	return nil
}

// GCP VPC Parameters
//
// x-displayName: "GCP VPC Parameters"
// Parameters to create new GCP VPC
type GCPCloudVPCParamsType struct {
	// GCP Name
	//
	// x-displayName: "GCP VPC Name"
	// x-required
	// x-example: "MyVpc"
	// Provide a name for the GCP VPC where this CE (Customer Edge) is deployed
	//
	// Types that are valid to be assigned to NameChoice:
	//	*GCPCloudVPCParamsType_NameTag
	//	*GCPCloudVPCParamsType_Autogenerate
	NameChoice isGCPCloudVPCParamsType_NameChoice `protobuf_oneof:"name_choice"`
}

func (m *GCPCloudVPCParamsType) Reset()      { *m = GCPCloudVPCParamsType{} }
func (*GCPCloudVPCParamsType) ProtoMessage() {}
func (*GCPCloudVPCParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{5}
}
func (m *GCPCloudVPCParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPCloudVPCParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPCloudVPCParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPCloudVPCParamsType.Merge(m, src)
}
func (m *GCPCloudVPCParamsType) XXX_Size() int {
	return m.Size()
}
func (m *GCPCloudVPCParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPCloudVPCParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPCloudVPCParamsType proto.InternalMessageInfo

type isGCPCloudVPCParamsType_NameChoice interface {
	isGCPCloudVPCParamsType_NameChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPCloudVPCParamsType_NameTag struct {
	NameTag string `protobuf:"bytes,2,opt,name=name_tag,json=nameTag,proto3,oneof" json:"name_tag,omitempty"`
}
type GCPCloudVPCParamsType_Autogenerate struct {
	Autogenerate *schema.Empty `protobuf:"bytes,3,opt,name=autogenerate,proto3,oneof" json:"autogenerate,omitempty"`
}

func (*GCPCloudVPCParamsType_NameTag) isGCPCloudVPCParamsType_NameChoice()      {}
func (*GCPCloudVPCParamsType_Autogenerate) isGCPCloudVPCParamsType_NameChoice() {}

func (m *GCPCloudVPCParamsType) GetNameChoice() isGCPCloudVPCParamsType_NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

func (m *GCPCloudVPCParamsType) GetNameTag() string {
	if x, ok := m.GetNameChoice().(*GCPCloudVPCParamsType_NameTag); ok {
		return x.NameTag
	}
	return ""
}

func (m *GCPCloudVPCParamsType) GetAutogenerate() *schema.Empty {
	if x, ok := m.GetNameChoice().(*GCPCloudVPCParamsType_Autogenerate); ok {
		return x.Autogenerate
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GCPCloudVPCParamsType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GCPCloudVPCParamsType_NameTag)(nil),
		(*GCPCloudVPCParamsType_Autogenerate)(nil),
	}
}

// GCP VPC
//
// x-displayName: "GCP VPC"
// Parameters for VPC
type GCPVPCChoiceType struct {
	// New/Existing Services VPC
	//
	// x-displayName: "New/Existing Services VPC"
	// x-required
	// Provide VPC details where CE (Customer Edge) site is to be deployed. This VPC can be an existing VPC
	// or a new VPC that F5 Distributed Cloud will orchestrate.
	//
	// Types that are valid to be assigned to ServiceVpcChoice:
	//	*GCPVPCChoiceType_NewVpc
	//	*GCPVPCChoiceType_ExistingVpcId
	ServiceVpcChoice isGCPVPCChoiceType_ServiceVpcChoice `protobuf_oneof:"service_vpc_choice"`
}

func (m *GCPVPCChoiceType) Reset()      { *m = GCPVPCChoiceType{} }
func (*GCPVPCChoiceType) ProtoMessage() {}
func (*GCPVPCChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{6}
}
func (m *GCPVPCChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPVPCChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPVPCChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPVPCChoiceType.Merge(m, src)
}
func (m *GCPVPCChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *GCPVPCChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPVPCChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPVPCChoiceType proto.InternalMessageInfo

type isGCPVPCChoiceType_ServiceVpcChoice interface {
	isGCPVPCChoiceType_ServiceVpcChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPVPCChoiceType_NewVpc struct {
	NewVpc *GCPCloudVPCParamsType `protobuf:"bytes,3,opt,name=new_vpc,json=newVpc,proto3,oneof" json:"new_vpc,omitempty"`
}
type GCPVPCChoiceType_ExistingVpcId struct {
	ExistingVpcId string `protobuf:"bytes,4,opt,name=existing_vpc_id,json=existingVpcId,proto3,oneof" json:"existing_vpc_id,omitempty"`
}

func (*GCPVPCChoiceType_NewVpc) isGCPVPCChoiceType_ServiceVpcChoice()        {}
func (*GCPVPCChoiceType_ExistingVpcId) isGCPVPCChoiceType_ServiceVpcChoice() {}

func (m *GCPVPCChoiceType) GetServiceVpcChoice() isGCPVPCChoiceType_ServiceVpcChoice {
	if m != nil {
		return m.ServiceVpcChoice
	}
	return nil
}

func (m *GCPVPCChoiceType) GetNewVpc() *GCPCloudVPCParamsType {
	if x, ok := m.GetServiceVpcChoice().(*GCPVPCChoiceType_NewVpc); ok {
		return x.NewVpc
	}
	return nil
}

func (m *GCPVPCChoiceType) GetExistingVpcId() string {
	if x, ok := m.GetServiceVpcChoice().(*GCPVPCChoiceType_ExistingVpcId); ok {
		return x.ExistingVpcId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GCPVPCChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GCPVPCChoiceType_NewVpc)(nil),
		(*GCPVPCChoiceType_ExistingVpcId)(nil),
	}
}

// GCPOrchestratedInterface
//
// x-displayName: "Interfaces"
// Interfaces belonging to this node
type GCPOrchestratedInterface struct {
	// VPC Choice
	//
	// x-displayName: "VPC Parameters"
	// Provide VPC details. User can either create a new VPC or use an existing VPC
	Vpc *GCPVPCChoiceType `protobuf:"bytes,1,opt,name=vpc,proto3" json:"vpc,omitempty"`
	// Subnet Choice
	//
	// x-displayName: "Subnet Parameters"
	// Provide Subnet details. User can either create a new subnet or use an existing subnet.
	Subnet *GCPSubnetChoiceType `protobuf:"bytes,2,opt,name=subnet,proto3" json:"subnet,omitempty"`
	// Select VRF
	//
	// x-displayName: "Select VRF"
	// x-required
	// Select virtual network (VRF) for this interface.
	// There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites.
	// A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional.
	// Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).
	NetworkOption *views.NetworkSelectType `protobuf:"bytes,3,opt,name=network_option,json=networkOption,proto3" json:"network_option,omitempty"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,4,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Use for Site to Site Connectivity
	//
	// x-displayName: "Use for Site to Site Connectivity"
	// Interface with this field enabled will be used to connect to other sites.
	// This setting is useful if a node has multiple interfaces configured in a VRF.
	// Only one interface in a VRF can have this field enabled.
	//
	// Types that are valid to be assigned to SiteToSiteConnectivityInterfaceChoice:
	//	*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled
	//	*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled
	SiteToSiteConnectivityInterfaceChoice isGCPOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice `protobuf_oneof:"site_to_site_connectivity_interface_choice"`
}

func (m *GCPOrchestratedInterface) Reset()      { *m = GCPOrchestratedInterface{} }
func (*GCPOrchestratedInterface) ProtoMessage() {}
func (*GCPOrchestratedInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{7}
}
func (m *GCPOrchestratedInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPOrchestratedInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPOrchestratedInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPOrchestratedInterface.Merge(m, src)
}
func (m *GCPOrchestratedInterface) XXX_Size() int {
	return m.Size()
}
func (m *GCPOrchestratedInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPOrchestratedInterface.DiscardUnknown(m)
}

var xxx_messageInfo_GCPOrchestratedInterface proto.InternalMessageInfo

type isGCPOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice interface {
	isGCPOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled struct {
	SiteToSiteConnectivityInterfaceDisabled *schema.Empty `protobuf:"bytes,10,opt,name=site_to_site_connectivity_interface_disabled,json=siteToSiteConnectivityInterfaceDisabled,proto3,oneof" json:"site_to_site_connectivity_interface_disabled,omitempty"`
}
type GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled struct {
	SiteToSiteConnectivityInterfaceEnabled *schema.Empty `protobuf:"bytes,11,opt,name=site_to_site_connectivity_interface_enabled,json=siteToSiteConnectivityInterfaceEnabled,proto3,oneof" json:"site_to_site_connectivity_interface_enabled,omitempty"`
}

func (*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) isGCPOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice() {
}
func (*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) isGCPOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice() {
}

func (m *GCPOrchestratedInterface) GetSiteToSiteConnectivityInterfaceChoice() isGCPOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice {
	if m != nil {
		return m.SiteToSiteConnectivityInterfaceChoice
	}
	return nil
}

func (m *GCPOrchestratedInterface) GetVpc() *GCPVPCChoiceType {
	if m != nil {
		return m.Vpc
	}
	return nil
}

func (m *GCPOrchestratedInterface) GetSubnet() *GCPSubnetChoiceType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *GCPOrchestratedInterface) GetNetworkOption() *views.NetworkSelectType {
	if m != nil {
		return m.NetworkOption
	}
	return nil
}

func (m *GCPOrchestratedInterface) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *GCPOrchestratedInterface) GetSiteToSiteConnectivityInterfaceDisabled() *schema.Empty {
	if x, ok := m.GetSiteToSiteConnectivityInterfaceChoice().(*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled); ok {
		return x.SiteToSiteConnectivityInterfaceDisabled
	}
	return nil
}

func (m *GCPOrchestratedInterface) GetSiteToSiteConnectivityInterfaceEnabled() *schema.Empty {
	if x, ok := m.GetSiteToSiteConnectivityInterfaceChoice().(*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled); ok {
		return x.SiteToSiteConnectivityInterfaceEnabled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GCPOrchestratedInterface) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled)(nil),
		(*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled)(nil),
	}
}

// GCP Subnet
//
// x-displayName: "GCP Subnet"
// Parameters for subnet
type GCPSubnetChoiceType struct {
	// Choice of subnet
	//
	// x-displayName: "Subnet Parameters"
	// x-required
	// Provide subnet details for this interface.
	//
	// Types that are valid to be assigned to Choice:
	//	*GCPSubnetChoiceType_SubnetParam
	//	*GCPSubnetChoiceType_ExistingSubnetId
	Choice isGCPSubnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *GCPSubnetChoiceType) Reset()      { *m = GCPSubnetChoiceType{} }
func (*GCPSubnetChoiceType) ProtoMessage() {}
func (*GCPSubnetChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{8}
}
func (m *GCPSubnetChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPSubnetChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPSubnetChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPSubnetChoiceType.Merge(m, src)
}
func (m *GCPSubnetChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *GCPSubnetChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPSubnetChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPSubnetChoiceType proto.InternalMessageInfo

type isGCPSubnetChoiceType_Choice interface {
	isGCPSubnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPSubnetChoiceType_SubnetParam struct {
	SubnetParam *GCPCloudSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam,proto3,oneof" json:"subnet_param,omitempty"`
}
type GCPSubnetChoiceType_ExistingSubnetId struct {
	ExistingSubnetId string `protobuf:"bytes,2,opt,name=existing_subnet_id,json=existingSubnetId,proto3,oneof" json:"existing_subnet_id,omitempty"`
}

func (*GCPSubnetChoiceType_SubnetParam) isGCPSubnetChoiceType_Choice()      {}
func (*GCPSubnetChoiceType_ExistingSubnetId) isGCPSubnetChoiceType_Choice() {}

func (m *GCPSubnetChoiceType) GetChoice() isGCPSubnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *GCPSubnetChoiceType) GetSubnetParam() *GCPCloudSubnetParamType {
	if x, ok := m.GetChoice().(*GCPSubnetChoiceType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *GCPSubnetChoiceType) GetExistingSubnetId() string {
	if x, ok := m.GetChoice().(*GCPSubnetChoiceType_ExistingSubnetId); ok {
		return x.ExistingSubnetId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GCPSubnetChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GCPSubnetChoiceType_SubnetParam)(nil),
		(*GCPSubnetChoiceType_ExistingSubnetId)(nil),
	}
}

// Cloud Subnet Param
//
// x-displayName: "New Cloud Subnet Parameters"
// Parameters for creating a new cloud subnet
type GCPCloudSubnetParamType struct {
	// Subnet Name
	//
	// x-displayName: "Subnet Name"
	// x-example: "subnet-a"
	// Enter a name for your subnet
	//
	// Types that are valid to be assigned to NameChoice:
	//	*GCPCloudSubnetParamType_Name
	//	*GCPCloudSubnetParamType_Autogenerate
	NameChoice isGCPCloudSubnetParamType_NameChoice `protobuf_oneof:"name_choice"`
	// IPv4 CIDR block
	//
	// x-displayName: "IPv4 Subnet Prefix"
	// x-required
	// x-example: "10.1.0.0/16"
	// Enter an IPv4 prefix for this subnet. The IP address must be in a private address space.
	Ipv4 string `protobuf:"bytes,4,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
}

func (m *GCPCloudSubnetParamType) Reset()      { *m = GCPCloudSubnetParamType{} }
func (*GCPCloudSubnetParamType) ProtoMessage() {}
func (*GCPCloudSubnetParamType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa66d287e6de511, []int{9}
}
func (m *GCPCloudSubnetParamType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPCloudSubnetParamType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPCloudSubnetParamType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPCloudSubnetParamType.Merge(m, src)
}
func (m *GCPCloudSubnetParamType) XXX_Size() int {
	return m.Size()
}
func (m *GCPCloudSubnetParamType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPCloudSubnetParamType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPCloudSubnetParamType proto.InternalMessageInfo

type isGCPCloudSubnetParamType_NameChoice interface {
	isGCPCloudSubnetParamType_NameChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPCloudSubnetParamType_Name struct {
	Name string `protobuf:"bytes,2,opt,name=name,proto3,oneof" json:"name,omitempty"`
}
type GCPCloudSubnetParamType_Autogenerate struct {
	Autogenerate *schema.Empty `protobuf:"bytes,3,opt,name=autogenerate,proto3,oneof" json:"autogenerate,omitempty"`
}

func (*GCPCloudSubnetParamType_Name) isGCPCloudSubnetParamType_NameChoice()         {}
func (*GCPCloudSubnetParamType_Autogenerate) isGCPCloudSubnetParamType_NameChoice() {}

func (m *GCPCloudSubnetParamType) GetNameChoice() isGCPCloudSubnetParamType_NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

func (m *GCPCloudSubnetParamType) GetName() string {
	if x, ok := m.GetNameChoice().(*GCPCloudSubnetParamType_Name); ok {
		return x.Name
	}
	return ""
}

func (m *GCPCloudSubnetParamType) GetAutogenerate() *schema.Empty {
	if x, ok := m.GetNameChoice().(*GCPCloudSubnetParamType_Autogenerate); ok {
		return x.Autogenerate
	}
	return nil
}

func (m *GCPCloudSubnetParamType) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GCPCloudSubnetParamType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GCPCloudSubnetParamType_Name)(nil),
		(*GCPCloudSubnetParamType_Autogenerate)(nil),
	}
}

func init() {
	proto.RegisterType((*GCPManagedMode)(nil), "ves.io.schema.views.securemesh_site_v2.GCPManagedMode")
	golang_proto.RegisterType((*GCPManagedMode)(nil), "ves.io.schema.views.securemesh_site_v2.GCPManagedMode")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.securemesh_site_v2.GCPManagedMode.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.securemesh_site_v2.GCPManagedMode.TagsEntry")
	proto.RegisterType((*GCPSingleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.GCPSingleInterface")
	golang_proto.RegisterType((*GCPSingleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.GCPSingleInterface")
	proto.RegisterType((*GCPMultipleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.GCPMultipleInterface")
	golang_proto.RegisterType((*GCPMultipleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.GCPMultipleInterface")
	proto.RegisterType((*GCPManagedNodeList)(nil), "ves.io.schema.views.securemesh_site_v2.GCPManagedNodeList")
	golang_proto.RegisterType((*GCPManagedNodeList)(nil), "ves.io.schema.views.securemesh_site_v2.GCPManagedNodeList")
	proto.RegisterType((*GCPManagedNode)(nil), "ves.io.schema.views.securemesh_site_v2.GCPManagedNode")
	golang_proto.RegisterType((*GCPManagedNode)(nil), "ves.io.schema.views.securemesh_site_v2.GCPManagedNode")
	proto.RegisterType((*GCPCloudVPCParamsType)(nil), "ves.io.schema.views.securemesh_site_v2.GCPCloudVPCParamsType")
	golang_proto.RegisterType((*GCPCloudVPCParamsType)(nil), "ves.io.schema.views.securemesh_site_v2.GCPCloudVPCParamsType")
	proto.RegisterType((*GCPVPCChoiceType)(nil), "ves.io.schema.views.securemesh_site_v2.GCPVPCChoiceType")
	golang_proto.RegisterType((*GCPVPCChoiceType)(nil), "ves.io.schema.views.securemesh_site_v2.GCPVPCChoiceType")
	proto.RegisterType((*GCPOrchestratedInterface)(nil), "ves.io.schema.views.securemesh_site_v2.GCPOrchestratedInterface")
	golang_proto.RegisterType((*GCPOrchestratedInterface)(nil), "ves.io.schema.views.securemesh_site_v2.GCPOrchestratedInterface")
	proto.RegisterType((*GCPSubnetChoiceType)(nil), "ves.io.schema.views.securemesh_site_v2.GCPSubnetChoiceType")
	golang_proto.RegisterType((*GCPSubnetChoiceType)(nil), "ves.io.schema.views.securemesh_site_v2.GCPSubnetChoiceType")
	proto.RegisterType((*GCPCloudSubnetParamType)(nil), "ves.io.schema.views.securemesh_site_v2.GCPCloudSubnetParamType")
	golang_proto.RegisterType((*GCPCloudSubnetParamType)(nil), "ves.io.schema.views.securemesh_site_v2.GCPCloudSubnetParamType")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/securemesh_site_v2/gcp_types.proto", fileDescriptor_9fa66d287e6de511)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/securemesh_site_v2/gcp_types.proto", fileDescriptor_9fa66d287e6de511)
}

var fileDescriptor_9fa66d287e6de511 = []byte{
	// 1947 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4f, 0x6c, 0x1b, 0x59,
	0x19, 0xf7, 0xf3, 0x38, 0x8e, 0xfd, 0xa5, 0x4e, 0xbc, 0xaf, 0xc9, 0xd6, 0x4d, 0xbb, 0x66, 0xd6,
	0x40, 0xd6, 0xcd, 0x3a, 0x76, 0xfc, 0xa7, 0xde, 0x34, 0x0b, 0xdb, 0xc6, 0xa6, 0x6a, 0x52, 0xb6,
	0xad, 0x99, 0x74, 0x23, 0x51, 0x01, 0xd6, 0x64, 0xe6, 0x65, 0xf2, 0xb6, 0xf6, 0xcc, 0x68, 0x66,
	0xec, 0x36, 0x95, 0x80, 0x9c, 0xf8, 0x7b, 0xa9, 0x7a, 0x42, 0x95, 0x90, 0x38, 0x22, 0x24, 0x24,
	0xce, 0x75, 0x90, 0xa2, 0x4a, 0x20, 0xb4, 0xa7, 0xdc, 0x28, 0x95, 0x90, 0x5a, 0xf7, 0xb2, 0x2b,
	0x71, 0xa8, 0x56, 0x1c, 0xf6, 0x82, 0x40, 0xef, 0xcd, 0xd8, 0xf1, 0x24, 0xce, 0xb6, 0x01, 0x71,
	0xca, 0xcc, 0x7c, 0xdf, 0xf7, 0xfb, 0xde, 0xf7, 0xef, 0xf7, 0xbd, 0x18, 0xca, 0x6d, 0x62, 0x67,
	0xa9, 0x91, 0xb3, 0x95, 0x4d, 0xd2, 0x94, 0x73, 0x6d, 0x4a, 0xee, 0xd8, 0x39, 0x9b, 0x28, 0x2d,
	0x8b, 0x34, 0x89, 0xbd, 0x59, 0xb7, 0xa9, 0x43, 0xea, 0xed, 0x42, 0x4e, 0x53, 0xcc, 0xba, 0xb3,
	0x65, 0x12, 0x3b, 0x6b, 0x5a, 0x86, 0x63, 0xe0, 0x19, 0xd7, 0x2e, 0xeb, 0xda, 0x65, 0xb9, 0x5d,
	0xf6, 0xb0, 0xdd, 0xf4, 0x9c, 0x46, 0x9d, 0xcd, 0xd6, 0x7a, 0x56, 0x31, 0x9a, 0x39, 0xcd, 0xd0,
	0x8c, 0x1c, 0x37, 0x5f, 0x6f, 0x6d, 0xf0, 0x37, 0xfe, 0xc2, 0x9f, 0x5c, 0xd8, 0xe9, 0x53, 0xfe,
	0xe3, 0xe8, 0xc4, 0xf1, 0x04, 0xef, 0x1e, 0x12, 0xdc, 0x31, 0xac, 0xdb, 0x75, 0xaa, 0x3b, 0xc4,
	0xda, 0x90, 0x15, 0x92, 0x1b, 0x38, 0xdc, 0xf4, 0x19, 0xbf, 0xb2, 0x61, 0x3a, 0xd4, 0xd0, 0x7b,
	0xc2, 0xd3, 0x7e, 0xe1, 0xa0, 0xdd, 0xd9, 0x03, 0xc9, 0x90, 0x1b, 0x54, 0x95, 0x1d, 0xe2, 0x49,
	0xc5, 0xc3, 0xa9, 0xaa, 0xfb, 0xa1, 0xbf, 0x36, 0x34, 0x99, 0x2c, 0x13, 0x83, 0x5e, 0xbe, 0x32,
	0x4c, 0x6b, 0x40, 0x21, 0xb5, 0x03, 0x30, 0x7e, 0xa5, 0x5a, 0xbb, 0x26, 0xeb, 0xb2, 0x46, 0xd4,
	0x6b, 0x86, 0x4a, 0x70, 0x11, 0x80, 0x55, 0xc0, 0x22, 0x1a, 0x35, 0xf4, 0x04, 0x12, 0x51, 0x3a,
	0x5a, 0x99, 0xfc, 0xa2, 0x83, 0x02, 0x8f, 0x76, 0xd0, 0x89, 0x34, 0x9a, 0x47, 0x8b, 0x61, 0xc5,
	0xd0, 0x37, 0xa8, 0x26, 0x45, 0x35, 0xc5, 0x94, 0xb8, 0x1a, 0x26, 0x10, 0x61, 0x46, 0x8a, 0x45,
	0xd4, 0x44, 0x50, 0x44, 0xe9, 0xb1, 0x42, 0x2a, 0x3b, 0xac, 0x6c, 0x37, 0xd6, 0x3f, 0x26, 0x8a,
	0x23, 0x91, 0x8d, 0x9b, 0x5b, 0x26, 0xa9, 0xcc, 0xfc, 0xee, 0x87, 0x6f, 0x28, 0x0d, 0xa3, 0xa5,
	0x72, 0x43, 0xa2, 0x3b, 0x54, 0x6e, 0xd8, 0x8f, 0x76, 0xd0, 0x78, 0x04, 0xf9, 0x1c, 0x8d, 0x6a,
	0x8a, 0x59, 0xb5, 0x88, 0x8a, 0x7f, 0x86, 0x20, 0xe4, 0xc8, 0x9a, 0x9d, 0x10, 0x44, 0x21, 0x3d,
	0x56, 0xb8, 0x94, 0x7d, 0xbd, 0xd6, 0xc8, 0xfa, 0x43, 0xcc, 0xde, 0x94, 0x35, 0xfb, 0xb2, 0xee,
	0x58, 0x5b, 0x95, 0xc2, 0xa3, 0xcf, 0x76, 0x85, 0xe8, 0x43, 0x14, 0x4e, 0x85, 0xac, 0x60, 0xe2,
	0xc7, 0xec, 0x6d, 0xe4, 0x21, 0x0a, 0xc6, 0xd3, 0xec, 0x09, 0x1e, 0xa2, 0xd1, 0xd9, 0x11, 0x4b,
	0x48, 0xfc, 0x1b, 0x75, 0x9f, 0xfd, 0x49, 0x08, 0xff, 0x62, 0x07, 0x05, 0x23, 0x01, 0x89, 0x9f,
	0x00, 0xff, 0x39, 0x08, 0x31, 0xaa, 0xdb, 0x8e, 0xac, 0x2b, 0x6e, 0xce, 0x13, 0x21, 0x9e, 0xaa,
	0xdf, 0x04, 0x9f, 0x76, 0x50, 0x4c, 0xcf, 0xcf, 0x31, 0x91, 0x2a, 0x5b, 0xea, 0x5c, 0x89, 0x25,
	0xef, 0xc1, 0x0e, 0xfa, 0x17, 0x82, 0xf7, 0xc1, 0x2f, 0xc1, 0xb3, 0xe9, 0x92, 0x78, 0x57, 0x6c,
	0x57, 0x6b, 0x1f, 0x65, 0xc4, 0x7c, 0xf9, 0x4a, 0x45, 0x94, 0x96, 0xae, 0x9d, 0x13, 0xaf, 0xe7,
	0xc5, 0x26, 0x51, 0x69, 0xab, 0x29, 0x9a, 0xc4, 0xda, 0x30, 0xac, 0x26, 0x73, 0x02, 0x17, 0xfc,
	0xc6, 0x0b, 0x38, 0x9d, 0x5e, 0xe8, 0x1b, 0x17, 0x0b, 0x03, 0xc6, 0x9b, 0x54, 0xdb, 0xf4, 0x99,
	0x5e, 0x82, 0xf1, 0x41, 0xd3, 0x7c, 0x19, 0x67, 0xd3, 0xf9, 0x72, 0xdf, 0xb8, 0x5c, 0x1a, 0x30,
	0x6e, 0x13, 0x6b, 0xeb, 0x30, 0xc2, 0x92, 0x1f, 0xa1, 0x58, 0xc0, 0xb9, 0x74, 0xb1, 0xb0, 0x7f,
	0xf6, 0xc2, 0xfc, 0xab, 0x20, 0x58, 0x46, 0x59, 0x92, 0x2f, 0x49, 0x27, 0x7a, 0x79, 0x63, 0x4d,
	0x80, 0x0b, 0x10, 0x55, 0xa9, 0x7d, 0xbb, 0x6e, 0xd3, 0x7b, 0x24, 0x31, 0x22, 0xa2, 0x74, 0xac,
	0x32, 0xf5, 0xb4, 0x83, 0x82, 0x0b, 0xf3, 0xbc, 0xe9, 0x3e, 0xdb, 0x15, 0xc2, 0xb3, 0xa1, 0xc4,
	0xf6, 0x3f, 0x05, 0x29, 0xc2, 0xf4, 0x56, 0xe9, 0x3d, 0x82, 0x6f, 0xc1, 0x5b, 0xa6, 0x45, 0xdb,
	0xb2, 0x43, 0xea, 0x8a, 0xa1, 0xeb, 0x44, 0x71, 0x68, 0x9b, 0x3a, 0x5b, 0x75, 0x95, 0xda, 0xf2,
	0x7a, 0x83, 0xa8, 0x89, 0x51, 0xde, 0x83, 0x93, 0x07, 0xfa, 0xe3, 0x72, 0xd3, 0x74, 0xb6, 0x96,
	0x03, 0xd2, 0x19, 0xcf, 0xb8, 0x3a, 0x60, 0xfb, 0x2d, 0xcf, 0x14, 0xaf, 0xc3, 0xe4, 0x30, 0xec,
	0x44, 0x84, 0x43, 0xce, 0x0d, 0x6d, 0xb9, 0x9a, 0x0f, 0xaf, 0xca, 0xbb, 0x96, 0x05, 0xb7, 0x1c,
	0x90, 0x4e, 0x0e, 0xf1, 0x85, 0x35, 0x88, 0xdb, 0x54, 0xd7, 0x1a, 0x64, 0x9f, 0x55, 0x12, 0xc0,
	0xf1, 0x17, 0x8f, 0xd1, 0xd2, 0xab, 0x1c, 0x62, 0xa5, 0x87, 0xb0, 0x8c, 0xa4, 0x09, 0xdb, 0xff,
	0x09, 0x37, 0x01, 0x37, 0x5b, 0x0d, 0x87, 0x9a, 0x3e, 0x57, 0x63, 0xdc, 0xd5, 0x37, 0x8e, 0x33,
	0x3d, 0x1e, 0xc8, 0xa0, 0xb3, 0x37, 0x9a, 0x07, 0x3f, 0x4e, 0xbf, 0x07, 0xd1, 0xfe, 0x6c, 0xe1,
	0x38, 0x08, 0xb7, 0xc9, 0x96, 0xcb, 0x20, 0x12, 0x7b, 0xc4, 0x93, 0x30, 0xd2, 0x96, 0x1b, 0x2d,
	0xc2, 0x29, 0x22, 0x2a, 0xb9, 0x2f, 0x8b, 0xc1, 0x05, 0xb4, 0xf8, 0xd1, 0xe3, 0x0e, 0xfa, 0x0e,
	0x24, 0x61, 0xea, 0x4a, 0xb5, 0x26, 0x56, 0xf7, 0xc9, 0x40, 0x9c, 0x11, 0xd7, 0x6a, 0x55, 0x3c,
	0x52, 0xc8, 0xe4, 0x33, 0x45, 0x48, 0xc0, 0xc4, 0x75, 0x43, 0x25, 0x62, 0xcd, 0x32, 0x4c, 0x62,
	0x39, 0x94, 0xd8, 0x78, 0xa4, 0x94, 0x39, 0x9f, 0xb9, 0x00, 0x53, 0x10, 0xaf, 0x32, 0x22, 0x11,
	0xaf, 0xbb, 0x6c, 0x4d, 0x75, 0x0d, 0xa3, 0x72, 0x25, 0x0b, 0x67, 0x86, 0xf6, 0x89, 0xb2, 0x69,
	0x50, 0x85, 0xe0, 0x89, 0xdd, 0x0e, 0x1a, 0xdd, 0xeb, 0xa0, 0x70, 0xb7, 0x83, 0x84, 0xf7, 0x32,
	0x0b, 0x95, 0x14, 0x44, 0xfb, 0x1c, 0x8a, 0xa7, 0x76, 0x3b, 0x08, 0xf6, 0x3a, 0x28, 0xda, 0xed,
	0xa0, 0x91, 0xfc, 0x7c, 0x26, 0x9f, 0xff, 0xb4, 0x83, 0xd0, 0xd5, 0x50, 0x24, 0x1c, 0x1f, 0xbd,
	0x1a, 0x8a, 0x44, 0xe3, 0x90, 0xb2, 0x01, 0x1f, 0xae, 0x03, 0xfe, 0x3e, 0x44, 0x75, 0x43, 0x25,
	0xf5, 0x06, 0xb5, 0x1d, 0x1e, 0xfe, 0xf1, 0xca, 0xea, 0x31, 0x15, 0x8b, 0xf4, 0x43, 0x6a, 0x3b,
	0x95, 0xd0, 0xcb, 0x0e, 0x42, 0x52, 0x44, 0xf7, 0xde, 0x53, 0x2d, 0x98, 0x1c, 0x56, 0x91, 0xff,
	0xb7, 0xdb, 0x6d, 0xc4, 0x83, 0x3d, 0xa0, 0x86, 0x3f, 0xf6, 0x7b, 0x65, 0xb4, 0x5c, 0xfe, 0xef,
	0xbc, 0x56, 0xa6, 0xf8, 0xb0, 0x3f, 0x40, 0x42, 0x7c, 0x1b, 0x71, 0x26, 0x7e, 0x80, 0x82, 0x09,
	0xdf, 0x11, 0x84, 0xc1, 0x6d, 0xc5, 0x6c, 0xf0, 0x2c, 0x44, 0x36, 0x0d, 0xdb, 0xd1, 0xe5, 0xa6,
	0xd7, 0x55, 0x95, 0xf1, 0xfb, 0x7f, 0x44, 0xae, 0xb9, 0x25, 0x24, 0xb6, 0x43, 0x52, 0x5f, 0x8e,
	0x17, 0x60, 0x8c, 0x2d, 0x29, 0xf9, 0x5e, 0x9d, 0xab, 0x0b, 0x5c, 0x3d, 0xe1, 0xad, 0xb6, 0x78,
	0x84, 0x6d, 0x1c, 0xe0, 0xeb, 0x68, 0x4e, 0x95, 0x1d, 0x99, 0xaf, 0xb7, 0xa5, 0x7b, 0xd7, 0x99,
	0xe5, 0x4f, 0x11, 0x8c, 0xf7, 0xc7, 0xc7, 0x0d, 0x35, 0x74, 0xec, 0x0d, 0x74, 0xc3, 0x52, 0x36,
	0x89, 0xed, 0x58, 0xb2, 0x43, 0xd4, 0x7e, 0xd5, 0x2a, 0xc9, 0x5e, 0xa4, 0xf1, 0x60, 0xef, 0x29,
	0x32, 0x18, 0x7d, 0xac, 0xef, 0x97, 0xa5, 0x60, 0xf1, 0x47, 0x8f, 0x3b, 0xe8, 0x3c, 0x9c, 0x82,
	0x38, 0x1f, 0x84, 0x15, 0x9d, 0xb3, 0x2b, 0xbb, 0x18, 0x60, 0xa1, 0x90, 0x29, 0xc2, 0x34, 0x4c,
	0xf5, 0xa1, 0x7d, 0x52, 0x54, 0xfa, 0xa4, 0x83, 0x96, 0xe0, 0x4d, 0x88, 0x2c, 0x7b, 0xe9, 0x98,
	0x86, 0xfd, 0xd4, 0xc1, 0x3b, 0xf0, 0xe6, 0x52, 0x5b, 0xa6, 0x0d, 0x79, 0x9d, 0x36, 0xa8, 0xb3,
	0x25, 0xde, 0x32, 0x74, 0x22, 0xa6, 0x97, 0x6e, 0x9d, 0x9b, 0x8e, 0xf9, 0x92, 0x96, 0xfa, 0x3d,
	0xe2, 0x33, 0xca, 0x87, 0x6d, 0xad, 0x56, 0xad, 0xc9, 0x96, 0xdc, 0xb4, 0x39, 0x8f, 0x67, 0x20,
	0xc2, 0x34, 0xea, 0x8e, 0xac, 0x79, 0x95, 0x98, 0xe8, 0x13, 0xb8, 0x15, 0x8a, 0xa3, 0xc4, 0xa5,
	0xe5, 0x80, 0x34, 0xca, 0x54, 0x6e, 0xca, 0x1a, 0x5e, 0x84, 0x13, 0x72, 0xcb, 0x31, 0x34, 0xa2,
	0x13, 0x96, 0x10, 0x5e, 0x8c, 0xa3, 0x09, 0xdb, 0xa7, 0xbb, 0x18, 0xfa, 0xfc, 0x03, 0x94, 0xaf,
	0x24, 0x61, 0x8c, 0xfb, 0x1b, 0x98, 0x65, 0x61, 0xaf, 0x83, 0x10, 0x9b, 0xe5, 0x62, 0xa6, 0x70,
	0x35, 0x14, 0x41, 0xf1, 0x60, 0xea, 0x1f, 0x08, 0xe2, 0x57, 0xaa, 0xb5, 0xb5, 0x5a, 0xb5, 0xca,
	0xf5, 0xf8, 0x51, 0x7f, 0x00, 0xa3, 0x3a, 0xb9, 0x53, 0x6f, 0x9b, 0x8a, 0xe7, 0xf7, 0x9b, 0xc7,
	0x28, 0xe3, 0xe1, 0xd0, 0x2b, 0xa1, 0x3f, 0xec, 0x20, 0xb4, 0x1c, 0x90, 0xc2, 0x3a, 0xb9, 0xb3,
	0x66, 0x2a, 0xf8, 0xdb, 0x30, 0x41, 0xee, 0x52, 0xdb, 0xa1, 0xba, 0xc6, 0x9c, 0xd4, 0xa9, 0xea,
	0x5d, 0x0e, 0xde, 0xf6, 0x9a, 0x6d, 0xdc, 0xdf, 0x6a, 0xfe, 0x1c, 0xc5, 0x7a, 0xb6, 0x6b, 0xa6,
	0xb2, 0xa2, 0x56, 0xbe, 0x0e, 0xd8, 0x26, 0x56, 0x9b, 0x2a, 0x84, 0x63, 0x1d, 0x08, 0x37, 0xe8,
	0x86, 0x5b, 0xba, 0x1a, 0x8a, 0x04, 0xe3, 0x42, 0xea, 0x6f, 0xa3, 0x90, 0x38, 0xaa, 0xd5, 0x70,
	0x0d, 0x04, 0x16, 0xb2, 0x4b, 0x0d, 0x0b, 0xc7, 0x08, 0xd9, 0x97, 0x3d, 0x37, 0x5a, 0x89, 0x41,
	0xe1, 0xef, 0x42, 0xd8, 0x6e, 0xad, 0xeb, 0xc4, 0xf1, 0x2e, 0x7d, 0xef, 0x1f, 0x67, 0x7b, 0x71,
	0xc3, 0x43, 0xb8, 0x1e, 0x20, 0x5e, 0x85, 0xf1, 0xde, 0xcd, 0xdb, 0xbd, 0xf9, 0x7a, 0xa5, 0x9a,
	0x19, 0xea, 0xc2, 0xa3, 0xfd, 0x55, 0xd2, 0x20, 0x8a, 0x33, 0x80, 0x16, 0xf3, 0x30, 0x6e, 0x70,
	0x08, 0x9c, 0x05, 0xa1, 0xe9, 0xb4, 0x78, 0x31, 0x62, 0x95, 0xb3, 0x4f, 0x3b, 0x28, 0x94, 0x2f,
	0x95, 0xe7, 0x59, 0xfa, 0x27, 0x66, 0x63, 0x95, 0xb1, 0xf9, 0xcc, 0xf9, 0x7c, 0x61, 0x2e, 0x5f,
	0x2e, 0x2e, 0x94, 0x24, 0xa6, 0x88, 0x5b, 0x90, 0x71, 0xf7, 0x81, 0xe1, 0x9e, 0xdc, 0xb7, 0x44,
	0xf6, 0x09, 0xa1, 0x7f, 0xed, 0x80, 0x2f, 0xed, 0xe2, 0x77, 0x18, 0xc6, 0x4d, 0x63, 0x95, 0xfa,
	0x6f, 0x03, 0xfd, 0x02, 0xf5, 0xaf, 0x20, 0x36, 0xbc, 0xfb, 0x3a, 0x6e, 0x89, 0xee, 0x7a, 0x1d,
	0xfb, 0x52, 0xaf, 0x33, 0xaf, 0xf0, 0x7a, 0xd9, 0x45, 0x59, 0xfc, 0x6b, 0xf0, 0x71, 0x07, 0x55,
	0x21, 0x05, 0xd3, 0x6b, 0xb5, 0xaa, 0x28, 0xeb, 0xaa, 0xe8, 0x56, 0xc8, 0x47, 0x23, 0xa1, 0x7c,
	0x46, 0x2c, 0xc0, 0x5b, 0x30, 0xb9, 0xcf, 0x32, 0x83, 0xcb, 0xb8, 0x98, 0x29, 0x65, 0x2e, 0x7c,
	0xd2, 0x41, 0xbf, 0x0c, 0x42, 0x0a, 0xa2, 0x0c, 0x67, 0x8d, 0xad, 0xf8, 0xc2, 0x14, 0x9c, 0x6c,
	0x9b, 0x4a, 0xf6, 0xc0, 0x50, 0xc0, 0x65, 0x38, 0xe1, 0xf9, 0x70, 0xd5, 0xce, 0x43, 0xc2, 0xad,
	0x7e, 0xd6, 0xfd, 0x53, 0x37, 0xd9, 0x8c, 0x65, 0xa9, 0xd9, 0x2e, 0xc1, 0x69, 0x4f, 0xd2, 0xc7,
	0xf0, 0x54, 0xa8, 0x0a, 0xbf, 0x46, 0x30, 0xb1, 0x46, 0x2d, 0xa7, 0x25, 0x37, 0x7a, 0xfb, 0x7f,
	0xf6, 0xe7, 0x08, 0x7e, 0x82, 0x20, 0x0d, 0x6f, 0xfb, 0x9b, 0x28, 0xcb, 0xf3, 0xd9, 0x30, 0x14,
	0xb9, 0x51, 0xf7, 0x24, 0x05, 0x61, 0xf5, 0xc3, 0x1b, 0x90, 0x83, 0xf4, 0xd1, 0x9a, 0x54, 0xb7,
	0xa9, 0x4a, 0x06, 0x0d, 0x56, 0xe0, 0x1c, 0x24, 0x0f, 0x1a, 0x10, 0xad, 0x49, 0x74, 0xa7, 0xaf,
	0x36, 0xba, 0xea, 0x7e, 0xa8, 0x5c, 0x84, 0xd9, 0xd7, 0x29, 0xa7, 0x37, 0xd9, 0x6f, 0x1c, 0xba,
	0x76, 0x78, 0x97, 0x8d, 0xbf, 0x23, 0x38, 0x39, 0x64, 0x6e, 0xb0, 0x0a, 0x27, 0x06, 0xd3, 0xe5,
	0xcd, 0xf7, 0xc5, 0xe3, 0x52, 0x9a, 0x8b, 0xcb, 0x59, 0xcd, 0xbb, 0xba, 0x8e, 0xd9, 0xfb, 0x9f,
	0xf0, 0x45, 0xc0, 0x87, 0x53, 0x7f, 0x34, 0xd1, 0xc7, 0x7b, 0xca, 0x2e, 0xec, 0x8a, 0x5a, 0x39,
	0x0d, 0xe1, 0x01, 0xee, 0x42, 0x7b, 0x1d, 0x24, 0x30, 0xee, 0xca, 0x73, 0xaa, 0x16, 0xe2, 0xa1,
	0xd4, 0x33, 0x04, 0xa7, 0x8e, 0x38, 0x0c, 0xfe, 0x2a, 0x84, 0x06, 0x56, 0x7c, 0xac, 0xe7, 0x8f,
	0xff, 0x3f, 0xb1, 0x1c, 0x90, 0xb8, 0xf0, 0x7f, 0xd9, 0x29, 0xb8, 0x0c, 0x21, 0xd6, 0x66, 0x1e,
	0x4f, 0xa7, 0x7a, 0x0e, 0x46, 0x2c, 0xe1, 0x8b, 0xfe, 0x6d, 0xe2, 0x57, 0xc1, 0xb3, 0xde, 0xd3,
	0xfd, 0x60, 0x44, 0xe2, 0xfa, 0x8b, 0xe1, 0xcf, 0x3f, 0x10, 0xf2, 0x99, 0xd2, 0xeb, 0x6d, 0xa3,
	0xca, 0x43, 0xb4, 0xf7, 0x3c, 0x19, 0x78, 0xf2, 0x3c, 0x19, 0x78, 0xf9, 0x3c, 0x89, 0xb6, 0xbb,
	0x49, 0xf4, 0xdb, 0x6e, 0x12, 0xfd, 0xa5, 0x9b, 0x44, 0x7b, 0xdd, 0x24, 0x7a, 0xd2, 0x4d, 0xa2,
	0x67, 0xdd, 0x24, 0xfa, 0xb4, 0x9b, 0x0c, 0xbc, 0xec, 0x26, 0xd1, 0xfd, 0x17, 0xc9, 0xc0, 0xee,
	0x8b, 0x24, 0xda, 0x7b, 0x91, 0x0c, 0x3c, 0x79, 0x91, 0x0c, 0xdc, 0xfa, 0x9e, 0x66, 0x98, 0xb7,
	0xb5, 0x6c, 0xdb, 0x68, 0x38, 0xc4, 0xb2, 0xe4, 0x6c, 0xcb, 0xce, 0xf1, 0x07, 0x36, 0x9f, 0x73,
	0xa6, 0x65, 0xb4, 0xa9, 0x4a, 0xac, 0xb9, 0x9e, 0x38, 0x67, 0xae, 0x6b, 0x46, 0x8e, 0xdc, 0x75,
	0xbc, 0xff, 0xfe, 0x5f, 0xf1, 0xbb, 0xcb, 0x7a, 0x98, 0xff, 0x24, 0x50, 0xfc, 0x4f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x2c, 0xe6, 0xa6, 0xa3, 0xa8, 0x11, 0x00, 0x00,
}

func (this *GCPManagedMode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPManagedMode)
	if !ok {
		that2, ok := that.(GCPManagedMode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GcpRegion != that1.GcpRegion {
		return false
	}
	if !this.GcpCred.Equal(that1.GcpCred) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.InstanceType != that1.InstanceType {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	if that1.PrivateConnectivityChoice == nil {
		if this.PrivateConnectivityChoice != nil {
			return false
		}
	} else if this.PrivateConnectivityChoice == nil {
		return false
	} else if !this.PrivateConnectivityChoice.Equal(that1.PrivateConnectivityChoice) {
		return false
	}
	if that1.SiteType == nil {
		if this.SiteType != nil {
			return false
		}
	} else if this.SiteType == nil {
		return false
	} else if !this.SiteType.Equal(that1.SiteType) {
		return false
	}
	return true
}
func (this *GCPManagedMode_PrivateConnectivityDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPManagedMode_PrivateConnectivityDisabled)
	if !ok {
		that2, ok := that.(GCPManagedMode_PrivateConnectivityDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrivateConnectivityDisabled.Equal(that1.PrivateConnectivityDisabled) {
		return false
	}
	return true
}
func (this *GCPManagedMode_PrivateConnectivity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPManagedMode_PrivateConnectivity)
	if !ok {
		that2, ok := that.(GCPManagedMode_PrivateConnectivity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrivateConnectivity.Equal(that1.PrivateConnectivity) {
		return false
	}
	return true
}
func (this *GCPManagedMode_SingleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPManagedMode_SingleInterface)
	if !ok {
		that2, ok := that.(GCPManagedMode_SingleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SingleInterface.Equal(that1.SingleInterface) {
		return false
	}
	return true
}
func (this *GCPManagedMode_MultipleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPManagedMode_MultipleInterface)
	if !ok {
		that2, ok := that.(GCPManagedMode_MultipleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MultipleInterface.Equal(that1.MultipleInterface) {
		return false
	}
	return true
}
func (this *GCPSingleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSingleInterface)
	if !ok {
		that2, ok := that.(GCPSingleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeList.Equal(that1.NodeList) {
		return false
	}
	return true
}
func (this *GCPMultipleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPMultipleInterface)
	if !ok {
		that2, ok := that.(GCPMultipleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeList.Equal(that1.NodeList) {
		return false
	}
	return true
}
func (this *GCPManagedNodeList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPManagedNodeList)
	if !ok {
		that2, ok := that.(GCPManagedNodeList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.NodeList) != len(that1.NodeList) {
		return false
	}
	for i := range this.NodeList {
		if !this.NodeList[i].Equal(that1.NodeList[i]) {
			return false
		}
	}
	return true
}
func (this *GCPManagedNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPManagedNode)
	if !ok {
		that2, ok := that.(GCPManagedNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.GcpAzName != that1.GcpAzName {
		return false
	}
	if len(this.InterfaceList) != len(that1.InterfaceList) {
		return false
	}
	for i := range this.InterfaceList {
		if !this.InterfaceList[i].Equal(that1.InterfaceList[i]) {
			return false
		}
	}
	return true
}
func (this *GCPCloudVPCParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPCloudVPCParamsType)
	if !ok {
		that2, ok := that.(GCPCloudVPCParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NameChoice == nil {
		if this.NameChoice != nil {
			return false
		}
	} else if this.NameChoice == nil {
		return false
	} else if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	return true
}
func (this *GCPCloudVPCParamsType_NameTag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPCloudVPCParamsType_NameTag)
	if !ok {
		that2, ok := that.(GCPCloudVPCParamsType_NameTag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NameTag != that1.NameTag {
		return false
	}
	return true
}
func (this *GCPCloudVPCParamsType_Autogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPCloudVPCParamsType_Autogenerate)
	if !ok {
		that2, ok := that.(GCPCloudVPCParamsType_Autogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Autogenerate.Equal(that1.Autogenerate) {
		return false
	}
	return true
}
func (this *GCPVPCChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCChoiceType)
	if !ok {
		that2, ok := that.(GCPVPCChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ServiceVpcChoice == nil {
		if this.ServiceVpcChoice != nil {
			return false
		}
	} else if this.ServiceVpcChoice == nil {
		return false
	} else if !this.ServiceVpcChoice.Equal(that1.ServiceVpcChoice) {
		return false
	}
	return true
}
func (this *GCPVPCChoiceType_NewVpc) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCChoiceType_NewVpc)
	if !ok {
		that2, ok := that.(GCPVPCChoiceType_NewVpc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVpc.Equal(that1.NewVpc) {
		return false
	}
	return true
}
func (this *GCPVPCChoiceType_ExistingVpcId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCChoiceType_ExistingVpcId)
	if !ok {
		that2, ok := that.(GCPVPCChoiceType_ExistingVpcId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExistingVpcId != that1.ExistingVpcId {
		return false
	}
	return true
}
func (this *GCPOrchestratedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPOrchestratedInterface)
	if !ok {
		that2, ok := that.(GCPOrchestratedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Vpc.Equal(that1.Vpc) {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	if !this.NetworkOption.Equal(that1.NetworkOption) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if that1.SiteToSiteConnectivityInterfaceChoice == nil {
		if this.SiteToSiteConnectivityInterfaceChoice != nil {
			return false
		}
	} else if this.SiteToSiteConnectivityInterfaceChoice == nil {
		return false
	} else if !this.SiteToSiteConnectivityInterfaceChoice.Equal(that1.SiteToSiteConnectivityInterfaceChoice) {
		return false
	}
	return true
}
func (this *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled)
	if !ok {
		that2, ok := that.(GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteToSiteConnectivityInterfaceDisabled.Equal(that1.SiteToSiteConnectivityInterfaceDisabled) {
		return false
	}
	return true
}
func (this *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled)
	if !ok {
		that2, ok := that.(GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteToSiteConnectivityInterfaceEnabled.Equal(that1.SiteToSiteConnectivityInterfaceEnabled) {
		return false
	}
	return true
}
func (this *GCPSubnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetChoiceType)
	if !ok {
		that2, ok := that.(GCPSubnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *GCPSubnetChoiceType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetChoiceType_SubnetParam)
	if !ok {
		that2, ok := that.(GCPSubnetChoiceType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *GCPSubnetChoiceType_ExistingSubnetId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetChoiceType_ExistingSubnetId)
	if !ok {
		that2, ok := that.(GCPSubnetChoiceType_ExistingSubnetId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExistingSubnetId != that1.ExistingSubnetId {
		return false
	}
	return true
}
func (this *GCPCloudSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPCloudSubnetParamType)
	if !ok {
		that2, ok := that.(GCPCloudSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NameChoice == nil {
		if this.NameChoice != nil {
			return false
		}
	} else if this.NameChoice == nil {
		return false
	} else if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	if this.Ipv4 != that1.Ipv4 {
		return false
	}
	return true
}
func (this *GCPCloudSubnetParamType_Name) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPCloudSubnetParamType_Name)
	if !ok {
		that2, ok := that.(GCPCloudSubnetParamType_Name)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GCPCloudSubnetParamType_Autogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPCloudSubnetParamType_Autogenerate)
	if !ok {
		that2, ok := that.(GCPCloudSubnetParamType_Autogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Autogenerate.Equal(that1.Autogenerate) {
		return false
	}
	return true
}
func (this *GCPManagedMode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&securemesh_site_v2.GCPManagedMode{")
	s = append(s, "GcpRegion: "+fmt.Sprintf("%#v", this.GcpRegion)+",\n")
	if this.GcpCred != nil {
		s = append(s, "GcpCred: "+fmt.Sprintf("%#v", this.GcpCred)+",\n")
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "InstanceType: "+fmt.Sprintf("%#v", this.InstanceType)+",\n")
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	if this.PrivateConnectivityChoice != nil {
		s = append(s, "PrivateConnectivityChoice: "+fmt.Sprintf("%#v", this.PrivateConnectivityChoice)+",\n")
	}
	if this.SiteType != nil {
		s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPManagedMode_PrivateConnectivityDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPManagedMode_PrivateConnectivityDisabled{` +
		`PrivateConnectivityDisabled:` + fmt.Sprintf("%#v", this.PrivateConnectivityDisabled) + `}`}, ", ")
	return s
}
func (this *GCPManagedMode_PrivateConnectivity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPManagedMode_PrivateConnectivity{` +
		`PrivateConnectivity:` + fmt.Sprintf("%#v", this.PrivateConnectivity) + `}`}, ", ")
	return s
}
func (this *GCPManagedMode_SingleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPManagedMode_SingleInterface{` +
		`SingleInterface:` + fmt.Sprintf("%#v", this.SingleInterface) + `}`}, ", ")
	return s
}
func (this *GCPManagedMode_MultipleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPManagedMode_MultipleInterface{` +
		`MultipleInterface:` + fmt.Sprintf("%#v", this.MultipleInterface) + `}`}, ", ")
	return s
}
func (this *GCPSingleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&securemesh_site_v2.GCPSingleInterface{")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPMultipleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&securemesh_site_v2.GCPMultipleInterface{")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPManagedNodeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&securemesh_site_v2.GCPManagedNodeList{")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPManagedNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&securemesh_site_v2.GCPManagedNode{")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "GcpAzName: "+fmt.Sprintf("%#v", this.GcpAzName)+",\n")
	if this.InterfaceList != nil {
		s = append(s, "InterfaceList: "+fmt.Sprintf("%#v", this.InterfaceList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPCloudVPCParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&securemesh_site_v2.GCPCloudVPCParamsType{")
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPCloudVPCParamsType_NameTag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPCloudVPCParamsType_NameTag{` +
		`NameTag:` + fmt.Sprintf("%#v", this.NameTag) + `}`}, ", ")
	return s
}
func (this *GCPCloudVPCParamsType_Autogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPCloudVPCParamsType_Autogenerate{` +
		`Autogenerate:` + fmt.Sprintf("%#v", this.Autogenerate) + `}`}, ", ")
	return s
}
func (this *GCPVPCChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&securemesh_site_v2.GCPVPCChoiceType{")
	if this.ServiceVpcChoice != nil {
		s = append(s, "ServiceVpcChoice: "+fmt.Sprintf("%#v", this.ServiceVpcChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCChoiceType_NewVpc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPVPCChoiceType_NewVpc{` +
		`NewVpc:` + fmt.Sprintf("%#v", this.NewVpc) + `}`}, ", ")
	return s
}
func (this *GCPVPCChoiceType_ExistingVpcId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPVPCChoiceType_ExistingVpcId{` +
		`ExistingVpcId:` + fmt.Sprintf("%#v", this.ExistingVpcId) + `}`}, ", ")
	return s
}
func (this *GCPOrchestratedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&securemesh_site_v2.GCPOrchestratedInterface{")
	if this.Vpc != nil {
		s = append(s, "Vpc: "+fmt.Sprintf("%#v", this.Vpc)+",\n")
	}
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	if this.NetworkOption != nil {
		s = append(s, "NetworkOption: "+fmt.Sprintf("%#v", this.NetworkOption)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	if this.SiteToSiteConnectivityInterfaceChoice != nil {
		s = append(s, "SiteToSiteConnectivityInterfaceChoice: "+fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled{` +
		`SiteToSiteConnectivityInterfaceDisabled:` + fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceDisabled) + `}`}, ", ")
	return s
}
func (this *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled{` +
		`SiteToSiteConnectivityInterfaceEnabled:` + fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceEnabled) + `}`}, ", ")
	return s
}
func (this *GCPSubnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&securemesh_site_v2.GCPSubnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetChoiceType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPSubnetChoiceType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *GCPSubnetChoiceType_ExistingSubnetId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPSubnetChoiceType_ExistingSubnetId{` +
		`ExistingSubnetId:` + fmt.Sprintf("%#v", this.ExistingSubnetId) + `}`}, ", ")
	return s
}
func (this *GCPCloudSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&securemesh_site_v2.GCPCloudSubnetParamType{")
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "Ipv4: "+fmt.Sprintf("%#v", this.Ipv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPCloudSubnetParamType_Name) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPCloudSubnetParamType_Name{` +
		`Name:` + fmt.Sprintf("%#v", this.Name) + `}`}, ", ")
	return s
}
func (this *GCPCloudSubnetParamType_Autogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.GCPCloudSubnetParamType_Autogenerate{` +
		`Autogenerate:` + fmt.Sprintf("%#v", this.Autogenerate) + `}`}, ", ")
	return s
}
func valueToGoStringGcpTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GCPManagedMode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPManagedMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPManagedMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SiteType != nil {
		{
			size := m.SiteType.Size()
			i -= size
			if _, err := m.SiteType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PrivateConnectivityChoice != nil {
		{
			size := m.PrivateConnectivityChoice.Size()
			i -= size
			if _, err := m.PrivateConnectivityChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DiskSize != 0 {
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.DiskSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.InstanceType) > 0 {
		i -= len(m.InstanceType)
		copy(dAtA[i:], m.InstanceType)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.InstanceType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGcpTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintGcpTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGcpTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.GcpCred != nil {
		{
			size, err := m.GcpCred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.GcpRegion) > 0 {
		i -= len(m.GcpRegion)
		copy(dAtA[i:], m.GcpRegion)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.GcpRegion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPManagedMode_PrivateConnectivityDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPManagedMode_PrivateConnectivityDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrivateConnectivityDisabled != nil {
		{
			size, err := m.PrivateConnectivityDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GCPManagedMode_PrivateConnectivity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPManagedMode_PrivateConnectivity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrivateConnectivity != nil {
		{
			size, err := m.PrivateConnectivity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *GCPManagedMode_SingleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPManagedMode_SingleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SingleInterface != nil {
		{
			size, err := m.SingleInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *GCPManagedMode_MultipleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPManagedMode_MultipleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultipleInterface != nil {
		{
			size, err := m.MultipleInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GCPSingleInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSingleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPSingleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeList != nil {
		{
			size, err := m.NodeList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPMultipleInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPMultipleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPMultipleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeList != nil {
		{
			size, err := m.NodeList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPManagedNodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPManagedNodeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPManagedNodeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeList) > 0 {
		for iNdEx := len(m.NodeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGcpTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GCPManagedNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPManagedNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPManagedNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceList) > 0 {
		for iNdEx := len(m.InterfaceList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGcpTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.GcpAzName) > 0 {
		i -= len(m.GcpAzName)
		copy(dAtA[i:], m.GcpAzName)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.GcpAzName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *GCPCloudVPCParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPCloudVPCParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPCloudVPCParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NameChoice != nil {
		{
			size := m.NameChoice.Size()
			i -= size
			if _, err := m.NameChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GCPCloudVPCParamsType_NameTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPCloudVPCParamsType_NameTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NameTag)
	copy(dAtA[i:], m.NameTag)
	i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.NameTag)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *GCPCloudVPCParamsType_Autogenerate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPCloudVPCParamsType_Autogenerate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Autogenerate != nil {
		{
			size, err := m.Autogenerate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GCPVPCChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServiceVpcChoice != nil {
		{
			size := m.ServiceVpcChoice.Size()
			i -= size
			if _, err := m.ServiceVpcChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GCPVPCChoiceType_NewVpc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCChoiceType_NewVpc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewVpc != nil {
		{
			size, err := m.NewVpc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GCPVPCChoiceType_ExistingVpcId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCChoiceType_ExistingVpcId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExistingVpcId)
	copy(dAtA[i:], m.ExistingVpcId)
	i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.ExistingVpcId)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *GCPOrchestratedInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPOrchestratedInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPOrchestratedInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceChoice != nil {
		{
			size := m.SiteToSiteConnectivityInterfaceChoice.Size()
			i -= size
			if _, err := m.SiteToSiteConnectivityInterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Mtu != 0 {
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x20
	}
	if m.NetworkOption != nil {
		{
			size, err := m.NetworkOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Vpc != nil {
		{
			size, err := m.Vpc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteToSiteConnectivityInterfaceDisabled != nil {
		{
			size, err := m.SiteToSiteConnectivityInterfaceDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteToSiteConnectivityInterfaceEnabled != nil {
		{
			size, err := m.SiteToSiteConnectivityInterfaceEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GCPSubnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPSubnetChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GCPSubnetChoiceType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPSubnetChoiceType_SubnetParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *GCPSubnetChoiceType_ExistingSubnetId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPSubnetChoiceType_ExistingSubnetId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExistingSubnetId)
	copy(dAtA[i:], m.ExistingSubnetId)
	i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.ExistingSubnetId)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *GCPCloudSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPCloudSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPCloudSubnetParamType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv4) > 0 {
		i -= len(m.Ipv4)
		copy(dAtA[i:], m.Ipv4)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.Ipv4)))
		i--
		dAtA[i] = 0x22
	}
	if m.NameChoice != nil {
		{
			size := m.NameChoice.Size()
			i -= size
			if _, err := m.NameChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GCPCloudSubnetParamType_Name) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPCloudSubnetParamType_Name) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *GCPCloudSubnetParamType_Autogenerate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPCloudSubnetParamType_Autogenerate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Autogenerate != nil {
		{
			size, err := m.Autogenerate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func encodeVarintGcpTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovGcpTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GCPManagedMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GcpRegion)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.GcpCred != nil {
		l = m.GcpCred.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGcpTypes(uint64(len(k))) + 1 + len(v) + sovGcpTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovGcpTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.InstanceType)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovGcpTypes(uint64(m.DiskSize))
	}
	if m.PrivateConnectivityChoice != nil {
		n += m.PrivateConnectivityChoice.Size()
	}
	if m.SiteType != nil {
		n += m.SiteType.Size()
	}
	return n
}

func (m *GCPManagedMode_PrivateConnectivityDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrivateConnectivityDisabled != nil {
		l = m.PrivateConnectivityDisabled.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}
func (m *GCPManagedMode_PrivateConnectivity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrivateConnectivity != nil {
		l = m.PrivateConnectivity.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}
func (m *GCPManagedMode_SingleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SingleInterface != nil {
		l = m.SingleInterface.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}
func (m *GCPManagedMode_MultipleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultipleInterface != nil {
		l = m.MultipleInterface.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}
func (m *GCPSingleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeList != nil {
		l = m.NodeList.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}

func (m *GCPMultipleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeList != nil {
		l = m.NodeList.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}

func (m *GCPManagedNodeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeList) > 0 {
		for _, e := range m.NodeList {
			l = e.Size()
			n += 1 + l + sovGcpTypes(uint64(l))
		}
	}
	return n
}

func (m *GCPManagedNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.GcpAzName)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if len(m.InterfaceList) > 0 {
		for _, e := range m.InterfaceList {
			l = e.Size()
			n += 1 + l + sovGcpTypes(uint64(l))
		}
	}
	return n
}

func (m *GCPCloudVPCParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NameChoice != nil {
		n += m.NameChoice.Size()
	}
	return n
}

func (m *GCPCloudVPCParamsType_NameTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NameTag)
	n += 1 + l + sovGcpTypes(uint64(l))
	return n
}
func (m *GCPCloudVPCParamsType_Autogenerate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Autogenerate != nil {
		l = m.Autogenerate.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceVpcChoice != nil {
		n += m.ServiceVpcChoice.Size()
	}
	return n
}

func (m *GCPVPCChoiceType_NewVpc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewVpc != nil {
		l = m.NewVpc.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCChoiceType_ExistingVpcId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExistingVpcId)
	n += 1 + l + sovGcpTypes(uint64(l))
	return n
}
func (m *GCPOrchestratedInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vpc != nil {
		l = m.Vpc.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.NetworkOption != nil {
		l = m.NetworkOption.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.Mtu != 0 {
		n += 1 + sovGcpTypes(uint64(m.Mtu))
	}
	if m.SiteToSiteConnectivityInterfaceChoice != nil {
		n += m.SiteToSiteConnectivityInterfaceChoice.Size()
	}
	return n
}

func (m *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceDisabled != nil {
		l = m.SiteToSiteConnectivityInterfaceDisabled.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}
func (m *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceEnabled != nil {
		l = m.SiteToSiteConnectivityInterfaceEnabled.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}
func (m *GCPSubnetChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *GCPSubnetChoiceType_SubnetParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}
func (m *GCPSubnetChoiceType_ExistingSubnetId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExistingSubnetId)
	n += 1 + l + sovGcpTypes(uint64(l))
	return n
}
func (m *GCPCloudSubnetParamType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NameChoice != nil {
		n += m.NameChoice.Size()
	}
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}

func (m *GCPCloudSubnetParamType_Name) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGcpTypes(uint64(l))
	return n
}
func (m *GCPCloudSubnetParamType_Autogenerate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Autogenerate != nil {
		l = m.Autogenerate.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}

func sovGcpTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGcpTypes(x uint64) (n int) {
	return sovGcpTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GCPManagedMode) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&GCPManagedMode{`,
		`GcpRegion:` + fmt.Sprintf("%v", this.GcpRegion) + `,`,
		`GcpCred:` + strings.Replace(fmt.Sprintf("%v", this.GcpCred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`InstanceType:` + fmt.Sprintf("%v", this.InstanceType) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`PrivateConnectivityChoice:` + fmt.Sprintf("%v", this.PrivateConnectivityChoice) + `,`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPManagedMode_PrivateConnectivityDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPManagedMode_PrivateConnectivityDisabled{`,
		`PrivateConnectivityDisabled:` + strings.Replace(fmt.Sprintf("%v", this.PrivateConnectivityDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPManagedMode_PrivateConnectivity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPManagedMode_PrivateConnectivity{`,
		`PrivateConnectivity:` + strings.Replace(fmt.Sprintf("%v", this.PrivateConnectivity), "PrivateConnectConfigType", "views.PrivateConnectConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPManagedMode_SingleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPManagedMode_SingleInterface{`,
		`SingleInterface:` + strings.Replace(fmt.Sprintf("%v", this.SingleInterface), "GCPSingleInterface", "GCPSingleInterface", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPManagedMode_MultipleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPManagedMode_MultipleInterface{`,
		`MultipleInterface:` + strings.Replace(fmt.Sprintf("%v", this.MultipleInterface), "GCPMultipleInterface", "GCPMultipleInterface", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSingleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSingleInterface{`,
		`NodeList:` + strings.Replace(this.NodeList.String(), "GCPManagedNodeList", "GCPManagedNodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPMultipleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPMultipleInterface{`,
		`NodeList:` + strings.Replace(this.NodeList.String(), "GCPManagedNodeList", "GCPManagedNodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPManagedNodeList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodeList := "[]*GCPManagedNode{"
	for _, f := range this.NodeList {
		repeatedStringForNodeList += strings.Replace(f.String(), "GCPManagedNode", "GCPManagedNode", 1) + ","
	}
	repeatedStringForNodeList += "}"
	s := strings.Join([]string{`&GCPManagedNodeList{`,
		`NodeList:` + repeatedStringForNodeList + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPManagedNode) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterfaceList := "[]*GCPOrchestratedInterface{"
	for _, f := range this.InterfaceList {
		repeatedStringForInterfaceList += strings.Replace(f.String(), "GCPOrchestratedInterface", "GCPOrchestratedInterface", 1) + ","
	}
	repeatedStringForInterfaceList += "}"
	s := strings.Join([]string{`&GCPManagedNode{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`GcpAzName:` + fmt.Sprintf("%v", this.GcpAzName) + `,`,
		`InterfaceList:` + repeatedStringForInterfaceList + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPCloudVPCParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPCloudVPCParamsType{`,
		`NameChoice:` + fmt.Sprintf("%v", this.NameChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPCloudVPCParamsType_NameTag) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPCloudVPCParamsType_NameTag{`,
		`NameTag:` + fmt.Sprintf("%v", this.NameTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPCloudVPCParamsType_Autogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPCloudVPCParamsType_Autogenerate{`,
		`Autogenerate:` + strings.Replace(fmt.Sprintf("%v", this.Autogenerate), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCChoiceType{`,
		`ServiceVpcChoice:` + fmt.Sprintf("%v", this.ServiceVpcChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCChoiceType_NewVpc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCChoiceType_NewVpc{`,
		`NewVpc:` + strings.Replace(fmt.Sprintf("%v", this.NewVpc), "GCPCloudVPCParamsType", "GCPCloudVPCParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCChoiceType_ExistingVpcId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCChoiceType_ExistingVpcId{`,
		`ExistingVpcId:` + fmt.Sprintf("%v", this.ExistingVpcId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPOrchestratedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPOrchestratedInterface{`,
		`Vpc:` + strings.Replace(this.Vpc.String(), "GCPVPCChoiceType", "GCPVPCChoiceType", 1) + `,`,
		`Subnet:` + strings.Replace(this.Subnet.String(), "GCPSubnetChoiceType", "GCPSubnetChoiceType", 1) + `,`,
		`NetworkOption:` + strings.Replace(fmt.Sprintf("%v", this.NetworkOption), "NetworkSelectType", "views.NetworkSelectType", 1) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`SiteToSiteConnectivityInterfaceChoice:` + fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled{`,
		`SiteToSiteConnectivityInterfaceDisabled:` + strings.Replace(fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled{`,
		`SiteToSiteConnectivityInterfaceEnabled:` + strings.Replace(fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceEnabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetChoiceType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetChoiceType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "GCPCloudSubnetParamType", "GCPCloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetChoiceType_ExistingSubnetId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetChoiceType_ExistingSubnetId{`,
		`ExistingSubnetId:` + fmt.Sprintf("%v", this.ExistingSubnetId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPCloudSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPCloudSubnetParamType{`,
		`NameChoice:` + fmt.Sprintf("%v", this.NameChoice) + `,`,
		`Ipv4:` + fmt.Sprintf("%v", this.Ipv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPCloudSubnetParamType_Name) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPCloudSubnetParamType_Name{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPCloudSubnetParamType_Autogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPCloudSubnetParamType_Autogenerate{`,
		`Autogenerate:` + strings.Replace(fmt.Sprintf("%v", this.Autogenerate), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGcpTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GCPManagedMode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPManagedMode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPManagedMode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpCred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GcpCred == nil {
				m.GcpCred = &views.ObjectRefType{}
			}
			if err := m.GcpCred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGcpTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGcpTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGcpTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGcpTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGcpTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGcpTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGcpTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGcpTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGcpTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateConnectivityDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrivateConnectivityChoice = &GCPManagedMode_PrivateConnectivityDisabled{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateConnectivity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.PrivateConnectConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrivateConnectivityChoice = &GCPManagedMode_PrivateConnectivity{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPSingleInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteType = &GCPManagedMode_SingleInterface{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPMultipleInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteType = &GCPManagedMode_MultipleInterface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSingleInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSingleInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSingleInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeList == nil {
				m.NodeList = &GCPManagedNodeList{}
			}
			if err := m.NodeList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPMultipleInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPMultipleInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPMultipleInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeList == nil {
				m.NodeList = &GCPManagedNodeList{}
			}
			if err := m.NodeList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPManagedNodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPManagedNodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPManagedNodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeList = append(m.NodeList, &GCPManagedNode{})
			if err := m.NodeList[len(m.NodeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPManagedNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPManagedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPManagedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpAzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpAzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceList = append(m.InterfaceList, &GCPOrchestratedInterface{})
			if err := m.InterfaceList[len(m.InterfaceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPCloudVPCParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPCloudVPCParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPCloudVPCParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameChoice = &GCPCloudVPCParamsType_NameTag{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NameChoice = &GCPCloudVPCParamsType_Autogenerate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPCloudVPCParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ServiceVpcChoice = &GCPVPCChoiceType_NewVpc{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingVpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceVpcChoice = &GCPVPCChoiceType_ExistingVpcId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPOrchestratedInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPOrchestratedInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPOrchestratedInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vpc == nil {
				m.Vpc = &GCPVPCChoiceType{}
			}
			if err := m.Vpc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &GCPSubnetChoiceType{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkOption == nil {
				m.NetworkOption = &views.NetworkSelectType{}
			}
			if err := m.NetworkOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteConnectivityInterfaceDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteToSiteConnectivityInterfaceChoice = &GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteConnectivityInterfaceEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteToSiteConnectivityInterfaceChoice = &GCPOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPCloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPSubnetChoiceType_SubnetParam{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &GCPSubnetChoiceType_ExistingSubnetId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPCloudSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPCloudSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPCloudSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameChoice = &GCPCloudSubnetParamType_Name{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NameChoice = &GCPCloudSubnetParamType_Autogenerate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGcpTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGcpTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGcpTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGcpTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGcpTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGcpTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGcpTypes = fmt.Errorf("proto: unexpected end of group")
)
