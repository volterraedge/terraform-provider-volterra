// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package securemesh_site_v2

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_network_interface "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_virtual_network "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_network"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AWSProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSProviderType) DeepCopy() *AWSProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *AWSProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AWSProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *AWSProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	case *AWSProviderType_Managed:

		drInfos, err := m.GetManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateAWSProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *AWSProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*AWSProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AWSProviderType_Managed:
		if fv, exists := v.FldValidators["orchestration_choice.managed"]; exists {
			val := m.GetOrchestrationChoice().(*AWSProviderType_Managed).Managed
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSProviderTypeValidator = func() *ValidateAWSProviderType {
	v := &ValidateAWSProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate
	v.FldValidators["orchestration_choice.managed"] = AWSManagedModeValidator().Validate

	return v
}()

func AWSProviderTypeValidator() db.Validator {
	return DefaultAWSProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureProviderType) DeepCopy() *AzureProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *AzureProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *AzureProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *AzureProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateAzureProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *AzureProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*AzureProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureProviderTypeValidator = func() *ValidateAzureProviderType {
	v := &ValidateAzureProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate

	return v
}()

func AzureProviderTypeValidator() db.Validator {
	return DefaultAzureProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BaremetalProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BaremetalProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BaremetalProviderType) DeepCopy() *BaremetalProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BaremetalProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BaremetalProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BaremetalProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BaremetalProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *BaremetalProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *BaremetalProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *BaremetalProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateBaremetalProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBaremetalProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BaremetalProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BaremetalProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *BaremetalProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*BaremetalProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBaremetalProviderTypeValidator = func() *ValidateBaremetalProviderType {
	v := &ValidateBaremetalProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate

	return v
}()

func BaremetalProviderTypeValidator() db.Validator {
	return DefaultBaremetalProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdminUserCredentials().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.admin_user_credentials")
	}

	if err := m.GetCustomProxy().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.custom_proxy")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetForwardProxyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetForwardProxyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLocalVrfDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLocalVrfDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLogsReceiverChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkPolicyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkPolicyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetProviderChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetProviderChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetS2SConnectivitySliChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetS2SConnectivitySliChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetS2SConnectivitySloChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetS2SConnectivitySloChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetForwardProxyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetForwardProxyChoice() == nil {
		return nil, nil
	}
	switch m.GetForwardProxyChoice().(type) {
	case *CreateSpecType_NoForwardProxy:

		return nil, nil

	case *CreateSpecType_ActiveForwardProxyPolicies:

		drInfos, err := m.GetActiveForwardProxyPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveForwardProxyPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_forward_proxy_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetLocalVrfDRefInfo() ([]db.DRefInfo, error) {
	if m.GetLocalVrf() == nil {
		return nil, nil
	}

	drInfos, err := m.GetLocalVrf().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetLocalVrf().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "local_vrf." + dri.DRField
	}
	return drInfos, err

}

func (m *CreateSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetLogsReceiverChoice().(type) {
	case *CreateSpecType_LogsStreamingDisabled:

		return nil, nil

	case *CreateSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		dri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *CreateSpecType_LogsStreamingDisabled:

	case *CreateSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetNetworkPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNetworkPolicyChoice() == nil {
		return nil, nil
	}
	switch m.GetNetworkPolicyChoice().(type) {
	case *CreateSpecType_NoNetworkPolicy:

		return nil, nil

	case *CreateSpecType_ActiveEnhancedFirewallPolicies:

		drInfos, err := m.GetActiveEnhancedFirewallPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveEnhancedFirewallPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_enhanced_firewall_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetProviderChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetProviderChoice() == nil {
		return nil, nil
	}
	switch m.GetProviderChoice().(type) {
	case *CreateSpecType_Vmware:

		drInfos, err := m.GetVmware().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVmware().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vmware." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Kvm:

		drInfos, err := m.GetKvm().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetKvm().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "kvm." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Aws:

		drInfos, err := m.GetAws().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAws().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "aws." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Azure:

		drInfos, err := m.GetAzure().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAzure().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "azure." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Gcp:

		drInfos, err := m.GetGcp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetGcp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "gcp." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Rseries:

		drInfos, err := m.GetRseries().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRseries().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "rseries." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Baremetal:

		drInfos, err := m.GetBaremetal().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetBaremetal().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "baremetal." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Oci:

		drInfos, err := m.GetOci().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOci().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "oci." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Openstack:

		drInfos, err := m.GetOpenstack().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOpenstack().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "openstack." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_Nutanix:

		drInfos, err := m.GetNutanix().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNutanix().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "nutanix." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *CreateSpecType) GetS2SConnectivitySliChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetS2SConnectivitySliChoice().(type) {
	case *CreateSpecType_NoS2SConnectivitySli:

		return nil, nil

	case *CreateSpecType_DcClusterGroupSli:

		vref := m.GetDcClusterGroupSli()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_sli",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetS2SConnectivitySliChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetS2SConnectivitySliChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetS2SConnectivitySliChoice().(type) {
	case *CreateSpecType_NoS2SConnectivitySli:

	case *CreateSpecType_DcClusterGroupSli:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupSli()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetS2SConnectivitySloChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetS2SConnectivitySloChoice() == nil {
		return nil, nil
	}
	switch m.GetS2SConnectivitySloChoice().(type) {
	case *CreateSpecType_NoS2SConnectivitySlo:

		return nil, nil

	case *CreateSpecType_SiteMeshGroupOnSlo:

		drInfos, err := m.GetSiteMeshGroupOnSlo().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSiteMeshGroupOnSlo().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site_mesh_group_on_slo." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_DcClusterGroupSlo:

		vref := m.GetDcClusterGroupSlo()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_slo",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) BlockedServicesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocked_services_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ProviderChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for provider_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["admin_user_credentials"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_user_credentials"))
		if err := fv(ctx, m.GetAdminUserCredentials(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocked_services_choice"]; exists {
		val := m.GetBlockedServicesChoice()
		vOpts := append(opts,
			db.WithValidateField("blocked_services_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockedServicesChoice().(type) {
	case *CreateSpecType_BlockAllServices:
		if fv, exists := v.FldValidators["blocked_services_choice.block_all_services"]; exists {
			val := m.GetBlockedServicesChoice().(*CreateSpecType_BlockAllServices).BlockAllServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("block_all_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_BlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*CreateSpecType_BlockedServices).BlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_ntp_config"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_ntp_config"))
		if err := fv(ctx, m.GetDnsNtpConfig(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetEnterpriseProxyChoice().(type) {
	case *CreateSpecType_F5Proxy:
		if fv, exists := v.FldValidators["enterprise_proxy_choice.f5_proxy"]; exists {
			val := m.GetEnterpriseProxyChoice().(*CreateSpecType_F5Proxy).F5Proxy
			vOpts := append(opts,
				db.WithValidateField("enterprise_proxy_choice"),
				db.WithValidateField("f5_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_CustomProxy:
		if fv, exists := v.FldValidators["enterprise_proxy_choice.custom_proxy"]; exists {
			val := m.GetEnterpriseProxyChoice().(*CreateSpecType_CustomProxy).CustomProxy
			vOpts := append(opts,
				db.WithValidateField("enterprise_proxy_choice"),
				db.WithValidateField("custom_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetForwardProxyChoice().(type) {
	case *CreateSpecType_NoForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.no_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*CreateSpecType_NoForwardProxy).NoForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("no_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ActiveForwardProxyPolicies:
		if fv, exists := v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"]; exists {
			val := m.GetForwardProxyChoice().(*CreateSpecType_ActiveForwardProxyPolicies).ActiveForwardProxyPolicies
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("active_forward_proxy_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["load_balancing"]; exists {

		vOpts := append(opts, db.WithValidateField("load_balancing"))
		if err := fv(ctx, m.GetLoadBalancing(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_vrf"]; exists {

		vOpts := append(opts, db.WithValidateField("local_vrf"))
		if err := fv(ctx, m.GetLocalVrf(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *CreateSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*CreateSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*CreateSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetNetworkPolicyChoice().(type) {
	case *CreateSpecType_NoNetworkPolicy:
		if fv, exists := v.FldValidators["network_policy_choice.no_network_policy"]; exists {
			val := m.GetNetworkPolicyChoice().(*CreateSpecType_NoNetworkPolicy).NoNetworkPolicy
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("no_network_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_ActiveEnhancedFirewallPolicies:
		if fv, exists := v.FldValidators["network_policy_choice.active_enhanced_firewall_policies"]; exists {
			val := m.GetNetworkPolicyChoice().(*CreateSpecType_ActiveEnhancedFirewallPolicies).ActiveEnhancedFirewallPolicies
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("active_enhanced_firewall_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetNodeHaChoice().(type) {
	case *CreateSpecType_DisableHa:
		if fv, exists := v.FldValidators["node_ha_choice.disable_ha"]; exists {
			val := m.GetNodeHaChoice().(*CreateSpecType_DisableHa).DisableHa
			vOpts := append(opts,
				db.WithValidateField("node_ha_choice"),
				db.WithValidateField("disable_ha"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_EnableHa:
		if fv, exists := v.FldValidators["node_ha_choice.enable_ha"]; exists {
			val := m.GetNodeHaChoice().(*CreateSpecType_EnableHa).EnableHa
			vOpts := append(opts,
				db.WithValidateField("node_ha_choice"),
				db.WithValidateField("enable_ha"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["offline_survivability_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("offline_survivability_mode"))
		if err := fv(ctx, m.GetOfflineSurvivabilityMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["performance_enhancement_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("performance_enhancement_mode"))
		if err := fv(ctx, m.GetPerformanceEnhancementMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proactive_monitoring"]; exists {

		vOpts := append(opts, db.WithValidateField("proactive_monitoring"))
		if err := fv(ctx, m.GetProactiveMonitoring(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_choice"]; exists {
		val := m.GetProviderChoice()
		vOpts := append(opts,
			db.WithValidateField("provider_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetProviderChoice().(type) {
	case *CreateSpecType_Vmware:
		if fv, exists := v.FldValidators["provider_choice.vmware"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Vmware).Vmware
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("vmware"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Kvm:
		if fv, exists := v.FldValidators["provider_choice.kvm"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Kvm).Kvm
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("kvm"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Aws:
		if fv, exists := v.FldValidators["provider_choice.aws"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Aws).Aws
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("aws"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Azure:
		if fv, exists := v.FldValidators["provider_choice.azure"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Azure).Azure
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("azure"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Gcp:
		if fv, exists := v.FldValidators["provider_choice.gcp"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Gcp).Gcp
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("gcp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Rseries:
		if fv, exists := v.FldValidators["provider_choice.rseries"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Rseries).Rseries
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("rseries"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Baremetal:
		if fv, exists := v.FldValidators["provider_choice.baremetal"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Baremetal).Baremetal
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("baremetal"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Oci:
		if fv, exists := v.FldValidators["provider_choice.oci"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Oci).Oci
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("oci"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Openstack:
		if fv, exists := v.FldValidators["provider_choice.openstack"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Openstack).Openstack
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("openstack"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Nutanix:
		if fv, exists := v.FldValidators["provider_choice.nutanix"]; exists {
			val := m.GetProviderChoice().(*CreateSpecType_Nutanix).Nutanix
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("nutanix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["re_select"]; exists {

		vOpts := append(opts, db.WithValidateField("re_select"))
		if err := fv(ctx, m.GetReSelect(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetS2SConnectivitySliChoice().(type) {
	case *CreateSpecType_NoS2SConnectivitySli:
		if fv, exists := v.FldValidators["s2s_connectivity_sli_choice.no_s2s_connectivity_sli"]; exists {
			val := m.GetS2SConnectivitySliChoice().(*CreateSpecType_NoS2SConnectivitySli).NoS2SConnectivitySli
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_sli_choice"),
				db.WithValidateField("no_s2s_connectivity_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DcClusterGroupSli:
		if fv, exists := v.FldValidators["s2s_connectivity_sli_choice.dc_cluster_group_sli"]; exists {
			val := m.GetS2SConnectivitySliChoice().(*CreateSpecType_DcClusterGroupSli).DcClusterGroupSli
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_sli_choice"),
				db.WithValidateField("dc_cluster_group_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetS2SConnectivitySloChoice().(type) {
	case *CreateSpecType_NoS2SConnectivitySlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.no_s2s_connectivity_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*CreateSpecType_NoS2SConnectivitySlo).NoS2SConnectivitySlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("no_s2s_connectivity_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_SiteMeshGroupOnSlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.site_mesh_group_on_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*CreateSpecType_SiteMeshGroupOnSlo).SiteMeshGroupOnSlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("site_mesh_group_on_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DcClusterGroupSlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.dc_cluster_group_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*CreateSpecType_DcClusterGroupSlo).DcClusterGroupSlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("dc_cluster_group_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["software_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("software_settings"))
		if err := fv(ctx, m.GetSoftwareSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upgrade_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("upgrade_settings"))
		if err := fv(ctx, m.GetUpgradeSettings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBlockedServicesChoice := v.BlockedServicesChoiceValidationRuleHandler
	rulesBlockedServicesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockedServicesChoice(rulesBlockedServicesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.blocked_services_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocked_services_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhProviderChoice := v.ProviderChoiceValidationRuleHandler
	rulesProviderChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhProviderChoice(rulesProviderChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.provider_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["provider_choice"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["blocked_services_choice.blocked_services"] = ves_io_schema_fleet.BlockedServicesListTypeValidator().Validate

	v.FldValidators["enterprise_proxy_choice.custom_proxy"] = CustomProxyValidator().Validate

	v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"] = ves_io_schema_network_firewall.ActiveForwardProxyPoliciesTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["network_policy_choice.active_enhanced_firewall_policies"] = ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesTypeValidator().Validate

	v.FldValidators["provider_choice.vmware"] = VMwareProviderTypeValidator().Validate
	v.FldValidators["provider_choice.kvm"] = KVMProviderTypeValidator().Validate
	v.FldValidators["provider_choice.aws"] = AWSProviderTypeValidator().Validate
	v.FldValidators["provider_choice.azure"] = AzureProviderTypeValidator().Validate
	v.FldValidators["provider_choice.gcp"] = GCPProviderTypeValidator().Validate
	v.FldValidators["provider_choice.rseries"] = RSeriesProviderTypeValidator().Validate
	v.FldValidators["provider_choice.baremetal"] = BaremetalProviderTypeValidator().Validate
	v.FldValidators["provider_choice.oci"] = OCIProviderTypeValidator().Validate
	v.FldValidators["provider_choice.openstack"] = OpenstackProviderTypeValidator().Validate
	v.FldValidators["provider_choice.nutanix"] = NutanixProviderTypeValidator().Validate

	v.FldValidators["s2s_connectivity_sli_choice.dc_cluster_group_sli"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["s2s_connectivity_slo_choice.site_mesh_group_on_slo"] = SiteMeshGroupTypeValidator().Validate
	v.FldValidators["s2s_connectivity_slo_choice.dc_cluster_group_slo"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["software_settings"] = SoftwareSettingsTypeValidator().Validate

	v.FldValidators["upgrade_settings"] = UpgradeSettingsTypeValidator().Validate

	v.FldValidators["performance_enhancement_mode"] = ves_io_schema_views.PerformanceEnhancementModeTypeValidator().Validate

	v.FldValidators["offline_survivability_mode"] = ves_io_schema_views.OfflineSurvivabilityModeTypeValidator().Validate

	v.FldValidators["local_vrf"] = LocalVRFSettingTypeValidator().Validate

	v.FldValidators["re_select"] = ves_io_schema_views.RegionalEdgeSelectionValidator().Validate

	v.FldValidators["admin_user_credentials"] = ves_io_schema_views.AdminUserCredentialsTypeValidator().Validate

	v.FldValidators["dns_ntp_config"] = DNSNTPServerConfigValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomDNSSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomDNSSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomDNSSettings) DeepCopy() *CustomDNSSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomDNSSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomDNSSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomDNSSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomDNSSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateCustomDNSSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomDNSSettings) DnsServersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for dns_servers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dns_servers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dns_servers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dns_servers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCustomDNSSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomDNSSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomDNSSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_servers"]; exists {
		vOpts := append(opts, db.WithValidateField("dns_servers"))
		if err := fv(ctx, m.GetDnsServers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomDNSSettingsValidator = func() *ValidateCustomDNSSettings {
	v := &ValidateCustomDNSSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsServers := v.DnsServersValidationRuleHandler
	rulesDnsServers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDnsServers(rulesDnsServers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomDNSSettings.dns_servers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_servers"] = vFn

	return v
}()

func CustomDNSSettingsValidator() db.Validator {
	return DefaultCustomDNSSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomNTPSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomNTPSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomNTPSettings) DeepCopy() *CustomNTPSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomNTPSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomNTPSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomNTPSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomNTPSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateCustomNTPSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomNTPSettings) NtpServersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ntp_servers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ntp_servers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ntp_servers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ntp_servers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCustomNTPSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomNTPSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomNTPSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ntp_servers"]; exists {
		vOpts := append(opts, db.WithValidateField("ntp_servers"))
		if err := fv(ctx, m.GetNtpServers(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomNTPSettingsValidator = func() *ValidateCustomNTPSettings {
	v := &ValidateCustomNTPSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNtpServers := v.NtpServersValidationRuleHandler
	rulesNtpServers := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhNtpServers(rulesNtpServers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomNTPSettings.ntp_servers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ntp_servers"] = vFn

	return v
}()

func CustomNTPSettingsValidator() db.Validator {
	return DefaultCustomNTPSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomProxy) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomProxy) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CustomProxy) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CustomProxy.password")
	}

	return nil
}

func (m *CustomProxy) DeepCopy() *CustomProxy {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomProxy{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomProxy) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomProxy) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomProxyValidator().Validate(ctx, m, opts...)
}

type ValidateCustomProxy struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomProxy) ProxyIpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for proxy_ip_address")
	}

	return validatorFn, nil
}

func (v *ValidateCustomProxy) ProxyPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for proxy_port")
	}

	return validatorFn, nil
}

func (v *ValidateCustomProxy) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomProxy)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomProxy got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proxy_ip_address"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy_ip_address"))
		if err := fv(ctx, m.GetProxyIpAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proxy_port"]; exists {

		vOpts := append(opts, db.WithValidateField("proxy_port"))
		if err := fv(ctx, m.GetProxyPort(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetUseForReTunnelChoice().(type) {
	case *CustomProxy_DisableReTunnel:
		if fv, exists := v.FldValidators["use_for_re_tunnel_choice.disable_re_tunnel"]; exists {
			val := m.GetUseForReTunnelChoice().(*CustomProxy_DisableReTunnel).DisableReTunnel
			vOpts := append(opts,
				db.WithValidateField("use_for_re_tunnel_choice"),
				db.WithValidateField("disable_re_tunnel"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CustomProxy_EnableReTunnel:
		if fv, exists := v.FldValidators["use_for_re_tunnel_choice.enable_re_tunnel"]; exists {
			val := m.GetUseForReTunnelChoice().(*CustomProxy_EnableReTunnel).EnableReTunnel
			vOpts := append(opts,
				db.WithValidateField("use_for_re_tunnel_choice"),
				db.WithValidateField("enable_re_tunnel"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomProxyValidator = func() *ValidateCustomProxy {
	v := &ValidateCustomProxy{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhProxyIpAddress := v.ProxyIpAddressValidationRuleHandler
	rulesProxyIpAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ipv4":      "true",
	}
	vFn, err = vrhProxyIpAddress(rulesProxyIpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomProxy.proxy_ip_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["proxy_ip_address"] = vFn

	vrhProxyPort := v.ProxyPortValidationRuleHandler
	rulesProxyPort := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "0",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhProxyPort(rulesProxyPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomProxy.proxy_port: %s", err)
		panic(errMsg)
	}
	v.FldValidators["proxy_port"] = vFn

	v.FldValidators["password"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func CustomProxyValidator() db.Validator {
	return DefaultCustomProxyValidator
}

// augmented methods on protoc/std generated struct

func (m *DNSNTPServerConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DNSNTPServerConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DNSNTPServerConfig) DeepCopy() *DNSNTPServerConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DNSNTPServerConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DNSNTPServerConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DNSNTPServerConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DNSNTPServerConfigValidator().Validate(ctx, m, opts...)
}

type ValidateDNSNTPServerConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDNSNTPServerConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DNSNTPServerConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DNSNTPServerConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetDnsServerChoice().(type) {
	case *DNSNTPServerConfig_F5DnsDefault:
		if fv, exists := v.FldValidators["dns_server_choice.f5_dns_default"]; exists {
			val := m.GetDnsServerChoice().(*DNSNTPServerConfig_F5DnsDefault).F5DnsDefault
			vOpts := append(opts,
				db.WithValidateField("dns_server_choice"),
				db.WithValidateField("f5_dns_default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DNSNTPServerConfig_CustomDns:
		if fv, exists := v.FldValidators["dns_server_choice.custom_dns"]; exists {
			val := m.GetDnsServerChoice().(*DNSNTPServerConfig_CustomDns).CustomDns
			vOpts := append(opts,
				db.WithValidateField("dns_server_choice"),
				db.WithValidateField("custom_dns"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetNtpServerChoice().(type) {
	case *DNSNTPServerConfig_F5NtpDefault:
		if fv, exists := v.FldValidators["ntp_server_choice.f5_ntp_default"]; exists {
			val := m.GetNtpServerChoice().(*DNSNTPServerConfig_F5NtpDefault).F5NtpDefault
			vOpts := append(opts,
				db.WithValidateField("ntp_server_choice"),
				db.WithValidateField("f5_ntp_default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DNSNTPServerConfig_CustomNtp:
		if fv, exists := v.FldValidators["ntp_server_choice.custom_ntp"]; exists {
			val := m.GetNtpServerChoice().(*DNSNTPServerConfig_CustomNtp).CustomNtp
			vOpts := append(opts,
				db.WithValidateField("ntp_server_choice"),
				db.WithValidateField("custom_ntp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDNSNTPServerConfigValidator = func() *ValidateDNSNTPServerConfig {
	v := &ValidateDNSNTPServerConfig{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["dns_server_choice.custom_dns"] = CustomDNSSettingsValidator().Validate

	v.FldValidators["ntp_server_choice.custom_ntp"] = CustomNTPSettingsValidator().Validate

	return v
}()

func DNSNTPServerConfigValidator() db.Validator {
	return DefaultDNSNTPServerConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *EthernetInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EthernetInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EthernetInterfaceType) DeepCopy() *EthernetInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EthernetInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EthernetInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EthernetInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EthernetInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateEthernetInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEthernetInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) MacValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mac")
	}

	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EthernetInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EthernetInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mac"]; exists {

		vOpts := append(opts, db.WithValidateField("mac"))
		if err := fv(ctx, m.GetMac(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEthernetInterfaceTypeValidator = func() *ValidateEthernetInterfaceType {
	v := &ValidateEthernetInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhMac := v.MacValidationRuleHandler
	rulesMac := map[string]string{
		"ves.io.schema.rules.string.mac": "true",
	}
	vFn, err = vrhMac(rulesMac)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.mac: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mac"] = vFn

	return v
}()

func EthernetInterfaceTypeValidator() db.Validator {
	return DefaultEthernetInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GCPProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GCPProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GCPProviderType) DeepCopy() *GCPProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GCPProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GCPProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GCPProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GCPProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *GCPProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *GCPProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *GCPProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateGCPProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGCPProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GCPProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GCPProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *GCPProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*GCPProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGCPProviderTypeValidator = func() *ValidateGCPProviderType {
	v := &ValidateGCPProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate

	return v
}()

func GCPProviderTypeValidator() db.Validator {
	return DefaultGCPProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdminUserCredentials().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.admin_user_credentials")
	}

	if err := m.GetCustomProxy().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.custom_proxy")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetForwardProxyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetForwardProxyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLocalVrfDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLocalVrfDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLogsReceiverChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkPolicyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkPolicyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetProviderChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetProviderChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetS2SConnectivitySliChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetS2SConnectivitySliChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetS2SConnectivitySloChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetS2SConnectivitySloChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetForwardProxyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetForwardProxyChoice() == nil {
		return nil, nil
	}
	switch m.GetForwardProxyChoice().(type) {
	case *GetSpecType_NoForwardProxy:

		return nil, nil

	case *GetSpecType_ActiveForwardProxyPolicies:

		drInfos, err := m.GetActiveForwardProxyPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveForwardProxyPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_forward_proxy_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetLocalVrfDRefInfo() ([]db.DRefInfo, error) {
	if m.GetLocalVrf() == nil {
		return nil, nil
	}

	drInfos, err := m.GetLocalVrf().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetLocalVrf().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "local_vrf." + dri.DRField
	}
	return drInfos, err

}

func (m *GetSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetLogsReceiverChoice().(type) {
	case *GetSpecType_LogsStreamingDisabled:

		return nil, nil

	case *GetSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		dri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *GetSpecType_LogsStreamingDisabled:

	case *GetSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetNetworkPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNetworkPolicyChoice() == nil {
		return nil, nil
	}
	switch m.GetNetworkPolicyChoice().(type) {
	case *GetSpecType_NoNetworkPolicy:

		return nil, nil

	case *GetSpecType_ActiveEnhancedFirewallPolicies:

		drInfos, err := m.GetActiveEnhancedFirewallPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveEnhancedFirewallPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_enhanced_firewall_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetProviderChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetProviderChoice() == nil {
		return nil, nil
	}
	switch m.GetProviderChoice().(type) {
	case *GetSpecType_Vmware:

		drInfos, err := m.GetVmware().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVmware().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vmware." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Kvm:

		drInfos, err := m.GetKvm().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetKvm().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "kvm." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Aws:

		drInfos, err := m.GetAws().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAws().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "aws." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Azure:

		drInfos, err := m.GetAzure().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAzure().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "azure." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Gcp:

		drInfos, err := m.GetGcp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetGcp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "gcp." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Rseries:

		drInfos, err := m.GetRseries().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRseries().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "rseries." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Baremetal:

		drInfos, err := m.GetBaremetal().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetBaremetal().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "baremetal." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Oci:

		drInfos, err := m.GetOci().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOci().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "oci." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Openstack:

		drInfos, err := m.GetOpenstack().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOpenstack().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "openstack." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_Nutanix:

		drInfos, err := m.GetNutanix().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNutanix().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "nutanix." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GetSpecType) GetS2SConnectivitySliChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetS2SConnectivitySliChoice().(type) {
	case *GetSpecType_NoS2SConnectivitySli:

		return nil, nil

	case *GetSpecType_DcClusterGroupSli:

		vref := m.GetDcClusterGroupSli()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_sli",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetS2SConnectivitySliChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetS2SConnectivitySliChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetS2SConnectivitySliChoice().(type) {
	case *GetSpecType_NoS2SConnectivitySli:

	case *GetSpecType_DcClusterGroupSli:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupSli()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetS2SConnectivitySloChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetS2SConnectivitySloChoice() == nil {
		return nil, nil
	}
	switch m.GetS2SConnectivitySloChoice().(type) {
	case *GetSpecType_NoS2SConnectivitySlo:

		return nil, nil

	case *GetSpecType_SiteMeshGroupOnSlo:

		drInfos, err := m.GetSiteMeshGroupOnSlo().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSiteMeshGroupOnSlo().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site_mesh_group_on_slo." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_DcClusterGroupSlo:

		vref := m.GetDcClusterGroupSlo()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_slo",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) BlockedServicesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocked_services_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) ProviderChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for provider_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["admin_user_credentials"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_user_credentials"))
		if err := fv(ctx, m.GetAdminUserCredentials(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocked_services_choice"]; exists {
		val := m.GetBlockedServicesChoice()
		vOpts := append(opts,
			db.WithValidateField("blocked_services_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockedServicesChoice().(type) {
	case *GetSpecType_BlockAllServices:
		if fv, exists := v.FldValidators["blocked_services_choice.block_all_services"]; exists {
			val := m.GetBlockedServicesChoice().(*GetSpecType_BlockAllServices).BlockAllServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("block_all_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_BlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*GetSpecType_BlockedServices).BlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_ntp_config"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_ntp_config"))
		if err := fv(ctx, m.GetDnsNtpConfig(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetEnterpriseProxyChoice().(type) {
	case *GetSpecType_F5Proxy:
		if fv, exists := v.FldValidators["enterprise_proxy_choice.f5_proxy"]; exists {
			val := m.GetEnterpriseProxyChoice().(*GetSpecType_F5Proxy).F5Proxy
			vOpts := append(opts,
				db.WithValidateField("enterprise_proxy_choice"),
				db.WithValidateField("f5_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_CustomProxy:
		if fv, exists := v.FldValidators["enterprise_proxy_choice.custom_proxy"]; exists {
			val := m.GetEnterpriseProxyChoice().(*GetSpecType_CustomProxy).CustomProxy
			vOpts := append(opts,
				db.WithValidateField("enterprise_proxy_choice"),
				db.WithValidateField("custom_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetForwardProxyChoice().(type) {
	case *GetSpecType_NoForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.no_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*GetSpecType_NoForwardProxy).NoForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("no_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ActiveForwardProxyPolicies:
		if fv, exists := v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"]; exists {
			val := m.GetForwardProxyChoice().(*GetSpecType_ActiveForwardProxyPolicies).ActiveForwardProxyPolicies
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("active_forward_proxy_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["load_balancing"]; exists {

		vOpts := append(opts, db.WithValidateField("load_balancing"))
		if err := fv(ctx, m.GetLoadBalancing(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_vrf"]; exists {

		vOpts := append(opts, db.WithValidateField("local_vrf"))
		if err := fv(ctx, m.GetLocalVrf(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *GetSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*GetSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*GetSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetNetworkPolicyChoice().(type) {
	case *GetSpecType_NoNetworkPolicy:
		if fv, exists := v.FldValidators["network_policy_choice.no_network_policy"]; exists {
			val := m.GetNetworkPolicyChoice().(*GetSpecType_NoNetworkPolicy).NoNetworkPolicy
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("no_network_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_ActiveEnhancedFirewallPolicies:
		if fv, exists := v.FldValidators["network_policy_choice.active_enhanced_firewall_policies"]; exists {
			val := m.GetNetworkPolicyChoice().(*GetSpecType_ActiveEnhancedFirewallPolicies).ActiveEnhancedFirewallPolicies
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("active_enhanced_firewall_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetNodeHaChoice().(type) {
	case *GetSpecType_DisableHa:
		if fv, exists := v.FldValidators["node_ha_choice.disable_ha"]; exists {
			val := m.GetNodeHaChoice().(*GetSpecType_DisableHa).DisableHa
			vOpts := append(opts,
				db.WithValidateField("node_ha_choice"),
				db.WithValidateField("disable_ha"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_EnableHa:
		if fv, exists := v.FldValidators["node_ha_choice.enable_ha"]; exists {
			val := m.GetNodeHaChoice().(*GetSpecType_EnableHa).EnableHa
			vOpts := append(opts,
				db.WithValidateField("node_ha_choice"),
				db.WithValidateField("enable_ha"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["offline_survivability_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("offline_survivability_mode"))
		if err := fv(ctx, m.GetOfflineSurvivabilityMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["performance_enhancement_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("performance_enhancement_mode"))
		if err := fv(ctx, m.GetPerformanceEnhancementMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proactive_monitoring"]; exists {

		vOpts := append(opts, db.WithValidateField("proactive_monitoring"))
		if err := fv(ctx, m.GetProactiveMonitoring(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_choice"]; exists {
		val := m.GetProviderChoice()
		vOpts := append(opts,
			db.WithValidateField("provider_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetProviderChoice().(type) {
	case *GetSpecType_Vmware:
		if fv, exists := v.FldValidators["provider_choice.vmware"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Vmware).Vmware
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("vmware"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Kvm:
		if fv, exists := v.FldValidators["provider_choice.kvm"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Kvm).Kvm
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("kvm"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Aws:
		if fv, exists := v.FldValidators["provider_choice.aws"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Aws).Aws
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("aws"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Azure:
		if fv, exists := v.FldValidators["provider_choice.azure"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Azure).Azure
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("azure"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Gcp:
		if fv, exists := v.FldValidators["provider_choice.gcp"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Gcp).Gcp
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("gcp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Rseries:
		if fv, exists := v.FldValidators["provider_choice.rseries"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Rseries).Rseries
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("rseries"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Baremetal:
		if fv, exists := v.FldValidators["provider_choice.baremetal"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Baremetal).Baremetal
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("baremetal"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Oci:
		if fv, exists := v.FldValidators["provider_choice.oci"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Oci).Oci
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("oci"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Openstack:
		if fv, exists := v.FldValidators["provider_choice.openstack"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Openstack).Openstack
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("openstack"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Nutanix:
		if fv, exists := v.FldValidators["provider_choice.nutanix"]; exists {
			val := m.GetProviderChoice().(*GetSpecType_Nutanix).Nutanix
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("nutanix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["re_select"]; exists {

		vOpts := append(opts, db.WithValidateField("re_select"))
		if err := fv(ctx, m.GetReSelect(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetS2SConnectivitySliChoice().(type) {
	case *GetSpecType_NoS2SConnectivitySli:
		if fv, exists := v.FldValidators["s2s_connectivity_sli_choice.no_s2s_connectivity_sli"]; exists {
			val := m.GetS2SConnectivitySliChoice().(*GetSpecType_NoS2SConnectivitySli).NoS2SConnectivitySli
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_sli_choice"),
				db.WithValidateField("no_s2s_connectivity_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DcClusterGroupSli:
		if fv, exists := v.FldValidators["s2s_connectivity_sli_choice.dc_cluster_group_sli"]; exists {
			val := m.GetS2SConnectivitySliChoice().(*GetSpecType_DcClusterGroupSli).DcClusterGroupSli
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_sli_choice"),
				db.WithValidateField("dc_cluster_group_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetS2SConnectivitySloChoice().(type) {
	case *GetSpecType_NoS2SConnectivitySlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.no_s2s_connectivity_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*GetSpecType_NoS2SConnectivitySlo).NoS2SConnectivitySlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("no_s2s_connectivity_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_SiteMeshGroupOnSlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.site_mesh_group_on_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*GetSpecType_SiteMeshGroupOnSlo).SiteMeshGroupOnSlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("site_mesh_group_on_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DcClusterGroupSlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.dc_cluster_group_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*GetSpecType_DcClusterGroupSlo).DcClusterGroupSlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("dc_cluster_group_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_state"]; exists {

		vOpts := append(opts, db.WithValidateField("site_state"))
		if err := fv(ctx, m.GetSiteState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["software_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("software_settings"))
		if err := fv(ctx, m.GetSoftwareSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upgrade_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("upgrade_settings"))
		if err := fv(ctx, m.GetUpgradeSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBlockedServicesChoice := v.BlockedServicesChoiceValidationRuleHandler
	rulesBlockedServicesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockedServicesChoice(rulesBlockedServicesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.blocked_services_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocked_services_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhProviderChoice := v.ProviderChoiceValidationRuleHandler
	rulesProviderChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhProviderChoice(rulesProviderChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.provider_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["provider_choice"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	v.FldValidators["blocked_services_choice.blocked_services"] = ves_io_schema_fleet.BlockedServicesListTypeValidator().Validate

	v.FldValidators["enterprise_proxy_choice.custom_proxy"] = CustomProxyValidator().Validate

	v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"] = ves_io_schema_network_firewall.ActiveForwardProxyPoliciesTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["network_policy_choice.active_enhanced_firewall_policies"] = ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesTypeValidator().Validate

	v.FldValidators["provider_choice.vmware"] = VMwareProviderTypeValidator().Validate
	v.FldValidators["provider_choice.kvm"] = KVMProviderTypeValidator().Validate
	v.FldValidators["provider_choice.aws"] = AWSProviderTypeValidator().Validate
	v.FldValidators["provider_choice.azure"] = AzureProviderTypeValidator().Validate
	v.FldValidators["provider_choice.gcp"] = GCPProviderTypeValidator().Validate
	v.FldValidators["provider_choice.rseries"] = RSeriesProviderTypeValidator().Validate
	v.FldValidators["provider_choice.baremetal"] = BaremetalProviderTypeValidator().Validate
	v.FldValidators["provider_choice.oci"] = OCIProviderTypeValidator().Validate
	v.FldValidators["provider_choice.openstack"] = OpenstackProviderTypeValidator().Validate
	v.FldValidators["provider_choice.nutanix"] = NutanixProviderTypeValidator().Validate

	v.FldValidators["s2s_connectivity_sli_choice.dc_cluster_group_sli"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["s2s_connectivity_slo_choice.site_mesh_group_on_slo"] = SiteMeshGroupTypeValidator().Validate
	v.FldValidators["s2s_connectivity_slo_choice.dc_cluster_group_slo"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["software_settings"] = SoftwareSettingsTypeValidator().Validate

	v.FldValidators["upgrade_settings"] = UpgradeSettingsTypeValidator().Validate

	v.FldValidators["performance_enhancement_mode"] = ves_io_schema_views.PerformanceEnhancementModeTypeValidator().Validate

	v.FldValidators["offline_survivability_mode"] = ves_io_schema_views.OfflineSurvivabilityModeTypeValidator().Validate

	v.FldValidators["local_vrf"] = LocalVRFSettingTypeValidator().Validate

	v.FldValidators["re_select"] = ves_io_schema_views.RegionalEdgeSelectionValidator().Validate

	v.FldValidators["admin_user_credentials"] = ves_io_schema_views.AdminUserCredentialsTypeValidator().Validate

	v.FldValidators["dns_ntp_config"] = DNSNTPServerConfigValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdminUserCredentials().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.admin_user_credentials")
	}

	if err := m.GetCustomProxy().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.custom_proxy")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetForwardProxyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetForwardProxyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLocalVrfDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLocalVrfDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLogsReceiverChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkPolicyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkPolicyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetProviderChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetProviderChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetS2SConnectivitySliChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetS2SConnectivitySliChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetS2SConnectivitySloChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetS2SConnectivitySloChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetViewInternalDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetViewInternalDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetForwardProxyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetForwardProxyChoice() == nil {
		return nil, nil
	}
	switch m.GetForwardProxyChoice().(type) {
	case *GlobalSpecType_NoForwardProxy:

		return nil, nil

	case *GlobalSpecType_ActiveForwardProxyPolicies:

		drInfos, err := m.GetActiveForwardProxyPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveForwardProxyPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_forward_proxy_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetLocalVrfDRefInfo() ([]db.DRefInfo, error) {
	if m.GetLocalVrf() == nil {
		return nil, nil
	}

	drInfos, err := m.GetLocalVrf().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetLocalVrf().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "local_vrf." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetLogsReceiverChoice().(type) {
	case *GlobalSpecType_LogsStreamingDisabled:

		return nil, nil

	case *GlobalSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		dri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *GlobalSpecType_LogsStreamingDisabled:

	case *GlobalSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetNetworkPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNetworkPolicyChoice() == nil {
		return nil, nil
	}
	switch m.GetNetworkPolicyChoice().(type) {
	case *GlobalSpecType_NoNetworkPolicy:

		return nil, nil

	case *GlobalSpecType_ActiveEnhancedFirewallPolicies:

		drInfos, err := m.GetActiveEnhancedFirewallPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveEnhancedFirewallPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_enhanced_firewall_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetProviderChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetProviderChoice() == nil {
		return nil, nil
	}
	switch m.GetProviderChoice().(type) {
	case *GlobalSpecType_Vmware:

		drInfos, err := m.GetVmware().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVmware().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vmware." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Kvm:

		drInfos, err := m.GetKvm().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetKvm().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "kvm." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Aws:

		drInfos, err := m.GetAws().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAws().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "aws." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Azure:

		drInfos, err := m.GetAzure().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAzure().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "azure." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Gcp:

		drInfos, err := m.GetGcp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetGcp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "gcp." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Rseries:

		drInfos, err := m.GetRseries().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRseries().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "rseries." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Baremetal:

		drInfos, err := m.GetBaremetal().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetBaremetal().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "baremetal." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Oci:

		drInfos, err := m.GetOci().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOci().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "oci." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Openstack:

		drInfos, err := m.GetOpenstack().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOpenstack().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "openstack." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Nutanix:

		drInfos, err := m.GetNutanix().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNutanix().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "nutanix." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetS2SConnectivitySliChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetS2SConnectivitySliChoice().(type) {
	case *GlobalSpecType_NoS2SConnectivitySli:

		return nil, nil

	case *GlobalSpecType_DcClusterGroupSli:

		vref := m.GetDcClusterGroupSli()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_sli",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetS2SConnectivitySliChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetS2SConnectivitySliChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetS2SConnectivitySliChoice().(type) {
	case *GlobalSpecType_NoS2SConnectivitySli:

	case *GlobalSpecType_DcClusterGroupSli:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupSli()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetS2SConnectivitySloChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetS2SConnectivitySloChoice() == nil {
		return nil, nil
	}
	switch m.GetS2SConnectivitySloChoice().(type) {
	case *GlobalSpecType_NoS2SConnectivitySlo:

		return nil, nil

	case *GlobalSpecType_SiteMeshGroupOnSlo:

		drInfos, err := m.GetSiteMeshGroupOnSlo().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSiteMeshGroupOnSlo().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site_mesh_group_on_slo." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_DcClusterGroupSlo:

		vref := m.GetDcClusterGroupSlo()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_slo",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetViewInternalDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("view_internal.Object")
	dri := db.DRefInfo{
		RefdType:   "view_internal.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "view_internal",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetViewInternalDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetViewInternalDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "view_internal.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: view_internal")
	}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "view_internal.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) BlockedServicesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocked_services_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ProviderChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for provider_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["admin_user_credentials"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_user_credentials"))
		if err := fv(ctx, m.GetAdminUserCredentials(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocked_services_choice"]; exists {
		val := m.GetBlockedServicesChoice()
		vOpts := append(opts,
			db.WithValidateField("blocked_services_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockedServicesChoice().(type) {
	case *GlobalSpecType_BlockAllServices:
		if fv, exists := v.FldValidators["blocked_services_choice.block_all_services"]; exists {
			val := m.GetBlockedServicesChoice().(*GlobalSpecType_BlockAllServices).BlockAllServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("block_all_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_BlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*GlobalSpecType_BlockedServices).BlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_ntp_config"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_ntp_config"))
		if err := fv(ctx, m.GetDnsNtpConfig(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetEnterpriseProxyChoice().(type) {
	case *GlobalSpecType_F5Proxy:
		if fv, exists := v.FldValidators["enterprise_proxy_choice.f5_proxy"]; exists {
			val := m.GetEnterpriseProxyChoice().(*GlobalSpecType_F5Proxy).F5Proxy
			vOpts := append(opts,
				db.WithValidateField("enterprise_proxy_choice"),
				db.WithValidateField("f5_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_CustomProxy:
		if fv, exists := v.FldValidators["enterprise_proxy_choice.custom_proxy"]; exists {
			val := m.GetEnterpriseProxyChoice().(*GlobalSpecType_CustomProxy).CustomProxy
			vOpts := append(opts,
				db.WithValidateField("enterprise_proxy_choice"),
				db.WithValidateField("custom_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetForwardProxyChoice().(type) {
	case *GlobalSpecType_NoForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.no_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*GlobalSpecType_NoForwardProxy).NoForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("no_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ActiveForwardProxyPolicies:
		if fv, exists := v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"]; exists {
			val := m.GetForwardProxyChoice().(*GlobalSpecType_ActiveForwardProxyPolicies).ActiveForwardProxyPolicies
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("active_forward_proxy_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["load_balancing"]; exists {

		vOpts := append(opts, db.WithValidateField("load_balancing"))
		if err := fv(ctx, m.GetLoadBalancing(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_vrf"]; exists {

		vOpts := append(opts, db.WithValidateField("local_vrf"))
		if err := fv(ctx, m.GetLocalVrf(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *GlobalSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*GlobalSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*GlobalSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetNetworkPolicyChoice().(type) {
	case *GlobalSpecType_NoNetworkPolicy:
		if fv, exists := v.FldValidators["network_policy_choice.no_network_policy"]; exists {
			val := m.GetNetworkPolicyChoice().(*GlobalSpecType_NoNetworkPolicy).NoNetworkPolicy
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("no_network_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_ActiveEnhancedFirewallPolicies:
		if fv, exists := v.FldValidators["network_policy_choice.active_enhanced_firewall_policies"]; exists {
			val := m.GetNetworkPolicyChoice().(*GlobalSpecType_ActiveEnhancedFirewallPolicies).ActiveEnhancedFirewallPolicies
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("active_enhanced_firewall_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetNodeHaChoice().(type) {
	case *GlobalSpecType_DisableHa:
		if fv, exists := v.FldValidators["node_ha_choice.disable_ha"]; exists {
			val := m.GetNodeHaChoice().(*GlobalSpecType_DisableHa).DisableHa
			vOpts := append(opts,
				db.WithValidateField("node_ha_choice"),
				db.WithValidateField("disable_ha"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_EnableHa:
		if fv, exists := v.FldValidators["node_ha_choice.enable_ha"]; exists {
			val := m.GetNodeHaChoice().(*GlobalSpecType_EnableHa).EnableHa
			vOpts := append(opts,
				db.WithValidateField("node_ha_choice"),
				db.WithValidateField("enable_ha"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["offline_survivability_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("offline_survivability_mode"))
		if err := fv(ctx, m.GetOfflineSurvivabilityMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["performance_enhancement_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("performance_enhancement_mode"))
		if err := fv(ctx, m.GetPerformanceEnhancementMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proactive_monitoring"]; exists {

		vOpts := append(opts, db.WithValidateField("proactive_monitoring"))
		if err := fv(ctx, m.GetProactiveMonitoring(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_choice"]; exists {
		val := m.GetProviderChoice()
		vOpts := append(opts,
			db.WithValidateField("provider_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetProviderChoice().(type) {
	case *GlobalSpecType_Vmware:
		if fv, exists := v.FldValidators["provider_choice.vmware"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Vmware).Vmware
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("vmware"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Kvm:
		if fv, exists := v.FldValidators["provider_choice.kvm"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Kvm).Kvm
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("kvm"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Aws:
		if fv, exists := v.FldValidators["provider_choice.aws"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Aws).Aws
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("aws"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Azure:
		if fv, exists := v.FldValidators["provider_choice.azure"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Azure).Azure
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("azure"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Gcp:
		if fv, exists := v.FldValidators["provider_choice.gcp"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Gcp).Gcp
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("gcp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Rseries:
		if fv, exists := v.FldValidators["provider_choice.rseries"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Rseries).Rseries
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("rseries"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Baremetal:
		if fv, exists := v.FldValidators["provider_choice.baremetal"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Baremetal).Baremetal
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("baremetal"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Oci:
		if fv, exists := v.FldValidators["provider_choice.oci"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Oci).Oci
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("oci"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Openstack:
		if fv, exists := v.FldValidators["provider_choice.openstack"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Openstack).Openstack
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("openstack"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Nutanix:
		if fv, exists := v.FldValidators["provider_choice.nutanix"]; exists {
			val := m.GetProviderChoice().(*GlobalSpecType_Nutanix).Nutanix
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("nutanix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["re_select"]; exists {

		vOpts := append(opts, db.WithValidateField("re_select"))
		if err := fv(ctx, m.GetReSelect(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetS2SConnectivitySliChoice().(type) {
	case *GlobalSpecType_NoS2SConnectivitySli:
		if fv, exists := v.FldValidators["s2s_connectivity_sli_choice.no_s2s_connectivity_sli"]; exists {
			val := m.GetS2SConnectivitySliChoice().(*GlobalSpecType_NoS2SConnectivitySli).NoS2SConnectivitySli
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_sli_choice"),
				db.WithValidateField("no_s2s_connectivity_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DcClusterGroupSli:
		if fv, exists := v.FldValidators["s2s_connectivity_sli_choice.dc_cluster_group_sli"]; exists {
			val := m.GetS2SConnectivitySliChoice().(*GlobalSpecType_DcClusterGroupSli).DcClusterGroupSli
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_sli_choice"),
				db.WithValidateField("dc_cluster_group_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetS2SConnectivitySloChoice().(type) {
	case *GlobalSpecType_NoS2SConnectivitySlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.no_s2s_connectivity_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*GlobalSpecType_NoS2SConnectivitySlo).NoS2SConnectivitySlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("no_s2s_connectivity_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_SiteMeshGroupOnSlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.site_mesh_group_on_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*GlobalSpecType_SiteMeshGroupOnSlo).SiteMeshGroupOnSlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("site_mesh_group_on_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DcClusterGroupSlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.dc_cluster_group_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*GlobalSpecType_DcClusterGroupSlo).DcClusterGroupSlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("dc_cluster_group_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_state"]; exists {

		vOpts := append(opts, db.WithValidateField("site_state"))
		if err := fv(ctx, m.GetSiteState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["software_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("software_settings"))
		if err := fv(ctx, m.GetSoftwareSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upgrade_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("upgrade_settings"))
		if err := fv(ctx, m.GetUpgradeSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["view_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("view_internal"))
		if err := fv(ctx, m.GetViewInternal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBlockedServicesChoice := v.BlockedServicesChoiceValidationRuleHandler
	rulesBlockedServicesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockedServicesChoice(rulesBlockedServicesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.blocked_services_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocked_services_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhProviderChoice := v.ProviderChoiceValidationRuleHandler
	rulesProviderChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhProviderChoice(rulesProviderChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.provider_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["provider_choice"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "512",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	v.FldValidators["blocked_services_choice.blocked_services"] = ves_io_schema_fleet.BlockedServicesListTypeValidator().Validate

	v.FldValidators["enterprise_proxy_choice.custom_proxy"] = CustomProxyValidator().Validate

	v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"] = ves_io_schema_network_firewall.ActiveForwardProxyPoliciesTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["network_policy_choice.active_enhanced_firewall_policies"] = ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesTypeValidator().Validate

	v.FldValidators["provider_choice.vmware"] = VMwareProviderTypeValidator().Validate
	v.FldValidators["provider_choice.kvm"] = KVMProviderTypeValidator().Validate
	v.FldValidators["provider_choice.aws"] = AWSProviderTypeValidator().Validate
	v.FldValidators["provider_choice.azure"] = AzureProviderTypeValidator().Validate
	v.FldValidators["provider_choice.gcp"] = GCPProviderTypeValidator().Validate
	v.FldValidators["provider_choice.rseries"] = RSeriesProviderTypeValidator().Validate
	v.FldValidators["provider_choice.baremetal"] = BaremetalProviderTypeValidator().Validate
	v.FldValidators["provider_choice.oci"] = OCIProviderTypeValidator().Validate
	v.FldValidators["provider_choice.openstack"] = OpenstackProviderTypeValidator().Validate
	v.FldValidators["provider_choice.nutanix"] = NutanixProviderTypeValidator().Validate

	v.FldValidators["s2s_connectivity_sli_choice.dc_cluster_group_sli"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["s2s_connectivity_slo_choice.site_mesh_group_on_slo"] = SiteMeshGroupTypeValidator().Validate
	v.FldValidators["s2s_connectivity_slo_choice.dc_cluster_group_slo"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["software_settings"] = SoftwareSettingsTypeValidator().Validate

	v.FldValidators["upgrade_settings"] = UpgradeSettingsTypeValidator().Validate

	v.FldValidators["performance_enhancement_mode"] = ves_io_schema_views.PerformanceEnhancementModeTypeValidator().Validate

	v.FldValidators["offline_survivability_mode"] = ves_io_schema_views.OfflineSurvivabilityModeTypeValidator().Validate

	v.FldValidators["local_vrf"] = LocalVRFSettingTypeValidator().Validate

	v.FldValidators["re_select"] = ves_io_schema_views.RegionalEdgeSelectionValidator().Validate

	v.FldValidators["admin_user_credentials"] = ves_io_schema_views.AdminUserCredentialsTypeValidator().Validate

	v.FldValidators["dns_ntp_config"] = DNSNTPServerConfigValidator().Validate

	v.FldValidators["coordinates"] = ves_io_schema_site.CoordinatesValidator().Validate

	v.FldValidators["view_internal"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Interface) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Interface) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Interface) DeepCopy() *Interface {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Interface{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Interface) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Interface) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InterfaceValidator().Validate(ctx, m, opts...)
}

func (m *Interface) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAddressChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAddressChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetIpv6AddressChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpv6AddressChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkOptionDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkOptionDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *Interface) GetAddressChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAddressChoice() == nil {
		return nil, nil
	}
	switch m.GetAddressChoice().(type) {
	case *Interface_DhcpClient:

		return nil, nil

	case *Interface_StaticIp:

		return nil, nil

	case *Interface_DhcpServer:

		drInfos, err := m.GetDhcpServer().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDhcpServer().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "dhcp_server." + dri.DRField
		}
		return drInfos, err

	case *Interface_NoIpv4Address:

		return nil, nil

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *Interface) GetIpv6AddressChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpv6AddressChoice() == nil {
		return nil, nil
	}
	switch m.GetIpv6AddressChoice().(type) {
	case *Interface_NoIpv6Address:

		return nil, nil

	case *Interface_StaticIpv6Address:

		drInfos, err := m.GetStaticIpv6Address().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStaticIpv6Address().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "static_ipv6_address." + dri.DRField
		}
		return drInfos, err

	case *Interface_Ipv6AutoConfig:

		drInfos, err := m.GetIpv6AutoConfig().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetIpv6AutoConfig().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ipv6_auto_config." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *Interface) GetNetworkOptionDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNetworkOption() == nil {
		return nil, nil
	}

	drInfos, err := m.GetNetworkOption().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetNetworkOption().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "network_option." + dri.DRField
	}
	return drInfos, err

}

type ValidateInterface struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInterface) AddressChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address_choice")
	}
	return validatorFn, nil
}

func (v *ValidateInterface) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateInterface) DescriptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for description")
	}

	return validatorFn, nil
}

func (v *ValidateInterface) LabelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for labels")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for labels")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for labels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map labels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items labels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateInterface) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateInterface) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateInterface) NetworkOptionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for network_option")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateInterface) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateInterface) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Interface)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Interface got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address_choice"]; exists {
		val := m.GetAddressChoice()
		vOpts := append(opts,
			db.WithValidateField("address_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAddressChoice().(type) {
	case *Interface_DhcpClient:
		if fv, exists := v.FldValidators["address_choice.dhcp_client"]; exists {
			val := m.GetAddressChoice().(*Interface_DhcpClient).DhcpClient
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("dhcp_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Interface_StaticIp:
		if fv, exists := v.FldValidators["address_choice.static_ip"]; exists {
			val := m.GetAddressChoice().(*Interface_StaticIp).StaticIp
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Interface_DhcpServer:
		if fv, exists := v.FldValidators["address_choice.dhcp_server"]; exists {
			val := m.GetAddressChoice().(*Interface_DhcpServer).DhcpServer
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("dhcp_server"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Interface_NoIpv4Address:
		if fv, exists := v.FldValidators["address_choice.no_ipv4_address"]; exists {
			val := m.GetAddressChoice().(*Interface_NoIpv4Address).NoIpv4Address
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("no_ipv4_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *Interface_EthernetInterface:
		if fv, exists := v.FldValidators["interface_choice.ethernet_interface"]; exists {
			val := m.GetInterfaceChoice().(*Interface_EthernetInterface).EthernetInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("ethernet_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Interface_VlanInterface:
		if fv, exists := v.FldValidators["interface_choice.vlan_interface"]; exists {
			val := m.GetInterfaceChoice().(*Interface_VlanInterface).VlanInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("vlan_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Interface_BondInterface:
		if fv, exists := v.FldValidators["interface_choice.bond_interface"]; exists {
			val := m.GetInterfaceChoice().(*Interface_BondInterface).BondInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("bond_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetIpv6AddressChoice().(type) {
	case *Interface_NoIpv6Address:
		if fv, exists := v.FldValidators["ipv6_address_choice.no_ipv6_address"]; exists {
			val := m.GetIpv6AddressChoice().(*Interface_NoIpv6Address).NoIpv6Address
			vOpts := append(opts,
				db.WithValidateField("ipv6_address_choice"),
				db.WithValidateField("no_ipv6_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Interface_StaticIpv6Address:
		if fv, exists := v.FldValidators["ipv6_address_choice.static_ipv6_address"]; exists {
			val := m.GetIpv6AddressChoice().(*Interface_StaticIpv6Address).StaticIpv6Address
			vOpts := append(opts,
				db.WithValidateField("ipv6_address_choice"),
				db.WithValidateField("static_ipv6_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Interface_Ipv6AutoConfig:
		if fv, exists := v.FldValidators["ipv6_address_choice.ipv6_auto_config"]; exists {
			val := m.GetIpv6AddressChoice().(*Interface_Ipv6AutoConfig).Ipv6AutoConfig
			vOpts := append(opts,
				db.WithValidateField("ipv6_address_choice"),
				db.WithValidateField("ipv6_auto_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["is_management"]; exists {

		vOpts := append(opts, db.WithValidateField("is_management"))
		if err := fv(ctx, m.GetIsManagement(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["is_primary"]; exists {

		vOpts := append(opts, db.WithValidateField("is_primary"))
		if err := fv(ctx, m.GetIsPrimary(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {
		vOpts := append(opts, db.WithValidateField("labels"))
		if err := fv(ctx, m.GetLabels(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *Interface_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*Interface_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Interface_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*Interface_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_option"]; exists {

		vOpts := append(opts, db.WithValidateField("network_option"))
		if err := fv(ctx, m.GetNetworkOption(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetSiteToSiteConnectivityInterfaceChoice().(type) {
	case *Interface_SiteToSiteConnectivityInterfaceDisabled:
		if fv, exists := v.FldValidators["site_to_site_connectivity_interface_choice.site_to_site_connectivity_interface_disabled"]; exists {
			val := m.GetSiteToSiteConnectivityInterfaceChoice().(*Interface_SiteToSiteConnectivityInterfaceDisabled).SiteToSiteConnectivityInterfaceDisabled
			vOpts := append(opts,
				db.WithValidateField("site_to_site_connectivity_interface_choice"),
				db.WithValidateField("site_to_site_connectivity_interface_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Interface_SiteToSiteConnectivityInterfaceEnabled:
		if fv, exists := v.FldValidators["site_to_site_connectivity_interface_choice.site_to_site_connectivity_interface_enabled"]; exists {
			val := m.GetSiteToSiteConnectivityInterfaceChoice().(*Interface_SiteToSiteConnectivityInterfaceEnabled).SiteToSiteConnectivityInterfaceEnabled
			vOpts := append(opts,
				db.WithValidateField("site_to_site_connectivity_interface_choice"),
				db.WithValidateField("site_to_site_connectivity_interface_enabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInterfaceValidator = func() *ValidateInterface {
	v := &ValidateInterface{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddressChoice := v.AddressChoiceValidationRuleHandler
	rulesAddressChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAddressChoice(rulesAddressChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Interface.address_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_choice"] = vFn

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Interface.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	vrhDescription := v.DescriptionValidationRuleHandler
	rulesDescription := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhDescription(rulesDescription)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Interface.description: %s", err)
		panic(errMsg)
	}
	v.FldValidators["description"] = vFn

	vrhLabels := v.LabelsValidationRuleHandler
	rulesLabels := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "64",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "64",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhLabels(rulesLabels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Interface.labels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["labels"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Interface.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Interface.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhNetworkOption := v.NetworkOptionValidationRuleHandler
	rulesNetworkOption := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetworkOption(rulesNetworkOption)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Interface.network_option: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_option"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Interface.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	v.FldValidators["address_choice.static_ip"] = ves_io_schema_network_interface.StaticIpParametersNodeTypeValidator().Validate
	v.FldValidators["address_choice.dhcp_server"] = ves_io_schema_network_interface.DHCPServerParametersTypeValidator().Validate

	v.FldValidators["interface_choice.ethernet_interface"] = EthernetInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.vlan_interface"] = VlanInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.bond_interface"] = ves_io_schema_fleet.FleetBondDeviceTypeValidator().Validate

	v.FldValidators["ipv6_address_choice.static_ipv6_address"] = ves_io_schema_network_interface.StaticIPParametersTypeValidator().Validate
	v.FldValidators["ipv6_address_choice.ipv6_auto_config"] = ves_io_schema_network_interface.IPV6AutoConfigTypeValidator().Validate

	return v
}()

func InterfaceValidator() db.Validator {
	return DefaultInterfaceValidator
}

// augmented methods on protoc/std generated struct

func (m *KVMProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *KVMProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *KVMProviderType) DeepCopy() *KVMProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &KVMProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *KVMProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *KVMProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return KVMProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *KVMProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *KVMProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *KVMProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateKVMProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateKVMProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*KVMProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *KVMProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *KVMProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*KVMProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultKVMProviderTypeValidator = func() *ValidateKVMProviderType {
	v := &ValidateKVMProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate

	return v
}()

func KVMProviderTypeValidator() db.Validator {
	return DefaultKVMProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LoadBalancingSettingsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoadBalancingSettingsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoadBalancingSettingsType) DeepCopy() *LoadBalancingSettingsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoadBalancingSettingsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoadBalancingSettingsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoadBalancingSettingsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoadBalancingSettingsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLoadBalancingSettingsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoadBalancingSettingsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoadBalancingSettingsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoadBalancingSettingsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoadBalancingSettingsTypeValidator = func() *ValidateLoadBalancingSettingsType {
	v := &ValidateLoadBalancingSettingsType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LoadBalancingSettingsTypeValidator() db.Validator {
	return DefaultLoadBalancingSettingsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LocalVRFSettingType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LocalVRFSettingType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LocalVRFSettingType) DeepCopy() *LocalVRFSettingType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LocalVRFSettingType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LocalVRFSettingType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LocalVRFSettingType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LocalVRFSettingTypeValidator().Validate(ctx, m, opts...)
}

func (m *LocalVRFSettingType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetSliChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSliChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSloChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSloChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *LocalVRFSettingType) GetSliChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSliChoice() == nil {
		return nil, nil
	}
	switch m.GetSliChoice().(type) {
	case *LocalVRFSettingType_DefaultSliConfig:

		return nil, nil

	case *LocalVRFSettingType_SliConfig:

		drInfos, err := m.GetSliConfig().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSliConfig().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "sli_config." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *LocalVRFSettingType) GetSloChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSloChoice() == nil {
		return nil, nil
	}
	switch m.GetSloChoice().(type) {
	case *LocalVRFSettingType_DefaultConfig:

		return nil, nil

	case *LocalVRFSettingType_SloConfig:

		drInfos, err := m.GetSloConfig().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSloConfig().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "slo_config." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateLocalVRFSettingType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLocalVRFSettingType) SloChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for slo_choice")
	}
	return validatorFn, nil
}

func (v *ValidateLocalVRFSettingType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LocalVRFSettingType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LocalVRFSettingType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetSliChoice().(type) {
	case *LocalVRFSettingType_DefaultSliConfig:
		if fv, exists := v.FldValidators["sli_choice.default_sli_config"]; exists {
			val := m.GetSliChoice().(*LocalVRFSettingType_DefaultSliConfig).DefaultSliConfig
			vOpts := append(opts,
				db.WithValidateField("sli_choice"),
				db.WithValidateField("default_sli_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LocalVRFSettingType_SliConfig:
		if fv, exists := v.FldValidators["sli_choice.sli_config"]; exists {
			val := m.GetSliChoice().(*LocalVRFSettingType_SliConfig).SliConfig
			vOpts := append(opts,
				db.WithValidateField("sli_choice"),
				db.WithValidateField("sli_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["slo_choice"]; exists {
		val := m.GetSloChoice()
		vOpts := append(opts,
			db.WithValidateField("slo_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSloChoice().(type) {
	case *LocalVRFSettingType_DefaultConfig:
		if fv, exists := v.FldValidators["slo_choice.default_config"]; exists {
			val := m.GetSloChoice().(*LocalVRFSettingType_DefaultConfig).DefaultConfig
			vOpts := append(opts,
				db.WithValidateField("slo_choice"),
				db.WithValidateField("default_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LocalVRFSettingType_SloConfig:
		if fv, exists := v.FldValidators["slo_choice.slo_config"]; exists {
			val := m.GetSloChoice().(*LocalVRFSettingType_SloConfig).SloConfig
			vOpts := append(opts,
				db.WithValidateField("slo_choice"),
				db.WithValidateField("slo_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLocalVRFSettingTypeValidator = func() *ValidateLocalVRFSettingType {
	v := &ValidateLocalVRFSettingType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSloChoice := v.SloChoiceValidationRuleHandler
	rulesSloChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSloChoice(rulesSloChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LocalVRFSettingType.slo_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["slo_choice"] = vFn

	v.FldValidators["sli_choice.sli_config"] = VirtualNetworkConfigurationValidator().Validate

	v.FldValidators["slo_choice.slo_config"] = VirtualNetworkConfigurationValidator().Validate

	return v
}()

func LocalVRFSettingTypeValidator() db.Validator {
	return DefaultLocalVRFSettingTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Node) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Node) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Node) DeepCopy() *Node {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Node{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Node) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Node) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeValidator().Validate(ctx, m, opts...)
}

func (m *Node) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetInterfaceListDRefInfo()

}

// GetDRefInfo for the field's type
func (m *Node) GetInterfaceListDRefInfo() ([]db.DRefInfo, error) {
	if m.GetInterfaceList() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetInterfaceList() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetInterfaceList() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("interface_list[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateNode struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNode) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateNode) HostnameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for hostname")
	}

	return validatorFn, nil
}

func (v *ValidateNode) PublicIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for public_ip")
	}

	return validatorFn, nil
}

func (v *ValidateNode) InterfaceListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for interface_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*Interface, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := InterfaceValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for interface_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*Interface)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*Interface, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated interface_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateNode) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Node)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Node got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["hostname"]; exists {

		vOpts := append(opts, db.WithValidateField("hostname"))
		if err := fv(ctx, m.GetHostname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_list"]; exists {
		vOpts := append(opts, db.WithValidateField("interface_list"))
		if err := fv(ctx, m.GetInterfaceList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("public_ip"))
		if err := fv(ctx, m.GetPublicIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeValidator = func() *ValidateNode {
	v := &ValidateNode{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.string.in": "[\"Control\",\"Worker\"]",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Node.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhHostname := v.HostnameValidationRuleHandler
	rulesHostname := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhHostname(rulesHostname)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Node.hostname: %s", err)
		panic(errMsg)
	}
	v.FldValidators["hostname"] = vFn

	vrhPublicIp := v.PublicIpValidationRuleHandler
	rulesPublicIp := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhPublicIp(rulesPublicIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Node.public_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ip"] = vFn

	vrhInterfaceList := v.InterfaceListValidationRuleHandler
	rulesInterfaceList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhInterfaceList(rulesInterfaceList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Node.interface_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_list"] = vFn

	return v
}()

func NodeValidator() db.Validator {
	return DefaultNodeValidator
}

// augmented methods on protoc/std generated struct

func (m *NodeList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NodeList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NodeList) DeepCopy() *NodeList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NodeList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NodeList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NodeList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeListValidator().Validate(ctx, m, opts...)
}

func (m *NodeList) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNodeListDRefInfo()

}

// GetDRefInfo for the field's type
func (m *NodeList) GetNodeListDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNodeList() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetNodeList() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNodeList() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("node_list[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateNodeList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNodeList) NodeListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for node_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*Node, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := NodeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for node_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*Node)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*Node, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated node_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items node_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateNodeList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NodeList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NodeList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["node_list"]; exists {
		vOpts := append(opts, db.WithValidateField("node_list"))
		if err := fv(ctx, m.GetNodeList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeListValidator = func() *ValidateNodeList {
	v := &ValidateNodeList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeList := v.NodeListValidationRuleHandler
	rulesNodeList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhNodeList(rulesNodeList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NodeList.node_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_list"] = vFn

	return v
}()

func NodeListValidator() db.Validator {
	return DefaultNodeListValidator
}

// augmented methods on protoc/std generated struct

func (m *NutanixProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NutanixProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NutanixProviderType) DeepCopy() *NutanixProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NutanixProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NutanixProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NutanixProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NutanixProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *NutanixProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *NutanixProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *NutanixProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateNutanixProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNutanixProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NutanixProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NutanixProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *NutanixProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*NutanixProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNutanixProviderTypeValidator = func() *ValidateNutanixProviderType {
	v := &ValidateNutanixProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate

	return v
}()

func NutanixProviderTypeValidator() db.Validator {
	return DefaultNutanixProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OCIProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OCIProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OCIProviderType) DeepCopy() *OCIProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OCIProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OCIProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OCIProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OCIProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *OCIProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *OCIProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *OCIProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateOCIProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOCIProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OCIProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OCIProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *OCIProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*OCIProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOCIProviderTypeValidator = func() *ValidateOCIProviderType {
	v := &ValidateOCIProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate

	return v
}()

func OCIProviderTypeValidator() db.Validator {
	return DefaultOCIProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenstackProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenstackProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenstackProviderType) DeepCopy() *OpenstackProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenstackProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenstackProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenstackProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenstackProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *OpenstackProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *OpenstackProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *OpenstackProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateOpenstackProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenstackProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenstackProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenstackProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *OpenstackProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*OpenstackProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenstackProviderTypeValidator = func() *ValidateOpenstackProviderType {
	v := &ValidateOpenstackProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate

	return v
}()

func OpenstackProviderTypeValidator() db.Validator {
	return DefaultOpenstackProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RSeriesProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RSeriesProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RSeriesProviderType) DeepCopy() *RSeriesProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RSeriesProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RSeriesProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RSeriesProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RSeriesProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *RSeriesProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *RSeriesProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *RSeriesProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateRSeriesProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRSeriesProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RSeriesProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RSeriesProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *RSeriesProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*RSeriesProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRSeriesProviderTypeValidator = func() *ValidateRSeriesProviderType {
	v := &ValidateRSeriesProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate

	return v
}()

func RSeriesProviderTypeValidator() db.Validator {
	return DefaultRSeriesProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetAdminUserCredentials().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.admin_user_credentials")
	}

	if err := m.GetCustomProxy().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.custom_proxy")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetForwardProxyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetForwardProxyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLocalVrfDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLocalVrfDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLogsReceiverChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkPolicyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkPolicyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetProviderChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetProviderChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetS2SConnectivitySliChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetS2SConnectivitySliChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetS2SConnectivitySloChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetS2SConnectivitySloChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetForwardProxyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetForwardProxyChoice() == nil {
		return nil, nil
	}
	switch m.GetForwardProxyChoice().(type) {
	case *ReplaceSpecType_NoForwardProxy:

		return nil, nil

	case *ReplaceSpecType_ActiveForwardProxyPolicies:

		drInfos, err := m.GetActiveForwardProxyPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveForwardProxyPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_forward_proxy_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetLocalVrfDRefInfo() ([]db.DRefInfo, error) {
	if m.GetLocalVrf() == nil {
		return nil, nil
	}

	drInfos, err := m.GetLocalVrf().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetLocalVrf().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "local_vrf." + dri.DRField
	}
	return drInfos, err

}

func (m *ReplaceSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetLogsReceiverChoice().(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:

		return nil, nil

	case *ReplaceSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		dri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:

	case *ReplaceSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetNetworkPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNetworkPolicyChoice() == nil {
		return nil, nil
	}
	switch m.GetNetworkPolicyChoice().(type) {
	case *ReplaceSpecType_NoNetworkPolicy:

		return nil, nil

	case *ReplaceSpecType_ActiveEnhancedFirewallPolicies:

		drInfos, err := m.GetActiveEnhancedFirewallPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveEnhancedFirewallPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_enhanced_firewall_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetProviderChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetProviderChoice() == nil {
		return nil, nil
	}
	switch m.GetProviderChoice().(type) {
	case *ReplaceSpecType_Vmware:

		drInfos, err := m.GetVmware().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVmware().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vmware." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Kvm:

		drInfos, err := m.GetKvm().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetKvm().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "kvm." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Aws:

		drInfos, err := m.GetAws().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAws().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "aws." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Azure:

		drInfos, err := m.GetAzure().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetAzure().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "azure." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Gcp:

		drInfos, err := m.GetGcp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetGcp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "gcp." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Rseries:

		drInfos, err := m.GetRseries().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRseries().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "rseries." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Baremetal:

		drInfos, err := m.GetBaremetal().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetBaremetal().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "baremetal." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Oci:

		drInfos, err := m.GetOci().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOci().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "oci." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Openstack:

		drInfos, err := m.GetOpenstack().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOpenstack().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "openstack." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_Nutanix:

		drInfos, err := m.GetNutanix().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNutanix().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "nutanix." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *ReplaceSpecType) GetS2SConnectivitySliChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetS2SConnectivitySliChoice().(type) {
	case *ReplaceSpecType_NoS2SConnectivitySli:

		return nil, nil

	case *ReplaceSpecType_DcClusterGroupSli:

		vref := m.GetDcClusterGroupSli()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_sli",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetS2SConnectivitySliChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetS2SConnectivitySliChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetS2SConnectivitySliChoice().(type) {
	case *ReplaceSpecType_NoS2SConnectivitySli:

	case *ReplaceSpecType_DcClusterGroupSli:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupSli()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetS2SConnectivitySloChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetS2SConnectivitySloChoice() == nil {
		return nil, nil
	}
	switch m.GetS2SConnectivitySloChoice().(type) {
	case *ReplaceSpecType_NoS2SConnectivitySlo:

		return nil, nil

	case *ReplaceSpecType_SiteMeshGroupOnSlo:

		drInfos, err := m.GetSiteMeshGroupOnSlo().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetSiteMeshGroupOnSlo().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "site_mesh_group_on_slo." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_DcClusterGroupSlo:

		vref := m.GetDcClusterGroupSlo()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_slo",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) BlockedServicesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocked_services_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ProviderChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for provider_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["admin_user_credentials"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_user_credentials"))
		if err := fv(ctx, m.GetAdminUserCredentials(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocked_services_choice"]; exists {
		val := m.GetBlockedServicesChoice()
		vOpts := append(opts,
			db.WithValidateField("blocked_services_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockedServicesChoice().(type) {
	case *ReplaceSpecType_BlockAllServices:
		if fv, exists := v.FldValidators["blocked_services_choice.block_all_services"]; exists {
			val := m.GetBlockedServicesChoice().(*ReplaceSpecType_BlockAllServices).BlockAllServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("block_all_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_BlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*ReplaceSpecType_BlockedServices).BlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_ntp_config"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_ntp_config"))
		if err := fv(ctx, m.GetDnsNtpConfig(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetEnterpriseProxyChoice().(type) {
	case *ReplaceSpecType_F5Proxy:
		if fv, exists := v.FldValidators["enterprise_proxy_choice.f5_proxy"]; exists {
			val := m.GetEnterpriseProxyChoice().(*ReplaceSpecType_F5Proxy).F5Proxy
			vOpts := append(opts,
				db.WithValidateField("enterprise_proxy_choice"),
				db.WithValidateField("f5_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_CustomProxy:
		if fv, exists := v.FldValidators["enterprise_proxy_choice.custom_proxy"]; exists {
			val := m.GetEnterpriseProxyChoice().(*ReplaceSpecType_CustomProxy).CustomProxy
			vOpts := append(opts,
				db.WithValidateField("enterprise_proxy_choice"),
				db.WithValidateField("custom_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetForwardProxyChoice().(type) {
	case *ReplaceSpecType_NoForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.no_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*ReplaceSpecType_NoForwardProxy).NoForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("no_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ActiveForwardProxyPolicies:
		if fv, exists := v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"]; exists {
			val := m.GetForwardProxyChoice().(*ReplaceSpecType_ActiveForwardProxyPolicies).ActiveForwardProxyPolicies
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("active_forward_proxy_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["load_balancing"]; exists {

		vOpts := append(opts, db.WithValidateField("load_balancing"))
		if err := fv(ctx, m.GetLoadBalancing(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_vrf"]; exists {

		vOpts := append(opts, db.WithValidateField("local_vrf"))
		if err := fv(ctx, m.GetLocalVrf(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetNetworkPolicyChoice().(type) {
	case *ReplaceSpecType_NoNetworkPolicy:
		if fv, exists := v.FldValidators["network_policy_choice.no_network_policy"]; exists {
			val := m.GetNetworkPolicyChoice().(*ReplaceSpecType_NoNetworkPolicy).NoNetworkPolicy
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("no_network_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_ActiveEnhancedFirewallPolicies:
		if fv, exists := v.FldValidators["network_policy_choice.active_enhanced_firewall_policies"]; exists {
			val := m.GetNetworkPolicyChoice().(*ReplaceSpecType_ActiveEnhancedFirewallPolicies).ActiveEnhancedFirewallPolicies
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("active_enhanced_firewall_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetNodeHaChoice().(type) {
	case *ReplaceSpecType_DisableHa:
		if fv, exists := v.FldValidators["node_ha_choice.disable_ha"]; exists {
			val := m.GetNodeHaChoice().(*ReplaceSpecType_DisableHa).DisableHa
			vOpts := append(opts,
				db.WithValidateField("node_ha_choice"),
				db.WithValidateField("disable_ha"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_EnableHa:
		if fv, exists := v.FldValidators["node_ha_choice.enable_ha"]; exists {
			val := m.GetNodeHaChoice().(*ReplaceSpecType_EnableHa).EnableHa
			vOpts := append(opts,
				db.WithValidateField("node_ha_choice"),
				db.WithValidateField("enable_ha"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["offline_survivability_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("offline_survivability_mode"))
		if err := fv(ctx, m.GetOfflineSurvivabilityMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["performance_enhancement_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("performance_enhancement_mode"))
		if err := fv(ctx, m.GetPerformanceEnhancementMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["proactive_monitoring"]; exists {

		vOpts := append(opts, db.WithValidateField("proactive_monitoring"))
		if err := fv(ctx, m.GetProactiveMonitoring(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provider_choice"]; exists {
		val := m.GetProviderChoice()
		vOpts := append(opts,
			db.WithValidateField("provider_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetProviderChoice().(type) {
	case *ReplaceSpecType_Vmware:
		if fv, exists := v.FldValidators["provider_choice.vmware"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Vmware).Vmware
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("vmware"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Kvm:
		if fv, exists := v.FldValidators["provider_choice.kvm"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Kvm).Kvm
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("kvm"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Aws:
		if fv, exists := v.FldValidators["provider_choice.aws"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Aws).Aws
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("aws"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Azure:
		if fv, exists := v.FldValidators["provider_choice.azure"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Azure).Azure
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("azure"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Gcp:
		if fv, exists := v.FldValidators["provider_choice.gcp"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Gcp).Gcp
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("gcp"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Rseries:
		if fv, exists := v.FldValidators["provider_choice.rseries"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Rseries).Rseries
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("rseries"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Baremetal:
		if fv, exists := v.FldValidators["provider_choice.baremetal"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Baremetal).Baremetal
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("baremetal"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Oci:
		if fv, exists := v.FldValidators["provider_choice.oci"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Oci).Oci
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("oci"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Openstack:
		if fv, exists := v.FldValidators["provider_choice.openstack"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Openstack).Openstack
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("openstack"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Nutanix:
		if fv, exists := v.FldValidators["provider_choice.nutanix"]; exists {
			val := m.GetProviderChoice().(*ReplaceSpecType_Nutanix).Nutanix
			vOpts := append(opts,
				db.WithValidateField("provider_choice"),
				db.WithValidateField("nutanix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["re_select"]; exists {

		vOpts := append(opts, db.WithValidateField("re_select"))
		if err := fv(ctx, m.GetReSelect(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetS2SConnectivitySliChoice().(type) {
	case *ReplaceSpecType_NoS2SConnectivitySli:
		if fv, exists := v.FldValidators["s2s_connectivity_sli_choice.no_s2s_connectivity_sli"]; exists {
			val := m.GetS2SConnectivitySliChoice().(*ReplaceSpecType_NoS2SConnectivitySli).NoS2SConnectivitySli
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_sli_choice"),
				db.WithValidateField("no_s2s_connectivity_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DcClusterGroupSli:
		if fv, exists := v.FldValidators["s2s_connectivity_sli_choice.dc_cluster_group_sli"]; exists {
			val := m.GetS2SConnectivitySliChoice().(*ReplaceSpecType_DcClusterGroupSli).DcClusterGroupSli
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_sli_choice"),
				db.WithValidateField("dc_cluster_group_sli"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetS2SConnectivitySloChoice().(type) {
	case *ReplaceSpecType_NoS2SConnectivitySlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.no_s2s_connectivity_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*ReplaceSpecType_NoS2SConnectivitySlo).NoS2SConnectivitySlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("no_s2s_connectivity_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_SiteMeshGroupOnSlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.site_mesh_group_on_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*ReplaceSpecType_SiteMeshGroupOnSlo).SiteMeshGroupOnSlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("site_mesh_group_on_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DcClusterGroupSlo:
		if fv, exists := v.FldValidators["s2s_connectivity_slo_choice.dc_cluster_group_slo"]; exists {
			val := m.GetS2SConnectivitySloChoice().(*ReplaceSpecType_DcClusterGroupSlo).DcClusterGroupSlo
			vOpts := append(opts,
				db.WithValidateField("s2s_connectivity_slo_choice"),
				db.WithValidateField("dc_cluster_group_slo"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["software_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("software_settings"))
		if err := fv(ctx, m.GetSoftwareSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["upgrade_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("upgrade_settings"))
		if err := fv(ctx, m.GetUpgradeSettings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBlockedServicesChoice := v.BlockedServicesChoiceValidationRuleHandler
	rulesBlockedServicesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockedServicesChoice(rulesBlockedServicesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.blocked_services_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocked_services_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhProviderChoice := v.ProviderChoiceValidationRuleHandler
	rulesProviderChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhProviderChoice(rulesProviderChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.provider_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["provider_choice"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["blocked_services_choice.blocked_services"] = ves_io_schema_fleet.BlockedServicesListTypeValidator().Validate

	v.FldValidators["enterprise_proxy_choice.custom_proxy"] = CustomProxyValidator().Validate

	v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"] = ves_io_schema_network_firewall.ActiveForwardProxyPoliciesTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["network_policy_choice.active_enhanced_firewall_policies"] = ves_io_schema_network_firewall.ActiveEnhancedFirewallPoliciesTypeValidator().Validate

	v.FldValidators["provider_choice.vmware"] = VMwareProviderTypeValidator().Validate
	v.FldValidators["provider_choice.kvm"] = KVMProviderTypeValidator().Validate
	v.FldValidators["provider_choice.aws"] = AWSProviderTypeValidator().Validate
	v.FldValidators["provider_choice.azure"] = AzureProviderTypeValidator().Validate
	v.FldValidators["provider_choice.gcp"] = GCPProviderTypeValidator().Validate
	v.FldValidators["provider_choice.rseries"] = RSeriesProviderTypeValidator().Validate
	v.FldValidators["provider_choice.baremetal"] = BaremetalProviderTypeValidator().Validate
	v.FldValidators["provider_choice.oci"] = OCIProviderTypeValidator().Validate
	v.FldValidators["provider_choice.openstack"] = OpenstackProviderTypeValidator().Validate
	v.FldValidators["provider_choice.nutanix"] = NutanixProviderTypeValidator().Validate

	v.FldValidators["s2s_connectivity_sli_choice.dc_cluster_group_sli"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["s2s_connectivity_slo_choice.site_mesh_group_on_slo"] = SiteMeshGroupTypeValidator().Validate
	v.FldValidators["s2s_connectivity_slo_choice.dc_cluster_group_slo"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["software_settings"] = SoftwareSettingsTypeValidator().Validate

	v.FldValidators["upgrade_settings"] = UpgradeSettingsTypeValidator().Validate

	v.FldValidators["performance_enhancement_mode"] = ves_io_schema_views.PerformanceEnhancementModeTypeValidator().Validate

	v.FldValidators["offline_survivability_mode"] = ves_io_schema_views.OfflineSurvivabilityModeTypeValidator().Validate

	v.FldValidators["local_vrf"] = LocalVRFSettingTypeValidator().Validate

	v.FldValidators["re_select"] = ves_io_schema_views.RegionalEdgeSelectionValidator().Validate

	v.FldValidators["admin_user_credentials"] = ves_io_schema_views.AdminUserCredentialsTypeValidator().Validate

	v.FldValidators["dns_ntp_config"] = DNSNTPServerConfigValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteMeshGroupType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteMeshGroupType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteMeshGroupType) DeepCopy() *SiteMeshGroupType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteMeshGroupType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteMeshGroupType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteMeshGroupType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteMeshGroupTypeValidator().Validate(ctx, m, opts...)
}

func (m *SiteMeshGroupType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteMeshGroupChoiceDRefInfo()

}

func (m *SiteMeshGroupType) GetSiteMeshGroupChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetSiteMeshGroupChoice().(type) {
	case *SiteMeshGroupType_NoSiteMeshGroup:

		return nil, nil

	case *SiteMeshGroupType_SiteMeshGroup:

		vref := m.GetSiteMeshGroup()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("site_mesh_group.Object")
		dri := db.DRefInfo{
			RefdType:   "site_mesh_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "site_mesh_group",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetSiteMeshGroupChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SiteMeshGroupType) GetSiteMeshGroupChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetSiteMeshGroupChoice().(type) {
	case *SiteMeshGroupType_NoSiteMeshGroup:

	case *SiteMeshGroupType_SiteMeshGroup:
		refdType, err := d.TypeForEntryKind("", "", "site_mesh_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: site_mesh_group")
		}

		vref := m.GetSiteMeshGroup()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "site_mesh_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateSiteMeshGroupType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteMeshGroupType) SiteMeshGroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_mesh_group_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSiteMeshGroupType) SiteMeshGroupIpChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_mesh_group_ip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSiteMeshGroupType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteMeshGroupType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteMeshGroupType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site_mesh_group_choice"]; exists {
		val := m.GetSiteMeshGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("site_mesh_group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSiteMeshGroupChoice().(type) {
	case *SiteMeshGroupType_NoSiteMeshGroup:
		if fv, exists := v.FldValidators["site_mesh_group_choice.no_site_mesh_group"]; exists {
			val := m.GetSiteMeshGroupChoice().(*SiteMeshGroupType_NoSiteMeshGroup).NoSiteMeshGroup
			vOpts := append(opts,
				db.WithValidateField("site_mesh_group_choice"),
				db.WithValidateField("no_site_mesh_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteMeshGroupType_SiteMeshGroup:
		if fv, exists := v.FldValidators["site_mesh_group_choice.site_mesh_group"]; exists {
			val := m.GetSiteMeshGroupChoice().(*SiteMeshGroupType_SiteMeshGroup).SiteMeshGroup
			vOpts := append(opts,
				db.WithValidateField("site_mesh_group_choice"),
				db.WithValidateField("site_mesh_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_mesh_group_ip_choice"]; exists {
		val := m.GetSiteMeshGroupIpChoice()
		vOpts := append(opts,
			db.WithValidateField("site_mesh_group_ip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSiteMeshGroupIpChoice().(type) {
	case *SiteMeshGroupType_SmConnectionPublicIp:
		if fv, exists := v.FldValidators["site_mesh_group_ip_choice.sm_connection_public_ip"]; exists {
			val := m.GetSiteMeshGroupIpChoice().(*SiteMeshGroupType_SmConnectionPublicIp).SmConnectionPublicIp
			vOpts := append(opts,
				db.WithValidateField("site_mesh_group_ip_choice"),
				db.WithValidateField("sm_connection_public_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SiteMeshGroupType_SmConnectionPvtIp:
		if fv, exists := v.FldValidators["site_mesh_group_ip_choice.sm_connection_pvt_ip"]; exists {
			val := m.GetSiteMeshGroupIpChoice().(*SiteMeshGroupType_SmConnectionPvtIp).SmConnectionPvtIp
			vOpts := append(opts,
				db.WithValidateField("site_mesh_group_ip_choice"),
				db.WithValidateField("sm_connection_pvt_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteMeshGroupTypeValidator = func() *ValidateSiteMeshGroupType {
	v := &ValidateSiteMeshGroupType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteMeshGroupChoice := v.SiteMeshGroupChoiceValidationRuleHandler
	rulesSiteMeshGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSiteMeshGroupChoice(rulesSiteMeshGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteMeshGroupType.site_mesh_group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_mesh_group_choice"] = vFn

	vrhSiteMeshGroupIpChoice := v.SiteMeshGroupIpChoiceValidationRuleHandler
	rulesSiteMeshGroupIpChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSiteMeshGroupIpChoice(rulesSiteMeshGroupIpChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SiteMeshGroupType.site_mesh_group_ip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_mesh_group_ip_choice"] = vFn

	v.FldValidators["site_mesh_group_choice.site_mesh_group"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func SiteMeshGroupTypeValidator() db.Validator {
	return DefaultSiteMeshGroupTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SoftwareSettingsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SoftwareSettingsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SoftwareSettingsType) DeepCopy() *SoftwareSettingsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SoftwareSettingsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SoftwareSettingsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SoftwareSettingsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SoftwareSettingsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSoftwareSettingsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSoftwareSettingsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SoftwareSettingsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SoftwareSettingsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["os"]; exists {

		vOpts := append(opts, db.WithValidateField("os"))
		if err := fv(ctx, m.GetOs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sw"]; exists {

		vOpts := append(opts, db.WithValidateField("sw"))
		if err := fv(ctx, m.GetSw(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSoftwareSettingsTypeValidator = func() *ValidateSoftwareSettingsType {
	v := &ValidateSoftwareSettingsType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["sw"] = ves_io_schema_views.VolterraSoftwareTypeValidator().Validate

	v.FldValidators["os"] = ves_io_schema_views.OperatingSystemTypeValidator().Validate

	return v
}()

func SoftwareSettingsTypeValidator() db.Validator {
	return DefaultSoftwareSettingsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticRoutesListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticRoutesListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticRoutesListType) DeepCopy() *StaticRoutesListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticRoutesListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticRoutesListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticRoutesListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticRoutesListTypeValidator().Validate(ctx, m, opts...)
}

func (m *StaticRoutesListType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetStaticRoutesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *StaticRoutesListType) GetStaticRoutesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetStaticRoutes() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetStaticRoutes() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStaticRoutes() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("static_routes[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateStaticRoutesListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticRoutesListType) StaticRoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for static_routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_virtual_network.StaticRouteViewType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_virtual_network.StaticRouteViewTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_virtual_network.StaticRouteViewType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_virtual_network.StaticRouteViewType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStaticRoutesListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticRoutesListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticRoutesListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["static_routes"]; exists {
		vOpts := append(opts, db.WithValidateField("static_routes"))
		if err := fv(ctx, m.GetStaticRoutes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticRoutesListTypeValidator = func() *ValidateStaticRoutesListType {
	v := &ValidateStaticRoutesListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStaticRoutes := v.StaticRoutesValidationRuleHandler
	rulesStaticRoutes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStaticRoutes(rulesStaticRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticRoutesListType.static_routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_routes"] = vFn

	return v
}()

func StaticRoutesListTypeValidator() db.Validator {
	return DefaultStaticRoutesListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *UpgradeSettingsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpgradeSettingsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpgradeSettingsType) DeepCopy() *UpgradeSettingsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpgradeSettingsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpgradeSettingsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpgradeSettingsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpgradeSettingsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateUpgradeSettingsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpgradeSettingsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpgradeSettingsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpgradeSettingsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["kubernetes_upgrade_drain"]; exists {

		vOpts := append(opts, db.WithValidateField("kubernetes_upgrade_drain"))
		if err := fv(ctx, m.GetKubernetesUpgradeDrain(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpgradeSettingsTypeValidator = func() *ValidateUpgradeSettingsType {
	v := &ValidateUpgradeSettingsType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["kubernetes_upgrade_drain"] = ves_io_schema_views.KubernetesUpgradeDrainValidator().Validate

	return v
}()

func UpgradeSettingsTypeValidator() db.Validator {
	return DefaultUpgradeSettingsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VMwareProviderType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VMwareProviderType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VMwareProviderType) DeepCopy() *VMwareProviderType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VMwareProviderType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VMwareProviderType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VMwareProviderType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VMwareProviderTypeValidator().Validate(ctx, m, opts...)
}

func (m *VMwareProviderType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetOrchestrationChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *VMwareProviderType) GetOrchestrationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOrchestrationChoice() == nil {
		return nil, nil
	}
	switch m.GetOrchestrationChoice().(type) {
	case *VMwareProviderType_NotManaged:

		drInfos, err := m.GetNotManaged().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetNotManaged().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "not_managed." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateVMwareProviderType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVMwareProviderType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VMwareProviderType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VMwareProviderType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetOrchestrationChoice().(type) {
	case *VMwareProviderType_NotManaged:
		if fv, exists := v.FldValidators["orchestration_choice.not_managed"]; exists {
			val := m.GetOrchestrationChoice().(*VMwareProviderType_NotManaged).NotManaged
			vOpts := append(opts,
				db.WithValidateField("orchestration_choice"),
				db.WithValidateField("not_managed"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVMwareProviderTypeValidator = func() *ValidateVMwareProviderType {
	v := &ValidateVMwareProviderType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["orchestration_choice.not_managed"] = NodeListValidator().Validate

	return v
}()

func VMwareProviderTypeValidator() db.Validator {
	return DefaultVMwareProviderTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualNetworkConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualNetworkConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualNetworkConfiguration) DeepCopy() *VirtualNetworkConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualNetworkConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualNetworkConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualNetworkConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualNetworkConfigurationValidator().Validate(ctx, m, opts...)
}

func (m *VirtualNetworkConfiguration) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetStaticRouteChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetStaticRouteChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStaticV6RouteChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetStaticV6RouteChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *VirtualNetworkConfiguration) GetStaticRouteChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetStaticRouteChoice() == nil {
		return nil, nil
	}
	switch m.GetStaticRouteChoice().(type) {
	case *VirtualNetworkConfiguration_NoStaticRoutes:

		return nil, nil

	case *VirtualNetworkConfiguration_StaticRoutes:

		drInfos, err := m.GetStaticRoutes().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStaticRoutes().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "static_routes." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *VirtualNetworkConfiguration) GetStaticV6RouteChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetStaticV6RouteChoice() == nil {
		return nil, nil
	}
	switch m.GetStaticV6RouteChoice().(type) {
	case *VirtualNetworkConfiguration_NoV6StaticRoutes:

		return nil, nil

	case *VirtualNetworkConfiguration_StaticV6Routes:

		drInfos, err := m.GetStaticV6Routes().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStaticV6Routes().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "static_v6_routes." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateVirtualNetworkConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualNetworkConfiguration) StaticRouteChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for static_route_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVirtualNetworkConfiguration) StaticV6RouteChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for static_v6_route_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVirtualNetworkConfiguration) LabelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for labels")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for labels")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for labels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map labels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items labels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVirtualNetworkConfiguration) VipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vip")
	}

	return validatorFn, nil
}

func (v *ValidateVirtualNetworkConfiguration) NameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateVirtualNetworkConfiguration) VipV6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vip_v6")
	}

	return validatorFn, nil
}

func (v *ValidateVirtualNetworkConfiguration) NameserverV6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nameserver_v6")
	}

	return validatorFn, nil
}

func (v *ValidateVirtualNetworkConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualNetworkConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualNetworkConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["labels"]; exists {
		vOpts := append(opts, db.WithValidateField("labels"))
		if err := fv(ctx, m.GetLabels(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("nameserver"))
		if err := fv(ctx, m.GetNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nameserver_v6"]; exists {

		vOpts := append(opts, db.WithValidateField("nameserver_v6"))
		if err := fv(ctx, m.GetNameserverV6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_route_choice"]; exists {
		val := m.GetStaticRouteChoice()
		vOpts := append(opts,
			db.WithValidateField("static_route_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStaticRouteChoice().(type) {
	case *VirtualNetworkConfiguration_NoStaticRoutes:
		if fv, exists := v.FldValidators["static_route_choice.no_static_routes"]; exists {
			val := m.GetStaticRouteChoice().(*VirtualNetworkConfiguration_NoStaticRoutes).NoStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("static_route_choice"),
				db.WithValidateField("no_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VirtualNetworkConfiguration_StaticRoutes:
		if fv, exists := v.FldValidators["static_route_choice.static_routes"]; exists {
			val := m.GetStaticRouteChoice().(*VirtualNetworkConfiguration_StaticRoutes).StaticRoutes
			vOpts := append(opts,
				db.WithValidateField("static_route_choice"),
				db.WithValidateField("static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["static_v6_route_choice"]; exists {
		val := m.GetStaticV6RouteChoice()
		vOpts := append(opts,
			db.WithValidateField("static_v6_route_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetStaticV6RouteChoice().(type) {
	case *VirtualNetworkConfiguration_NoV6StaticRoutes:
		if fv, exists := v.FldValidators["static_v6_route_choice.no_v6_static_routes"]; exists {
			val := m.GetStaticV6RouteChoice().(*VirtualNetworkConfiguration_NoV6StaticRoutes).NoV6StaticRoutes
			vOpts := append(opts,
				db.WithValidateField("static_v6_route_choice"),
				db.WithValidateField("no_v6_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VirtualNetworkConfiguration_StaticV6Routes:
		if fv, exists := v.FldValidators["static_v6_route_choice.static_v6_routes"]; exists {
			val := m.GetStaticV6RouteChoice().(*VirtualNetworkConfiguration_StaticV6Routes).StaticV6Routes
			vOpts := append(opts,
				db.WithValidateField("static_v6_route_choice"),
				db.WithValidateField("static_v6_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vip"]; exists {

		vOpts := append(opts, db.WithValidateField("vip"))
		if err := fv(ctx, m.GetVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_v6"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_v6"))
		if err := fv(ctx, m.GetVipV6(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualNetworkConfigurationValidator = func() *ValidateVirtualNetworkConfiguration {
	v := &ValidateVirtualNetworkConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStaticRouteChoice := v.StaticRouteChoiceValidationRuleHandler
	rulesStaticRouteChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStaticRouteChoice(rulesStaticRouteChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualNetworkConfiguration.static_route_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_route_choice"] = vFn

	vrhStaticV6RouteChoice := v.StaticV6RouteChoiceValidationRuleHandler
	rulesStaticV6RouteChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhStaticV6RouteChoice(rulesStaticV6RouteChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualNetworkConfiguration.static_v6_route_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_v6_route_choice"] = vFn

	vrhLabels := v.LabelsValidationRuleHandler
	rulesLabels := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "64",
		"ves.io.schema.rules.map.keys.string.min_len":   "1",
		"ves.io.schema.rules.map.max_pairs":             "16",
		"ves.io.schema.rules.map.values.string.max_len": "64",
		"ves.io.schema.rules.map.values.string.min_len": "1",
	}
	vFn, err = vrhLabels(rulesLabels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualNetworkConfiguration.labels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["labels"] = vFn

	vrhVip := v.VipValidationRuleHandler
	rulesVip := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhVip(rulesVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualNetworkConfiguration.vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vip"] = vFn

	vrhNameserver := v.NameserverValidationRuleHandler
	rulesNameserver := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhNameserver(rulesNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualNetworkConfiguration.nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nameserver"] = vFn

	vrhVipV6 := v.VipV6ValidationRuleHandler
	rulesVipV6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhVipV6(rulesVipV6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualNetworkConfiguration.vip_v6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vip_v6"] = vFn

	vrhNameserverV6 := v.NameserverV6ValidationRuleHandler
	rulesNameserverV6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhNameserverV6(rulesNameserverV6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualNetworkConfiguration.nameserver_v6: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nameserver_v6"] = vFn

	v.FldValidators["static_route_choice.static_routes"] = StaticRoutesListTypeValidator().Validate

	v.FldValidators["static_v6_route_choice.static_v6_routes"] = ves_io_schema_virtual_network.StaticV6RoutesListTypeValidator().Validate

	return v
}()

func VirtualNetworkConfigurationValidator() db.Validator {
	return DefaultVirtualNetworkConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *VlanInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VlanInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VlanInterfaceType) DeepCopy() *VlanInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VlanInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VlanInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VlanInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VlanInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVlanInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVlanInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateVlanInterfaceType) VlanIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_id")
	}

	return validatorFn, nil
}

func (v *ValidateVlanInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VlanInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VlanInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_id"))
		if err := fv(ctx, m.GetVlanId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVlanInterfaceTypeValidator = func() *ValidateVlanInterfaceType {
	v := &ValidateVlanInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VlanInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhVlanId := v.VlanIdValidationRuleHandler
	rulesVlanId := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "4095",
	}
	vFn, err = vrhVlanId(rulesVlanId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VlanInterfaceType.vlan_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_id"] = vFn

	return v
}()

func VlanInterfaceTypeValidator() db.Validator {
	return DefaultVlanInterfaceTypeValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetBlockedServicesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BlockedServicesChoice.(type) {
	case nil:
		o.BlockedServicesChoice = nil

	case *CreateSpecType_BlockAllServices:
		o.BlockedServicesChoice = &GlobalSpecType_BlockAllServices{BlockAllServices: of.BlockAllServices}

	case *CreateSpecType_BlockedServices:
		o.BlockedServicesChoice = &GlobalSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetBlockedServicesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BlockedServicesChoice.(type) {
	case nil:
		r.BlockedServicesChoice = nil

	case *GlobalSpecType_BlockAllServices:
		r.BlockedServicesChoice = &CreateSpecType_BlockAllServices{BlockAllServices: of.BlockAllServices}

	case *GlobalSpecType_BlockedServices:
		r.BlockedServicesChoice = &CreateSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetEnterpriseProxyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.EnterpriseProxyChoice.(type) {
	case nil:
		o.EnterpriseProxyChoice = nil

	case *CreateSpecType_CustomProxy:
		o.EnterpriseProxyChoice = &GlobalSpecType_CustomProxy{CustomProxy: of.CustomProxy}

	case *CreateSpecType_F5Proxy:
		o.EnterpriseProxyChoice = &GlobalSpecType_F5Proxy{F5Proxy: of.F5Proxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetEnterpriseProxyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.EnterpriseProxyChoice.(type) {
	case nil:
		r.EnterpriseProxyChoice = nil

	case *GlobalSpecType_CustomProxy:
		r.EnterpriseProxyChoice = &CreateSpecType_CustomProxy{CustomProxy: of.CustomProxy}

	case *GlobalSpecType_F5Proxy:
		r.EnterpriseProxyChoice = &CreateSpecType_F5Proxy{F5Proxy: of.F5Proxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetForwardProxyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ForwardProxyChoice.(type) {
	case nil:
		o.ForwardProxyChoice = nil

	case *CreateSpecType_ActiveForwardProxyPolicies:
		o.ForwardProxyChoice = &GlobalSpecType_ActiveForwardProxyPolicies{ActiveForwardProxyPolicies: of.ActiveForwardProxyPolicies}

	case *CreateSpecType_NoForwardProxy:
		o.ForwardProxyChoice = &GlobalSpecType_NoForwardProxy{NoForwardProxy: of.NoForwardProxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetForwardProxyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ForwardProxyChoice.(type) {
	case nil:
		r.ForwardProxyChoice = nil

	case *GlobalSpecType_ActiveForwardProxyPolicies:
		r.ForwardProxyChoice = &CreateSpecType_ActiveForwardProxyPolicies{ActiveForwardProxyPolicies: of.ActiveForwardProxyPolicies}

	case *GlobalSpecType_NoForwardProxy:
		r.ForwardProxyChoice = &CreateSpecType_NoForwardProxy{NoForwardProxy: of.NoForwardProxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetLogsReceiverChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LogsReceiverChoice.(type) {
	case nil:
		o.LogsReceiverChoice = nil

	case *CreateSpecType_LogReceiver:
		o.LogsReceiverChoice = &GlobalSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *CreateSpecType_LogsStreamingDisabled:
		o.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetLogsReceiverChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LogsReceiverChoice.(type) {
	case nil:
		r.LogsReceiverChoice = nil

	case *GlobalSpecType_LogReceiver:
		r.LogsReceiverChoice = &CreateSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GlobalSpecType_LogsStreamingDisabled:
		r.LogsReceiverChoice = &CreateSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetNetworkPolicyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.NetworkPolicyChoice.(type) {
	case nil:
		o.NetworkPolicyChoice = nil

	case *CreateSpecType_ActiveEnhancedFirewallPolicies:
		o.NetworkPolicyChoice = &GlobalSpecType_ActiveEnhancedFirewallPolicies{ActiveEnhancedFirewallPolicies: of.ActiveEnhancedFirewallPolicies}

	case *CreateSpecType_NoNetworkPolicy:
		o.NetworkPolicyChoice = &GlobalSpecType_NoNetworkPolicy{NoNetworkPolicy: of.NoNetworkPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetNetworkPolicyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.NetworkPolicyChoice.(type) {
	case nil:
		r.NetworkPolicyChoice = nil

	case *GlobalSpecType_ActiveEnhancedFirewallPolicies:
		r.NetworkPolicyChoice = &CreateSpecType_ActiveEnhancedFirewallPolicies{ActiveEnhancedFirewallPolicies: of.ActiveEnhancedFirewallPolicies}

	case *GlobalSpecType_NoNetworkPolicy:
		r.NetworkPolicyChoice = &CreateSpecType_NoNetworkPolicy{NoNetworkPolicy: of.NoNetworkPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetNodeHaChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.NodeHaChoice.(type) {
	case nil:
		o.NodeHaChoice = nil

	case *CreateSpecType_DisableHa:
		o.NodeHaChoice = &GlobalSpecType_DisableHa{DisableHa: of.DisableHa}

	case *CreateSpecType_EnableHa:
		o.NodeHaChoice = &GlobalSpecType_EnableHa{EnableHa: of.EnableHa}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetNodeHaChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.NodeHaChoice.(type) {
	case nil:
		r.NodeHaChoice = nil

	case *GlobalSpecType_DisableHa:
		r.NodeHaChoice = &CreateSpecType_DisableHa{DisableHa: of.DisableHa}

	case *GlobalSpecType_EnableHa:
		r.NodeHaChoice = &CreateSpecType_EnableHa{EnableHa: of.EnableHa}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetProviderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ProviderChoice.(type) {
	case nil:
		o.ProviderChoice = nil

	case *CreateSpecType_Aws:
		o.ProviderChoice = &GlobalSpecType_Aws{Aws: of.Aws}

	case *CreateSpecType_Azure:
		o.ProviderChoice = &GlobalSpecType_Azure{Azure: of.Azure}

	case *CreateSpecType_Baremetal:
		o.ProviderChoice = &GlobalSpecType_Baremetal{Baremetal: of.Baremetal}

	case *CreateSpecType_Gcp:
		o.ProviderChoice = &GlobalSpecType_Gcp{Gcp: of.Gcp}

	case *CreateSpecType_Kvm:
		o.ProviderChoice = &GlobalSpecType_Kvm{Kvm: of.Kvm}

	case *CreateSpecType_Nutanix:
		o.ProviderChoice = &GlobalSpecType_Nutanix{Nutanix: of.Nutanix}

	case *CreateSpecType_Oci:
		o.ProviderChoice = &GlobalSpecType_Oci{Oci: of.Oci}

	case *CreateSpecType_Openstack:
		o.ProviderChoice = &GlobalSpecType_Openstack{Openstack: of.Openstack}

	case *CreateSpecType_Rseries:
		o.ProviderChoice = &GlobalSpecType_Rseries{Rseries: of.Rseries}

	case *CreateSpecType_Vmware:
		o.ProviderChoice = &GlobalSpecType_Vmware{Vmware: of.Vmware}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetProviderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ProviderChoice.(type) {
	case nil:
		r.ProviderChoice = nil

	case *GlobalSpecType_Aws:
		r.ProviderChoice = &CreateSpecType_Aws{Aws: of.Aws}

	case *GlobalSpecType_Azure:
		r.ProviderChoice = &CreateSpecType_Azure{Azure: of.Azure}

	case *GlobalSpecType_Baremetal:
		r.ProviderChoice = &CreateSpecType_Baremetal{Baremetal: of.Baremetal}

	case *GlobalSpecType_Gcp:
		r.ProviderChoice = &CreateSpecType_Gcp{Gcp: of.Gcp}

	case *GlobalSpecType_Kvm:
		r.ProviderChoice = &CreateSpecType_Kvm{Kvm: of.Kvm}

	case *GlobalSpecType_Nutanix:
		r.ProviderChoice = &CreateSpecType_Nutanix{Nutanix: of.Nutanix}

	case *GlobalSpecType_Oci:
		r.ProviderChoice = &CreateSpecType_Oci{Oci: of.Oci}

	case *GlobalSpecType_Openstack:
		r.ProviderChoice = &CreateSpecType_Openstack{Openstack: of.Openstack}

	case *GlobalSpecType_Rseries:
		r.ProviderChoice = &CreateSpecType_Rseries{Rseries: of.Rseries}

	case *GlobalSpecType_Vmware:
		r.ProviderChoice = &CreateSpecType_Vmware{Vmware: of.Vmware}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetS2SConnectivitySliChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.S2SConnectivitySliChoice.(type) {
	case nil:
		o.S2SConnectivitySliChoice = nil

	case *CreateSpecType_DcClusterGroupSli:
		o.S2SConnectivitySliChoice = &GlobalSpecType_DcClusterGroupSli{DcClusterGroupSli: of.DcClusterGroupSli}

	case *CreateSpecType_NoS2SConnectivitySli:
		o.S2SConnectivitySliChoice = &GlobalSpecType_NoS2SConnectivitySli{NoS2SConnectivitySli: of.NoS2SConnectivitySli}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetS2SConnectivitySliChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.S2SConnectivitySliChoice.(type) {
	case nil:
		r.S2SConnectivitySliChoice = nil

	case *GlobalSpecType_DcClusterGroupSli:
		r.S2SConnectivitySliChoice = &CreateSpecType_DcClusterGroupSli{DcClusterGroupSli: of.DcClusterGroupSli}

	case *GlobalSpecType_NoS2SConnectivitySli:
		r.S2SConnectivitySliChoice = &CreateSpecType_NoS2SConnectivitySli{NoS2SConnectivitySli: of.NoS2SConnectivitySli}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetS2SConnectivitySloChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.S2SConnectivitySloChoice.(type) {
	case nil:
		o.S2SConnectivitySloChoice = nil

	case *CreateSpecType_DcClusterGroupSlo:
		o.S2SConnectivitySloChoice = &GlobalSpecType_DcClusterGroupSlo{DcClusterGroupSlo: of.DcClusterGroupSlo}

	case *CreateSpecType_NoS2SConnectivitySlo:
		o.S2SConnectivitySloChoice = &GlobalSpecType_NoS2SConnectivitySlo{NoS2SConnectivitySlo: of.NoS2SConnectivitySlo}

	case *CreateSpecType_SiteMeshGroupOnSlo:
		o.S2SConnectivitySloChoice = &GlobalSpecType_SiteMeshGroupOnSlo{SiteMeshGroupOnSlo: of.SiteMeshGroupOnSlo}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetS2SConnectivitySloChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.S2SConnectivitySloChoice.(type) {
	case nil:
		r.S2SConnectivitySloChoice = nil

	case *GlobalSpecType_DcClusterGroupSlo:
		r.S2SConnectivitySloChoice = &CreateSpecType_DcClusterGroupSlo{DcClusterGroupSlo: of.DcClusterGroupSlo}

	case *GlobalSpecType_NoS2SConnectivitySlo:
		r.S2SConnectivitySloChoice = &CreateSpecType_NoS2SConnectivitySlo{NoS2SConnectivitySlo: of.NoS2SConnectivitySlo}

	case *GlobalSpecType_SiteMeshGroupOnSlo:
		r.S2SConnectivitySloChoice = &CreateSpecType_SiteMeshGroupOnSlo{SiteMeshGroupOnSlo: of.SiteMeshGroupOnSlo}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AdminUserCredentials = f.GetAdminUserCredentials()
	m.GetBlockedServicesChoiceFromGlobalSpecType(f)
	m.DnsNtpConfig = f.GetDnsNtpConfig()
	m.GetEnterpriseProxyChoiceFromGlobalSpecType(f)
	m.GetForwardProxyChoiceFromGlobalSpecType(f)
	m.LoadBalancing = f.GetLoadBalancing()
	m.LocalVrf = f.GetLocalVrf()
	m.GetLogsReceiverChoiceFromGlobalSpecType(f)
	m.GetNetworkPolicyChoiceFromGlobalSpecType(f)
	m.GetNodeHaChoiceFromGlobalSpecType(f)
	m.OfflineSurvivabilityMode = f.GetOfflineSurvivabilityMode()
	m.PerformanceEnhancementMode = f.GetPerformanceEnhancementMode()
	m.ProactiveMonitoring = f.GetProactiveMonitoring()
	m.GetProviderChoiceFromGlobalSpecType(f)
	m.ReSelect = f.GetReSelect()
	m.GetS2SConnectivitySliChoiceFromGlobalSpecType(f)
	m.GetS2SConnectivitySloChoiceFromGlobalSpecType(f)
	m.SoftwareSettings = f.GetSoftwareSettings()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.UpgradeSettings = f.GetUpgradeSettings()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AdminUserCredentials = m1.AdminUserCredentials
	m1.SetBlockedServicesChoiceToGlobalSpecType(f)
	f.DnsNtpConfig = m1.DnsNtpConfig
	m1.SetEnterpriseProxyChoiceToGlobalSpecType(f)
	m1.SetForwardProxyChoiceToGlobalSpecType(f)
	f.LoadBalancing = m1.LoadBalancing
	f.LocalVrf = m1.LocalVrf
	m1.SetLogsReceiverChoiceToGlobalSpecType(f)
	m1.SetNetworkPolicyChoiceToGlobalSpecType(f)
	m1.SetNodeHaChoiceToGlobalSpecType(f)
	f.OfflineSurvivabilityMode = m1.OfflineSurvivabilityMode
	f.PerformanceEnhancementMode = m1.PerformanceEnhancementMode
	f.ProactiveMonitoring = m1.ProactiveMonitoring
	m1.SetProviderChoiceToGlobalSpecType(f)
	f.ReSelect = m1.ReSelect
	m1.SetS2SConnectivitySliChoiceToGlobalSpecType(f)
	m1.SetS2SConnectivitySloChoiceToGlobalSpecType(f)
	f.SoftwareSettings = m1.SoftwareSettings
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.UpgradeSettings = m1.UpgradeSettings
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetBlockedServicesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BlockedServicesChoice.(type) {
	case nil:
		o.BlockedServicesChoice = nil

	case *GetSpecType_BlockAllServices:
		o.BlockedServicesChoice = &GlobalSpecType_BlockAllServices{BlockAllServices: of.BlockAllServices}

	case *GetSpecType_BlockedServices:
		o.BlockedServicesChoice = &GlobalSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetBlockedServicesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BlockedServicesChoice.(type) {
	case nil:
		r.BlockedServicesChoice = nil

	case *GlobalSpecType_BlockAllServices:
		r.BlockedServicesChoice = &GetSpecType_BlockAllServices{BlockAllServices: of.BlockAllServices}

	case *GlobalSpecType_BlockedServices:
		r.BlockedServicesChoice = &GetSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetEnterpriseProxyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.EnterpriseProxyChoice.(type) {
	case nil:
		o.EnterpriseProxyChoice = nil

	case *GetSpecType_CustomProxy:
		o.EnterpriseProxyChoice = &GlobalSpecType_CustomProxy{CustomProxy: of.CustomProxy}

	case *GetSpecType_F5Proxy:
		o.EnterpriseProxyChoice = &GlobalSpecType_F5Proxy{F5Proxy: of.F5Proxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetEnterpriseProxyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.EnterpriseProxyChoice.(type) {
	case nil:
		r.EnterpriseProxyChoice = nil

	case *GlobalSpecType_CustomProxy:
		r.EnterpriseProxyChoice = &GetSpecType_CustomProxy{CustomProxy: of.CustomProxy}

	case *GlobalSpecType_F5Proxy:
		r.EnterpriseProxyChoice = &GetSpecType_F5Proxy{F5Proxy: of.F5Proxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetForwardProxyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ForwardProxyChoice.(type) {
	case nil:
		o.ForwardProxyChoice = nil

	case *GetSpecType_ActiveForwardProxyPolicies:
		o.ForwardProxyChoice = &GlobalSpecType_ActiveForwardProxyPolicies{ActiveForwardProxyPolicies: of.ActiveForwardProxyPolicies}

	case *GetSpecType_NoForwardProxy:
		o.ForwardProxyChoice = &GlobalSpecType_NoForwardProxy{NoForwardProxy: of.NoForwardProxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetForwardProxyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ForwardProxyChoice.(type) {
	case nil:
		r.ForwardProxyChoice = nil

	case *GlobalSpecType_ActiveForwardProxyPolicies:
		r.ForwardProxyChoice = &GetSpecType_ActiveForwardProxyPolicies{ActiveForwardProxyPolicies: of.ActiveForwardProxyPolicies}

	case *GlobalSpecType_NoForwardProxy:
		r.ForwardProxyChoice = &GetSpecType_NoForwardProxy{NoForwardProxy: of.NoForwardProxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetLogsReceiverChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LogsReceiverChoice.(type) {
	case nil:
		o.LogsReceiverChoice = nil

	case *GetSpecType_LogReceiver:
		o.LogsReceiverChoice = &GlobalSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GetSpecType_LogsStreamingDisabled:
		o.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetLogsReceiverChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LogsReceiverChoice.(type) {
	case nil:
		r.LogsReceiverChoice = nil

	case *GlobalSpecType_LogReceiver:
		r.LogsReceiverChoice = &GetSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GlobalSpecType_LogsStreamingDisabled:
		r.LogsReceiverChoice = &GetSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetNetworkPolicyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.NetworkPolicyChoice.(type) {
	case nil:
		o.NetworkPolicyChoice = nil

	case *GetSpecType_ActiveEnhancedFirewallPolicies:
		o.NetworkPolicyChoice = &GlobalSpecType_ActiveEnhancedFirewallPolicies{ActiveEnhancedFirewallPolicies: of.ActiveEnhancedFirewallPolicies}

	case *GetSpecType_NoNetworkPolicy:
		o.NetworkPolicyChoice = &GlobalSpecType_NoNetworkPolicy{NoNetworkPolicy: of.NoNetworkPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetNetworkPolicyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.NetworkPolicyChoice.(type) {
	case nil:
		r.NetworkPolicyChoice = nil

	case *GlobalSpecType_ActiveEnhancedFirewallPolicies:
		r.NetworkPolicyChoice = &GetSpecType_ActiveEnhancedFirewallPolicies{ActiveEnhancedFirewallPolicies: of.ActiveEnhancedFirewallPolicies}

	case *GlobalSpecType_NoNetworkPolicy:
		r.NetworkPolicyChoice = &GetSpecType_NoNetworkPolicy{NoNetworkPolicy: of.NoNetworkPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetNodeHaChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.NodeHaChoice.(type) {
	case nil:
		o.NodeHaChoice = nil

	case *GetSpecType_DisableHa:
		o.NodeHaChoice = &GlobalSpecType_DisableHa{DisableHa: of.DisableHa}

	case *GetSpecType_EnableHa:
		o.NodeHaChoice = &GlobalSpecType_EnableHa{EnableHa: of.EnableHa}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetNodeHaChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.NodeHaChoice.(type) {
	case nil:
		r.NodeHaChoice = nil

	case *GlobalSpecType_DisableHa:
		r.NodeHaChoice = &GetSpecType_DisableHa{DisableHa: of.DisableHa}

	case *GlobalSpecType_EnableHa:
		r.NodeHaChoice = &GetSpecType_EnableHa{EnableHa: of.EnableHa}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetProviderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ProviderChoice.(type) {
	case nil:
		o.ProviderChoice = nil

	case *GetSpecType_Aws:
		o.ProviderChoice = &GlobalSpecType_Aws{Aws: of.Aws}

	case *GetSpecType_Azure:
		o.ProviderChoice = &GlobalSpecType_Azure{Azure: of.Azure}

	case *GetSpecType_Baremetal:
		o.ProviderChoice = &GlobalSpecType_Baremetal{Baremetal: of.Baremetal}

	case *GetSpecType_Gcp:
		o.ProviderChoice = &GlobalSpecType_Gcp{Gcp: of.Gcp}

	case *GetSpecType_Kvm:
		o.ProviderChoice = &GlobalSpecType_Kvm{Kvm: of.Kvm}

	case *GetSpecType_Nutanix:
		o.ProviderChoice = &GlobalSpecType_Nutanix{Nutanix: of.Nutanix}

	case *GetSpecType_Oci:
		o.ProviderChoice = &GlobalSpecType_Oci{Oci: of.Oci}

	case *GetSpecType_Openstack:
		o.ProviderChoice = &GlobalSpecType_Openstack{Openstack: of.Openstack}

	case *GetSpecType_Rseries:
		o.ProviderChoice = &GlobalSpecType_Rseries{Rseries: of.Rseries}

	case *GetSpecType_Vmware:
		o.ProviderChoice = &GlobalSpecType_Vmware{Vmware: of.Vmware}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetProviderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ProviderChoice.(type) {
	case nil:
		r.ProviderChoice = nil

	case *GlobalSpecType_Aws:
		r.ProviderChoice = &GetSpecType_Aws{Aws: of.Aws}

	case *GlobalSpecType_Azure:
		r.ProviderChoice = &GetSpecType_Azure{Azure: of.Azure}

	case *GlobalSpecType_Baremetal:
		r.ProviderChoice = &GetSpecType_Baremetal{Baremetal: of.Baremetal}

	case *GlobalSpecType_Gcp:
		r.ProviderChoice = &GetSpecType_Gcp{Gcp: of.Gcp}

	case *GlobalSpecType_Kvm:
		r.ProviderChoice = &GetSpecType_Kvm{Kvm: of.Kvm}

	case *GlobalSpecType_Nutanix:
		r.ProviderChoice = &GetSpecType_Nutanix{Nutanix: of.Nutanix}

	case *GlobalSpecType_Oci:
		r.ProviderChoice = &GetSpecType_Oci{Oci: of.Oci}

	case *GlobalSpecType_Openstack:
		r.ProviderChoice = &GetSpecType_Openstack{Openstack: of.Openstack}

	case *GlobalSpecType_Rseries:
		r.ProviderChoice = &GetSpecType_Rseries{Rseries: of.Rseries}

	case *GlobalSpecType_Vmware:
		r.ProviderChoice = &GetSpecType_Vmware{Vmware: of.Vmware}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetS2SConnectivitySliChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.S2SConnectivitySliChoice.(type) {
	case nil:
		o.S2SConnectivitySliChoice = nil

	case *GetSpecType_DcClusterGroupSli:
		o.S2SConnectivitySliChoice = &GlobalSpecType_DcClusterGroupSli{DcClusterGroupSli: of.DcClusterGroupSli}

	case *GetSpecType_NoS2SConnectivitySli:
		o.S2SConnectivitySliChoice = &GlobalSpecType_NoS2SConnectivitySli{NoS2SConnectivitySli: of.NoS2SConnectivitySli}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetS2SConnectivitySliChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.S2SConnectivitySliChoice.(type) {
	case nil:
		r.S2SConnectivitySliChoice = nil

	case *GlobalSpecType_DcClusterGroupSli:
		r.S2SConnectivitySliChoice = &GetSpecType_DcClusterGroupSli{DcClusterGroupSli: of.DcClusterGroupSli}

	case *GlobalSpecType_NoS2SConnectivitySli:
		r.S2SConnectivitySliChoice = &GetSpecType_NoS2SConnectivitySli{NoS2SConnectivitySli: of.NoS2SConnectivitySli}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetS2SConnectivitySloChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.S2SConnectivitySloChoice.(type) {
	case nil:
		o.S2SConnectivitySloChoice = nil

	case *GetSpecType_DcClusterGroupSlo:
		o.S2SConnectivitySloChoice = &GlobalSpecType_DcClusterGroupSlo{DcClusterGroupSlo: of.DcClusterGroupSlo}

	case *GetSpecType_NoS2SConnectivitySlo:
		o.S2SConnectivitySloChoice = &GlobalSpecType_NoS2SConnectivitySlo{NoS2SConnectivitySlo: of.NoS2SConnectivitySlo}

	case *GetSpecType_SiteMeshGroupOnSlo:
		o.S2SConnectivitySloChoice = &GlobalSpecType_SiteMeshGroupOnSlo{SiteMeshGroupOnSlo: of.SiteMeshGroupOnSlo}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetS2SConnectivitySloChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.S2SConnectivitySloChoice.(type) {
	case nil:
		r.S2SConnectivitySloChoice = nil

	case *GlobalSpecType_DcClusterGroupSlo:
		r.S2SConnectivitySloChoice = &GetSpecType_DcClusterGroupSlo{DcClusterGroupSlo: of.DcClusterGroupSlo}

	case *GlobalSpecType_NoS2SConnectivitySlo:
		r.S2SConnectivitySloChoice = &GetSpecType_NoS2SConnectivitySlo{NoS2SConnectivitySlo: of.NoS2SConnectivitySlo}

	case *GlobalSpecType_SiteMeshGroupOnSlo:
		r.S2SConnectivitySloChoice = &GetSpecType_SiteMeshGroupOnSlo{SiteMeshGroupOnSlo: of.SiteMeshGroupOnSlo}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AdminUserCredentials = f.GetAdminUserCredentials()
	m.GetBlockedServicesChoiceFromGlobalSpecType(f)
	m.DnsNtpConfig = f.GetDnsNtpConfig()
	m.GetEnterpriseProxyChoiceFromGlobalSpecType(f)
	m.GetForwardProxyChoiceFromGlobalSpecType(f)
	m.LoadBalancing = f.GetLoadBalancing()
	m.LocalVrf = f.GetLocalVrf()
	m.GetLogsReceiverChoiceFromGlobalSpecType(f)
	m.GetNetworkPolicyChoiceFromGlobalSpecType(f)
	m.GetNodeHaChoiceFromGlobalSpecType(f)
	m.OfflineSurvivabilityMode = f.GetOfflineSurvivabilityMode()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.PerformanceEnhancementMode = f.GetPerformanceEnhancementMode()
	m.ProactiveMonitoring = f.GetProactiveMonitoring()
	m.GetProviderChoiceFromGlobalSpecType(f)
	m.ReSelect = f.GetReSelect()
	m.GetS2SConnectivitySliChoiceFromGlobalSpecType(f)
	m.GetS2SConnectivitySloChoiceFromGlobalSpecType(f)
	m.SiteState = f.GetSiteState()
	m.SoftwareSettings = f.GetSoftwareSettings()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.UpgradeSettings = f.GetUpgradeSettings()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AdminUserCredentials = m1.AdminUserCredentials
	m1.SetBlockedServicesChoiceToGlobalSpecType(f)
	f.DnsNtpConfig = m1.DnsNtpConfig
	m1.SetEnterpriseProxyChoiceToGlobalSpecType(f)
	m1.SetForwardProxyChoiceToGlobalSpecType(f)
	f.LoadBalancing = m1.LoadBalancing
	f.LocalVrf = m1.LocalVrf
	m1.SetLogsReceiverChoiceToGlobalSpecType(f)
	m1.SetNetworkPolicyChoiceToGlobalSpecType(f)
	m1.SetNodeHaChoiceToGlobalSpecType(f)
	f.OfflineSurvivabilityMode = m1.OfflineSurvivabilityMode
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.PerformanceEnhancementMode = m1.PerformanceEnhancementMode
	f.ProactiveMonitoring = m1.ProactiveMonitoring
	m1.SetProviderChoiceToGlobalSpecType(f)
	f.ReSelect = m1.ReSelect
	m1.SetS2SConnectivitySliChoiceToGlobalSpecType(f)
	m1.SetS2SConnectivitySloChoiceToGlobalSpecType(f)
	f.SiteState = m1.SiteState
	f.SoftwareSettings = m1.SoftwareSettings
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.UpgradeSettings = m1.UpgradeSettings
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetBlockedServicesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BlockedServicesChoice.(type) {
	case nil:
		o.BlockedServicesChoice = nil

	case *ReplaceSpecType_BlockAllServices:
		o.BlockedServicesChoice = &GlobalSpecType_BlockAllServices{BlockAllServices: of.BlockAllServices}

	case *ReplaceSpecType_BlockedServices:
		o.BlockedServicesChoice = &GlobalSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetBlockedServicesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BlockedServicesChoice.(type) {
	case nil:
		r.BlockedServicesChoice = nil

	case *GlobalSpecType_BlockAllServices:
		r.BlockedServicesChoice = &ReplaceSpecType_BlockAllServices{BlockAllServices: of.BlockAllServices}

	case *GlobalSpecType_BlockedServices:
		r.BlockedServicesChoice = &ReplaceSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetEnterpriseProxyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.EnterpriseProxyChoice.(type) {
	case nil:
		o.EnterpriseProxyChoice = nil

	case *ReplaceSpecType_CustomProxy:
		o.EnterpriseProxyChoice = &GlobalSpecType_CustomProxy{CustomProxy: of.CustomProxy}

	case *ReplaceSpecType_F5Proxy:
		o.EnterpriseProxyChoice = &GlobalSpecType_F5Proxy{F5Proxy: of.F5Proxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetEnterpriseProxyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.EnterpriseProxyChoice.(type) {
	case nil:
		r.EnterpriseProxyChoice = nil

	case *GlobalSpecType_CustomProxy:
		r.EnterpriseProxyChoice = &ReplaceSpecType_CustomProxy{CustomProxy: of.CustomProxy}

	case *GlobalSpecType_F5Proxy:
		r.EnterpriseProxyChoice = &ReplaceSpecType_F5Proxy{F5Proxy: of.F5Proxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetForwardProxyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ForwardProxyChoice.(type) {
	case nil:
		o.ForwardProxyChoice = nil

	case *ReplaceSpecType_ActiveForwardProxyPolicies:
		o.ForwardProxyChoice = &GlobalSpecType_ActiveForwardProxyPolicies{ActiveForwardProxyPolicies: of.ActiveForwardProxyPolicies}

	case *ReplaceSpecType_NoForwardProxy:
		o.ForwardProxyChoice = &GlobalSpecType_NoForwardProxy{NoForwardProxy: of.NoForwardProxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetForwardProxyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ForwardProxyChoice.(type) {
	case nil:
		r.ForwardProxyChoice = nil

	case *GlobalSpecType_ActiveForwardProxyPolicies:
		r.ForwardProxyChoice = &ReplaceSpecType_ActiveForwardProxyPolicies{ActiveForwardProxyPolicies: of.ActiveForwardProxyPolicies}

	case *GlobalSpecType_NoForwardProxy:
		r.ForwardProxyChoice = &ReplaceSpecType_NoForwardProxy{NoForwardProxy: of.NoForwardProxy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetLogsReceiverChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LogsReceiverChoice.(type) {
	case nil:
		o.LogsReceiverChoice = nil

	case *ReplaceSpecType_LogReceiver:
		o.LogsReceiverChoice = &GlobalSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *ReplaceSpecType_LogsStreamingDisabled:
		o.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetLogsReceiverChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LogsReceiverChoice.(type) {
	case nil:
		r.LogsReceiverChoice = nil

	case *GlobalSpecType_LogReceiver:
		r.LogsReceiverChoice = &ReplaceSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GlobalSpecType_LogsStreamingDisabled:
		r.LogsReceiverChoice = &ReplaceSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetNetworkPolicyChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.NetworkPolicyChoice.(type) {
	case nil:
		o.NetworkPolicyChoice = nil

	case *ReplaceSpecType_ActiveEnhancedFirewallPolicies:
		o.NetworkPolicyChoice = &GlobalSpecType_ActiveEnhancedFirewallPolicies{ActiveEnhancedFirewallPolicies: of.ActiveEnhancedFirewallPolicies}

	case *ReplaceSpecType_NoNetworkPolicy:
		o.NetworkPolicyChoice = &GlobalSpecType_NoNetworkPolicy{NoNetworkPolicy: of.NoNetworkPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetNetworkPolicyChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.NetworkPolicyChoice.(type) {
	case nil:
		r.NetworkPolicyChoice = nil

	case *GlobalSpecType_ActiveEnhancedFirewallPolicies:
		r.NetworkPolicyChoice = &ReplaceSpecType_ActiveEnhancedFirewallPolicies{ActiveEnhancedFirewallPolicies: of.ActiveEnhancedFirewallPolicies}

	case *GlobalSpecType_NoNetworkPolicy:
		r.NetworkPolicyChoice = &ReplaceSpecType_NoNetworkPolicy{NoNetworkPolicy: of.NoNetworkPolicy}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetNodeHaChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.NodeHaChoice.(type) {
	case nil:
		o.NodeHaChoice = nil

	case *ReplaceSpecType_DisableHa:
		o.NodeHaChoice = &GlobalSpecType_DisableHa{DisableHa: of.DisableHa}

	case *ReplaceSpecType_EnableHa:
		o.NodeHaChoice = &GlobalSpecType_EnableHa{EnableHa: of.EnableHa}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetNodeHaChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.NodeHaChoice.(type) {
	case nil:
		r.NodeHaChoice = nil

	case *GlobalSpecType_DisableHa:
		r.NodeHaChoice = &ReplaceSpecType_DisableHa{DisableHa: of.DisableHa}

	case *GlobalSpecType_EnableHa:
		r.NodeHaChoice = &ReplaceSpecType_EnableHa{EnableHa: of.EnableHa}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetProviderChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ProviderChoice.(type) {
	case nil:
		o.ProviderChoice = nil

	case *ReplaceSpecType_Aws:
		o.ProviderChoice = &GlobalSpecType_Aws{Aws: of.Aws}

	case *ReplaceSpecType_Azure:
		o.ProviderChoice = &GlobalSpecType_Azure{Azure: of.Azure}

	case *ReplaceSpecType_Baremetal:
		o.ProviderChoice = &GlobalSpecType_Baremetal{Baremetal: of.Baremetal}

	case *ReplaceSpecType_Gcp:
		o.ProviderChoice = &GlobalSpecType_Gcp{Gcp: of.Gcp}

	case *ReplaceSpecType_Kvm:
		o.ProviderChoice = &GlobalSpecType_Kvm{Kvm: of.Kvm}

	case *ReplaceSpecType_Nutanix:
		o.ProviderChoice = &GlobalSpecType_Nutanix{Nutanix: of.Nutanix}

	case *ReplaceSpecType_Oci:
		o.ProviderChoice = &GlobalSpecType_Oci{Oci: of.Oci}

	case *ReplaceSpecType_Openstack:
		o.ProviderChoice = &GlobalSpecType_Openstack{Openstack: of.Openstack}

	case *ReplaceSpecType_Rseries:
		o.ProviderChoice = &GlobalSpecType_Rseries{Rseries: of.Rseries}

	case *ReplaceSpecType_Vmware:
		o.ProviderChoice = &GlobalSpecType_Vmware{Vmware: of.Vmware}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetProviderChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ProviderChoice.(type) {
	case nil:
		r.ProviderChoice = nil

	case *GlobalSpecType_Aws:
		r.ProviderChoice = &ReplaceSpecType_Aws{Aws: of.Aws}

	case *GlobalSpecType_Azure:
		r.ProviderChoice = &ReplaceSpecType_Azure{Azure: of.Azure}

	case *GlobalSpecType_Baremetal:
		r.ProviderChoice = &ReplaceSpecType_Baremetal{Baremetal: of.Baremetal}

	case *GlobalSpecType_Gcp:
		r.ProviderChoice = &ReplaceSpecType_Gcp{Gcp: of.Gcp}

	case *GlobalSpecType_Kvm:
		r.ProviderChoice = &ReplaceSpecType_Kvm{Kvm: of.Kvm}

	case *GlobalSpecType_Nutanix:
		r.ProviderChoice = &ReplaceSpecType_Nutanix{Nutanix: of.Nutanix}

	case *GlobalSpecType_Oci:
		r.ProviderChoice = &ReplaceSpecType_Oci{Oci: of.Oci}

	case *GlobalSpecType_Openstack:
		r.ProviderChoice = &ReplaceSpecType_Openstack{Openstack: of.Openstack}

	case *GlobalSpecType_Rseries:
		r.ProviderChoice = &ReplaceSpecType_Rseries{Rseries: of.Rseries}

	case *GlobalSpecType_Vmware:
		r.ProviderChoice = &ReplaceSpecType_Vmware{Vmware: of.Vmware}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetS2SConnectivitySliChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.S2SConnectivitySliChoice.(type) {
	case nil:
		o.S2SConnectivitySliChoice = nil

	case *ReplaceSpecType_DcClusterGroupSli:
		o.S2SConnectivitySliChoice = &GlobalSpecType_DcClusterGroupSli{DcClusterGroupSli: of.DcClusterGroupSli}

	case *ReplaceSpecType_NoS2SConnectivitySli:
		o.S2SConnectivitySliChoice = &GlobalSpecType_NoS2SConnectivitySli{NoS2SConnectivitySli: of.NoS2SConnectivitySli}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetS2SConnectivitySliChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.S2SConnectivitySliChoice.(type) {
	case nil:
		r.S2SConnectivitySliChoice = nil

	case *GlobalSpecType_DcClusterGroupSli:
		r.S2SConnectivitySliChoice = &ReplaceSpecType_DcClusterGroupSli{DcClusterGroupSli: of.DcClusterGroupSli}

	case *GlobalSpecType_NoS2SConnectivitySli:
		r.S2SConnectivitySliChoice = &ReplaceSpecType_NoS2SConnectivitySli{NoS2SConnectivitySli: of.NoS2SConnectivitySli}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetS2SConnectivitySloChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.S2SConnectivitySloChoice.(type) {
	case nil:
		o.S2SConnectivitySloChoice = nil

	case *ReplaceSpecType_DcClusterGroupSlo:
		o.S2SConnectivitySloChoice = &GlobalSpecType_DcClusterGroupSlo{DcClusterGroupSlo: of.DcClusterGroupSlo}

	case *ReplaceSpecType_NoS2SConnectivitySlo:
		o.S2SConnectivitySloChoice = &GlobalSpecType_NoS2SConnectivitySlo{NoS2SConnectivitySlo: of.NoS2SConnectivitySlo}

	case *ReplaceSpecType_SiteMeshGroupOnSlo:
		o.S2SConnectivitySloChoice = &GlobalSpecType_SiteMeshGroupOnSlo{SiteMeshGroupOnSlo: of.SiteMeshGroupOnSlo}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetS2SConnectivitySloChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.S2SConnectivitySloChoice.(type) {
	case nil:
		r.S2SConnectivitySloChoice = nil

	case *GlobalSpecType_DcClusterGroupSlo:
		r.S2SConnectivitySloChoice = &ReplaceSpecType_DcClusterGroupSlo{DcClusterGroupSlo: of.DcClusterGroupSlo}

	case *GlobalSpecType_NoS2SConnectivitySlo:
		r.S2SConnectivitySloChoice = &ReplaceSpecType_NoS2SConnectivitySlo{NoS2SConnectivitySlo: of.NoS2SConnectivitySlo}

	case *GlobalSpecType_SiteMeshGroupOnSlo:
		r.S2SConnectivitySloChoice = &ReplaceSpecType_SiteMeshGroupOnSlo{SiteMeshGroupOnSlo: of.SiteMeshGroupOnSlo}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AdminUserCredentials = f.GetAdminUserCredentials()
	m.GetBlockedServicesChoiceFromGlobalSpecType(f)
	m.DnsNtpConfig = f.GetDnsNtpConfig()
	m.GetEnterpriseProxyChoiceFromGlobalSpecType(f)
	m.GetForwardProxyChoiceFromGlobalSpecType(f)
	m.LoadBalancing = f.GetLoadBalancing()
	m.LocalVrf = f.GetLocalVrf()
	m.GetLogsReceiverChoiceFromGlobalSpecType(f)
	m.GetNetworkPolicyChoiceFromGlobalSpecType(f)
	m.GetNodeHaChoiceFromGlobalSpecType(f)
	m.OfflineSurvivabilityMode = f.GetOfflineSurvivabilityMode()
	m.PerformanceEnhancementMode = f.GetPerformanceEnhancementMode()
	m.ProactiveMonitoring = f.GetProactiveMonitoring()
	m.GetProviderChoiceFromGlobalSpecType(f)
	m.ReSelect = f.GetReSelect()
	m.GetS2SConnectivitySliChoiceFromGlobalSpecType(f)
	m.GetS2SConnectivitySloChoiceFromGlobalSpecType(f)
	m.SoftwareSettings = f.GetSoftwareSettings()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.UpgradeSettings = f.GetUpgradeSettings()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AdminUserCredentials = m1.AdminUserCredentials
	m1.SetBlockedServicesChoiceToGlobalSpecType(f)
	f.DnsNtpConfig = m1.DnsNtpConfig
	m1.SetEnterpriseProxyChoiceToGlobalSpecType(f)
	m1.SetForwardProxyChoiceToGlobalSpecType(f)
	f.LoadBalancing = m1.LoadBalancing
	f.LocalVrf = m1.LocalVrf
	m1.SetLogsReceiverChoiceToGlobalSpecType(f)
	m1.SetNetworkPolicyChoiceToGlobalSpecType(f)
	m1.SetNodeHaChoiceToGlobalSpecType(f)
	f.OfflineSurvivabilityMode = m1.OfflineSurvivabilityMode
	f.PerformanceEnhancementMode = m1.PerformanceEnhancementMode
	f.ProactiveMonitoring = m1.ProactiveMonitoring
	m1.SetProviderChoiceToGlobalSpecType(f)
	f.ReSelect = m1.ReSelect
	m1.SetS2SConnectivitySliChoiceToGlobalSpecType(f)
	m1.SetS2SConnectivitySloChoiceToGlobalSpecType(f)
	f.SoftwareSettings = m1.SoftwareSettings
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.UpgradeSettings = m1.UpgradeSettings
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
