// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/securemesh_site_v2/azure_types.proto

package securemesh_site_v2

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_interface"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AzureManagedMode
//
// x-displayName: "Managed By F5XC"
// F5 Distributed Cloud will automate provisioning (ex: node bringup) for this Azure site.
type AzureManagedMode struct {
	// Recommended Azure Region Name
	//
	// x-displayName: "Recommended Azure Region Name"
	// x-example: "eastus"
	// x-required
	// Name of the azure region which supports availability zones.
	AzureRegion string `protobuf:"bytes,1,opt,name=azure_region,json=azureRegion,proto3" json:"azure_region,omitempty"`
	// Resource Group
	//
	// x-displayName: "Resource Group"
	// x-example: "my-resources"
	// x-required
	// Azure resource group for resources that will be created
	ResourceGroup string `protobuf:"bytes,4,opt,name=resource_group,json=resourceGroup,proto3" json:"resource_group,omitempty"`
	// Vnet
	//
	// x-displayName: "Vnet"
	// x-required
	// Choice of using existing VNet or create new VNet
	Vnet *views.AzureVnetChoiceType `protobuf:"bytes,5,opt,name=vnet,proto3" json:"vnet,omitempty"`
	// Automatic Deployment
	//
	// x-displayName: "Cloud Credentials"
	// x-required
	// Reference to Azure credentials for automatic deployment
	AzureCred *views.ObjectRefType `protobuf:"bytes,6,opt,name=azure_cred,json=azureCred,proto3" json:"azure_cred,omitempty"`
	// Azure Tags
	//
	// x-displayName: "Azure Tags"
	// x-example: "dev: staging"
	// Azure Tags is a label consisting of a user-defined key and value.
	// It helps to manage, identify, organize, search for, and filter resources in Azure console.
	Tags map[string]string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Machine Type
	//
	// x-displayName: "Azure Machine Type for Node"
	// x-example: "Standard_D3_v2"
	// x-required
	// Select Instance size based on performance needed.
	// The default setting for Accelerated Networking is enabled, thus make sure
	// you select a Virtual Machine that supports accelerated networking or
	// disable the setting under, Select Ingress Gateway or Ingress/Egress Gateway
	// > advanced options.
	MachineType string `protobuf:"bytes,8,opt,name=machine_type,json=machineType,proto3" json:"machine_type,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example: "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,9,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// Number of interfaces on CE
	//
	// x-displayName: "Select Node Settings"
	// x-required
	// Choice of deploying one interface or multiple interface site
	//
	// Types that are valid to be assigned to SiteType:
	//	*AzureManagedMode_SingleInterface
	//	*AzureManagedMode_MultipleInterface
	SiteType isAzureManagedMode_SiteType `protobuf_oneof:"site_type"`
	// Accelerated Networking
	//
	// x-displayName: "Accelerated Networking"
	// Accelerated Networking to reduce Latency, When Mode is toggled, traffic
	// disruption will be seen
	AcceleratedNetworking *views.AcceleratedNetworkingType `protobuf:"bytes,22,opt,name=accelerated_networking,json=acceleratedNetworking,proto3" json:"accelerated_networking,omitempty"`
	// Configure Cloud Connect for this site
	//
	// x-displayName: "Cloud Connect"
	// x-required
	// Configure Cloud Connect for this site.
	//
	// Types that are valid to be assigned to CloudConnectAttachments:
	//	*AzureManagedMode_Disabled
	//	*AzureManagedMode_Enabled
	CloudConnectAttachments isAzureManagedMode_CloudConnectAttachments `protobuf_oneof:"cloud_connect_attachments"`
}

func (m *AzureManagedMode) Reset()      { *m = AzureManagedMode{} }
func (*AzureManagedMode) ProtoMessage() {}
func (*AzureManagedMode) Descriptor() ([]byte, []int) {
	return fileDescriptor_d985f1cdb6c16fdf, []int{0}
}
func (m *AzureManagedMode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureManagedMode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureManagedMode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureManagedMode.Merge(m, src)
}
func (m *AzureManagedMode) XXX_Size() int {
	return m.Size()
}
func (m *AzureManagedMode) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureManagedMode.DiscardUnknown(m)
}

var xxx_messageInfo_AzureManagedMode proto.InternalMessageInfo

type isAzureManagedMode_SiteType interface {
	isAzureManagedMode_SiteType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isAzureManagedMode_CloudConnectAttachments interface {
	isAzureManagedMode_CloudConnectAttachments()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureManagedMode_SingleInterface struct {
	SingleInterface *AzureSingleInterface `protobuf:"bytes,12,opt,name=single_interface,json=singleInterface,proto3,oneof" json:"single_interface,omitempty"`
}
type AzureManagedMode_MultipleInterface struct {
	MultipleInterface *AzureMultipleInterface `protobuf:"bytes,13,opt,name=multiple_interface,json=multipleInterface,proto3,oneof" json:"multiple_interface,omitempty"`
}
type AzureManagedMode_Disabled struct {
	Disabled *schema.Empty `protobuf:"bytes,24,opt,name=disabled,proto3,oneof" json:"disabled,omitempty"`
}
type AzureManagedMode_Enabled struct {
	Enabled *schema.Empty `protobuf:"bytes,25,opt,name=enabled,proto3,oneof" json:"enabled,omitempty"`
}

func (*AzureManagedMode_SingleInterface) isAzureManagedMode_SiteType()         {}
func (*AzureManagedMode_MultipleInterface) isAzureManagedMode_SiteType()       {}
func (*AzureManagedMode_Disabled) isAzureManagedMode_CloudConnectAttachments() {}
func (*AzureManagedMode_Enabled) isAzureManagedMode_CloudConnectAttachments()  {}

func (m *AzureManagedMode) GetSiteType() isAzureManagedMode_SiteType {
	if m != nil {
		return m.SiteType
	}
	return nil
}
func (m *AzureManagedMode) GetCloudConnectAttachments() isAzureManagedMode_CloudConnectAttachments {
	if m != nil {
		return m.CloudConnectAttachments
	}
	return nil
}

func (m *AzureManagedMode) GetAzureRegion() string {
	if m != nil {
		return m.AzureRegion
	}
	return ""
}

func (m *AzureManagedMode) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *AzureManagedMode) GetVnet() *views.AzureVnetChoiceType {
	if m != nil {
		return m.Vnet
	}
	return nil
}

func (m *AzureManagedMode) GetAzureCred() *views.ObjectRefType {
	if m != nil {
		return m.AzureCred
	}
	return nil
}

func (m *AzureManagedMode) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AzureManagedMode) GetMachineType() string {
	if m != nil {
		return m.MachineType
	}
	return ""
}

func (m *AzureManagedMode) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

func (m *AzureManagedMode) GetSingleInterface() *AzureSingleInterface {
	if x, ok := m.GetSiteType().(*AzureManagedMode_SingleInterface); ok {
		return x.SingleInterface
	}
	return nil
}

func (m *AzureManagedMode) GetMultipleInterface() *AzureMultipleInterface {
	if x, ok := m.GetSiteType().(*AzureManagedMode_MultipleInterface); ok {
		return x.MultipleInterface
	}
	return nil
}

func (m *AzureManagedMode) GetAcceleratedNetworking() *views.AcceleratedNetworkingType {
	if m != nil {
		return m.AcceleratedNetworking
	}
	return nil
}

func (m *AzureManagedMode) GetDisabled() *schema.Empty {
	if x, ok := m.GetCloudConnectAttachments().(*AzureManagedMode_Disabled); ok {
		return x.Disabled
	}
	return nil
}

func (m *AzureManagedMode) GetEnabled() *schema.Empty {
	if x, ok := m.GetCloudConnectAttachments().(*AzureManagedMode_Enabled); ok {
		return x.Enabled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureManagedMode) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureManagedMode_SingleInterface)(nil),
		(*AzureManagedMode_MultipleInterface)(nil),
		(*AzureManagedMode_Disabled)(nil),
		(*AzureManagedMode_Enabled)(nil),
	}
}

// One Interface
//
// x-displayName: "One Interface"
// One interface site is useful when site is only used as ingress gateway to the VNET.
type AzureSingleInterface struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// This section will show nodes associated with this site.
	NodeList *AzureManagedNodeList `protobuf:"bytes,1,opt,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
}

func (m *AzureSingleInterface) Reset()      { *m = AzureSingleInterface{} }
func (*AzureSingleInterface) ProtoMessage() {}
func (*AzureSingleInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_d985f1cdb6c16fdf, []int{1}
}
func (m *AzureSingleInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSingleInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSingleInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSingleInterface.Merge(m, src)
}
func (m *AzureSingleInterface) XXX_Size() int {
	return m.Size()
}
func (m *AzureSingleInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSingleInterface.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSingleInterface proto.InternalMessageInfo

func (m *AzureSingleInterface) GetNodeList() *AzureManagedNodeList {
	if m != nil {
		return m.NodeList
	}
	return nil
}

// Multiple Interface Site
//
// x-displayName: "Multiple Interface"
// Multiple interface site is useful when site is used as ingress/egress gateway to the VNET.
type AzureMultipleInterface struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// This section will show nodes associated with this site.
	NodeList *AzureManagedNodeList `protobuf:"bytes,1,opt,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
}

func (m *AzureMultipleInterface) Reset()      { *m = AzureMultipleInterface{} }
func (*AzureMultipleInterface) ProtoMessage() {}
func (*AzureMultipleInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_d985f1cdb6c16fdf, []int{2}
}
func (m *AzureMultipleInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureMultipleInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureMultipleInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureMultipleInterface.Merge(m, src)
}
func (m *AzureMultipleInterface) XXX_Size() int {
	return m.Size()
}
func (m *AzureMultipleInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureMultipleInterface.DiscardUnknown(m)
}

var xxx_messageInfo_AzureMultipleInterface proto.InternalMessageInfo

func (m *AzureMultipleInterface) GetNodeList() *AzureManagedNodeList {
	if m != nil {
		return m.NodeList
	}
	return nil
}

// AzureManagedNodeList
//
// x-displayName: "List of Nodes"
// This section will show nodes associated with this site.
type AzureManagedNodeList struct {
	// Nodes
	//
	// x-displayName: "Nodes"
	// x-required
	// This section will show nodes associated with this site.
	NodeList []*AzureManagedNode `protobuf:"bytes,1,rep,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
}

func (m *AzureManagedNodeList) Reset()      { *m = AzureManagedNodeList{} }
func (*AzureManagedNodeList) ProtoMessage() {}
func (*AzureManagedNodeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_d985f1cdb6c16fdf, []int{3}
}
func (m *AzureManagedNodeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureManagedNodeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureManagedNodeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureManagedNodeList.Merge(m, src)
}
func (m *AzureManagedNodeList) XXX_Size() int {
	return m.Size()
}
func (m *AzureManagedNodeList) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureManagedNodeList.DiscardUnknown(m)
}

var xxx_messageInfo_AzureManagedNodeList proto.InternalMessageInfo

func (m *AzureManagedNodeList) GetNodeList() []*AzureManagedNode {
	if m != nil {
		return m.NodeList
	}
	return nil
}

// AzureManagedNode
//
// x-displayName: "Nodes"
// This section will show nodes associated with this site.
type AzureManagedNode struct {
	// Type
	//
	// x-displayName: "Type"
	// x-required
	// x-example: "Control"
	// Type for this Node, can be Control
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Hostname
	//
	// x-displayName: "Hostname"
	// Hostname for this Node
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Azure AZ
	//
	// x-displayName: "Azure AZ Name"
	// x-required
	// x-example: "1"
	// Azure availability zone.
	AzureAz string `protobuf:"bytes,3,opt,name=azure_az,json=azureAz,proto3" json:"azure_az,omitempty"`
	// AzureOrchestratedInterface
	//
	// x-displayName: "Interfaces"
	// x-required
	// Interfaces belonging to this node
	InterfaceList []*AzureOrchestratedInterface `protobuf:"bytes,4,rep,name=interface_list,json=interfaceList,proto3" json:"interface_list,omitempty"`
}

func (m *AzureManagedNode) Reset()      { *m = AzureManagedNode{} }
func (*AzureManagedNode) ProtoMessage() {}
func (*AzureManagedNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_d985f1cdb6c16fdf, []int{4}
}
func (m *AzureManagedNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureManagedNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureManagedNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureManagedNode.Merge(m, src)
}
func (m *AzureManagedNode) XXX_Size() int {
	return m.Size()
}
func (m *AzureManagedNode) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureManagedNode.DiscardUnknown(m)
}

var xxx_messageInfo_AzureManagedNode proto.InternalMessageInfo

func (m *AzureManagedNode) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AzureManagedNode) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AzureManagedNode) GetAzureAz() string {
	if m != nil {
		return m.AzureAz
	}
	return ""
}

func (m *AzureManagedNode) GetInterfaceList() []*AzureOrchestratedInterface {
	if m != nil {
		return m.InterfaceList
	}
	return nil
}

// AzureOrchestratedInterface
//
// x-displayName: "Interfaces"
// Interfaces belonging to this node
type AzureOrchestratedInterface struct {
	// Subnet Choice
	//
	// x-displayName: "Specify Subnet"
	// Select Existing Subnet or Create New
	Subnet *AzureSubnetChoiceType `protobuf:"bytes,1,opt,name=subnet,proto3" json:"subnet,omitempty"`
	// Select VRF
	//
	// x-displayName: "Select VRF"
	// x-required
	// Select virtual network (VRF) for this interface.
	// There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites.
	// A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional.
	// Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).
	NetworkOption *views.NetworkSelectType `protobuf:"bytes,2,opt,name=network_option,json=networkOption,proto3" json:"network_option,omitempty"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Use for Site to Site Connectivity
	//
	// x-displayName: "Use for Site to Site Connectivity"
	// Interface with this field enabled will be used to connect to other sites.
	// This setting is useful if a node has multiple interfaces configured in a VRF.
	// Only one interface in a VRF can have this field enabled.
	//
	// Types that are valid to be assigned to SiteToSiteConnectivityInterfaceChoice:
	//	*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled
	//	*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled
	SiteToSiteConnectivityInterfaceChoice isAzureOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice `protobuf_oneof:"site_to_site_connectivity_interface_choice"`
}

func (m *AzureOrchestratedInterface) Reset()      { *m = AzureOrchestratedInterface{} }
func (*AzureOrchestratedInterface) ProtoMessage() {}
func (*AzureOrchestratedInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_d985f1cdb6c16fdf, []int{5}
}
func (m *AzureOrchestratedInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureOrchestratedInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureOrchestratedInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureOrchestratedInterface.Merge(m, src)
}
func (m *AzureOrchestratedInterface) XXX_Size() int {
	return m.Size()
}
func (m *AzureOrchestratedInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureOrchestratedInterface.DiscardUnknown(m)
}

var xxx_messageInfo_AzureOrchestratedInterface proto.InternalMessageInfo

type isAzureOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice interface {
	isAzureOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled struct {
	SiteToSiteConnectivityInterfaceDisabled *schema.Empty `protobuf:"bytes,5,opt,name=site_to_site_connectivity_interface_disabled,json=siteToSiteConnectivityInterfaceDisabled,proto3,oneof" json:"site_to_site_connectivity_interface_disabled,omitempty"`
}
type AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled struct {
	SiteToSiteConnectivityInterfaceEnabled *schema.Empty `protobuf:"bytes,6,opt,name=site_to_site_connectivity_interface_enabled,json=siteToSiteConnectivityInterfaceEnabled,proto3,oneof" json:"site_to_site_connectivity_interface_enabled,omitempty"`
}

func (*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) isAzureOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice() {
}
func (*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) isAzureOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice() {
}

func (m *AzureOrchestratedInterface) GetSiteToSiteConnectivityInterfaceChoice() isAzureOrchestratedInterface_SiteToSiteConnectivityInterfaceChoice {
	if m != nil {
		return m.SiteToSiteConnectivityInterfaceChoice
	}
	return nil
}

func (m *AzureOrchestratedInterface) GetSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *AzureOrchestratedInterface) GetNetworkOption() *views.NetworkSelectType {
	if m != nil {
		return m.NetworkOption
	}
	return nil
}

func (m *AzureOrchestratedInterface) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *AzureOrchestratedInterface) GetSiteToSiteConnectivityInterfaceDisabled() *schema.Empty {
	if x, ok := m.GetSiteToSiteConnectivityInterfaceChoice().(*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled); ok {
		return x.SiteToSiteConnectivityInterfaceDisabled
	}
	return nil
}

func (m *AzureOrchestratedInterface) GetSiteToSiteConnectivityInterfaceEnabled() *schema.Empty {
	if x, ok := m.GetSiteToSiteConnectivityInterfaceChoice().(*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled); ok {
		return x.SiteToSiteConnectivityInterfaceEnabled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureOrchestratedInterface) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled)(nil),
		(*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled)(nil),
	}
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetChoiceType struct {
	// Choice of subnet
	//
	// x-displayName: "Select Existing Subnet or Create New"
	// x-required
	// Subnet for the Single interface of the site
	//
	// Types that are valid to be assigned to Choice:
	//	*AzureSubnetChoiceType_SubnetParam
	//	*AzureSubnetChoiceType_ExistingSubnet
	Choice isAzureSubnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AzureSubnetChoiceType) Reset()      { *m = AzureSubnetChoiceType{} }
func (*AzureSubnetChoiceType) ProtoMessage() {}
func (*AzureSubnetChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d985f1cdb6c16fdf, []int{6}
}
func (m *AzureSubnetChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetChoiceType.Merge(m, src)
}
func (m *AzureSubnetChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetChoiceType proto.InternalMessageInfo

type isAzureSubnetChoiceType_Choice interface {
	isAzureSubnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureSubnetChoiceType_SubnetParam struct {
	SubnetParam *CloudSubnetParamType `protobuf:"bytes,2,opt,name=subnet_param,json=subnetParam,proto3,oneof" json:"subnet_param,omitempty"`
}
type AzureSubnetChoiceType_ExistingSubnet struct {
	ExistingSubnet *AzureSubnetType `protobuf:"bytes,3,opt,name=existing_subnet,json=existingSubnet,proto3,oneof" json:"existing_subnet,omitempty"`
}

func (*AzureSubnetChoiceType_SubnetParam) isAzureSubnetChoiceType_Choice()    {}
func (*AzureSubnetChoiceType_ExistingSubnet) isAzureSubnetChoiceType_Choice() {}

func (m *AzureSubnetChoiceType) GetChoice() isAzureSubnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AzureSubnetChoiceType) GetSubnetParam() *CloudSubnetParamType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *AzureSubnetChoiceType) GetExistingSubnet() *AzureSubnetType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceType_ExistingSubnet); ok {
		return x.ExistingSubnet
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureSubnetChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureSubnetChoiceType_SubnetParam)(nil),
		(*AzureSubnetChoiceType_ExistingSubnet)(nil),
	}
}

// Cloud Subnet Param
//
// x-displayName: "New Cloud Subnet Parameters"
// Parameters for creating a new cloud subnet
type CloudSubnetParamType struct {
	// Subnet Name
	//
	// x-displayName: "Subnet Name"
	// x-example: "subnet-a"
	// Name for your Subnet
	//
	// Types that are valid to be assigned to NameChoice:
	//	*CloudSubnetParamType_Name
	//	*CloudSubnetParamType_Autogenerate
	NameChoice isCloudSubnetParamType_NameChoice `protobuf_oneof:"name_choice"`
	// IPv4 Subnet
	//
	// x-displayName: "IPv4 Subnet"
	// x-required
	// x-example: "10.1.2.0/24"
	// IPv4 subnet prefix for this subnet
	Ipv4 string `protobuf:"bytes,4,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
}

func (m *CloudSubnetParamType) Reset()      { *m = CloudSubnetParamType{} }
func (*CloudSubnetParamType) ProtoMessage() {}
func (*CloudSubnetParamType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d985f1cdb6c16fdf, []int{7}
}
func (m *CloudSubnetParamType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudSubnetParamType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudSubnetParamType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudSubnetParamType.Merge(m, src)
}
func (m *CloudSubnetParamType) XXX_Size() int {
	return m.Size()
}
func (m *CloudSubnetParamType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudSubnetParamType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudSubnetParamType proto.InternalMessageInfo

type isCloudSubnetParamType_NameChoice interface {
	isCloudSubnetParamType_NameChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudSubnetParamType_Name struct {
	Name string `protobuf:"bytes,2,opt,name=name,proto3,oneof" json:"name,omitempty"`
}
type CloudSubnetParamType_Autogenerate struct {
	Autogenerate *schema.Empty `protobuf:"bytes,3,opt,name=autogenerate,proto3,oneof" json:"autogenerate,omitempty"`
}

func (*CloudSubnetParamType_Name) isCloudSubnetParamType_NameChoice()         {}
func (*CloudSubnetParamType_Autogenerate) isCloudSubnetParamType_NameChoice() {}

func (m *CloudSubnetParamType) GetNameChoice() isCloudSubnetParamType_NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

func (m *CloudSubnetParamType) GetName() string {
	if x, ok := m.GetNameChoice().(*CloudSubnetParamType_Name); ok {
		return x.Name
	}
	return ""
}

func (m *CloudSubnetParamType) GetAutogenerate() *schema.Empty {
	if x, ok := m.GetNameChoice().(*CloudSubnetParamType_Autogenerate); ok {
		return x.Autogenerate
	}
	return nil
}

func (m *CloudSubnetParamType) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CloudSubnetParamType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CloudSubnetParamType_Name)(nil),
		(*CloudSubnetParamType_Autogenerate)(nil),
	}
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetType struct {
	// Existing Subnet Name
	//
	// x-displayName: "Subnet Name"
	// x-example: "MySubnet"
	// x-required
	// Name of existing subnet.
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
	// Existing Subnet Resource Group
	//
	// x-displayName: "Subnet Resource Group"
	// x-example: "MySubnet"
	// Resource group for this subnet.
	//
	// Types that are valid to be assigned to ResourceGroupChoice:
	//	*AzureSubnetType_VnetResourceGroup
	ResourceGroupChoice isAzureSubnetType_ResourceGroupChoice `protobuf_oneof:"resource_group_choice"`
}

func (m *AzureSubnetType) Reset()      { *m = AzureSubnetType{} }
func (*AzureSubnetType) ProtoMessage() {}
func (*AzureSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d985f1cdb6c16fdf, []int{8}
}
func (m *AzureSubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetType.Merge(m, src)
}
func (m *AzureSubnetType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetType proto.InternalMessageInfo

type isAzureSubnetType_ResourceGroupChoice interface {
	isAzureSubnetType_ResourceGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureSubnetType_VnetResourceGroup struct {
	VnetResourceGroup *schema.Empty `protobuf:"bytes,4,opt,name=vnet_resource_group,json=vnetResourceGroup,proto3,oneof" json:"vnet_resource_group,omitempty"`
}

func (*AzureSubnetType_VnetResourceGroup) isAzureSubnetType_ResourceGroupChoice() {}

func (m *AzureSubnetType) GetResourceGroupChoice() isAzureSubnetType_ResourceGroupChoice {
	if m != nil {
		return m.ResourceGroupChoice
	}
	return nil
}

func (m *AzureSubnetType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

func (m *AzureSubnetType) GetVnetResourceGroup() *schema.Empty {
	if x, ok := m.GetResourceGroupChoice().(*AzureSubnetType_VnetResourceGroup); ok {
		return x.VnetResourceGroup
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureSubnetType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureSubnetType_VnetResourceGroup)(nil),
	}
}

func init() {
	proto.RegisterType((*AzureManagedMode)(nil), "ves.io.schema.views.securemesh_site_v2.AzureManagedMode")
	golang_proto.RegisterType((*AzureManagedMode)(nil), "ves.io.schema.views.securemesh_site_v2.AzureManagedMode")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.securemesh_site_v2.AzureManagedMode.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.securemesh_site_v2.AzureManagedMode.TagsEntry")
	proto.RegisterType((*AzureSingleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.AzureSingleInterface")
	golang_proto.RegisterType((*AzureSingleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.AzureSingleInterface")
	proto.RegisterType((*AzureMultipleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.AzureMultipleInterface")
	golang_proto.RegisterType((*AzureMultipleInterface)(nil), "ves.io.schema.views.securemesh_site_v2.AzureMultipleInterface")
	proto.RegisterType((*AzureManagedNodeList)(nil), "ves.io.schema.views.securemesh_site_v2.AzureManagedNodeList")
	golang_proto.RegisterType((*AzureManagedNodeList)(nil), "ves.io.schema.views.securemesh_site_v2.AzureManagedNodeList")
	proto.RegisterType((*AzureManagedNode)(nil), "ves.io.schema.views.securemesh_site_v2.AzureManagedNode")
	golang_proto.RegisterType((*AzureManagedNode)(nil), "ves.io.schema.views.securemesh_site_v2.AzureManagedNode")
	proto.RegisterType((*AzureOrchestratedInterface)(nil), "ves.io.schema.views.securemesh_site_v2.AzureOrchestratedInterface")
	golang_proto.RegisterType((*AzureOrchestratedInterface)(nil), "ves.io.schema.views.securemesh_site_v2.AzureOrchestratedInterface")
	proto.RegisterType((*AzureSubnetChoiceType)(nil), "ves.io.schema.views.securemesh_site_v2.AzureSubnetChoiceType")
	golang_proto.RegisterType((*AzureSubnetChoiceType)(nil), "ves.io.schema.views.securemesh_site_v2.AzureSubnetChoiceType")
	proto.RegisterType((*CloudSubnetParamType)(nil), "ves.io.schema.views.securemesh_site_v2.CloudSubnetParamType")
	golang_proto.RegisterType((*CloudSubnetParamType)(nil), "ves.io.schema.views.securemesh_site_v2.CloudSubnetParamType")
	proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.securemesh_site_v2.AzureSubnetType")
	golang_proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.securemesh_site_v2.AzureSubnetType")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/securemesh_site_v2/azure_types.proto", fileDescriptor_d985f1cdb6c16fdf)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/securemesh_site_v2/azure_types.proto", fileDescriptor_d985f1cdb6c16fdf)
}

var fileDescriptor_d985f1cdb6c16fdf = []byte{
	// 2494 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4d, 0x6c, 0x1b, 0xc7,
	0xf5, 0xd7, 0x90, 0x14, 0x45, 0x3d, 0x8a, 0x12, 0x3d, 0xb6, 0xe4, 0xb5, 0xe2, 0x30, 0x1b, 0xc5,
	0xb1, 0x29, 0x99, 0x22, 0xc5, 0xa5, 0x24, 0x2b, 0xc2, 0xdf, 0x41, 0x44, 0x45, 0x89, 0xad, 0xc4,
	0xb2, 0xff, 0xa4, 0xed, 0x02, 0x49, 0x5b, 0x62, 0xb4, 0x1c, 0x51, 0x13, 0x91, 0xbb, 0xec, 0xee,
	0x92, 0x0a, 0xd5, 0x06, 0x35, 0xd0, 0xa2, 0x40, 0x02, 0x14, 0x08, 0xd2, 0x43, 0x5b, 0x03, 0x3d,
	0x16, 0x28, 0x7a, 0x6a, 0x81, 0x9e, 0x42, 0x07, 0x35, 0x02, 0x14, 0x68, 0x7b, 0xd2, 0x31, 0xf0,
	0x29, 0x91, 0x2f, 0xe9, 0xcd, 0x28, 0x5a, 0x20, 0xb7, 0x16, 0x33, 0xfb, 0xc1, 0x5d, 0x8a, 0x4e,
	0xec, 0x00, 0x3d, 0x71, 0x77, 0xde, 0xfb, 0xbd, 0x8f, 0xdf, 0xbc, 0x79, 0x6f, 0x87, 0xb0, 0xd2,
	0xa6, 0x66, 0x96, 0xe9, 0x39, 0x53, 0xdd, 0xa5, 0x0d, 0x92, 0x6b, 0x33, 0xba, 0x6f, 0xe6, 0x4c,
	0xaa, 0xb6, 0x0c, 0xda, 0xa0, 0xe6, 0x6e, 0xc5, 0x64, 0x16, 0xad, 0xb4, 0x95, 0x1c, 0x39, 0x68,
	0x19, 0xb4, 0x62, 0x75, 0x9a, 0xd4, 0xcc, 0x36, 0x0d, 0xdd, 0xd2, 0xf1, 0x79, 0x1b, 0x99, 0xb5,
	0x91, 0x59, 0x81, 0xcc, 0x1e, 0x47, 0x4e, 0xcf, 0xd7, 0x98, 0xb5, 0xdb, 0xda, 0xce, 0xaa, 0x7a,
	0x23, 0x57, 0xd3, 0x6b, 0x7a, 0x4e, 0xc0, 0xb7, 0x5b, 0x3b, 0xe2, 0x4d, 0xbc, 0x88, 0x27, 0xdb,
	0xec, 0xf4, 0xe9, 0x60, 0x40, 0x1a, 0xb5, 0x1c, 0xc1, 0xc5, 0x63, 0x82, 0x7d, 0xdd, 0xd8, 0xab,
	0x30, 0xcd, 0xa2, 0xc6, 0x0e, 0x51, 0x69, 0xce, 0x17, 0xdc, 0xf4, 0x33, 0x41, 0x65, 0xbd, 0x69,
	0x31, 0x5d, 0x73, 0x85, 0x67, 0x82, 0x42, 0x3f, 0xee, 0x6c, 0x1f, 0x1d, 0xa4, 0xce, 0xaa, 0xc4,
	0xa2, 0x8e, 0x54, 0x3e, 0x4e, 0x56, 0x25, 0x68, 0xfa, 0xdc, 0x40, 0x3a, 0x39, 0x13, 0x7e, 0x2f,
	0xcf, 0x0d, 0xd2, 0xf2, 0x29, 0xcc, 0xbc, 0x3f, 0x05, 0xc9, 0x35, 0xce, 0xf8, 0x35, 0xa2, 0x91,
	0x1a, 0xad, 0x5e, 0xd3, 0xab, 0x14, 0xff, 0x0d, 0x60, 0xcc, 0xde, 0x06, 0x83, 0xd6, 0x98, 0xae,
	0x49, 0x48, 0x46, 0xe9, 0xd1, 0xe2, 0x6f, 0xe1, 0xab, 0x2e, 0x1a, 0xfa, 0xe8, 0x1e, 0xfa, 0x05,
	0xc0, 0x32, 0x24, 0x4d, 0xbd, 0x65, 0xed, 0x92, 0x1d, 0x83, 0xa9, 0x44, 0xd3, 0x0d, 0x6b, 0x17,
	0xcf, 0xa4, 0xd7, 0xc4, 0xdb, 0xac, 0x5c, 0xe6, 0x22, 0xd9, 0x7e, 0x93, 0xb7, 0xb8, 0x50, 0x2e,
	0x09, 0x4b, 0xb0, 0x04, 0x09, 0xd2, 0x32, 0x2d, 0x83, 0xd4, 0x19, 0xa1, 0xc4, 0xb4, 0xf0, 0xb9,
	0xf4, 0x9a, 0xc9, 0x88, 0x7c, 0x83, 0xa8, 0x6c, 0x87, 0xa9, 0xb3, 0xf2, 0x9a, 0x2b, 0x95, 0x37,
	0x88, 0x69, 0xb9, 0xb0, 0x02, 0x8c, 0xa9, 0x54, 0x13, 0x02, 0xad, 0xca, 0x08, 0x7e, 0xa1, 0x0f,
	0xb5, 0x6e, 0x0b, 0xe5, 0xab, 0x5c, 0xea, 0x82, 0x2e, 0x42, 0x8c, 0xbb, 0x20, 0x26, 0x23, 0xf8,
	0xb9, 0x3e, 0x80, 0x30, 0x2e, 0x96, 0x1c, 0xe5, 0x79, 0x18, 0x7d, 0x87, 0x34, 0x89, 0x26, 0x82,
	0x92, 0xfb, 0xb4, 0x37, 0xb9, 0xa4, 0x3f, 0xa0, 0x3d, 0xdd, 0xa0, 0xc4, 0x89, 0xea, 0x58, 0x40,
	0x6f, 0x70, 0xa1, 0x17, 0x56, 0x2f, 0x79, 0x41, 0x9a, 0x17, 0x55, 0x7f, 0xf2, 0x65, 0x57, 0x1a,
	0x08, 0x2d, 0x07, 0x09, 0x95, 0x68, 0xa4, 0xea, 0x39, 0x4b, 0xa5, 0xd7, 0xc5, 0xfb, 0xac, 0x6c,
	0xff, 0xf6, 0xfb, 0xc9, 0x41, 0x62, 0xc7, 0x20, 0x9a, 0x4a, 0x7b, 0x80, 0x8d, 0x96, 0xa1, 0x37,
	0xe9, 0xac, 0xfc, 0x9a, 0x58, 0xef, 0x07, 0xac, 0x02, 0xae, 0x51, 0xa3, 0x41, 0xb4, 0xce, 0x3e,
	0x35, 0x2d, 0x17, 0x75, 0xce, 0x43, 0xbd, 0x6e, 0x0b, 0xe5, 0xef, 0x50, 0xd3, 0xea, 0xc7, 0xce,
	0x02, 0x30, 0x8b, 0xd4, 0x3b, 0x76, 0x0d, 0x3c, 0xe3, 0x61, 0xae, 0xf2, 0xc5, 0xe0, 0xe6, 0x5f,
	0x84, 0xb8, 0xd0, 0xa2, 0x42, 0x05, 0x9f, 0xf5, 0x74, 0x6d, 0x2d, 0xfb, 0xcd, 0x67, 0x57, 0xd3,
	0x8d, 0x7d, 0xd2, 0x11, 0x3b, 0xf2, 0x8c, 0x5f, 0x77, 0x9f, 0x74, 0x02, 0x9b, 0x91, 0x83, 0x44,
	0x53, 0xaf, 0x13, 0xad, 0x7a, 0x3c, 0xdf, 0x1b, 0x62, 0x7d, 0x00, 0x41, 0xe6, 0x3e, 0xad, 0x52,
	0xed, 0x38, 0xa0, 0x2c, 0xd6, 0x8f, 0xef, 0x5c, 0xd2, 0xdc, 0x67, 0xd6, 0x01, 0x35, 0xb8, 0x39,
	0x3b, 0xd5, 0xe7, 0x7d, 0x18, 0x4f, 0x14, 0x4c, 0xf8, 0x05, 0x18, 0x69, 0xed, 0x89, 0x2d, 0xc7,
	0x92, 0xa7, 0x7d, 0xeb, 0x0d, 0xe7, 0x7c, 0xf4, 0x12, 0xe5, 0xac, 0x3b, 0xa4, 0xf4, 0x12, 0x15,
	0x64, 0x07, 0x39, 0x59, 0x84, 0x04, 0x33, 0x0d, 0x42, 0xeb, 0xbd, 0xb2, 0xbb, 0xc6, 0xaa, 0xd5,
	0x3a, 0x15, 0x74, 0xcc, 0xca, 0x57, 0x85, 0xb0, 0x3f, 0x78, 0x05, 0xc6, 0x7e, 0x40, 0x2c, 0x62,
	0xb8, 0xa0, 0x99, 0x20, 0xe8, 0xff, 0xb9, 0xac, 0x1f, 0x33, 0x07, 0xb1, 0x16, 0xa1, 0x76, 0xa2,
	0xa9, 0xa0, 0xfe, 0xad, 0xb5, 0x8d, 0x60, 0x96, 0x0a, 0xc4, 0xb7, 0x0d, 0x72, 0xc0, 0xea, 0x76,
	0xa6, 0x2f, 0xa4, 0x9d, 0xe3, 0xdf, 0xa0, 0x76, 0x37, 0x28, 0x0a, 0x61, 0x30, 0xe9, 0xb3, 0x30,
	0xea, 0x84, 0xd3, 0x32, 0xf1, 0x44, 0xfa, 0x56, 0xb9, 0x77, 0x86, 0x6f, 0x95, 0xe1, 0x59, 0x88,
	0xf2, 0x5d, 0x6f, 0x99, 0xf8, 0xa4, 0x10, 0x89, 0xcd, 0xbe, 0x55, 0x76, 0xc1, 0x32, 0x8c, 0xd8,
	0x62, 0x05, 0x4f, 0x06, 0xe4, 0x8a, 0xab, 0x91, 0x85, 0x71, 0x11, 0x4c, 0xcf, 0xc7, 0x59, 0xa1,
	0x68, 0xc7, 0xd0, 0xf3, 0xe4, 0xb3, 0xc8, 0xf7, 0xa0, 0x67, 0x51, 0x90, 0xef, 0xb7, 0xe8, 0x69,
	0x14, 0xfa, 0x34, 0x0a, 0x8e, 0xc6, 0xc7, 0xff, 0xb8, 0x1f, 0x8e, 0x18, 0x21, 0xe9, 0x95, 0x52,
	0x5c, 0xf4, 0x4e, 0x7b, 0x15, 0x2f, 0xc3, 0xb8, 0x41, 0x4d, 0xbd, 0x65, 0xa8, 0xb4, 0x52, 0x33,
	0xf4, 0x56, 0x53, 0x8a, 0x88, 0x66, 0x3a, 0xc1, 0x7b, 0x29, 0xc7, 0x44, 0x8d, 0x48, 0x12, 0x49,
	0xaf, 0x94, 0x12, 0xae, 0xda, 0xeb, 0x5c, 0x0b, 0x17, 0x21, 0xd2, 0xd6, 0xa8, 0x25, 0x0d, 0xcb,
	0x28, 0x1d, 0x57, 0xd2, 0xd9, 0x41, 0x33, 0x50, 0x34, 0xee, 0xdb, 0x1a, 0xb5, 0xd6, 0x77, 0x75,
	0xa6, 0xd2, 0x9b, 0x9d, 0x26, 0x2d, 0x46, 0xfe, 0x70, 0x0f, 0xa1, 0x92, 0xc0, 0x62, 0x06, 0x60,
	0xb7, 0x71, 0xd5, 0xa0, 0x55, 0x29, 0x2a, 0x2c, 0xcd, 0x0c, 0xb4, 0x74, 0x7d, 0xfb, 0x1d, 0xaa,
	0x5a, 0x25, 0xba, 0x23, 0x6c, 0x9c, 0xff, 0xfd, 0x7b, 0x27, 0xd4, 0xba, 0xde, 0xaa, 0x0a, 0x20,
	0xd5, 0x2c, 0x46, 0xea, 0xe6, 0xc7, 0xf7, 0xd0, 0x78, 0x0c, 0xa5, 0xd1, 0x02, 0x5a, 0x8d, 0xaa,
	0xba, 0xb6, 0xc3, 0x6a, 0xa5, 0x51, 0x61, 0x7d, 0xdd, 0xa0, 0x55, 0xfc, 0x01, 0x82, 0x88, 0x45,
	0x6a, 0xa6, 0x34, 0x22, 0x87, 0xd3, 0x71, 0xa5, 0x98, 0x7d, 0xb2, 0x99, 0x9d, 0xed, 0x9f, 0x3d,
	0xd9, 0x9b, 0xa4, 0x66, 0x6e, 0x68, 0x96, 0xd1, 0x29, 0x2a, 0x9c, 0x9d, 0xd1, 0xbb, 0x28, 0x3a,
	0xc3, 0x69, 0xfd, 0x31, 0x7f, 0x1b, 0xbe, 0x8b, 0x42, 0xc9, 0x34, 0x7f, 0x82, 0xbb, 0x68, 0x64,
	0x6e, 0xd8, 0x08, 0x4b, 0xff, 0x41, 0x47, 0x9f, 0xff, 0x25, 0x1c, 0xfd, 0xe0, 0x1e, 0x0a, 0xc5,
	0x86, 0x4a, 0x22, 0x06, 0xfc, 0x49, 0x08, 0xc6, 0x1a, 0x44, 0xdd, 0x65, 0x9a, 0x3d, 0x0d, 0xa5,
	0x98, 0xa0, 0xfc, 0xd7, 0xa1, 0x07, 0x5d, 0x34, 0x5e, 0xb6, 0x88, 0x56, 0x25, 0x46, 0xb5, 0xf2,
	0x6a, 0xa1, 0xd2, 0x56, 0x9c, 0x89, 0xf6, 0x6f, 0x04, 0x2f, 0x41, 0x9f, 0x08, 0x5f, 0x48, 0x2f,
	0xca, 0xef, 0xca, 0xed, 0xf5, 0x1b, 0xb7, 0x32, 0x72, 0x7e, 0xf1, 0xf5, 0xa2, 0x5c, 0x5a, 0xbb,
	0x36, 0x2b, 0x37, 0x68, 0x95, 0xb5, 0x1a, 0x72, 0x93, 0x1a, 0x3b, 0x3a, 0xef, 0x8a, 0x2a, 0x85,
	0x4b, 0x7e, 0xe8, 0x22, 0x87, 0xbe, 0x98, 0x5e, 0xf1, 0xa0, 0xca, 0x8a, 0x0b, 0xdd, 0x65, 0xb5,
	0xdd, 0x00, 0xf0, 0xb2, 0x1f, 0xb8, 0xc4, 0x81, 0x17, 0xd3, 0xf9, 0x65, 0x0f, 0xb9, 0xb4, 0xec,
	0x22, 0xdb, 0xd4, 0xe8, 0x1c, 0x87, 0xbf, 0x02, 0x49, 0x5f, 0xc8, 0x8a, 0x59, 0x69, 0x17, 0x70,
	0x26, 0x5d, 0x50, 0x7a, 0x51, 0xf7, 0x7c, 0x0f, 0xb4, 0xe0, 0xab, 0x59, 0x87, 0x2f, 0xbe, 0xff,
	0x58, 0x81, 0xd1, 0x2a, 0x33, 0xf7, 0x2a, 0x26, 0x3b, 0xa0, 0xd2, 0xa8, 0x8c, 0xd2, 0x89, 0xe2,
	0xe4, 0x83, 0x2e, 0x0a, 0xad, 0x2c, 0x78, 0x45, 0x3b, 0x17, 0x91, 0xee, 0xfc, 0x2b, 0x5c, 0x8a,
	0x71, 0xbd, 0x32, 0x3b, 0xa0, 0x98, 0x41, 0xd2, 0x64, 0x5a, 0xad, 0x4e, 0x7b, 0xdf, 0x49, 0xd2,
	0x98, 0xa8, 0xb8, 0xff, 0x7b, 0xaa, 0x5a, 0x28, 0x0b, 0x23, 0x57, 0x5d, 0x1b, 0x57, 0x86, 0x4a,
	0x13, 0x66, 0x70, 0x09, 0xeb, 0x80, 0x1b, 0xad, 0xba, 0xc5, 0x9a, 0x01, 0x67, 0x09, 0xe1, 0xec,
	0xe5, 0xa7, 0x2b, 0x3c, 0xc7, 0x8c, 0xdf, 0xdd, 0x89, 0x46, 0xff, 0x22, 0xde, 0x83, 0x29, 0xa2,
	0xaa, 0xb4, 0x4e, 0x0d, 0x62, 0xd1, 0x6a, 0xc5, 0xf9, 0x20, 0x64, 0x5a, 0x4d, 0x9a, 0x12, 0x4e,
	0xb3, 0x83, 0x4f, 0x67, 0x0f, 0xb2, 0xe5, 0x21, 0xec, 0x33, 0xfa, 0xa8, 0x8b, 0x50, 0x69, 0x92,
	0x0c, 0x52, 0xc0, 0x0a, 0x70, 0x52, 0xc9, 0x76, 0x9d, 0x56, 0x25, 0x49, 0x98, 0x3f, 0xd5, 0x67,
	0x7e, 0xa3, 0xd1, 0xb4, 0x3a, 0x57, 0x50, 0xc9, 0xd3, 0xc3, 0x0b, 0x30, 0x42, 0x35, 0x1b, 0x72,
	0xe6, 0x6b, 0x21, 0xae, 0xda, 0xf4, 0x25, 0x18, 0xf5, 0x4e, 0x1a, 0x4e, 0x42, 0x78, 0x8f, 0x76,
	0xec, 0xaf, 0xbc, 0x12, 0x7f, 0xc4, 0xa7, 0x60, 0xb8, 0x4d, 0xea, 0x2d, 0x2a, 0x85, 0xc4, 0x9a,
	0xfd, 0xb2, 0x1a, 0x5a, 0x41, 0xab, 0xe6, 0xa7, 0x5d, 0xa4, 0xc3, 0x8b, 0x20, 0x09, 0x02, 0xe5,
	0xf5, 0x5e, 0x83, 0x90, 0xcf, 0xcb, 0xb7, 0xb7, 0x36, 0x6e, 0xe2, 0xd1, 0xe5, 0xcc, 0x62, 0x26,
	0x9f, 0x59, 0xca, 0x5c, 0x82, 0x33, 0x30, 0xb1, 0xa5, 0x57, 0xa9, 0x7c, 0x83, 0x0f, 0x31, 0xc3,
	0x62, 0xd4, 0xc4, 0xd1, 0x95, 0xcc, 0x4b, 0x99, 0x7c, 0x1e, 0xa6, 0x20, 0xb9, 0xce, 0x5b, 0x8c,
	0xec, 0x4b, 0x3d, 0xa4, 0x28, 0x70, 0x12, 0x12, 0xf6, 0xfa, 0xba, 0xae, 0x69, 0x54, 0xb5, 0x70,
	0x48, 0x29, 0x14, 0x67, 0x60, 0xd4, 0xfb, 0xb4, 0xc5, 0x93, 0xf7, 0xbb, 0x68, 0xec, 0xb0, 0x8b,
	0xe2, 0x47, 0x5d, 0x34, 0x9c, 0x57, 0x32, 0xf9, 0xc2, 0x97, 0x5d, 0x84, 0x8a, 0x59, 0x38, 0xe3,
	0xf4, 0x2c, 0x1b, 0x58, 0x21, 0x96, 0x45, 0xd4, 0xdd, 0x06, 0xd5, 0x2c, 0x13, 0x9f, 0xb8, 0xdf,
	0x45, 0xd2, 0x61, 0x17, 0x9d, 0xe6, 0x18, 0x65, 0x31, 0xa3, 0x2c, 0x6d, 0x46, 0x62, 0x90, 0x8c,
	0x6f, 0x46, 0x62, 0xf1, 0xe4, 0xd8, 0x66, 0x24, 0x76, 0x3a, 0x29, 0xcd, 0xec, 0xc3, 0xa9, 0x41,
	0x25, 0x88, 0x2b, 0x30, 0xaa, 0xe9, 0x55, 0x5a, 0xa9, 0x33, 0xd3, 0x12, 0x24, 0x3d, 0x6d, 0x4d,
	0x3b, 0xfd, 0x8d, 0x53, 0xf1, 0x26, 0x33, 0x2d, 0x67, 0xff, 0x63, 0x9a, 0xf3, 0x3e, 0xd3, 0x81,
	0xa9, 0xc1, 0xe5, 0xf8, 0xbf, 0x77, 0xfd, 0x53, 0xe4, 0x24, 0xdd, 0xa7, 0x88, 0xeb, 0x41, 0xcf,
	0xbc, 0xa9, 0xaf, 0x7c, 0x5b, 0xcf, 0xc5, 0x49, 0xd1, 0x33, 0x3e, 0x42, 0xe1, 0xe4, 0x1d, 0x24,
	0xfa, 0xf8, 0x47, 0x28, 0x24, 0xf9, 0xc3, 0xf8, 0x53, 0x38, 0x78, 0x0d, 0xe1, 0x28, 0x7c, 0x01,
	0x22, 0xa2, 0x7b, 0xdb, 0xb7, 0x8f, 0x93, 0x0f, 0xba, 0x68, 0x64, 0x5d, 0xd7, 0x2c, 0x43, 0xaf,
	0xf3, 0x36, 0xf4, 0xe1, 0x27, 0x7c, 0xce, 0x89, 0x8a, 0x98, 0x83, 0xd8, 0xae, 0x6e, 0x5a, 0x1a,
	0x69, 0x38, 0x05, 0x5b, 0x1c, 0xe7, 0x52, 0xe1, 0xc9, 0x08, 0x4b, 0x77, 0x22, 0x25, 0x4f, 0x8e,
	0x73, 0x10, 0xb3, 0x67, 0x22, 0x39, 0x90, 0xc2, 0x42, 0xf7, 0x94, 0xdb, 0xd4, 0xe2, 0xc6, 0x68,
	0x09, 0xe5, 0x4b, 0x48, 0x29, 0xa1, 0x42, 0x69, 0x44, 0x68, 0xad, 0x1d, 0xe0, 0xf7, 0x11, 0x8c,
	0x7b, 0x5d, 0xc6, 0xa6, 0x23, 0xf2, 0x2d, 0x66, 0xdc, 0x75, 0x43, 0xdd, 0xa5, 0xfc, 0x6a, 0x63,
	0xd1, 0xaa, 0xb7, 0xbf, 0xc5, 0x94, 0xcb, 0x46, 0x32, 0xe4, 0x3e, 0xc5, 0xfc, 0x0c, 0x25, 0x3c,
	0xcf, 0x9c, 0xa6, 0xd5, 0x9f, 0xa3, 0x4f, 0xbb, 0x88, 0x1f, 0xab, 0xa4, 0x38, 0x56, 0x57, 0x35,
	0xd1, 0xc8, 0xf9, 0xb5, 0x10, 0x0f, 0xe7, 0x33, 0x4a, 0xa6, 0x00, 0xd3, 0x30, 0xe9, 0x59, 0x0f,
	0xc8, 0xd1, 0xe2, 0xdf, 0xbb, 0x68, 0x0b, 0xa6, 0x20, 0x76, 0xc5, 0xa1, 0x62, 0x1a, 0x7a, 0xb4,
	0xc1, 0x39, 0x98, 0x5a, 0x6b, 0x13, 0x56, 0x27, 0xdb, 0xac, 0xce, 0xac, 0x8e, 0xfc, 0x96, 0xae,
	0x51, 0x39, 0xbd, 0xf6, 0xd6, 0x2c, 0xd7, 0x72, 0x09, 0x83, 0x71, 0x88, 0xf0, 0x06, 0x36, 0x1d,
	0xb5, 0x77, 0x66, 0xe6, 0x61, 0x14, 0xa6, 0x1f, 0x9f, 0x1d, 0x7e, 0x1b, 0xa2, 0x66, 0x6b, 0x9b,
	0x7f, 0xc5, 0xd8, 0xa5, 0x7b, 0xf9, 0xe9, 0x26, 0x81, 0x80, 0x1e, 0xfb, 0xb4, 0x71, 0x4c, 0xe2,
	0x32, 0x8c, 0xbb, 0x37, 0x73, 0xfb, 0x66, 0x2c, 0xb6, 0x3e, 0xae, 0x9c, 0x1f, 0xe8, 0xc4, 0xe9,
	0x32, 0x65, 0x5a, 0xa7, 0xaa, 0xe5, 0xb3, 0x96, 0x70, 0x6c, 0x5c, 0x17, 0x26, 0x70, 0x16, 0xc2,
	0x0d, 0xab, 0x25, 0x0a, 0x23, 0x51, 0x3c, 0xfb, 0xa0, 0x8b, 0x22, 0xf9, 0xa5, 0x85, 0x05, 0xbe,
	0x21, 0x13, 0x73, 0x89, 0x62, 0x7c, 0x21, 0xb3, 0x94, 0x57, 0xe6, 0xf3, 0xcb, 0x85, 0x95, 0xc5,
	0x12, 0x57, 0xc4, 0x2d, 0xc8, 0xd8, 0x8d, 0x49, 0xb7, 0x63, 0x77, 0x7a, 0x0f, 0x6b, 0x33, 0xab,
	0xd3, 0x9b, 0x4d, 0x15, 0xaf, 0xa1, 0x0f, 0x7f, 0x4d, 0x77, 0x1e, 0x2a, 0x5d, 0xe0, 0x36, 0x6e,
	0xea, 0x65, 0x66, 0xd1, 0x75, 0x9f, 0x21, 0x8f, 0xd0, 0x57, 0xdd, 0x7e, 0x6f, 0xc2, 0xc5, 0x27,
	0x71, 0xeb, 0xce, 0x84, 0xe8, 0xd7, 0x7a, 0x3d, 0xff, 0x0d, 0x5e, 0x37, 0x6c, 0x2b, 0xab, 0x7f,
	0x0c, 0x7d, 0xda, 0x45, 0x2b, 0x70, 0x1a, 0xb0, 0xbd, 0x33, 0xc1, 0xf2, 0xca, 0xc3, 0xb3, 0x70,
	0xaa, 0x57, 0x7a, 0xbe, 0x8e, 0x3f, 0xac, 0x64, 0x0a, 0x19, 0x5e, 0x7d, 0x8f, 0x10, 0x6c, 0xc1,
	0x98, 0x03, 0xbe, 0xcd, 0x27, 0x8a, 0xf2, 0x32, 0x48, 0xf6, 0x76, 0x66, 0xed, 0x9f, 0x4a, 0x93,
	0x18, 0xa4, 0x91, 0x65, 0xcd, 0xf6, 0x22, 0xcc, 0x38, 0x12, 0xfa, 0x2e, 0x33, 0x2d, 0xa6, 0xd5,
	0x2a, 0x41, 0x4d, 0x51, 0xb6, 0xbf, 0x41, 0x30, 0x71, 0x9b, 0x19, 0x56, 0x8b, 0xd4, 0xdd, 0x41,
	0x32, 0xf7, 0x3e, 0x82, 0x9f, 0x21, 0x48, 0xc3, 0xf3, 0xc1, 0xf2, 0xc8, 0x0a, 0xa6, 0xea, 0xba,
	0x4a, 0xea, 0xee, 0x04, 0x57, 0xc2, 0xe5, 0x37, 0xaf, 0x43, 0x0e, 0xd2, 0x8f, 0xd7, 0x64, 0x9a,
	0xc9, 0xaa, 0xd4, 0x0f, 0xb8, 0x0a, 0xb3, 0x90, 0xea, 0x07, 0xd0, 0x1a, 0x9f, 0x33, 0x9e, 0xda,
	0x48, 0xd9, 0x5e, 0x28, 0x5e, 0x86, 0xb9, 0x27, 0xd9, 0x28, 0x55, 0x14, 0x39, 0x9e, 0xb8, 0xdf,
	0x45, 0xc3, 0x87, 0x5d, 0x14, 0x39, 0xea, 0xa2, 0xf0, 0x52, 0x66, 0x79, 0x33, 0x12, 0x8b, 0x24,
	0x87, 0x67, 0x7e, 0x19, 0x82, 0xc9, 0x81, 0x27, 0x02, 0x37, 0x60, 0xcc, 0xcf, 0x9b, 0x73, 0x02,
	0x9e, 0x78, 0x42, 0x88, 0x41, 0x6b, 0x1b, 0xbd, 0xc1, 0xf1, 0xe2, 0x5c, 0x80, 0x68, 0x3f, 0x1f,
	0xa0, 0x50, 0x12, 0x5d, 0x19, 0x2a, 0xc5, 0xcd, 0x9e, 0x18, 0x6b, 0x30, 0xd1, 0xb7, 0x19, 0xe2,
	0xa4, 0xc4, 0x95, 0x4b, 0xdf, 0xe2, 0x60, 0x0f, 0x70, 0x36, 0xee, 0x5a, 0xb7, 0x35, 0x8a, 0x67,
	0x20, 0xea, 0x63, 0x26, 0x74, 0xd8, 0x45, 0x88, 0x33, 0xa3, 0x64, 0x0a, 0x9b, 0x91, 0x18, 0x4a,
	0x86, 0x66, 0x7e, 0x12, 0x82, 0x53, 0x83, 0x92, 0xc0, 0x65, 0x88, 0xf8, 0xa6, 0xc1, 0xe5, 0xbe,
	0xbb, 0x16, 0x7f, 0x9c, 0x35, 0x2e, 0x28, 0x2f, 0x7e, 0x3f, 0x6d, 0xa7, 0x31, 0x3f, 0x9b, 0x7e,
	0x9b, 0xcc, 0x1f, 0x2c, 0xcc, 0xbf, 0xf4, 0xbd, 0x1f, 0xae, 0xbc, 0xf7, 0x23, 0xef, 0x39, 0x7f,
	0xe9, 0xbd, 0xd9, 0x73, 0x57, 0x86, 0x4a, 0xc2, 0x18, 0x5e, 0x85, 0x31, 0xd2, 0xb2, 0xf4, 0x1a,
	0xd5, 0xc4, 0x47, 0x9b, 0x93, 0xfb, 0xe3, 0x8e, 0x55, 0x40, 0x17, 0x67, 0x20, 0xc2, 0x8b, 0xda,
	0xb9, 0xfc, 0x49, 0x6e, 0x40, 0xc3, 0x46, 0xf8, 0x2b, 0x6f, 0x50, 0xfd, 0x2a, 0x74, 0xb6, 0x24,
	0xb4, 0x56, 0xa3, 0xff, 0x7c, 0x39, 0x9c, 0xcf, 0x28, 0xc5, 0x14, 0xc4, 0xb9, 0x67, 0x7f, 0x7d,
	0x84, 0x5d, 0x16, 0x0a, 0x19, 0xc5, 0x61, 0xe1, 0xcf, 0x08, 0x26, 0xfa, 0x88, 0xc5, 0x59, 0x88,
	0xfb, 0xce, 0x89, 0x33, 0x42, 0x13, 0xae, 0x5b, 0xfb, 0x9b, 0x1f, 0x6c, 0x8d, 0x2d, 0x9e, 0xdb,
	0x6b, 0x70, 0x92, 0x5f, 0x19, 0x2b, 0x03, 0xee, 0xaa, 0x8f, 0x4f, 0xf1, 0x04, 0x87, 0x94, 0xfc,
	0xd7, 0x56, 0x11, 0x79, 0x21, 0x93, 0x2f, 0x9e, 0x87, 0xc9, 0xa0, 0x29, 0x37, 0x87, 0xc4, 0xfd,
	0x2e, 0x8a, 0x1c, 0x76, 0x51, 0xf8, 0xa8, 0x8b, 0xd0, 0xe2, 0x66, 0x24, 0x16, 0x4e, 0x46, 0x8a,
	0x77, 0xd1, 0xe1, 0x17, 0xa9, 0xa1, 0xcf, 0xbe, 0x48, 0x0d, 0x3d, 0xfa, 0x22, 0x85, 0xee, 0x1c,
	0xa5, 0xd0, 0xef, 0x8e, 0x52, 0xe8, 0xaf, 0x47, 0x29, 0x74, 0x78, 0x94, 0x42, 0x9f, 0x1d, 0xa5,
	0xd0, 0xe7, 0x47, 0x29, 0xf4, 0xe5, 0x51, 0x6a, 0xe8, 0xd1, 0x51, 0x0a, 0x7d, 0xf8, 0x30, 0x35,
	0x74, 0xff, 0x61, 0x0a, 0x1d, 0x3e, 0x4c, 0x0d, 0x7d, 0xf6, 0x30, 0x35, 0xf4, 0xd6, 0x77, 0x6b,
	0x7a, 0x73, 0xaf, 0x96, 0x6d, 0xeb, 0x75, 0x8b, 0x1a, 0x06, 0xc9, 0xb6, 0xcc, 0x9c, 0x78, 0xe0,
	0xed, 0x69, 0xbe, 0x69, 0xe8, 0x6d, 0x56, 0xa5, 0xc6, 0xbc, 0x2b, 0xce, 0x35, 0xb7, 0x6b, 0x7a,
	0x8e, 0xbe, 0x6b, 0x39, 0x7f, 0x8a, 0x7e, 0xc3, 0x1f, 0xd2, 0xdb, 0x51, 0xf1, 0x4f, 0x69, 0xe1,
	0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x95, 0x1d, 0x53, 0xc1, 0x16, 0x00, 0x00,
}

func (this *AzureManagedMode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureManagedMode)
	if !ok {
		that2, ok := that.(AzureManagedMode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzureRegion != that1.AzureRegion {
		return false
	}
	if this.ResourceGroup != that1.ResourceGroup {
		return false
	}
	if !this.Vnet.Equal(that1.Vnet) {
		return false
	}
	if !this.AzureCred.Equal(that1.AzureCred) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.MachineType != that1.MachineType {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	if that1.SiteType == nil {
		if this.SiteType != nil {
			return false
		}
	} else if this.SiteType == nil {
		return false
	} else if !this.SiteType.Equal(that1.SiteType) {
		return false
	}
	if !this.AcceleratedNetworking.Equal(that1.AcceleratedNetworking) {
		return false
	}
	if that1.CloudConnectAttachments == nil {
		if this.CloudConnectAttachments != nil {
			return false
		}
	} else if this.CloudConnectAttachments == nil {
		return false
	} else if !this.CloudConnectAttachments.Equal(that1.CloudConnectAttachments) {
		return false
	}
	return true
}
func (this *AzureManagedMode_SingleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureManagedMode_SingleInterface)
	if !ok {
		that2, ok := that.(AzureManagedMode_SingleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SingleInterface.Equal(that1.SingleInterface) {
		return false
	}
	return true
}
func (this *AzureManagedMode_MultipleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureManagedMode_MultipleInterface)
	if !ok {
		that2, ok := that.(AzureManagedMode_MultipleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MultipleInterface.Equal(that1.MultipleInterface) {
		return false
	}
	return true
}
func (this *AzureManagedMode_Disabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureManagedMode_Disabled)
	if !ok {
		that2, ok := that.(AzureManagedMode_Disabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disabled.Equal(that1.Disabled) {
		return false
	}
	return true
}
func (this *AzureManagedMode_Enabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureManagedMode_Enabled)
	if !ok {
		that2, ok := that.(AzureManagedMode_Enabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Enabled.Equal(that1.Enabled) {
		return false
	}
	return true
}
func (this *AzureSingleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSingleInterface)
	if !ok {
		that2, ok := that.(AzureSingleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeList.Equal(that1.NodeList) {
		return false
	}
	return true
}
func (this *AzureMultipleInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureMultipleInterface)
	if !ok {
		that2, ok := that.(AzureMultipleInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeList.Equal(that1.NodeList) {
		return false
	}
	return true
}
func (this *AzureManagedNodeList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureManagedNodeList)
	if !ok {
		that2, ok := that.(AzureManagedNodeList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.NodeList) != len(that1.NodeList) {
		return false
	}
	for i := range this.NodeList {
		if !this.NodeList[i].Equal(that1.NodeList[i]) {
			return false
		}
	}
	return true
}
func (this *AzureManagedNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureManagedNode)
	if !ok {
		that2, ok := that.(AzureManagedNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.AzureAz != that1.AzureAz {
		return false
	}
	if len(this.InterfaceList) != len(that1.InterfaceList) {
		return false
	}
	for i := range this.InterfaceList {
		if !this.InterfaceList[i].Equal(that1.InterfaceList[i]) {
			return false
		}
	}
	return true
}
func (this *AzureOrchestratedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureOrchestratedInterface)
	if !ok {
		that2, ok := that.(AzureOrchestratedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	if !this.NetworkOption.Equal(that1.NetworkOption) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if that1.SiteToSiteConnectivityInterfaceChoice == nil {
		if this.SiteToSiteConnectivityInterfaceChoice != nil {
			return false
		}
	} else if this.SiteToSiteConnectivityInterfaceChoice == nil {
		return false
	} else if !this.SiteToSiteConnectivityInterfaceChoice.Equal(that1.SiteToSiteConnectivityInterfaceChoice) {
		return false
	}
	return true
}
func (this *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled)
	if !ok {
		that2, ok := that.(AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteToSiteConnectivityInterfaceDisabled.Equal(that1.SiteToSiteConnectivityInterfaceDisabled) {
		return false
	}
	return true
}
func (this *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled)
	if !ok {
		that2, ok := that.(AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteToSiteConnectivityInterfaceEnabled.Equal(that1.SiteToSiteConnectivityInterfaceEnabled) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType_SubnetParam)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType_ExistingSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType_ExistingSubnet)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType_ExistingSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingSubnet.Equal(that1.ExistingSubnet) {
		return false
	}
	return true
}
func (this *CloudSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetParamType)
	if !ok {
		that2, ok := that.(CloudSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NameChoice == nil {
		if this.NameChoice != nil {
			return false
		}
	} else if this.NameChoice == nil {
		return false
	} else if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	if this.Ipv4 != that1.Ipv4 {
		return false
	}
	return true
}
func (this *CloudSubnetParamType_Name) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetParamType_Name)
	if !ok {
		that2, ok := that.(CloudSubnetParamType_Name)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *CloudSubnetParamType_Autogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetParamType_Autogenerate)
	if !ok {
		that2, ok := that.(CloudSubnetParamType_Autogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Autogenerate.Equal(that1.Autogenerate) {
		return false
	}
	return true
}
func (this *AzureSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType)
	if !ok {
		that2, ok := that.(AzureSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	if that1.ResourceGroupChoice == nil {
		if this.ResourceGroupChoice != nil {
			return false
		}
	} else if this.ResourceGroupChoice == nil {
		return false
	} else if !this.ResourceGroupChoice.Equal(that1.ResourceGroupChoice) {
		return false
	}
	return true
}
func (this *AzureSubnetType_VnetResourceGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType_VnetResourceGroup)
	if !ok {
		that2, ok := that.(AzureSubnetType_VnetResourceGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VnetResourceGroup.Equal(that1.VnetResourceGroup) {
		return false
	}
	return true
}
func (this *AzureManagedMode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&securemesh_site_v2.AzureManagedMode{")
	s = append(s, "AzureRegion: "+fmt.Sprintf("%#v", this.AzureRegion)+",\n")
	s = append(s, "ResourceGroup: "+fmt.Sprintf("%#v", this.ResourceGroup)+",\n")
	if this.Vnet != nil {
		s = append(s, "Vnet: "+fmt.Sprintf("%#v", this.Vnet)+",\n")
	}
	if this.AzureCred != nil {
		s = append(s, "AzureCred: "+fmt.Sprintf("%#v", this.AzureCred)+",\n")
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "MachineType: "+fmt.Sprintf("%#v", this.MachineType)+",\n")
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	if this.SiteType != nil {
		s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	}
	if this.AcceleratedNetworking != nil {
		s = append(s, "AcceleratedNetworking: "+fmt.Sprintf("%#v", this.AcceleratedNetworking)+",\n")
	}
	if this.CloudConnectAttachments != nil {
		s = append(s, "CloudConnectAttachments: "+fmt.Sprintf("%#v", this.CloudConnectAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureManagedMode_SingleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AzureManagedMode_SingleInterface{` +
		`SingleInterface:` + fmt.Sprintf("%#v", this.SingleInterface) + `}`}, ", ")
	return s
}
func (this *AzureManagedMode_MultipleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AzureManagedMode_MultipleInterface{` +
		`MultipleInterface:` + fmt.Sprintf("%#v", this.MultipleInterface) + `}`}, ", ")
	return s
}
func (this *AzureManagedMode_Disabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AzureManagedMode_Disabled{` +
		`Disabled:` + fmt.Sprintf("%#v", this.Disabled) + `}`}, ", ")
	return s
}
func (this *AzureManagedMode_Enabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AzureManagedMode_Enabled{` +
		`Enabled:` + fmt.Sprintf("%#v", this.Enabled) + `}`}, ", ")
	return s
}
func (this *AzureSingleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&securemesh_site_v2.AzureSingleInterface{")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureMultipleInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&securemesh_site_v2.AzureMultipleInterface{")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureManagedNodeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&securemesh_site_v2.AzureManagedNodeList{")
	if this.NodeList != nil {
		s = append(s, "NodeList: "+fmt.Sprintf("%#v", this.NodeList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureManagedNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&securemesh_site_v2.AzureManagedNode{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "AzureAz: "+fmt.Sprintf("%#v", this.AzureAz)+",\n")
	if this.InterfaceList != nil {
		s = append(s, "InterfaceList: "+fmt.Sprintf("%#v", this.InterfaceList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureOrchestratedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&securemesh_site_v2.AzureOrchestratedInterface{")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	if this.NetworkOption != nil {
		s = append(s, "NetworkOption: "+fmt.Sprintf("%#v", this.NetworkOption)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	if this.SiteToSiteConnectivityInterfaceChoice != nil {
		s = append(s, "SiteToSiteConnectivityInterfaceChoice: "+fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled{` +
		`SiteToSiteConnectivityInterfaceDisabled:` + fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceDisabled) + `}`}, ", ")
	return s
}
func (this *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled{` +
		`SiteToSiteConnectivityInterfaceEnabled:` + fmt.Sprintf("%#v", this.SiteToSiteConnectivityInterfaceEnabled) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&securemesh_site_v2.AzureSubnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetChoiceType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AzureSubnetChoiceType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceType_ExistingSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AzureSubnetChoiceType_ExistingSubnet{` +
		`ExistingSubnet:` + fmt.Sprintf("%#v", this.ExistingSubnet) + `}`}, ", ")
	return s
}
func (this *CloudSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&securemesh_site_v2.CloudSubnetParamType{")
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "Ipv4: "+fmt.Sprintf("%#v", this.Ipv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudSubnetParamType_Name) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.CloudSubnetParamType_Name{` +
		`Name:` + fmt.Sprintf("%#v", this.Name) + `}`}, ", ")
	return s
}
func (this *CloudSubnetParamType_Autogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.CloudSubnetParamType_Autogenerate{` +
		`Autogenerate:` + fmt.Sprintf("%#v", this.Autogenerate) + `}`}, ", ")
	return s
}
func (this *AzureSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&securemesh_site_v2.AzureSubnetType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	if this.ResourceGroupChoice != nil {
		s = append(s, "ResourceGroupChoice: "+fmt.Sprintf("%#v", this.ResourceGroupChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetType_VnetResourceGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&securemesh_site_v2.AzureSubnetType_VnetResourceGroup{` +
		`VnetResourceGroup:` + fmt.Sprintf("%#v", this.VnetResourceGroup) + `}`}, ", ")
	return s
}
func valueToGoStringAzureTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AzureManagedMode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureManagedMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureManagedMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudConnectAttachments != nil {
		{
			size := m.CloudConnectAttachments.Size()
			i -= size
			if _, err := m.CloudConnectAttachments.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AcceleratedNetworking != nil {
		{
			size, err := m.AcceleratedNetworking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.SiteType != nil {
		{
			size := m.SiteType.Size()
			i -= size
			if _, err := m.SiteType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DiskSize != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.DiskSize))
		i--
		dAtA[i] = 0x48
	}
	if len(m.MachineType) > 0 {
		i -= len(m.MachineType)
		copy(dAtA[i:], m.MachineType)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.MachineType)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAzureTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintAzureTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAzureTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.AzureCred != nil {
		{
			size, err := m.AzureCred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Vnet != nil {
		{
			size, err := m.Vnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ResourceGroup) > 0 {
		i -= len(m.ResourceGroup)
		copy(dAtA[i:], m.ResourceGroup)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.ResourceGroup)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AzureRegion) > 0 {
		i -= len(m.AzureRegion)
		copy(dAtA[i:], m.AzureRegion)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AzureRegion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureManagedMode_SingleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureManagedMode_SingleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SingleInterface != nil {
		{
			size, err := m.SingleInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *AzureManagedMode_MultipleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureManagedMode_MultipleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultipleInterface != nil {
		{
			size, err := m.MultipleInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *AzureManagedMode_Disabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureManagedMode_Disabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disabled != nil {
		{
			size, err := m.Disabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *AzureManagedMode_Enabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureManagedMode_Enabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Enabled != nil {
		{
			size, err := m.Enabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *AzureSingleInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSingleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSingleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeList != nil {
		{
			size, err := m.NodeList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureMultipleInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureMultipleInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureMultipleInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeList != nil {
		{
			size, err := m.NodeList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureManagedNodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureManagedNodeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureManagedNodeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeList) > 0 {
		for iNdEx := len(m.NodeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureManagedNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureManagedNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureManagedNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceList) > 0 {
		for iNdEx := len(m.InterfaceList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterfaceList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AzureAz) > 0 {
		i -= len(m.AzureAz)
		copy(dAtA[i:], m.AzureAz)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AzureAz)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureOrchestratedInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureOrchestratedInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureOrchestratedInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceChoice != nil {
		{
			size := m.SiteToSiteConnectivityInterfaceChoice.Size()
			i -= size
			if _, err := m.SiteToSiteConnectivityInterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Mtu != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x18
	}
	if m.NetworkOption != nil {
		{
			size, err := m.NetworkOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteToSiteConnectivityInterfaceDisabled != nil {
		{
			size, err := m.SiteToSiteConnectivityInterfaceDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteToSiteConnectivityInterfaceEnabled != nil {
		{
			size, err := m.SiteToSiteConnectivityInterfaceEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AzureSubnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetChoiceType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceType_SubnetParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AzureSubnetChoiceType_ExistingSubnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceType_ExistingSubnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExistingSubnet != nil {
		{
			size, err := m.ExistingSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CloudSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudSubnetParamType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv4) > 0 {
		i -= len(m.Ipv4)
		copy(dAtA[i:], m.Ipv4)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Ipv4)))
		i--
		dAtA[i] = 0x22
	}
	if m.NameChoice != nil {
		{
			size := m.NameChoice.Size()
			i -= size
			if _, err := m.NameChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudSubnetParamType_Name) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudSubnetParamType_Name) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CloudSubnetParamType_Autogenerate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudSubnetParamType_Autogenerate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Autogenerate != nil {
		{
			size, err := m.Autogenerate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AzureSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceGroupChoice != nil {
		{
			size := m.ResourceGroupChoice.Size()
			i -= size
			if _, err := m.ResourceGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SubnetName) > 0 {
		i -= len(m.SubnetName)
		copy(dAtA[i:], m.SubnetName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.SubnetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetType_VnetResourceGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetType_VnetResourceGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VnetResourceGroup != nil {
		{
			size, err := m.VnetResourceGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func encodeVarintAzureTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovAzureTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AzureManagedMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AzureRegion)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Vnet != nil {
		l = m.Vnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.AzureCred != nil {
		l = m.AzureCred.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAzureTypes(uint64(len(k))) + 1 + len(v) + sovAzureTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAzureTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.MachineType)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovAzureTypes(uint64(m.DiskSize))
	}
	if m.SiteType != nil {
		n += m.SiteType.Size()
	}
	if m.AcceleratedNetworking != nil {
		l = m.AcceleratedNetworking.Size()
		n += 2 + l + sovAzureTypes(uint64(l))
	}
	if m.CloudConnectAttachments != nil {
		n += m.CloudConnectAttachments.Size()
	}
	return n
}

func (m *AzureManagedMode_SingleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SingleInterface != nil {
		l = m.SingleInterface.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}
func (m *AzureManagedMode_MultipleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultipleInterface != nil {
		l = m.MultipleInterface.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}
func (m *AzureManagedMode_Disabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled != nil {
		l = m.Disabled.Size()
		n += 2 + l + sovAzureTypes(uint64(l))
	}
	return n
}
func (m *AzureManagedMode_Enabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 2 + l + sovAzureTypes(uint64(l))
	}
	return n
}
func (m *AzureSingleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeList != nil {
		l = m.NodeList.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureMultipleInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeList != nil {
		l = m.NodeList.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureManagedNodeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeList) > 0 {
		for _, e := range m.NodeList {
			l = e.Size()
			n += 1 + l + sovAzureTypes(uint64(l))
		}
	}
	return n
}

func (m *AzureManagedNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.AzureAz)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if len(m.InterfaceList) > 0 {
		for _, e := range m.InterfaceList {
			l = e.Size()
			n += 1 + l + sovAzureTypes(uint64(l))
		}
	}
	return n
}

func (m *AzureOrchestratedInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.NetworkOption != nil {
		l = m.NetworkOption.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Mtu != 0 {
		n += 1 + sovAzureTypes(uint64(m.Mtu))
	}
	if m.SiteToSiteConnectivityInterfaceChoice != nil {
		n += m.SiteToSiteConnectivityInterfaceChoice.Size()
	}
	return n
}

func (m *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceDisabled != nil {
		l = m.SiteToSiteConnectivityInterfaceDisabled.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}
func (m *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteToSiteConnectivityInterfaceEnabled != nil {
		l = m.SiteToSiteConnectivityInterfaceEnabled.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AzureSubnetChoiceType_SubnetParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceType_ExistingSubnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExistingSubnet != nil {
		l = m.ExistingSubnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}
func (m *CloudSubnetParamType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NameChoice != nil {
		n += m.NameChoice.Size()
	}
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *CloudSubnetParamType_Name) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovAzureTypes(uint64(l))
	return n
}
func (m *CloudSubnetParamType_Autogenerate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Autogenerate != nil {
		l = m.Autogenerate.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.ResourceGroupChoice != nil {
		n += m.ResourceGroupChoice.Size()
	}
	return n
}

func (m *AzureSubnetType_VnetResourceGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VnetResourceGroup != nil {
		l = m.VnetResourceGroup.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func sovAzureTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAzureTypes(x uint64) (n int) {
	return sovAzureTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AzureManagedMode) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AzureManagedMode{`,
		`AzureRegion:` + fmt.Sprintf("%v", this.AzureRegion) + `,`,
		`ResourceGroup:` + fmt.Sprintf("%v", this.ResourceGroup) + `,`,
		`Vnet:` + strings.Replace(fmt.Sprintf("%v", this.Vnet), "AzureVnetChoiceType", "views.AzureVnetChoiceType", 1) + `,`,
		`AzureCred:` + strings.Replace(fmt.Sprintf("%v", this.AzureCred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`MachineType:` + fmt.Sprintf("%v", this.MachineType) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`AcceleratedNetworking:` + strings.Replace(fmt.Sprintf("%v", this.AcceleratedNetworking), "AcceleratedNetworkingType", "views.AcceleratedNetworkingType", 1) + `,`,
		`CloudConnectAttachments:` + fmt.Sprintf("%v", this.CloudConnectAttachments) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureManagedMode_SingleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureManagedMode_SingleInterface{`,
		`SingleInterface:` + strings.Replace(fmt.Sprintf("%v", this.SingleInterface), "AzureSingleInterface", "AzureSingleInterface", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureManagedMode_MultipleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureManagedMode_MultipleInterface{`,
		`MultipleInterface:` + strings.Replace(fmt.Sprintf("%v", this.MultipleInterface), "AzureMultipleInterface", "AzureMultipleInterface", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureManagedMode_Disabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureManagedMode_Disabled{`,
		`Disabled:` + strings.Replace(fmt.Sprintf("%v", this.Disabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureManagedMode_Enabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureManagedMode_Enabled{`,
		`Enabled:` + strings.Replace(fmt.Sprintf("%v", this.Enabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSingleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSingleInterface{`,
		`NodeList:` + strings.Replace(this.NodeList.String(), "AzureManagedNodeList", "AzureManagedNodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureMultipleInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureMultipleInterface{`,
		`NodeList:` + strings.Replace(this.NodeList.String(), "AzureManagedNodeList", "AzureManagedNodeList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureManagedNodeList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodeList := "[]*AzureManagedNode{"
	for _, f := range this.NodeList {
		repeatedStringForNodeList += strings.Replace(f.String(), "AzureManagedNode", "AzureManagedNode", 1) + ","
	}
	repeatedStringForNodeList += "}"
	s := strings.Join([]string{`&AzureManagedNodeList{`,
		`NodeList:` + repeatedStringForNodeList + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureManagedNode) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterfaceList := "[]*AzureOrchestratedInterface{"
	for _, f := range this.InterfaceList {
		repeatedStringForInterfaceList += strings.Replace(f.String(), "AzureOrchestratedInterface", "AzureOrchestratedInterface", 1) + ","
	}
	repeatedStringForInterfaceList += "}"
	s := strings.Join([]string{`&AzureManagedNode{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`AzureAz:` + fmt.Sprintf("%v", this.AzureAz) + `,`,
		`InterfaceList:` + repeatedStringForInterfaceList + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureOrchestratedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureOrchestratedInterface{`,
		`Subnet:` + strings.Replace(this.Subnet.String(), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`NetworkOption:` + strings.Replace(fmt.Sprintf("%v", this.NetworkOption), "NetworkSelectType", "views.NetworkSelectType", 1) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`SiteToSiteConnectivityInterfaceChoice:` + fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled{`,
		`SiteToSiteConnectivityInterfaceDisabled:` + strings.Replace(fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled{`,
		`SiteToSiteConnectivityInterfaceEnabled:` + strings.Replace(fmt.Sprintf("%v", this.SiteToSiteConnectivityInterfaceEnabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "CloudSubnetParamType", "CloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType_ExistingSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType_ExistingSubnet{`,
		`ExistingSubnet:` + strings.Replace(fmt.Sprintf("%v", this.ExistingSubnet), "AzureSubnetType", "AzureSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetParamType{`,
		`NameChoice:` + fmt.Sprintf("%v", this.NameChoice) + `,`,
		`Ipv4:` + fmt.Sprintf("%v", this.Ipv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetParamType_Name) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetParamType_Name{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetParamType_Autogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetParamType_Autogenerate{`,
		`Autogenerate:` + strings.Replace(fmt.Sprintf("%v", this.Autogenerate), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`ResourceGroupChoice:` + fmt.Sprintf("%v", this.ResourceGroupChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType_VnetResourceGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType_VnetResourceGroup{`,
		`VnetResourceGroup:` + strings.Replace(fmt.Sprintf("%v", this.VnetResourceGroup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAzureTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AzureManagedMode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureManagedMode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureManagedMode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vnet == nil {
				m.Vnet = &views.AzureVnetChoiceType{}
			}
			if err := m.Vnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureCred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AzureCred == nil {
				m.AzureCred = &views.ObjectRefType{}
			}
			if err := m.AzureCred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAzureTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAzureTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAzureTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAzureTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAzureTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAzureTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAzureTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAzureTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAzureTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MachineType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureSingleInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteType = &AzureManagedMode_SingleInterface{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureMultipleInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteType = &AzureManagedMode_MultipleInterface{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceleratedNetworking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceleratedNetworking == nil {
				m.AcceleratedNetworking = &views.AcceleratedNetworkingType{}
			}
			if err := m.AcceleratedNetworking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudConnectAttachments = &AzureManagedMode_Disabled{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudConnectAttachments = &AzureManagedMode_Enabled{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSingleInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSingleInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSingleInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeList == nil {
				m.NodeList = &AzureManagedNodeList{}
			}
			if err := m.NodeList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureMultipleInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureMultipleInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureMultipleInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeList == nil {
				m.NodeList = &AzureManagedNodeList{}
			}
			if err := m.NodeList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureManagedNodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureManagedNodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureManagedNodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeList = append(m.NodeList, &AzureManagedNode{})
			if err := m.NodeList[len(m.NodeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureManagedNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureManagedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureManagedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureAz", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureAz = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceList = append(m.InterfaceList, &AzureOrchestratedInterface{})
			if err := m.InterfaceList[len(m.InterfaceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureOrchestratedInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureOrchestratedInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureOrchestratedInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &AzureSubnetChoiceType{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkOption == nil {
				m.NetworkOption = &views.NetworkSelectType{}
			}
			if err := m.NetworkOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteConnectivityInterfaceDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteToSiteConnectivityInterfaceChoice = &AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceDisabled{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteConnectivityInterfaceEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SiteToSiteConnectivityInterfaceChoice = &AzureOrchestratedInterface_SiteToSiteConnectivityInterfaceEnabled{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceType_SubnetParam{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceType_ExistingSubnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameChoice = &CloudSubnetParamType_Name{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NameChoice = &CloudSubnetParamType_Autogenerate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetResourceGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceGroupChoice = &AzureSubnetType_VnetResourceGroup{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAzureTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAzureTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAzureTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAzureTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAzureTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAzureTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAzureTypes = fmt.Errorf("proto: unexpected end of group")
)
