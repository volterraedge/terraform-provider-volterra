// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/common_cdn/types.proto

package common_cdn

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_type"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CDN LoadBalancer Deployment status
//
// x-displayName: "CDN LoadBalancer Deployment status"
// Deployment status
type CDNLoadbalancerDeploymentStatus int32

const (
	// x-displayName: "Created"
	CDN_LB_STATUS_CREATED CDNLoadbalancerDeploymentStatus = 0
	// x-displayName: "Deploying"
	CDN_LB_STATUS_DEPLOYING CDNLoadbalancerDeploymentStatus = 1
	// x-displayName: "Deploy Failed"
	CDN_LB_STATUS_DEPLOY_FAILED CDNLoadbalancerDeploymentStatus = 2
	// x-displayName: "Deployed"
	CDN_LB_STATUS_DEPLOYED CDNLoadbalancerDeploymentStatus = 3
	// x-displayname: "Failed"
	CDN_LB_STATUS_FAILED CDNLoadbalancerDeploymentStatus = 4
)

var CDNLoadbalancerDeploymentStatus_name = map[int32]string{
	0: "CDN_LB_STATUS_CREATED",
	1: "CDN_LB_STATUS_DEPLOYING",
	2: "CDN_LB_STATUS_DEPLOY_FAILED",
	3: "CDN_LB_STATUS_DEPLOYED",
	4: "CDN_LB_STATUS_FAILED",
}

var CDNLoadbalancerDeploymentStatus_value = map[string]int32{
	"CDN_LB_STATUS_CREATED":       0,
	"CDN_LB_STATUS_DEPLOYING":     1,
	"CDN_LB_STATUS_DEPLOY_FAILED": 2,
	"CDN_LB_STATUS_DEPLOYED":      3,
	"CDN_LB_STATUS_FAILED":        4,
}

func (CDNLoadbalancerDeploymentStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{0}
}

// CDNSiteDeploymentStatus
//
// x-displayName: "CDN LoadBalancer Site Deployment status"
type CDNSiteDeploymentStatus int32

const (
	// x-displayName: "Not deployed"
	DEPLOYMENT_STATUS_NOT_DEPLOYED CDNSiteDeploymentStatus = 0
	// x-displayName: "Deploying"
	DEPLOYMENT_STATUS_DEPLOYING CDNSiteDeploymentStatus = 1
	// x-displayName: "Failed"
	DEPLOYMENT_STATUS_DEPLOY_FAILED CDNSiteDeploymentStatus = 2
	// x-displayName: "Deployed"
	DEPLOYMENT_STATUS_DEPLOYED CDNSiteDeploymentStatus = 3
)

var CDNSiteDeploymentStatus_name = map[int32]string{
	0: "DEPLOYMENT_STATUS_NOT_DEPLOYED",
	1: "DEPLOYMENT_STATUS_DEPLOYING",
	2: "DEPLOYMENT_STATUS_DEPLOY_FAILED",
	3: "DEPLOYMENT_STATUS_DEPLOYED",
}

var CDNSiteDeploymentStatus_value = map[string]int32{
	"DEPLOYMENT_STATUS_NOT_DEPLOYED":  0,
	"DEPLOYMENT_STATUS_DEPLOYING":     1,
	"DEPLOYMENT_STATUS_DEPLOY_FAILED": 2,
	"DEPLOYMENT_STATUS_DEPLOYED":      3,
}

func (CDNSiteDeploymentStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{1}
}

// CDN Controller status
//
// x-displayName: "CDN Controller Status"
// CDN Controller Status
type CDNControllerStatus struct {
	// Deployment Status
	//
	// x-displayName: "Deployment Status"
	// Deployment status
	DeploymentStatus CDNLoadbalancerDeploymentStatus `protobuf:"varint,1,opt,name=deployment_status,json=deploymentStatus,proto3,enum=ves.io.schema.views.common_cdn.CDNLoadbalancerDeploymentStatus" json:"deployment_status,omitempty"`
	// Error
	//
	// x-displayName: "Error"
	// Error message
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Cfg Version
	//
	// x-displayName: "Cfg Version"
	// Cfg version
	CfgVersion uint32 `protobuf:"varint,3,opt,name=cfg_version,json=cfgVersion,proto3" json:"cfg_version,omitempty"`
	// CP Version
	//
	// x-displayName: "CP Version"
	// CP version
	CpVersion uint32 `protobuf:"varint,4,opt,name=cp_version,json=cpVersion,proto3" json:"cp_version,omitempty"`
}

func (m *CDNControllerStatus) Reset()      { *m = CDNControllerStatus{} }
func (*CDNControllerStatus) ProtoMessage() {}
func (*CDNControllerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{0}
}
func (m *CDNControllerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNControllerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNControllerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNControllerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNControllerStatus.Merge(m, src)
}
func (m *CDNControllerStatus) XXX_Size() int {
	return m.Size()
}
func (m *CDNControllerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNControllerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CDNControllerStatus proto.InternalMessageInfo

func (m *CDNControllerStatus) GetDeploymentStatus() CDNLoadbalancerDeploymentStatus {
	if m != nil {
		return m.DeploymentStatus
	}
	return CDN_LB_STATUS_CREATED
}

func (m *CDNControllerStatus) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *CDNControllerStatus) GetCfgVersion() uint32 {
	if m != nil {
		return m.CfgVersion
	}
	return 0
}

func (m *CDNControllerStatus) GetCpVersion() uint32 {
	if m != nil {
		return m.CpVersion
	}
	return 0
}

// CDN Site status details
//
// x-displayName: "CDN Site Status"
// This CDN status is per site and it indicates the status of the CDN service for the LB on the site
type CDNSiteStatus struct {
	// Deployment Status
	//
	// x-displayName: "Deployment Status"
	// Indicates the status of deployment on the site
	Status CDNSiteDeploymentStatus `protobuf:"varint,1,opt,name=status,proto3,enum=ves.io.schema.views.common_cdn.CDNSiteDeploymentStatus" json:"status,omitempty"`
	// Site Name
	//
	// x-displayName: "Site"
	// Name of the site that reported this status
	Site string `protobuf:"bytes,2,opt,name=site,proto3" json:"site,omitempty"`
	// Error
	//
	// x-displayName: "Error"
	// Error message (if any)
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *CDNSiteStatus) Reset()      { *m = CDNSiteStatus{} }
func (*CDNSiteStatus) ProtoMessage() {}
func (*CDNSiteStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{1}
}
func (m *CDNSiteStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNSiteStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDNSiteStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDNSiteStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNSiteStatus.Merge(m, src)
}
func (m *CDNSiteStatus) XXX_Size() int {
	return m.Size()
}
func (m *CDNSiteStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNSiteStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CDNSiteStatus proto.InternalMessageInfo

func (m *CDNSiteStatus) GetStatus() CDNSiteDeploymentStatus {
	if m != nil {
		return m.Status
	}
	return DEPLOYMENT_STATUS_NOT_DEPLOYED
}

func (m *CDNSiteStatus) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *CDNSiteStatus) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Cache Purge Request
//
// x-displayName: "Cache Purge"
// CDN Cache Purge
type LilacCDNCachePurgeRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "default"
	// x-required
	// Namespace scope of the metric request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// CDN Distribution Name
	//
	// x-displayName: "Name of the CDN distrubition"
	// x-example: "cdn-1"
	// x-required
	// Format: string
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Purge Timestamp
	//
	// x-displayName: "Purge Time"
	// x-example: "1659758607"
	// Format: unix_timestamp|rfc 3339
	// Purge objects that were created on or before this timestamp
	PurgeEpochTimestamp string `protobuf:"bytes,3,opt,name=purge_epoch_timestamp,json=purgeEpochTimestamp,proto3" json:"purge_epoch_timestamp,omitempty"`
	// Purge Options
	//
	// x-displayName: "Purge Options"
	// x-required
	// Format: string
	// Options to purge cache for a specific distribution
	//
	// Types that are valid to be assigned to PatternType:
	//	*LilacCDNCachePurgeRequest_PurgeAll
	//	*LilacCDNCachePurgeRequest_Url
	//	*LilacCDNCachePurgeRequest_Hostname
	//	*LilacCDNCachePurgeRequest_Pattern
	PatternType isLilacCDNCachePurgeRequest_PatternType `protobuf_oneof:"pattern_type"`
	// Purge Type
	//
	// x-displayName: "Purge Type"
	// x-required
	// Purge type controls how the purge is performed
	//
	// Types that are valid to be assigned to PurgeType:
	//	*LilacCDNCachePurgeRequest_SoftPurge
	//	*LilacCDNCachePurgeRequest_HardPurge
	PurgeType isLilacCDNCachePurgeRequest_PurgeType `protobuf_oneof:"purge_type"`
}

func (m *LilacCDNCachePurgeRequest) Reset()      { *m = LilacCDNCachePurgeRequest{} }
func (*LilacCDNCachePurgeRequest) ProtoMessage() {}
func (*LilacCDNCachePurgeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{2}
}
func (m *LilacCDNCachePurgeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNCachePurgeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LilacCDNCachePurgeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LilacCDNCachePurgeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNCachePurgeRequest.Merge(m, src)
}
func (m *LilacCDNCachePurgeRequest) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNCachePurgeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNCachePurgeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNCachePurgeRequest proto.InternalMessageInfo

type isLilacCDNCachePurgeRequest_PatternType interface {
	isLilacCDNCachePurgeRequest_PatternType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isLilacCDNCachePurgeRequest_PurgeType interface {
	isLilacCDNCachePurgeRequest_PurgeType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LilacCDNCachePurgeRequest_PurgeAll struct {
	PurgeAll *schema.Empty `protobuf:"bytes,9,opt,name=purge_all,json=purgeAll,proto3,oneof" json:"purge_all,omitempty"`
}
type LilacCDNCachePurgeRequest_Url struct {
	Url string `protobuf:"bytes,10,opt,name=url,proto3,oneof" json:"url,omitempty"`
}
type LilacCDNCachePurgeRequest_Hostname struct {
	Hostname string `protobuf:"bytes,11,opt,name=hostname,proto3,oneof" json:"hostname,omitempty"`
}
type LilacCDNCachePurgeRequest_Pattern struct {
	Pattern string `protobuf:"bytes,4,opt,name=pattern,proto3,oneof" json:"pattern,omitempty"`
}
type LilacCDNCachePurgeRequest_SoftPurge struct {
	SoftPurge *schema.Empty `protobuf:"bytes,6,opt,name=soft_purge,json=softPurge,proto3,oneof" json:"soft_purge,omitempty"`
}
type LilacCDNCachePurgeRequest_HardPurge struct {
	HardPurge *schema.Empty `protobuf:"bytes,7,opt,name=hard_purge,json=hardPurge,proto3,oneof" json:"hard_purge,omitempty"`
}

func (*LilacCDNCachePurgeRequest_PurgeAll) isLilacCDNCachePurgeRequest_PatternType() {}
func (*LilacCDNCachePurgeRequest_Url) isLilacCDNCachePurgeRequest_PatternType()      {}
func (*LilacCDNCachePurgeRequest_Hostname) isLilacCDNCachePurgeRequest_PatternType() {}
func (*LilacCDNCachePurgeRequest_Pattern) isLilacCDNCachePurgeRequest_PatternType()  {}
func (*LilacCDNCachePurgeRequest_SoftPurge) isLilacCDNCachePurgeRequest_PurgeType()  {}
func (*LilacCDNCachePurgeRequest_HardPurge) isLilacCDNCachePurgeRequest_PurgeType()  {}

func (m *LilacCDNCachePurgeRequest) GetPatternType() isLilacCDNCachePurgeRequest_PatternType {
	if m != nil {
		return m.PatternType
	}
	return nil
}
func (m *LilacCDNCachePurgeRequest) GetPurgeType() isLilacCDNCachePurgeRequest_PurgeType {
	if m != nil {
		return m.PurgeType
	}
	return nil
}

func (m *LilacCDNCachePurgeRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetPurgeEpochTimestamp() string {
	if m != nil {
		return m.PurgeEpochTimestamp
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetPurgeAll() *schema.Empty {
	if x, ok := m.GetPatternType().(*LilacCDNCachePurgeRequest_PurgeAll); ok {
		return x.PurgeAll
	}
	return nil
}

func (m *LilacCDNCachePurgeRequest) GetUrl() string {
	if x, ok := m.GetPatternType().(*LilacCDNCachePurgeRequest_Url); ok {
		return x.Url
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetHostname() string {
	if x, ok := m.GetPatternType().(*LilacCDNCachePurgeRequest_Hostname); ok {
		return x.Hostname
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetPattern() string {
	if x, ok := m.GetPatternType().(*LilacCDNCachePurgeRequest_Pattern); ok {
		return x.Pattern
	}
	return ""
}

func (m *LilacCDNCachePurgeRequest) GetSoftPurge() *schema.Empty {
	if x, ok := m.GetPurgeType().(*LilacCDNCachePurgeRequest_SoftPurge); ok {
		return x.SoftPurge
	}
	return nil
}

func (m *LilacCDNCachePurgeRequest) GetHardPurge() *schema.Empty {
	if x, ok := m.GetPurgeType().(*LilacCDNCachePurgeRequest_HardPurge); ok {
		return x.HardPurge
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LilacCDNCachePurgeRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LilacCDNCachePurgeRequest_PurgeAll)(nil),
		(*LilacCDNCachePurgeRequest_Url)(nil),
		(*LilacCDNCachePurgeRequest_Hostname)(nil),
		(*LilacCDNCachePurgeRequest_Pattern)(nil),
		(*LilacCDNCachePurgeRequest_SoftPurge)(nil),
		(*LilacCDNCachePurgeRequest_HardPurge)(nil),
	}
}

// Purge Response
//
// x-displayName: "Cache Purge Response"
// Cache Purge message
type LilacCDNCachePurgeResponse struct {
	// Purge Request Id
	//
	// x-displayName: "Purge Request Id"
	// Request Id to track the status of the purge request
	PurgeRequestId uint32 `protobuf:"varint,1,opt,name=purge_request_id,json=purgeRequestId,proto3" json:"purge_request_id,omitempty"`
}

func (m *LilacCDNCachePurgeResponse) Reset()      { *m = LilacCDNCachePurgeResponse{} }
func (*LilacCDNCachePurgeResponse) ProtoMessage() {}
func (*LilacCDNCachePurgeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{3}
}
func (m *LilacCDNCachePurgeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LilacCDNCachePurgeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LilacCDNCachePurgeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LilacCDNCachePurgeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LilacCDNCachePurgeResponse.Merge(m, src)
}
func (m *LilacCDNCachePurgeResponse) XXX_Size() int {
	return m.Size()
}
func (m *LilacCDNCachePurgeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LilacCDNCachePurgeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LilacCDNCachePurgeResponse proto.InternalMessageInfo

func (m *LilacCDNCachePurgeResponse) GetPurgeRequestId() uint32 {
	if m != nil {
		return m.PurgeRequestId
	}
	return 0
}

// Service Operation Request
//
// x-displayName: "Get Service Operation Request"
// Get Service Operation Request
type GetServiceOperationReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "default"
	// x-required
	// Namespace scope of the operation request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// CDN Distribution Name
	//
	// x-displayName: "Name of the CDN distribution"
	// x-example: "cdn-1"
	// x-required
	// Name of the CDN distribution.
	// Format: string
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Service Operation ID
	//
	// x-displayName: "Service Operation ID"
	// x-example: "101"
	// x-required
	// Operation ID for which status is requested
	ServiceOpId uint32 `protobuf:"varint,3,opt,name=service_op_id,json=serviceOpId,proto3" json:"service_op_id,omitempty"`
}

func (m *GetServiceOperationReq) Reset()      { *m = GetServiceOperationReq{} }
func (*GetServiceOperationReq) ProtoMessage() {}
func (*GetServiceOperationReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{4}
}
func (m *GetServiceOperationReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetServiceOperationReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetServiceOperationReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetServiceOperationReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetServiceOperationReq.Merge(m, src)
}
func (m *GetServiceOperationReq) XXX_Size() int {
	return m.Size()
}
func (m *GetServiceOperationReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetServiceOperationReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetServiceOperationReq proto.InternalMessageInfo

func (m *GetServiceOperationReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetServiceOperationReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetServiceOperationReq) GetServiceOpId() uint32 {
	if m != nil {
		return m.ServiceOpId
	}
	return 0
}

// Purge Operation Status
//
// x-displayName: "Purge Operation Status"
// Purge Operation Status
type PurgeOperationItem struct {
	// NodeId on which the operation status is gathered
	//
	// x-displayName: "CDN CE Site"
	// Site at which the purge operation was performed.
	Site string `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
	// Time taken for Cache Purge
	//
	// x-displayName: "Cache Purge Time"
	// x-example: "2018-12-23T12:30:11.733Z"
	// Time taken for Cache Purge
	PurgeTime string `protobuf:"bytes,2,opt,name=purge_time,json=purgeTime,proto3" json:"purge_time,omitempty"`
	// Regex used in Purge
	//
	// x-displayName: "Cache Purge Regex"
	// x-example: "*.m3u8"
	// Regex issued in the Purge Operation
	Regexp string `protobuf:"bytes,3,opt,name=regexp,proto3" json:"regexp,omitempty"`
	// Start time of Purge Operation
	//
	// x-displayName: "Cache Purge Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// Start time of Purge Operation
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Finish time of Purge Operation
	//
	// x-displayName: "Cache Purge Finish Time"
	// x-example: "2019-09-23T12:32:11.733Z"
	// Finish time of Purge Operation
	// format: unix_timestamp|rfc 3339
	FinishTime string `protobuf:"bytes,5,opt,name=finish_time,json=finishTime,proto3" json:"finish_time,omitempty"`
	// Hard Purge
	//
	// x-displayName: "Cache Hard Purge"
	// x-example: true
	// Cache Hard Purge
	HardPurge bool `protobuf:"varint,6,opt,name=hard_purge,json=hardPurge,proto3" json:"hard_purge,omitempty"`
	// Number of Bytes Purged
	//
	// x-displayName: "Number of Bytes Purged"
	// x-example: 1024
	// Number of bytes Purged
	BytesPurged uint64 `protobuf:"varint,7,opt,name=bytes_purged,json=bytesPurged,proto3" json:"bytes_purged,omitempty"`
	// Number of Bytes Not Purged
	//
	// x-displayName: "Number of Bytes Not Purged"
	// x-example: 1024
	// Number of bytes Not Purged
	BytesNotPurged uint64 `protobuf:"varint,8,opt,name=bytes_not_purged,json=bytesNotPurged,proto3" json:"bytes_not_purged,omitempty"`
}

func (m *PurgeOperationItem) Reset()      { *m = PurgeOperationItem{} }
func (*PurgeOperationItem) ProtoMessage() {}
func (*PurgeOperationItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{5}
}
func (m *PurgeOperationItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PurgeOperationItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PurgeOperationItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PurgeOperationItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PurgeOperationItem.Merge(m, src)
}
func (m *PurgeOperationItem) XXX_Size() int {
	return m.Size()
}
func (m *PurgeOperationItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PurgeOperationItem.DiscardUnknown(m)
}

var xxx_messageInfo_PurgeOperationItem proto.InternalMessageInfo

func (m *PurgeOperationItem) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *PurgeOperationItem) GetPurgeTime() string {
	if m != nil {
		return m.PurgeTime
	}
	return ""
}

func (m *PurgeOperationItem) GetRegexp() string {
	if m != nil {
		return m.Regexp
	}
	return ""
}

func (m *PurgeOperationItem) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *PurgeOperationItem) GetFinishTime() string {
	if m != nil {
		return m.FinishTime
	}
	return ""
}

func (m *PurgeOperationItem) GetHardPurge() bool {
	if m != nil {
		return m.HardPurge
	}
	return false
}

func (m *PurgeOperationItem) GetBytesPurged() uint64 {
	if m != nil {
		return m.BytesPurged
	}
	return 0
}

func (m *PurgeOperationItem) GetBytesNotPurged() uint64 {
	if m != nil {
		return m.BytesNotPurged
	}
	return 0
}

// Service Operation Item
//
// x-displayName: "Service Operation Item"
// Service Operation Item
type ServiceOperationItem struct {
	// Service Operation ID
	//
	// x-displayName: "Service Operation ID"
	// x-example: "101"
	// Operation ID for which status is requested. This for example is the purge_request_id obtained in the response to the CachePurge Request.
	ServiceOpId uint32 `protobuf:"varint,1,opt,name=service_op_id,json=serviceOpId,proto3" json:"service_op_id,omitempty"`
	// Service Operation Status
	//
	// x-displayName: "Service Operation Status"
	// x-example: success
	// Status of the operation command
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// operation status
	//
	// x-displayName: "Operation Status"
	// Specify operation status of each operation item
	//
	// Types that are valid to be assigned to OpStatus:
	//	*ServiceOperationItem_Purge
	OpStatus isServiceOperationItem_OpStatus `protobuf_oneof:"op_status"`
}

func (m *ServiceOperationItem) Reset()      { *m = ServiceOperationItem{} }
func (*ServiceOperationItem) ProtoMessage() {}
func (*ServiceOperationItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{6}
}
func (m *ServiceOperationItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceOperationItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceOperationItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceOperationItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceOperationItem.Merge(m, src)
}
func (m *ServiceOperationItem) XXX_Size() int {
	return m.Size()
}
func (m *ServiceOperationItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceOperationItem.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceOperationItem proto.InternalMessageInfo

type isServiceOperationItem_OpStatus interface {
	isServiceOperationItem_OpStatus()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ServiceOperationItem_Purge struct {
	Purge *PurgeOperationItem `protobuf:"bytes,4,opt,name=purge,proto3,oneof" json:"purge,omitempty"`
}

func (*ServiceOperationItem_Purge) isServiceOperationItem_OpStatus() {}

func (m *ServiceOperationItem) GetOpStatus() isServiceOperationItem_OpStatus {
	if m != nil {
		return m.OpStatus
	}
	return nil
}

func (m *ServiceOperationItem) GetServiceOpId() uint32 {
	if m != nil {
		return m.ServiceOpId
	}
	return 0
}

func (m *ServiceOperationItem) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ServiceOperationItem) GetPurge() *PurgeOperationItem {
	if x, ok := m.GetOpStatus().(*ServiceOperationItem_Purge); ok {
		return x.Purge
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ServiceOperationItem) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ServiceOperationItem_Purge)(nil),
	}
}

// Service Operation Response
//
// x-displayName: "Service Operation Response"
// Get Service Operation Response
type GetServiceOperationRsp struct {
	// error
	//
	// x-displayName: "Errors"
	// Errors(if any) while listing items from collection
	Error *schema.ErrorType `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// Serice Operation Status Details
	//
	// x-displayName: "Operation Status Details"
	// items represents the collection in response
	Items []*ServiceOperationItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *GetServiceOperationRsp) Reset()      { *m = GetServiceOperationRsp{} }
func (*GetServiceOperationRsp) ProtoMessage() {}
func (*GetServiceOperationRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{7}
}
func (m *GetServiceOperationRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetServiceOperationRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetServiceOperationRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetServiceOperationRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetServiceOperationRsp.Merge(m, src)
}
func (m *GetServiceOperationRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetServiceOperationRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetServiceOperationRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetServiceOperationRsp proto.InternalMessageInfo

func (m *GetServiceOperationRsp) GetError() *schema.ErrorType {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetServiceOperationRsp) GetItems() []*ServiceOperationItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// Service Operations Time Range
//
// x-displayName: "Service Operations Options"
// Option to specify lastn or start-end time.
type ServiceOperationsTimeRange struct {
	// Start time of Service Operations
	//
	// x-displayName: "Service Operation Start Time"
	// x-example: "2019-09-23T12:30:11.733Z"
	// x-required
	// A start time for the time range in which the service operation status is requested.
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Finish time of Service Operations
	//
	// x-displayName: "Service Operation Finish Time"
	// x-example: "2019-09-23T12:32:11.733Z"
	// x-required
	// A finish time for the time range in which the service operation status is requested.
	// format: unix_timestamp|rfc 3339
	FinishTime string `protobuf:"bytes,5,opt,name=finish_time,json=finishTime,proto3" json:"finish_time,omitempty"`
}

func (m *ServiceOperationsTimeRange) Reset()      { *m = ServiceOperationsTimeRange{} }
func (*ServiceOperationsTimeRange) ProtoMessage() {}
func (*ServiceOperationsTimeRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{8}
}
func (m *ServiceOperationsTimeRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceOperationsTimeRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceOperationsTimeRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceOperationsTimeRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceOperationsTimeRange.Merge(m, src)
}
func (m *ServiceOperationsTimeRange) XXX_Size() int {
	return m.Size()
}
func (m *ServiceOperationsTimeRange) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceOperationsTimeRange.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceOperationsTimeRange proto.InternalMessageInfo

func (m *ServiceOperationsTimeRange) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *ServiceOperationsTimeRange) GetFinishTime() string {
	if m != nil {
		return m.FinishTime
	}
	return ""
}

// Service Operations Request
//
// x-displayName: "List Service Operations Request"
// List Service Operations Request
type ListServiceOperationsReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// x-required
	// The namespace this item belongs to
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "name"
	// Name of the CDN Distribution
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// service operation options
	//
	// x-required
	// x-displayName: "Options"
	// Specify one of the service operation options. It can be either operations in a timerange or last-n operations.
	//
	// Types that are valid to be assigned to Options:
	//	*ListServiceOperationsReq_TimeRange
	//	*ListServiceOperationsReq_Lastn
	Options isListServiceOperationsReq_Options `protobuf_oneof:"options"`
}

func (m *ListServiceOperationsReq) Reset()      { *m = ListServiceOperationsReq{} }
func (*ListServiceOperationsReq) ProtoMessage() {}
func (*ListServiceOperationsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{9}
}
func (m *ListServiceOperationsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListServiceOperationsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListServiceOperationsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListServiceOperationsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListServiceOperationsReq.Merge(m, src)
}
func (m *ListServiceOperationsReq) XXX_Size() int {
	return m.Size()
}
func (m *ListServiceOperationsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListServiceOperationsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListServiceOperationsReq proto.InternalMessageInfo

type isListServiceOperationsReq_Options interface {
	isListServiceOperationsReq_Options()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListServiceOperationsReq_TimeRange struct {
	TimeRange *ServiceOperationsTimeRange `protobuf:"bytes,4,opt,name=time_range,json=timeRange,proto3,oneof" json:"time_range,omitempty"`
}
type ListServiceOperationsReq_Lastn struct {
	Lastn uint32 `protobuf:"varint,5,opt,name=lastn,proto3,oneof" json:"lastn,omitempty"`
}

func (*ListServiceOperationsReq_TimeRange) isListServiceOperationsReq_Options() {}
func (*ListServiceOperationsReq_Lastn) isListServiceOperationsReq_Options()     {}

func (m *ListServiceOperationsReq) GetOptions() isListServiceOperationsReq_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ListServiceOperationsReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListServiceOperationsReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListServiceOperationsReq) GetTimeRange() *ServiceOperationsTimeRange {
	if x, ok := m.GetOptions().(*ListServiceOperationsReq_TimeRange); ok {
		return x.TimeRange
	}
	return nil
}

func (m *ListServiceOperationsReq) GetLastn() uint32 {
	if x, ok := m.GetOptions().(*ListServiceOperationsReq_Lastn); ok {
		return x.Lastn
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ListServiceOperationsReq) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ListServiceOperationsReq_TimeRange)(nil),
		(*ListServiceOperationsReq_Lastn)(nil),
	}
}

// Service Operations Item
//
// x-displayName: "List of Service Operations"
// List of Service Operations
type ServiceOperationsItem struct {
	// service operation id
	//
	// x-displayName: "Service Operation ID"
	// x-example: ""
	// The id of the operation command
	ServiceOpId uint32 `protobuf:"varint,1,opt,name=service_op_id,json=serviceOpId,proto3" json:"service_op_id,omitempty"`
	// svc version
	//
	// x-displayName: "Service Version"
	// x-example: ""
	// The version info of the service
	SvcVersion uint32 `protobuf:"varint,2,opt,name=svc_version,json=svcVersion,proto3" json:"svc_version,omitempty"`
	// created time
	//
	// x-displayName: "Created Time"
	// The service created time
	CreatedTime string `protobuf:"bytes,3,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// modified time
	//
	// x-displayName: "Modified Time"
	// The service modified time
	ModifiedTime string `protobuf:"bytes,4,opt,name=modified_time,json=modifiedTime,proto3" json:"modified_time,omitempty"`
}

func (m *ServiceOperationsItem) Reset()      { *m = ServiceOperationsItem{} }
func (*ServiceOperationsItem) ProtoMessage() {}
func (*ServiceOperationsItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{10}
}
func (m *ServiceOperationsItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceOperationsItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceOperationsItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceOperationsItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceOperationsItem.Merge(m, src)
}
func (m *ServiceOperationsItem) XXX_Size() int {
	return m.Size()
}
func (m *ServiceOperationsItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceOperationsItem.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceOperationsItem proto.InternalMessageInfo

func (m *ServiceOperationsItem) GetServiceOpId() uint32 {
	if m != nil {
		return m.ServiceOpId
	}
	return 0
}

func (m *ServiceOperationsItem) GetSvcVersion() uint32 {
	if m != nil {
		return m.SvcVersion
	}
	return 0
}

func (m *ServiceOperationsItem) GetCreatedTime() string {
	if m != nil {
		return m.CreatedTime
	}
	return ""
}

func (m *ServiceOperationsItem) GetModifiedTime() string {
	if m != nil {
		return m.ModifiedTime
	}
	return ""
}

// Service Operations Response
//
// x-displayName: "Service Operations Response"
// Get Service Operations Response
type ListServiceOperationsRsp struct {
	// error
	//
	// x-displayName: "Errors"
	// Errors(if any) while listing items from collection
	Error *schema.ErrorType `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// Details of the Service Operation
	//
	// x-displayName: "Details of the Service Operation"
	// items represents the collection in response
	Items []*ServiceOperationsItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *ListServiceOperationsRsp) Reset()      { *m = ListServiceOperationsRsp{} }
func (*ListServiceOperationsRsp) ProtoMessage() {}
func (*ListServiceOperationsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_46a1a9d3548cfe8a, []int{11}
}
func (m *ListServiceOperationsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListServiceOperationsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListServiceOperationsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListServiceOperationsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListServiceOperationsRsp.Merge(m, src)
}
func (m *ListServiceOperationsRsp) XXX_Size() int {
	return m.Size()
}
func (m *ListServiceOperationsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListServiceOperationsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ListServiceOperationsRsp proto.InternalMessageInfo

func (m *ListServiceOperationsRsp) GetError() *schema.ErrorType {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ListServiceOperationsRsp) GetItems() []*ServiceOperationsItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.views.common_cdn.CDNLoadbalancerDeploymentStatus", CDNLoadbalancerDeploymentStatus_name, CDNLoadbalancerDeploymentStatus_value)
	proto.RegisterEnum("ves.io.schema.views.common_cdn.CDNSiteDeploymentStatus", CDNSiteDeploymentStatus_name, CDNSiteDeploymentStatus_value)
	proto.RegisterType((*CDNControllerStatus)(nil), "ves.io.schema.views.common_cdn.CDNControllerStatus")
	proto.RegisterType((*CDNSiteStatus)(nil), "ves.io.schema.views.common_cdn.CDNSiteStatus")
	proto.RegisterType((*LilacCDNCachePurgeRequest)(nil), "ves.io.schema.views.common_cdn.LilacCDNCachePurgeRequest")
	proto.RegisterType((*LilacCDNCachePurgeResponse)(nil), "ves.io.schema.views.common_cdn.LilacCDNCachePurgeResponse")
	proto.RegisterType((*GetServiceOperationReq)(nil), "ves.io.schema.views.common_cdn.GetServiceOperationReq")
	proto.RegisterType((*PurgeOperationItem)(nil), "ves.io.schema.views.common_cdn.PurgeOperationItem")
	proto.RegisterType((*ServiceOperationItem)(nil), "ves.io.schema.views.common_cdn.ServiceOperationItem")
	proto.RegisterType((*GetServiceOperationRsp)(nil), "ves.io.schema.views.common_cdn.GetServiceOperationRsp")
	proto.RegisterType((*ServiceOperationsTimeRange)(nil), "ves.io.schema.views.common_cdn.ServiceOperationsTimeRange")
	proto.RegisterType((*ListServiceOperationsReq)(nil), "ves.io.schema.views.common_cdn.ListServiceOperationsReq")
	proto.RegisterType((*ServiceOperationsItem)(nil), "ves.io.schema.views.common_cdn.ServiceOperationsItem")
	proto.RegisterType((*ListServiceOperationsRsp)(nil), "ves.io.schema.views.common_cdn.ListServiceOperationsRsp")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/common_cdn/types.proto", fileDescriptor_46a1a9d3548cfe8a)
}

var fileDescriptor_46a1a9d3548cfe8a = []byte{
	// 1354 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x3d, 0x70, 0x1b, 0x45,
	0x1b, 0xd6, 0x5a, 0x92, 0x23, 0xbd, 0xb2, 0xf3, 0xe9, 0xdb, 0xd8, 0xfe, 0x14, 0x25, 0x39, 0xfb,
	0x3b, 0x06, 0x46, 0x24, 0xb1, 0x44, 0x9c, 0x64, 0xf8, 0x69, 0x18, 0xcb, 0x52, 0x62, 0x1b, 0x23,
	0x67, 0xce, 0x82, 0x19, 0x68, 0x6e, 0xce, 0x77, 0x6b, 0xf9, 0x86, 0x93, 0xf6, 0x72, 0xbb, 0x12,
	0x71, 0x97, 0x92, 0x49, 0x45, 0xc1, 0x0c, 0xf4, 0x34, 0x74, 0x50, 0x23, 0x0a, 0x97, 0x94, 0x2e,
	0x43, 0x47, 0x94, 0x26, 0xcc, 0x50, 0xa4, 0xa0, 0xa0, 0x64, 0x76, 0xf7, 0x4e, 0xff, 0x76, 0x12,
	0x18, 0x3a, 0xed, 0x3e, 0xcf, 0xfb, 0xb3, 0xef, 0xf3, 0xdc, 0xde, 0x09, 0xae, 0x76, 0x08, 0x2b,
	0xba, 0xb4, 0xc4, 0xec, 0x43, 0xd2, 0xb4, 0x4a, 0x1d, 0x97, 0x7c, 0xce, 0x4a, 0x36, 0x6d, 0x36,
	0x69, 0xcb, 0xb4, 0x9d, 0x56, 0x89, 0x1f, 0xf9, 0x84, 0x15, 0xfd, 0x80, 0x72, 0x8a, 0x35, 0xc5,
	0x2d, 0x2a, 0x6e, 0x51, 0x72, 0x8b, 0x03, 0x6e, 0x7e, 0xb5, 0xe1, 0xf2, 0xc3, 0xf6, 0xbe, 0xd8,
	0x2a, 0x35, 0x68, 0x83, 0x96, 0x64, 0xd8, 0x7e, 0xfb, 0x40, 0xae, 0xe4, 0x42, 0xfe, 0x52, 0xe9,
	0xf2, 0xcb, 0x0d, 0x4a, 0x1b, 0x1e, 0x19, 0xb0, 0xb8, 0xdb, 0x24, 0x8c, 0x5b, 0x4d, 0x3f, 0x24,
	0xe8, 0xa3, 0xbd, 0x59, 0xbe, 0x6f, 0x8a, 0x76, 0x86, 0x7b, 0xca, 0xe7, 0x47, 0x39, 0x24, 0x08,
	0x68, 0x10, 0x61, 0x97, 0x46, 0x31, 0xea, 0x73, 0x97, 0xb6, 0x22, 0x70, 0x65, 0x14, 0xf4, 0xa9,
	0xe7, 0xda, 0x47, 0x23, 0xa9, 0x2f, 0x8e, 0x32, 0x86, 0xa1, 0xcb, 0x63, 0x53, 0xb3, 0x3c, 0xd7,
	0xb1, 0x38, 0x99, 0x9e, 0x5a, 0xcc, 0xc9, 0x1c, 0x2d, 0xbe, 0x3c, 0x6d, 0xea, 0xc3, 0x05, 0xde,
	0x18, 0x27, 0x04, 0xbc, 0x6d, 0x79, 0xe6, 0x21, 0x65, 0x7c, 0x98, 0xa7, 0xff, 0x82, 0xe0, 0xc2,
	0x46, 0xa5, 0xb6, 0x41, 0x5b, 0x3c, 0xa0, 0x9e, 0x47, 0x82, 0x3d, 0x6e, 0xf1, 0x36, 0xc3, 0x1e,
	0xfc, 0xd7, 0x21, 0xbe, 0x47, 0x8f, 0x9a, 0xa4, 0xc5, 0x4d, 0x26, 0x37, 0x73, 0x68, 0x05, 0x15,
	0xce, 0xaf, 0xbd, 0x5f, 0x3c, 0x5b, 0xc6, 0xe2, 0x46, 0xa5, 0xb6, 0x43, 0x2d, 0x67, 0xdf, 0xf2,
	0xac, 0x96, 0x4d, 0x82, 0x4a, 0x3f, 0x8f, 0xca, 0x6d, 0x64, 0x9d, 0xb1, 0x1d, 0xbc, 0x00, 0x49,
	0x39, 0xf8, 0xdc, 0xcc, 0x0a, 0x2a, 0xa4, 0x0d, 0xb5, 0xc0, 0xcb, 0x90, 0xb1, 0x0f, 0x1a, 0x66,
	0x87, 0x04, 0xcc, 0xa5, 0xad, 0x5c, 0x7c, 0x05, 0x15, 0xe6, 0x0d, 0xb0, 0x0f, 0x1a, 0x1f, 0xab,
	0x1d, 0x7c, 0x05, 0xc0, 0xf6, 0xfb, 0x78, 0x42, 0xe2, 0x69, 0xdb, 0x0f, 0x61, 0xfd, 0x11, 0x82,
	0xf9, 0x8d, 0x4a, 0x6d, 0xcf, 0xe5, 0x24, 0xac, 0xb3, 0x0b, 0xb3, 0x23, 0x47, 0x79, 0xfb, 0x25,
	0x8e, 0x22, 0xc2, 0x27, 0x8e, 0x10, 0xa6, 0xc1, 0x18, 0x12, 0xcc, 0xe5, 0x24, 0xec, 0x5b, 0xfe,
	0x1e, 0x1c, 0x26, 0x3e, 0x74, 0x18, 0xfd, 0xf7, 0x38, 0x5c, 0xdc, 0x71, 0x3d, 0xcb, 0x16, 0xd3,
	0xb6, 0xec, 0x43, 0x72, 0xaf, 0x1d, 0x34, 0x88, 0x41, 0xee, 0xb7, 0x09, 0xe3, 0x58, 0x87, 0x74,
	0xcb, 0x6a, 0x12, 0xe6, 0x5b, 0x36, 0x91, 0xbd, 0xa5, 0xcb, 0x89, 0x67, 0x5d, 0x84, 0x8c, 0xc1,
	0x36, 0xce, 0x41, 0x42, 0x2c, 0x54, 0xad, 0x10, 0x96, 0x3b, 0xf8, 0x1d, 0x58, 0xf4, 0x45, 0x36,
	0x93, 0xf8, 0xd4, 0x3e, 0x34, 0xfb, 0x8f, 0x81, 0xea, 0x20, 0xa4, 0x5e, 0x90, 0x94, 0xaa, 0x60,
	0xd4, 0x23, 0x02, 0xbe, 0x09, 0x69, 0x15, 0x69, 0x79, 0x5e, 0x2e, 0xbd, 0x82, 0x0a, 0x99, 0xb5,
	0x85, 0xb1, 0x99, 0x54, 0x9b, 0x3e, 0x3f, 0xda, 0x8c, 0x19, 0x29, 0x49, 0x5c, 0xf7, 0x3c, 0x8c,
	0x21, 0xde, 0x0e, 0xbc, 0x1c, 0x88, 0xe4, 0x9b, 0x31, 0x43, 0x2c, 0x70, 0x01, 0x52, 0xc2, 0x5b,
	0xb2, 0xc1, 0x8c, 0xac, 0x0a, 0x3f, 0xfe, 0x76, 0x1c, 0x4f, 0x06, 0xf1, 0x2f, 0x66, 0x90, 0x88,
	0x8e, 0x50, 0x7c, 0x0d, 0xce, 0xf9, 0x16, 0xe7, 0x24, 0x50, 0x8a, 0xa5, 0xcb, 0xff, 0x11, 0x44,
	0x08, 0x52, 0x59, 0x94, 0x7b, 0x38, 0x73, 0x8c, 0x04, 0x3b, 0x62, 0xe0, 0xdb, 0x00, 0x8c, 0x1e,
	0x70, 0x53, 0xd6, 0xce, 0xcd, 0x9e, 0xd1, 0x20, 0x32, 0xd2, 0x82, 0x29, 0xa7, 0x2a, 0xc2, 0x0e,
	0xad, 0xc0, 0x09, 0xc3, 0xce, 0x9d, 0x1d, 0x26, 0x98, 0x32, 0xac, 0xfc, 0x3a, 0xcc, 0x85, 0x85,
	0xe5, 0x3d, 0x81, 0x17, 0x8f, 0xbb, 0x28, 0x7d, 0xd2, 0x45, 0xa9, 0x5e, 0x17, 0xa5, 0xdf, 0xbd,
	0x7e, 0xe3, 0xad, 0xeb, 0x37, 0x6e, 0x5c, 0xbf, 0x55, 0x5e, 0x02, 0x50, 0x43, 0x93, 0xa4, 0xd4,
	0x71, 0x17, 0xcd, 0x9e, 0x74, 0x51, 0x72, 0x3b, 0x91, 0x4a, 0x65, 0xd3, 0xdb, 0x89, 0x54, 0x32,
	0x3b, 0xab, 0xdf, 0x81, 0xfc, 0x34, 0xb5, 0x99, 0x4f, 0x5b, 0x8c, 0xe0, 0x02, 0x64, 0x55, 0x86,
	0x40, 0xe9, 0x6f, 0xba, 0x8e, 0x54, 0x7d, 0xde, 0x38, 0xef, 0x0f, 0xd9, 0x62, 0xcb, 0xd1, 0x1f,
	0x22, 0x58, 0xba, 0x4b, 0xf8, 0x1e, 0x09, 0x3a, 0xae, 0x4d, 0x76, 0x7d, 0x12, 0x58, 0xe2, 0x1e,
	0x30, 0xc8, 0xfd, 0xa9, 0x9e, 0xf9, 0xb3, 0x8b, 0x62, 0x67, 0x78, 0x46, 0xc2, 0xca, 0x33, 0x05,
	0x98, 0x67, 0x2a, 0xa9, 0x49, 0x7d, 0x51, 0x5f, 0x3e, 0x5e, 0x21, 0x25, 0xc3, 0xa2, 0x7a, 0x5b,
	0x8e, 0xfe, 0xfd, 0x0c, 0x60, 0xd9, 0x7e, 0xbf, 0xfa, 0x16, 0x27, 0xcd, 0xbe, 0xf5, 0xd1, 0x90,
	0xf5, 0xdf, 0xec, 0x4f, 0xc6, 0xed, 0x17, 0x8d, 0x7c, 0xf0, 0x4d, 0x02, 0x19, 0xca, 0x6c, 0xc2,
	0x7e, 0x78, 0x09, 0x66, 0x03, 0xd2, 0x20, 0x0f, 0x42, 0x93, 0x1a, 0xe1, 0x4a, 0xa4, 0x60, 0xdc,
	0x0a, 0xb8, 0x4a, 0x91, 0x98, 0x4c, 0x21, 0x51, 0x99, 0xe2, 0x1a, 0x64, 0x0e, 0xdc, 0x96, 0xcb,
	0x94, 0xe3, 0x73, 0xc9, 0x09, 0x2e, 0x28, 0x58, 0x92, 0xaf, 0x8c, 0x58, 0x42, 0x38, 0x29, 0x35,
	0x24, 0x3d, 0xfe, 0x3f, 0xcc, 0xed, 0x1f, 0x71, 0xc2, 0x14, 0xee, 0x48, 0xcf, 0x24, 0x8c, 0x8c,
	0xdc, 0x93, 0x0c, 0x47, 0x88, 0xa6, 0x28, 0x2d, 0xca, 0x23, 0x5a, 0x4a, 0xd2, 0xce, 0xcb, 0xfd,
	0x1a, 0x55, 0xee, 0x73, 0xf4, 0x2e, 0x82, 0x85, 0x71, 0xc5, 0xe4, 0xcc, 0xf4, 0xf1, 0xa1, 0x2b,
	0xd1, 0x87, 0xc7, 0x2d, 0x06, 0x13, 0xde, 0x51, 0xea, 0x52, 0x89, 0xae, 0x9a, 0x6d, 0x48, 0xaa,
	0xde, 0x13, 0xd2, 0xce, 0x6b, 0x2f, 0xba, 0xba, 0x26, 0x25, 0xdb, 0x8c, 0x19, 0x2a, 0x45, 0x79,
	0x11, 0xd2, 0xd4, 0x0f, 0x6f, 0x75, 0x69, 0xe0, 0xc4, 0x49, 0x17, 0xc5, 0xb7, 0x13, 0xa9, 0x78,
	0x36, 0xa1, 0x7f, 0x75, 0x8a, 0xe5, 0x98, 0x8f, 0x8b, 0xd1, 0xd5, 0x86, 0x64, 0x0f, 0xb9, 0xf1,
	0x47, 0x4a, 0x60, 0xf5, 0x23, 0x9f, 0x44, 0x37, 0xf8, 0x36, 0x24, 0x5d, 0x4e, 0x9a, 0xe2, 0x28,
	0xf1, 0x42, 0x66, 0xed, 0xd6, 0x8b, 0x7a, 0x9e, 0x36, 0x34, 0x43, 0xa5, 0xd0, 0x39, 0xe4, 0xc7,
	0x61, 0x26, 0x94, 0x35, 0xac, 0x56, 0x83, 0xfc, 0x5b, 0xb6, 0xd1, 0xff, 0x40, 0x90, 0xdb, 0x71,
	0xd9, 0xc4, 0x34, 0xd8, 0x3f, 0x7f, 0x02, 0x2d, 0x00, 0xd1, 0x80, 0x19, 0x88, 0x03, 0x84, 0xaa,
	0xbe, 0xf7, 0xaa, 0x13, 0x1a, 0x8c, 0x40, 0xe5, 0xde, 0x8c, 0x19, 0x69, 0xde, 0x9f, 0xca, 0x65,
	0x48, 0x7a, 0x16, 0xe3, 0x2d, 0x79, 0xc8, 0xf9, 0x3e, 0x43, 0x6d, 0x96, 0x2f, 0xc0, 0xb9, 0xf0,
	0xab, 0x42, 0x7a, 0x20, 0x39, 0xe4, 0x81, 0x9f, 0x10, 0x2c, 0x4e, 0x94, 0x7a, 0x69, 0x0b, 0x2f,
	0x43, 0x86, 0x75, 0xec, 0xfe, 0x8b, 0x79, 0x46, 0xbd, 0xb8, 0x59, 0xc7, 0x8e, 0x5e, 0xdc, 0xab,
	0x30, 0x67, 0x07, 0xc4, 0xe2, 0xc4, 0x51, 0x1a, 0xc4, 0x27, 0x34, 0xc8, 0x84, 0xb8, 0x54, 0xac,
	0x04, 0xf3, 0x4d, 0xea, 0xb8, 0x07, 0x6e, 0xc4, 0x9f, 0xd4, 0x77, 0x2e, 0x22, 0x48, 0xd5, 0xbe,
	0x3e, 0x55, 0xb5, 0xbf, 0x61, 0xe2, 0x0f, 0x46, 0x4d, 0x7c, 0xfb, 0x95, 0x25, 0x1a, 0x72, 0xf1,
	0xd5, 0x1f, 0x10, 0x2c, 0xbf, 0xe0, 0xfb, 0x08, 0x5f, 0x84, 0xc5, 0x8d, 0x4a, 0xcd, 0xdc, 0x29,
	0x9b, 0x7b, 0xf5, 0xf5, 0xfa, 0x47, 0x7b, 0xe6, 0x86, 0x51, 0x5d, 0xaf, 0x57, 0x2b, 0xd9, 0x18,
	0xbe, 0x04, 0xff, 0x1b, 0x85, 0x2a, 0xd5, 0x7b, 0x3b, 0xbb, 0x9f, 0x6c, 0xd5, 0xee, 0x66, 0x11,
	0x5e, 0x86, 0x4b, 0xd3, 0x40, 0xf3, 0xce, 0xfa, 0xd6, 0x4e, 0xb5, 0x92, 0x9d, 0xc1, 0x79, 0x58,
	0x9a, 0x46, 0xa8, 0x56, 0xb2, 0x71, 0x9c, 0x83, 0x85, 0x51, 0x2c, 0x8c, 0x4a, 0x5c, 0xfd, 0x16,
	0xc9, 0xa2, 0xd3, 0xbe, 0x83, 0xb0, 0x0e, 0x9a, 0xca, 0xf1, 0x61, 0xb5, 0x56, 0x8f, 0x22, 0x6b,
	0xbb, 0xf5, 0x41, 0xe6, 0x98, 0x68, 0x6b, 0x92, 0x33, 0xdc, 0xf7, 0x6b, 0xb0, 0x7c, 0x1a, 0x61,
	0xd0, 0xbb, 0x06, 0xf9, 0xd3, 0x48, 0xa2, 0xff, 0xf2, 0x23, 0x74, 0xf2, 0x44, 0x8b, 0x3d, 0x7e,
	0xa2, 0xc5, 0x9e, 0x3f, 0xd1, 0xd0, 0xc3, 0x9e, 0x86, 0xbe, 0xeb, 0x69, 0xe8, 0xe7, 0x9e, 0x86,
	0x4e, 0x7a, 0x1a, 0xfa, 0xb5, 0xa7, 0xa1, 0x67, 0x3d, 0x2d, 0xf6, 0xbc, 0xa7, 0xa1, 0x2f, 0x9f,
	0x6a, 0xb1, 0x93, 0xa7, 0x5a, 0xec, 0xf1, 0x53, 0x2d, 0xf6, 0x69, 0xbd, 0x41, 0xfd, 0xcf, 0x1a,
	0xc5, 0x0e, 0xf5, 0x38, 0x09, 0x02, 0xab, 0xd8, 0x66, 0x25, 0xf9, 0xe3, 0x80, 0x06, 0xcd, 0x55,
	0x3f, 0xa0, 0x1d, 0xd7, 0x21, 0xc1, 0x6a, 0x04, 0x97, 0xfc, 0xfd, 0x06, 0x2d, 0x91, 0x07, 0x3c,
	0xfc, 0xac, 0x3e, 0xe5, 0x4f, 0xcf, 0xfe, 0xac, 0xfc, 0xb8, 0xbe, 0xf9, 0x57, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x70, 0x41, 0xac, 0x91, 0x1d, 0x0d, 0x00, 0x00,
}

func (x CDNLoadbalancerDeploymentStatus) String() string {
	s, ok := CDNLoadbalancerDeploymentStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CDNSiteDeploymentStatus) String() string {
	s, ok := CDNSiteDeploymentStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *CDNControllerStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNControllerStatus)
	if !ok {
		that2, ok := that.(CDNControllerStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeploymentStatus != that1.DeploymentStatus {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if this.CfgVersion != that1.CfgVersion {
		return false
	}
	if this.CpVersion != that1.CpVersion {
		return false
	}
	return true
}
func (this *CDNSiteStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNSiteStatus)
	if !ok {
		that2, ok := that.(CDNSiteStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.PurgeEpochTimestamp != that1.PurgeEpochTimestamp {
		return false
	}
	if that1.PatternType == nil {
		if this.PatternType != nil {
			return false
		}
	} else if this.PatternType == nil {
		return false
	} else if !this.PatternType.Equal(that1.PatternType) {
		return false
	}
	if that1.PurgeType == nil {
		if this.PurgeType != nil {
			return false
		}
	} else if this.PurgeType == nil {
		return false
	} else if !this.PurgeType.Equal(that1.PurgeType) {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_PurgeAll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_PurgeAll)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_PurgeAll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PurgeAll.Equal(that1.PurgeAll) {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_Url) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_Url)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_Url)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_Hostname) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_Hostname)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_Hostname)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_Pattern) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_Pattern)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_Pattern)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pattern != that1.Pattern {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_SoftPurge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_SoftPurge)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_SoftPurge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SoftPurge.Equal(that1.SoftPurge) {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeRequest_HardPurge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeRequest_HardPurge)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeRequest_HardPurge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HardPurge.Equal(that1.HardPurge) {
		return false
	}
	return true
}
func (this *LilacCDNCachePurgeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LilacCDNCachePurgeResponse)
	if !ok {
		that2, ok := that.(LilacCDNCachePurgeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PurgeRequestId != that1.PurgeRequestId {
		return false
	}
	return true
}
func (this *GetServiceOperationReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetServiceOperationReq)
	if !ok {
		that2, ok := that.(GetServiceOperationReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ServiceOpId != that1.ServiceOpId {
		return false
	}
	return true
}
func (this *PurgeOperationItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PurgeOperationItem)
	if !ok {
		that2, ok := that.(PurgeOperationItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.PurgeTime != that1.PurgeTime {
		return false
	}
	if this.Regexp != that1.Regexp {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.FinishTime != that1.FinishTime {
		return false
	}
	if this.HardPurge != that1.HardPurge {
		return false
	}
	if this.BytesPurged != that1.BytesPurged {
		return false
	}
	if this.BytesNotPurged != that1.BytesNotPurged {
		return false
	}
	return true
}
func (this *ServiceOperationItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceOperationItem)
	if !ok {
		that2, ok := that.(ServiceOperationItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceOpId != that1.ServiceOpId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if that1.OpStatus == nil {
		if this.OpStatus != nil {
			return false
		}
	} else if this.OpStatus == nil {
		return false
	} else if !this.OpStatus.Equal(that1.OpStatus) {
		return false
	}
	return true
}
func (this *ServiceOperationItem_Purge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceOperationItem_Purge)
	if !ok {
		that2, ok := that.(ServiceOperationItem_Purge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Purge.Equal(that1.Purge) {
		return false
	}
	return true
}
func (this *GetServiceOperationRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetServiceOperationRsp)
	if !ok {
		that2, ok := that.(GetServiceOperationRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *ServiceOperationsTimeRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceOperationsTimeRange)
	if !ok {
		that2, ok := that.(ServiceOperationsTimeRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.FinishTime != that1.FinishTime {
		return false
	}
	return true
}
func (this *ListServiceOperationsReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListServiceOperationsReq)
	if !ok {
		that2, ok := that.(ListServiceOperationsReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Options == nil {
		if this.Options != nil {
			return false
		}
	} else if this.Options == nil {
		return false
	} else if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *ListServiceOperationsReq_TimeRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListServiceOperationsReq_TimeRange)
	if !ok {
		that2, ok := that.(ListServiceOperationsReq_TimeRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TimeRange.Equal(that1.TimeRange) {
		return false
	}
	return true
}
func (this *ListServiceOperationsReq_Lastn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListServiceOperationsReq_Lastn)
	if !ok {
		that2, ok := that.(ListServiceOperationsReq_Lastn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Lastn != that1.Lastn {
		return false
	}
	return true
}
func (this *ServiceOperationsItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceOperationsItem)
	if !ok {
		that2, ok := that.(ServiceOperationsItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServiceOpId != that1.ServiceOpId {
		return false
	}
	if this.SvcVersion != that1.SvcVersion {
		return false
	}
	if this.CreatedTime != that1.CreatedTime {
		return false
	}
	if this.ModifiedTime != that1.ModifiedTime {
		return false
	}
	return true
}
func (this *ListServiceOperationsRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListServiceOperationsRsp)
	if !ok {
		that2, ok := that.(ListServiceOperationsRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *CDNControllerStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&common_cdn.CDNControllerStatus{")
	s = append(s, "DeploymentStatus: "+fmt.Sprintf("%#v", this.DeploymentStatus)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "CfgVersion: "+fmt.Sprintf("%#v", this.CfgVersion)+",\n")
	s = append(s, "CpVersion: "+fmt.Sprintf("%#v", this.CpVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNSiteStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&common_cdn.CDNSiteStatus{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNCachePurgeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&common_cdn.LilacCDNCachePurgeRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "PurgeEpochTimestamp: "+fmt.Sprintf("%#v", this.PurgeEpochTimestamp)+",\n")
	if this.PatternType != nil {
		s = append(s, "PatternType: "+fmt.Sprintf("%#v", this.PatternType)+",\n")
	}
	if this.PurgeType != nil {
		s = append(s, "PurgeType: "+fmt.Sprintf("%#v", this.PurgeType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LilacCDNCachePurgeRequest_PurgeAll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_cdn.LilacCDNCachePurgeRequest_PurgeAll{` +
		`PurgeAll:` + fmt.Sprintf("%#v", this.PurgeAll) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_Url) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_cdn.LilacCDNCachePurgeRequest_Url{` +
		`Url:` + fmt.Sprintf("%#v", this.Url) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_Hostname) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_cdn.LilacCDNCachePurgeRequest_Hostname{` +
		`Hostname:` + fmt.Sprintf("%#v", this.Hostname) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_Pattern) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_cdn.LilacCDNCachePurgeRequest_Pattern{` +
		`Pattern:` + fmt.Sprintf("%#v", this.Pattern) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_SoftPurge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_cdn.LilacCDNCachePurgeRequest_SoftPurge{` +
		`SoftPurge:` + fmt.Sprintf("%#v", this.SoftPurge) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeRequest_HardPurge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_cdn.LilacCDNCachePurgeRequest_HardPurge{` +
		`HardPurge:` + fmt.Sprintf("%#v", this.HardPurge) + `}`}, ", ")
	return s
}
func (this *LilacCDNCachePurgeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&common_cdn.LilacCDNCachePurgeResponse{")
	s = append(s, "PurgeRequestId: "+fmt.Sprintf("%#v", this.PurgeRequestId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetServiceOperationReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&common_cdn.GetServiceOperationReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ServiceOpId: "+fmt.Sprintf("%#v", this.ServiceOpId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PurgeOperationItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&common_cdn.PurgeOperationItem{")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "PurgeTime: "+fmt.Sprintf("%#v", this.PurgeTime)+",\n")
	s = append(s, "Regexp: "+fmt.Sprintf("%#v", this.Regexp)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "FinishTime: "+fmt.Sprintf("%#v", this.FinishTime)+",\n")
	s = append(s, "HardPurge: "+fmt.Sprintf("%#v", this.HardPurge)+",\n")
	s = append(s, "BytesPurged: "+fmt.Sprintf("%#v", this.BytesPurged)+",\n")
	s = append(s, "BytesNotPurged: "+fmt.Sprintf("%#v", this.BytesNotPurged)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceOperationItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&common_cdn.ServiceOperationItem{")
	s = append(s, "ServiceOpId: "+fmt.Sprintf("%#v", this.ServiceOpId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.OpStatus != nil {
		s = append(s, "OpStatus: "+fmt.Sprintf("%#v", this.OpStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceOperationItem_Purge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_cdn.ServiceOperationItem_Purge{` +
		`Purge:` + fmt.Sprintf("%#v", this.Purge) + `}`}, ", ")
	return s
}
func (this *GetServiceOperationRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&common_cdn.GetServiceOperationRsp{")
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceOperationsTimeRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&common_cdn.ServiceOperationsTimeRange{")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "FinishTime: "+fmt.Sprintf("%#v", this.FinishTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListServiceOperationsReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&common_cdn.ListServiceOperationsReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListServiceOperationsReq_TimeRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_cdn.ListServiceOperationsReq_TimeRange{` +
		`TimeRange:` + fmt.Sprintf("%#v", this.TimeRange) + `}`}, ", ")
	return s
}
func (this *ListServiceOperationsReq_Lastn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&common_cdn.ListServiceOperationsReq_Lastn{` +
		`Lastn:` + fmt.Sprintf("%#v", this.Lastn) + `}`}, ", ")
	return s
}
func (this *ServiceOperationsItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&common_cdn.ServiceOperationsItem{")
	s = append(s, "ServiceOpId: "+fmt.Sprintf("%#v", this.ServiceOpId)+",\n")
	s = append(s, "SvcVersion: "+fmt.Sprintf("%#v", this.SvcVersion)+",\n")
	s = append(s, "CreatedTime: "+fmt.Sprintf("%#v", this.CreatedTime)+",\n")
	s = append(s, "ModifiedTime: "+fmt.Sprintf("%#v", this.ModifiedTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListServiceOperationsRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&common_cdn.ListServiceOperationsRsp{")
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CDNControllerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNControllerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNControllerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CpVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CpVersion))
		i--
		dAtA[i] = 0x20
	}
	if m.CfgVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CfgVersion))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.DeploymentStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DeploymentStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CDNSiteStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNSiteStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNSiteStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNCachePurgeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNCachePurgeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PatternType != nil {
		{
			size := m.PatternType.Size()
			i -= size
			if _, err := m.PatternType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PurgeType != nil {
		{
			size := m.PurgeType.Size()
			i -= size
			if _, err := m.PurgeType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.PurgeEpochTimestamp) > 0 {
		i -= len(m.PurgeEpochTimestamp)
		copy(dAtA[i:], m.PurgeEpochTimestamp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PurgeEpochTimestamp)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LilacCDNCachePurgeRequest_Pattern) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_Pattern) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Pattern)
	copy(dAtA[i:], m.Pattern)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Pattern)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_SoftPurge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_SoftPurge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SoftPurge != nil {
		{
			size, err := m.SoftPurge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_HardPurge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_HardPurge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HardPurge != nil {
		{
			size, err := m.HardPurge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_PurgeAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_PurgeAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PurgeAll != nil {
		{
			size, err := m.PurgeAll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_Url) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_Url) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Url)
	copy(dAtA[i:], m.Url)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeRequest_Hostname) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeRequest_Hostname) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Hostname)
	copy(dAtA[i:], m.Hostname)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *LilacCDNCachePurgeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LilacCDNCachePurgeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LilacCDNCachePurgeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PurgeRequestId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PurgeRequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetServiceOperationReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetServiceOperationReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetServiceOperationReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServiceOpId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceOpId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PurgeOperationItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PurgeOperationItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PurgeOperationItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BytesNotPurged != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BytesNotPurged))
		i--
		dAtA[i] = 0x40
	}
	if m.BytesPurged != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BytesPurged))
		i--
		dAtA[i] = 0x38
	}
	if m.HardPurge {
		i--
		if m.HardPurge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.FinishTime) > 0 {
		i -= len(m.FinishTime)
		copy(dAtA[i:], m.FinishTime)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FinishTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Regexp) > 0 {
		i -= len(m.Regexp)
		copy(dAtA[i:], m.Regexp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Regexp)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PurgeTime) > 0 {
		i -= len(m.PurgeTime)
		copy(dAtA[i:], m.PurgeTime)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PurgeTime)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceOperationItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOperationItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceOperationItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OpStatus != nil {
		{
			size := m.OpStatus.Size()
			i -= size
			if _, err := m.OpStatus.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if m.ServiceOpId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceOpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceOperationItem_Purge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceOperationItem_Purge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Purge != nil {
		{
			size, err := m.Purge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GetServiceOperationRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetServiceOperationRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetServiceOperationRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceOperationsTimeRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOperationsTimeRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceOperationsTimeRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FinishTime) > 0 {
		i -= len(m.FinishTime)
		copy(dAtA[i:], m.FinishTime)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FinishTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *ListServiceOperationsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListServiceOperationsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListServiceOperationsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		{
			size := m.Options.Size()
			i -= size
			if _, err := m.Options.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListServiceOperationsReq_TimeRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListServiceOperationsReq_TimeRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TimeRange != nil {
		{
			size, err := m.TimeRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ListServiceOperationsReq_Lastn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListServiceOperationsReq_Lastn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Lastn))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *ServiceOperationsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOperationsItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceOperationsItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModifiedTime) > 0 {
		i -= len(m.ModifiedTime)
		copy(dAtA[i:], m.ModifiedTime)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModifiedTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CreatedTime) > 0 {
		i -= len(m.CreatedTime)
		copy(dAtA[i:], m.CreatedTime)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatedTime)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SvcVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SvcVersion))
		i--
		dAtA[i] = 0x10
	}
	if m.ServiceOpId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ServiceOpId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListServiceOperationsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListServiceOperationsRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListServiceOperationsRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CDNControllerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeploymentStatus != 0 {
		n += 1 + sovTypes(uint64(m.DeploymentStatus))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CfgVersion != 0 {
		n += 1 + sovTypes(uint64(m.CfgVersion))
	}
	if m.CpVersion != 0 {
		n += 1 + sovTypes(uint64(m.CpVersion))
	}
	return n
}

func (m *CDNSiteStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LilacCDNCachePurgeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PurgeEpochTimestamp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PatternType != nil {
		n += m.PatternType.Size()
	}
	if m.PurgeType != nil {
		n += m.PurgeType.Size()
	}
	return n
}

func (m *LilacCDNCachePurgeRequest_Pattern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pattern)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *LilacCDNCachePurgeRequest_SoftPurge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SoftPurge != nil {
		l = m.SoftPurge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LilacCDNCachePurgeRequest_HardPurge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HardPurge != nil {
		l = m.HardPurge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LilacCDNCachePurgeRequest_PurgeAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PurgeAll != nil {
		l = m.PurgeAll.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LilacCDNCachePurgeRequest_Url) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *LilacCDNCachePurgeRequest_Hostname) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *LilacCDNCachePurgeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PurgeRequestId != 0 {
		n += 1 + sovTypes(uint64(m.PurgeRequestId))
	}
	return n
}

func (m *GetServiceOperationReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServiceOpId != 0 {
		n += 1 + sovTypes(uint64(m.ServiceOpId))
	}
	return n
}

func (m *PurgeOperationItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PurgeTime)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Regexp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FinishTime)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HardPurge {
		n += 2
	}
	if m.BytesPurged != 0 {
		n += 1 + sovTypes(uint64(m.BytesPurged))
	}
	if m.BytesNotPurged != 0 {
		n += 1 + sovTypes(uint64(m.BytesNotPurged))
	}
	return n
}

func (m *ServiceOperationItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceOpId != 0 {
		n += 1 + sovTypes(uint64(m.ServiceOpId))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OpStatus != nil {
		n += m.OpStatus.Size()
	}
	return n
}

func (m *ServiceOperationItem_Purge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Purge != nil {
		l = m.Purge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetServiceOperationRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ServiceOperationsTimeRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FinishTime)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ListServiceOperationsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Options != nil {
		n += m.Options.Size()
	}
	return n
}

func (m *ListServiceOperationsReq_TimeRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimeRange != nil {
		l = m.TimeRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ListServiceOperationsReq_Lastn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Lastn))
	return n
}
func (m *ServiceOperationsItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceOpId != 0 {
		n += 1 + sovTypes(uint64(m.ServiceOpId))
	}
	if m.SvcVersion != 0 {
		n += 1 + sovTypes(uint64(m.SvcVersion))
	}
	l = len(m.CreatedTime)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ModifiedTime)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ListServiceOperationsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CDNControllerStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNControllerStatus{`,
		`DeploymentStatus:` + fmt.Sprintf("%v", this.DeploymentStatus) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`CfgVersion:` + fmt.Sprintf("%v", this.CfgVersion) + `,`,
		`CpVersion:` + fmt.Sprintf("%v", this.CpVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNSiteStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNSiteStatus{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`PurgeEpochTimestamp:` + fmt.Sprintf("%v", this.PurgeEpochTimestamp) + `,`,
		`PatternType:` + fmt.Sprintf("%v", this.PatternType) + `,`,
		`PurgeType:` + fmt.Sprintf("%v", this.PurgeType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_Pattern) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_Pattern{`,
		`Pattern:` + fmt.Sprintf("%v", this.Pattern) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_SoftPurge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_SoftPurge{`,
		`SoftPurge:` + strings.Replace(fmt.Sprintf("%v", this.SoftPurge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_HardPurge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_HardPurge{`,
		`HardPurge:` + strings.Replace(fmt.Sprintf("%v", this.HardPurge), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_PurgeAll) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_PurgeAll{`,
		`PurgeAll:` + strings.Replace(fmt.Sprintf("%v", this.PurgeAll), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_Url) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_Url{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeRequest_Hostname) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeRequest_Hostname{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LilacCDNCachePurgeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LilacCDNCachePurgeResponse{`,
		`PurgeRequestId:` + fmt.Sprintf("%v", this.PurgeRequestId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetServiceOperationReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetServiceOperationReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ServiceOpId:` + fmt.Sprintf("%v", this.ServiceOpId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PurgeOperationItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PurgeOperationItem{`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`PurgeTime:` + fmt.Sprintf("%v", this.PurgeTime) + `,`,
		`Regexp:` + fmt.Sprintf("%v", this.Regexp) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`FinishTime:` + fmt.Sprintf("%v", this.FinishTime) + `,`,
		`HardPurge:` + fmt.Sprintf("%v", this.HardPurge) + `,`,
		`BytesPurged:` + fmt.Sprintf("%v", this.BytesPurged) + `,`,
		`BytesNotPurged:` + fmt.Sprintf("%v", this.BytesNotPurged) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceOperationItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceOperationItem{`,
		`ServiceOpId:` + fmt.Sprintf("%v", this.ServiceOpId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`OpStatus:` + fmt.Sprintf("%v", this.OpStatus) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceOperationItem_Purge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceOperationItem_Purge{`,
		`Purge:` + strings.Replace(fmt.Sprintf("%v", this.Purge), "PurgeOperationItem", "PurgeOperationItem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetServiceOperationRsp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*ServiceOperationItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "ServiceOperationItem", "ServiceOperationItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&GetServiceOperationRsp{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "ErrorType", "schema.ErrorType", 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceOperationsTimeRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceOperationsTimeRange{`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`FinishTime:` + fmt.Sprintf("%v", this.FinishTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListServiceOperationsReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListServiceOperationsReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListServiceOperationsReq_TimeRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListServiceOperationsReq_TimeRange{`,
		`TimeRange:` + strings.Replace(fmt.Sprintf("%v", this.TimeRange), "ServiceOperationsTimeRange", "ServiceOperationsTimeRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListServiceOperationsReq_Lastn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListServiceOperationsReq_Lastn{`,
		`Lastn:` + fmt.Sprintf("%v", this.Lastn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceOperationsItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceOperationsItem{`,
		`ServiceOpId:` + fmt.Sprintf("%v", this.ServiceOpId) + `,`,
		`SvcVersion:` + fmt.Sprintf("%v", this.SvcVersion) + `,`,
		`CreatedTime:` + fmt.Sprintf("%v", this.CreatedTime) + `,`,
		`ModifiedTime:` + fmt.Sprintf("%v", this.ModifiedTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListServiceOperationsRsp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*ServiceOperationsItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "ServiceOperationsItem", "ServiceOperationsItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ListServiceOperationsRsp{`,
		`Error:` + strings.Replace(fmt.Sprintf("%v", this.Error), "ErrorType", "schema.ErrorType", 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CDNControllerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNControllerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNControllerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentStatus", wireType)
			}
			m.DeploymentStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentStatus |= CDNLoadbalancerDeploymentStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgVersion", wireType)
			}
			m.CfgVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CfgVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpVersion", wireType)
			}
			m.CpVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNSiteStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNSiteStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNSiteStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CDNSiteDeploymentStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNCachePurgeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNCachePurgeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNCachePurgeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeEpochTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurgeEpochTimestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternType = &LilacCDNCachePurgeRequest_Pattern{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftPurge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PurgeType = &LilacCDNCachePurgeRequest_SoftPurge{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardPurge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PurgeType = &LilacCDNCachePurgeRequest_HardPurge{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PatternType = &LilacCDNCachePurgeRequest_PurgeAll{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternType = &LilacCDNCachePurgeRequest_Url{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternType = &LilacCDNCachePurgeRequest_Hostname{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LilacCDNCachePurgeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LilacCDNCachePurgeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LilacCDNCachePurgeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeRequestId", wireType)
			}
			m.PurgeRequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PurgeRequestId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetServiceOperationReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetServiceOperationReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetServiceOperationReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceOpId", wireType)
			}
			m.ServiceOpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceOpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PurgeOperationItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PurgeOperationItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PurgeOperationItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurgeTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regexp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regexp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinishTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardPurge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HardPurge = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesPurged", wireType)
			}
			m.BytesPurged = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesPurged |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesNotPurged", wireType)
			}
			m.BytesNotPurged = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesNotPurged |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOperationItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOperationItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOperationItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceOpId", wireType)
			}
			m.ServiceOpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceOpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PurgeOperationItem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OpStatus = &ServiceOperationItem_Purge{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetServiceOperationRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetServiceOperationRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetServiceOperationRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &schema.ErrorType{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ServiceOperationItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOperationsTimeRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOperationsTimeRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOperationsTimeRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinishTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListServiceOperationsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListServiceOperationsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListServiceOperationsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ServiceOperationsTimeRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &ListServiceOperationsReq_TimeRange{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Options = &ListServiceOperationsReq_Lastn{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOperationsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOperationsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOperationsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceOpId", wireType)
			}
			m.ServiceOpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceOpId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvcVersion", wireType)
			}
			m.SvcVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SvcVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModifiedTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListServiceOperationsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListServiceOperationsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListServiceOperationsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &schema.ErrorType{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ServiceOperationsItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
