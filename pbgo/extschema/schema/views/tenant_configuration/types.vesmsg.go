// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package tenant_configuration

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *BasicConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BasicConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BasicConfiguration) DeepCopy() *BasicConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BasicConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BasicConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BasicConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BasicConfigurationValidator().Validate(ctx, m, opts...)
}

type ValidateBasicConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBasicConfiguration) DisplayNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for display_name")
	}

	return validatorFn, nil
}

func (v *ValidateBasicConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BasicConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BasicConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["display_name"]; exists {

		vOpts := append(opts, db.WithValidateField("display_name"))
		if err := fv(ctx, m.GetDisplayName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBasicConfigurationValidator = func() *ValidateBasicConfiguration {
	v := &ValidateBasicConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDisplayName := v.DisplayNameValidationRuleHandler
	rulesDisplayName := map[string]string{
		"ves.io.schema.rules.string.max_len": "255",
	}
	vFn, err = vrhDisplayName(rulesDisplayName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BasicConfiguration.display_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["display_name"] = vFn

	return v
}()

func BasicConfigurationValidator() db.Validator {
	return DefaultBasicConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *BruteForceDetectionSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BruteForceDetectionSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BruteForceDetectionSettings) DeepCopy() *BruteForceDetectionSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BruteForceDetectionSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BruteForceDetectionSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BruteForceDetectionSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BruteForceDetectionSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateBruteForceDetectionSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBruteForceDetectionSettings) MaxLoginFailuresValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_login_failures")
	}

	return validatorFn, nil
}

func (v *ValidateBruteForceDetectionSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BruteForceDetectionSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BruteForceDetectionSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["max_login_failures"]; exists {

		vOpts := append(opts, db.WithValidateField("max_login_failures"))
		if err := fv(ctx, m.GetMaxLoginFailures(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBruteForceDetectionSettingsValidator = func() *ValidateBruteForceDetectionSettings {
	v := &ValidateBruteForceDetectionSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMaxLoginFailures := v.MaxLoginFailuresValidationRuleHandler
	rulesMaxLoginFailures := map[string]string{
		"ves.io.schema.rules.uint32.lte": "30",
	}
	vFn, err = vrhMaxLoginFailures(rulesMaxLoginFailures)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BruteForceDetectionSettings.max_login_failures: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_login_failures"] = vFn

	return v
}()

func BruteForceDetectionSettingsValidator() db.Validator {
	return DefaultBruteForceDetectionSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["basic_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("basic_configuration"))
		if err := fv(ctx, m.GetBasicConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["brute_force_detection_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("brute_force_detection_settings"))
		if err := fv(ctx, m.GetBruteForceDetectionSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["password_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("password_policy"))
		if err := fv(ctx, m.GetPasswordPolicy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["basic_configuration"] = BasicConfigurationValidator().Validate

	v.FldValidators["brute_force_detection_settings"] = BruteForceDetectionSettingsValidator().Validate

	v.FldValidators["password_policy"] = PasswordPolicyValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["basic_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("basic_configuration"))
		if err := fv(ctx, m.GetBasicConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["brute_force_detection_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("brute_force_detection_settings"))
		if err := fv(ctx, m.GetBruteForceDetectionSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["password_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("password_policy"))
		if err := fv(ctx, m.GetPasswordPolicy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["basic_configuration"] = BasicConfigurationValidator().Validate

	v.FldValidators["brute_force_detection_settings"] = BruteForceDetectionSettingsValidator().Validate

	v.FldValidators["password_policy"] = PasswordPolicyValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["basic_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("basic_configuration"))
		if err := fv(ctx, m.GetBasicConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["brute_force_detection_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("brute_force_detection_settings"))
		if err := fv(ctx, m.GetBruteForceDetectionSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["password_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("password_policy"))
		if err := fv(ctx, m.GetPasswordPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["session_management"]; exists {

		vOpts := append(opts, db.WithValidateField("session_management"))
		if err := fv(ctx, m.GetSessionManagement(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["basic_configuration"] = BasicConfigurationValidator().Validate

	v.FldValidators["brute_force_detection_settings"] = BruteForceDetectionSettingsValidator().Validate

	v.FldValidators["password_policy"] = PasswordPolicyValidator().Validate

	v.FldValidators["session_management"] = SessionManagementValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PasswordPolicy) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PasswordPolicy) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PasswordPolicy) DeepCopy() *PasswordPolicy {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PasswordPolicy{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PasswordPolicy) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PasswordPolicy) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PasswordPolicyValidator().Validate(ctx, m, opts...)
}

type ValidatePasswordPolicy struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePasswordPolicy) DigitsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for digits")
	}

	return validatorFn, nil
}

func (v *ValidatePasswordPolicy) LowercaseCharactersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for lowercase_characters")
	}

	return validatorFn, nil
}

func (v *ValidatePasswordPolicy) UppercaseCharactersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for uppercase_characters")
	}

	return validatorFn, nil
}

func (v *ValidatePasswordPolicy) SpecialCharactersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for special_characters")
	}

	return validatorFn, nil
}

func (v *ValidatePasswordPolicy) ExpirePasswordValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for expire_password")
	}

	return validatorFn, nil
}

func (v *ValidatePasswordPolicy) MinimumLengthValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for minimum_length")
	}

	return validatorFn, nil
}

func (v *ValidatePasswordPolicy) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PasswordPolicy)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PasswordPolicy got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["digits"]; exists {

		vOpts := append(opts, db.WithValidateField("digits"))
		if err := fv(ctx, m.GetDigits(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["expire_password"]; exists {

		vOpts := append(opts, db.WithValidateField("expire_password"))
		if err := fv(ctx, m.GetExpirePassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lowercase_characters"]; exists {

		vOpts := append(opts, db.WithValidateField("lowercase_characters"))
		if err := fv(ctx, m.GetLowercaseCharacters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["minimum_length"]; exists {

		vOpts := append(opts, db.WithValidateField("minimum_length"))
		if err := fv(ctx, m.GetMinimumLength(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_recently_used"]; exists {

		vOpts := append(opts, db.WithValidateField("not_recently_used"))
		if err := fv(ctx, m.GetNotRecentlyUsed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_username"]; exists {

		vOpts := append(opts, db.WithValidateField("not_username"))
		if err := fv(ctx, m.GetNotUsername(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["special_characters"]; exists {

		vOpts := append(opts, db.WithValidateField("special_characters"))
		if err := fv(ctx, m.GetSpecialCharacters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uppercase_characters"]; exists {

		vOpts := append(opts, db.WithValidateField("uppercase_characters"))
		if err := fv(ctx, m.GetUppercaseCharacters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPasswordPolicyValidator = func() *ValidatePasswordPolicy {
	v := &ValidatePasswordPolicy{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDigits := v.DigitsValidationRuleHandler
	rulesDigits := map[string]string{
		"ves.io.schema.rules.uint32.lte": "16",
	}
	vFn, err = vrhDigits(rulesDigits)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PasswordPolicy.digits: %s", err)
		panic(errMsg)
	}
	v.FldValidators["digits"] = vFn

	vrhLowercaseCharacters := v.LowercaseCharactersValidationRuleHandler
	rulesLowercaseCharacters := map[string]string{
		"ves.io.schema.rules.uint32.lte": "16",
	}
	vFn, err = vrhLowercaseCharacters(rulesLowercaseCharacters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PasswordPolicy.lowercase_characters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["lowercase_characters"] = vFn

	vrhUppercaseCharacters := v.UppercaseCharactersValidationRuleHandler
	rulesUppercaseCharacters := map[string]string{
		"ves.io.schema.rules.uint32.lte": "16",
	}
	vFn, err = vrhUppercaseCharacters(rulesUppercaseCharacters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PasswordPolicy.uppercase_characters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["uppercase_characters"] = vFn

	vrhSpecialCharacters := v.SpecialCharactersValidationRuleHandler
	rulesSpecialCharacters := map[string]string{
		"ves.io.schema.rules.uint32.lte": "16",
	}
	vFn, err = vrhSpecialCharacters(rulesSpecialCharacters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PasswordPolicy.special_characters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["special_characters"] = vFn

	vrhExpirePassword := v.ExpirePasswordValidationRuleHandler
	rulesExpirePassword := map[string]string{
		"ves.io.schema.rules.uint32.lte": "1080",
	}
	vFn, err = vrhExpirePassword(rulesExpirePassword)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PasswordPolicy.expire_password: %s", err)
		panic(errMsg)
	}
	v.FldValidators["expire_password"] = vFn

	vrhMinimumLength := v.MinimumLengthValidationRuleHandler
	rulesMinimumLength := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "7",
	}
	vFn, err = vrhMinimumLength(rulesMinimumLength)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PasswordPolicy.minimum_length: %s", err)
		panic(errMsg)
	}
	v.FldValidators["minimum_length"] = vFn

	return v
}()

func PasswordPolicyValidator() db.Validator {
	return DefaultPasswordPolicyValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["basic_configuration"]; exists {

		vOpts := append(opts, db.WithValidateField("basic_configuration"))
		if err := fv(ctx, m.GetBasicConfiguration(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["brute_force_detection_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("brute_force_detection_settings"))
		if err := fv(ctx, m.GetBruteForceDetectionSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["password_policy"]; exists {

		vOpts := append(opts, db.WithValidateField("password_policy"))
		if err := fv(ctx, m.GetPasswordPolicy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["basic_configuration"] = BasicConfigurationValidator().Validate

	v.FldValidators["brute_force_detection_settings"] = BruteForceDetectionSettingsValidator().Validate

	v.FldValidators["password_policy"] = PasswordPolicyValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SessionManagement) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SessionManagement) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SessionManagement) DeepCopy() *SessionManagement {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SessionManagement{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SessionManagement) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SessionManagement) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SessionManagementValidator().Validate(ctx, m, opts...)
}

type ValidateSessionManagement struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSessionManagement) CookieExpiryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie_expiry")
	}

	return validatorFn, nil
}

func (v *ValidateSessionManagement) SessionExpiryValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for session_expiry")
	}

	return validatorFn, nil
}

func (v *ValidateSessionManagement) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SessionManagement)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SessionManagement got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_expiry"))
		if err := fv(ctx, m.GetCookieExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookie_refresh_interval"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_refresh_interval"))
		if err := fv(ctx, m.GetCookieRefreshInterval(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["session_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("session_expiry"))
		if err := fv(ctx, m.GetSessionExpiry(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSessionManagementValidator = func() *ValidateSessionManagement {
	v := &ValidateSessionManagement{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCookieExpiry := v.CookieExpiryValidationRuleHandler
	rulesCookieExpiry := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "60",
		"ves.io.schema.rules.uint32.lte":       "86400",
	}
	vFn, err = vrhCookieExpiry(rulesCookieExpiry)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SessionManagement.cookie_expiry: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_expiry"] = vFn

	vrhSessionExpiry := v.SessionExpiryValidationRuleHandler
	rulesSessionExpiry := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "60",
		"ves.io.schema.rules.uint32.lte":       "86400",
	}
	vFn, err = vrhSessionExpiry(rulesSessionExpiry)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SessionManagement.session_expiry: %s", err)
		panic(errMsg)
	}
	v.FldValidators["session_expiry"] = vFn

	return v
}()

func SessionManagementValidator() db.Validator {
	return DefaultSessionManagementValidator
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.BasicConfiguration = f.GetBasicConfiguration()
	m.BruteForceDetectionSettings = f.GetBruteForceDetectionSettings()
	m.PasswordPolicy = f.GetPasswordPolicy()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.BasicConfiguration = m1.BasicConfiguration
	f.BruteForceDetectionSettings = m1.BruteForceDetectionSettings
	f.PasswordPolicy = m1.PasswordPolicy
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.BasicConfiguration = f.GetBasicConfiguration()
	m.BruteForceDetectionSettings = f.GetBruteForceDetectionSettings()
	m.PasswordPolicy = f.GetPasswordPolicy()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.BasicConfiguration = m1.BasicConfiguration
	f.BruteForceDetectionSettings = m1.BruteForceDetectionSettings
	f.PasswordPolicy = m1.PasswordPolicy
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.BasicConfiguration = f.GetBasicConfiguration()
	m.BruteForceDetectionSettings = f.GetBruteForceDetectionSettings()
	m.PasswordPolicy = f.GetPasswordPolicy()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.BasicConfiguration = m1.BasicConfiguration
	f.BruteForceDetectionSettings = m1.BruteForceDetectionSettings
	f.PasswordPolicy = m1.PasswordPolicy
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
