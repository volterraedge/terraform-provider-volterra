// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/tenant_configuration/types.proto

package tenant_configuration

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BasicConfiguration
//
// x-displayName: "BasicConfiguration"
type BasicConfiguration struct {
	// Display Name
	//
	// x-displayName: "Display Name"
	// x-example: "value"
	// Tenant display name in the login screen
	DisplayName string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *BasicConfiguration) Reset()      { *m = BasicConfiguration{} }
func (*BasicConfiguration) ProtoMessage() {}
func (*BasicConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_364750f54271448d, []int{0}
}
func (m *BasicConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BasicConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicConfiguration.Merge(m, src)
}
func (m *BasicConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *BasicConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_BasicConfiguration proto.InternalMessageInfo

func (m *BasicConfiguration) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// BruteForceDetectionSettings
//
// x-displayName: "BruteForceDetectionSettings"
type BruteForceDetectionSettings struct {
	// Max Login Failures
	//
	// x-displayName: "Max Login Failures"
	// x-example: "5"
	// How many failures before wait is triggered.
	// When login failure count is hit, user will be temporarily locked for a max duration of 15 minutes.
	MaxLoginFailures uint32 `protobuf:"varint,1,opt,name=max_login_failures,json=maxLoginFailures,proto3" json:"max_login_failures,omitempty"`
}

func (m *BruteForceDetectionSettings) Reset()      { *m = BruteForceDetectionSettings{} }
func (*BruteForceDetectionSettings) ProtoMessage() {}
func (*BruteForceDetectionSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_364750f54271448d, []int{1}
}
func (m *BruteForceDetectionSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BruteForceDetectionSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BruteForceDetectionSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BruteForceDetectionSettings.Merge(m, src)
}
func (m *BruteForceDetectionSettings) XXX_Size() int {
	return m.Size()
}
func (m *BruteForceDetectionSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_BruteForceDetectionSettings.DiscardUnknown(m)
}

var xxx_messageInfo_BruteForceDetectionSettings proto.InternalMessageInfo

func (m *BruteForceDetectionSettings) GetMaxLoginFailures() uint32 {
	if m != nil {
		return m.MaxLoginFailures
	}
	return 0
}

// PasswordPolicy
//
// x-displayName: "PasswordPolicy"
type PasswordPolicy struct {
	// Digits
	//
	// x-displayName: "Min Number Of Digits"
	// x-example: "1"
	// The number of digits required to be in the password string.
	Digits uint32 `protobuf:"varint,1,opt,name=digits,proto3" json:"digits,omitempty"`
	// Lowercase Characters
	//
	// x-displayName: "Min Number Of Lowercase Characters"
	// x-example: "8"
	// The number of lower case letters required to be in the password string.
	LowercaseCharacters uint32 `protobuf:"varint,2,opt,name=lowercase_characters,json=lowercaseCharacters,proto3" json:"lowercase_characters,omitempty"`
	// Uppercase Characters
	//
	// x-displayName: "Min Number Of Uppercase Characters"
	// x-example: "2"
	// The number of upper case letters required to be in the password string.
	UppercaseCharacters uint32 `protobuf:"varint,3,opt,name=uppercase_characters,json=uppercaseCharacters,proto3" json:"uppercase_characters,omitempty"`
	// Special Characters
	//
	// x-displayName: "Min Number Of Special Characters"
	// x-example: "1"
	// The number of special characters like '?!#%$' required to be in the password string.
	SpecialCharacters uint32 `protobuf:"varint,4,opt,name=special_characters,json=specialCharacters,proto3" json:"special_characters,omitempty"`
	// Not Username
	//
	// x-displayName: "Not Username"
	// When set, the password is not allowed to be the same as the username.
	NotUsername bool `protobuf:"varint,5,opt,name=not_username,json=notUsername,proto3" json:"not_username,omitempty"`
	// Expire Password
	//
	// x-displayName: "Expire Password"
	// x-example: "30"
	// The number of days for which the password is valid.
	// After the number of days has expired, the user is required to change their password.
	ExpirePassword uint32 `protobuf:"varint,6,opt,name=expire_password,json=expirePassword,proto3" json:"expire_password,omitempty"`
	// Not Recently Used
	//
	// x-displayName: "Not Recently Used"
	// x-example: "2"
	// This policy is used to restrict user from using previously used passwords.
	// Number that's set determines number of last passwords which user cannot use as new password.
	NotRecentlyUsed uint32 `protobuf:"varint,7,opt,name=not_recently_used,json=notRecentlyUsed,proto3" json:"not_recently_used,omitempty"`
	// Minimum Length
	//
	// x-displayName: "Minimum Length"
	// x-required
	// x-example: "12"
	// Minimum length of password.
	MinimumLength uint32 `protobuf:"varint,8,opt,name=minimum_length,json=minimumLength,proto3" json:"minimum_length,omitempty"`
}

func (m *PasswordPolicy) Reset()      { *m = PasswordPolicy{} }
func (*PasswordPolicy) ProtoMessage() {}
func (*PasswordPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_364750f54271448d, []int{2}
}
func (m *PasswordPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PasswordPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PasswordPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PasswordPolicy.Merge(m, src)
}
func (m *PasswordPolicy) XXX_Size() int {
	return m.Size()
}
func (m *PasswordPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_PasswordPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_PasswordPolicy proto.InternalMessageInfo

func (m *PasswordPolicy) GetDigits() uint32 {
	if m != nil {
		return m.Digits
	}
	return 0
}

func (m *PasswordPolicy) GetLowercaseCharacters() uint32 {
	if m != nil {
		return m.LowercaseCharacters
	}
	return 0
}

func (m *PasswordPolicy) GetUppercaseCharacters() uint32 {
	if m != nil {
		return m.UppercaseCharacters
	}
	return 0
}

func (m *PasswordPolicy) GetSpecialCharacters() uint32 {
	if m != nil {
		return m.SpecialCharacters
	}
	return 0
}

func (m *PasswordPolicy) GetNotUsername() bool {
	if m != nil {
		return m.NotUsername
	}
	return false
}

func (m *PasswordPolicy) GetExpirePassword() uint32 {
	if m != nil {
		return m.ExpirePassword
	}
	return 0
}

func (m *PasswordPolicy) GetNotRecentlyUsed() uint32 {
	if m != nil {
		return m.NotRecentlyUsed
	}
	return 0
}

func (m *PasswordPolicy) GetMinimumLength() uint32 {
	if m != nil {
		return m.MinimumLength
	}
	return 0
}

// SessionManagement
//
// x-displayName: "SessionManagement"
type SessionManagement struct {
	// Session Cookie Expiry
	//
	// x-displayName: "Session Cookie Expiry"
	// x-required
	// x-example: "900"
	// Session cookie expiry in seconds.
	// The user will be logged-out after these many seconds, if inactive on the console.
	CookieExpiry uint32 `protobuf:"varint,1,opt,name=cookie_expiry,json=cookieExpiry,proto3" json:"cookie_expiry,omitempty"`
	// Session Cookie Refresh Interval
	//
	// x-displayName: "Session Cookie Refresh Interval"
	// x-example: "840"
	// Session cookie refresh interval in seconds.
	// The session cookie will be renewed when (expiry - current_timestamp < cookie_refresh_interval) and (max_session_expiry - expiry > cookie_refresh_interval ), otherwise, the existing cookie will be re-used
	CookieRefreshInterval uint32 `protobuf:"varint,2,opt,name=cookie_refresh_interval,json=cookieRefreshInterval,proto3" json:"cookie_refresh_interval,omitempty"`
	// Maximum Session Expiry
	//
	// x-displayName: "Maximum Session Expiry"
	// x-required
	// x-example: "86400"
	// Maximum session expiry in seconds.
	// The user will be prompted for a re-login after this interval in spite of being active on the console
	SessionExpiry uint32 `protobuf:"varint,3,opt,name=session_expiry,json=sessionExpiry,proto3" json:"session_expiry,omitempty"`
}

func (m *SessionManagement) Reset()      { *m = SessionManagement{} }
func (*SessionManagement) ProtoMessage() {}
func (*SessionManagement) Descriptor() ([]byte, []int) {
	return fileDescriptor_364750f54271448d, []int{3}
}
func (m *SessionManagement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionManagement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SessionManagement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionManagement.Merge(m, src)
}
func (m *SessionManagement) XXX_Size() int {
	return m.Size()
}
func (m *SessionManagement) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionManagement.DiscardUnknown(m)
}

var xxx_messageInfo_SessionManagement proto.InternalMessageInfo

func (m *SessionManagement) GetCookieExpiry() uint32 {
	if m != nil {
		return m.CookieExpiry
	}
	return 0
}

func (m *SessionManagement) GetCookieRefreshInterval() uint32 {
	if m != nil {
		return m.CookieRefreshInterval
	}
	return 0
}

func (m *SessionManagement) GetSessionExpiry() uint32 {
	if m != nil {
		return m.SessionExpiry
	}
	return 0
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Shape of the tenant configuration specification
type GlobalSpecType struct {
	// Basic Configuration
	//
	// x-displayName: "Basic Configuration"
	// Basic configuration contains general parameters which can be adjusted within tenant.
	BasicConfiguration *BasicConfiguration `protobuf:"bytes,1,opt,name=basic_configuration,json=basicConfiguration,proto3" json:"basic_configuration,omitempty"`
	// Brute Force Detection Settings
	//
	// x-displayName: "Brute Force Detection Settings"
	// Our brute force detection system uses temporary lockout algorithm.
	// Temporary lockout will disable a userâ€™s account for a time period after an attack is detected;
	// the time period for which the account is disabled increases the longer the attack continues.
	// You can adjust some parameters of the brute force detection system.
	BruteForceDetectionSettings *BruteForceDetectionSettings `protobuf:"bytes,2,opt,name=brute_force_detection_settings,json=bruteForceDetectionSettings,proto3" json:"brute_force_detection_settings,omitempty"`
	// Password Policy
	//
	// x-displayName: "Password Policy"
	// Password policy allows you to configure your own password policy within tenant.
	// Each user within tenant will have to comply with the configured policy when they set or update the password.
	PasswordPolicy *PasswordPolicy `protobuf:"bytes,3,opt,name=password_policy,json=passwordPolicy,proto3" json:"password_policy,omitempty"`
	// Session Managemement
	//
	// x-displayName: "Session Managemement"
	// Session management allows you to configure the session attributes such as cookie expiry, etc.
	SessionManagement *SessionManagement `protobuf:"bytes,4,opt,name=session_management,json=sessionManagement,proto3" json:"session_management,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_364750f54271448d, []int{4}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetBasicConfiguration() *BasicConfiguration {
	if m != nil {
		return m.BasicConfiguration
	}
	return nil
}

func (m *GlobalSpecType) GetBruteForceDetectionSettings() *BruteForceDetectionSettings {
	if m != nil {
		return m.BruteForceDetectionSettings
	}
	return nil
}

func (m *GlobalSpecType) GetPasswordPolicy() *PasswordPolicy {
	if m != nil {
		return m.PasswordPolicy
	}
	return nil
}

func (m *GlobalSpecType) GetSessionManagement() *SessionManagement {
	if m != nil {
		return m.SessionManagement
	}
	return nil
}

// CreateSpecType
//
// x-displayName: "Create tenant configuration"
// Shape of the tenant configuration specification
type CreateSpecType struct {
	BasicConfiguration          *BasicConfiguration          `protobuf:"bytes,1,opt,name=basic_configuration,json=basicConfiguration,proto3" json:"basic_configuration,omitempty"`
	BruteForceDetectionSettings *BruteForceDetectionSettings `protobuf:"bytes,2,opt,name=brute_force_detection_settings,json=bruteForceDetectionSettings,proto3" json:"brute_force_detection_settings,omitempty"`
	PasswordPolicy              *PasswordPolicy              `protobuf:"bytes,3,opt,name=password_policy,json=passwordPolicy,proto3" json:"password_policy,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_364750f54271448d, []int{5}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetBasicConfiguration() *BasicConfiguration {
	if m != nil {
		return m.BasicConfiguration
	}
	return nil
}

func (m *CreateSpecType) GetBruteForceDetectionSettings() *BruteForceDetectionSettings {
	if m != nil {
		return m.BruteForceDetectionSettings
	}
	return nil
}

func (m *CreateSpecType) GetPasswordPolicy() *PasswordPolicy {
	if m != nil {
		return m.PasswordPolicy
	}
	return nil
}

// ReplaceSpecType
//
// x-displayName: "Replace tenant configuration"
// Shape of the tenant configuration specification
type ReplaceSpecType struct {
	BasicConfiguration          *BasicConfiguration          `protobuf:"bytes,1,opt,name=basic_configuration,json=basicConfiguration,proto3" json:"basic_configuration,omitempty"`
	BruteForceDetectionSettings *BruteForceDetectionSettings `protobuf:"bytes,2,opt,name=brute_force_detection_settings,json=bruteForceDetectionSettings,proto3" json:"brute_force_detection_settings,omitempty"`
	PasswordPolicy              *PasswordPolicy              `protobuf:"bytes,3,opt,name=password_policy,json=passwordPolicy,proto3" json:"password_policy,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_364750f54271448d, []int{6}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetBasicConfiguration() *BasicConfiguration {
	if m != nil {
		return m.BasicConfiguration
	}
	return nil
}

func (m *ReplaceSpecType) GetBruteForceDetectionSettings() *BruteForceDetectionSettings {
	if m != nil {
		return m.BruteForceDetectionSettings
	}
	return nil
}

func (m *ReplaceSpecType) GetPasswordPolicy() *PasswordPolicy {
	if m != nil {
		return m.PasswordPolicy
	}
	return nil
}

// GetSpecType
//
// x-displayName: "Get tenant configuration"
// Shape of the tenant configuration specification
type GetSpecType struct {
	BasicConfiguration          *BasicConfiguration          `protobuf:"bytes,1,opt,name=basic_configuration,json=basicConfiguration,proto3" json:"basic_configuration,omitempty"`
	BruteForceDetectionSettings *BruteForceDetectionSettings `protobuf:"bytes,2,opt,name=brute_force_detection_settings,json=bruteForceDetectionSettings,proto3" json:"brute_force_detection_settings,omitempty"`
	PasswordPolicy              *PasswordPolicy              `protobuf:"bytes,3,opt,name=password_policy,json=passwordPolicy,proto3" json:"password_policy,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_364750f54271448d, []int{7}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetBasicConfiguration() *BasicConfiguration {
	if m != nil {
		return m.BasicConfiguration
	}
	return nil
}

func (m *GetSpecType) GetBruteForceDetectionSettings() *BruteForceDetectionSettings {
	if m != nil {
		return m.BruteForceDetectionSettings
	}
	return nil
}

func (m *GetSpecType) GetPasswordPolicy() *PasswordPolicy {
	if m != nil {
		return m.PasswordPolicy
	}
	return nil
}

func init() {
	proto.RegisterType((*BasicConfiguration)(nil), "ves.io.schema.views.tenant_configuration.BasicConfiguration")
	golang_proto.RegisterType((*BasicConfiguration)(nil), "ves.io.schema.views.tenant_configuration.BasicConfiguration")
	proto.RegisterType((*BruteForceDetectionSettings)(nil), "ves.io.schema.views.tenant_configuration.BruteForceDetectionSettings")
	golang_proto.RegisterType((*BruteForceDetectionSettings)(nil), "ves.io.schema.views.tenant_configuration.BruteForceDetectionSettings")
	proto.RegisterType((*PasswordPolicy)(nil), "ves.io.schema.views.tenant_configuration.PasswordPolicy")
	golang_proto.RegisterType((*PasswordPolicy)(nil), "ves.io.schema.views.tenant_configuration.PasswordPolicy")
	proto.RegisterType((*SessionManagement)(nil), "ves.io.schema.views.tenant_configuration.SessionManagement")
	golang_proto.RegisterType((*SessionManagement)(nil), "ves.io.schema.views.tenant_configuration.SessionManagement")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.tenant_configuration.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.views.tenant_configuration.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.tenant_configuration.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.views.tenant_configuration.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.tenant_configuration.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.views.tenant_configuration.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.tenant_configuration.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.views.tenant_configuration.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/tenant_configuration/types.proto", fileDescriptor_364750f54271448d)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/tenant_configuration/types.proto", fileDescriptor_364750f54271448d)
}

var fileDescriptor_364750f54271448d = []byte{
	// 917 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0xcf, 0x6f, 0xdc, 0x44,
	0x14, 0xde, 0x89, 0x9b, 0x1f, 0x9d, 0xcd, 0x6e, 0xba, 0x2e, 0x08, 0xb3, 0x41, 0x26, 0xdd, 0xd3,
	0x2a, 0x22, 0xde, 0x90, 0x56, 0x10, 0x20, 0x80, 0xd8, 0xd0, 0x56, 0x48, 0x05, 0x55, 0x0e, 0xe5,
	0xc0, 0x01, 0x6b, 0x6c, 0xbf, 0xf5, 0x8e, 0x6a, 0x7b, 0xac, 0x99, 0xf1, 0x26, 0x7b, 0xa8, 0x54,
	0xc1, 0x05, 0x71, 0xe2, 0x0f, 0x40, 0xe2, 0xc0, 0x85, 0x3f, 0x01, 0x11, 0x0e, 0x3d, 0x22, 0x4e,
	0x39, 0xa1, 0xa8, 0x27, 0xb2, 0xb9, 0x94, 0x9e, 0xfa, 0x1f, 0x14, 0xd9, 0x9e, 0x0d, 0xfb, 0x23,
	0x40, 0xb8, 0xb4, 0x97, 0xdc, 0x76, 0xfd, 0xbe, 0xef, 0x7b, 0x6f, 0xde, 0xe7, 0xcf, 0x1a, 0x7c,
	0xad, 0x07, 0xc2, 0xa2, 0xac, 0x25, 0xbc, 0x2e, 0x44, 0xa4, 0xd5, 0xa3, 0xb0, 0x2b, 0x5a, 0x12,
	0x62, 0x12, 0x4b, 0xc7, 0x63, 0x71, 0x87, 0x06, 0x29, 0x27, 0x92, 0xb2, 0xb8, 0x25, 0xfb, 0x09,
	0x08, 0x2b, 0xe1, 0x4c, 0x32, 0xbd, 0x59, 0xb0, 0xac, 0x82, 0x65, 0xe5, 0x2c, 0xeb, 0x34, 0x56,
	0x7d, 0x2d, 0xa0, 0xb2, 0x9b, 0xba, 0x96, 0xc7, 0xa2, 0x56, 0xc0, 0x02, 0xd6, 0xca, 0x05, 0xdc,
	0xb4, 0x93, 0xff, 0xcb, 0xff, 0xe4, 0xbf, 0x0a, 0xe1, 0xfa, 0xf2, 0xf8, 0x38, 0x2c, 0xc9, 0x44,
	0x54, 0xd7, 0xfa, 0xcb, 0xe3, 0xc5, 0x91, 0x81, 0xea, 0xaf, 0x4c, 0x1c, 0x83, 0x84, 0xd4, 0x27,
	0x12, 0x54, 0x75, 0x65, 0xfa, 0x90, 0xce, 0xb8, 0xf4, 0xab, 0xa7, 0xae, 0xe1, 0xef, 0x06, 0x8d,
	0x6d, 0xac, 0xb7, 0x89, 0xa0, 0xde, 0xf6, 0xe8, 0xe9, 0xf4, 0x35, 0xbc, 0xe8, 0x53, 0x91, 0x84,
	0xa4, 0xef, 0xc4, 0x24, 0x02, 0x03, 0xad, 0xa0, 0xe6, 0xc5, 0x36, 0xfe, 0xf9, 0xcf, 0x07, 0xda,
	0x2c, 0xd7, 0x8c, 0xa7, 0xc8, 0x2e, 0xab, 0xfa, 0x27, 0x24, 0x82, 0xc6, 0x67, 0x78, 0xb9, 0xcd,
	0x53, 0x09, 0x37, 0x18, 0xf7, 0xe0, 0x43, 0x90, 0xe0, 0x65, 0x2a, 0x3b, 0x20, 0x25, 0x8d, 0x03,
	0xa1, 0xbf, 0x89, 0xf5, 0x88, 0xec, 0x39, 0x21, 0x0b, 0x68, 0xec, 0x74, 0x08, 0x0d, 0x53, 0x0e,
	0x22, 0xd7, 0xac, 0xb4, 0x2f, 0x66, 0x9a, 0x17, 0x56, 0x67, 0x0c, 0xd3, 0xbe, 0x14, 0x91, 0xbd,
	0x5b, 0x19, 0xe6, 0x86, 0x82, 0x34, 0xbe, 0xd7, 0x70, 0xf5, 0x36, 0x11, 0x62, 0x97, 0x71, 0xff,
	0x36, 0x0b, 0xa9, 0xd7, 0xd7, 0xaf, 0xe0, 0x39, 0x9f, 0x06, 0x54, 0x4e, 0xf1, 0x2f, 0xd9, 0xaa,
	0xa0, 0x6f, 0xe1, 0x17, 0x42, 0xb6, 0x0b, 0xdc, 0x23, 0x02, 0x1c, 0xaf, 0x4b, 0x38, 0xf1, 0x24,
	0x70, 0x61, 0xcc, 0x4c, 0x12, 0x2e, 0x9f, 0xc0, 0xb6, 0x4f, 0x50, 0x19, 0x3b, 0x4d, 0x92, 0x69,
	0xb6, 0x36, 0xc5, 0x3e, 0x81, 0x8d, 0xb0, 0x37, 0xb1, 0x2e, 0x12, 0xf0, 0x28, 0x09, 0x47, 0xb9,
	0x17, 0x26, 0xb9, 0x35, 0x05, 0x1a, 0x61, 0x5e, 0xc1, 0x8b, 0x31, 0x93, 0x4e, 0x2a, 0x80, 0xe7,
	0x2b, 0x9f, 0x5d, 0x41, 0xcd, 0x05, 0xbb, 0x1c, 0x33, 0x79, 0x47, 0x3d, 0xd2, 0xaf, 0xe2, 0x25,
	0xd8, 0x4b, 0x28, 0x07, 0x27, 0x51, 0x4b, 0x31, 0xe6, 0x72, 0xe5, 0xc2, 0x98, 0x55, 0xcd, 0xf8,
	0x69, 0xc1, 0xae, 0x16, 0x90, 0xe1, 0xda, 0xf4, 0x55, 0x5c, 0xcb, 0x74, 0x39, 0x78, 0x10, 0xcb,
	0xb0, 0x9f, 0x35, 0xf0, 0x8d, 0xf9, 0x8c, 0x66, 0x2f, 0xc5, 0x4c, 0xda, 0xea, 0xf9, 0x1d, 0x01,
	0xbe, 0xbe, 0x8e, 0xab, 0x11, 0x8d, 0x69, 0x94, 0x46, 0x4e, 0x08, 0x71, 0x20, 0xbb, 0xc6, 0xc2,
	0xd8, 0xe4, 0xcd, 0x79, 0xbb, 0xa2, 0x00, 0xb7, 0xf2, 0x7a, 0xe3, 0x77, 0x84, 0x6b, 0x3b, 0x20,
	0x04, 0x65, 0xf1, 0xc7, 0x24, 0x26, 0x01, 0x44, 0x10, 0x4b, 0xfd, 0x5d, 0x5c, 0xf1, 0x18, 0xbb,
	0x4b, 0xc1, 0xc9, 0x87, 0xe9, 0x2b, 0xaf, 0x8c, 0x87, 0xfb, 0x48, 0x7b, 0x6b, 0x7d, 0xfd, 0xeb,
	0x5f, 0x10, 0xca, 0x14, 0x17, 0x56, 0xe7, 0x8c, 0xfb, 0x3f, 0xcc, 0x36, 0xb7, 0xec, 0xc5, 0x02,
	0x7e, 0x3d, 0x47, 0xeb, 0xef, 0xe3, 0x97, 0x14, 0x9d, 0x43, 0x87, 0x83, 0xe8, 0x3a, 0x34, 0x96,
	0xc0, 0x7b, 0x24, 0x54, 0x1e, 0xce, 0x1f, 0xde, 0x43, 0x8f, 0xf6, 0x11, 0xb2, 0x5f, 0x2c, 0x70,
	0x76, 0x01, 0xfb, 0x48, 0xa1, 0xf4, 0x0f, 0x70, 0x55, 0x14, 0x43, 0x0d, 0x07, 0x28, 0xdc, 0xab,
	0x3f, 0xdc, 0x47, 0xb3, 0x9b, 0x6f, 0x5c, 0x3b, 0x6d, 0x84, 0x8a, 0x62, 0x14, 0x33, 0x34, 0x1e,
	0x6b, 0xb8, 0x7a, 0x33, 0x64, 0x2e, 0x09, 0x77, 0x12, 0xf0, 0x3e, 0xed, 0x27, 0xa0, 0x47, 0xf8,
	0xb2, 0x9b, 0x45, 0x65, 0xfc, 0x4b, 0x90, 0x9f, 0xad, 0xbc, 0xb1, 0x65, 0x9d, 0xf5, 0xd3, 0x61,
	0x4d, 0xe7, 0xcd, 0xd6, 0xdd, 0xe9, 0x0c, 0x7e, 0x83, 0xb0, 0xe9, 0x66, 0xa9, 0x72, 0x3a, 0x59,
	0xac, 0x1c, 0x7f, 0x98, 0x2b, 0x47, 0xa8, 0x60, 0xe5, 0xdb, 0x28, 0x6f, 0x5c, 0xff, 0x1f, 0xad,
	0xff, 0x39, 0xa5, 0xf6, 0xb2, 0xfb, 0x2f, 0x11, 0x26, 0x78, 0x69, 0xf8, 0xce, 0x39, 0x49, 0x9e,
	0xc4, 0x7c, 0xa5, 0xe5, 0x8d, 0xcd, 0xb3, 0x37, 0x1f, 0x4f, 0xb2, 0x5d, 0x4d, 0xc6, 0x93, 0xdd,
	0xc7, 0xfa, 0xd0, 0xb4, 0xe8, 0xe4, 0x55, 0xca, 0xa3, 0x53, 0xde, 0x78, 0xe7, 0xec, 0x5d, 0xa6,
	0xde, 0xc6, 0x76, 0xe5, 0xf1, 0x3d, 0xec, 0x43, 0xc4, 0x5e, 0x7f, 0x4d, 0x82, 0x90, 0x76, 0x4d,
	0x4c, 0x22, 0x1a, 0x5f, 0x6a, 0xb8, 0xba, 0xcd, 0x81, 0x48, 0x38, 0x37, 0xfb, 0x99, 0x98, 0xfd,
	0x76, 0xed, 0xb7, 0xf7, 0x26, 0xe2, 0xd5, 0xf8, 0x4a, 0xc3, 0x4b, 0x36, 0x24, 0x21, 0xf1, 0xce,
	0x5d, 0x78, 0x7e, 0x2e, 0x3c, 0x9d, 0xc1, 0xe5, 0x9b, 0x20, 0xcf, 0x1d, 0x78, 0x5e, 0x0e, 0xb4,
	0xbf, 0x43, 0x07, 0x47, 0x66, 0xe9, 0xf0, 0xc8, 0x2c, 0x3d, 0x39, 0x32, 0xd1, 0xfd, 0x81, 0x89,
	0x7e, 0x1c, 0x98, 0xe8, 0xd7, 0x81, 0x89, 0x0e, 0x06, 0x26, 0x3a, 0x1c, 0x98, 0xe8, 0x8f, 0x81,
	0x89, 0x1e, 0x0d, 0xcc, 0xd2, 0x93, 0x81, 0x89, 0xbe, 0x3d, 0x36, 0x4b, 0x0f, 0x8e, 0x4d, 0x74,
	0x70, 0x6c, 0x96, 0x0e, 0x8f, 0xcd, 0xd2, 0xe7, 0x5f, 0x04, 0x2c, 0xb9, 0x1b, 0x58, 0x3d, 0x16,
	0x4a, 0xe0, 0x9c, 0x58, 0x69, 0x76, 0xed, 0xe5, 0x9c, 0x74, 0x18, 0x8f, 0xd6, 0x12, 0xce, 0x7a,
	0xd4, 0x07, 0xbe, 0x36, 0x2c, 0xb7, 0x12, 0x37, 0x60, 0x2d, 0xd8, 0x93, 0xea, 0x82, 0xf8, 0x9f,
	0xd7, 0x65, 0x77, 0x2e, 0xbf, 0x37, 0x5e, 0xfd, 0x2b, 0x00, 0x00, 0xff, 0xff, 0xe6, 0x4f, 0x9c,
	0xfc, 0x61, 0x0b, 0x00, 0x00,
}

func (this *BasicConfiguration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BasicConfiguration)
	if !ok {
		that2, ok := that.(BasicConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DisplayName != that1.DisplayName {
		return false
	}
	return true
}
func (this *BruteForceDetectionSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BruteForceDetectionSettings)
	if !ok {
		that2, ok := that.(BruteForceDetectionSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxLoginFailures != that1.MaxLoginFailures {
		return false
	}
	return true
}
func (this *PasswordPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PasswordPolicy)
	if !ok {
		that2, ok := that.(PasswordPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Digits != that1.Digits {
		return false
	}
	if this.LowercaseCharacters != that1.LowercaseCharacters {
		return false
	}
	if this.UppercaseCharacters != that1.UppercaseCharacters {
		return false
	}
	if this.SpecialCharacters != that1.SpecialCharacters {
		return false
	}
	if this.NotUsername != that1.NotUsername {
		return false
	}
	if this.ExpirePassword != that1.ExpirePassword {
		return false
	}
	if this.NotRecentlyUsed != that1.NotRecentlyUsed {
		return false
	}
	if this.MinimumLength != that1.MinimumLength {
		return false
	}
	return true
}
func (this *SessionManagement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SessionManagement)
	if !ok {
		that2, ok := that.(SessionManagement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CookieExpiry != that1.CookieExpiry {
		return false
	}
	if this.CookieRefreshInterval != that1.CookieRefreshInterval {
		return false
	}
	if this.SessionExpiry != that1.SessionExpiry {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BasicConfiguration.Equal(that1.BasicConfiguration) {
		return false
	}
	if !this.BruteForceDetectionSettings.Equal(that1.BruteForceDetectionSettings) {
		return false
	}
	if !this.PasswordPolicy.Equal(that1.PasswordPolicy) {
		return false
	}
	if !this.SessionManagement.Equal(that1.SessionManagement) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BasicConfiguration.Equal(that1.BasicConfiguration) {
		return false
	}
	if !this.BruteForceDetectionSettings.Equal(that1.BruteForceDetectionSettings) {
		return false
	}
	if !this.PasswordPolicy.Equal(that1.PasswordPolicy) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BasicConfiguration.Equal(that1.BasicConfiguration) {
		return false
	}
	if !this.BruteForceDetectionSettings.Equal(that1.BruteForceDetectionSettings) {
		return false
	}
	if !this.PasswordPolicy.Equal(that1.PasswordPolicy) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BasicConfiguration.Equal(that1.BasicConfiguration) {
		return false
	}
	if !this.BruteForceDetectionSettings.Equal(that1.BruteForceDetectionSettings) {
		return false
	}
	if !this.PasswordPolicy.Equal(that1.PasswordPolicy) {
		return false
	}
	return true
}
func (this *BasicConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tenant_configuration.BasicConfiguration{")
	s = append(s, "DisplayName: "+fmt.Sprintf("%#v", this.DisplayName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BruteForceDetectionSettings) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tenant_configuration.BruteForceDetectionSettings{")
	s = append(s, "MaxLoginFailures: "+fmt.Sprintf("%#v", this.MaxLoginFailures)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PasswordPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&tenant_configuration.PasswordPolicy{")
	s = append(s, "Digits: "+fmt.Sprintf("%#v", this.Digits)+",\n")
	s = append(s, "LowercaseCharacters: "+fmt.Sprintf("%#v", this.LowercaseCharacters)+",\n")
	s = append(s, "UppercaseCharacters: "+fmt.Sprintf("%#v", this.UppercaseCharacters)+",\n")
	s = append(s, "SpecialCharacters: "+fmt.Sprintf("%#v", this.SpecialCharacters)+",\n")
	s = append(s, "NotUsername: "+fmt.Sprintf("%#v", this.NotUsername)+",\n")
	s = append(s, "ExpirePassword: "+fmt.Sprintf("%#v", this.ExpirePassword)+",\n")
	s = append(s, "NotRecentlyUsed: "+fmt.Sprintf("%#v", this.NotRecentlyUsed)+",\n")
	s = append(s, "MinimumLength: "+fmt.Sprintf("%#v", this.MinimumLength)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionManagement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tenant_configuration.SessionManagement{")
	s = append(s, "CookieExpiry: "+fmt.Sprintf("%#v", this.CookieExpiry)+",\n")
	s = append(s, "CookieRefreshInterval: "+fmt.Sprintf("%#v", this.CookieRefreshInterval)+",\n")
	s = append(s, "SessionExpiry: "+fmt.Sprintf("%#v", this.SessionExpiry)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tenant_configuration.GlobalSpecType{")
	if this.BasicConfiguration != nil {
		s = append(s, "BasicConfiguration: "+fmt.Sprintf("%#v", this.BasicConfiguration)+",\n")
	}
	if this.BruteForceDetectionSettings != nil {
		s = append(s, "BruteForceDetectionSettings: "+fmt.Sprintf("%#v", this.BruteForceDetectionSettings)+",\n")
	}
	if this.PasswordPolicy != nil {
		s = append(s, "PasswordPolicy: "+fmt.Sprintf("%#v", this.PasswordPolicy)+",\n")
	}
	if this.SessionManagement != nil {
		s = append(s, "SessionManagement: "+fmt.Sprintf("%#v", this.SessionManagement)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tenant_configuration.CreateSpecType{")
	if this.BasicConfiguration != nil {
		s = append(s, "BasicConfiguration: "+fmt.Sprintf("%#v", this.BasicConfiguration)+",\n")
	}
	if this.BruteForceDetectionSettings != nil {
		s = append(s, "BruteForceDetectionSettings: "+fmt.Sprintf("%#v", this.BruteForceDetectionSettings)+",\n")
	}
	if this.PasswordPolicy != nil {
		s = append(s, "PasswordPolicy: "+fmt.Sprintf("%#v", this.PasswordPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tenant_configuration.ReplaceSpecType{")
	if this.BasicConfiguration != nil {
		s = append(s, "BasicConfiguration: "+fmt.Sprintf("%#v", this.BasicConfiguration)+",\n")
	}
	if this.BruteForceDetectionSettings != nil {
		s = append(s, "BruteForceDetectionSettings: "+fmt.Sprintf("%#v", this.BruteForceDetectionSettings)+",\n")
	}
	if this.PasswordPolicy != nil {
		s = append(s, "PasswordPolicy: "+fmt.Sprintf("%#v", this.PasswordPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tenant_configuration.GetSpecType{")
	if this.BasicConfiguration != nil {
		s = append(s, "BasicConfiguration: "+fmt.Sprintf("%#v", this.BasicConfiguration)+",\n")
	}
	if this.BruteForceDetectionSettings != nil {
		s = append(s, "BruteForceDetectionSettings: "+fmt.Sprintf("%#v", this.BruteForceDetectionSettings)+",\n")
	}
	if this.PasswordPolicy != nil {
		s = append(s, "PasswordPolicy: "+fmt.Sprintf("%#v", this.PasswordPolicy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *BasicConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasicConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BruteForceDetectionSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BruteForceDetectionSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BruteForceDetectionSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxLoginFailures != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxLoginFailures))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PasswordPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PasswordPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PasswordPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinimumLength != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinimumLength))
		i--
		dAtA[i] = 0x40
	}
	if m.NotRecentlyUsed != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NotRecentlyUsed))
		i--
		dAtA[i] = 0x38
	}
	if m.ExpirePassword != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirePassword))
		i--
		dAtA[i] = 0x30
	}
	if m.NotUsername {
		i--
		if m.NotUsername {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SpecialCharacters != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SpecialCharacters))
		i--
		dAtA[i] = 0x20
	}
	if m.UppercaseCharacters != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UppercaseCharacters))
		i--
		dAtA[i] = 0x18
	}
	if m.LowercaseCharacters != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LowercaseCharacters))
		i--
		dAtA[i] = 0x10
	}
	if m.Digits != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Digits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionManagement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionManagement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionManagement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionExpiry != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SessionExpiry))
		i--
		dAtA[i] = 0x18
	}
	if m.CookieRefreshInterval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieRefreshInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.CookieExpiry != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CookieExpiry))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionManagement != nil {
		{
			size, err := m.SessionManagement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PasswordPolicy != nil {
		{
			size, err := m.PasswordPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BruteForceDetectionSettings != nil {
		{
			size, err := m.BruteForceDetectionSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BasicConfiguration != nil {
		{
			size, err := m.BasicConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PasswordPolicy != nil {
		{
			size, err := m.PasswordPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BruteForceDetectionSettings != nil {
		{
			size, err := m.BruteForceDetectionSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BasicConfiguration != nil {
		{
			size, err := m.BasicConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PasswordPolicy != nil {
		{
			size, err := m.PasswordPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BruteForceDetectionSettings != nil {
		{
			size, err := m.BruteForceDetectionSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BasicConfiguration != nil {
		{
			size, err := m.BasicConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PasswordPolicy != nil {
		{
			size, err := m.PasswordPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BruteForceDetectionSettings != nil {
		{
			size, err := m.BruteForceDetectionSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BasicConfiguration != nil {
		{
			size, err := m.BasicConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BasicConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BruteForceDetectionSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxLoginFailures != 0 {
		n += 1 + sovTypes(uint64(m.MaxLoginFailures))
	}
	return n
}

func (m *PasswordPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Digits != 0 {
		n += 1 + sovTypes(uint64(m.Digits))
	}
	if m.LowercaseCharacters != 0 {
		n += 1 + sovTypes(uint64(m.LowercaseCharacters))
	}
	if m.UppercaseCharacters != 0 {
		n += 1 + sovTypes(uint64(m.UppercaseCharacters))
	}
	if m.SpecialCharacters != 0 {
		n += 1 + sovTypes(uint64(m.SpecialCharacters))
	}
	if m.NotUsername {
		n += 2
	}
	if m.ExpirePassword != 0 {
		n += 1 + sovTypes(uint64(m.ExpirePassword))
	}
	if m.NotRecentlyUsed != 0 {
		n += 1 + sovTypes(uint64(m.NotRecentlyUsed))
	}
	if m.MinimumLength != 0 {
		n += 1 + sovTypes(uint64(m.MinimumLength))
	}
	return n
}

func (m *SessionManagement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CookieExpiry != 0 {
		n += 1 + sovTypes(uint64(m.CookieExpiry))
	}
	if m.CookieRefreshInterval != 0 {
		n += 1 + sovTypes(uint64(m.CookieRefreshInterval))
	}
	if m.SessionExpiry != 0 {
		n += 1 + sovTypes(uint64(m.SessionExpiry))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BasicConfiguration != nil {
		l = m.BasicConfiguration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BruteForceDetectionSettings != nil {
		l = m.BruteForceDetectionSettings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PasswordPolicy != nil {
		l = m.PasswordPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SessionManagement != nil {
		l = m.SessionManagement.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BasicConfiguration != nil {
		l = m.BasicConfiguration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BruteForceDetectionSettings != nil {
		l = m.BruteForceDetectionSettings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PasswordPolicy != nil {
		l = m.PasswordPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BasicConfiguration != nil {
		l = m.BasicConfiguration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BruteForceDetectionSettings != nil {
		l = m.BruteForceDetectionSettings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PasswordPolicy != nil {
		l = m.PasswordPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BasicConfiguration != nil {
		l = m.BasicConfiguration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BruteForceDetectionSettings != nil {
		l = m.BruteForceDetectionSettings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PasswordPolicy != nil {
		l = m.PasswordPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BasicConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BasicConfiguration{`,
		`DisplayName:` + fmt.Sprintf("%v", this.DisplayName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BruteForceDetectionSettings) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BruteForceDetectionSettings{`,
		`MaxLoginFailures:` + fmt.Sprintf("%v", this.MaxLoginFailures) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PasswordPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PasswordPolicy{`,
		`Digits:` + fmt.Sprintf("%v", this.Digits) + `,`,
		`LowercaseCharacters:` + fmt.Sprintf("%v", this.LowercaseCharacters) + `,`,
		`UppercaseCharacters:` + fmt.Sprintf("%v", this.UppercaseCharacters) + `,`,
		`SpecialCharacters:` + fmt.Sprintf("%v", this.SpecialCharacters) + `,`,
		`NotUsername:` + fmt.Sprintf("%v", this.NotUsername) + `,`,
		`ExpirePassword:` + fmt.Sprintf("%v", this.ExpirePassword) + `,`,
		`NotRecentlyUsed:` + fmt.Sprintf("%v", this.NotRecentlyUsed) + `,`,
		`MinimumLength:` + fmt.Sprintf("%v", this.MinimumLength) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SessionManagement) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SessionManagement{`,
		`CookieExpiry:` + fmt.Sprintf("%v", this.CookieExpiry) + `,`,
		`CookieRefreshInterval:` + fmt.Sprintf("%v", this.CookieRefreshInterval) + `,`,
		`SessionExpiry:` + fmt.Sprintf("%v", this.SessionExpiry) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`BasicConfiguration:` + strings.Replace(this.BasicConfiguration.String(), "BasicConfiguration", "BasicConfiguration", 1) + `,`,
		`BruteForceDetectionSettings:` + strings.Replace(this.BruteForceDetectionSettings.String(), "BruteForceDetectionSettings", "BruteForceDetectionSettings", 1) + `,`,
		`PasswordPolicy:` + strings.Replace(this.PasswordPolicy.String(), "PasswordPolicy", "PasswordPolicy", 1) + `,`,
		`SessionManagement:` + strings.Replace(this.SessionManagement.String(), "SessionManagement", "SessionManagement", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`BasicConfiguration:` + strings.Replace(this.BasicConfiguration.String(), "BasicConfiguration", "BasicConfiguration", 1) + `,`,
		`BruteForceDetectionSettings:` + strings.Replace(this.BruteForceDetectionSettings.String(), "BruteForceDetectionSettings", "BruteForceDetectionSettings", 1) + `,`,
		`PasswordPolicy:` + strings.Replace(this.PasswordPolicy.String(), "PasswordPolicy", "PasswordPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`BasicConfiguration:` + strings.Replace(this.BasicConfiguration.String(), "BasicConfiguration", "BasicConfiguration", 1) + `,`,
		`BruteForceDetectionSettings:` + strings.Replace(this.BruteForceDetectionSettings.String(), "BruteForceDetectionSettings", "BruteForceDetectionSettings", 1) + `,`,
		`PasswordPolicy:` + strings.Replace(this.PasswordPolicy.String(), "PasswordPolicy", "PasswordPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`BasicConfiguration:` + strings.Replace(this.BasicConfiguration.String(), "BasicConfiguration", "BasicConfiguration", 1) + `,`,
		`BruteForceDetectionSettings:` + strings.Replace(this.BruteForceDetectionSettings.String(), "BruteForceDetectionSettings", "BruteForceDetectionSettings", 1) + `,`,
		`PasswordPolicy:` + strings.Replace(this.PasswordPolicy.String(), "PasswordPolicy", "PasswordPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BasicConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BruteForceDetectionSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BruteForceDetectionSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BruteForceDetectionSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLoginFailures", wireType)
			}
			m.MaxLoginFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLoginFailures |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PasswordPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PasswordPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PasswordPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digits", wireType)
			}
			m.Digits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Digits |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowercaseCharacters", wireType)
			}
			m.LowercaseCharacters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowercaseCharacters |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UppercaseCharacters", wireType)
			}
			m.UppercaseCharacters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UppercaseCharacters |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialCharacters", wireType)
			}
			m.SpecialCharacters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpecialCharacters |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotUsername", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotUsername = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirePassword", wireType)
			}
			m.ExpirePassword = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirePassword |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotRecentlyUsed", wireType)
			}
			m.NotRecentlyUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotRecentlyUsed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumLength", wireType)
			}
			m.MinimumLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionManagement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionManagement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionManagement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieExpiry", wireType)
			}
			m.CookieExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieExpiry |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieRefreshInterval", wireType)
			}
			m.CookieRefreshInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CookieRefreshInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionExpiry", wireType)
			}
			m.SessionExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionExpiry |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BasicConfiguration == nil {
				m.BasicConfiguration = &BasicConfiguration{}
			}
			if err := m.BasicConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BruteForceDetectionSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BruteForceDetectionSettings == nil {
				m.BruteForceDetectionSettings = &BruteForceDetectionSettings{}
			}
			if err := m.BruteForceDetectionSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PasswordPolicy == nil {
				m.PasswordPolicy = &PasswordPolicy{}
			}
			if err := m.PasswordPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionManagement == nil {
				m.SessionManagement = &SessionManagement{}
			}
			if err := m.SessionManagement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BasicConfiguration == nil {
				m.BasicConfiguration = &BasicConfiguration{}
			}
			if err := m.BasicConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BruteForceDetectionSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BruteForceDetectionSettings == nil {
				m.BruteForceDetectionSettings = &BruteForceDetectionSettings{}
			}
			if err := m.BruteForceDetectionSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PasswordPolicy == nil {
				m.PasswordPolicy = &PasswordPolicy{}
			}
			if err := m.PasswordPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BasicConfiguration == nil {
				m.BasicConfiguration = &BasicConfiguration{}
			}
			if err := m.BasicConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BruteForceDetectionSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BruteForceDetectionSettings == nil {
				m.BruteForceDetectionSettings = &BruteForceDetectionSettings{}
			}
			if err := m.BruteForceDetectionSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PasswordPolicy == nil {
				m.PasswordPolicy = &PasswordPolicy{}
			}
			if err := m.PasswordPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BasicConfiguration == nil {
				m.BasicConfiguration = &BasicConfiguration{}
			}
			if err := m.BasicConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BruteForceDetectionSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BruteForceDetectionSettings == nil {
				m.BruteForceDetectionSettings = &BruteForceDetectionSettings{}
			}
			if err := m.BruteForceDetectionSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PasswordPolicy == nil {
				m.PasswordPolicy = &PasswordPolicy{}
			}
			if err := m.PasswordPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
