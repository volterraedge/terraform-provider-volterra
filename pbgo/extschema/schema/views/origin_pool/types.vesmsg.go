// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package origin_pool

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_cluster "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/cluster"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetUseTls().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.use_tls")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetHealthcheckDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHealthcheckDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOriginServersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetOriginServersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *CreateSpecType) GetHealthcheckDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetHealthcheck()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("CreateSpecType.healthcheck[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("healthcheck.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "healthcheck.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "healthcheck",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetHealthcheckDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetHealthcheckDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "healthcheck.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: healthcheck")
	}
	for i, vref := range m.GetHealthcheck() {
		if vref == nil {
			return nil, fmt.Errorf("CreateSpecType.healthcheck[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "healthcheck.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetOriginServersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOriginServers() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetOriginServers() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOriginServers() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("origin_servers[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetTlsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsChoice().(type) {
	case *CreateSpecType_NoTls:

		return nil, nil

	case *CreateSpecType_UseTls:

		drInfos, err := m.GetUseTls().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetUseTls().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "use_tls." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) HealthCheckPortChoiceHealthCheckPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_HealthCheckPort, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for health_check_port")
	}
	return oValidatorFn_HealthCheckPort, nil
}

func (v *ValidateCreateSpecType) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) PortChoicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}

func (v *ValidateCreateSpecType) TlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OriginServersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for origin_servers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*OriginServerType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := OriginServerTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for origin_servers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OriginServerType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OriginServerType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated origin_servers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items origin_servers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) HealthcheckValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for healthcheck")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for healthcheck")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated healthcheck")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items healthcheck")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) LoadbalancerAlgorithmValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_cluster.LoadbalancerAlgorithm)
		return int32(i)
	}
	// ves_io_schema_cluster.LoadbalancerAlgorithm_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_cluster.LoadbalancerAlgorithm_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_algorithm")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) EndpointSelectionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_cluster.EndpointSelectionPolicy)
		return int32(i)
	}
	// ves_io_schema_cluster.EndpointSelectionPolicy_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_cluster.EndpointSelectionPolicy_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for endpoint_selection")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advanced_options"]; exists {

		vOpts := append(opts, db.WithValidateField("advanced_options"))
		if err := fv(ctx, m.GetAdvancedOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_selection"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_selection"))
		if err := fv(ctx, m.GetEndpointSelection(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetHealthCheckPortChoice().(type) {
	case *CreateSpecType_SameAsEndpointPort:
		if fv, exists := v.FldValidators["health_check_port_choice.same_as_endpoint_port"]; exists {
			val := m.GetHealthCheckPortChoice().(*CreateSpecType_SameAsEndpointPort).SameAsEndpointPort
			vOpts := append(opts,
				db.WithValidateField("health_check_port_choice"),
				db.WithValidateField("same_as_endpoint_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_HealthCheckPort:
		if fv, exists := v.FldValidators["health_check_port_choice.health_check_port"]; exists {
			val := m.GetHealthCheckPortChoice().(*CreateSpecType_HealthCheckPort).HealthCheckPort
			vOpts := append(opts,
				db.WithValidateField("health_check_port_choice"),
				db.WithValidateField("health_check_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["healthcheck"]; exists {
		vOpts := append(opts, db.WithValidateField("healthcheck"))
		if err := fv(ctx, m.GetHealthcheck(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_servers"]; exists {
		vOpts := append(opts, db.WithValidateField("origin_servers"))
		if err := fv(ctx, m.GetOriginServers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *CreateSpecType_Port:
		if fv, exists := v.FldValidators["port_choice.port"]; exists {
			val := m.GetPortChoice().(*CreateSpecType_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AutomaticPort:
		if fv, exists := v.FldValidators["port_choice.automatic_port"]; exists {
			val := m.GetPortChoice().(*CreateSpecType_AutomaticPort).AutomaticPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("automatic_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_LbPort:
		if fv, exists := v.FldValidators["port_choice.lb_port"]; exists {
			val := m.GetPortChoice().(*CreateSpecType_LbPort).LbPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("lb_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_choice"]; exists {
		val := m.GetTlsChoice()
		vOpts := append(opts,
			db.WithValidateField("tls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTlsChoice().(type) {
	case *CreateSpecType_NoTls:
		if fv, exists := v.FldValidators["tls_choice.no_tls"]; exists {
			val := m.GetTlsChoice().(*CreateSpecType_NoTls).NoTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("no_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_UseTls:
		if fv, exists := v.FldValidators["tls_choice.use_tls"]; exists {
			val := m.GetTlsChoice().(*CreateSpecType_UseTls).UseTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("use_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHealthCheckPortChoiceHealthCheckPort := v.HealthCheckPortChoiceHealthCheckPortValidationRuleHandler
	rulesHealthCheckPortChoiceHealthCheckPort := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["health_check_port_choice.health_check_port"], err = vrhHealthCheckPortChoiceHealthCheckPort(rulesHealthCheckPortChoiceHealthCheckPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.health_check_port_choice_health_check_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["health_check_port_choice.health_check_port"] = vFnMap["health_check_port_choice.health_check_port"]

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoicePort := v.PortChoicePortValidationRuleHandler
	rulesPortChoicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.port"], err = vrhPortChoicePort(rulesPortChoicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.port_choice_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.port"] = vFnMap["port_choice.port"]

	vrhTlsChoice := v.TlsChoiceValidationRuleHandler
	rulesTlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTlsChoice(rulesTlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.tls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_choice"] = vFn

	vrhOriginServers := v.OriginServersValidationRuleHandler
	rulesOriginServers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhOriginServers(rulesOriginServers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.origin_servers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_servers"] = vFn

	vrhHealthcheck := v.HealthcheckValidationRuleHandler
	rulesHealthcheck := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhHealthcheck(rulesHealthcheck)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.healthcheck: %s", err)
		panic(errMsg)
	}
	v.FldValidators["healthcheck"] = vFn

	vrhLoadbalancerAlgorithm := v.LoadbalancerAlgorithmValidationRuleHandler
	rulesLoadbalancerAlgorithm := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLoadbalancerAlgorithm(rulesLoadbalancerAlgorithm)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.loadbalancer_algorithm: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_algorithm"] = vFn

	vrhEndpointSelection := v.EndpointSelectionValidationRuleHandler
	rulesEndpointSelection := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndpointSelection(rulesEndpointSelection)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.endpoint_selection: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_selection"] = vFn

	v.FldValidators["tls_choice.use_tls"] = UpstreamTlsParametersValidator().Validate

	v.FldValidators["advanced_options"] = OriginPoolAdvancedOptionsValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetUseTls().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.use_tls")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetHealthcheckDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHealthcheckDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOriginServersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetOriginServersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetSpecType) GetHealthcheckDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetHealthcheck()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("GetSpecType.healthcheck[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("healthcheck.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "healthcheck.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "healthcheck",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetHealthcheckDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetHealthcheckDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "healthcheck.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: healthcheck")
	}
	for i, vref := range m.GetHealthcheck() {
		if vref == nil {
			return nil, fmt.Errorf("GetSpecType.healthcheck[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "healthcheck.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetOriginServersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOriginServers() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetOriginServers() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOriginServers() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("origin_servers[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetTlsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsChoice().(type) {
	case *GetSpecType_NoTls:

		return nil, nil

	case *GetSpecType_UseTls:

		drInfos, err := m.GetUseTls().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetUseTls().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "use_tls." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) HealthCheckPortChoiceHealthCheckPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_HealthCheckPort, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for health_check_port")
	}
	return oValidatorFn_HealthCheckPort, nil
}

func (v *ValidateGetSpecType) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) PortChoicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}

func (v *ValidateGetSpecType) TlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) OriginServersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for origin_servers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*OriginServerType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := OriginServerTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for origin_servers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OriginServerType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OriginServerType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated origin_servers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items origin_servers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) HealthcheckValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for healthcheck")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for healthcheck")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated healthcheck")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items healthcheck")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) LoadbalancerAlgorithmValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_cluster.LoadbalancerAlgorithm)
		return int32(i)
	}
	// ves_io_schema_cluster.LoadbalancerAlgorithm_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_cluster.LoadbalancerAlgorithm_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_algorithm")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) EndpointSelectionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_cluster.EndpointSelectionPolicy)
		return int32(i)
	}
	// ves_io_schema_cluster.EndpointSelectionPolicy_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_cluster.EndpointSelectionPolicy_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for endpoint_selection")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advanced_options"]; exists {

		vOpts := append(opts, db.WithValidateField("advanced_options"))
		if err := fv(ctx, m.GetAdvancedOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_selection"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_selection"))
		if err := fv(ctx, m.GetEndpointSelection(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetHealthCheckPortChoice().(type) {
	case *GetSpecType_SameAsEndpointPort:
		if fv, exists := v.FldValidators["health_check_port_choice.same_as_endpoint_port"]; exists {
			val := m.GetHealthCheckPortChoice().(*GetSpecType_SameAsEndpointPort).SameAsEndpointPort
			vOpts := append(opts,
				db.WithValidateField("health_check_port_choice"),
				db.WithValidateField("same_as_endpoint_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_HealthCheckPort:
		if fv, exists := v.FldValidators["health_check_port_choice.health_check_port"]; exists {
			val := m.GetHealthCheckPortChoice().(*GetSpecType_HealthCheckPort).HealthCheckPort
			vOpts := append(opts,
				db.WithValidateField("health_check_port_choice"),
				db.WithValidateField("health_check_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["healthcheck"]; exists {
		vOpts := append(opts, db.WithValidateField("healthcheck"))
		if err := fv(ctx, m.GetHealthcheck(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_servers"]; exists {
		vOpts := append(opts, db.WithValidateField("origin_servers"))
		if err := fv(ctx, m.GetOriginServers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *GetSpecType_Port:
		if fv, exists := v.FldValidators["port_choice.port"]; exists {
			val := m.GetPortChoice().(*GetSpecType_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AutomaticPort:
		if fv, exists := v.FldValidators["port_choice.automatic_port"]; exists {
			val := m.GetPortChoice().(*GetSpecType_AutomaticPort).AutomaticPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("automatic_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_LbPort:
		if fv, exists := v.FldValidators["port_choice.lb_port"]; exists {
			val := m.GetPortChoice().(*GetSpecType_LbPort).LbPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("lb_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_choice"]; exists {
		val := m.GetTlsChoice()
		vOpts := append(opts,
			db.WithValidateField("tls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTlsChoice().(type) {
	case *GetSpecType_NoTls:
		if fv, exists := v.FldValidators["tls_choice.no_tls"]; exists {
			val := m.GetTlsChoice().(*GetSpecType_NoTls).NoTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("no_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_UseTls:
		if fv, exists := v.FldValidators["tls_choice.use_tls"]; exists {
			val := m.GetTlsChoice().(*GetSpecType_UseTls).UseTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("use_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHealthCheckPortChoiceHealthCheckPort := v.HealthCheckPortChoiceHealthCheckPortValidationRuleHandler
	rulesHealthCheckPortChoiceHealthCheckPort := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["health_check_port_choice.health_check_port"], err = vrhHealthCheckPortChoiceHealthCheckPort(rulesHealthCheckPortChoiceHealthCheckPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.health_check_port_choice_health_check_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["health_check_port_choice.health_check_port"] = vFnMap["health_check_port_choice.health_check_port"]

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoicePort := v.PortChoicePortValidationRuleHandler
	rulesPortChoicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.port"], err = vrhPortChoicePort(rulesPortChoicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.port_choice_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.port"] = vFnMap["port_choice.port"]

	vrhTlsChoice := v.TlsChoiceValidationRuleHandler
	rulesTlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTlsChoice(rulesTlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_choice"] = vFn

	vrhOriginServers := v.OriginServersValidationRuleHandler
	rulesOriginServers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhOriginServers(rulesOriginServers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.origin_servers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_servers"] = vFn

	vrhHealthcheck := v.HealthcheckValidationRuleHandler
	rulesHealthcheck := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhHealthcheck(rulesHealthcheck)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.healthcheck: %s", err)
		panic(errMsg)
	}
	v.FldValidators["healthcheck"] = vFn

	vrhLoadbalancerAlgorithm := v.LoadbalancerAlgorithmValidationRuleHandler
	rulesLoadbalancerAlgorithm := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLoadbalancerAlgorithm(rulesLoadbalancerAlgorithm)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.loadbalancer_algorithm: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_algorithm"] = vFn

	vrhEndpointSelection := v.EndpointSelectionValidationRuleHandler
	rulesEndpointSelection := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndpointSelection(rulesEndpointSelection)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.endpoint_selection: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_selection"] = vFn

	v.FldValidators["tls_choice.use_tls"] = UpstreamTlsParametersValidator().Validate

	v.FldValidators["advanced_options"] = OriginPoolAdvancedOptionsValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetUseTls().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.use_tls")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetHealthcheckDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHealthcheckDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOriginServersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetOriginServersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetViewInternalDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetViewInternalDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetHealthcheckDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetHealthcheck()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("GlobalSpecType.healthcheck[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("healthcheck.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "healthcheck.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "healthcheck",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetHealthcheckDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetHealthcheckDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "healthcheck.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: healthcheck")
	}
	for i, vref := range m.GetHealthcheck() {
		if vref == nil {
			return nil, fmt.Errorf("GlobalSpecType.healthcheck[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "healthcheck.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetOriginServersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOriginServers() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetOriginServers() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOriginServers() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("origin_servers[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetTlsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsChoice().(type) {
	case *GlobalSpecType_NoTls:

		return nil, nil

	case *GlobalSpecType_UseTls:

		drInfos, err := m.GetUseTls().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetUseTls().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "use_tls." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *GlobalSpecType) GetViewInternalDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("view_internal.Object")
	dri := db.DRefInfo{
		RefdType:   "view_internal.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "view_internal",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetViewInternalDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetViewInternalDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "view_internal.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: view_internal")
	}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "view_internal.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) HealthCheckPortChoiceHealthCheckPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_HealthCheckPort, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for health_check_port")
	}
	return oValidatorFn_HealthCheckPort, nil
}

func (v *ValidateGlobalSpecType) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) PortChoicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}

func (v *ValidateGlobalSpecType) TlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OriginServersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for origin_servers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*OriginServerType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := OriginServerTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for origin_servers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OriginServerType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OriginServerType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated origin_servers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items origin_servers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) HealthcheckValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for healthcheck")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for healthcheck")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated healthcheck")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items healthcheck")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) LoadbalancerAlgorithmValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_cluster.LoadbalancerAlgorithm)
		return int32(i)
	}
	// ves_io_schema_cluster.LoadbalancerAlgorithm_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_cluster.LoadbalancerAlgorithm_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_algorithm")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) EndpointSelectionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_cluster.EndpointSelectionPolicy)
		return int32(i)
	}
	// ves_io_schema_cluster.EndpointSelectionPolicy_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_cluster.EndpointSelectionPolicy_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for endpoint_selection")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advanced_options"]; exists {

		vOpts := append(opts, db.WithValidateField("advanced_options"))
		if err := fv(ctx, m.GetAdvancedOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_selection"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_selection"))
		if err := fv(ctx, m.GetEndpointSelection(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetHealthCheckPortChoice().(type) {
	case *GlobalSpecType_SameAsEndpointPort:
		if fv, exists := v.FldValidators["health_check_port_choice.same_as_endpoint_port"]; exists {
			val := m.GetHealthCheckPortChoice().(*GlobalSpecType_SameAsEndpointPort).SameAsEndpointPort
			vOpts := append(opts,
				db.WithValidateField("health_check_port_choice"),
				db.WithValidateField("same_as_endpoint_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_HealthCheckPort:
		if fv, exists := v.FldValidators["health_check_port_choice.health_check_port"]; exists {
			val := m.GetHealthCheckPortChoice().(*GlobalSpecType_HealthCheckPort).HealthCheckPort
			vOpts := append(opts,
				db.WithValidateField("health_check_port_choice"),
				db.WithValidateField("health_check_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["healthcheck"]; exists {
		vOpts := append(opts, db.WithValidateField("healthcheck"))
		if err := fv(ctx, m.GetHealthcheck(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_servers"]; exists {
		vOpts := append(opts, db.WithValidateField("origin_servers"))
		if err := fv(ctx, m.GetOriginServers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *GlobalSpecType_Port:
		if fv, exists := v.FldValidators["port_choice.port"]; exists {
			val := m.GetPortChoice().(*GlobalSpecType_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AutomaticPort:
		if fv, exists := v.FldValidators["port_choice.automatic_port"]; exists {
			val := m.GetPortChoice().(*GlobalSpecType_AutomaticPort).AutomaticPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("automatic_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_LbPort:
		if fv, exists := v.FldValidators["port_choice.lb_port"]; exists {
			val := m.GetPortChoice().(*GlobalSpecType_LbPort).LbPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("lb_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_choice"]; exists {
		val := m.GetTlsChoice()
		vOpts := append(opts,
			db.WithValidateField("tls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTlsChoice().(type) {
	case *GlobalSpecType_NoTls:
		if fv, exists := v.FldValidators["tls_choice.no_tls"]; exists {
			val := m.GetTlsChoice().(*GlobalSpecType_NoTls).NoTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("no_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_UseTls:
		if fv, exists := v.FldValidators["tls_choice.use_tls"]; exists {
			val := m.GetTlsChoice().(*GlobalSpecType_UseTls).UseTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("use_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["view_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("view_internal"))
		if err := fv(ctx, m.GetViewInternal(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHealthCheckPortChoiceHealthCheckPort := v.HealthCheckPortChoiceHealthCheckPortValidationRuleHandler
	rulesHealthCheckPortChoiceHealthCheckPort := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["health_check_port_choice.health_check_port"], err = vrhHealthCheckPortChoiceHealthCheckPort(rulesHealthCheckPortChoiceHealthCheckPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.health_check_port_choice_health_check_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["health_check_port_choice.health_check_port"] = vFnMap["health_check_port_choice.health_check_port"]

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoicePort := v.PortChoicePortValidationRuleHandler
	rulesPortChoicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.port"], err = vrhPortChoicePort(rulesPortChoicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.port_choice_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.port"] = vFnMap["port_choice.port"]

	vrhTlsChoice := v.TlsChoiceValidationRuleHandler
	rulesTlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTlsChoice(rulesTlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_choice"] = vFn

	vrhOriginServers := v.OriginServersValidationRuleHandler
	rulesOriginServers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhOriginServers(rulesOriginServers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.origin_servers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_servers"] = vFn

	vrhHealthcheck := v.HealthcheckValidationRuleHandler
	rulesHealthcheck := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhHealthcheck(rulesHealthcheck)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.healthcheck: %s", err)
		panic(errMsg)
	}
	v.FldValidators["healthcheck"] = vFn

	vrhLoadbalancerAlgorithm := v.LoadbalancerAlgorithmValidationRuleHandler
	rulesLoadbalancerAlgorithm := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLoadbalancerAlgorithm(rulesLoadbalancerAlgorithm)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.loadbalancer_algorithm: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_algorithm"] = vFn

	vrhEndpointSelection := v.EndpointSelectionValidationRuleHandler
	rulesEndpointSelection := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndpointSelection(rulesEndpointSelection)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.endpoint_selection: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_selection"] = vFn

	v.FldValidators["tls_choice.use_tls"] = UpstreamTlsParametersValidator().Validate

	v.FldValidators["advanced_options"] = OriginPoolAdvancedOptionsValidator().Validate

	v.FldValidators["view_internal"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginPoolAdvancedOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginPoolAdvancedOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginPoolAdvancedOptions) DeepCopy() *OriginPoolAdvancedOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginPoolAdvancedOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginPoolAdvancedOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginPoolAdvancedOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginPoolAdvancedOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateOriginPoolAdvancedOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginPoolAdvancedOptions) CircuitBreakerChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for circuit_breaker_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginPoolAdvancedOptions) HttpProtocolTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_protocol_type")
	}
	return validatorFn, nil
}

func (v *ValidateOriginPoolAdvancedOptions) OutlierDetectionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outlier_detection_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginPoolAdvancedOptions) PanicThresholdTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for panic_threshold_type")
	}
	return validatorFn, nil
}

func (v *ValidateOriginPoolAdvancedOptions) PanicThresholdTypePanicThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_PanicThreshold, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for panic_threshold")
	}
	return oValidatorFn_PanicThreshold, nil
}

func (v *ValidateOriginPoolAdvancedOptions) SubsetChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for subset_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginPoolAdvancedOptions) ConnectionTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for connection_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolAdvancedOptions) HttpIdleTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_idle_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolAdvancedOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginPoolAdvancedOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginPoolAdvancedOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["circuit_breaker_choice"]; exists {
		val := m.GetCircuitBreakerChoice()
		vOpts := append(opts,
			db.WithValidateField("circuit_breaker_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCircuitBreakerChoice().(type) {
	case *OriginPoolAdvancedOptions_DisableCircuitBreaker:
		if fv, exists := v.FldValidators["circuit_breaker_choice.disable_circuit_breaker"]; exists {
			val := m.GetCircuitBreakerChoice().(*OriginPoolAdvancedOptions_DisableCircuitBreaker).DisableCircuitBreaker
			vOpts := append(opts,
				db.WithValidateField("circuit_breaker_choice"),
				db.WithValidateField("disable_circuit_breaker"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_CircuitBreaker:
		if fv, exists := v.FldValidators["circuit_breaker_choice.circuit_breaker"]; exists {
			val := m.GetCircuitBreakerChoice().(*OriginPoolAdvancedOptions_CircuitBreaker).CircuitBreaker
			vOpts := append(opts,
				db.WithValidateField("circuit_breaker_choice"),
				db.WithValidateField("circuit_breaker"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_DefaultCircuitBreaker:
		if fv, exists := v.FldValidators["circuit_breaker_choice.default_circuit_breaker"]; exists {
			val := m.GetCircuitBreakerChoice().(*OriginPoolAdvancedOptions_DefaultCircuitBreaker).DefaultCircuitBreaker
			vOpts := append(opts,
				db.WithValidateField("circuit_breaker_choice"),
				db.WithValidateField("default_circuit_breaker"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["connection_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_timeout"))
		if err := fv(ctx, m.GetConnectionTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header_transformation_type"]; exists {

		vOpts := append(opts, db.WithValidateField("header_transformation_type"))
		if err := fv(ctx, m.GetHeaderTransformationType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_idle_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("http_idle_timeout"))
		if err := fv(ctx, m.GetHttpIdleTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["http_protocol_type"]; exists {
		val := m.GetHttpProtocolType()
		vOpts := append(opts,
			db.WithValidateField("http_protocol_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpProtocolType().(type) {
	case *OriginPoolAdvancedOptions_Http2Options:
		if fv, exists := v.FldValidators["http_protocol_type.http2_options"]; exists {
			val := m.GetHttpProtocolType().(*OriginPoolAdvancedOptions_Http2Options).Http2Options
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http2_options"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_Http1Config:
		if fv, exists := v.FldValidators["http_protocol_type.http1_config"]; exists {
			val := m.GetHttpProtocolType().(*OriginPoolAdvancedOptions_Http1Config).Http1Config
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("http1_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_AutoHttpConfig:
		if fv, exists := v.FldValidators["http_protocol_type.auto_http_config"]; exists {
			val := m.GetHttpProtocolType().(*OriginPoolAdvancedOptions_AutoHttpConfig).AutoHttpConfig
			vOpts := append(opts,
				db.WithValidateField("http_protocol_type"),
				db.WithValidateField("auto_http_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetLbSourceIpPersistanceChoice().(type) {
	case *OriginPoolAdvancedOptions_EnableLbSourceIpPersistance:
		if fv, exists := v.FldValidators["lb_source_ip_persistance_choice.enable_lb_source_ip_persistance"]; exists {
			val := m.GetLbSourceIpPersistanceChoice().(*OriginPoolAdvancedOptions_EnableLbSourceIpPersistance).EnableLbSourceIpPersistance
			vOpts := append(opts,
				db.WithValidateField("lb_source_ip_persistance_choice"),
				db.WithValidateField("enable_lb_source_ip_persistance"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_DisableLbSourceIpPersistance:
		if fv, exists := v.FldValidators["lb_source_ip_persistance_choice.disable_lb_source_ip_persistance"]; exists {
			val := m.GetLbSourceIpPersistanceChoice().(*OriginPoolAdvancedOptions_DisableLbSourceIpPersistance).DisableLbSourceIpPersistance
			vOpts := append(opts,
				db.WithValidateField("lb_source_ip_persistance_choice"),
				db.WithValidateField("disable_lb_source_ip_persistance"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["outlier_detection_choice"]; exists {
		val := m.GetOutlierDetectionChoice()
		vOpts := append(opts,
			db.WithValidateField("outlier_detection_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOutlierDetectionChoice().(type) {
	case *OriginPoolAdvancedOptions_DisableOutlierDetection:
		if fv, exists := v.FldValidators["outlier_detection_choice.disable_outlier_detection"]; exists {
			val := m.GetOutlierDetectionChoice().(*OriginPoolAdvancedOptions_DisableOutlierDetection).DisableOutlierDetection
			vOpts := append(opts,
				db.WithValidateField("outlier_detection_choice"),
				db.WithValidateField("disable_outlier_detection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_OutlierDetection:
		if fv, exists := v.FldValidators["outlier_detection_choice.outlier_detection"]; exists {
			val := m.GetOutlierDetectionChoice().(*OriginPoolAdvancedOptions_OutlierDetection).OutlierDetection
			vOpts := append(opts,
				db.WithValidateField("outlier_detection_choice"),
				db.WithValidateField("outlier_detection"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["panic_threshold_type"]; exists {
		val := m.GetPanicThresholdType()
		vOpts := append(opts,
			db.WithValidateField("panic_threshold_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPanicThresholdType().(type) {
	case *OriginPoolAdvancedOptions_NoPanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.no_panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*OriginPoolAdvancedOptions_NoPanicThreshold).NoPanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("no_panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_PanicThreshold:
		if fv, exists := v.FldValidators["panic_threshold_type.panic_threshold"]; exists {
			val := m.GetPanicThresholdType().(*OriginPoolAdvancedOptions_PanicThreshold).PanicThreshold
			vOpts := append(opts,
				db.WithValidateField("panic_threshold_type"),
				db.WithValidateField("panic_threshold"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetProxyProtocolChoice().(type) {
	case *OriginPoolAdvancedOptions_DisableProxyProtocol:
		if fv, exists := v.FldValidators["proxy_protocol_choice.disable_proxy_protocol"]; exists {
			val := m.GetProxyProtocolChoice().(*OriginPoolAdvancedOptions_DisableProxyProtocol).DisableProxyProtocol
			vOpts := append(opts,
				db.WithValidateField("proxy_protocol_choice"),
				db.WithValidateField("disable_proxy_protocol"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_ProxyProtocolV1:
		if fv, exists := v.FldValidators["proxy_protocol_choice.proxy_protocol_v1"]; exists {
			val := m.GetProxyProtocolChoice().(*OriginPoolAdvancedOptions_ProxyProtocolV1).ProxyProtocolV1
			vOpts := append(opts,
				db.WithValidateField("proxy_protocol_choice"),
				db.WithValidateField("proxy_protocol_v1"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_ProxyProtocolV2:
		if fv, exists := v.FldValidators["proxy_protocol_choice.proxy_protocol_v2"]; exists {
			val := m.GetProxyProtocolChoice().(*OriginPoolAdvancedOptions_ProxyProtocolV2).ProxyProtocolV2
			vOpts := append(opts,
				db.WithValidateField("proxy_protocol_choice"),
				db.WithValidateField("proxy_protocol_v2"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["subset_choice"]; exists {
		val := m.GetSubsetChoice()
		vOpts := append(opts,
			db.WithValidateField("subset_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSubsetChoice().(type) {
	case *OriginPoolAdvancedOptions_DisableSubsets:
		if fv, exists := v.FldValidators["subset_choice.disable_subsets"]; exists {
			val := m.GetSubsetChoice().(*OriginPoolAdvancedOptions_DisableSubsets).DisableSubsets
			vOpts := append(opts,
				db.WithValidateField("subset_choice"),
				db.WithValidateField("disable_subsets"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolAdvancedOptions_EnableSubsets:
		if fv, exists := v.FldValidators["subset_choice.enable_subsets"]; exists {
			val := m.GetSubsetChoice().(*OriginPoolAdvancedOptions_EnableSubsets).EnableSubsets
			vOpts := append(opts,
				db.WithValidateField("subset_choice"),
				db.WithValidateField("enable_subsets"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginPoolAdvancedOptionsValidator = func() *ValidateOriginPoolAdvancedOptions {
	v := &ValidateOriginPoolAdvancedOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCircuitBreakerChoice := v.CircuitBreakerChoiceValidationRuleHandler
	rulesCircuitBreakerChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCircuitBreakerChoice(rulesCircuitBreakerChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolAdvancedOptions.circuit_breaker_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["circuit_breaker_choice"] = vFn

	vrhHttpProtocolType := v.HttpProtocolTypeValidationRuleHandler
	rulesHttpProtocolType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpProtocolType(rulesHttpProtocolType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolAdvancedOptions.http_protocol_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_protocol_type"] = vFn

	vrhOutlierDetectionChoice := v.OutlierDetectionChoiceValidationRuleHandler
	rulesOutlierDetectionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhOutlierDetectionChoice(rulesOutlierDetectionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolAdvancedOptions.outlier_detection_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outlier_detection_choice"] = vFn

	vrhPanicThresholdType := v.PanicThresholdTypeValidationRuleHandler
	rulesPanicThresholdType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPanicThresholdType(rulesPanicThresholdType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolAdvancedOptions.panic_threshold_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["panic_threshold_type"] = vFn

	vrhPanicThresholdTypePanicThreshold := v.PanicThresholdTypePanicThresholdValidationRuleHandler
	rulesPanicThresholdTypePanicThreshold := map[string]string{
		"ves.io.schema.rules.uint32.lte": "100",
	}
	vFnMap["panic_threshold_type.panic_threshold"], err = vrhPanicThresholdTypePanicThreshold(rulesPanicThresholdTypePanicThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginPoolAdvancedOptions.panic_threshold_type_panic_threshold: %s", err)
		panic(errMsg)
	}

	v.FldValidators["panic_threshold_type.panic_threshold"] = vFnMap["panic_threshold_type.panic_threshold"]

	vrhSubsetChoice := v.SubsetChoiceValidationRuleHandler
	rulesSubsetChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSubsetChoice(rulesSubsetChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolAdvancedOptions.subset_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subset_choice"] = vFn

	vrhConnectionTimeout := v.ConnectionTimeoutValidationRuleHandler
	rulesConnectionTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "1800000",
	}
	vFn, err = vrhConnectionTimeout(rulesConnectionTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolAdvancedOptions.connection_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connection_timeout"] = vFn

	vrhHttpIdleTimeout := v.HttpIdleTimeoutValidationRuleHandler
	rulesHttpIdleTimeout := map[string]string{
		"ves.io.schema.rules.uint32.lte": "600000",
	}
	vFn, err = vrhHttpIdleTimeout(rulesHttpIdleTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolAdvancedOptions.http_idle_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_idle_timeout"] = vFn

	v.FldValidators["circuit_breaker_choice.circuit_breaker"] = ves_io_schema_cluster.CircuitBreakerValidator().Validate

	v.FldValidators["http_protocol_type.http1_config"] = ves_io_schema_cluster.Http1ProtocolOptionsValidator().Validate

	v.FldValidators["outlier_detection_choice.outlier_detection"] = ves_io_schema_cluster.OutlierDetectionTypeValidator().Validate

	v.FldValidators["subset_choice.enable_subsets"] = OriginPoolSubsetsValidator().Validate

	v.FldValidators["header_transformation_type"] = ves_io_schema.HeaderTransformationTypeValidator().Validate

	return v
}()

func OriginPoolAdvancedOptionsValidator() db.Validator {
	return DefaultOriginPoolAdvancedOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginPoolDefaultSubset) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginPoolDefaultSubset) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginPoolDefaultSubset) DeepCopy() *OriginPoolDefaultSubset {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginPoolDefaultSubset{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginPoolDefaultSubset) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginPoolDefaultSubset) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginPoolDefaultSubsetValidator().Validate(ctx, m, opts...)
}

type ValidateOriginPoolDefaultSubset struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginPoolDefaultSubset) DefaultSubsetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for default_subset")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for default_subset")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for default_subset")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map default_subset")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items default_subset")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolDefaultSubset) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginPoolDefaultSubset)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginPoolDefaultSubset got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_subset"]; exists {
		vOpts := append(opts, db.WithValidateField("default_subset"))
		if err := fv(ctx, m.GetDefaultSubset(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginPoolDefaultSubsetValidator = func() *ValidateOriginPoolDefaultSubset {
	v := &ValidateOriginPoolDefaultSubset{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDefaultSubset := v.DefaultSubsetValidationRuleHandler
	rulesDefaultSubset := map[string]string{
		"ves.io.schema.rules.map.max_pairs": "32",
	}
	vFn, err = vrhDefaultSubset(rulesDefaultSubset)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolDefaultSubset.default_subset: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_subset"] = vFn

	return v
}()

func OriginPoolDefaultSubsetValidator() db.Validator {
	return DefaultOriginPoolDefaultSubsetValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginPoolSubsets) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginPoolSubsets) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginPoolSubsets) DeepCopy() *OriginPoolSubsets {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginPoolSubsets{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginPoolSubsets) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginPoolSubsets) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginPoolSubsetsValidator().Validate(ctx, m, opts...)
}

type ValidateOriginPoolSubsets struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginPoolSubsets) FallbackPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fallback_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginPoolSubsets) EndpointSubsetsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for endpoint_subsets")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_cluster.EndpointSubsetSelectorType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_cluster.EndpointSubsetSelectorTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for endpoint_subsets")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_cluster.EndpointSubsetSelectorType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_cluster.EndpointSubsetSelectorType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated endpoint_subsets")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items endpoint_subsets")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginPoolSubsets) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginPoolSubsets)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginPoolSubsets got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["endpoint_subsets"]; exists {
		vOpts := append(opts, db.WithValidateField("endpoint_subsets"))
		if err := fv(ctx, m.GetEndpointSubsets(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fallback_policy_choice"]; exists {
		val := m.GetFallbackPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("fallback_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFallbackPolicyChoice().(type) {
	case *OriginPoolSubsets_AnyEndpoint:
		if fv, exists := v.FldValidators["fallback_policy_choice.any_endpoint"]; exists {
			val := m.GetFallbackPolicyChoice().(*OriginPoolSubsets_AnyEndpoint).AnyEndpoint
			vOpts := append(opts,
				db.WithValidateField("fallback_policy_choice"),
				db.WithValidateField("any_endpoint"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolSubsets_DefaultSubset:
		if fv, exists := v.FldValidators["fallback_policy_choice.default_subset"]; exists {
			val := m.GetFallbackPolicyChoice().(*OriginPoolSubsets_DefaultSubset).DefaultSubset
			vOpts := append(opts,
				db.WithValidateField("fallback_policy_choice"),
				db.WithValidateField("default_subset"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginPoolSubsets_FailRequest:
		if fv, exists := v.FldValidators["fallback_policy_choice.fail_request"]; exists {
			val := m.GetFallbackPolicyChoice().(*OriginPoolSubsets_FailRequest).FailRequest
			vOpts := append(opts,
				db.WithValidateField("fallback_policy_choice"),
				db.WithValidateField("fail_request"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginPoolSubsetsValidator = func() *ValidateOriginPoolSubsets {
	v := &ValidateOriginPoolSubsets{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFallbackPolicyChoice := v.FallbackPolicyChoiceValidationRuleHandler
	rulesFallbackPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFallbackPolicyChoice(rulesFallbackPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolSubsets.fallback_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fallback_policy_choice"] = vFn

	vrhEndpointSubsets := v.EndpointSubsetsValidationRuleHandler
	rulesEndpointSubsets := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhEndpointSubsets(rulesEndpointSubsets)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginPoolSubsets.endpoint_subsets: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_subsets"] = vFn

	v.FldValidators["fallback_policy_choice.default_subset"] = OriginPoolDefaultSubsetValidator().Validate

	return v
}()

func OriginPoolSubsetsValidator() db.Validator {
	return DefaultOriginPoolSubsetsValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerConsulService) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerConsulService) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerConsulService) DeepCopy() *OriginServerConsulService {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerConsulService{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerConsulService) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerConsulService) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerConsulServiceValidator().Validate(ctx, m, opts...)
}

func (m *OriginServerConsulService) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteLocatorDRefInfo()

}

// GetDRefInfo for the field's type
func (m *OriginServerConsulService) GetSiteLocatorDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSiteLocator() == nil {
		return nil, nil
	}

	drInfos, err := m.GetSiteLocator().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetSiteLocator().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "site_locator." + dri.DRField
	}
	return drInfos, err

}

type ValidateOriginServerConsulService struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerConsulService) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerConsulService) ServiceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_name")
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerConsulService) SiteLocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for site_locator")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.SiteLocatorValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerConsulService) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerConsulService)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerConsulService got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *OriginServerConsulService_InsideNetwork:
		if fv, exists := v.FldValidators["network_choice.inside_network"]; exists {
			val := m.GetNetworkChoice().(*OriginServerConsulService_InsideNetwork).InsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerConsulService_OutsideNetwork:
		if fv, exists := v.FldValidators["network_choice.outside_network"]; exists {
			val := m.GetNetworkChoice().(*OriginServerConsulService_OutsideNetwork).OutsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("outside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_name"]; exists {

		vOpts := append(opts, db.WithValidateField("service_name"))
		if err := fv(ctx, m.GetServiceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_locator"]; exists {

		vOpts := append(opts, db.WithValidateField("site_locator"))
		if err := fv(ctx, m.GetSiteLocator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerConsulServiceValidator = func() *ValidateOriginServerConsulService {
	v := &ValidateOriginServerConsulService{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerConsulService.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	vrhServiceName := v.ServiceNameValidationRuleHandler
	rulesServiceName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhServiceName(rulesServiceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerConsulService.service_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_name"] = vFn

	vrhSiteLocator := v.SiteLocatorValidationRuleHandler
	rulesSiteLocator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSiteLocator(rulesSiteLocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerConsulService.site_locator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_locator"] = vFn

	return v
}()

func OriginServerConsulServiceValidator() db.Validator {
	return DefaultOriginServerConsulServiceValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerCustomEndpoint) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerCustomEndpoint) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerCustomEndpoint) DeepCopy() *OriginServerCustomEndpoint {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerCustomEndpoint{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerCustomEndpoint) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerCustomEndpoint) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerCustomEndpointValidator().Validate(ctx, m, opts...)
}

func (m *OriginServerCustomEndpoint) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetEndpointDRefInfo()

}

func (m *OriginServerCustomEndpoint) GetEndpointDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetEndpoint()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("endpoint.Object")
	dri := db.DRefInfo{
		RefdType:   "endpoint.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "endpoint",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetEndpointDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *OriginServerCustomEndpoint) GetEndpointDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "endpoint.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: endpoint")
	}

	vref := m.GetEndpoint()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "endpoint.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateOriginServerCustomEndpoint struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerCustomEndpoint) EndpointValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for endpoint")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerCustomEndpoint) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerCustomEndpoint)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerCustomEndpoint got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["endpoint"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint"))
		if err := fv(ctx, m.GetEndpoint(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerCustomEndpointValidator = func() *ValidateOriginServerCustomEndpoint {
	v := &ValidateOriginServerCustomEndpoint{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEndpoint := v.EndpointValidationRuleHandler
	rulesEndpoint := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndpoint(rulesEndpoint)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerCustomEndpoint.endpoint: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint"] = vFn

	return v
}()

func OriginServerCustomEndpointValidator() db.Validator {
	return DefaultOriginServerCustomEndpointValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerK8SService) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerK8SService) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerK8SService) DeepCopy() *OriginServerK8SService {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerK8SService{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerK8SService) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerK8SService) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerK8SServiceValidator().Validate(ctx, m, opts...)
}

func (m *OriginServerK8SService) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSiteLocatorDRefInfo()

}

// GetDRefInfo for the field's type
func (m *OriginServerK8SService) GetSiteLocatorDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSiteLocator() == nil {
		return nil, nil
	}

	drInfos, err := m.GetSiteLocator().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetSiteLocator().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "site_locator." + dri.DRField
	}
	return drInfos, err

}

type ValidateOriginServerK8SService struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerK8SService) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerK8SService) ServiceInfoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_info")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerK8SService) ServiceInfoServiceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ServiceName, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_name")
	}
	return oValidatorFn_ServiceName, nil
}

func (v *ValidateOriginServerK8SService) SiteLocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for site_locator")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.SiteLocatorValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerK8SService) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerK8SService)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerK8SService got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *OriginServerK8SService_InsideNetwork:
		if fv, exists := v.FldValidators["network_choice.inside_network"]; exists {
			val := m.GetNetworkChoice().(*OriginServerK8SService_InsideNetwork).InsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerK8SService_OutsideNetwork:
		if fv, exists := v.FldValidators["network_choice.outside_network"]; exists {
			val := m.GetNetworkChoice().(*OriginServerK8SService_OutsideNetwork).OutsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("outside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerK8SService_Vk8SNetworks:
		if fv, exists := v.FldValidators["network_choice.vk8s_networks"]; exists {
			val := m.GetNetworkChoice().(*OriginServerK8SService_Vk8SNetworks).Vk8SNetworks
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("vk8s_networks"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["service_info"]; exists {
		val := m.GetServiceInfo()
		vOpts := append(opts,
			db.WithValidateField("service_info"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServiceInfo().(type) {
	case *OriginServerK8SService_ServiceName:
		if fv, exists := v.FldValidators["service_info.service_name"]; exists {
			val := m.GetServiceInfo().(*OriginServerK8SService_ServiceName).ServiceName
			vOpts := append(opts,
				db.WithValidateField("service_info"),
				db.WithValidateField("service_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerK8SService_ServiceSelector:
		if fv, exists := v.FldValidators["service_info.service_selector"]; exists {
			val := m.GetServiceInfo().(*OriginServerK8SService_ServiceSelector).ServiceSelector
			vOpts := append(opts,
				db.WithValidateField("service_info"),
				db.WithValidateField("service_selector"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_locator"]; exists {

		vOpts := append(opts, db.WithValidateField("site_locator"))
		if err := fv(ctx, m.GetSiteLocator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerK8SServiceValidator = func() *ValidateOriginServerK8SService {
	v := &ValidateOriginServerK8SService{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerK8SService.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	vrhServiceInfo := v.ServiceInfoValidationRuleHandler
	rulesServiceInfo := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServiceInfo(rulesServiceInfo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerK8SService.service_info: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_info"] = vFn

	vrhServiceInfoServiceName := v.ServiceInfoServiceNameValidationRuleHandler
	rulesServiceInfoServiceName := map[string]string{
		"ves.io.schema.rules.string.ves_service_namespace_name": "true",
	}
	vFnMap["service_info.service_name"], err = vrhServiceInfoServiceName(rulesServiceInfoServiceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginServerK8SService.service_info_service_name: %s", err)
		panic(errMsg)
	}

	v.FldValidators["service_info.service_name"] = vFnMap["service_info.service_name"]

	vrhSiteLocator := v.SiteLocatorValidationRuleHandler
	rulesSiteLocator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSiteLocator(rulesSiteLocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerK8SService.site_locator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_locator"] = vFn

	v.FldValidators["service_info.service_selector"] = ves_io_schema.LabelSelectorTypeValidator().Validate

	return v
}()

func OriginServerK8SServiceValidator() db.Validator {
	return DefaultOriginServerK8SServiceValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerPrivateIP) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerPrivateIP) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerPrivateIP) DeepCopy() *OriginServerPrivateIP {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerPrivateIP{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerPrivateIP) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerPrivateIP) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerPrivateIPValidator().Validate(ctx, m, opts...)
}

func (m *OriginServerPrivateIP) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetNetworkChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSiteLocatorDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSiteLocatorDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *OriginServerPrivateIP) GetNetworkChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetNetworkChoice().(type) {
	case *OriginServerPrivateIP_InsideNetwork:

		return nil, nil

	case *OriginServerPrivateIP_OutsideNetwork:

		return nil, nil

	case *OriginServerPrivateIP_Segment:

		vref := m.GetSegment()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("segment.Object")
		dri := db.DRefInfo{
			RefdType:   "segment.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "segment",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetNetworkChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *OriginServerPrivateIP) GetNetworkChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetNetworkChoice().(type) {
	case *OriginServerPrivateIP_InsideNetwork:

	case *OriginServerPrivateIP_OutsideNetwork:

	case *OriginServerPrivateIP_Segment:
		refdType, err := d.TypeForEntryKind("", "", "segment.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: segment")
		}

		vref := m.GetSegment()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "segment.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *OriginServerPrivateIP) GetSiteLocatorDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSiteLocator() == nil {
		return nil, nil
	}

	drInfos, err := m.GetSiteLocator().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetSiteLocator().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "site_locator." + dri.DRField
	}
	return drInfos, err

}

type ValidateOriginServerPrivateIP struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerPrivateIP) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerPrivateIP) NetworkChoiceSegmentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return ves_io_schema_views.ObjectRefTypeValidator().Validate, nil
}

func (v *ValidateOriginServerPrivateIP) PrivateIpChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for private_ip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerPrivateIP) PrivateIpChoiceIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ip, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}
	return oValidatorFn_Ip, nil
}
func (v *ValidateOriginServerPrivateIP) PrivateIpChoiceIpv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ipv6, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}
	return oValidatorFn_Ipv6, nil
}

func (v *ValidateOriginServerPrivateIP) SiteLocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for site_locator")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.SiteLocatorValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerPrivateIP) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerPrivateIP)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerPrivateIP got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *OriginServerPrivateIP_InsideNetwork:
		if fv, exists := v.FldValidators["network_choice.inside_network"]; exists {
			val := m.GetNetworkChoice().(*OriginServerPrivateIP_InsideNetwork).InsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerPrivateIP_OutsideNetwork:
		if fv, exists := v.FldValidators["network_choice.outside_network"]; exists {
			val := m.GetNetworkChoice().(*OriginServerPrivateIP_OutsideNetwork).OutsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("outside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerPrivateIP_Segment:
		if fv, exists := v.FldValidators["network_choice.segment"]; exists {
			val := m.GetNetworkChoice().(*OriginServerPrivateIP_Segment).Segment
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("segment"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["private_ip_choice"]; exists {
		val := m.GetPrivateIpChoice()
		vOpts := append(opts,
			db.WithValidateField("private_ip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPrivateIpChoice().(type) {
	case *OriginServerPrivateIP_Ip:
		if fv, exists := v.FldValidators["private_ip_choice.ip"]; exists {
			val := m.GetPrivateIpChoice().(*OriginServerPrivateIP_Ip).Ip
			vOpts := append(opts,
				db.WithValidateField("private_ip_choice"),
				db.WithValidateField("ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerPrivateIP_Ipv6:
		if fv, exists := v.FldValidators["private_ip_choice.ipv6"]; exists {
			val := m.GetPrivateIpChoice().(*OriginServerPrivateIP_Ipv6).Ipv6
			vOpts := append(opts,
				db.WithValidateField("private_ip_choice"),
				db.WithValidateField("ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_locator"]; exists {

		vOpts := append(opts, db.WithValidateField("site_locator"))
		if err := fv(ctx, m.GetSiteLocator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerPrivateIPValidator = func() *ValidateOriginServerPrivateIP {
	v := &ValidateOriginServerPrivateIP{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPrivateIP.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	vrhNetworkChoiceSegment := v.NetworkChoiceSegmentValidationRuleHandler
	rulesNetworkChoiceSegment := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["network_choice.segment"], err = vrhNetworkChoiceSegment(rulesNetworkChoiceSegment)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginServerPrivateIP.network_choice_segment: %s", err)
		panic(errMsg)
	}

	v.FldValidators["network_choice.segment"] = vFnMap["network_choice.segment"]

	vrhPrivateIpChoice := v.PrivateIpChoiceValidationRuleHandler
	rulesPrivateIpChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPrivateIpChoice(rulesPrivateIpChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPrivateIP.private_ip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["private_ip_choice"] = vFn

	vrhPrivateIpChoiceIp := v.PrivateIpChoiceIpValidationRuleHandler
	rulesPrivateIpChoiceIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["private_ip_choice.ip"], err = vrhPrivateIpChoiceIp(rulesPrivateIpChoiceIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginServerPrivateIP.private_ip_choice_ip: %s", err)
		panic(errMsg)
	}
	vrhPrivateIpChoiceIpv6 := v.PrivateIpChoiceIpv6ValidationRuleHandler
	rulesPrivateIpChoiceIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFnMap["private_ip_choice.ipv6"], err = vrhPrivateIpChoiceIpv6(rulesPrivateIpChoiceIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginServerPrivateIP.private_ip_choice_ipv6: %s", err)
		panic(errMsg)
	}

	v.FldValidators["private_ip_choice.ip"] = vFnMap["private_ip_choice.ip"]
	v.FldValidators["private_ip_choice.ipv6"] = vFnMap["private_ip_choice.ipv6"]

	vrhSiteLocator := v.SiteLocatorValidationRuleHandler
	rulesSiteLocator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSiteLocator(rulesSiteLocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPrivateIP.site_locator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_locator"] = vFn

	return v
}()

func OriginServerPrivateIPValidator() db.Validator {
	return DefaultOriginServerPrivateIPValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerPrivateName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerPrivateName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerPrivateName) DeepCopy() *OriginServerPrivateName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerPrivateName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerPrivateName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerPrivateName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerPrivateNameValidator().Validate(ctx, m, opts...)
}

func (m *OriginServerPrivateName) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetNetworkChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetSiteLocatorDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetSiteLocatorDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *OriginServerPrivateName) GetNetworkChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetNetworkChoice().(type) {
	case *OriginServerPrivateName_InsideNetwork:

		return nil, nil

	case *OriginServerPrivateName_OutsideNetwork:

		return nil, nil

	case *OriginServerPrivateName_Segment:

		vref := m.GetSegment()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("segment.Object")
		dri := db.DRefInfo{
			RefdType:   "segment.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "segment",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetNetworkChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *OriginServerPrivateName) GetNetworkChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetNetworkChoice().(type) {
	case *OriginServerPrivateName_InsideNetwork:

	case *OriginServerPrivateName_OutsideNetwork:

	case *OriginServerPrivateName_Segment:
		refdType, err := d.TypeForEntryKind("", "", "segment.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: segment")
		}

		vref := m.GetSegment()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "segment.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *OriginServerPrivateName) GetSiteLocatorDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSiteLocator() == nil {
		return nil, nil
	}

	drInfos, err := m.GetSiteLocator().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetSiteLocator().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "site_locator." + dri.DRField
	}
	return drInfos, err

}

type ValidateOriginServerPrivateName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerPrivateName) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerPrivateName) NetworkChoiceSegmentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return ves_io_schema_views.ObjectRefTypeValidator().Validate, nil
}

func (v *ValidateOriginServerPrivateName) DnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_name")
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerPrivateName) SiteLocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for site_locator")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.SiteLocatorValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerPrivateName) RefreshIntervalValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for refresh_interval")
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerPrivateName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerPrivateName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerPrivateName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_name"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_name"))
		if err := fv(ctx, m.GetDnsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *OriginServerPrivateName_InsideNetwork:
		if fv, exists := v.FldValidators["network_choice.inside_network"]; exists {
			val := m.GetNetworkChoice().(*OriginServerPrivateName_InsideNetwork).InsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerPrivateName_OutsideNetwork:
		if fv, exists := v.FldValidators["network_choice.outside_network"]; exists {
			val := m.GetNetworkChoice().(*OriginServerPrivateName_OutsideNetwork).OutsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("outside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerPrivateName_Segment:
		if fv, exists := v.FldValidators["network_choice.segment"]; exists {
			val := m.GetNetworkChoice().(*OriginServerPrivateName_Segment).Segment
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("segment"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["refresh_interval"]; exists {

		vOpts := append(opts, db.WithValidateField("refresh_interval"))
		if err := fv(ctx, m.GetRefreshInterval(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_locator"]; exists {

		vOpts := append(opts, db.WithValidateField("site_locator"))
		if err := fv(ctx, m.GetSiteLocator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerPrivateNameValidator = func() *ValidateOriginServerPrivateName {
	v := &ValidateOriginServerPrivateName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPrivateName.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	vrhNetworkChoiceSegment := v.NetworkChoiceSegmentValidationRuleHandler
	rulesNetworkChoiceSegment := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["network_choice.segment"], err = vrhNetworkChoiceSegment(rulesNetworkChoiceSegment)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginServerPrivateName.network_choice_segment: %s", err)
		panic(errMsg)
	}

	v.FldValidators["network_choice.segment"] = vFnMap["network_choice.segment"]

	vrhDnsName := v.DnsNameValidationRuleHandler
	rulesDnsName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDnsName(rulesDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPrivateName.dns_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_name"] = vFn

	vrhSiteLocator := v.SiteLocatorValidationRuleHandler
	rulesSiteLocator := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSiteLocator(rulesSiteLocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPrivateName.site_locator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_locator"] = vFn

	vrhRefreshInterval := v.RefreshIntervalValidationRuleHandler
	rulesRefreshInterval := map[string]string{
		"ves.io.schema.rules.uint32.lte": "604800",
	}
	vFn, err = vrhRefreshInterval(rulesRefreshInterval)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPrivateName.refresh_interval: %s", err)
		panic(errMsg)
	}
	v.FldValidators["refresh_interval"] = vFn

	return v
}()

func OriginServerPrivateNameValidator() db.Validator {
	return DefaultOriginServerPrivateNameValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerPublicIP) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerPublicIP) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerPublicIP) DeepCopy() *OriginServerPublicIP {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerPublicIP{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerPublicIP) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerPublicIP) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerPublicIPValidator().Validate(ctx, m, opts...)
}

type ValidateOriginServerPublicIP struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerPublicIP) PublicIpChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for public_ip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerPublicIP) PublicIpChoiceIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ip, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}
	return oValidatorFn_Ip, nil
}
func (v *ValidateOriginServerPublicIP) PublicIpChoiceIpv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ipv6, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}
	return oValidatorFn_Ipv6, nil
}

func (v *ValidateOriginServerPublicIP) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerPublicIP)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerPublicIP got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["public_ip_choice"]; exists {
		val := m.GetPublicIpChoice()
		vOpts := append(opts,
			db.WithValidateField("public_ip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPublicIpChoice().(type) {
	case *OriginServerPublicIP_Ip:
		if fv, exists := v.FldValidators["public_ip_choice.ip"]; exists {
			val := m.GetPublicIpChoice().(*OriginServerPublicIP_Ip).Ip
			vOpts := append(opts,
				db.WithValidateField("public_ip_choice"),
				db.WithValidateField("ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerPublicIP_Ipv6:
		if fv, exists := v.FldValidators["public_ip_choice.ipv6"]; exists {
			val := m.GetPublicIpChoice().(*OriginServerPublicIP_Ipv6).Ipv6
			vOpts := append(opts,
				db.WithValidateField("public_ip_choice"),
				db.WithValidateField("ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerPublicIPValidator = func() *ValidateOriginServerPublicIP {
	v := &ValidateOriginServerPublicIP{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPublicIpChoice := v.PublicIpChoiceValidationRuleHandler
	rulesPublicIpChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPublicIpChoice(rulesPublicIpChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPublicIP.public_ip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ip_choice"] = vFn

	vrhPublicIpChoiceIp := v.PublicIpChoiceIpValidationRuleHandler
	rulesPublicIpChoiceIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["public_ip_choice.ip"], err = vrhPublicIpChoiceIp(rulesPublicIpChoiceIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginServerPublicIP.public_ip_choice_ip: %s", err)
		panic(errMsg)
	}
	vrhPublicIpChoiceIpv6 := v.PublicIpChoiceIpv6ValidationRuleHandler
	rulesPublicIpChoiceIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFnMap["public_ip_choice.ipv6"], err = vrhPublicIpChoiceIpv6(rulesPublicIpChoiceIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginServerPublicIP.public_ip_choice_ipv6: %s", err)
		panic(errMsg)
	}

	v.FldValidators["public_ip_choice.ip"] = vFnMap["public_ip_choice.ip"]
	v.FldValidators["public_ip_choice.ipv6"] = vFnMap["public_ip_choice.ipv6"]

	return v
}()

func OriginServerPublicIPValidator() db.Validator {
	return DefaultOriginServerPublicIPValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerPublicName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerPublicName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerPublicName) DeepCopy() *OriginServerPublicName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerPublicName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerPublicName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerPublicName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerPublicNameValidator().Validate(ctx, m, opts...)
}

type ValidateOriginServerPublicName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerPublicName) DnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_name")
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerPublicName) RefreshIntervalValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for refresh_interval")
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerPublicName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerPublicName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerPublicName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_name"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_name"))
		if err := fv(ctx, m.GetDnsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["refresh_interval"]; exists {

		vOpts := append(opts, db.WithValidateField("refresh_interval"))
		if err := fv(ctx, m.GetRefreshInterval(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerPublicNameValidator = func() *ValidateOriginServerPublicName {
	v := &ValidateOriginServerPublicName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsName := v.DnsNameValidationRuleHandler
	rulesDnsName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.hostname":  "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDnsName(rulesDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPublicName.dns_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_name"] = vFn

	vrhRefreshInterval := v.RefreshIntervalValidationRuleHandler
	rulesRefreshInterval := map[string]string{
		"ves.io.schema.rules.uint32.lte": "604800",
	}
	vFn, err = vrhRefreshInterval(rulesRefreshInterval)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerPublicName.refresh_interval: %s", err)
		panic(errMsg)
	}
	v.FldValidators["refresh_interval"] = vFn

	return v
}()

func OriginServerPublicNameValidator() db.Validator {
	return DefaultOriginServerPublicNameValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerType) DeepCopy() *OriginServerType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerTypeValidator().Validate(ctx, m, opts...)
}

func (m *OriginServerType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *OriginServerType) GetChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetChoice() == nil {
		return nil, nil
	}
	switch m.GetChoice().(type) {
	case *OriginServerType_PublicIp:

		return nil, nil

	case *OriginServerType_PrivateIp:

		drInfos, err := m.GetPrivateIp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPrivateIp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "private_ip." + dri.DRField
		}
		return drInfos, err

	case *OriginServerType_PublicName:

		return nil, nil

	case *OriginServerType_PrivateName:

		drInfos, err := m.GetPrivateName().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPrivateName().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "private_name." + dri.DRField
		}
		return drInfos, err

	case *OriginServerType_K8SService:

		drInfos, err := m.GetK8SService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetK8SService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "k8s_service." + dri.DRField
		}
		return drInfos, err

	case *OriginServerType_ConsulService:

		drInfos, err := m.GetConsulService().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetConsulService().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "consul_service." + dri.DRField
		}
		return drInfos, err

	case *OriginServerType_CustomEndpointObject:

		drInfos, err := m.GetCustomEndpointObject().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCustomEndpointObject().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "custom_endpoint_object." + dri.DRField
		}
		return drInfos, err

	case *OriginServerType_VnPrivateIp:

		drInfos, err := m.GetVnPrivateIp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVnPrivateIp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vn_private_ip." + dri.DRField
		}
		return drInfos, err

	case *OriginServerType_VnPrivateName:

		drInfos, err := m.GetVnPrivateName().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetVnPrivateName().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "vn_private_name." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateOriginServerType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerType) ChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["choice"]; exists {
		val := m.GetChoice()
		vOpts := append(opts,
			db.WithValidateField("choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChoice().(type) {
	case *OriginServerType_PublicIp:
		if fv, exists := v.FldValidators["choice.public_ip"]; exists {
			val := m.GetChoice().(*OriginServerType_PublicIp).PublicIp
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("public_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerType_PrivateIp:
		if fv, exists := v.FldValidators["choice.private_ip"]; exists {
			val := m.GetChoice().(*OriginServerType_PrivateIp).PrivateIp
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("private_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerType_PublicName:
		if fv, exists := v.FldValidators["choice.public_name"]; exists {
			val := m.GetChoice().(*OriginServerType_PublicName).PublicName
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("public_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerType_PrivateName:
		if fv, exists := v.FldValidators["choice.private_name"]; exists {
			val := m.GetChoice().(*OriginServerType_PrivateName).PrivateName
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("private_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerType_K8SService:
		if fv, exists := v.FldValidators["choice.k8s_service"]; exists {
			val := m.GetChoice().(*OriginServerType_K8SService).K8SService
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("k8s_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerType_ConsulService:
		if fv, exists := v.FldValidators["choice.consul_service"]; exists {
			val := m.GetChoice().(*OriginServerType_ConsulService).ConsulService
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("consul_service"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerType_CustomEndpointObject:
		if fv, exists := v.FldValidators["choice.custom_endpoint_object"]; exists {
			val := m.GetChoice().(*OriginServerType_CustomEndpointObject).CustomEndpointObject
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("custom_endpoint_object"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerType_VnPrivateIp:
		if fv, exists := v.FldValidators["choice.vn_private_ip"]; exists {
			val := m.GetChoice().(*OriginServerType_VnPrivateIp).VnPrivateIp
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("vn_private_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerType_VnPrivateName:
		if fv, exists := v.FldValidators["choice.vn_private_name"]; exists {
			val := m.GetChoice().(*OriginServerType_VnPrivateName).VnPrivateName
			vOpts := append(opts,
				db.WithValidateField("choice"),
				db.WithValidateField("vn_private_name"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerTypeValidator = func() *ValidateOriginServerType {
	v := &ValidateOriginServerType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChoice := v.ChoiceValidationRuleHandler
	rulesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChoice(rulesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerType.choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["choice"] = vFn

	v.FldValidators["choice.public_ip"] = OriginServerPublicIPValidator().Validate
	v.FldValidators["choice.private_ip"] = OriginServerPrivateIPValidator().Validate
	v.FldValidators["choice.public_name"] = OriginServerPublicNameValidator().Validate
	v.FldValidators["choice.private_name"] = OriginServerPrivateNameValidator().Validate
	v.FldValidators["choice.k8s_service"] = OriginServerK8SServiceValidator().Validate
	v.FldValidators["choice.consul_service"] = OriginServerConsulServiceValidator().Validate
	v.FldValidators["choice.custom_endpoint_object"] = OriginServerCustomEndpointValidator().Validate
	v.FldValidators["choice.vn_private_ip"] = OriginServerVirtualNetworkIPValidator().Validate
	v.FldValidators["choice.vn_private_name"] = OriginServerVirtualNetworkNameValidator().Validate

	return v
}()

func OriginServerTypeValidator() db.Validator {
	return DefaultOriginServerTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerVirtualNetworkIP) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerVirtualNetworkIP) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerVirtualNetworkIP) DeepCopy() *OriginServerVirtualNetworkIP {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerVirtualNetworkIP{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerVirtualNetworkIP) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerVirtualNetworkIP) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerVirtualNetworkIPValidator().Validate(ctx, m, opts...)
}

func (m *OriginServerVirtualNetworkIP) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetVirtualNetworkDRefInfo()

}

func (m *OriginServerVirtualNetworkIP) GetVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetVirtualNetwork()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_network.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_network.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "virtual_network",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *OriginServerVirtualNetworkIP) GetVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}

	vref := m.GetVirtualNetwork()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_network.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateOriginServerVirtualNetworkIP struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerVirtualNetworkIP) VirtualNetworkIpChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for virtual_network_ip_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOriginServerVirtualNetworkIP) VirtualNetworkIpChoiceIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ip, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip")
	}
	return oValidatorFn_Ip, nil
}
func (v *ValidateOriginServerVirtualNetworkIP) VirtualNetworkIpChoiceIpv6ValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ipv6, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6")
	}
	return oValidatorFn_Ipv6, nil
}

func (v *ValidateOriginServerVirtualNetworkIP) VirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for virtual_network")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerVirtualNetworkIP) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerVirtualNetworkIP)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerVirtualNetworkIP got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["virtual_network"]; exists {

		vOpts := append(opts, db.WithValidateField("virtual_network"))
		if err := fv(ctx, m.GetVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_network_ip_choice"]; exists {
		val := m.GetVirtualNetworkIpChoice()
		vOpts := append(opts,
			db.WithValidateField("virtual_network_ip_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVirtualNetworkIpChoice().(type) {
	case *OriginServerVirtualNetworkIP_Ip:
		if fv, exists := v.FldValidators["virtual_network_ip_choice.ip"]; exists {
			val := m.GetVirtualNetworkIpChoice().(*OriginServerVirtualNetworkIP_Ip).Ip
			vOpts := append(opts,
				db.WithValidateField("virtual_network_ip_choice"),
				db.WithValidateField("ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OriginServerVirtualNetworkIP_Ipv6:
		if fv, exists := v.FldValidators["virtual_network_ip_choice.ipv6"]; exists {
			val := m.GetVirtualNetworkIpChoice().(*OriginServerVirtualNetworkIP_Ipv6).Ipv6
			vOpts := append(opts,
				db.WithValidateField("virtual_network_ip_choice"),
				db.WithValidateField("ipv6"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerVirtualNetworkIPValidator = func() *ValidateOriginServerVirtualNetworkIP {
	v := &ValidateOriginServerVirtualNetworkIP{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVirtualNetworkIpChoice := v.VirtualNetworkIpChoiceValidationRuleHandler
	rulesVirtualNetworkIpChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVirtualNetworkIpChoice(rulesVirtualNetworkIpChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerVirtualNetworkIP.virtual_network_ip_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_network_ip_choice"] = vFn

	vrhVirtualNetworkIpChoiceIp := v.VirtualNetworkIpChoiceIpValidationRuleHandler
	rulesVirtualNetworkIpChoiceIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["virtual_network_ip_choice.ip"], err = vrhVirtualNetworkIpChoiceIp(rulesVirtualNetworkIpChoiceIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginServerVirtualNetworkIP.virtual_network_ip_choice_ip: %s", err)
		panic(errMsg)
	}
	vrhVirtualNetworkIpChoiceIpv6 := v.VirtualNetworkIpChoiceIpv6ValidationRuleHandler
	rulesVirtualNetworkIpChoiceIpv6 := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFnMap["virtual_network_ip_choice.ipv6"], err = vrhVirtualNetworkIpChoiceIpv6(rulesVirtualNetworkIpChoiceIpv6)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OriginServerVirtualNetworkIP.virtual_network_ip_choice_ipv6: %s", err)
		panic(errMsg)
	}

	v.FldValidators["virtual_network_ip_choice.ip"] = vFnMap["virtual_network_ip_choice.ip"]
	v.FldValidators["virtual_network_ip_choice.ipv6"] = vFnMap["virtual_network_ip_choice.ipv6"]

	vrhVirtualNetwork := v.VirtualNetworkValidationRuleHandler
	rulesVirtualNetwork := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVirtualNetwork(rulesVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerVirtualNetworkIP.virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_network"] = vFn

	return v
}()

func OriginServerVirtualNetworkIPValidator() db.Validator {
	return DefaultOriginServerVirtualNetworkIPValidator
}

// augmented methods on protoc/std generated struct

func (m *OriginServerVirtualNetworkName) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OriginServerVirtualNetworkName) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OriginServerVirtualNetworkName) DeepCopy() *OriginServerVirtualNetworkName {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OriginServerVirtualNetworkName{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OriginServerVirtualNetworkName) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OriginServerVirtualNetworkName) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OriginServerVirtualNetworkNameValidator().Validate(ctx, m, opts...)
}

func (m *OriginServerVirtualNetworkName) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPrivateNetworkDRefInfo()

}

func (m *OriginServerVirtualNetworkName) GetPrivateNetworkDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetPrivateNetwork()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("virtual_network.Object")
	dri := db.DRefInfo{
		RefdType:   "virtual_network.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "private_network",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetPrivateNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *OriginServerVirtualNetworkName) GetPrivateNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}

	vref := m.GetPrivateNetwork()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "virtual_network.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateOriginServerVirtualNetworkName struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOriginServerVirtualNetworkName) DnsNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_name")
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerVirtualNetworkName) PrivateNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for private_network")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOriginServerVirtualNetworkName) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OriginServerVirtualNetworkName)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OriginServerVirtualNetworkName got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_name"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_name"))
		if err := fv(ctx, m.GetDnsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_network"]; exists {

		vOpts := append(opts, db.WithValidateField("private_network"))
		if err := fv(ctx, m.GetPrivateNetwork(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOriginServerVirtualNetworkNameValidator = func() *ValidateOriginServerVirtualNetworkName {
	v := &ValidateOriginServerVirtualNetworkName{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsName := v.DnsNameValidationRuleHandler
	rulesDnsName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDnsName(rulesDnsName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerVirtualNetworkName.dns_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_name"] = vFn

	vrhPrivateNetwork := v.PrivateNetworkValidationRuleHandler
	rulesPrivateNetwork := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPrivateNetwork(rulesPrivateNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OriginServerVirtualNetworkName.private_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["private_network"] = vFn

	return v
}()

func OriginServerVirtualNetworkNameValidator() db.Validator {
	return DefaultOriginServerVirtualNetworkNameValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetUseTls().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.use_tls")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetHealthcheckDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetHealthcheckDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOriginServersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetOriginServersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTlsChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTlsChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *ReplaceSpecType) GetHealthcheckDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetHealthcheck()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.healthcheck[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("healthcheck.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "healthcheck.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "healthcheck",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetHealthcheckDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetHealthcheckDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "healthcheck.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: healthcheck")
	}
	for i, vref := range m.GetHealthcheck() {
		if vref == nil {
			return nil, fmt.Errorf("ReplaceSpecType.healthcheck[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "healthcheck.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetOriginServersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOriginServers() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetOriginServers() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOriginServers() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("origin_servers[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetTlsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTlsChoice() == nil {
		return nil, nil
	}
	switch m.GetTlsChoice().(type) {
	case *ReplaceSpecType_NoTls:

		return nil, nil

	case *ReplaceSpecType_UseTls:

		drInfos, err := m.GetUseTls().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetUseTls().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "use_tls." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) HealthCheckPortChoiceHealthCheckPortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_HealthCheckPort, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for health_check_port")
	}
	return oValidatorFn_HealthCheckPort, nil
}

func (v *ValidateReplaceSpecType) PortChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) PortChoicePortValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Port, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for port")
	}
	return oValidatorFn_Port, nil
}

func (v *ValidateReplaceSpecType) TlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OriginServersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for origin_servers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*OriginServerType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := OriginServerTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for origin_servers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OriginServerType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OriginServerType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated origin_servers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items origin_servers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) HealthcheckValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for healthcheck")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for healthcheck")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated healthcheck")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items healthcheck")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) LoadbalancerAlgorithmValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_cluster.LoadbalancerAlgorithm)
		return int32(i)
	}
	// ves_io_schema_cluster.LoadbalancerAlgorithm_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_cluster.LoadbalancerAlgorithm_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for loadbalancer_algorithm")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) EndpointSelectionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_cluster.EndpointSelectionPolicy)
		return int32(i)
	}
	// ves_io_schema_cluster.EndpointSelectionPolicy_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_cluster.EndpointSelectionPolicy_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for endpoint_selection")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["advanced_options"]; exists {

		vOpts := append(opts, db.WithValidateField("advanced_options"))
		if err := fv(ctx, m.GetAdvancedOptions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["endpoint_selection"]; exists {

		vOpts := append(opts, db.WithValidateField("endpoint_selection"))
		if err := fv(ctx, m.GetEndpointSelection(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetHealthCheckPortChoice().(type) {
	case *ReplaceSpecType_SameAsEndpointPort:
		if fv, exists := v.FldValidators["health_check_port_choice.same_as_endpoint_port"]; exists {
			val := m.GetHealthCheckPortChoice().(*ReplaceSpecType_SameAsEndpointPort).SameAsEndpointPort
			vOpts := append(opts,
				db.WithValidateField("health_check_port_choice"),
				db.WithValidateField("same_as_endpoint_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_HealthCheckPort:
		if fv, exists := v.FldValidators["health_check_port_choice.health_check_port"]; exists {
			val := m.GetHealthCheckPortChoice().(*ReplaceSpecType_HealthCheckPort).HealthCheckPort
			vOpts := append(opts,
				db.WithValidateField("health_check_port_choice"),
				db.WithValidateField("health_check_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["healthcheck"]; exists {
		vOpts := append(opts, db.WithValidateField("healthcheck"))
		if err := fv(ctx, m.GetHealthcheck(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["loadbalancer_algorithm"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancer_algorithm"))
		if err := fv(ctx, m.GetLoadbalancerAlgorithm(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["origin_servers"]; exists {
		vOpts := append(opts, db.WithValidateField("origin_servers"))
		if err := fv(ctx, m.GetOriginServers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port_choice"]; exists {
		val := m.GetPortChoice()
		vOpts := append(opts,
			db.WithValidateField("port_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPortChoice().(type) {
	case *ReplaceSpecType_Port:
		if fv, exists := v.FldValidators["port_choice.port"]; exists {
			val := m.GetPortChoice().(*ReplaceSpecType_Port).Port
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AutomaticPort:
		if fv, exists := v.FldValidators["port_choice.automatic_port"]; exists {
			val := m.GetPortChoice().(*ReplaceSpecType_AutomaticPort).AutomaticPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("automatic_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_LbPort:
		if fv, exists := v.FldValidators["port_choice.lb_port"]; exists {
			val := m.GetPortChoice().(*ReplaceSpecType_LbPort).LbPort
			vOpts := append(opts,
				db.WithValidateField("port_choice"),
				db.WithValidateField("lb_port"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_choice"]; exists {
		val := m.GetTlsChoice()
		vOpts := append(opts,
			db.WithValidateField("tls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTlsChoice().(type) {
	case *ReplaceSpecType_NoTls:
		if fv, exists := v.FldValidators["tls_choice.no_tls"]; exists {
			val := m.GetTlsChoice().(*ReplaceSpecType_NoTls).NoTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("no_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_UseTls:
		if fv, exists := v.FldValidators["tls_choice.use_tls"]; exists {
			val := m.GetTlsChoice().(*ReplaceSpecType_UseTls).UseTls
			vOpts := append(opts,
				db.WithValidateField("tls_choice"),
				db.WithValidateField("use_tls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHealthCheckPortChoiceHealthCheckPort := v.HealthCheckPortChoiceHealthCheckPortValidationRuleHandler
	rulesHealthCheckPortChoiceHealthCheckPort := map[string]string{
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["health_check_port_choice.health_check_port"], err = vrhHealthCheckPortChoiceHealthCheckPort(rulesHealthCheckPortChoiceHealthCheckPort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.health_check_port_choice_health_check_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["health_check_port_choice.health_check_port"] = vFnMap["health_check_port_choice.health_check_port"]

	vrhPortChoice := v.PortChoiceValidationRuleHandler
	rulesPortChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPortChoice(rulesPortChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.port_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["port_choice"] = vFn

	vrhPortChoicePort := v.PortChoicePortValidationRuleHandler
	rulesPortChoicePort := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFnMap["port_choice.port"], err = vrhPortChoicePort(rulesPortChoicePort)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.port_choice_port: %s", err)
		panic(errMsg)
	}

	v.FldValidators["port_choice.port"] = vFnMap["port_choice.port"]

	vrhTlsChoice := v.TlsChoiceValidationRuleHandler
	rulesTlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTlsChoice(rulesTlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.tls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_choice"] = vFn

	vrhOriginServers := v.OriginServersValidationRuleHandler
	rulesOriginServers := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhOriginServers(rulesOriginServers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.origin_servers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["origin_servers"] = vFn

	vrhHealthcheck := v.HealthcheckValidationRuleHandler
	rulesHealthcheck := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "4",
	}
	vFn, err = vrhHealthcheck(rulesHealthcheck)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.healthcheck: %s", err)
		panic(errMsg)
	}
	v.FldValidators["healthcheck"] = vFn

	vrhLoadbalancerAlgorithm := v.LoadbalancerAlgorithmValidationRuleHandler
	rulesLoadbalancerAlgorithm := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLoadbalancerAlgorithm(rulesLoadbalancerAlgorithm)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.loadbalancer_algorithm: %s", err)
		panic(errMsg)
	}
	v.FldValidators["loadbalancer_algorithm"] = vFn

	vrhEndpointSelection := v.EndpointSelectionValidationRuleHandler
	rulesEndpointSelection := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhEndpointSelection(rulesEndpointSelection)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.endpoint_selection: %s", err)
		panic(errMsg)
	}
	v.FldValidators["endpoint_selection"] = vFn

	v.FldValidators["tls_choice.use_tls"] = UpstreamTlsParametersValidator().Validate

	v.FldValidators["advanced_options"] = OriginPoolAdvancedOptionsValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TlsCertificatesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TlsCertificatesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *TlsCertificatesType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetTlsCertificates() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting TlsCertificatesType.tls_certificates idx %v", idx)
		}
	}

	return nil
}

func (m *TlsCertificatesType) DeepCopy() *TlsCertificatesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TlsCertificatesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TlsCertificatesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TlsCertificatesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TlsCertificatesTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTlsCertificatesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTlsCertificatesType) TlsCertificatesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for tls_certificates")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.TlsCertificateType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.TlsCertificateTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tls_certificates")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.TlsCertificateType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.TlsCertificateType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tls_certificates")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tls_certificates")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTlsCertificatesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TlsCertificatesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TlsCertificatesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tls_certificates"]; exists {
		vOpts := append(opts, db.WithValidateField("tls_certificates"))
		if err := fv(ctx, m.GetTlsCertificates(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTlsCertificatesTypeValidator = func() *ValidateTlsCertificatesType {
	v := &ValidateTlsCertificatesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTlsCertificates := v.TlsCertificatesValidationRuleHandler
	rulesTlsCertificates := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhTlsCertificates(rulesTlsCertificates)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TlsCertificatesType.tls_certificates: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_certificates"] = vFn

	return v
}()

func TlsCertificatesTypeValidator() db.Validator {
	return DefaultTlsCertificatesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *UpstreamTlsParameters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpstreamTlsParameters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *UpstreamTlsParameters) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetUseMtls().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting UpstreamTlsParameters.use_mtls")
	}

	return nil
}

func (m *UpstreamTlsParameters) DeepCopy() *UpstreamTlsParameters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpstreamTlsParameters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpstreamTlsParameters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpstreamTlsParameters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpstreamTlsParametersValidator().Validate(ctx, m, opts...)
}

func (m *UpstreamTlsParameters) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetMtlsChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetMtlsChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServerValidationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServerValidationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *UpstreamTlsParameters) GetMtlsChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetMtlsChoice().(type) {
	case *UpstreamTlsParameters_NoMtls:

		return nil, nil

	case *UpstreamTlsParameters_UseMtls:

		return nil, nil

	case *UpstreamTlsParameters_UseMtlsObj:

		vref := m.GetUseMtlsObj()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("certificate.Object")
		dri := db.DRefInfo{
			RefdType:   "certificate.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "use_mtls_obj",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetMtlsChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *UpstreamTlsParameters) GetMtlsChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetMtlsChoice().(type) {
	case *UpstreamTlsParameters_NoMtls:

	case *UpstreamTlsParameters_UseMtls:

	case *UpstreamTlsParameters_UseMtlsObj:
		refdType, err := d.TypeForEntryKind("", "", "certificate.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: certificate")
		}

		vref := m.GetUseMtlsObj()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "certificate.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *UpstreamTlsParameters) GetServerValidationChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetServerValidationChoice() == nil {
		return nil, nil
	}
	switch m.GetServerValidationChoice().(type) {
	case *UpstreamTlsParameters_UseServerVerification:

		drInfos, err := m.GetUseServerVerification().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetUseServerVerification().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "use_server_verification." + dri.DRField
		}
		return drInfos, err

	case *UpstreamTlsParameters_SkipServerVerification:

		return nil, nil

	case *UpstreamTlsParameters_VolterraTrustedCa:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateUpstreamTlsParameters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpstreamTlsParameters) MaxSessionKeysTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_session_keys_type")
	}
	return validatorFn, nil
}

func (v *ValidateUpstreamTlsParameters) MaxSessionKeysTypeMaxSessionKeysValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_MaxSessionKeys, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_session_keys")
	}
	return oValidatorFn_MaxSessionKeys, nil
}

func (v *ValidateUpstreamTlsParameters) MtlsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtls_choice")
	}
	return validatorFn, nil
}

func (v *ValidateUpstreamTlsParameters) ServerValidationChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for server_validation_choice")
	}
	return validatorFn, nil
}

func (v *ValidateUpstreamTlsParameters) SniChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sni_choice")
	}
	return validatorFn, nil
}

func (v *ValidateUpstreamTlsParameters) SniChoiceSniValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Sni, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for sni")
	}
	return oValidatorFn_Sni, nil
}

func (v *ValidateUpstreamTlsParameters) TlsConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for tls_config")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.TlsConfigValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateUpstreamTlsParameters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpstreamTlsParameters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpstreamTlsParameters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["max_session_keys_type"]; exists {
		val := m.GetMaxSessionKeysType()
		vOpts := append(opts,
			db.WithValidateField("max_session_keys_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMaxSessionKeysType().(type) {
	case *UpstreamTlsParameters_DefaultSessionKeyCaching:
		if fv, exists := v.FldValidators["max_session_keys_type.default_session_key_caching"]; exists {
			val := m.GetMaxSessionKeysType().(*UpstreamTlsParameters_DefaultSessionKeyCaching).DefaultSessionKeyCaching
			vOpts := append(opts,
				db.WithValidateField("max_session_keys_type"),
				db.WithValidateField("default_session_key_caching"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpstreamTlsParameters_DisableSessionKeyCaching:
		if fv, exists := v.FldValidators["max_session_keys_type.disable_session_key_caching"]; exists {
			val := m.GetMaxSessionKeysType().(*UpstreamTlsParameters_DisableSessionKeyCaching).DisableSessionKeyCaching
			vOpts := append(opts,
				db.WithValidateField("max_session_keys_type"),
				db.WithValidateField("disable_session_key_caching"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpstreamTlsParameters_MaxSessionKeys:
		if fv, exists := v.FldValidators["max_session_keys_type.max_session_keys"]; exists {
			val := m.GetMaxSessionKeysType().(*UpstreamTlsParameters_MaxSessionKeys).MaxSessionKeys
			vOpts := append(opts,
				db.WithValidateField("max_session_keys_type"),
				db.WithValidateField("max_session_keys"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtls_choice"]; exists {
		val := m.GetMtlsChoice()
		vOpts := append(opts,
			db.WithValidateField("mtls_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMtlsChoice().(type) {
	case *UpstreamTlsParameters_NoMtls:
		if fv, exists := v.FldValidators["mtls_choice.no_mtls"]; exists {
			val := m.GetMtlsChoice().(*UpstreamTlsParameters_NoMtls).NoMtls
			vOpts := append(opts,
				db.WithValidateField("mtls_choice"),
				db.WithValidateField("no_mtls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpstreamTlsParameters_UseMtls:
		if fv, exists := v.FldValidators["mtls_choice.use_mtls"]; exists {
			val := m.GetMtlsChoice().(*UpstreamTlsParameters_UseMtls).UseMtls
			vOpts := append(opts,
				db.WithValidateField("mtls_choice"),
				db.WithValidateField("use_mtls"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpstreamTlsParameters_UseMtlsObj:
		if fv, exists := v.FldValidators["mtls_choice.use_mtls_obj"]; exists {
			val := m.GetMtlsChoice().(*UpstreamTlsParameters_UseMtlsObj).UseMtlsObj
			vOpts := append(opts,
				db.WithValidateField("mtls_choice"),
				db.WithValidateField("use_mtls_obj"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["server_validation_choice"]; exists {
		val := m.GetServerValidationChoice()
		vOpts := append(opts,
			db.WithValidateField("server_validation_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServerValidationChoice().(type) {
	case *UpstreamTlsParameters_UseServerVerification:
		if fv, exists := v.FldValidators["server_validation_choice.use_server_verification"]; exists {
			val := m.GetServerValidationChoice().(*UpstreamTlsParameters_UseServerVerification).UseServerVerification
			vOpts := append(opts,
				db.WithValidateField("server_validation_choice"),
				db.WithValidateField("use_server_verification"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpstreamTlsParameters_SkipServerVerification:
		if fv, exists := v.FldValidators["server_validation_choice.skip_server_verification"]; exists {
			val := m.GetServerValidationChoice().(*UpstreamTlsParameters_SkipServerVerification).SkipServerVerification
			vOpts := append(opts,
				db.WithValidateField("server_validation_choice"),
				db.WithValidateField("skip_server_verification"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpstreamTlsParameters_VolterraTrustedCa:
		if fv, exists := v.FldValidators["server_validation_choice.volterra_trusted_ca"]; exists {
			val := m.GetServerValidationChoice().(*UpstreamTlsParameters_VolterraTrustedCa).VolterraTrustedCa
			vOpts := append(opts,
				db.WithValidateField("server_validation_choice"),
				db.WithValidateField("volterra_trusted_ca"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["sni_choice"]; exists {
		val := m.GetSniChoice()
		vOpts := append(opts,
			db.WithValidateField("sni_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSniChoice().(type) {
	case *UpstreamTlsParameters_Sni:
		if fv, exists := v.FldValidators["sni_choice.sni"]; exists {
			val := m.GetSniChoice().(*UpstreamTlsParameters_Sni).Sni
			vOpts := append(opts,
				db.WithValidateField("sni_choice"),
				db.WithValidateField("sni"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpstreamTlsParameters_UseHostHeaderAsSni:
		if fv, exists := v.FldValidators["sni_choice.use_host_header_as_sni"]; exists {
			val := m.GetSniChoice().(*UpstreamTlsParameters_UseHostHeaderAsSni).UseHostHeaderAsSni
			vOpts := append(opts,
				db.WithValidateField("sni_choice"),
				db.WithValidateField("use_host_header_as_sni"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpstreamTlsParameters_DisableSni:
		if fv, exists := v.FldValidators["sni_choice.disable_sni"]; exists {
			val := m.GetSniChoice().(*UpstreamTlsParameters_DisableSni).DisableSni
			vOpts := append(opts,
				db.WithValidateField("sni_choice"),
				db.WithValidateField("disable_sni"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tls_config"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_config"))
		if err := fv(ctx, m.GetTlsConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpstreamTlsParametersValidator = func() *ValidateUpstreamTlsParameters {
	v := &ValidateUpstreamTlsParameters{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMaxSessionKeysType := v.MaxSessionKeysTypeValidationRuleHandler
	rulesMaxSessionKeysType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMaxSessionKeysType(rulesMaxSessionKeysType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpstreamTlsParameters.max_session_keys_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_session_keys_type"] = vFn

	vrhMaxSessionKeysTypeMaxSessionKeys := v.MaxSessionKeysTypeMaxSessionKeysValidationRuleHandler
	rulesMaxSessionKeysTypeMaxSessionKeys := map[string]string{
		"ves.io.schema.rules.uint32.gte": "2",
		"ves.io.schema.rules.uint32.lte": "64",
	}
	vFnMap["max_session_keys_type.max_session_keys"], err = vrhMaxSessionKeysTypeMaxSessionKeys(rulesMaxSessionKeysTypeMaxSessionKeys)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field UpstreamTlsParameters.max_session_keys_type_max_session_keys: %s", err)
		panic(errMsg)
	}

	v.FldValidators["max_session_keys_type.max_session_keys"] = vFnMap["max_session_keys_type.max_session_keys"]

	vrhMtlsChoice := v.MtlsChoiceValidationRuleHandler
	rulesMtlsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMtlsChoice(rulesMtlsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpstreamTlsParameters.mtls_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtls_choice"] = vFn

	vrhServerValidationChoice := v.ServerValidationChoiceValidationRuleHandler
	rulesServerValidationChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServerValidationChoice(rulesServerValidationChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpstreamTlsParameters.server_validation_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_validation_choice"] = vFn

	vrhSniChoice := v.SniChoiceValidationRuleHandler
	rulesSniChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSniChoice(rulesSniChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpstreamTlsParameters.sni_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sni_choice"] = vFn

	vrhSniChoiceSni := v.SniChoiceSniValidationRuleHandler
	rulesSniChoiceSni := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
		"ves.io.schema.rules.string.max_len":  "256",
	}
	vFnMap["sni_choice.sni"], err = vrhSniChoiceSni(rulesSniChoiceSni)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field UpstreamTlsParameters.sni_choice_sni: %s", err)
		panic(errMsg)
	}

	v.FldValidators["sni_choice.sni"] = vFnMap["sni_choice.sni"]

	vrhTlsConfig := v.TlsConfigValidationRuleHandler
	rulesTlsConfig := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTlsConfig(rulesTlsConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpstreamTlsParameters.tls_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tls_config"] = vFn

	v.FldValidators["mtls_choice.use_mtls"] = TlsCertificatesTypeValidator().Validate
	v.FldValidators["mtls_choice.use_mtls_obj"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["server_validation_choice.use_server_verification"] = UpstreamTlsValidationContextValidator().Validate

	return v
}()

func UpstreamTlsParametersValidator() db.Validator {
	return DefaultUpstreamTlsParametersValidator
}

// augmented methods on protoc/std generated struct

func (m *UpstreamTlsValidationContext) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpstreamTlsValidationContext) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpstreamTlsValidationContext) DeepCopy() *UpstreamTlsValidationContext {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpstreamTlsValidationContext{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpstreamTlsValidationContext) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpstreamTlsValidationContext) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpstreamTlsValidationContextValidator().Validate(ctx, m, opts...)
}

func (m *UpstreamTlsValidationContext) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetTrustedCaChoiceDRefInfo()

}

func (m *UpstreamTlsValidationContext) GetTrustedCaChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetTrustedCaChoice().(type) {
	case *UpstreamTlsValidationContext_TrustedCa:

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("trusted_ca_list.Object")
		dri := db.DRefInfo{
			RefdType:   "trusted_ca_list.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "trusted_ca",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetTrustedCaChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *UpstreamTlsValidationContext) GetTrustedCaChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetTrustedCaChoice().(type) {
	case *UpstreamTlsValidationContext_TrustedCa:
		refdType, err := d.TypeForEntryKind("", "", "trusted_ca_list.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: trusted_ca_list")
		}

		vref := m.GetTrustedCa()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "trusted_ca_list.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateUpstreamTlsValidationContext struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpstreamTlsValidationContext) TrustedCaChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_choice")
	}
	return validatorFn, nil
}

func (v *ValidateUpstreamTlsValidationContext) TrustedCaChoiceTrustedCaUrlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_TrustedCaUrl, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for trusted_ca_url")
	}
	return oValidatorFn_TrustedCaUrl, nil
}

func (v *ValidateUpstreamTlsValidationContext) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpstreamTlsValidationContext)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpstreamTlsValidationContext got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["trusted_ca_choice"]; exists {
		val := m.GetTrustedCaChoice()
		vOpts := append(opts,
			db.WithValidateField("trusted_ca_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTrustedCaChoice().(type) {
	case *UpstreamTlsValidationContext_TrustedCaUrl:
		if fv, exists := v.FldValidators["trusted_ca_choice.trusted_ca_url"]; exists {
			val := m.GetTrustedCaChoice().(*UpstreamTlsValidationContext_TrustedCaUrl).TrustedCaUrl
			vOpts := append(opts,
				db.WithValidateField("trusted_ca_choice"),
				db.WithValidateField("trusted_ca_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *UpstreamTlsValidationContext_TrustedCa:
		if fv, exists := v.FldValidators["trusted_ca_choice.trusted_ca"]; exists {
			val := m.GetTrustedCaChoice().(*UpstreamTlsValidationContext_TrustedCa).TrustedCa
			vOpts := append(opts,
				db.WithValidateField("trusted_ca_choice"),
				db.WithValidateField("trusted_ca"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpstreamTlsValidationContextValidator = func() *ValidateUpstreamTlsValidationContext {
	v := &ValidateUpstreamTlsValidationContext{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTrustedCaChoice := v.TrustedCaChoiceValidationRuleHandler
	rulesTrustedCaChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTrustedCaChoice(rulesTrustedCaChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for UpstreamTlsValidationContext.trusted_ca_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["trusted_ca_choice"] = vFn

	vrhTrustedCaChoiceTrustedCaUrl := v.TrustedCaChoiceTrustedCaUrlValidationRuleHandler
	rulesTrustedCaChoiceTrustedCaUrl := map[string]string{
		"ves.io.schema.rules.string.max_bytes":      "131072",
		"ves.io.schema.rules.string.min_bytes":      "1",
		"ves.io.schema.rules.string.truststore_url": "true",
	}
	vFnMap["trusted_ca_choice.trusted_ca_url"], err = vrhTrustedCaChoiceTrustedCaUrl(rulesTrustedCaChoiceTrustedCaUrl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field UpstreamTlsValidationContext.trusted_ca_choice_trusted_ca_url: %s", err)
		panic(errMsg)
	}

	v.FldValidators["trusted_ca_choice.trusted_ca_url"] = vFnMap["trusted_ca_choice.trusted_ca_url"]

	v.FldValidators["trusted_ca_choice.trusted_ca"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func UpstreamTlsValidationContextValidator() db.Validator {
	return DefaultUpstreamTlsValidationContextValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetHealthCheckPortChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.HealthCheckPortChoice.(type) {
	case nil:
		o.HealthCheckPortChoice = nil

	case *CreateSpecType_HealthCheckPort:
		o.HealthCheckPortChoice = &GlobalSpecType_HealthCheckPort{HealthCheckPort: of.HealthCheckPort}

	case *CreateSpecType_SameAsEndpointPort:
		o.HealthCheckPortChoice = &GlobalSpecType_SameAsEndpointPort{SameAsEndpointPort: of.SameAsEndpointPort}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetHealthCheckPortChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.HealthCheckPortChoice.(type) {
	case nil:
		r.HealthCheckPortChoice = nil

	case *GlobalSpecType_HealthCheckPort:
		r.HealthCheckPortChoice = &CreateSpecType_HealthCheckPort{HealthCheckPort: of.HealthCheckPort}

	case *GlobalSpecType_SameAsEndpointPort:
		r.HealthCheckPortChoice = &CreateSpecType_SameAsEndpointPort{SameAsEndpointPort: of.SameAsEndpointPort}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetPortChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PortChoice.(type) {
	case nil:
		o.PortChoice = nil

	case *CreateSpecType_AutomaticPort:
		o.PortChoice = &GlobalSpecType_AutomaticPort{AutomaticPort: of.AutomaticPort}

	case *CreateSpecType_LbPort:
		o.PortChoice = &GlobalSpecType_LbPort{LbPort: of.LbPort}

	case *CreateSpecType_Port:
		o.PortChoice = &GlobalSpecType_Port{Port: of.Port}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetPortChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PortChoice.(type) {
	case nil:
		r.PortChoice = nil

	case *GlobalSpecType_AutomaticPort:
		r.PortChoice = &CreateSpecType_AutomaticPort{AutomaticPort: of.AutomaticPort}

	case *GlobalSpecType_LbPort:
		r.PortChoice = &CreateSpecType_LbPort{LbPort: of.LbPort}

	case *GlobalSpecType_Port:
		r.PortChoice = &CreateSpecType_Port{Port: of.Port}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetTlsChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.TlsChoice.(type) {
	case nil:
		o.TlsChoice = nil

	case *CreateSpecType_NoTls:
		o.TlsChoice = &GlobalSpecType_NoTls{NoTls: of.NoTls}

	case *CreateSpecType_UseTls:
		o.TlsChoice = &GlobalSpecType_UseTls{UseTls: of.UseTls}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetTlsChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.TlsChoice.(type) {
	case nil:
		r.TlsChoice = nil

	case *GlobalSpecType_NoTls:
		r.TlsChoice = &CreateSpecType_NoTls{NoTls: of.NoTls}

	case *GlobalSpecType_UseTls:
		r.TlsChoice = &CreateSpecType_UseTls{UseTls: of.UseTls}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AdvancedOptions = f.GetAdvancedOptions()
	m.EndpointSelection = f.GetEndpointSelection()
	m.GetHealthCheckPortChoiceFromGlobalSpecType(f)
	m.Healthcheck = f.GetHealthcheck()
	m.LoadbalancerAlgorithm = f.GetLoadbalancerAlgorithm()
	m.OriginServers = f.GetOriginServers()
	m.GetPortChoiceFromGlobalSpecType(f)
	m.GetTlsChoiceFromGlobalSpecType(f)
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AdvancedOptions = m1.AdvancedOptions
	f.EndpointSelection = m1.EndpointSelection
	m1.SetHealthCheckPortChoiceToGlobalSpecType(f)
	f.Healthcheck = m1.Healthcheck
	f.LoadbalancerAlgorithm = m1.LoadbalancerAlgorithm
	f.OriginServers = m1.OriginServers
	m1.SetPortChoiceToGlobalSpecType(f)
	m1.SetTlsChoiceToGlobalSpecType(f)
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetHealthCheckPortChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.HealthCheckPortChoice.(type) {
	case nil:
		o.HealthCheckPortChoice = nil

	case *GetSpecType_HealthCheckPort:
		o.HealthCheckPortChoice = &GlobalSpecType_HealthCheckPort{HealthCheckPort: of.HealthCheckPort}

	case *GetSpecType_SameAsEndpointPort:
		o.HealthCheckPortChoice = &GlobalSpecType_SameAsEndpointPort{SameAsEndpointPort: of.SameAsEndpointPort}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetHealthCheckPortChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.HealthCheckPortChoice.(type) {
	case nil:
		r.HealthCheckPortChoice = nil

	case *GlobalSpecType_HealthCheckPort:
		r.HealthCheckPortChoice = &GetSpecType_HealthCheckPort{HealthCheckPort: of.HealthCheckPort}

	case *GlobalSpecType_SameAsEndpointPort:
		r.HealthCheckPortChoice = &GetSpecType_SameAsEndpointPort{SameAsEndpointPort: of.SameAsEndpointPort}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetPortChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PortChoice.(type) {
	case nil:
		o.PortChoice = nil

	case *GetSpecType_AutomaticPort:
		o.PortChoice = &GlobalSpecType_AutomaticPort{AutomaticPort: of.AutomaticPort}

	case *GetSpecType_LbPort:
		o.PortChoice = &GlobalSpecType_LbPort{LbPort: of.LbPort}

	case *GetSpecType_Port:
		o.PortChoice = &GlobalSpecType_Port{Port: of.Port}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetPortChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PortChoice.(type) {
	case nil:
		r.PortChoice = nil

	case *GlobalSpecType_AutomaticPort:
		r.PortChoice = &GetSpecType_AutomaticPort{AutomaticPort: of.AutomaticPort}

	case *GlobalSpecType_LbPort:
		r.PortChoice = &GetSpecType_LbPort{LbPort: of.LbPort}

	case *GlobalSpecType_Port:
		r.PortChoice = &GetSpecType_Port{Port: of.Port}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetTlsChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.TlsChoice.(type) {
	case nil:
		o.TlsChoice = nil

	case *GetSpecType_NoTls:
		o.TlsChoice = &GlobalSpecType_NoTls{NoTls: of.NoTls}

	case *GetSpecType_UseTls:
		o.TlsChoice = &GlobalSpecType_UseTls{UseTls: of.UseTls}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetTlsChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.TlsChoice.(type) {
	case nil:
		r.TlsChoice = nil

	case *GlobalSpecType_NoTls:
		r.TlsChoice = &GetSpecType_NoTls{NoTls: of.NoTls}

	case *GlobalSpecType_UseTls:
		r.TlsChoice = &GetSpecType_UseTls{UseTls: of.UseTls}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AdvancedOptions = f.GetAdvancedOptions()
	m.EndpointSelection = f.GetEndpointSelection()
	m.GetHealthCheckPortChoiceFromGlobalSpecType(f)
	m.Healthcheck = f.GetHealthcheck()
	m.LoadbalancerAlgorithm = f.GetLoadbalancerAlgorithm()
	m.OriginServers = f.GetOriginServers()
	m.GetPortChoiceFromGlobalSpecType(f)
	m.GetTlsChoiceFromGlobalSpecType(f)
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AdvancedOptions = m1.AdvancedOptions
	f.EndpointSelection = m1.EndpointSelection
	m1.SetHealthCheckPortChoiceToGlobalSpecType(f)
	f.Healthcheck = m1.Healthcheck
	f.LoadbalancerAlgorithm = m1.LoadbalancerAlgorithm
	f.OriginServers = m1.OriginServers
	m1.SetPortChoiceToGlobalSpecType(f)
	m1.SetTlsChoiceToGlobalSpecType(f)
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetHealthCheckPortChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.HealthCheckPortChoice.(type) {
	case nil:
		o.HealthCheckPortChoice = nil

	case *ReplaceSpecType_HealthCheckPort:
		o.HealthCheckPortChoice = &GlobalSpecType_HealthCheckPort{HealthCheckPort: of.HealthCheckPort}

	case *ReplaceSpecType_SameAsEndpointPort:
		o.HealthCheckPortChoice = &GlobalSpecType_SameAsEndpointPort{SameAsEndpointPort: of.SameAsEndpointPort}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetHealthCheckPortChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.HealthCheckPortChoice.(type) {
	case nil:
		r.HealthCheckPortChoice = nil

	case *GlobalSpecType_HealthCheckPort:
		r.HealthCheckPortChoice = &ReplaceSpecType_HealthCheckPort{HealthCheckPort: of.HealthCheckPort}

	case *GlobalSpecType_SameAsEndpointPort:
		r.HealthCheckPortChoice = &ReplaceSpecType_SameAsEndpointPort{SameAsEndpointPort: of.SameAsEndpointPort}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetPortChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.PortChoice.(type) {
	case nil:
		o.PortChoice = nil

	case *ReplaceSpecType_AutomaticPort:
		o.PortChoice = &GlobalSpecType_AutomaticPort{AutomaticPort: of.AutomaticPort}

	case *ReplaceSpecType_LbPort:
		o.PortChoice = &GlobalSpecType_LbPort{LbPort: of.LbPort}

	case *ReplaceSpecType_Port:
		o.PortChoice = &GlobalSpecType_Port{Port: of.Port}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetPortChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.PortChoice.(type) {
	case nil:
		r.PortChoice = nil

	case *GlobalSpecType_AutomaticPort:
		r.PortChoice = &ReplaceSpecType_AutomaticPort{AutomaticPort: of.AutomaticPort}

	case *GlobalSpecType_LbPort:
		r.PortChoice = &ReplaceSpecType_LbPort{LbPort: of.LbPort}

	case *GlobalSpecType_Port:
		r.PortChoice = &ReplaceSpecType_Port{Port: of.Port}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetTlsChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.TlsChoice.(type) {
	case nil:
		o.TlsChoice = nil

	case *ReplaceSpecType_NoTls:
		o.TlsChoice = &GlobalSpecType_NoTls{NoTls: of.NoTls}

	case *ReplaceSpecType_UseTls:
		o.TlsChoice = &GlobalSpecType_UseTls{UseTls: of.UseTls}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetTlsChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.TlsChoice.(type) {
	case nil:
		r.TlsChoice = nil

	case *GlobalSpecType_NoTls:
		r.TlsChoice = &ReplaceSpecType_NoTls{NoTls: of.NoTls}

	case *GlobalSpecType_UseTls:
		r.TlsChoice = &ReplaceSpecType_UseTls{UseTls: of.UseTls}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.AdvancedOptions = f.GetAdvancedOptions()
	m.EndpointSelection = f.GetEndpointSelection()
	m.GetHealthCheckPortChoiceFromGlobalSpecType(f)
	m.Healthcheck = f.GetHealthcheck()
	m.LoadbalancerAlgorithm = f.GetLoadbalancerAlgorithm()
	m.OriginServers = f.GetOriginServers()
	m.GetPortChoiceFromGlobalSpecType(f)
	m.GetTlsChoiceFromGlobalSpecType(f)
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.AdvancedOptions = m1.AdvancedOptions
	f.EndpointSelection = m1.EndpointSelection
	m1.SetHealthCheckPortChoiceToGlobalSpecType(f)
	f.Healthcheck = m1.Healthcheck
	f.LoadbalancerAlgorithm = m1.LoadbalancerAlgorithm
	f.OriginServers = m1.OriginServers
	m1.SetPortChoiceToGlobalSpecType(f)
	m1.SetTlsChoiceToGlobalSpecType(f)
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
