// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package common_waf

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_app_type "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_type"
	ves_io_schema_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	ves_io_schema_rate_limiter "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/rate_limiter"
	ves_io_schema_service_policy_rule "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/service_policy_rule"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ves_io_schema_views_rate_limiter_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/rate_limiter_policy"
	ves_io_schema_virtual_host "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/virtual_host"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *APIEndpointProtectionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *APIEndpointProtectionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *APIEndpointProtectionRule) DeepCopy() *APIEndpointProtectionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &APIEndpointProtectionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *APIEndpointProtectionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *APIEndpointProtectionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return APIEndpointProtectionRuleValidator().Validate(ctx, m, opts...)
}

func (m *APIEndpointProtectionRule) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetClientMatcherDRefInfo()

}

// GetDRefInfo for the field's type
func (m *APIEndpointProtectionRule) GetClientMatcherDRefInfo() ([]db.DRefInfo, error) {
	if m.GetClientMatcher() == nil {
		return nil, nil
	}

	drInfos, err := m.GetClientMatcher().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetClientMatcher().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "client_matcher." + dri.DRField
	}
	return drInfos, err

}

type ValidateAPIEndpointProtectionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAPIEndpointProtectionRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAPIEndpointProtectionRule) DomainChoiceSpecificDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SpecificDomain, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for specific_domain")
	}
	return oValidatorFn_SpecificDomain, nil
}

func (v *ValidateAPIEndpointProtectionRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIEndpointProtectionRule) ActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for action")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := APIProtectionRuleActionValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIEndpointProtectionRule) ApiEndpointPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_endpoint_path")
	}

	return validatorFn, nil
}

func (v *ValidateAPIEndpointProtectionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*APIEndpointProtectionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *APIEndpointProtectionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action"]; exists {

		vOpts := append(opts, db.WithValidateField("action"))
		if err := fv(ctx, m.GetAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["api_endpoint_method"]; exists {

		vOpts := append(opts, db.WithValidateField("api_endpoint_method"))
		if err := fv(ctx, m.GetApiEndpointMethod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["api_endpoint_path"]; exists {

		vOpts := append(opts, db.WithValidateField("api_endpoint_path"))
		if err := fv(ctx, m.GetApiEndpointPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("client_matcher"))
		if err := fv(ctx, m.GetClientMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *APIEndpointProtectionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*APIEndpointProtectionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APIEndpointProtectionRule_SpecificDomain:
		if fv, exists := v.FldValidators["domain_choice.specific_domain"]; exists {
			val := m.GetDomainChoice().(*APIEndpointProtectionRule_SpecificDomain).SpecificDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("specific_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("request_matcher"))
		if err := fv(ctx, m.GetRequestMatcher(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAPIEndpointProtectionRuleValidator = func() *ValidateAPIEndpointProtectionRule {
	v := &ValidateAPIEndpointProtectionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIEndpointProtectionRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceSpecificDomain := v.DomainChoiceSpecificDomainValidationRuleHandler
	rulesDomainChoiceSpecificDomain := map[string]string{
		"ves.io.schema.rules.string.max_len":   "128",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFnMap["domain_choice.specific_domain"], err = vrhDomainChoiceSpecificDomain(rulesDomainChoiceSpecificDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field APIEndpointProtectionRule.domain_choice_specific_domain: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.specific_domain"] = vFnMap["domain_choice.specific_domain"]

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIEndpointProtectionRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhAction := v.ActionValidationRuleHandler
	rulesAction := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAction(rulesAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIEndpointProtectionRule.action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action"] = vFn

	vrhApiEndpointPath := v.ApiEndpointPathValidationRuleHandler
	rulesApiEndpointPath := map[string]string{
		"ves.io.schema.rules.message.required":           "true",
		"ves.io.schema.rules.string.max_len":             "1024",
		"ves.io.schema.rules.string.templated_http_path": "true",
	}
	vFn, err = vrhApiEndpointPath(rulesApiEndpointPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIEndpointProtectionRule.api_endpoint_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_endpoint_path"] = vFn

	v.FldValidators["api_endpoint_method"] = ves_io_schema_policy.HttpMethodMatcherTypeValidator().Validate

	v.FldValidators["request_matcher"] = ves_io_schema_policy.RequestMatcherValidator().Validate

	v.FldValidators["client_matcher"] = ves_io_schema_policy.ClientMatcherValidator().Validate

	return v
}()

func APIEndpointProtectionRuleValidator() db.Validator {
	return DefaultAPIEndpointProtectionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *APIGroupProtectionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *APIGroupProtectionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *APIGroupProtectionRule) DeepCopy() *APIGroupProtectionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &APIGroupProtectionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *APIGroupProtectionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *APIGroupProtectionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return APIGroupProtectionRuleValidator().Validate(ctx, m, opts...)
}

func (m *APIGroupProtectionRule) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetClientMatcherDRefInfo()

}

// GetDRefInfo for the field's type
func (m *APIGroupProtectionRule) GetClientMatcherDRefInfo() ([]db.DRefInfo, error) {
	if m.GetClientMatcher() == nil {
		return nil, nil
	}

	drInfos, err := m.GetClientMatcher().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetClientMatcher().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "client_matcher." + dri.DRField
	}
	return drInfos, err

}

type ValidateAPIGroupProtectionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAPIGroupProtectionRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAPIGroupProtectionRule) DomainChoiceSpecificDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SpecificDomain, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for specific_domain")
	}
	return oValidatorFn_SpecificDomain, nil
}

func (v *ValidateAPIGroupProtectionRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIGroupProtectionRule) ActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for action")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := APIProtectionRuleActionValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIGroupProtectionRule) ApiGroupValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_group")
	}

	return validatorFn, nil
}

func (v *ValidateAPIGroupProtectionRule) BasePathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for base_path")
	}

	return validatorFn, nil
}

func (v *ValidateAPIGroupProtectionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*APIGroupProtectionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *APIGroupProtectionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action"]; exists {

		vOpts := append(opts, db.WithValidateField("action"))
		if err := fv(ctx, m.GetAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["api_group"]; exists {

		vOpts := append(opts, db.WithValidateField("api_group"))
		if err := fv(ctx, m.GetApiGroup(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["base_path"]; exists {

		vOpts := append(opts, db.WithValidateField("base_path"))
		if err := fv(ctx, m.GetBasePath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("client_matcher"))
		if err := fv(ctx, m.GetClientMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *APIGroupProtectionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*APIGroupProtectionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APIGroupProtectionRule_SpecificDomain:
		if fv, exists := v.FldValidators["domain_choice.specific_domain"]; exists {
			val := m.GetDomainChoice().(*APIGroupProtectionRule_SpecificDomain).SpecificDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("specific_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("request_matcher"))
		if err := fv(ctx, m.GetRequestMatcher(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAPIGroupProtectionRuleValidator = func() *ValidateAPIGroupProtectionRule {
	v := &ValidateAPIGroupProtectionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIGroupProtectionRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceSpecificDomain := v.DomainChoiceSpecificDomainValidationRuleHandler
	rulesDomainChoiceSpecificDomain := map[string]string{
		"ves.io.schema.rules.string.max_len":   "128",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFnMap["domain_choice.specific_domain"], err = vrhDomainChoiceSpecificDomain(rulesDomainChoiceSpecificDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field APIGroupProtectionRule.domain_choice_specific_domain: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.specific_domain"] = vFnMap["domain_choice.specific_domain"]

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIGroupProtectionRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhAction := v.ActionValidationRuleHandler
	rulesAction := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAction(rulesAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIGroupProtectionRule.action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action"] = vFn

	vrhApiGroup := v.ApiGroupValidationRuleHandler
	rulesApiGroup := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhApiGroup(rulesApiGroup)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIGroupProtectionRule.api_group: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_group"] = vFn

	vrhBasePath := v.BasePathValidationRuleHandler
	rulesBasePath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFn, err = vrhBasePath(rulesBasePath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIGroupProtectionRule.base_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["base_path"] = vFn

	v.FldValidators["request_matcher"] = ves_io_schema_policy.RequestMatcherValidator().Validate

	v.FldValidators["client_matcher"] = ves_io_schema_policy.ClientMatcherValidator().Validate

	return v
}()

func APIGroupProtectionRuleValidator() db.Validator {
	return DefaultAPIGroupProtectionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *APIGroups) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *APIGroups) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *APIGroups) DeepCopy() *APIGroups {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &APIGroups{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *APIGroups) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *APIGroups) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return APIGroupsValidator().Validate(ctx, m, opts...)
}

type ValidateAPIGroups struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAPIGroups) ApiGroupsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for api_groups")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for api_groups")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated api_groups")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items api_groups")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIGroups) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*APIGroups)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *APIGroups got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_groups"]; exists {
		vOpts := append(opts, db.WithValidateField("api_groups"))
		if err := fv(ctx, m.GetApiGroups(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAPIGroupsValidator = func() *ValidateAPIGroups {
	v := &ValidateAPIGroups{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiGroups := v.ApiGroupsValidationRuleHandler
	rulesApiGroups := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "32",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhApiGroups(rulesApiGroups)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIGroups.api_groups: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_groups"] = vFn

	return v
}()

func APIGroupsValidator() db.Validator {
	return DefaultAPIGroupsValidator
}

// augmented methods on protoc/std generated struct

func (m *APIProtectionRuleAction) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *APIProtectionRuleAction) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *APIProtectionRuleAction) DeepCopy() *APIProtectionRuleAction {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &APIProtectionRuleAction{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *APIProtectionRuleAction) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *APIProtectionRuleAction) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return APIProtectionRuleActionValidator().Validate(ctx, m, opts...)
}

type ValidateAPIProtectionRuleAction struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAPIProtectionRuleAction) ActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action")
	}
	return validatorFn, nil
}

func (v *ValidateAPIProtectionRuleAction) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*APIProtectionRuleAction)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *APIProtectionRuleAction got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action"]; exists {
		val := m.GetAction()
		vOpts := append(opts,
			db.WithValidateField("action"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAction().(type) {
	case *APIProtectionRuleAction_Allow:
		if fv, exists := v.FldValidators["action.allow"]; exists {
			val := m.GetAction().(*APIProtectionRuleAction_Allow).Allow
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APIProtectionRuleAction_Deny:
		if fv, exists := v.FldValidators["action.deny"]; exists {
			val := m.GetAction().(*APIProtectionRuleAction_Deny).Deny
			vOpts := append(opts,
				db.WithValidateField("action"),
				db.WithValidateField("deny"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAPIProtectionRuleActionValidator = func() *ValidateAPIProtectionRuleAction {
	v := &ValidateAPIProtectionRuleAction{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAction := v.ActionValidationRuleHandler
	rulesAction := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAction(rulesAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIProtectionRuleAction.action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action"] = vFn

	return v
}()

func APIProtectionRuleActionValidator() db.Validator {
	return DefaultAPIProtectionRuleActionValidator
}

// augmented methods on protoc/std generated struct

func (m *APIProtectionRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *APIProtectionRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *APIProtectionRules) DeepCopy() *APIProtectionRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &APIProtectionRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *APIProtectionRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *APIProtectionRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return APIProtectionRulesValidator().Validate(ctx, m, opts...)
}

func (m *APIProtectionRules) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetApiEndpointRulesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiEndpointRulesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiGroupsRulesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiGroupsRulesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *APIProtectionRules) GetApiEndpointRulesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiEndpointRules() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetApiEndpointRules() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetApiEndpointRules() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("api_endpoint_rules[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *APIProtectionRules) GetApiGroupsRulesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiGroupsRules() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetApiGroupsRules() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetApiGroupsRules() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("api_groups_rules[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateAPIProtectionRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAPIProtectionRules) ApiEndpointRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for api_endpoint_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*APIEndpointProtectionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := APIEndpointProtectionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for api_endpoint_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*APIEndpointProtectionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*APIEndpointProtectionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated api_endpoint_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items api_endpoint_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIProtectionRules) ApiGroupsRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for api_groups_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*APIGroupProtectionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := APIGroupProtectionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for api_groups_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*APIGroupProtectionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*APIGroupProtectionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated api_groups_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items api_groups_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIProtectionRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*APIProtectionRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *APIProtectionRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_endpoint_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("api_endpoint_rules"))
		if err := fv(ctx, m.GetApiEndpointRules(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["api_groups_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("api_groups_rules"))
		if err := fv(ctx, m.GetApiGroupsRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAPIProtectionRulesValidator = func() *ValidateAPIProtectionRules {
	v := &ValidateAPIProtectionRules{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiEndpointRules := v.ApiEndpointRulesValidationRuleHandler
	rulesApiEndpointRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "20",
	}
	vFn, err = vrhApiEndpointRules(rulesApiEndpointRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIProtectionRules.api_endpoint_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_endpoint_rules"] = vFn

	vrhApiGroupsRules := v.ApiGroupsRulesValidationRuleHandler
	rulesApiGroupsRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "20",
	}
	vFn, err = vrhApiGroupsRules(rulesApiGroupsRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIProtectionRules.api_groups_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_groups_rules"] = vFn

	return v
}()

func APIProtectionRulesValidator() db.Validator {
	return DefaultAPIProtectionRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *APIRateLimit) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *APIRateLimit) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *APIRateLimit) DeepCopy() *APIRateLimit {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &APIRateLimit{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *APIRateLimit) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *APIRateLimit) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return APIRateLimitValidator().Validate(ctx, m, opts...)
}

func (m *APIRateLimit) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetApiEndpointRulesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiEndpointRulesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetIpAllowedListChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpAllowedListChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServerUrlRulesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServerUrlRulesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *APIRateLimit) GetApiEndpointRulesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiEndpointRules() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetApiEndpointRules() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetApiEndpointRules() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("api_endpoint_rules[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *APIRateLimit) GetIpAllowedListChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpAllowedListChoice() == nil {
		return nil, nil
	}
	switch m.GetIpAllowedListChoice().(type) {
	case *APIRateLimit_NoIpAllowedList:

		return nil, nil

	case *APIRateLimit_IpAllowedList:

		return nil, nil

	case *APIRateLimit_CustomIpAllowedList:

		drInfos, err := m.GetCustomIpAllowedList().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCustomIpAllowedList().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "custom_ip_allowed_list." + dri.DRField
		}
		return drInfos, err

	case *APIRateLimit_BypassRateLimitingRules:

		drInfos, err := m.GetBypassRateLimitingRules().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetBypassRateLimitingRules().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "bypass_rate_limiting_rules." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *APIRateLimit) GetServerUrlRulesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetServerUrlRules() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetServerUrlRules() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetServerUrlRules() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("server_url_rules[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateAPIRateLimit struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAPIRateLimit) IpAllowedListChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_allowed_list_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAPIRateLimit) ServerUrlRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for server_url_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ServerUrlRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ServerUrlRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for server_url_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ServerUrlRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ServerUrlRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated server_url_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items server_url_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIRateLimit) ApiEndpointRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for api_endpoint_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ApiEndpointRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ApiEndpointRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for api_endpoint_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ApiEndpointRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ApiEndpointRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated api_endpoint_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items api_endpoint_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIRateLimit) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*APIRateLimit)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *APIRateLimit got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_endpoint_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("api_endpoint_rules"))
		if err := fv(ctx, m.GetApiEndpointRules(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_allowed_list_choice"]; exists {
		val := m.GetIpAllowedListChoice()
		vOpts := append(opts,
			db.WithValidateField("ip_allowed_list_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetIpAllowedListChoice().(type) {
	case *APIRateLimit_NoIpAllowedList:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.no_ip_allowed_list"]; exists {
			val := m.GetIpAllowedListChoice().(*APIRateLimit_NoIpAllowedList).NoIpAllowedList
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("no_ip_allowed_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APIRateLimit_IpAllowedList:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.ip_allowed_list"]; exists {
			val := m.GetIpAllowedListChoice().(*APIRateLimit_IpAllowedList).IpAllowedList
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("ip_allowed_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APIRateLimit_CustomIpAllowedList:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.custom_ip_allowed_list"]; exists {
			val := m.GetIpAllowedListChoice().(*APIRateLimit_CustomIpAllowedList).CustomIpAllowedList
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("custom_ip_allowed_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APIRateLimit_BypassRateLimitingRules:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.bypass_rate_limiting_rules"]; exists {
			val := m.GetIpAllowedListChoice().(*APIRateLimit_BypassRateLimitingRules).BypassRateLimitingRules
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("bypass_rate_limiting_rules"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["server_url_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("server_url_rules"))
		if err := fv(ctx, m.GetServerUrlRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAPIRateLimitValidator = func() *ValidateAPIRateLimit {
	v := &ValidateAPIRateLimit{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpAllowedListChoice := v.IpAllowedListChoiceValidationRuleHandler
	rulesIpAllowedListChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhIpAllowedListChoice(rulesIpAllowedListChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIRateLimit.ip_allowed_list_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_allowed_list_choice"] = vFn

	vrhServerUrlRules := v.ServerUrlRulesValidationRuleHandler
	rulesServerUrlRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "20",
	}
	vFn, err = vrhServerUrlRules(rulesServerUrlRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIRateLimit.server_url_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_url_rules"] = vFn

	vrhApiEndpointRules := v.ApiEndpointRulesValidationRuleHandler
	rulesApiEndpointRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "20",
	}
	vFn, err = vrhApiEndpointRules(rulesApiEndpointRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIRateLimit.api_endpoint_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_endpoint_rules"] = vFn

	v.FldValidators["ip_allowed_list_choice.ip_allowed_list"] = ves_io_schema_views.PrefixStringListTypeValidator().Validate
	v.FldValidators["ip_allowed_list_choice.custom_ip_allowed_list"] = CustomIpAllowedListValidator().Validate
	v.FldValidators["ip_allowed_list_choice.bypass_rate_limiting_rules"] = BypassRateLimitingRulesValidator().Validate

	return v
}()

func APIRateLimitValidator() db.Validator {
	return DefaultAPIRateLimitValidator
}

// augmented methods on protoc/std generated struct

func (m *APIRateLimitLegacy) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *APIRateLimitLegacy) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *APIRateLimitLegacy) DeepCopy() *APIRateLimitLegacy {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &APIRateLimitLegacy{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *APIRateLimitLegacy) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *APIRateLimitLegacy) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return APIRateLimitLegacyValidator().Validate(ctx, m, opts...)
}

func (m *APIRateLimitLegacy) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetApiEndpointRulesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiEndpointRulesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetIpAllowedListChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpAllowedListChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetServerUrlRulesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetServerUrlRulesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *APIRateLimitLegacy) GetApiEndpointRulesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiEndpointRules() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetApiEndpointRules() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetApiEndpointRules() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("api_endpoint_rules[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *APIRateLimitLegacy) GetIpAllowedListChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpAllowedListChoice() == nil {
		return nil, nil
	}
	switch m.GetIpAllowedListChoice().(type) {
	case *APIRateLimitLegacy_NoIpAllowedList:

		return nil, nil

	case *APIRateLimitLegacy_IpAllowedList:

		return nil, nil

	case *APIRateLimitLegacy_CustomIpAllowedList:

		drInfos, err := m.GetCustomIpAllowedList().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCustomIpAllowedList().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "custom_ip_allowed_list." + dri.DRField
		}
		return drInfos, err

	case *APIRateLimitLegacy_BypassRateLimitingRules:

		drInfos, err := m.GetBypassRateLimitingRules().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetBypassRateLimitingRules().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "bypass_rate_limiting_rules." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *APIRateLimitLegacy) GetServerUrlRulesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetServerUrlRules() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetServerUrlRules() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetServerUrlRules() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("server_url_rules[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateAPIRateLimitLegacy struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAPIRateLimitLegacy) IpAllowedListChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_allowed_list_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAPIRateLimitLegacy) ServerUrlRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for server_url_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ServerUrlRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ServerUrlRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for server_url_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ServerUrlRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ServerUrlRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated server_url_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items server_url_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIRateLimitLegacy) ApiEndpointRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for api_endpoint_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ApiEndpointRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ApiEndpointRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for api_endpoint_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ApiEndpointRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ApiEndpointRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated api_endpoint_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items api_endpoint_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPIRateLimitLegacy) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*APIRateLimitLegacy)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *APIRateLimitLegacy got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_endpoint_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("api_endpoint_rules"))
		if err := fv(ctx, m.GetApiEndpointRules(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_allowed_list_choice"]; exists {
		val := m.GetIpAllowedListChoice()
		vOpts := append(opts,
			db.WithValidateField("ip_allowed_list_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetIpAllowedListChoice().(type) {
	case *APIRateLimitLegacy_NoIpAllowedList:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.no_ip_allowed_list"]; exists {
			val := m.GetIpAllowedListChoice().(*APIRateLimitLegacy_NoIpAllowedList).NoIpAllowedList
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("no_ip_allowed_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APIRateLimitLegacy_IpAllowedList:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.ip_allowed_list"]; exists {
			val := m.GetIpAllowedListChoice().(*APIRateLimitLegacy_IpAllowedList).IpAllowedList
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("ip_allowed_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APIRateLimitLegacy_CustomIpAllowedList:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.custom_ip_allowed_list"]; exists {
			val := m.GetIpAllowedListChoice().(*APIRateLimitLegacy_CustomIpAllowedList).CustomIpAllowedList
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("custom_ip_allowed_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APIRateLimitLegacy_BypassRateLimitingRules:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.bypass_rate_limiting_rules"]; exists {
			val := m.GetIpAllowedListChoice().(*APIRateLimitLegacy_BypassRateLimitingRules).BypassRateLimitingRules
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("bypass_rate_limiting_rules"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["server_url_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("server_url_rules"))
		if err := fv(ctx, m.GetServerUrlRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAPIRateLimitLegacyValidator = func() *ValidateAPIRateLimitLegacy {
	v := &ValidateAPIRateLimitLegacy{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpAllowedListChoice := v.IpAllowedListChoiceValidationRuleHandler
	rulesIpAllowedListChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhIpAllowedListChoice(rulesIpAllowedListChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIRateLimitLegacy.ip_allowed_list_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_allowed_list_choice"] = vFn

	vrhServerUrlRules := v.ServerUrlRulesValidationRuleHandler
	rulesServerUrlRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "20",
	}
	vFn, err = vrhServerUrlRules(rulesServerUrlRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIRateLimitLegacy.server_url_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["server_url_rules"] = vFn

	vrhApiEndpointRules := v.ApiEndpointRulesValidationRuleHandler
	rulesApiEndpointRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "20",
	}
	vFn, err = vrhApiEndpointRules(rulesApiEndpointRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APIRateLimitLegacy.api_endpoint_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_endpoint_rules"] = vFn

	v.FldValidators["ip_allowed_list_choice.ip_allowed_list"] = ves_io_schema_views.PrefixStringListTypeValidator().Validate
	v.FldValidators["ip_allowed_list_choice.custom_ip_allowed_list"] = CustomIpAllowedListValidator().Validate
	v.FldValidators["ip_allowed_list_choice.bypass_rate_limiting_rules"] = BypassRateLimitingRulesValidator().Validate

	return v
}()

func APIRateLimitLegacyValidator() db.Validator {
	return DefaultAPIRateLimitLegacyValidator
}

// augmented methods on protoc/std generated struct

func (m *APISpecificationSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *APISpecificationSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *APISpecificationSettings) DeepCopy() *APISpecificationSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &APISpecificationSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *APISpecificationSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *APISpecificationSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return APISpecificationSettingsValidator().Validate(ctx, m, opts...)
}

func (m *APISpecificationSettings) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetApiDefinitionDRefInfo()

}

func (m *APISpecificationSettings) GetApiDefinitionDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetApiDefinition()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("api_definition.Object")
	dri := db.DRefInfo{
		RefdType:   "api_definition.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "api_definition",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetApiDefinitionDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *APISpecificationSettings) GetApiDefinitionDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "api_definition.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: api_definition")
	}

	vref := m.GetApiDefinition()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "api_definition.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateAPISpecificationSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAPISpecificationSettings) ValidationTargetChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for validation_target_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAPISpecificationSettings) ApiDefinitionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for api_definition")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAPISpecificationSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*APISpecificationSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *APISpecificationSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_definition"]; exists {

		vOpts := append(opts, db.WithValidateField("api_definition"))
		if err := fv(ctx, m.GetApiDefinition(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validation_target_choice"]; exists {
		val := m.GetValidationTargetChoice()
		vOpts := append(opts,
			db.WithValidateField("validation_target_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetValidationTargetChoice().(type) {
	case *APISpecificationSettings_ValidationDisabled:
		if fv, exists := v.FldValidators["validation_target_choice.validation_disabled"]; exists {
			val := m.GetValidationTargetChoice().(*APISpecificationSettings_ValidationDisabled).ValidationDisabled
			vOpts := append(opts,
				db.WithValidateField("validation_target_choice"),
				db.WithValidateField("validation_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APISpecificationSettings_ValidationAllSpecEndpoints:
		if fv, exists := v.FldValidators["validation_target_choice.validation_all_spec_endpoints"]; exists {
			val := m.GetValidationTargetChoice().(*APISpecificationSettings_ValidationAllSpecEndpoints).ValidationAllSpecEndpoints
			vOpts := append(opts,
				db.WithValidateField("validation_target_choice"),
				db.WithValidateField("validation_all_spec_endpoints"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *APISpecificationSettings_ValidationCustomList:
		if fv, exists := v.FldValidators["validation_target_choice.validation_custom_list"]; exists {
			val := m.GetValidationTargetChoice().(*APISpecificationSettings_ValidationCustomList).ValidationCustomList
			vOpts := append(opts,
				db.WithValidateField("validation_target_choice"),
				db.WithValidateField("validation_custom_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAPISpecificationSettingsValidator = func() *ValidateAPISpecificationSettings {
	v := &ValidateAPISpecificationSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValidationTargetChoice := v.ValidationTargetChoiceValidationRuleHandler
	rulesValidationTargetChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhValidationTargetChoice(rulesValidationTargetChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APISpecificationSettings.validation_target_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["validation_target_choice"] = vFn

	vrhApiDefinition := v.ApiDefinitionValidationRuleHandler
	rulesApiDefinition := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhApiDefinition(rulesApiDefinition)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for APISpecificationSettings.api_definition: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_definition"] = vFn

	v.FldValidators["validation_target_choice.validation_all_spec_endpoints"] = OpenApiValidationAllSpecEndpointsSettingsValidator().Validate
	v.FldValidators["validation_target_choice.validation_custom_list"] = ValidateApiBySpecRuleValidator().Validate

	return v
}()

func APISpecificationSettingsValidator() db.Validator {
	return DefaultAPISpecificationSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiCodeRepos) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiCodeRepos) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiCodeRepos) DeepCopy() *ApiCodeRepos {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiCodeRepos{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiCodeRepos) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiCodeRepos) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiCodeReposValidator().Validate(ctx, m, opts...)
}

type ValidateApiCodeRepos struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiCodeRepos) ApiCodeRepoValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for api_code_repo")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for api_code_repo")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated api_code_repo")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items api_code_repo")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateApiCodeRepos) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiCodeRepos)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiCodeRepos got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_code_repo"]; exists {
		vOpts := append(opts, db.WithValidateField("api_code_repo"))
		if err := fv(ctx, m.GetApiCodeRepo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiCodeReposValidator = func() *ValidateApiCodeRepos {
	v := &ValidateApiCodeRepos{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiCodeRepo := v.ApiCodeRepoValidationRuleHandler
	rulesApiCodeRepo := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhApiCodeRepo(rulesApiCodeRepo)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiCodeRepos.api_code_repo: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_code_repo"] = vFn

	return v
}()

func ApiCodeReposValidator() db.Validator {
	return DefaultApiCodeReposValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiCrawler) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiCrawler) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ApiCrawler) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetApiCrawlerConfig().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ApiCrawler.api_crawler_config")
	}

	return nil
}

func (m *ApiCrawler) DeepCopy() *ApiCrawler {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiCrawler{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiCrawler) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiCrawler) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiCrawlerValidator().Validate(ctx, m, opts...)
}

type ValidateApiCrawler struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiCrawler) ApiCrawlerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_crawler")
	}
	return validatorFn, nil
}

func (v *ValidateApiCrawler) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiCrawler)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiCrawler got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_crawler"]; exists {
		val := m.GetApiCrawler()
		vOpts := append(opts,
			db.WithValidateField("api_crawler"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetApiCrawler().(type) {
	case *ApiCrawler_DisableApiCrawler:
		if fv, exists := v.FldValidators["api_crawler.disable_api_crawler"]; exists {
			val := m.GetApiCrawler().(*ApiCrawler_DisableApiCrawler).DisableApiCrawler
			vOpts := append(opts,
				db.WithValidateField("api_crawler"),
				db.WithValidateField("disable_api_crawler"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ApiCrawler_ApiCrawlerConfig:
		if fv, exists := v.FldValidators["api_crawler.api_crawler_config"]; exists {
			val := m.GetApiCrawler().(*ApiCrawler_ApiCrawlerConfig).ApiCrawlerConfig
			vOpts := append(opts,
				db.WithValidateField("api_crawler"),
				db.WithValidateField("api_crawler_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiCrawlerValidator = func() *ValidateApiCrawler {
	v := &ValidateApiCrawler{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiCrawler := v.ApiCrawlerValidationRuleHandler
	rulesApiCrawler := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhApiCrawler(rulesApiCrawler)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiCrawler.api_crawler: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_crawler"] = vFn

	v.FldValidators["api_crawler.api_crawler_config"] = ApiCrawlerConfigurationValidator().Validate

	return v
}()

func ApiCrawlerValidator() db.Validator {
	return DefaultApiCrawlerValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiCrawlerConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiCrawlerConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ApiCrawlerConfiguration) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetDomains() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting ApiCrawlerConfiguration.domains idx %v", idx)
		}
	}

	return nil
}

func (m *ApiCrawlerConfiguration) DeepCopy() *ApiCrawlerConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiCrawlerConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiCrawlerConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiCrawlerConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiCrawlerConfigurationValidator().Validate(ctx, m, opts...)
}

type ValidateApiCrawlerConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiCrawlerConfiguration) DomainsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for domains")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*DomainConfiguration, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := DomainConfigurationValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for domains")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DomainConfiguration)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DomainConfiguration, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated domains")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items domains")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateApiCrawlerConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiCrawlerConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiCrawlerConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domains"]; exists {
		vOpts := append(opts, db.WithValidateField("domains"))
		if err := fv(ctx, m.GetDomains(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiCrawlerConfigurationValidator = func() *ValidateApiCrawlerConfiguration {
	v := &ValidateApiCrawlerConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomains := v.DomainsValidationRuleHandler
	rulesDomains := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
	}
	vFn, err = vrhDomains(rulesDomains)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiCrawlerConfiguration.domains: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domains"] = vFn

	return v
}()

func ApiCrawlerConfigurationValidator() db.Validator {
	return DefaultApiCrawlerConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiDefinitionList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiDefinitionList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiDefinitionList) DeepCopy() *ApiDefinitionList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiDefinitionList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiDefinitionList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiDefinitionList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiDefinitionListValidator().Validate(ctx, m, opts...)
}

func (m *ApiDefinitionList) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetApiDefinitionsDRefInfo()

}

func (m *ApiDefinitionList) GetApiDefinitionsDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetApiDefinitions()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("ApiDefinitionList.api_definitions[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("api_definition.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "api_definition.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "api_definitions",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetApiDefinitionsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ApiDefinitionList) GetApiDefinitionsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "api_definition.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: api_definition")
	}
	for i, vref := range m.GetApiDefinitions() {
		if vref == nil {
			return nil, fmt.Errorf("ApiDefinitionList.api_definitions[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "api_definition.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateApiDefinitionList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiDefinitionList) ApiDefinitionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for api_definitions")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for api_definitions")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated api_definitions")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items api_definitions")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateApiDefinitionList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiDefinitionList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiDefinitionList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_definitions"]; exists {
		vOpts := append(opts, db.WithValidateField("api_definitions"))
		if err := fv(ctx, m.GetApiDefinitions(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiDefinitionListValidator = func() *ValidateApiDefinitionList {
	v := &ValidateApiDefinitionList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiDefinitions := v.ApiDefinitionsValidationRuleHandler
	rulesApiDefinitions := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhApiDefinitions(rulesApiDefinitions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiDefinitionList.api_definitions: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_definitions"] = vFn

	return v
}()

func ApiDefinitionListValidator() db.Validator {
	return DefaultApiDefinitionListValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiDiscoveryAdvancedSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiDiscoveryAdvancedSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiDiscoveryAdvancedSettings) DeepCopy() *ApiDiscoveryAdvancedSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiDiscoveryAdvancedSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiDiscoveryAdvancedSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiDiscoveryAdvancedSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiDiscoveryAdvancedSettingsValidator().Validate(ctx, m, opts...)
}

func (m *ApiDiscoveryAdvancedSettings) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetApiDiscoveryRefDRefInfo()

}

func (m *ApiDiscoveryAdvancedSettings) GetApiDiscoveryRefDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetApiDiscoveryRef()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("api_discovery.Object")
	dri := db.DRefInfo{
		RefdType:   "api_discovery.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "api_discovery_ref",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetApiDiscoveryRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ApiDiscoveryAdvancedSettings) GetApiDiscoveryRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "api_discovery.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: api_discovery")
	}

	vref := m.GetApiDiscoveryRef()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "api_discovery.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateApiDiscoveryAdvancedSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiDiscoveryAdvancedSettings) ApiDiscoveryRefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for api_discovery_ref")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateApiDiscoveryAdvancedSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiDiscoveryAdvancedSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiDiscoveryAdvancedSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_discovery_ref"]; exists {

		vOpts := append(opts, db.WithValidateField("api_discovery_ref"))
		if err := fv(ctx, m.GetApiDiscoveryRef(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiDiscoveryAdvancedSettingsValidator = func() *ValidateApiDiscoveryAdvancedSettings {
	v := &ValidateApiDiscoveryAdvancedSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiDiscoveryRef := v.ApiDiscoveryRefValidationRuleHandler
	rulesApiDiscoveryRef := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhApiDiscoveryRef(rulesApiDiscoveryRef)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiDiscoveryAdvancedSettings.api_discovery_ref: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_discovery_ref"] = vFn

	return v
}()

func ApiDiscoveryAdvancedSettingsValidator() db.Validator {
	return DefaultApiDiscoveryAdvancedSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiDiscoveryFromCodeScan) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiDiscoveryFromCodeScan) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiDiscoveryFromCodeScan) DeepCopy() *ApiDiscoveryFromCodeScan {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiDiscoveryFromCodeScan{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiDiscoveryFromCodeScan) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiDiscoveryFromCodeScan) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiDiscoveryFromCodeScanValidator().Validate(ctx, m, opts...)
}

func (m *ApiDiscoveryFromCodeScan) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCodeBaseIntegrationsDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ApiDiscoveryFromCodeScan) GetCodeBaseIntegrationsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetCodeBaseIntegrations() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetCodeBaseIntegrations() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCodeBaseIntegrations() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("code_base_integrations[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateApiDiscoveryFromCodeScan struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiDiscoveryFromCodeScan) CodeBaseIntegrationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for code_base_integrations")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CodeBaseIntegrationSelection, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CodeBaseIntegrationSelectionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for code_base_integrations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CodeBaseIntegrationSelection)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CodeBaseIntegrationSelection, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated code_base_integrations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items code_base_integrations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateApiDiscoveryFromCodeScan) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiDiscoveryFromCodeScan)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiDiscoveryFromCodeScan got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["code_base_integrations"]; exists {
		vOpts := append(opts, db.WithValidateField("code_base_integrations"))
		if err := fv(ctx, m.GetCodeBaseIntegrations(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiDiscoveryFromCodeScanValidator = func() *ValidateApiDiscoveryFromCodeScan {
	v := &ValidateApiDiscoveryFromCodeScan{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCodeBaseIntegrations := v.CodeBaseIntegrationsValidationRuleHandler
	rulesCodeBaseIntegrations := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "5",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCodeBaseIntegrations(rulesCodeBaseIntegrations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiDiscoveryFromCodeScan.code_base_integrations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["code_base_integrations"] = vFn

	return v
}()

func ApiDiscoveryFromCodeScanValidator() db.Validator {
	return DefaultApiDiscoveryFromCodeScanValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiDiscoverySetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiDiscoverySetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ApiDiscoverySetting) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetApiCrawler().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ApiDiscoverySetting.api_crawler")
	}

	return nil
}

func (m *ApiDiscoverySetting) DeepCopy() *ApiDiscoverySetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiDiscoverySetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiDiscoverySetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiDiscoverySetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiDiscoverySettingValidator().Validate(ctx, m, opts...)
}

func (m *ApiDiscoverySetting) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetApiDiscoveryFromCodeScanDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiDiscoveryFromCodeScanDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetApiDiscoverySettingsChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetApiDiscoverySettingsChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ApiDiscoverySetting) GetApiDiscoveryFromCodeScanDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiDiscoveryFromCodeScan() == nil {
		return nil, nil
	}

	drInfos, err := m.GetApiDiscoveryFromCodeScan().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetApiDiscoveryFromCodeScan().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "api_discovery_from_code_scan." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ApiDiscoverySetting) GetApiDiscoverySettingsChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetApiDiscoverySettingsChoice() == nil {
		return nil, nil
	}
	switch m.GetApiDiscoverySettingsChoice().(type) {
	case *ApiDiscoverySetting_DefaultApiAuthDiscovery:

		return nil, nil

	case *ApiDiscoverySetting_CustomApiAuthDiscovery:

		drInfos, err := m.GetCustomApiAuthDiscovery().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCustomApiAuthDiscovery().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "custom_api_auth_discovery." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateApiDiscoverySetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiDiscoverySetting) ApiDiscoverySettingsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_discovery_settings_choice")
	}
	return validatorFn, nil
}

func (v *ValidateApiDiscoverySetting) LearnFromRedirectTrafficValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for learn_from_redirect_traffic")
	}
	return validatorFn, nil
}

func (v *ValidateApiDiscoverySetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiDiscoverySetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiDiscoverySetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_crawler"]; exists {

		vOpts := append(opts, db.WithValidateField("api_crawler"))
		if err := fv(ctx, m.GetApiCrawler(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["api_discovery_from_code_scan"]; exists {

		vOpts := append(opts, db.WithValidateField("api_discovery_from_code_scan"))
		if err := fv(ctx, m.GetApiDiscoveryFromCodeScan(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["api_discovery_settings_choice"]; exists {
		val := m.GetApiDiscoverySettingsChoice()
		vOpts := append(opts,
			db.WithValidateField("api_discovery_settings_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetApiDiscoverySettingsChoice().(type) {
	case *ApiDiscoverySetting_DefaultApiAuthDiscovery:
		if fv, exists := v.FldValidators["api_discovery_settings_choice.default_api_auth_discovery"]; exists {
			val := m.GetApiDiscoverySettingsChoice().(*ApiDiscoverySetting_DefaultApiAuthDiscovery).DefaultApiAuthDiscovery
			vOpts := append(opts,
				db.WithValidateField("api_discovery_settings_choice"),
				db.WithValidateField("default_api_auth_discovery"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ApiDiscoverySetting_CustomApiAuthDiscovery:
		if fv, exists := v.FldValidators["api_discovery_settings_choice.custom_api_auth_discovery"]; exists {
			val := m.GetApiDiscoverySettingsChoice().(*ApiDiscoverySetting_CustomApiAuthDiscovery).CustomApiAuthDiscovery
			vOpts := append(opts,
				db.WithValidateField("api_discovery_settings_choice"),
				db.WithValidateField("custom_api_auth_discovery"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["discovered_api_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("discovered_api_settings"))
		if err := fv(ctx, m.GetDiscoveredApiSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["learn_from_redirect_traffic"]; exists {
		val := m.GetLearnFromRedirectTraffic()
		vOpts := append(opts,
			db.WithValidateField("learn_from_redirect_traffic"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLearnFromRedirectTraffic().(type) {
	case *ApiDiscoverySetting_DisableLearnFromRedirectTraffic:
		if fv, exists := v.FldValidators["learn_from_redirect_traffic.disable_learn_from_redirect_traffic"]; exists {
			val := m.GetLearnFromRedirectTraffic().(*ApiDiscoverySetting_DisableLearnFromRedirectTraffic).DisableLearnFromRedirectTraffic
			vOpts := append(opts,
				db.WithValidateField("learn_from_redirect_traffic"),
				db.WithValidateField("disable_learn_from_redirect_traffic"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ApiDiscoverySetting_EnableLearnFromRedirectTraffic:
		if fv, exists := v.FldValidators["learn_from_redirect_traffic.enable_learn_from_redirect_traffic"]; exists {
			val := m.GetLearnFromRedirectTraffic().(*ApiDiscoverySetting_EnableLearnFromRedirectTraffic).EnableLearnFromRedirectTraffic
			vOpts := append(opts,
				db.WithValidateField("learn_from_redirect_traffic"),
				db.WithValidateField("enable_learn_from_redirect_traffic"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["sensitive_data_detection_rules"]; exists {

		vOpts := append(opts, db.WithValidateField("sensitive_data_detection_rules"))
		if err := fv(ctx, m.GetSensitiveDataDetectionRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiDiscoverySettingValidator = func() *ValidateApiDiscoverySetting {
	v := &ValidateApiDiscoverySetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiDiscoverySettingsChoice := v.ApiDiscoverySettingsChoiceValidationRuleHandler
	rulesApiDiscoverySettingsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhApiDiscoverySettingsChoice(rulesApiDiscoverySettingsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiDiscoverySetting.api_discovery_settings_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_discovery_settings_choice"] = vFn

	vrhLearnFromRedirectTraffic := v.LearnFromRedirectTrafficValidationRuleHandler
	rulesLearnFromRedirectTraffic := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLearnFromRedirectTraffic(rulesLearnFromRedirectTraffic)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiDiscoverySetting.learn_from_redirect_traffic: %s", err)
		panic(errMsg)
	}
	v.FldValidators["learn_from_redirect_traffic"] = vFn

	v.FldValidators["api_discovery_settings_choice.custom_api_auth_discovery"] = ApiDiscoveryAdvancedSettingsValidator().Validate

	v.FldValidators["sensitive_data_detection_rules"] = ves_io_schema_app_type.SensitiveDataDetectionRulesValidator().Validate

	v.FldValidators["discovered_api_settings"] = ves_io_schema_app_type.DiscoveredAPISettingsValidator().Validate

	v.FldValidators["api_discovery_from_code_scan"] = ApiDiscoveryFromCodeScanValidator().Validate

	v.FldValidators["api_crawler"] = ApiCrawlerValidator().Validate

	return v
}()

func ApiDiscoverySettingValidator() db.Validator {
	return DefaultApiDiscoverySettingValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiEndpointDetails) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiEndpointDetails) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiEndpointDetails) DeepCopy() *ApiEndpointDetails {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiEndpointDetails{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiEndpointDetails) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiEndpointDetails) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiEndpointDetailsValidator().Validate(ctx, m, opts...)
}

type ValidateApiEndpointDetails struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiEndpointDetails) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path")
	}

	return validatorFn, nil
}

func (v *ValidateApiEndpointDetails) MethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpMethod)
		return int32(i)
	}
	// ves_io_schema.HttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.HttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.HttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.HttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.HttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateApiEndpointDetails) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiEndpointDetails)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiEndpointDetails got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["methods"]; exists {
		vOpts := append(opts, db.WithValidateField("methods"))
		if err := fv(ctx, m.GetMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiEndpointDetailsValidator = func() *ValidateApiEndpointDetails {
	v := &ValidateApiEndpointDetails{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required":           "true",
		"ves.io.schema.rules.string.max_len":             "1024",
		"ves.io.schema.rules.string.templated_http_path": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiEndpointDetails.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	vrhMethods := v.MethodsValidationRuleHandler
	rulesMethods := map[string]string{
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.max_items":               "16",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhMethods(rulesMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiEndpointDetails.methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["methods"] = vFn

	return v
}()

func ApiEndpointDetailsValidator() db.Validator {
	return DefaultApiEndpointDetailsValidator
}

// augmented methods on protoc/std generated struct

func (m *ApiEndpointRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ApiEndpointRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ApiEndpointRule) DeepCopy() *ApiEndpointRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ApiEndpointRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ApiEndpointRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ApiEndpointRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ApiEndpointRuleValidator().Validate(ctx, m, opts...)
}

func (m *ApiEndpointRule) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetClientMatcherDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetClientMatcherDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ApiEndpointRule) GetClientMatcherDRefInfo() ([]db.DRefInfo, error) {
	if m.GetClientMatcher() == nil {
		return nil, nil
	}

	drInfos, err := m.GetClientMatcher().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetClientMatcher().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "client_matcher." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ApiEndpointRule) GetRateLimiterChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRateLimiterChoice() == nil {
		return nil, nil
	}
	switch m.GetRateLimiterChoice().(type) {
	case *ApiEndpointRule_InlineRateLimiter:

		drInfos, err := m.GetInlineRateLimiter().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetInlineRateLimiter().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "inline_rate_limiter." + dri.DRField
		}
		return drInfos, err

	case *ApiEndpointRule_RefRateLimiter:

		vref := m.GetRefRateLimiter()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("rate_limiter.Object")
		dri := db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "ref_rate_limiter",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}

}

type ValidateApiEndpointRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateApiEndpointRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateApiEndpointRule) DomainChoiceSpecificDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SpecificDomain, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for specific_domain")
	}
	return oValidatorFn_SpecificDomain, nil
}

func (v *ValidateApiEndpointRule) RateLimiterChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for rate_limiter_choice")
	}
	return validatorFn, nil
}

func (v *ValidateApiEndpointRule) ApiEndpointPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_endpoint_path")
	}

	return validatorFn, nil
}

func (v *ValidateApiEndpointRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ApiEndpointRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ApiEndpointRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_endpoint_method"]; exists {

		vOpts := append(opts, db.WithValidateField("api_endpoint_method"))
		if err := fv(ctx, m.GetApiEndpointMethod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["api_endpoint_path"]; exists {

		vOpts := append(opts, db.WithValidateField("api_endpoint_path"))
		if err := fv(ctx, m.GetApiEndpointPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["base_path"]; exists {

		vOpts := append(opts, db.WithValidateField("base_path"))
		if err := fv(ctx, m.GetBasePath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("client_matcher"))
		if err := fv(ctx, m.GetClientMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *ApiEndpointRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*ApiEndpointRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ApiEndpointRule_SpecificDomain:
		if fv, exists := v.FldValidators["domain_choice.specific_domain"]; exists {
			val := m.GetDomainChoice().(*ApiEndpointRule_SpecificDomain).SpecificDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("specific_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_choice"]; exists {
		val := m.GetRateLimiterChoice()
		vOpts := append(opts,
			db.WithValidateField("rate_limiter_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRateLimiterChoice().(type) {
	case *ApiEndpointRule_InlineRateLimiter:
		if fv, exists := v.FldValidators["rate_limiter_choice.inline_rate_limiter"]; exists {
			val := m.GetRateLimiterChoice().(*ApiEndpointRule_InlineRateLimiter).InlineRateLimiter
			vOpts := append(opts,
				db.WithValidateField("rate_limiter_choice"),
				db.WithValidateField("inline_rate_limiter"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ApiEndpointRule_RefRateLimiter:
		if fv, exists := v.FldValidators["rate_limiter_choice.ref_rate_limiter"]; exists {
			val := m.GetRateLimiterChoice().(*ApiEndpointRule_RefRateLimiter).RefRateLimiter
			vOpts := append(opts,
				db.WithValidateField("rate_limiter_choice"),
				db.WithValidateField("ref_rate_limiter"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["request_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("request_matcher"))
		if err := fv(ctx, m.GetRequestMatcher(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultApiEndpointRuleValidator = func() *ValidateApiEndpointRule {
	v := &ValidateApiEndpointRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiEndpointRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceSpecificDomain := v.DomainChoiceSpecificDomainValidationRuleHandler
	rulesDomainChoiceSpecificDomain := map[string]string{
		"ves.io.schema.rules.string.max_len":   "128",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFnMap["domain_choice.specific_domain"], err = vrhDomainChoiceSpecificDomain(rulesDomainChoiceSpecificDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ApiEndpointRule.domain_choice_specific_domain: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.specific_domain"] = vFnMap["domain_choice.specific_domain"]

	vrhRateLimiterChoice := v.RateLimiterChoiceValidationRuleHandler
	rulesRateLimiterChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRateLimiterChoice(rulesRateLimiterChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiEndpointRule.rate_limiter_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_choice"] = vFn

	vrhApiEndpointPath := v.ApiEndpointPathValidationRuleHandler
	rulesApiEndpointPath := map[string]string{
		"ves.io.schema.rules.message.required":           "true",
		"ves.io.schema.rules.string.max_len":             "1024",
		"ves.io.schema.rules.string.templated_http_path": "true",
	}
	vFn, err = vrhApiEndpointPath(rulesApiEndpointPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ApiEndpointRule.api_endpoint_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_endpoint_path"] = vFn

	v.FldValidators["rate_limiter_choice.inline_rate_limiter"] = InlineRateLimiterValidator().Validate
	v.FldValidators["rate_limiter_choice.ref_rate_limiter"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["api_endpoint_method"] = ves_io_schema_policy.HttpMethodMatcherTypeValidator().Validate

	v.FldValidators["request_matcher"] = ves_io_schema_policy.RequestMatcherValidator().Validate

	v.FldValidators["client_matcher"] = ves_io_schema_policy.ClientMatcherValidator().Validate

	return v
}()

func ApiEndpointRuleValidator() db.Validator {
	return DefaultApiEndpointRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *Audiences) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Audiences) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Audiences) DeepCopy() *Audiences {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Audiences{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Audiences) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Audiences) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AudiencesValidator().Validate(ctx, m, opts...)
}

type ValidateAudiences struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAudiences) AudiencesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for audiences")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for audiences")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated audiences")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items audiences")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAudiences) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Audiences)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Audiences got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["audiences"]; exists {
		vOpts := append(opts, db.WithValidateField("audiences"))
		if err := fv(ctx, m.GetAudiences(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAudiencesValidator = func() *ValidateAudiences {
	v := &ValidateAudiences{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAudiences := v.AudiencesValidationRuleHandler
	rulesAudiences := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAudiences(rulesAudiences)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Audiences.audiences: %s", err)
		panic(errMsg)
	}
	v.FldValidators["audiences"] = vFn

	return v
}()

func AudiencesValidator() db.Validator {
	return DefaultAudiencesValidator
}

// augmented methods on protoc/std generated struct

func (m *BasePathsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BasePathsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BasePathsType) DeepCopy() *BasePathsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BasePathsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BasePathsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BasePathsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BasePathsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBasePathsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBasePathsType) BasePathsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for base_paths")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for base_paths")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated base_paths")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items base_paths")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBasePathsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BasePathsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BasePathsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["base_paths"]; exists {
		vOpts := append(opts, db.WithValidateField("base_paths"))
		if err := fv(ctx, m.GetBasePaths(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBasePathsTypeValidator = func() *ValidateBasePathsType {
	v := &ValidateBasePathsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBasePaths := v.BasePathsValidationRuleHandler
	rulesBasePaths := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.http_path": "true",
		"ves.io.schema.rules.repeated.items.string.not_empty": "true",
		"ves.io.schema.rules.repeated.max_items":              "16",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhBasePaths(rulesBasePaths)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BasePathsType.base_paths: %s", err)
		panic(errMsg)
	}
	v.FldValidators["base_paths"] = vFn

	return v
}()

func BasePathsTypeValidator() db.Validator {
	return DefaultBasePathsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BypassRateLimitingRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BypassRateLimitingRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BypassRateLimitingRule) DeepCopy() *BypassRateLimitingRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BypassRateLimitingRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BypassRateLimitingRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BypassRateLimitingRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BypassRateLimitingRuleValidator().Validate(ctx, m, opts...)
}

func (m *BypassRateLimitingRule) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetClientMatcherDRefInfo()

}

// GetDRefInfo for the field's type
func (m *BypassRateLimitingRule) GetClientMatcherDRefInfo() ([]db.DRefInfo, error) {
	if m.GetClientMatcher() == nil {
		return nil, nil
	}

	drInfos, err := m.GetClientMatcher().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetClientMatcher().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "client_matcher." + dri.DRField
	}
	return drInfos, err

}

type ValidateBypassRateLimitingRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBypassRateLimitingRule) DestinationTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for destination_type")
	}
	return validatorFn, nil
}

func (v *ValidateBypassRateLimitingRule) DestinationTypeApiEndpointValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return ApiEndpointDetailsValidator().Validate, nil
}

func (v *ValidateBypassRateLimitingRule) DestinationTypeBasePathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_BasePath, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for base_path")
	}
	return oValidatorFn_BasePath, nil
}

func (v *ValidateBypassRateLimitingRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateBypassRateLimitingRule) DomainChoiceSpecificDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SpecificDomain, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for specific_domain")
	}
	return oValidatorFn_SpecificDomain, nil
}

func (v *ValidateBypassRateLimitingRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BypassRateLimitingRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BypassRateLimitingRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["client_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("client_matcher"))
		if err := fv(ctx, m.GetClientMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["destination_type"]; exists {
		val := m.GetDestinationType()
		vOpts := append(opts,
			db.WithValidateField("destination_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDestinationType().(type) {
	case *BypassRateLimitingRule_AnyUrl:
		if fv, exists := v.FldValidators["destination_type.any_url"]; exists {
			val := m.GetDestinationType().(*BypassRateLimitingRule_AnyUrl).AnyUrl
			vOpts := append(opts,
				db.WithValidateField("destination_type"),
				db.WithValidateField("any_url"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BypassRateLimitingRule_BasePath:
		if fv, exists := v.FldValidators["destination_type.base_path"]; exists {
			val := m.GetDestinationType().(*BypassRateLimitingRule_BasePath).BasePath
			vOpts := append(opts,
				db.WithValidateField("destination_type"),
				db.WithValidateField("base_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BypassRateLimitingRule_ApiEndpoint:
		if fv, exists := v.FldValidators["destination_type.api_endpoint"]; exists {
			val := m.GetDestinationType().(*BypassRateLimitingRule_ApiEndpoint).ApiEndpoint
			vOpts := append(opts,
				db.WithValidateField("destination_type"),
				db.WithValidateField("api_endpoint"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BypassRateLimitingRule_ApiGroups:
		if fv, exists := v.FldValidators["destination_type.api_groups"]; exists {
			val := m.GetDestinationType().(*BypassRateLimitingRule_ApiGroups).ApiGroups
			vOpts := append(opts,
				db.WithValidateField("destination_type"),
				db.WithValidateField("api_groups"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *BypassRateLimitingRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*BypassRateLimitingRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BypassRateLimitingRule_SpecificDomain:
		if fv, exists := v.FldValidators["domain_choice.specific_domain"]; exists {
			val := m.GetDomainChoice().(*BypassRateLimitingRule_SpecificDomain).SpecificDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("specific_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["request_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("request_matcher"))
		if err := fv(ctx, m.GetRequestMatcher(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBypassRateLimitingRuleValidator = func() *ValidateBypassRateLimitingRule {
	v := &ValidateBypassRateLimitingRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDestinationType := v.DestinationTypeValidationRuleHandler
	rulesDestinationType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDestinationType(rulesDestinationType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BypassRateLimitingRule.destination_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["destination_type"] = vFn

	vrhDestinationTypeBasePath := v.DestinationTypeBasePathValidationRuleHandler
	rulesDestinationTypeBasePath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFnMap["destination_type.base_path"], err = vrhDestinationTypeBasePath(rulesDestinationTypeBasePath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field BypassRateLimitingRule.destination_type_base_path: %s", err)
		panic(errMsg)
	}
	vrhDestinationTypeApiEndpoint := v.DestinationTypeApiEndpointValidationRuleHandler
	rulesDestinationTypeApiEndpoint := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFnMap["destination_type.api_endpoint"], err = vrhDestinationTypeApiEndpoint(rulesDestinationTypeApiEndpoint)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field BypassRateLimitingRule.destination_type_api_endpoint: %s", err)
		panic(errMsg)
	}

	v.FldValidators["destination_type.base_path"] = vFnMap["destination_type.base_path"]
	v.FldValidators["destination_type.api_endpoint"] = vFnMap["destination_type.api_endpoint"]

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BypassRateLimitingRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceSpecificDomain := v.DomainChoiceSpecificDomainValidationRuleHandler
	rulesDomainChoiceSpecificDomain := map[string]string{
		"ves.io.schema.rules.string.max_len":   "128",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFnMap["domain_choice.specific_domain"], err = vrhDomainChoiceSpecificDomain(rulesDomainChoiceSpecificDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field BypassRateLimitingRule.domain_choice_specific_domain: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.specific_domain"] = vFnMap["domain_choice.specific_domain"]

	v.FldValidators["destination_type.api_groups"] = APIGroupsValidator().Validate

	v.FldValidators["request_matcher"] = ves_io_schema_policy.RequestMatcherValidator().Validate

	v.FldValidators["client_matcher"] = ves_io_schema_policy.ClientMatcherValidator().Validate

	return v
}()

func BypassRateLimitingRuleValidator() db.Validator {
	return DefaultBypassRateLimitingRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *BypassRateLimitingRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BypassRateLimitingRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BypassRateLimitingRules) DeepCopy() *BypassRateLimitingRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BypassRateLimitingRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BypassRateLimitingRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BypassRateLimitingRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BypassRateLimitingRulesValidator().Validate(ctx, m, opts...)
}

func (m *BypassRateLimitingRules) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetBypassRateLimitingRulesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *BypassRateLimitingRules) GetBypassRateLimitingRulesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetBypassRateLimitingRules() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetBypassRateLimitingRules() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetBypassRateLimitingRules() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("bypass_rate_limiting_rules[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateBypassRateLimitingRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBypassRateLimitingRules) BypassRateLimitingRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for bypass_rate_limiting_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*BypassRateLimitingRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := BypassRateLimitingRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for bypass_rate_limiting_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*BypassRateLimitingRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*BypassRateLimitingRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated bypass_rate_limiting_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items bypass_rate_limiting_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBypassRateLimitingRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BypassRateLimitingRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BypassRateLimitingRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bypass_rate_limiting_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("bypass_rate_limiting_rules"))
		if err := fv(ctx, m.GetBypassRateLimitingRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBypassRateLimitingRulesValidator = func() *ValidateBypassRateLimitingRules {
	v := &ValidateBypassRateLimitingRules{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBypassRateLimitingRules := v.BypassRateLimitingRulesValidationRuleHandler
	rulesBypassRateLimitingRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "20",
	}
	vFn, err = vrhBypassRateLimitingRules(rulesBypassRateLimitingRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BypassRateLimitingRules.bypass_rate_limiting_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bypass_rate_limiting_rules"] = vFn

	return v
}()

func BypassRateLimitingRulesValidator() db.Validator {
	return DefaultBypassRateLimitingRulesValidator
}

// augmented methods on protoc/std generated struct

func (m *ChallengeRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ChallengeRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ChallengeRule) DeepCopy() *ChallengeRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ChallengeRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ChallengeRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ChallengeRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChallengeRuleValidator().Validate(ctx, m, opts...)
}

func (m *ChallengeRule) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSpecDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ChallengeRule) GetSpecDRefInfo() ([]db.DRefInfo, error) {
	if m.GetSpec() == nil {
		return nil, nil
	}

	drInfos, err := m.GetSpec().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetSpec().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "spec." + dri.DRField
	}
	return drInfos, err

}

type ValidateChallengeRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChallengeRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateChallengeRule) SpecValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for spec")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_service_policy_rule.ChallengeRuleSpecValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateChallengeRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ChallengeRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ChallengeRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spec"]; exists {

		vOpts := append(opts, db.WithValidateField("spec"))
		if err := fv(ctx, m.GetSpec(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChallengeRuleValidator = func() *ValidateChallengeRule {
	v := &ValidateChallengeRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ChallengeRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhSpec := v.SpecValidationRuleHandler
	rulesSpec := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSpec(rulesSpec)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ChallengeRule.spec: %s", err)
		panic(errMsg)
	}
	v.FldValidators["spec"] = vFn

	return v
}()

func ChallengeRuleValidator() db.Validator {
	return DefaultChallengeRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *ChallengeRuleList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ChallengeRuleList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ChallengeRuleList) DeepCopy() *ChallengeRuleList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ChallengeRuleList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ChallengeRuleList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ChallengeRuleList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChallengeRuleListValidator().Validate(ctx, m, opts...)
}

func (m *ChallengeRuleList) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRulesDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ChallengeRuleList) GetRulesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRules() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetRules() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRules() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("rules[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateChallengeRuleList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChallengeRuleList) RulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ChallengeRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ChallengeRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ChallengeRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ChallengeRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateChallengeRuleList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ChallengeRuleList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ChallengeRuleList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["rules"]; exists {
		vOpts := append(opts, db.WithValidateField("rules"))
		if err := fv(ctx, m.GetRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChallengeRuleListValidator = func() *ValidateChallengeRuleList {
	v := &ValidateChallengeRuleList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRules := v.RulesValidationRuleHandler
	rulesRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items":            "64",
		"ves.io.schema.rules.repeated.unique_metadata_name": "true",
	}
	vFn, err = vrhRules(rulesRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ChallengeRuleList.rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rules"] = vFn

	return v
}()

func ChallengeRuleListValidator() db.Validator {
	return DefaultChallengeRuleListValidator
}

// augmented methods on protoc/std generated struct

func (m *CodeBaseIntegrationSelection) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CodeBaseIntegrationSelection) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CodeBaseIntegrationSelection) DeepCopy() *CodeBaseIntegrationSelection {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CodeBaseIntegrationSelection{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CodeBaseIntegrationSelection) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CodeBaseIntegrationSelection) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CodeBaseIntegrationSelectionValidator().Validate(ctx, m, opts...)
}

func (m *CodeBaseIntegrationSelection) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCodeBaseIntegrationDRefInfo()

}

func (m *CodeBaseIntegrationSelection) GetCodeBaseIntegrationDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetCodeBaseIntegration()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("code_base_integration.Object")
	dri := db.DRefInfo{
		RefdType:   "code_base_integration.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "code_base_integration",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetCodeBaseIntegrationDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CodeBaseIntegrationSelection) GetCodeBaseIntegrationDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "code_base_integration.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: code_base_integration")
	}

	vref := m.GetCodeBaseIntegration()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "code_base_integration.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateCodeBaseIntegrationSelection struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCodeBaseIntegrationSelection) ApiReposChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_repos_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCodeBaseIntegrationSelection) CodeBaseIntegrationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for code_base_integration")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCodeBaseIntegrationSelection) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CodeBaseIntegrationSelection)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CodeBaseIntegrationSelection got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_repos_choice"]; exists {
		val := m.GetApiReposChoice()
		vOpts := append(opts,
			db.WithValidateField("api_repos_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetApiReposChoice().(type) {
	case *CodeBaseIntegrationSelection_AllRepos:
		if fv, exists := v.FldValidators["api_repos_choice.all_repos"]; exists {
			val := m.GetApiReposChoice().(*CodeBaseIntegrationSelection_AllRepos).AllRepos
			vOpts := append(opts,
				db.WithValidateField("api_repos_choice"),
				db.WithValidateField("all_repos"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CodeBaseIntegrationSelection_SelectedRepos:
		if fv, exists := v.FldValidators["api_repos_choice.selected_repos"]; exists {
			val := m.GetApiReposChoice().(*CodeBaseIntegrationSelection_SelectedRepos).SelectedRepos
			vOpts := append(opts,
				db.WithValidateField("api_repos_choice"),
				db.WithValidateField("selected_repos"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["code_base_integration"]; exists {

		vOpts := append(opts, db.WithValidateField("code_base_integration"))
		if err := fv(ctx, m.GetCodeBaseIntegration(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCodeBaseIntegrationSelectionValidator = func() *ValidateCodeBaseIntegrationSelection {
	v := &ValidateCodeBaseIntegrationSelection{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhApiReposChoice := v.ApiReposChoiceValidationRuleHandler
	rulesApiReposChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhApiReposChoice(rulesApiReposChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CodeBaseIntegrationSelection.api_repos_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_repos_choice"] = vFn

	vrhCodeBaseIntegration := v.CodeBaseIntegrationValidationRuleHandler
	rulesCodeBaseIntegration := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCodeBaseIntegration(rulesCodeBaseIntegration)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CodeBaseIntegrationSelection.code_base_integration: %s", err)
		panic(errMsg)
	}
	v.FldValidators["code_base_integration"] = vFn

	v.FldValidators["api_repos_choice.selected_repos"] = ApiCodeReposValidator().Validate

	return v
}()

func CodeBaseIntegrationSelectionValidator() db.Validator {
	return DefaultCodeBaseIntegrationSelectionValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomFallThroughMode) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomFallThroughMode) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomFallThroughMode) DeepCopy() *CustomFallThroughMode {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomFallThroughMode{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomFallThroughMode) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomFallThroughMode) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomFallThroughModeValidator().Validate(ctx, m, opts...)
}

type ValidateCustomFallThroughMode struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomFallThroughMode) OpenApiValidationRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for open_api_validation_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*FallThroughRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := FallThroughRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for open_api_validation_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*FallThroughRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*FallThroughRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated open_api_validation_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items open_api_validation_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCustomFallThroughMode) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomFallThroughMode)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomFallThroughMode got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["open_api_validation_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("open_api_validation_rules"))
		if err := fv(ctx, m.GetOpenApiValidationRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomFallThroughModeValidator = func() *ValidateCustomFallThroughMode {
	v := &ValidateCustomFallThroughMode{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOpenApiValidationRules := v.OpenApiValidationRulesValidationRuleHandler
	rulesOpenApiValidationRules := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.max_items":            "15",
		"ves.io.schema.rules.repeated.unique_metadata_name": "true",
	}
	vFn, err = vrhOpenApiValidationRules(rulesOpenApiValidationRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomFallThroughMode.open_api_validation_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["open_api_validation_rules"] = vFn

	return v
}()

func CustomFallThroughModeValidator() db.Validator {
	return DefaultCustomFallThroughModeValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomIpAllowedList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomIpAllowedList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomIpAllowedList) DeepCopy() *CustomIpAllowedList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomIpAllowedList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomIpAllowedList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomIpAllowedList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomIpAllowedListValidator().Validate(ctx, m, opts...)
}

func (m *CustomIpAllowedList) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetRateLimiterAllowedPrefixesDRefInfo()

}

func (m *CustomIpAllowedList) GetRateLimiterAllowedPrefixesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetRateLimiterAllowedPrefixes()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("CustomIpAllowedList.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("ip_prefix_set.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "ip_prefix_set.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "rate_limiter_allowed_prefixes",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetRateLimiterAllowedPrefixesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CustomIpAllowedList) GetRateLimiterAllowedPrefixesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "ip_prefix_set.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: ip_prefix_set")
	}
	for i, vref := range m.GetRateLimiterAllowedPrefixes() {
		if vref == nil {
			return nil, fmt.Errorf("CustomIpAllowedList.rate_limiter_allowed_prefixes[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "ip_prefix_set.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateCustomIpAllowedList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomIpAllowedList) RateLimiterAllowedPrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rate_limiter_allowed_prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rate_limiter_allowed_prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rate_limiter_allowed_prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCustomIpAllowedList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomIpAllowedList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomIpAllowedList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["rate_limiter_allowed_prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("rate_limiter_allowed_prefixes"))
		if err := fv(ctx, m.GetRateLimiterAllowedPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomIpAllowedListValidator = func() *ValidateCustomIpAllowedList {
	v := &ValidateCustomIpAllowedList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRateLimiterAllowedPrefixes := v.RateLimiterAllowedPrefixesValidationRuleHandler
	rulesRateLimiterAllowedPrefixes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
		"ves.io.schema.rules.repeated.min_items": "1",
	}
	vFn, err = vrhRateLimiterAllowedPrefixes(rulesRateLimiterAllowedPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomIpAllowedList.rate_limiter_allowed_prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_allowed_prefixes"] = vFn

	return v
}()

func CustomIpAllowedListValidator() db.Validator {
	return DefaultCustomIpAllowedListValidator
}

// augmented methods on protoc/std generated struct

func (m *DomainConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DomainConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *DomainConfiguration) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetSimpleLogin().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting DomainConfiguration.simple_login")
	}

	return nil
}

func (m *DomainConfiguration) DeepCopy() *DomainConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DomainConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DomainConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DomainConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DomainConfigurationValidator().Validate(ctx, m, opts...)
}

type ValidateDomainConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDomainConfiguration) DomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain")
	}

	return validatorFn, nil
}

func (v *ValidateDomainConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DomainConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DomainConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["simple_login"]; exists {

		vOpts := append(opts, db.WithValidateField("simple_login"))
		if err := fv(ctx, m.GetSimpleLogin(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDomainConfigurationValidator = func() *ValidateDomainConfiguration {
	v := &ValidateDomainConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomain := v.DomainValidationRuleHandler
	rulesDomain := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFn, err = vrhDomain(rulesDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DomainConfiguration.domain: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain"] = vFn

	v.FldValidators["simple_login"] = SimpleLoginValidator().Validate

	return v
}()

func DomainConfigurationValidator() db.Validator {
	return DefaultDomainConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *EnableChallenge) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnableChallenge) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnableChallenge) DeepCopy() *EnableChallenge {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnableChallenge{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnableChallenge) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnableChallenge) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnableChallengeValidator().Validate(ctx, m, opts...)
}

func (m *EnableChallenge) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetMaliciousUserMitigationChoiceDRefInfo()

}

func (m *EnableChallenge) GetMaliciousUserMitigationChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetMaliciousUserMitigationChoice().(type) {
	case *EnableChallenge_DefaultMitigationSettings:

		return nil, nil

	case *EnableChallenge_MaliciousUserMitigation:

		vref := m.GetMaliciousUserMitigation()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("malicious_user_mitigation.Object")
		dri := db.DRefInfo{
			RefdType:   "malicious_user_mitigation.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "malicious_user_mitigation",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetMaliciousUserMitigationChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *EnableChallenge) GetMaliciousUserMitigationChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetMaliciousUserMitigationChoice().(type) {
	case *EnableChallenge_DefaultMitigationSettings:

	case *EnableChallenge_MaliciousUserMitigation:
		refdType, err := d.TypeForEntryKind("", "", "malicious_user_mitigation.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: malicious_user_mitigation")
		}

		vref := m.GetMaliciousUserMitigation()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "malicious_user_mitigation.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateEnableChallenge struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnableChallenge) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnableChallenge)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnableChallenge got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetCaptchaChallengeParametersChoice().(type) {
	case *EnableChallenge_DefaultCaptchaChallengeParameters:
		if fv, exists := v.FldValidators["captcha_challenge_parameters_choice.default_captcha_challenge_parameters"]; exists {
			val := m.GetCaptchaChallengeParametersChoice().(*EnableChallenge_DefaultCaptchaChallengeParameters).DefaultCaptchaChallengeParameters
			vOpts := append(opts,
				db.WithValidateField("captcha_challenge_parameters_choice"),
				db.WithValidateField("default_captcha_challenge_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EnableChallenge_CaptchaChallengeParameters:
		if fv, exists := v.FldValidators["captcha_challenge_parameters_choice.captcha_challenge_parameters"]; exists {
			val := m.GetCaptchaChallengeParametersChoice().(*EnableChallenge_CaptchaChallengeParameters).CaptchaChallengeParameters
			vOpts := append(opts,
				db.WithValidateField("captcha_challenge_parameters_choice"),
				db.WithValidateField("captcha_challenge_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetJsChallengeParametersChoice().(type) {
	case *EnableChallenge_DefaultJsChallengeParameters:
		if fv, exists := v.FldValidators["js_challenge_parameters_choice.default_js_challenge_parameters"]; exists {
			val := m.GetJsChallengeParametersChoice().(*EnableChallenge_DefaultJsChallengeParameters).DefaultJsChallengeParameters
			vOpts := append(opts,
				db.WithValidateField("js_challenge_parameters_choice"),
				db.WithValidateField("default_js_challenge_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EnableChallenge_JsChallengeParameters:
		if fv, exists := v.FldValidators["js_challenge_parameters_choice.js_challenge_parameters"]; exists {
			val := m.GetJsChallengeParametersChoice().(*EnableChallenge_JsChallengeParameters).JsChallengeParameters
			vOpts := append(opts,
				db.WithValidateField("js_challenge_parameters_choice"),
				db.WithValidateField("js_challenge_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetMaliciousUserMitigationChoice().(type) {
	case *EnableChallenge_DefaultMitigationSettings:
		if fv, exists := v.FldValidators["malicious_user_mitigation_choice.default_mitigation_settings"]; exists {
			val := m.GetMaliciousUserMitigationChoice().(*EnableChallenge_DefaultMitigationSettings).DefaultMitigationSettings
			vOpts := append(opts,
				db.WithValidateField("malicious_user_mitigation_choice"),
				db.WithValidateField("default_mitigation_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EnableChallenge_MaliciousUserMitigation:
		if fv, exists := v.FldValidators["malicious_user_mitigation_choice.malicious_user_mitigation"]; exists {
			val := m.GetMaliciousUserMitigationChoice().(*EnableChallenge_MaliciousUserMitigation).MaliciousUserMitigation
			vOpts := append(opts,
				db.WithValidateField("malicious_user_mitigation_choice"),
				db.WithValidateField("malicious_user_mitigation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnableChallengeValidator = func() *ValidateEnableChallenge {
	v := &ValidateEnableChallenge{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["captcha_challenge_parameters_choice.captcha_challenge_parameters"] = ves_io_schema_virtual_host.CaptchaChallengeTypeValidator().Validate

	v.FldValidators["js_challenge_parameters_choice.js_challenge_parameters"] = ves_io_schema_virtual_host.JavascriptChallengeTypeValidator().Validate

	v.FldValidators["malicious_user_mitigation_choice.malicious_user_mitigation"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func EnableChallengeValidator() db.Validator {
	return DefaultEnableChallengeValidator
}

// augmented methods on protoc/std generated struct

func (m *FallThroughRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FallThroughRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FallThroughRule) DeepCopy() *FallThroughRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FallThroughRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FallThroughRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FallThroughRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FallThroughRuleValidator().Validate(ctx, m, opts...)
}

type ValidateFallThroughRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFallThroughRule) ActionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for action_choice")
	}
	return validatorFn, nil
}

func (v *ValidateFallThroughRule) ConditionTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for condition_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateFallThroughRule) ConditionTypeChoiceBasePathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_BasePath, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for base_path")
	}
	return oValidatorFn_BasePath, nil
}
func (v *ValidateFallThroughRule) ConditionTypeChoiceApiGroupValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ApiGroup, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_group")
	}
	return oValidatorFn_ApiGroup, nil
}

func (v *ValidateFallThroughRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateFallThroughRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FallThroughRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FallThroughRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action_choice"]; exists {
		val := m.GetActionChoice()
		vOpts := append(opts,
			db.WithValidateField("action_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetActionChoice().(type) {
	case *FallThroughRule_ActionSkip:
		if fv, exists := v.FldValidators["action_choice.action_skip"]; exists {
			val := m.GetActionChoice().(*FallThroughRule_ActionSkip).ActionSkip
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("action_skip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FallThroughRule_ActionReport:
		if fv, exists := v.FldValidators["action_choice.action_report"]; exists {
			val := m.GetActionChoice().(*FallThroughRule_ActionReport).ActionReport
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("action_report"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FallThroughRule_ActionBlock:
		if fv, exists := v.FldValidators["action_choice.action_block"]; exists {
			val := m.GetActionChoice().(*FallThroughRule_ActionBlock).ActionBlock
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("action_block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["condition_type_choice"]; exists {
		val := m.GetConditionTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("condition_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConditionTypeChoice().(type) {
	case *FallThroughRule_BasePath:
		if fv, exists := v.FldValidators["condition_type_choice.base_path"]; exists {
			val := m.GetConditionTypeChoice().(*FallThroughRule_BasePath).BasePath
			vOpts := append(opts,
				db.WithValidateField("condition_type_choice"),
				db.WithValidateField("base_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FallThroughRule_ApiGroup:
		if fv, exists := v.FldValidators["condition_type_choice.api_group"]; exists {
			val := m.GetConditionTypeChoice().(*FallThroughRule_ApiGroup).ApiGroup
			vOpts := append(opts,
				db.WithValidateField("condition_type_choice"),
				db.WithValidateField("api_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *FallThroughRule_ApiEndpoint:
		if fv, exists := v.FldValidators["condition_type_choice.api_endpoint"]; exists {
			val := m.GetConditionTypeChoice().(*FallThroughRule_ApiEndpoint).ApiEndpoint
			vOpts := append(opts,
				db.WithValidateField("condition_type_choice"),
				db.WithValidateField("api_endpoint"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFallThroughRuleValidator = func() *ValidateFallThroughRule {
	v := &ValidateFallThroughRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhActionChoice := v.ActionChoiceValidationRuleHandler
	rulesActionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhActionChoice(rulesActionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FallThroughRule.action_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action_choice"] = vFn

	vrhConditionTypeChoice := v.ConditionTypeChoiceValidationRuleHandler
	rulesConditionTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhConditionTypeChoice(rulesConditionTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FallThroughRule.condition_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["condition_type_choice"] = vFn

	vrhConditionTypeChoiceBasePath := v.ConditionTypeChoiceBasePathValidationRuleHandler
	rulesConditionTypeChoiceBasePath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFnMap["condition_type_choice.base_path"], err = vrhConditionTypeChoiceBasePath(rulesConditionTypeChoiceBasePath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field FallThroughRule.condition_type_choice_base_path: %s", err)
		panic(errMsg)
	}
	vrhConditionTypeChoiceApiGroup := v.ConditionTypeChoiceApiGroupValidationRuleHandler
	rulesConditionTypeChoiceApiGroup := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFnMap["condition_type_choice.api_group"], err = vrhConditionTypeChoiceApiGroup(rulesConditionTypeChoiceApiGroup)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field FallThroughRule.condition_type_choice_api_group: %s", err)
		panic(errMsg)
	}

	v.FldValidators["condition_type_choice.base_path"] = vFnMap["condition_type_choice.base_path"]
	v.FldValidators["condition_type_choice.api_group"] = vFnMap["condition_type_choice.api_group"]

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for FallThroughRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	v.FldValidators["condition_type_choice.api_endpoint"] = ApiEndpointDetailsValidator().Validate

	return v
}()

func FallThroughRuleValidator() db.Validator {
	return DefaultFallThroughRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *HttpHeaderMatcherList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HttpHeaderMatcherList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HttpHeaderMatcherList) DeepCopy() *HttpHeaderMatcherList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HttpHeaderMatcherList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HttpHeaderMatcherList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HttpHeaderMatcherList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HttpHeaderMatcherListValidator().Validate(ctx, m, opts...)
}

type ValidateHttpHeaderMatcherList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHttpHeaderMatcherList) HeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.HeaderMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.HeaderMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.HeaderMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.HeaderMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateHttpHeaderMatcherList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HttpHeaderMatcherList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HttpHeaderMatcherList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["headers"]; exists {
		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHttpHeaderMatcherListValidator = func() *ValidateHttpHeaderMatcherList {
	v := &ValidateHttpHeaderMatcherList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaders := v.HeadersValidationRuleHandler
	rulesHeaders := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhHeaders(rulesHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HttpHeaderMatcherList.headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["headers"] = vFn

	return v
}()

func HttpHeaderMatcherListValidator() db.Validator {
	return DefaultHttpHeaderMatcherListValidator
}

// augmented methods on protoc/std generated struct

func (m *IPThreatCategoryListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPThreatCategoryListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPThreatCategoryListType) DeepCopy() *IPThreatCategoryListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPThreatCategoryListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPThreatCategoryListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPThreatCategoryListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPThreatCategoryListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateIPThreatCategoryListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPThreatCategoryListType) IpThreatCategoriesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_policy.IPThreatCategory)
		return int32(i)
	}
	// ves_io_schema_policy.IPThreatCategory_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema_policy.IPThreatCategory_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_threat_categories")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema_policy.IPThreatCategory, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ip_threat_categories")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema_policy.IPThreatCategory)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema_policy.IPThreatCategory, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ip_threat_categories")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ip_threat_categories")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIPThreatCategoryListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPThreatCategoryListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPThreatCategoryListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_threat_categories"]; exists {
		vOpts := append(opts, db.WithValidateField("ip_threat_categories"))
		if err := fv(ctx, m.GetIpThreatCategories(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPThreatCategoryListTypeValidator = func() *ValidateIPThreatCategoryListType {
	v := &ValidateIPThreatCategoryListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpThreatCategories := v.IpThreatCategoriesValidationRuleHandler
	rulesIpThreatCategories := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhIpThreatCategories(rulesIpThreatCategories)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPThreatCategoryListType.ip_threat_categories: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_threat_categories"] = vFn

	return v
}()

func IPThreatCategoryListTypeValidator() db.Validator {
	return DefaultIPThreatCategoryListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InlineRateLimiter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InlineRateLimiter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InlineRateLimiter) DeepCopy() *InlineRateLimiter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InlineRateLimiter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InlineRateLimiter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InlineRateLimiter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InlineRateLimiterValidator().Validate(ctx, m, opts...)
}

func (m *InlineRateLimiter) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetCountByChoiceDRefInfo()

}

func (m *InlineRateLimiter) GetCountByChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetCountByChoice().(type) {
	case *InlineRateLimiter_UseHttpLbUserId:

		return nil, nil

	case *InlineRateLimiter_RefUserId:

		vref := m.GetRefUserId()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("user_identification.Object")
		dri := db.DRefInfo{
			RefdType:   "user_identification.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "ref_user_id",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetCountByChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *InlineRateLimiter) GetCountByChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetCountByChoice().(type) {
	case *InlineRateLimiter_UseHttpLbUserId:

	case *InlineRateLimiter_RefUserId:
		refdType, err := d.TypeForEntryKind("", "", "user_identification.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: user_identification")
		}

		vref := m.GetRefUserId()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "user_identification.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateInlineRateLimiter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInlineRateLimiter) CountByChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for count_by_choice")
	}
	return validatorFn, nil
}

func (v *ValidateInlineRateLimiter) ThresholdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for threshold")
	}

	return validatorFn, nil
}

func (v *ValidateInlineRateLimiter) UnitValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_rate_limiter.RateLimitPeriodUnit)
		return int32(i)
	}
	// ves_io_schema_rate_limiter.RateLimitPeriodUnit_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema_rate_limiter.RateLimitPeriodUnit_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for unit")
	}

	return validatorFn, nil
}

func (v *ValidateInlineRateLimiter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InlineRateLimiter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InlineRateLimiter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count_by_choice"]; exists {
		val := m.GetCountByChoice()
		vOpts := append(opts,
			db.WithValidateField("count_by_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCountByChoice().(type) {
	case *InlineRateLimiter_UseHttpLbUserId:
		if fv, exists := v.FldValidators["count_by_choice.use_http_lb_user_id"]; exists {
			val := m.GetCountByChoice().(*InlineRateLimiter_UseHttpLbUserId).UseHttpLbUserId
			vOpts := append(opts,
				db.WithValidateField("count_by_choice"),
				db.WithValidateField("use_http_lb_user_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *InlineRateLimiter_RefUserId:
		if fv, exists := v.FldValidators["count_by_choice.ref_user_id"]; exists {
			val := m.GetCountByChoice().(*InlineRateLimiter_RefUserId).RefUserId
			vOpts := append(opts,
				db.WithValidateField("count_by_choice"),
				db.WithValidateField("ref_user_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["threshold"]; exists {

		vOpts := append(opts, db.WithValidateField("threshold"))
		if err := fv(ctx, m.GetThreshold(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unit"]; exists {

		vOpts := append(opts, db.WithValidateField("unit"))
		if err := fv(ctx, m.GetUnit(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInlineRateLimiterValidator = func() *ValidateInlineRateLimiter {
	v := &ValidateInlineRateLimiter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCountByChoice := v.CountByChoiceValidationRuleHandler
	rulesCountByChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCountByChoice(rulesCountByChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InlineRateLimiter.count_by_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["count_by_choice"] = vFn

	vrhThreshold := v.ThresholdValidationRuleHandler
	rulesThreshold := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gt":        "0",
		"ves.io.schema.rules.uint32.lte":       "8192",
	}
	vFn, err = vrhThreshold(rulesThreshold)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InlineRateLimiter.threshold: %s", err)
		panic(errMsg)
	}
	v.FldValidators["threshold"] = vFn

	vrhUnit := v.UnitValidationRuleHandler
	rulesUnit := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhUnit(rulesUnit)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for InlineRateLimiter.unit: %s", err)
		panic(errMsg)
	}
	v.FldValidators["unit"] = vFn

	v.FldValidators["count_by_choice.ref_user_id"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func InlineRateLimiterValidator() db.Validator {
	return DefaultInlineRateLimiterValidator
}

// augmented methods on protoc/std generated struct

func (m *JWKS) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JWKS) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JWKS) String() string {
	if m == nil {
		return ""
	}
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.string()
}

func (m *JWKS) GoString() string {
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.goString()
}

// Redact squashes sensitive info in m (in-place)
func (m *JWKS) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	m.Cleartext = "Redacted"

	return nil
}

func (m *JWKS) DeepCopy() *JWKS {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JWKS{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JWKS) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JWKS) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JWKSValidator().Validate(ctx, m, opts...)
}

type ValidateJWKS struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJWKS) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JWKS)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JWKS got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cleartext"]; exists {

		vOpts := append(opts, db.WithValidateField("cleartext"))
		if err := fv(ctx, m.GetCleartext(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJWKSValidator = func() *ValidateJWKS {
	v := &ValidateJWKS{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JWKSValidator() db.Validator {
	return DefaultJWKSValidator
}

// augmented methods on protoc/std generated struct

func (m *JWTValidation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JWTValidation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *JWTValidation) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetJwksConfig().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting JWTValidation.jwks_config")
	}

	return nil
}

func (m *JWTValidation) DeepCopy() *JWTValidation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JWTValidation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JWTValidation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JWTValidation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JWTValidationValidator().Validate(ctx, m, opts...)
}

type ValidateJWTValidation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJWTValidation) JwksConfigurationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for jwks_configuration")
	}
	return validatorFn, nil
}

func (v *ValidateJWTValidation) TargetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for target")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := TargetValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJWTValidation) TokenLocationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for token_location")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := TokenLocationValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJWTValidation) ActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for action")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.ActionValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateJWTValidation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JWTValidation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JWTValidation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["action"]; exists {

		vOpts := append(opts, db.WithValidateField("action"))
		if err := fv(ctx, m.GetAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["jwks_configuration"]; exists {
		val := m.GetJwksConfiguration()
		vOpts := append(opts,
			db.WithValidateField("jwks_configuration"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetJwksConfiguration().(type) {
	case *JWTValidation_AuthServerUri:
		if fv, exists := v.FldValidators["jwks_configuration.auth_server_uri"]; exists {
			val := m.GetJwksConfiguration().(*JWTValidation_AuthServerUri).AuthServerUri
			vOpts := append(opts,
				db.WithValidateField("jwks_configuration"),
				db.WithValidateField("auth_server_uri"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JWTValidation_Jwks:
		if fv, exists := v.FldValidators["jwks_configuration.jwks"]; exists {
			val := m.GetJwksConfiguration().(*JWTValidation_Jwks).Jwks
			vOpts := append(opts,
				db.WithValidateField("jwks_configuration"),
				db.WithValidateField("jwks"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *JWTValidation_JwksConfig:
		if fv, exists := v.FldValidators["jwks_configuration.jwks_config"]; exists {
			val := m.GetJwksConfiguration().(*JWTValidation_JwksConfig).JwksConfig
			vOpts := append(opts,
				db.WithValidateField("jwks_configuration"),
				db.WithValidateField("jwks_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mandatory_claims"]; exists {

		vOpts := append(opts, db.WithValidateField("mandatory_claims"))
		if err := fv(ctx, m.GetMandatoryClaims(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reserved_claims"]; exists {

		vOpts := append(opts, db.WithValidateField("reserved_claims"))
		if err := fv(ctx, m.GetReservedClaims(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["target"]; exists {

		vOpts := append(opts, db.WithValidateField("target"))
		if err := fv(ctx, m.GetTarget(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["token_location"]; exists {

		vOpts := append(opts, db.WithValidateField("token_location"))
		if err := fv(ctx, m.GetTokenLocation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJWTValidationValidator = func() *ValidateJWTValidation {
	v := &ValidateJWTValidation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJwksConfiguration := v.JwksConfigurationValidationRuleHandler
	rulesJwksConfiguration := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhJwksConfiguration(rulesJwksConfiguration)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JWTValidation.jwks_configuration: %s", err)
		panic(errMsg)
	}
	v.FldValidators["jwks_configuration"] = vFn

	vrhTarget := v.TargetValidationRuleHandler
	rulesTarget := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTarget(rulesTarget)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JWTValidation.target: %s", err)
		panic(errMsg)
	}
	v.FldValidators["target"] = vFn

	vrhTokenLocation := v.TokenLocationValidationRuleHandler
	rulesTokenLocation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTokenLocation(rulesTokenLocation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JWTValidation.token_location: %s", err)
		panic(errMsg)
	}
	v.FldValidators["token_location"] = vFn

	vrhAction := v.ActionValidationRuleHandler
	rulesAction := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAction(rulesAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for JWTValidation.action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["action"] = vFn

	v.FldValidators["reserved_claims"] = ReservedClaimsValidator().Validate

	v.FldValidators["mandatory_claims"] = MandatoryClaimsValidator().Validate

	return v
}()

func JWTValidationValidator() db.Validator {
	return DefaultJWTValidationValidator
}

// augmented methods on protoc/std generated struct

func (m *MandatoryClaims) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MandatoryClaims) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MandatoryClaims) DeepCopy() *MandatoryClaims {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MandatoryClaims{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MandatoryClaims) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MandatoryClaims) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MandatoryClaimsValidator().Validate(ctx, m, opts...)
}

type ValidateMandatoryClaims struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMandatoryClaims) ClaimNamesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for claim_names")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for claim_names")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated claim_names")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items claim_names")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMandatoryClaims) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MandatoryClaims)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MandatoryClaims got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["claim_names"]; exists {
		vOpts := append(opts, db.WithValidateField("claim_names"))
		if err := fv(ctx, m.GetClaimNames(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMandatoryClaimsValidator = func() *ValidateMandatoryClaims {
	v := &ValidateMandatoryClaims{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClaimNames := v.ClaimNamesValidationRuleHandler
	rulesClaimNames := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhClaimNames(rulesClaimNames)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MandatoryClaims.claim_names: %s", err)
		panic(errMsg)
	}
	v.FldValidators["claim_names"] = vFn

	return v
}()

func MandatoryClaimsValidator() db.Validator {
	return DefaultMandatoryClaimsValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiFallThroughMode) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiFallThroughMode) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiFallThroughMode) DeepCopy() *OpenApiFallThroughMode {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiFallThroughMode{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiFallThroughMode) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiFallThroughMode) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiFallThroughModeValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiFallThroughMode struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiFallThroughMode) FallThroughModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fall_through_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOpenApiFallThroughMode) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiFallThroughMode)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiFallThroughMode got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fall_through_mode_choice"]; exists {
		val := m.GetFallThroughModeChoice()
		vOpts := append(opts,
			db.WithValidateField("fall_through_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFallThroughModeChoice().(type) {
	case *OpenApiFallThroughMode_FallThroughModeAllow:
		if fv, exists := v.FldValidators["fall_through_mode_choice.fall_through_mode_allow"]; exists {
			val := m.GetFallThroughModeChoice().(*OpenApiFallThroughMode_FallThroughModeAllow).FallThroughModeAllow
			vOpts := append(opts,
				db.WithValidateField("fall_through_mode_choice"),
				db.WithValidateField("fall_through_mode_allow"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiFallThroughMode_FallThroughModeCustom:
		if fv, exists := v.FldValidators["fall_through_mode_choice.fall_through_mode_custom"]; exists {
			val := m.GetFallThroughModeChoice().(*OpenApiFallThroughMode_FallThroughModeCustom).FallThroughModeCustom
			vOpts := append(opts,
				db.WithValidateField("fall_through_mode_choice"),
				db.WithValidateField("fall_through_mode_custom"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiFallThroughModeValidator = func() *ValidateOpenApiFallThroughMode {
	v := &ValidateOpenApiFallThroughMode{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFallThroughModeChoice := v.FallThroughModeChoiceValidationRuleHandler
	rulesFallThroughModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFallThroughModeChoice(rulesFallThroughModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiFallThroughMode.fall_through_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fall_through_mode_choice"] = vFn

	v.FldValidators["fall_through_mode_choice.fall_through_mode_custom"] = CustomFallThroughModeValidator().Validate

	return v
}()

func OpenApiFallThroughModeValidator() db.Validator {
	return DefaultOpenApiFallThroughModeValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiValidationAllSpecEndpointsSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiValidationAllSpecEndpointsSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiValidationAllSpecEndpointsSettings) DeepCopy() *OpenApiValidationAllSpecEndpointsSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiValidationAllSpecEndpointsSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiValidationAllSpecEndpointsSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiValidationAllSpecEndpointsSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiValidationAllSpecEndpointsSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiValidationAllSpecEndpointsSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiValidationAllSpecEndpointsSettings) ValidationModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for validation_mode")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := OpenApiValidationModeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationAllSpecEndpointsSettings) FallThroughModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for fall_through_mode")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := OpenApiFallThroughModeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationAllSpecEndpointsSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiValidationAllSpecEndpointsSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiValidationAllSpecEndpointsSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fall_through_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("fall_through_mode"))
		if err := fv(ctx, m.GetFallThroughMode(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetOversizedBodyChoice().(type) {
	case *OpenApiValidationAllSpecEndpointsSettings_OversizedBodySkipValidation:
		if fv, exists := v.FldValidators["oversized_body_choice.oversized_body_skip_validation"]; exists {
			val := m.GetOversizedBodyChoice().(*OpenApiValidationAllSpecEndpointsSettings_OversizedBodySkipValidation).OversizedBodySkipValidation
			vOpts := append(opts,
				db.WithValidateField("oversized_body_choice"),
				db.WithValidateField("oversized_body_skip_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationAllSpecEndpointsSettings_OversizedBodyFailValidation:
		if fv, exists := v.FldValidators["oversized_body_choice.oversized_body_fail_validation"]; exists {
			val := m.GetOversizedBodyChoice().(*OpenApiValidationAllSpecEndpointsSettings_OversizedBodyFailValidation).OversizedBodyFailValidation
			vOpts := append(opts,
				db.WithValidateField("oversized_body_choice"),
				db.WithValidateField("oversized_body_fail_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["settings"]; exists {

		vOpts := append(opts, db.WithValidateField("settings"))
		if err := fv(ctx, m.GetSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validation_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("validation_mode"))
		if err := fv(ctx, m.GetValidationMode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiValidationAllSpecEndpointsSettingsValidator = func() *ValidateOpenApiValidationAllSpecEndpointsSettings {
	v := &ValidateOpenApiValidationAllSpecEndpointsSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValidationMode := v.ValidationModeValidationRuleHandler
	rulesValidationMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhValidationMode(rulesValidationMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationAllSpecEndpointsSettings.validation_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["validation_mode"] = vFn

	vrhFallThroughMode := v.FallThroughModeValidationRuleHandler
	rulesFallThroughMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhFallThroughMode(rulesFallThroughMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationAllSpecEndpointsSettings.fall_through_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fall_through_mode"] = vFn

	v.FldValidators["settings"] = OpenApiValidationCommonSettingsValidator().Validate

	return v
}()

func OpenApiValidationAllSpecEndpointsSettingsValidator() db.Validator {
	return DefaultOpenApiValidationAllSpecEndpointsSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiValidationCommonSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiValidationCommonSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiValidationCommonSettings) DeepCopy() *OpenApiValidationCommonSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiValidationCommonSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiValidationCommonSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiValidationCommonSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiValidationCommonSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiValidationCommonSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiValidationCommonSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiValidationCommonSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiValidationCommonSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetFailConfiguration().(type) {
	case *OpenApiValidationCommonSettings_FailOpen:
		if fv, exists := v.FldValidators["fail_configuration.fail_open"]; exists {
			val := m.GetFailConfiguration().(*OpenApiValidationCommonSettings_FailOpen).FailOpen
			vOpts := append(opts,
				db.WithValidateField("fail_configuration"),
				db.WithValidateField("fail_open"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationCommonSettings_FailClose:
		if fv, exists := v.FldValidators["fail_configuration.fail_close"]; exists {
			val := m.GetFailConfiguration().(*OpenApiValidationCommonSettings_FailClose).FailClose
			vOpts := append(opts,
				db.WithValidateField("fail_configuration"),
				db.WithValidateField("fail_close"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetOversizedBodyChoice().(type) {
	case *OpenApiValidationCommonSettings_OversizedBodySkipValidation:
		if fv, exists := v.FldValidators["oversized_body_choice.oversized_body_skip_validation"]; exists {
			val := m.GetOversizedBodyChoice().(*OpenApiValidationCommonSettings_OversizedBodySkipValidation).OversizedBodySkipValidation
			vOpts := append(opts,
				db.WithValidateField("oversized_body_choice"),
				db.WithValidateField("oversized_body_skip_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationCommonSettings_OversizedBodyFailValidation:
		if fv, exists := v.FldValidators["oversized_body_choice.oversized_body_fail_validation"]; exists {
			val := m.GetOversizedBodyChoice().(*OpenApiValidationCommonSettings_OversizedBodyFailValidation).OversizedBodyFailValidation
			vOpts := append(opts,
				db.WithValidateField("oversized_body_choice"),
				db.WithValidateField("oversized_body_fail_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetPropertyValidationSettingsChoice().(type) {
	case *OpenApiValidationCommonSettings_PropertyValidationSettingsDefault:
		if fv, exists := v.FldValidators["property_validation_settings_choice.property_validation_settings_default"]; exists {
			val := m.GetPropertyValidationSettingsChoice().(*OpenApiValidationCommonSettings_PropertyValidationSettingsDefault).PropertyValidationSettingsDefault
			vOpts := append(opts,
				db.WithValidateField("property_validation_settings_choice"),
				db.WithValidateField("property_validation_settings_default"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationCommonSettings_PropertyValidationSettingsCustom:
		if fv, exists := v.FldValidators["property_validation_settings_choice.property_validation_settings_custom"]; exists {
			val := m.GetPropertyValidationSettingsChoice().(*OpenApiValidationCommonSettings_PropertyValidationSettingsCustom).PropertyValidationSettingsCustom
			vOpts := append(opts,
				db.WithValidateField("property_validation_settings_choice"),
				db.WithValidateField("property_validation_settings_custom"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiValidationCommonSettingsValidator = func() *ValidateOpenApiValidationCommonSettings {
	v := &ValidateOpenApiValidationCommonSettings{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["property_validation_settings_choice.property_validation_settings_custom"] = ValidationPropertySettingValidator().Validate

	return v
}()

func OpenApiValidationCommonSettingsValidator() db.Validator {
	return DefaultOpenApiValidationCommonSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiValidationMode) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiValidationMode) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiValidationMode) DeepCopy() *OpenApiValidationMode {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiValidationMode{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiValidationMode) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiValidationMode) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiValidationModeValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiValidationMode struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiValidationMode) ResponseValidationModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_validation_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOpenApiValidationMode) ValidationModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for validation_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOpenApiValidationMode) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiValidationMode)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiValidationMode got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["response_validation_mode_choice"]; exists {
		val := m.GetResponseValidationModeChoice()
		vOpts := append(opts,
			db.WithValidateField("response_validation_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetResponseValidationModeChoice().(type) {
	case *OpenApiValidationMode_SkipResponseValidation:
		if fv, exists := v.FldValidators["response_validation_mode_choice.skip_response_validation"]; exists {
			val := m.GetResponseValidationModeChoice().(*OpenApiValidationMode_SkipResponseValidation).SkipResponseValidation
			vOpts := append(opts,
				db.WithValidateField("response_validation_mode_choice"),
				db.WithValidateField("skip_response_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationMode_ResponseValidationModeActive:
		if fv, exists := v.FldValidators["response_validation_mode_choice.response_validation_mode_active"]; exists {
			val := m.GetResponseValidationModeChoice().(*OpenApiValidationMode_ResponseValidationModeActive).ResponseValidationModeActive
			vOpts := append(opts,
				db.WithValidateField("response_validation_mode_choice"),
				db.WithValidateField("response_validation_mode_active"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["validation_mode_choice"]; exists {
		val := m.GetValidationModeChoice()
		vOpts := append(opts,
			db.WithValidateField("validation_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetValidationModeChoice().(type) {
	case *OpenApiValidationMode_ValidationModeActive:
		if fv, exists := v.FldValidators["validation_mode_choice.validation_mode_active"]; exists {
			val := m.GetValidationModeChoice().(*OpenApiValidationMode_ValidationModeActive).ValidationModeActive
			vOpts := append(opts,
				db.WithValidateField("validation_mode_choice"),
				db.WithValidateField("validation_mode_active"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationMode_SkipValidation:
		if fv, exists := v.FldValidators["validation_mode_choice.skip_validation"]; exists {
			val := m.GetValidationModeChoice().(*OpenApiValidationMode_SkipValidation).SkipValidation
			vOpts := append(opts,
				db.WithValidateField("validation_mode_choice"),
				db.WithValidateField("skip_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiValidationModeValidator = func() *ValidateOpenApiValidationMode {
	v := &ValidateOpenApiValidationMode{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseValidationModeChoice := v.ResponseValidationModeChoiceValidationRuleHandler
	rulesResponseValidationModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhResponseValidationModeChoice(rulesResponseValidationModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationMode.response_validation_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_validation_mode_choice"] = vFn

	vrhValidationModeChoice := v.ValidationModeChoiceValidationRuleHandler
	rulesValidationModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhValidationModeChoice(rulesValidationModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationMode.validation_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["validation_mode_choice"] = vFn

	v.FldValidators["response_validation_mode_choice.response_validation_mode_active"] = OpenApiValidationModeActiveResponseValidator().Validate

	v.FldValidators["validation_mode_choice.validation_mode_active"] = OpenApiValidationModeActiveValidator().Validate

	return v
}()

func OpenApiValidationModeValidator() db.Validator {
	return DefaultOpenApiValidationModeValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiValidationModeActive) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiValidationModeActive) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiValidationModeActive) DeepCopy() *OpenApiValidationModeActive {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiValidationModeActive{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiValidationModeActive) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiValidationModeActive) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiValidationModeActiveValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiValidationModeActive struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiValidationModeActive) ValidationEnforcementTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for validation_enforcement_type")
	}
	return validatorFn, nil
}

func (v *ValidateOpenApiValidationModeActive) RequestValidationPropertiesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.OpenApiValidationProperties)
		return int32(i)
	}
	// ves_io_schema.OpenApiValidationProperties_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.OpenApiValidationProperties_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for request_validation_properties")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.OpenApiValidationProperties, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for request_validation_properties")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.OpenApiValidationProperties)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.OpenApiValidationProperties, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated request_validation_properties")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items request_validation_properties")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationModeActive) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiValidationModeActive)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiValidationModeActive got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["request_validation_properties"]; exists {
		vOpts := append(opts, db.WithValidateField("request_validation_properties"))
		if err := fv(ctx, m.GetRequestValidationProperties(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validation_enforcement_type"]; exists {
		val := m.GetValidationEnforcementType()
		vOpts := append(opts,
			db.WithValidateField("validation_enforcement_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetValidationEnforcementType().(type) {
	case *OpenApiValidationModeActive_EnforcementReport:
		if fv, exists := v.FldValidators["validation_enforcement_type.enforcement_report"]; exists {
			val := m.GetValidationEnforcementType().(*OpenApiValidationModeActive_EnforcementReport).EnforcementReport
			vOpts := append(opts,
				db.WithValidateField("validation_enforcement_type"),
				db.WithValidateField("enforcement_report"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationModeActive_EnforcementBlock:
		if fv, exists := v.FldValidators["validation_enforcement_type.enforcement_block"]; exists {
			val := m.GetValidationEnforcementType().(*OpenApiValidationModeActive_EnforcementBlock).EnforcementBlock
			vOpts := append(opts,
				db.WithValidateField("validation_enforcement_type"),
				db.WithValidateField("enforcement_block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiValidationModeActiveValidator = func() *ValidateOpenApiValidationModeActive {
	v := &ValidateOpenApiValidationModeActive{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValidationEnforcementType := v.ValidationEnforcementTypeValidationRuleHandler
	rulesValidationEnforcementType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhValidationEnforcementType(rulesValidationEnforcementType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationModeActive.validation_enforcement_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["validation_enforcement_type"] = vFn

	vrhRequestValidationProperties := v.RequestValidationPropertiesValidationRuleHandler
	rulesRequestValidationProperties := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.not_in":       "[7]",
		"ves.io.schema.rules.repeated.min_items":               "1",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhRequestValidationProperties(rulesRequestValidationProperties)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationModeActive.request_validation_properties: %s", err)
		panic(errMsg)
	}
	v.FldValidators["request_validation_properties"] = vFn

	return v
}()

func OpenApiValidationModeActiveValidator() db.Validator {
	return DefaultOpenApiValidationModeActiveValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiValidationModeActiveResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiValidationModeActiveResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiValidationModeActiveResponse) DeepCopy() *OpenApiValidationModeActiveResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiValidationModeActiveResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiValidationModeActiveResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiValidationModeActiveResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiValidationModeActiveResponseValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiValidationModeActiveResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiValidationModeActiveResponse) ValidationEnforcementTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for validation_enforcement_type")
	}
	return validatorFn, nil
}

func (v *ValidateOpenApiValidationModeActiveResponse) ResponseValidationPropertiesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.OpenApiValidationProperties)
		return int32(i)
	}
	// ves_io_schema.OpenApiValidationProperties_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.OpenApiValidationProperties_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_validation_properties")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.OpenApiValidationProperties, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_validation_properties")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.OpenApiValidationProperties)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.OpenApiValidationProperties, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_validation_properties")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_validation_properties")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationModeActiveResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiValidationModeActiveResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiValidationModeActiveResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["response_validation_properties"]; exists {
		vOpts := append(opts, db.WithValidateField("response_validation_properties"))
		if err := fv(ctx, m.GetResponseValidationProperties(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validation_enforcement_type"]; exists {
		val := m.GetValidationEnforcementType()
		vOpts := append(opts,
			db.WithValidateField("validation_enforcement_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetValidationEnforcementType().(type) {
	case *OpenApiValidationModeActiveResponse_EnforcementReport:
		if fv, exists := v.FldValidators["validation_enforcement_type.enforcement_report"]; exists {
			val := m.GetValidationEnforcementType().(*OpenApiValidationModeActiveResponse_EnforcementReport).EnforcementReport
			vOpts := append(opts,
				db.WithValidateField("validation_enforcement_type"),
				db.WithValidateField("enforcement_report"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationModeActiveResponse_EnforcementBlock:
		if fv, exists := v.FldValidators["validation_enforcement_type.enforcement_block"]; exists {
			val := m.GetValidationEnforcementType().(*OpenApiValidationModeActiveResponse_EnforcementBlock).EnforcementBlock
			vOpts := append(opts,
				db.WithValidateField("validation_enforcement_type"),
				db.WithValidateField("enforcement_block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiValidationModeActiveResponseValidator = func() *ValidateOpenApiValidationModeActiveResponse {
	v := &ValidateOpenApiValidationModeActiveResponse{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValidationEnforcementType := v.ValidationEnforcementTypeValidationRuleHandler
	rulesValidationEnforcementType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhValidationEnforcementType(rulesValidationEnforcementType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationModeActiveResponse.validation_enforcement_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["validation_enforcement_type"] = vFn

	vrhResponseValidationProperties := v.ResponseValidationPropertiesValidationRuleHandler
	rulesResponseValidationProperties := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.in":           "[2,4,5,7]",
		"ves.io.schema.rules.repeated.min_items":               "1",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhResponseValidationProperties(rulesResponseValidationProperties)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationModeActiveResponse.response_validation_properties: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_validation_properties"] = vFn

	return v
}()

func OpenApiValidationModeActiveResponseValidator() db.Validator {
	return DefaultOpenApiValidationModeActiveResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *OpenApiValidationRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OpenApiValidationRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OpenApiValidationRule) DeepCopy() *OpenApiValidationRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OpenApiValidationRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OpenApiValidationRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OpenApiValidationRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OpenApiValidationRuleValidator().Validate(ctx, m, opts...)
}

type ValidateOpenApiValidationRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOpenApiValidationRule) ConditionTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for condition_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOpenApiValidationRule) ConditionTypeChoiceBasePathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_BasePath, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for base_path")
	}
	return oValidatorFn_BasePath, nil
}
func (v *ValidateOpenApiValidationRule) ConditionTypeChoiceApiGroupValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ApiGroup, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_group")
	}
	return oValidatorFn_ApiGroup, nil
}

func (v *ValidateOpenApiValidationRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateOpenApiValidationRule) DomainChoiceSpecificDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SpecificDomain, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for specific_domain")
	}
	return oValidatorFn_SpecificDomain, nil
}

func (v *ValidateOpenApiValidationRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationRule) ValidationModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for validation_mode")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := OpenApiValidationModeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateOpenApiValidationRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OpenApiValidationRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OpenApiValidationRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["condition_type_choice"]; exists {
		val := m.GetConditionTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("condition_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConditionTypeChoice().(type) {
	case *OpenApiValidationRule_BasePath:
		if fv, exists := v.FldValidators["condition_type_choice.base_path"]; exists {
			val := m.GetConditionTypeChoice().(*OpenApiValidationRule_BasePath).BasePath
			vOpts := append(opts,
				db.WithValidateField("condition_type_choice"),
				db.WithValidateField("base_path"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationRule_ApiGroup:
		if fv, exists := v.FldValidators["condition_type_choice.api_group"]; exists {
			val := m.GetConditionTypeChoice().(*OpenApiValidationRule_ApiGroup).ApiGroup
			vOpts := append(opts,
				db.WithValidateField("condition_type_choice"),
				db.WithValidateField("api_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationRule_ApiEndpoint:
		if fv, exists := v.FldValidators["condition_type_choice.api_endpoint"]; exists {
			val := m.GetConditionTypeChoice().(*OpenApiValidationRule_ApiEndpoint).ApiEndpoint
			vOpts := append(opts,
				db.WithValidateField("condition_type_choice"),
				db.WithValidateField("api_endpoint"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *OpenApiValidationRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*OpenApiValidationRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *OpenApiValidationRule_SpecificDomain:
		if fv, exists := v.FldValidators["domain_choice.specific_domain"]; exists {
			val := m.GetDomainChoice().(*OpenApiValidationRule_SpecificDomain).SpecificDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("specific_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validation_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("validation_mode"))
		if err := fv(ctx, m.GetValidationMode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOpenApiValidationRuleValidator = func() *ValidateOpenApiValidationRule {
	v := &ValidateOpenApiValidationRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConditionTypeChoice := v.ConditionTypeChoiceValidationRuleHandler
	rulesConditionTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhConditionTypeChoice(rulesConditionTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationRule.condition_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["condition_type_choice"] = vFn

	vrhConditionTypeChoiceBasePath := v.ConditionTypeChoiceBasePathValidationRuleHandler
	rulesConditionTypeChoiceBasePath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFnMap["condition_type_choice.base_path"], err = vrhConditionTypeChoiceBasePath(rulesConditionTypeChoiceBasePath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OpenApiValidationRule.condition_type_choice_base_path: %s", err)
		panic(errMsg)
	}
	vrhConditionTypeChoiceApiGroup := v.ConditionTypeChoiceApiGroupValidationRuleHandler
	rulesConditionTypeChoiceApiGroup := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFnMap["condition_type_choice.api_group"], err = vrhConditionTypeChoiceApiGroup(rulesConditionTypeChoiceApiGroup)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OpenApiValidationRule.condition_type_choice_api_group: %s", err)
		panic(errMsg)
	}

	v.FldValidators["condition_type_choice.base_path"] = vFnMap["condition_type_choice.base_path"]
	v.FldValidators["condition_type_choice.api_group"] = vFnMap["condition_type_choice.api_group"]

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceSpecificDomain := v.DomainChoiceSpecificDomainValidationRuleHandler
	rulesDomainChoiceSpecificDomain := map[string]string{
		"ves.io.schema.rules.string.max_len":   "128",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFnMap["domain_choice.specific_domain"], err = vrhDomainChoiceSpecificDomain(rulesDomainChoiceSpecificDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field OpenApiValidationRule.domain_choice_specific_domain: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.specific_domain"] = vFnMap["domain_choice.specific_domain"]

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhValidationMode := v.ValidationModeValidationRuleHandler
	rulesValidationMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhValidationMode(rulesValidationMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OpenApiValidationRule.validation_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["validation_mode"] = vFn

	v.FldValidators["condition_type_choice.api_endpoint"] = ApiEndpointDetailsValidator().Validate

	return v
}()

func OpenApiValidationRuleValidator() db.Validator {
	return DefaultOpenApiValidationRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *PolicyBasedChallenge) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PolicyBasedChallenge) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PolicyBasedChallenge) DeepCopy() *PolicyBasedChallenge {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PolicyBasedChallenge{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PolicyBasedChallenge) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PolicyBasedChallenge) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PolicyBasedChallengeValidator().Validate(ctx, m, opts...)
}

func (m *PolicyBasedChallenge) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetMaliciousUserMitigationChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetMaliciousUserMitigationChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRuleListDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRuleListDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *PolicyBasedChallenge) GetMaliciousUserMitigationChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetMaliciousUserMitigationChoice().(type) {
	case *PolicyBasedChallenge_DefaultMitigationSettings:

		return nil, nil

	case *PolicyBasedChallenge_MaliciousUserMitigation:

		vref := m.GetMaliciousUserMitigation()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("malicious_user_mitigation.Object")
		dri := db.DRefInfo{
			RefdType:   "malicious_user_mitigation.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "malicious_user_mitigation",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetMaliciousUserMitigationChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *PolicyBasedChallenge) GetMaliciousUserMitigationChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetMaliciousUserMitigationChoice().(type) {
	case *PolicyBasedChallenge_DefaultMitigationSettings:

	case *PolicyBasedChallenge_MaliciousUserMitigation:
		refdType, err := d.TypeForEntryKind("", "", "malicious_user_mitigation.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: malicious_user_mitigation")
		}

		vref := m.GetMaliciousUserMitigation()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "malicious_user_mitigation.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *PolicyBasedChallenge) GetRuleListDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRuleList() == nil {
		return nil, nil
	}

	drInfos, err := m.GetRuleList().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetRuleList().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "rule_list." + dri.DRField
	}
	return drInfos, err

}

type ValidatePolicyBasedChallenge struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePolicyBasedChallenge) ChallengeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for challenge_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePolicyBasedChallenge) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PolicyBasedChallenge)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PolicyBasedChallenge got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetCaptchaChallengeParametersChoice().(type) {
	case *PolicyBasedChallenge_DefaultCaptchaChallengeParameters:
		if fv, exists := v.FldValidators["captcha_challenge_parameters_choice.default_captcha_challenge_parameters"]; exists {
			val := m.GetCaptchaChallengeParametersChoice().(*PolicyBasedChallenge_DefaultCaptchaChallengeParameters).DefaultCaptchaChallengeParameters
			vOpts := append(opts,
				db.WithValidateField("captcha_challenge_parameters_choice"),
				db.WithValidateField("default_captcha_challenge_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_CaptchaChallengeParameters:
		if fv, exists := v.FldValidators["captcha_challenge_parameters_choice.captcha_challenge_parameters"]; exists {
			val := m.GetCaptchaChallengeParametersChoice().(*PolicyBasedChallenge_CaptchaChallengeParameters).CaptchaChallengeParameters
			vOpts := append(opts,
				db.WithValidateField("captcha_challenge_parameters_choice"),
				db.WithValidateField("captcha_challenge_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["challenge_choice"]; exists {
		val := m.GetChallengeChoice()
		vOpts := append(opts,
			db.WithValidateField("challenge_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetChallengeChoice().(type) {
	case *PolicyBasedChallenge_NoChallenge:
		if fv, exists := v.FldValidators["challenge_choice.no_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_NoChallenge).NoChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("no_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_AlwaysEnableJsChallenge:
		if fv, exists := v.FldValidators["challenge_choice.always_enable_js_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableJsChallenge).AlwaysEnableJsChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("always_enable_js_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_AlwaysEnableCaptchaChallenge:
		if fv, exists := v.FldValidators["challenge_choice.always_enable_captcha_challenge"]; exists {
			val := m.GetChallengeChoice().(*PolicyBasedChallenge_AlwaysEnableCaptchaChallenge).AlwaysEnableCaptchaChallenge
			vOpts := append(opts,
				db.WithValidateField("challenge_choice"),
				db.WithValidateField("always_enable_captcha_challenge"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetJsChallengeParametersChoice().(type) {
	case *PolicyBasedChallenge_DefaultJsChallengeParameters:
		if fv, exists := v.FldValidators["js_challenge_parameters_choice.default_js_challenge_parameters"]; exists {
			val := m.GetJsChallengeParametersChoice().(*PolicyBasedChallenge_DefaultJsChallengeParameters).DefaultJsChallengeParameters
			vOpts := append(opts,
				db.WithValidateField("js_challenge_parameters_choice"),
				db.WithValidateField("default_js_challenge_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_JsChallengeParameters:
		if fv, exists := v.FldValidators["js_challenge_parameters_choice.js_challenge_parameters"]; exists {
			val := m.GetJsChallengeParametersChoice().(*PolicyBasedChallenge_JsChallengeParameters).JsChallengeParameters
			vOpts := append(opts,
				db.WithValidateField("js_challenge_parameters_choice"),
				db.WithValidateField("js_challenge_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetMaliciousUserMitigationChoice().(type) {
	case *PolicyBasedChallenge_DefaultMitigationSettings:
		if fv, exists := v.FldValidators["malicious_user_mitigation_choice.default_mitigation_settings"]; exists {
			val := m.GetMaliciousUserMitigationChoice().(*PolicyBasedChallenge_DefaultMitigationSettings).DefaultMitigationSettings
			vOpts := append(opts,
				db.WithValidateField("malicious_user_mitigation_choice"),
				db.WithValidateField("default_mitigation_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_MaliciousUserMitigation:
		if fv, exists := v.FldValidators["malicious_user_mitigation_choice.malicious_user_mitigation"]; exists {
			val := m.GetMaliciousUserMitigationChoice().(*PolicyBasedChallenge_MaliciousUserMitigation).MaliciousUserMitigation
			vOpts := append(opts,
				db.WithValidateField("malicious_user_mitigation_choice"),
				db.WithValidateField("malicious_user_mitigation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rule_list"]; exists {

		vOpts := append(opts, db.WithValidateField("rule_list"))
		if err := fv(ctx, m.GetRuleList(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetTemporaryBlockingParametersChoice().(type) {
	case *PolicyBasedChallenge_DefaultTemporaryBlockingParameters:
		if fv, exists := v.FldValidators["temporary_blocking_parameters_choice.default_temporary_blocking_parameters"]; exists {
			val := m.GetTemporaryBlockingParametersChoice().(*PolicyBasedChallenge_DefaultTemporaryBlockingParameters).DefaultTemporaryBlockingParameters
			vOpts := append(opts,
				db.WithValidateField("temporary_blocking_parameters_choice"),
				db.WithValidateField("default_temporary_blocking_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PolicyBasedChallenge_TemporaryUserBlocking:
		if fv, exists := v.FldValidators["temporary_blocking_parameters_choice.temporary_user_blocking"]; exists {
			val := m.GetTemporaryBlockingParametersChoice().(*PolicyBasedChallenge_TemporaryUserBlocking).TemporaryUserBlocking
			vOpts := append(opts,
				db.WithValidateField("temporary_blocking_parameters_choice"),
				db.WithValidateField("temporary_user_blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPolicyBasedChallengeValidator = func() *ValidatePolicyBasedChallenge {
	v := &ValidatePolicyBasedChallenge{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhChallengeChoice := v.ChallengeChoiceValidationRuleHandler
	rulesChallengeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhChallengeChoice(rulesChallengeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PolicyBasedChallenge.challenge_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["challenge_choice"] = vFn

	v.FldValidators["captcha_challenge_parameters_choice.captcha_challenge_parameters"] = ves_io_schema_virtual_host.CaptchaChallengeTypeValidator().Validate

	v.FldValidators["js_challenge_parameters_choice.js_challenge_parameters"] = ves_io_schema_virtual_host.JavascriptChallengeTypeValidator().Validate

	v.FldValidators["malicious_user_mitigation_choice.malicious_user_mitigation"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["temporary_blocking_parameters_choice.temporary_user_blocking"] = ves_io_schema_virtual_host.TemporaryUserBlockingTypeValidator().Validate

	v.FldValidators["rule_list"] = ChallengeRuleListValidator().Validate

	return v
}()

func PolicyBasedChallengeValidator() db.Validator {
	return DefaultPolicyBasedChallengeValidator
}

// augmented methods on protoc/std generated struct

func (m *RateLimitConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RateLimitConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RateLimitConfigType) DeepCopy() *RateLimitConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RateLimitConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RateLimitConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RateLimitConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RateLimitConfigTypeValidator().Validate(ctx, m, opts...)
}

func (m *RateLimitConfigType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetIpAllowedListChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpAllowedListChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetPolicyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetPolicyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *RateLimitConfigType) GetIpAllowedListChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpAllowedListChoice() == nil {
		return nil, nil
	}
	switch m.GetIpAllowedListChoice().(type) {
	case *RateLimitConfigType_NoIpAllowedList:

		return nil, nil

	case *RateLimitConfigType_IpAllowedList:

		return nil, nil

	case *RateLimitConfigType_CustomIpAllowedList:

		drInfos, err := m.GetCustomIpAllowedList().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetCustomIpAllowedList().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "custom_ip_allowed_list." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *RateLimitConfigType) GetPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetPolicyChoice() == nil {
		return nil, nil
	}
	switch m.GetPolicyChoice().(type) {
	case *RateLimitConfigType_NoPolicies:

		return nil, nil

	case *RateLimitConfigType_Policies:

		drInfos, err := m.GetPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateRateLimitConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRateLimitConfigType) IpAllowedListChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_allowed_list_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRateLimitConfigType) PolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateRateLimitConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RateLimitConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RateLimitConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ip_allowed_list_choice"]; exists {
		val := m.GetIpAllowedListChoice()
		vOpts := append(opts,
			db.WithValidateField("ip_allowed_list_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetIpAllowedListChoice().(type) {
	case *RateLimitConfigType_NoIpAllowedList:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.no_ip_allowed_list"]; exists {
			val := m.GetIpAllowedListChoice().(*RateLimitConfigType_NoIpAllowedList).NoIpAllowedList
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("no_ip_allowed_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RateLimitConfigType_IpAllowedList:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.ip_allowed_list"]; exists {
			val := m.GetIpAllowedListChoice().(*RateLimitConfigType_IpAllowedList).IpAllowedList
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("ip_allowed_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RateLimitConfigType_CustomIpAllowedList:
		if fv, exists := v.FldValidators["ip_allowed_list_choice.custom_ip_allowed_list"]; exists {
			val := m.GetIpAllowedListChoice().(*RateLimitConfigType_CustomIpAllowedList).CustomIpAllowedList
			vOpts := append(opts,
				db.WithValidateField("ip_allowed_list_choice"),
				db.WithValidateField("custom_ip_allowed_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["policy_choice"]; exists {
		val := m.GetPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPolicyChoice().(type) {
	case *RateLimitConfigType_NoPolicies:
		if fv, exists := v.FldValidators["policy_choice.no_policies"]; exists {
			val := m.GetPolicyChoice().(*RateLimitConfigType_NoPolicies).NoPolicies
			vOpts := append(opts,
				db.WithValidateField("policy_choice"),
				db.WithValidateField("no_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RateLimitConfigType_Policies:
		if fv, exists := v.FldValidators["policy_choice.policies"]; exists {
			val := m.GetPolicyChoice().(*RateLimitConfigType_Policies).Policies
			vOpts := append(opts,
				db.WithValidateField("policy_choice"),
				db.WithValidateField("policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rate_limiter"]; exists {

		vOpts := append(opts, db.WithValidateField("rate_limiter"))
		if err := fv(ctx, m.GetRateLimiter(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRateLimitConfigTypeValidator = func() *ValidateRateLimitConfigType {
	v := &ValidateRateLimitConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpAllowedListChoice := v.IpAllowedListChoiceValidationRuleHandler
	rulesIpAllowedListChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhIpAllowedListChoice(rulesIpAllowedListChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RateLimitConfigType.ip_allowed_list_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_allowed_list_choice"] = vFn

	vrhPolicyChoice := v.PolicyChoiceValidationRuleHandler
	rulesPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPolicyChoice(rulesPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RateLimitConfigType.policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["policy_choice"] = vFn

	v.FldValidators["ip_allowed_list_choice.ip_allowed_list"] = ves_io_schema_views.PrefixStringListTypeValidator().Validate
	v.FldValidators["ip_allowed_list_choice.custom_ip_allowed_list"] = CustomIpAllowedListValidator().Validate

	v.FldValidators["policy_choice.policies"] = ves_io_schema_views_rate_limiter_policy.PolicyListValidator().Validate

	v.FldValidators["rate_limiter"] = ves_io_schema_rate_limiter.RateLimitValueValidator().Validate

	return v
}()

func RateLimitConfigTypeValidator() db.Validator {
	return DefaultRateLimitConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReservedClaims) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReservedClaims) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReservedClaims) DeepCopy() *ReservedClaims {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReservedClaims{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReservedClaims) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReservedClaims) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReservedClaimsValidator().Validate(ctx, m, opts...)
}

type ValidateReservedClaims struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReservedClaims) AudienceValidationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for audience_validation")
	}
	return validatorFn, nil
}

func (v *ValidateReservedClaims) IssuerValidationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for issuer_validation")
	}
	return validatorFn, nil
}

func (v *ValidateReservedClaims) ValidatePeriodValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for validate_period")
	}
	return validatorFn, nil
}

func (v *ValidateReservedClaims) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReservedClaims)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReservedClaims got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["audience_validation"]; exists {
		val := m.GetAudienceValidation()
		vOpts := append(opts,
			db.WithValidateField("audience_validation"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAudienceValidation().(type) {
	case *ReservedClaims_AudienceDisable:
		if fv, exists := v.FldValidators["audience_validation.audience_disable"]; exists {
			val := m.GetAudienceValidation().(*ReservedClaims_AudienceDisable).AudienceDisable
			vOpts := append(opts,
				db.WithValidateField("audience_validation"),
				db.WithValidateField("audience_disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReservedClaims_Audience:
		if fv, exists := v.FldValidators["audience_validation.audience"]; exists {
			val := m.GetAudienceValidation().(*ReservedClaims_Audience).Audience
			vOpts := append(opts,
				db.WithValidateField("audience_validation"),
				db.WithValidateField("audience"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["issuer_validation"]; exists {
		val := m.GetIssuerValidation()
		vOpts := append(opts,
			db.WithValidateField("issuer_validation"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetIssuerValidation().(type) {
	case *ReservedClaims_IssuerDisable:
		if fv, exists := v.FldValidators["issuer_validation.issuer_disable"]; exists {
			val := m.GetIssuerValidation().(*ReservedClaims_IssuerDisable).IssuerDisable
			vOpts := append(opts,
				db.WithValidateField("issuer_validation"),
				db.WithValidateField("issuer_disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReservedClaims_Issuer:
		if fv, exists := v.FldValidators["issuer_validation.issuer"]; exists {
			val := m.GetIssuerValidation().(*ReservedClaims_Issuer).Issuer
			vOpts := append(opts,
				db.WithValidateField("issuer_validation"),
				db.WithValidateField("issuer"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["validate_period"]; exists {
		val := m.GetValidatePeriod()
		vOpts := append(opts,
			db.WithValidateField("validate_period"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetValidatePeriod().(type) {
	case *ReservedClaims_ValidatePeriodDisable:
		if fv, exists := v.FldValidators["validate_period.validate_period_disable"]; exists {
			val := m.GetValidatePeriod().(*ReservedClaims_ValidatePeriodDisable).ValidatePeriodDisable
			vOpts := append(opts,
				db.WithValidateField("validate_period"),
				db.WithValidateField("validate_period_disable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReservedClaims_ValidatePeriodEnable:
		if fv, exists := v.FldValidators["validate_period.validate_period_enable"]; exists {
			val := m.GetValidatePeriod().(*ReservedClaims_ValidatePeriodEnable).ValidatePeriodEnable
			vOpts := append(opts,
				db.WithValidateField("validate_period"),
				db.WithValidateField("validate_period_enable"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReservedClaimsValidator = func() *ValidateReservedClaims {
	v := &ValidateReservedClaims{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAudienceValidation := v.AudienceValidationValidationRuleHandler
	rulesAudienceValidation := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAudienceValidation(rulesAudienceValidation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReservedClaims.audience_validation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["audience_validation"] = vFn

	vrhIssuerValidation := v.IssuerValidationValidationRuleHandler
	rulesIssuerValidation := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhIssuerValidation(rulesIssuerValidation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReservedClaims.issuer_validation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["issuer_validation"] = vFn

	vrhValidatePeriod := v.ValidatePeriodValidationRuleHandler
	rulesValidatePeriod := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhValidatePeriod(rulesValidatePeriod)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReservedClaims.validate_period: %s", err)
		panic(errMsg)
	}
	v.FldValidators["validate_period"] = vFn

	v.FldValidators["audience_validation.audience"] = AudiencesValidator().Validate

	return v
}()

func ReservedClaimsValidator() db.Validator {
	return DefaultReservedClaimsValidator
}

// augmented methods on protoc/std generated struct

func (m *ServerUrlRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServerUrlRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServerUrlRule) DeepCopy() *ServerUrlRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServerUrlRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServerUrlRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServerUrlRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServerUrlRuleValidator().Validate(ctx, m, opts...)
}

func (m *ServerUrlRule) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetClientMatcherDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetClientMatcherDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetRateLimiterChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetRateLimiterChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *ServerUrlRule) GetClientMatcherDRefInfo() ([]db.DRefInfo, error) {
	if m.GetClientMatcher() == nil {
		return nil, nil
	}

	drInfos, err := m.GetClientMatcher().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetClientMatcher().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "client_matcher." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ServerUrlRule) GetRateLimiterChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetRateLimiterChoice() == nil {
		return nil, nil
	}
	switch m.GetRateLimiterChoice().(type) {
	case *ServerUrlRule_InlineRateLimiter:

		drInfos, err := m.GetInlineRateLimiter().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetInlineRateLimiter().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "inline_rate_limiter." + dri.DRField
		}
		return drInfos, err

	case *ServerUrlRule_RefRateLimiter:

		vref := m.GetRefRateLimiter()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("rate_limiter.Object")
		dri := db.DRefInfo{
			RefdType:   "rate_limiter.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "ref_rate_limiter",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}

}

type ValidateServerUrlRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServerUrlRule) DomainChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServerUrlRule) DomainChoiceSpecificDomainValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_SpecificDomain, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for specific_domain")
	}
	return oValidatorFn_SpecificDomain, nil
}

func (v *ValidateServerUrlRule) RateLimiterChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for rate_limiter_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServerUrlRule) BasePathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for base_path")
	}

	return validatorFn, nil
}

func (v *ValidateServerUrlRule) ApiGroupValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for api_group")
	}

	return validatorFn, nil
}

func (v *ValidateServerUrlRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServerUrlRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServerUrlRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["api_group"]; exists {

		vOpts := append(opts, db.WithValidateField("api_group"))
		if err := fv(ctx, m.GetApiGroup(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["base_path"]; exists {

		vOpts := append(opts, db.WithValidateField("base_path"))
		if err := fv(ctx, m.GetBasePath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("client_matcher"))
		if err := fv(ctx, m.GetClientMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain_choice"]; exists {
		val := m.GetDomainChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainChoice().(type) {
	case *ServerUrlRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_choice.any_domain"]; exists {
			val := m.GetDomainChoice().(*ServerUrlRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServerUrlRule_SpecificDomain:
		if fv, exists := v.FldValidators["domain_choice.specific_domain"]; exists {
			val := m.GetDomainChoice().(*ServerUrlRule_SpecificDomain).SpecificDomain
			vOpts := append(opts,
				db.WithValidateField("domain_choice"),
				db.WithValidateField("specific_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rate_limiter_choice"]; exists {
		val := m.GetRateLimiterChoice()
		vOpts := append(opts,
			db.WithValidateField("rate_limiter_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRateLimiterChoice().(type) {
	case *ServerUrlRule_InlineRateLimiter:
		if fv, exists := v.FldValidators["rate_limiter_choice.inline_rate_limiter"]; exists {
			val := m.GetRateLimiterChoice().(*ServerUrlRule_InlineRateLimiter).InlineRateLimiter
			vOpts := append(opts,
				db.WithValidateField("rate_limiter_choice"),
				db.WithValidateField("inline_rate_limiter"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServerUrlRule_RefRateLimiter:
		if fv, exists := v.FldValidators["rate_limiter_choice.ref_rate_limiter"]; exists {
			val := m.GetRateLimiterChoice().(*ServerUrlRule_RefRateLimiter).RefRateLimiter
			vOpts := append(opts,
				db.WithValidateField("rate_limiter_choice"),
				db.WithValidateField("ref_rate_limiter"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["request_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("request_matcher"))
		if err := fv(ctx, m.GetRequestMatcher(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServerUrlRuleValidator = func() *ValidateServerUrlRule {
	v := &ValidateServerUrlRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainChoice := v.DomainChoiceValidationRuleHandler
	rulesDomainChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainChoice(rulesDomainChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServerUrlRule.domain_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_choice"] = vFn

	vrhDomainChoiceSpecificDomain := v.DomainChoiceSpecificDomainValidationRuleHandler
	rulesDomainChoiceSpecificDomain := map[string]string{
		"ves.io.schema.rules.string.max_len":   "128",
		"ves.io.schema.rules.string.vh_domain": "true",
	}
	vFnMap["domain_choice.specific_domain"], err = vrhDomainChoiceSpecificDomain(rulesDomainChoiceSpecificDomain)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServerUrlRule.domain_choice_specific_domain: %s", err)
		panic(errMsg)
	}

	v.FldValidators["domain_choice.specific_domain"] = vFnMap["domain_choice.specific_domain"]

	vrhRateLimiterChoice := v.RateLimiterChoiceValidationRuleHandler
	rulesRateLimiterChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhRateLimiterChoice(rulesRateLimiterChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServerUrlRule.rate_limiter_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rate_limiter_choice"] = vFn

	vrhBasePath := v.BasePathValidationRuleHandler
	rulesBasePath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.http_path": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFn, err = vrhBasePath(rulesBasePath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServerUrlRule.base_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["base_path"] = vFn

	vrhApiGroup := v.ApiGroupValidationRuleHandler
	rulesApiGroup := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhApiGroup(rulesApiGroup)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServerUrlRule.api_group: %s", err)
		panic(errMsg)
	}
	v.FldValidators["api_group"] = vFn

	v.FldValidators["rate_limiter_choice.inline_rate_limiter"] = InlineRateLimiterValidator().Validate
	v.FldValidators["rate_limiter_choice.ref_rate_limiter"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["client_matcher"] = ves_io_schema_policy.ClientMatcherValidator().Validate

	v.FldValidators["request_matcher"] = ves_io_schema_policy.RequestMatcherValidator().Validate

	return v
}()

func ServerUrlRuleValidator() db.Validator {
	return DefaultServerUrlRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *ServicePolicyList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServicePolicyList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServicePolicyList) DeepCopy() *ServicePolicyList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServicePolicyList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServicePolicyList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServicePolicyList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServicePolicyListValidator().Validate(ctx, m, opts...)
}

func (m *ServicePolicyList) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetPoliciesDRefInfo()

}

func (m *ServicePolicyList) GetPoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetPolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("ServicePolicyList.policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("service_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "service_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetPoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ServicePolicyList) GetPoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "service_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: service_policy")
	}
	for i, vref := range m.GetPolicies() {
		if vref == nil {
			return nil, fmt.Errorf("ServicePolicyList.policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "service_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateServicePolicyList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServicePolicyList) PoliciesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for policies")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for policies")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated policies")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items policies")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServicePolicyList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServicePolicyList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServicePolicyList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["policies"]; exists {
		vOpts := append(opts, db.WithValidateField("policies"))
		if err := fv(ctx, m.GetPolicies(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServicePolicyListValidator = func() *ValidateServicePolicyList {
	v := &ValidateServicePolicyList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPolicies := v.PoliciesValidationRuleHandler
	rulesPolicies := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhPolicies(rulesPolicies)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicePolicyList.policies: %s", err)
		panic(errMsg)
	}
	v.FldValidators["policies"] = vFn

	return v
}()

func ServicePolicyListValidator() db.Validator {
	return DefaultServicePolicyListValidator
}

// augmented methods on protoc/std generated struct

func (m *SimpleClientSrcRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SimpleClientSrcRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SimpleClientSrcRule) DeepCopy() *SimpleClientSrcRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SimpleClientSrcRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SimpleClientSrcRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SimpleClientSrcRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SimpleClientSrcRuleValidator().Validate(ctx, m, opts...)
}

type ValidateSimpleClientSrcRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSimpleClientSrcRule) ClientSourceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for client_source_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSimpleClientSrcRule) ClientSourceChoiceIpPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_IpPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_prefix")
	}
	return oValidatorFn_IpPrefix, nil
}
func (v *ValidateSimpleClientSrcRule) ClientSourceChoiceAsNumberValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_AsNumber, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for as_number")
	}
	return oValidatorFn_AsNumber, nil
}
func (v *ValidateSimpleClientSrcRule) ClientSourceChoiceUserIdentifierValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_UserIdentifier, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for user_identifier")
	}
	return oValidatorFn_UserIdentifier, nil
}
func (v *ValidateSimpleClientSrcRule) ClientSourceChoiceIpv6PrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Ipv6Prefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipv6_prefix")
	}
	return oValidatorFn_Ipv6Prefix, nil
}

func (v *ValidateSimpleClientSrcRule) ExpirationTimestampValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleClientSrcRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleClientSrcRule) ActionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ClientSrcRuleAction)
		return int32(i)
	}
	// ClientSrcRuleAction_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ClientSrcRuleAction_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for actions")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ClientSrcRuleAction, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for actions")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ClientSrcRuleAction)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ClientSrcRuleAction, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated actions")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items actions")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSimpleClientSrcRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SimpleClientSrcRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SimpleClientSrcRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetActionChoice().(type) {
	case *SimpleClientSrcRule_SkipProcessing:
		if fv, exists := v.FldValidators["action_choice.skip_processing"]; exists {
			val := m.GetActionChoice().(*SimpleClientSrcRule_SkipProcessing).SkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleClientSrcRule_WafSkipProcessing:
		if fv, exists := v.FldValidators["action_choice.waf_skip_processing"]; exists {
			val := m.GetActionChoice().(*SimpleClientSrcRule_WafSkipProcessing).WafSkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("waf_skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleClientSrcRule_BotSkipProcessing:
		if fv, exists := v.FldValidators["action_choice.bot_skip_processing"]; exists {
			val := m.GetActionChoice().(*SimpleClientSrcRule_BotSkipProcessing).BotSkipProcessing
			vOpts := append(opts,
				db.WithValidateField("action_choice"),
				db.WithValidateField("bot_skip_processing"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["actions"]; exists {
		vOpts := append(opts, db.WithValidateField("actions"))
		if err := fv(ctx, m.GetActions(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["client_source_choice"]; exists {
		val := m.GetClientSourceChoice()
		vOpts := append(opts,
			db.WithValidateField("client_source_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetClientSourceChoice().(type) {
	case *SimpleClientSrcRule_IpPrefix:
		if fv, exists := v.FldValidators["client_source_choice.ip_prefix"]; exists {
			val := m.GetClientSourceChoice().(*SimpleClientSrcRule_IpPrefix).IpPrefix
			vOpts := append(opts,
				db.WithValidateField("client_source_choice"),
				db.WithValidateField("ip_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleClientSrcRule_AsNumber:
		if fv, exists := v.FldValidators["client_source_choice.as_number"]; exists {
			val := m.GetClientSourceChoice().(*SimpleClientSrcRule_AsNumber).AsNumber
			vOpts := append(opts,
				db.WithValidateField("client_source_choice"),
				db.WithValidateField("as_number"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleClientSrcRule_HttpHeader:
		if fv, exists := v.FldValidators["client_source_choice.http_header"]; exists {
			val := m.GetClientSourceChoice().(*SimpleClientSrcRule_HttpHeader).HttpHeader
			vOpts := append(opts,
				db.WithValidateField("client_source_choice"),
				db.WithValidateField("http_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleClientSrcRule_UserIdentifier:
		if fv, exists := v.FldValidators["client_source_choice.user_identifier"]; exists {
			val := m.GetClientSourceChoice().(*SimpleClientSrcRule_UserIdentifier).UserIdentifier
			vOpts := append(opts,
				db.WithValidateField("client_source_choice"),
				db.WithValidateField("user_identifier"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SimpleClientSrcRule_Ipv6Prefix:
		if fv, exists := v.FldValidators["client_source_choice.ipv6_prefix"]; exists {
			val := m.GetClientSourceChoice().(*SimpleClientSrcRule_Ipv6Prefix).Ipv6Prefix
			vOpts := append(opts,
				db.WithValidateField("client_source_choice"),
				db.WithValidateField("ipv6_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["expiration_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("expiration_timestamp"))
		if err := fv(ctx, m.GetExpirationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSimpleClientSrcRuleValidator = func() *ValidateSimpleClientSrcRule {
	v := &ValidateSimpleClientSrcRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhClientSourceChoice := v.ClientSourceChoiceValidationRuleHandler
	rulesClientSourceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhClientSourceChoice(rulesClientSourceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleClientSrcRule.client_source_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["client_source_choice"] = vFn

	vrhClientSourceChoiceIpPrefix := v.ClientSourceChoiceIpPrefixValidationRuleHandler
	rulesClientSourceChoiceIpPrefix := map[string]string{
		"ves.io.schema.rules.string.ipv4_prefix": "true",
	}
	vFnMap["client_source_choice.ip_prefix"], err = vrhClientSourceChoiceIpPrefix(rulesClientSourceChoiceIpPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleClientSrcRule.client_source_choice_ip_prefix: %s", err)
		panic(errMsg)
	}
	vrhClientSourceChoiceAsNumber := v.ClientSourceChoiceAsNumberValidationRuleHandler
	rulesClientSourceChoiceAsNumber := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "401308",
	}
	vFnMap["client_source_choice.as_number"], err = vrhClientSourceChoiceAsNumber(rulesClientSourceChoiceAsNumber)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleClientSrcRule.client_source_choice_as_number: %s", err)
		panic(errMsg)
	}
	vrhClientSourceChoiceUserIdentifier := v.ClientSourceChoiceUserIdentifierValidationRuleHandler
	rulesClientSourceChoiceUserIdentifier := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFnMap["client_source_choice.user_identifier"], err = vrhClientSourceChoiceUserIdentifier(rulesClientSourceChoiceUserIdentifier)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleClientSrcRule.client_source_choice_user_identifier: %s", err)
		panic(errMsg)
	}
	vrhClientSourceChoiceIpv6Prefix := v.ClientSourceChoiceIpv6PrefixValidationRuleHandler
	rulesClientSourceChoiceIpv6Prefix := map[string]string{
		"ves.io.schema.rules.string.ipv6_prefix": "true",
	}
	vFnMap["client_source_choice.ipv6_prefix"], err = vrhClientSourceChoiceIpv6Prefix(rulesClientSourceChoiceIpv6Prefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field SimpleClientSrcRule.client_source_choice_ipv6_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["client_source_choice.ip_prefix"] = vFnMap["client_source_choice.ip_prefix"]
	v.FldValidators["client_source_choice.as_number"] = vFnMap["client_source_choice.as_number"]
	v.FldValidators["client_source_choice.user_identifier"] = vFnMap["client_source_choice.user_identifier"]
	v.FldValidators["client_source_choice.ipv6_prefix"] = vFnMap["client_source_choice.ipv6_prefix"]

	vrhExpirationTimestamp := v.ExpirationTimestampValidationRuleHandler
	rulesExpirationTimestamp := map[string]string{
		"ves.io.schema.rules.timestamp.within.seconds": "31536000",
	}
	vFn, err = vrhExpirationTimestamp(rulesExpirationTimestamp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleClientSrcRule.expiration_timestamp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["expiration_timestamp"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleClientSrcRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhActions := v.ActionsValidationRuleHandler
	rulesActions := map[string]string{
		"ves.io.schema.rules.enum.defined_only":  "true",
		"ves.io.schema.rules.repeated.max_items": "10",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhActions(rulesActions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleClientSrcRule.actions: %s", err)
		panic(errMsg)
	}
	v.FldValidators["actions"] = vFn

	v.FldValidators["client_source_choice.http_header"] = HttpHeaderMatcherListValidator().Validate

	return v
}()

func SimpleClientSrcRuleValidator() db.Validator {
	return DefaultSimpleClientSrcRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *SimpleLogin) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SimpleLogin) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *SimpleLogin) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetPassword().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting SimpleLogin.password")
	}

	return nil
}

func (m *SimpleLogin) DeepCopy() *SimpleLogin {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SimpleLogin{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SimpleLogin) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SimpleLogin) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SimpleLoginValidator().Validate(ctx, m, opts...)
}

type ValidateSimpleLogin struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSimpleLogin) UserValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for user")
	}

	return validatorFn, nil
}

func (v *ValidateSimpleLogin) PasswordValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn := ves_io_schema.SecretTypeValidator().Validate

	return validatorFn, nil
}

func (v *ValidateSimpleLogin) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SimpleLogin)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SimpleLogin got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["password"]; exists {

		vOpts := append(opts, db.WithValidateField("password"))
		if err := fv(ctx, m.GetPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user"]; exists {

		vOpts := append(opts, db.WithValidateField("user"))
		if err := fv(ctx, m.GetUser(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSimpleLoginValidator = func() *ValidateSimpleLogin {
	v := &ValidateSimpleLogin{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhUser := v.UserValidationRuleHandler
	rulesUser := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhUser(rulesUser)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleLogin.user: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user"] = vFn

	vrhPassword := v.PasswordValidationRuleHandler
	rulesPassword := map[string]string{
		"ves.io.schema.rules.string.max_len": "128",
	}
	vFn, err = vrhPassword(rulesPassword)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SimpleLogin.password: %s", err)
		panic(errMsg)
	}
	v.FldValidators["password"] = vFn

	return v
}()

func SimpleLoginValidator() db.Validator {
	return DefaultSimpleLoginValidator
}

// augmented methods on protoc/std generated struct

func (m *Target) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Target) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Target) DeepCopy() *Target {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Target{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Target) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Target) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TargetValidator().Validate(ctx, m, opts...)
}

type ValidateTarget struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTarget) TargetValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for target")
	}
	return validatorFn, nil
}

func (v *ValidateTarget) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Target)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Target got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["target"]; exists {
		val := m.GetTarget()
		vOpts := append(opts,
			db.WithValidateField("target"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTarget().(type) {
	case *Target_AllEndpoint:
		if fv, exists := v.FldValidators["target.all_endpoint"]; exists {
			val := m.GetTarget().(*Target_AllEndpoint).AllEndpoint
			vOpts := append(opts,
				db.WithValidateField("target"),
				db.WithValidateField("all_endpoint"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Target_ApiGroups:
		if fv, exists := v.FldValidators["target.api_groups"]; exists {
			val := m.GetTarget().(*Target_ApiGroups).ApiGroups
			vOpts := append(opts,
				db.WithValidateField("target"),
				db.WithValidateField("api_groups"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Target_BasePaths:
		if fv, exists := v.FldValidators["target.base_paths"]; exists {
			val := m.GetTarget().(*Target_BasePaths).BasePaths
			vOpts := append(opts,
				db.WithValidateField("target"),
				db.WithValidateField("base_paths"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTargetValidator = func() *ValidateTarget {
	v := &ValidateTarget{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTarget := v.TargetValidationRuleHandler
	rulesTarget := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTarget(rulesTarget)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Target.target: %s", err)
		panic(errMsg)
	}
	v.FldValidators["target"] = vFn

	v.FldValidators["target.api_groups"] = APIGroupsValidator().Validate
	v.FldValidators["target.base_paths"] = BasePathsTypeValidator().Validate

	return v
}()

func TargetValidator() db.Validator {
	return DefaultTargetValidator
}

// augmented methods on protoc/std generated struct

func (m *TokenLocation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TokenLocation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TokenLocation) DeepCopy() *TokenLocation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TokenLocation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TokenLocation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TokenLocation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TokenLocationValidator().Validate(ctx, m, opts...)
}

type ValidateTokenLocation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTokenLocation) TokenLocationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for token_location")
	}
	return validatorFn, nil
}

func (v *ValidateTokenLocation) TokenLocationCookieValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Cookie, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie")
	}
	return oValidatorFn_Cookie, nil
}
func (v *ValidateTokenLocation) TokenLocationHeaderValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Header, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header")
	}
	return oValidatorFn_Header, nil
}
func (v *ValidateTokenLocation) TokenLocationQueryParamValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_QueryParam, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for query_param")
	}
	return oValidatorFn_QueryParam, nil
}

func (v *ValidateTokenLocation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TokenLocation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TokenLocation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["token_location"]; exists {
		val := m.GetTokenLocation()
		vOpts := append(opts,
			db.WithValidateField("token_location"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTokenLocation().(type) {
	case *TokenLocation_BearerToken:
		if fv, exists := v.FldValidators["token_location.bearer_token"]; exists {
			val := m.GetTokenLocation().(*TokenLocation_BearerToken).BearerToken
			vOpts := append(opts,
				db.WithValidateField("token_location"),
				db.WithValidateField("bearer_token"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TokenLocation_Cookie:
		if fv, exists := v.FldValidators["token_location.cookie"]; exists {
			val := m.GetTokenLocation().(*TokenLocation_Cookie).Cookie
			vOpts := append(opts,
				db.WithValidateField("token_location"),
				db.WithValidateField("cookie"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TokenLocation_Header:
		if fv, exists := v.FldValidators["token_location.header"]; exists {
			val := m.GetTokenLocation().(*TokenLocation_Header).Header
			vOpts := append(opts,
				db.WithValidateField("token_location"),
				db.WithValidateField("header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TokenLocation_QueryParam:
		if fv, exists := v.FldValidators["token_location.query_param"]; exists {
			val := m.GetTokenLocation().(*TokenLocation_QueryParam).QueryParam
			vOpts := append(opts,
				db.WithValidateField("token_location"),
				db.WithValidateField("query_param"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTokenLocationValidator = func() *ValidateTokenLocation {
	v := &ValidateTokenLocation{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTokenLocation := v.TokenLocationValidationRuleHandler
	rulesTokenLocation := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTokenLocation(rulesTokenLocation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TokenLocation.token_location: %s", err)
		panic(errMsg)
	}
	v.FldValidators["token_location"] = vFn

	vrhTokenLocationCookie := v.TokenLocationCookieValidationRuleHandler
	rulesTokenLocationCookie := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFnMap["token_location.cookie"], err = vrhTokenLocationCookie(rulesTokenLocationCookie)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TokenLocation.token_location_cookie: %s", err)
		panic(errMsg)
	}
	vrhTokenLocationHeader := v.TokenLocationHeaderValidationRuleHandler
	rulesTokenLocationHeader := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFnMap["token_location.header"], err = vrhTokenLocationHeader(rulesTokenLocationHeader)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TokenLocation.token_location_header: %s", err)
		panic(errMsg)
	}
	vrhTokenLocationQueryParam := v.TokenLocationQueryParamValidationRuleHandler
	rulesTokenLocationQueryParam := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFnMap["token_location.query_param"], err = vrhTokenLocationQueryParam(rulesTokenLocationQueryParam)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TokenLocation.token_location_query_param: %s", err)
		panic(errMsg)
	}

	v.FldValidators["token_location.cookie"] = vFnMap["token_location.cookie"]
	v.FldValidators["token_location.header"] = vFnMap["token_location.header"]
	v.FldValidators["token_location.query_param"] = vFnMap["token_location.query_param"]

	return v
}()

func TokenLocationValidator() db.Validator {
	return DefaultTokenLocationValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidateApiBySpecRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidateApiBySpecRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidateApiBySpecRule) DeepCopy() *ValidateApiBySpecRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidateApiBySpecRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidateApiBySpecRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidateApiBySpecRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidateApiBySpecRuleValidator().Validate(ctx, m, opts...)
}

type ValidateValidateApiBySpecRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidateApiBySpecRule) OpenApiValidationRulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for open_api_validation_rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*OpenApiValidationRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := OpenApiValidationRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for open_api_validation_rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*OpenApiValidationRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*OpenApiValidationRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated open_api_validation_rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items open_api_validation_rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateValidateApiBySpecRule) FallThroughModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for fall_through_mode")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := OpenApiFallThroughModeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateValidateApiBySpecRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidateApiBySpecRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidateApiBySpecRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["fall_through_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("fall_through_mode"))
		if err := fv(ctx, m.GetFallThroughMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["open_api_validation_rules"]; exists {
		vOpts := append(opts, db.WithValidateField("open_api_validation_rules"))
		if err := fv(ctx, m.GetOpenApiValidationRules(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetOversizedBodyChoice().(type) {
	case *ValidateApiBySpecRule_OversizedBodySkipValidation:
		if fv, exists := v.FldValidators["oversized_body_choice.oversized_body_skip_validation"]; exists {
			val := m.GetOversizedBodyChoice().(*ValidateApiBySpecRule_OversizedBodySkipValidation).OversizedBodySkipValidation
			vOpts := append(opts,
				db.WithValidateField("oversized_body_choice"),
				db.WithValidateField("oversized_body_skip_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ValidateApiBySpecRule_OversizedBodyFailValidation:
		if fv, exists := v.FldValidators["oversized_body_choice.oversized_body_fail_validation"]; exists {
			val := m.GetOversizedBodyChoice().(*ValidateApiBySpecRule_OversizedBodyFailValidation).OversizedBodyFailValidation
			vOpts := append(opts,
				db.WithValidateField("oversized_body_choice"),
				db.WithValidateField("oversized_body_fail_validation"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["settings"]; exists {

		vOpts := append(opts, db.WithValidateField("settings"))
		if err := fv(ctx, m.GetSettings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidateApiBySpecRuleValidator = func() *ValidateValidateApiBySpecRule {
	v := &ValidateValidateApiBySpecRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhOpenApiValidationRules := v.OpenApiValidationRulesValidationRuleHandler
	rulesOpenApiValidationRules := map[string]string{
		"ves.io.schema.rules.message.required":              "true",
		"ves.io.schema.rules.repeated.max_items":            "15",
		"ves.io.schema.rules.repeated.unique_metadata_name": "true",
	}
	vFn, err = vrhOpenApiValidationRules(rulesOpenApiValidationRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ValidateApiBySpecRule.open_api_validation_rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["open_api_validation_rules"] = vFn

	vrhFallThroughMode := v.FallThroughModeValidationRuleHandler
	rulesFallThroughMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhFallThroughMode(rulesFallThroughMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ValidateApiBySpecRule.fall_through_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fall_through_mode"] = vFn

	v.FldValidators["settings"] = OpenApiValidationCommonSettingsValidator().Validate

	return v
}()

func ValidateApiBySpecRuleValidator() db.Validator {
	return DefaultValidateApiBySpecRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidationPropertySetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidationPropertySetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidationPropertySetting) DeepCopy() *ValidationPropertySetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidationPropertySetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidationPropertySetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidationPropertySetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidationPropertySettingValidator().Validate(ctx, m, opts...)
}

type ValidateValidationPropertySetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidationPropertySetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidationPropertySetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidationPropertySetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["headers"]; exists {

		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["queryParameters"]; exists {

		vOpts := append(opts, db.WithValidateField("queryParameters"))
		if err := fv(ctx, m.GetQueryParameters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidationPropertySettingValidator = func() *ValidateValidationPropertySetting {
	v := &ValidateValidationPropertySetting{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["queryParameters"] = ValidationSettingForQueryParametersValidator().Validate

	v.FldValidators["headers"] = ValidationSettingForHeadersValidator().Validate

	return v
}()

func ValidationPropertySettingValidator() db.Validator {
	return DefaultValidationPropertySettingValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidationSettingForHeaders) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidationSettingForHeaders) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidationSettingForHeaders) DeepCopy() *ValidationSettingForHeaders {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidationSettingForHeaders{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidationSettingForHeaders) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidationSettingForHeaders) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidationSettingForHeadersValidator().Validate(ctx, m, opts...)
}

type ValidateValidationSettingForHeaders struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidationSettingForHeaders) AdditionalHeadersChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for additional_headers_choice")
	}
	return validatorFn, nil
}

func (v *ValidateValidationSettingForHeaders) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidationSettingForHeaders)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidationSettingForHeaders got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["additional_headers_choice"]; exists {
		val := m.GetAdditionalHeadersChoice()
		vOpts := append(opts,
			db.WithValidateField("additional_headers_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdditionalHeadersChoice().(type) {
	case *ValidationSettingForHeaders_AllowAdditionalHeaders:
		if fv, exists := v.FldValidators["additional_headers_choice.allow_additional_headers"]; exists {
			val := m.GetAdditionalHeadersChoice().(*ValidationSettingForHeaders_AllowAdditionalHeaders).AllowAdditionalHeaders
			vOpts := append(opts,
				db.WithValidateField("additional_headers_choice"),
				db.WithValidateField("allow_additional_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ValidationSettingForHeaders_DisallowAdditionalHeaders:
		if fv, exists := v.FldValidators["additional_headers_choice.disallow_additional_headers"]; exists {
			val := m.GetAdditionalHeadersChoice().(*ValidationSettingForHeaders_DisallowAdditionalHeaders).DisallowAdditionalHeaders
			vOpts := append(opts,
				db.WithValidateField("additional_headers_choice"),
				db.WithValidateField("disallow_additional_headers"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidationSettingForHeadersValidator = func() *ValidateValidationSettingForHeaders {
	v := &ValidateValidationSettingForHeaders{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdditionalHeadersChoice := v.AdditionalHeadersChoiceValidationRuleHandler
	rulesAdditionalHeadersChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdditionalHeadersChoice(rulesAdditionalHeadersChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ValidationSettingForHeaders.additional_headers_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["additional_headers_choice"] = vFn

	return v
}()

func ValidationSettingForHeadersValidator() db.Validator {
	return DefaultValidationSettingForHeadersValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidationSettingForQueryParameters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidationSettingForQueryParameters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidationSettingForQueryParameters) DeepCopy() *ValidationSettingForQueryParameters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidationSettingForQueryParameters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidationSettingForQueryParameters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidationSettingForQueryParameters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidationSettingForQueryParametersValidator().Validate(ctx, m, opts...)
}

type ValidateValidationSettingForQueryParameters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidationSettingForQueryParameters) AdditionalParametersChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for additional_parameters_choice")
	}
	return validatorFn, nil
}

func (v *ValidateValidationSettingForQueryParameters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidationSettingForQueryParameters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidationSettingForQueryParameters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["additional_parameters_choice"]; exists {
		val := m.GetAdditionalParametersChoice()
		vOpts := append(opts,
			db.WithValidateField("additional_parameters_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAdditionalParametersChoice().(type) {
	case *ValidationSettingForQueryParameters_AllowAdditionalParameters:
		if fv, exists := v.FldValidators["additional_parameters_choice.allow_additional_parameters"]; exists {
			val := m.GetAdditionalParametersChoice().(*ValidationSettingForQueryParameters_AllowAdditionalParameters).AllowAdditionalParameters
			vOpts := append(opts,
				db.WithValidateField("additional_parameters_choice"),
				db.WithValidateField("allow_additional_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ValidationSettingForQueryParameters_DisallowAdditionalParameters:
		if fv, exists := v.FldValidators["additional_parameters_choice.disallow_additional_parameters"]; exists {
			val := m.GetAdditionalParametersChoice().(*ValidationSettingForQueryParameters_DisallowAdditionalParameters).DisallowAdditionalParameters
			vOpts := append(opts,
				db.WithValidateField("additional_parameters_choice"),
				db.WithValidateField("disallow_additional_parameters"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidationSettingForQueryParametersValidator = func() *ValidateValidationSettingForQueryParameters {
	v := &ValidateValidationSettingForQueryParameters{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAdditionalParametersChoice := v.AdditionalParametersChoiceValidationRuleHandler
	rulesAdditionalParametersChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAdditionalParametersChoice(rulesAdditionalParametersChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ValidationSettingForQueryParameters.additional_parameters_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["additional_parameters_choice"] = vFn

	return v
}()

func ValidationSettingForQueryParametersValidator() db.Validator {
	return DefaultValidationSettingForQueryParametersValidator
}

// augmented methods on protoc/std generated struct

func (m *WafExclusion) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafExclusion) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafExclusion) DeepCopy() *WafExclusion {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafExclusion{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafExclusion) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafExclusion) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafExclusionValidator().Validate(ctx, m, opts...)
}

func (m *WafExclusion) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetWafExclusionChoiceDRefInfo()

}

func (m *WafExclusion) GetWafExclusionChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetWafExclusionChoice().(type) {
	case *WafExclusion_WafExclusionInlineRules:

		return nil, nil

	case *WafExclusion_WafExclusionPolicy:

		vref := m.GetWafExclusionPolicy()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("waf_exclusion_policy.Object")
		dri := db.DRefInfo{
			RefdType:   "waf_exclusion_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "waf_exclusion_policy",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetWafExclusionChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *WafExclusion) GetWafExclusionChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetWafExclusionChoice().(type) {
	case *WafExclusion_WafExclusionInlineRules:

	case *WafExclusion_WafExclusionPolicy:
		refdType, err := d.TypeForEntryKind("", "", "waf_exclusion_policy.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: waf_exclusion_policy")
		}

		vref := m.GetWafExclusionPolicy()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "waf_exclusion_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateWafExclusion struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafExclusion) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafExclusion)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafExclusion got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetWafExclusionChoice().(type) {
	case *WafExclusion_WafExclusionInlineRules:
		if fv, exists := v.FldValidators["waf_exclusion_choice.waf_exclusion_inline_rules"]; exists {
			val := m.GetWafExclusionChoice().(*WafExclusion_WafExclusionInlineRules).WafExclusionInlineRules
			vOpts := append(opts,
				db.WithValidateField("waf_exclusion_choice"),
				db.WithValidateField("waf_exclusion_inline_rules"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *WafExclusion_WafExclusionPolicy:
		if fv, exists := v.FldValidators["waf_exclusion_choice.waf_exclusion_policy"]; exists {
			val := m.GetWafExclusionChoice().(*WafExclusion_WafExclusionPolicy).WafExclusionPolicy
			vOpts := append(opts,
				db.WithValidateField("waf_exclusion_choice"),
				db.WithValidateField("waf_exclusion_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafExclusionValidator = func() *ValidateWafExclusion {
	v := &ValidateWafExclusion{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["waf_exclusion_choice.waf_exclusion_inline_rules"] = WafExclusionInlineRulesValidator().Validate
	v.FldValidators["waf_exclusion_choice.waf_exclusion_policy"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func WafExclusionValidator() db.Validator {
	return DefaultWafExclusionValidator
}

// augmented methods on protoc/std generated struct

func (m *WafExclusionInlineRules) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WafExclusionInlineRules) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WafExclusionInlineRules) DeepCopy() *WafExclusionInlineRules {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WafExclusionInlineRules{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WafExclusionInlineRules) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WafExclusionInlineRules) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WafExclusionInlineRulesValidator().Validate(ctx, m, opts...)
}

type ValidateWafExclusionInlineRules struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWafExclusionInlineRules) RulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_policy.SimpleWafExclusionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_policy.SimpleWafExclusionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_policy.SimpleWafExclusionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_policy.SimpleWafExclusionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWafExclusionInlineRules) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WafExclusionInlineRules)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WafExclusionInlineRules got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["rules"]; exists {
		vOpts := append(opts, db.WithValidateField("rules"))
		if err := fv(ctx, m.GetRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWafExclusionInlineRulesValidator = func() *ValidateWafExclusionInlineRules {
	v := &ValidateWafExclusionInlineRules{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRules := v.RulesValidationRuleHandler
	rulesRules := map[string]string{
		"ves.io.schema.rules.repeated.max_items":            "256",
		"ves.io.schema.rules.repeated.unique_metadata_name": "true",
	}
	vFn, err = vrhRules(rulesRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WafExclusionInlineRules.rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rules"] = vFn

	return v
}()

func WafExclusionInlineRulesValidator() db.Validator {
	return DefaultWafExclusionInlineRulesValidator
}
