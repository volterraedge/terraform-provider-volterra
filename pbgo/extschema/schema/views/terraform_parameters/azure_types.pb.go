// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/terraform_parameters/azure_types.proto

package terraform_parameters

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	certified_hardware "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/certified_hardware"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Azure Terraform Instance Parameters
//
// x-displayName: "Azure Terraform Instance Parameters"
// Shape of the view terraform parameters specification
type AzureInstanceType struct {
	// Volterra Node Id
	//
	// x-displayName: "Volterra Node ID"
	// Volterra Node ID will be used to refer to this node in other TF parameters
	VoltNodeId string `protobuf:"bytes,1,opt,name=volt_node_id,json=voltNodeId,proto3" json:"volt_node_id,omitempty"`
	// Volterra Vnet id
	//
	// x-displayName: "Volterra Vnet id"
	// Vnet in which Cloud Instance is launched
	VoltVnetId string `protobuf:"bytes,3,opt,name=volt_vnet_id,json=voltVnetId,proto3" json:"volt_vnet_id,omitempty"`
	// Public Subnet
	//
	// x-displayName: "Public Subnet"
	// Public subnet will be used as site local network
	PublicSubnetId string `protobuf:"bytes,4,opt,name=public_subnet_id,json=publicSubnetId,proto3" json:"public_subnet_id,omitempty"`
	// Private Subnet
	//
	// x-displayName: "Private Subnet"
	// Private subnet will be used as site inside network, when node type has two interfaces.
	PrivateSubnetId string `protobuf:"bytes,5,opt,name=private_subnet_id,json=privateSubnetId,proto3" json:"private_subnet_id,omitempty"`
	// Cloud Instance Type
	//
	// x-displayName: "Cloud Instance Type"
	// Cloud instance type like small, medium, large etc
	MachineType string `protobuf:"bytes,6,opt,name=machine_type,json=machineType,proto3" json:"machine_type,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// Disk size to be used for this instance
	DiskSize string `protobuf:"bytes,7,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// Azure Image Parameters
	//
	// x-displayName: " Azure Image Parameters"
	// Azure Image parameters
	Marketplace *certified_hardware.Marketplace `protobuf:"bytes,9,opt,name=marketplace,proto3" json:"marketplace,omitempty"`
	// Cloud Instance AZ
	//
	// x-displayName: "Cloud Instance Az"
	// Cloud Instance AZ in which to create this instance
	Az string `protobuf:"bytes,10,opt,name=az,proto3" json:"az,omitempty"`
	// Volterra Node count
	//
	// x-displayName: "Volterra Node count"
	// Desired number of node count used for worker node scaling
	NodeCount int32 `protobuf:"varint,11,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
}

func (m *AzureInstanceType) Reset()      { *m = AzureInstanceType{} }
func (*AzureInstanceType) ProtoMessage() {}
func (*AzureInstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{0}
}
func (m *AzureInstanceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureInstanceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureInstanceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureInstanceType.Merge(m, src)
}
func (m *AzureInstanceType) XXX_Size() int {
	return m.Size()
}
func (m *AzureInstanceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureInstanceType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureInstanceType proto.InternalMessageInfo

func (m *AzureInstanceType) GetVoltNodeId() string {
	if m != nil {
		return m.VoltNodeId
	}
	return ""
}

func (m *AzureInstanceType) GetVoltVnetId() string {
	if m != nil {
		return m.VoltVnetId
	}
	return ""
}

func (m *AzureInstanceType) GetPublicSubnetId() string {
	if m != nil {
		return m.PublicSubnetId
	}
	return ""
}

func (m *AzureInstanceType) GetPrivateSubnetId() string {
	if m != nil {
		return m.PrivateSubnetId
	}
	return ""
}

func (m *AzureInstanceType) GetMachineType() string {
	if m != nil {
		return m.MachineType
	}
	return ""
}

func (m *AzureInstanceType) GetDiskSize() string {
	if m != nil {
		return m.DiskSize
	}
	return ""
}

func (m *AzureInstanceType) GetMarketplace() *certified_hardware.Marketplace {
	if m != nil {
		return m.Marketplace
	}
	return nil
}

func (m *AzureInstanceType) GetAz() string {
	if m != nil {
		return m.Az
	}
	return ""
}

func (m *AzureInstanceType) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

// Azure Subnet Param
//
// x-displayName: "New Cloud Subnet Parameters"
// Parameters for creating new AWS subnet
type AzureSubnetParamType struct {
	// Azure Resource Group
	//
	// x-displayName: "Resource Group"
	// Resource Group for this subnet
	ResourceGroup string `protobuf:"bytes,1,opt,name=resource_group,json=resourceGroup,proto3" json:"resource_group,omitempty"`
	// IPv4 Subnet
	//
	// x-displayName: "IPv4 Subnet"
	// x-example: "10.1.2.0/24"
	// IPv4 subnet prefix for this subnet
	Ipv4 string `protobuf:"bytes,2,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	// IPv6 Subnet
	//
	// x-displayName: "IPv6 Subnet"
	// x-example: "1234:568:abcd:9100::/64"
	// IPv6 subnet prefix for this subnet
	Ipv6 string `protobuf:"bytes,3,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
}

func (m *AzureSubnetParamType) Reset()      { *m = AzureSubnetParamType{} }
func (*AzureSubnetParamType) ProtoMessage() {}
func (*AzureSubnetParamType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{1}
}
func (m *AzureSubnetParamType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetParamType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetParamType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetParamType.Merge(m, src)
}
func (m *AzureSubnetParamType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetParamType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetParamType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetParamType proto.InternalMessageInfo

func (m *AzureSubnetParamType) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *AzureSubnetParamType) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

func (m *AzureSubnetParamType) GetIpv6() string {
	if m != nil {
		return m.Ipv6
	}
	return ""
}

// Azure Existing Subnet Type
//
// x-displayName: "Azure Existing Subnet Parameters"
// Parameters for existing subnet
type AzureExistingSubnetParamType struct {
	// Existing Subnet Name
	//
	// x-displayName: "Subnet Name"
	// Name of existing subnet.
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
	// subnet_resource_grp
	//
	// x-displayName: "Resource Group Name"
	// Specify name of Resource Group
	SubnetResourceGrp string `protobuf:"bytes,2,opt,name=subnet_resource_grp,json=subnetResourceGrp,proto3" json:"subnet_resource_grp,omitempty"`
}

func (m *AzureExistingSubnetParamType) Reset()      { *m = AzureExistingSubnetParamType{} }
func (*AzureExistingSubnetParamType) ProtoMessage() {}
func (*AzureExistingSubnetParamType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{2}
}
func (m *AzureExistingSubnetParamType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureExistingSubnetParamType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureExistingSubnetParamType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureExistingSubnetParamType.Merge(m, src)
}
func (m *AzureExistingSubnetParamType) XXX_Size() int {
	return m.Size()
}
func (m *AzureExistingSubnetParamType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureExistingSubnetParamType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureExistingSubnetParamType proto.InternalMessageInfo

func (m *AzureExistingSubnetParamType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

func (m *AzureExistingSubnetParamType) GetSubnetResourceGrp() string {
	if m != nil {
		return m.SubnetResourceGrp
	}
	return ""
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetChoice struct {
	// New Subnet
	//
	// x-displayName: "New Subnet"
	// Parameters for creating new subnet
	SubnetParam *AzureSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam,proto3" json:"subnet_param,omitempty"`
	// Existing Subnet Name
	//
	// x-displayName: "Existing Subnet Name"
	// Information about existing subnet
	ExistingSubnet *AzureExistingSubnetParamType `protobuf:"bytes,3,opt,name=existing_subnet,json=existingSubnet,proto3" json:"existing_subnet,omitempty"`
}

func (m *AzureSubnetChoice) Reset()      { *m = AzureSubnetChoice{} }
func (*AzureSubnetChoice) ProtoMessage() {}
func (*AzureSubnetChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{3}
}
func (m *AzureSubnetChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetChoice.Merge(m, src)
}
func (m *AzureSubnetChoice) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetChoice.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetChoice proto.InternalMessageInfo

func (m *AzureSubnetChoice) GetSubnetParam() *AzureSubnetParamType {
	if m != nil {
		return m.SubnetParam
	}
	return nil
}

func (m *AzureSubnetChoice) GetExistingSubnet() *AzureExistingSubnetParamType {
	if m != nil {
		return m.ExistingSubnet
	}
	return nil
}

// Terraform subnets Parameters
//
// x-displayName: "Terraform Subnet Parameters"
// Specifies subnet to be used or created in the cloud
type AzureSubnetType struct {
	// Volterra Subnet Id
	//
	// x-displayName: "Volterra Subnet ID"
	// Volterra subnet ID will be used to refer to this subnet in other TF parameters
	VoltSubnetId string `protobuf:"bytes,1,opt,name=volt_subnet_id,json=voltSubnetId,proto3" json:"volt_subnet_id,omitempty"`
	// Volterra Vnet id
	//
	// x-displayName: "Volterra Vnet id"
	// Vnet in which Cloud Instance is launched
	VoltVnetId string `protobuf:"bytes,2,opt,name=volt_vnet_id,json=voltVnetId,proto3" json:"volt_vnet_id,omitempty"`
	// Subnet Parameters
	//
	// x-displayName: "Subnet Parameters"
	// Subnet parameters for existing subnet or new subnet
	Subnet *AzureSubnetChoice `protobuf:"bytes,4,opt,name=subnet,proto3" json:"subnet,omitempty"`
	// Interface Type
	//
	// x-displayName: "Interface Type"
	// Interface Type
	InterfaceType InterfaceType `protobuf:"varint,5,opt,name=interface_type,json=interfaceType,proto3,enum=ves.io.schema.views.terraform_parameters.InterfaceType" json:"interface_type,omitempty"`
}

func (m *AzureSubnetType) Reset()      { *m = AzureSubnetType{} }
func (*AzureSubnetType) ProtoMessage() {}
func (*AzureSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{4}
}
func (m *AzureSubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetType.Merge(m, src)
}
func (m *AzureSubnetType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetType proto.InternalMessageInfo

func (m *AzureSubnetType) GetVoltSubnetId() string {
	if m != nil {
		return m.VoltSubnetId
	}
	return ""
}

func (m *AzureSubnetType) GetVoltVnetId() string {
	if m != nil {
		return m.VoltVnetId
	}
	return ""
}

func (m *AzureSubnetType) GetSubnet() *AzureSubnetChoice {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *AzureSubnetType) GetInterfaceType() InterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return INTERFACE_INSIDE
}

// Azure Vnet Parameters
//
// x-displayName: "AWS VPC Parameters"
// Parameters to create new AWS VPC
type AzureVnetParamsType struct {
	// Azure Resource Group
	//
	// x-displayName: "Resource Group"
	// Resource Group for this Vnet
	ResourceGroup string `protobuf:"bytes,1,opt,name=resource_group,json=resourceGroup,proto3" json:"resource_group,omitempty"`
	// Azure Vnet Name
	//
	// x-displayName: "Azure Vnet Name"
	// x-example: "MyVnet"
	// Name for your Azure Vnet
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// IPv4 CIDR block
	//
	// x-displayName: "IPv4 CIDR block"
	// x-example: "10.1.2.3.0/24"
	// IPv4 CIDR block for this Vnet. It has to private address space.
	PrimaryIpv4 string `protobuf:"bytes,3,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
}

func (m *AzureVnetParamsType) Reset()      { *m = AzureVnetParamsType{} }
func (*AzureVnetParamsType) ProtoMessage() {}
func (*AzureVnetParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{5}
}
func (m *AzureVnetParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetParamsType.Merge(m, src)
}
func (m *AzureVnetParamsType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetParamsType proto.InternalMessageInfo

func (m *AzureVnetParamsType) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *AzureVnetParamsType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AzureVnetParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

// Azure Vnet Information
//
// x-displayName: "Azure Vnet Information"
// This defines Azure Vnet for a view
type AzureVnetInfoType struct {
	// New Vnet
	//
	// x-displayName: "New Vnet Parameters"
	// Parameters for creating new Vnet
	NewVnet *views.AzureVnetParamsType `protobuf:"bytes,1,opt,name=new_vnet,json=newVnet,proto3" json:"new_vnet,omitempty"`
	// Existing Vnet
	//
	// x-displayName: "Existing Vnet"
	// Information about existing Vnet
	Vnet *views.AzureVnetType `protobuf:"bytes,2,opt,name=vnet,proto3" json:"vnet,omitempty"`
}

func (m *AzureVnetInfoType) Reset()      { *m = AzureVnetInfoType{} }
func (*AzureVnetInfoType) ProtoMessage() {}
func (*AzureVnetInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{6}
}
func (m *AzureVnetInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetInfoType.Merge(m, src)
}
func (m *AzureVnetInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetInfoType proto.InternalMessageInfo

func (m *AzureVnetInfoType) GetNewVnet() *views.AzureVnetParamsType {
	if m != nil {
		return m.NewVnet
	}
	return nil
}

func (m *AzureVnetInfoType) GetVnet() *views.AzureVnetType {
	if m != nil {
		return m.Vnet
	}
	return nil
}

// Azure Availability Sets Information
//
// x-displayName: "Availability Sets Information"
// Provides information related to availability sets
type AvailabilitySetsInfoType struct {
	// Enable Availability Sets
	//
	// x-displayName: "Enable Availability Sets"
	// Flag to enable/disable availability sets
	Enable string `protobuf:"bytes,1,opt,name=enable,proto3" json:"enable,omitempty"`
	// Number of fault domains
	//
	// x-displayName: "Number of fault domains"
	// x-example: "1"
	// Namuber of fault domains to be used while creating the availability set
	FaultDomains uint32 `protobuf:"varint,4,opt,name=fault_domains,json=faultDomains,proto3" json:"fault_domains,omitempty"`
	// Number of update domains
	//
	// x-displayName: "Number of update domains"
	// x-example: "1"
	// Namuber of update domains to be used while creating the availability set
	UpdateDomains uint32 `protobuf:"varint,5,opt,name=update_domains,json=updateDomains,proto3" json:"update_domains,omitempty"`
}

func (m *AvailabilitySetsInfoType) Reset()      { *m = AvailabilitySetsInfoType{} }
func (*AvailabilitySetsInfoType) ProtoMessage() {}
func (*AvailabilitySetsInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{7}
}
func (m *AvailabilitySetsInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AvailabilitySetsInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AvailabilitySetsInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvailabilitySetsInfoType.Merge(m, src)
}
func (m *AvailabilitySetsInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AvailabilitySetsInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AvailabilitySetsInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AvailabilitySetsInfoType proto.InternalMessageInfo

func (m *AvailabilitySetsInfoType) GetEnable() string {
	if m != nil {
		return m.Enable
	}
	return ""
}

func (m *AvailabilitySetsInfoType) GetFaultDomains() uint32 {
	if m != nil {
		return m.FaultDomains
	}
	return 0
}

func (m *AvailabilitySetsInfoType) GetUpdateDomains() uint32 {
	if m != nil {
		return m.UpdateDomains
	}
	return 0
}

// Azure Spoke Vnet Information
//
// x-displayName: "Azure Spoke Vnet Information"
// Azure Spoke Vnet related information, these vnets info will be use to establish vnet peering
// between volterra site vnet and spoke vnets
type SpokeVnetsInfoType struct {
	// Name of Vnet Resource Group
	//
	// x-displayName: "Name of Vnet Resource Group"
	// Azure resource group in which vnet exists
	VnetResourceGroup string `protobuf:"bytes,1,opt,name=vnet_resource_group,json=vnetResourceGroup,proto3" json:"vnet_resource_group,omitempty"`
	// Name of Vnet
	//
	// x-displayName: "Name of Vnet"
	// Azure Virtual Network Name
	VnetName string `protobuf:"bytes,2,opt,name=vnet_name,json=vnetName,proto3" json:"vnet_name,omitempty"`
	// Auto Routing
	//
	// x-displayName: "Auto Routing"
	// setup routing for all existing subnets on spoke vnet
	AutoRouting bool `protobuf:"varint,3,opt,name=auto_routing,json=autoRouting,proto3" json:"auto_routing,omitempty"`
}

func (m *SpokeVnetsInfoType) Reset()      { *m = SpokeVnetsInfoType{} }
func (*SpokeVnetsInfoType) ProtoMessage() {}
func (*SpokeVnetsInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{8}
}
func (m *SpokeVnetsInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpokeVnetsInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpokeVnetsInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpokeVnetsInfoType.Merge(m, src)
}
func (m *SpokeVnetsInfoType) XXX_Size() int {
	return m.Size()
}
func (m *SpokeVnetsInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_SpokeVnetsInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_SpokeVnetsInfoType proto.InternalMessageInfo

func (m *SpokeVnetsInfoType) GetVnetResourceGroup() string {
	if m != nil {
		return m.VnetResourceGroup
	}
	return ""
}

func (m *SpokeVnetsInfoType) GetVnetName() string {
	if m != nil {
		return m.VnetName
	}
	return ""
}

func (m *SpokeVnetsInfoType) GetAutoRouting() bool {
	if m != nil {
		return m.AutoRouting
	}
	return false
}

// Terraform Azure Vnet Site Parameters
//
// x-displayName: "Terraform Object Parameters"
// Terraform parameters to create site in Azure.
type AzureVnetSiteType struct {
	// Site Name
	//
	// x-displayName: "Site Name"
	// Name of the site object to be created
	SiteName string `protobuf:"bytes,1,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
	// Azure Unique Name
	//
	// x-displayName: "Azure Unique Name"
	// Azure unique name which will be used to create the cloud resource objects on azure"
	AzureName string `protobuf:"bytes,15,opt,name=azure_name,json=azureName,proto3" json:"azure_name,omitempty"`
	// Volterra Vnet Id
	//
	// x-displayName: "Volterra Vnet ID"
	// Volterra vnet ID will be used to refer to this vnet in other TF parameters
	VoltVnetId string `protobuf:"bytes,2,opt,name=volt_vnet_id,json=voltVnetId,proto3" json:"volt_vnet_id,omitempty"`
	// Certified Hardware
	//
	// x-displayName: "Certified Hardware"
	// Certified Hardware to be used to create this site.
	CertifiedHw string `protobuf:"bytes,4,opt,name=certified_hw,json=certifiedHw,proto3" json:"certified_hw,omitempty"`
	// Azure Region
	//
	// x-displayName: "Azure Region"
	// Azure region
	AzureRegion string `protobuf:"bytes,5,opt,name=azure_region,json=azureRegion,proto3" json:"azure_region,omitempty"`
	// Azure Resource Group
	//
	// x-displayName: "Azure Resource Group"
	// Azure resource group
	AzureResourceGrp string `protobuf:"bytes,6,opt,name=azure_resource_grp,json=azureResourceGrp,proto3" json:"azure_resource_grp,omitempty"`
	// Vnet
	//
	// x-displayName: "Vnet"
	// Vnet parameters to instantiate this site
	Vnet *AzureVnetInfoType `protobuf:"bytes,7,opt,name=vnet,proto3" json:"vnet,omitempty"`
	// List of Subnets
	//
	// x-displayName: "List of Subnets"
	// List of Subnets that TF script needs
	Subnets []*AzureSubnetType `protobuf:"bytes,8,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// List of Master Nodes
	//
	// x-displayName: "List of Master Nodes"
	// List of Master Nodes in this Site that TF script needs to instantiate
	MasterNodes []*AzureInstanceType `protobuf:"bytes,9,rep,name=master_nodes,json=masterNodes,proto3" json:"master_nodes,omitempty"`
	// List of Inside VIP Port Config
	//
	// x-displayName: "List of Inside VIP Port Config"
	// List of Ports which will be used to create cloud loadbalancer listener
	InsideVipPortConfig []*VIPPortConfig `protobuf:"bytes,16,rep,name=inside_vip_port_config,json=insideVipPortConfig,proto3" json:"inside_vip_port_config,omitempty"`
	// List of Outside VIP Port Config
	//
	// x-displayName: "List of Outside VIP Port Config"
	// List of Ports which will be used to create cloud loadbalancer listener
	OutsideVipPortConfig []*VIPPortConfig `protobuf:"bytes,17,rep,name=outside_vip_port_config,json=outsideVipPortConfig,proto3" json:"outside_vip_port_config,omitempty"`
	// Worker Node Scaling
	//
	// x-displayName: "Worker Node Scaling"
	// Number of Maximum Worker Nodes for Auto Scale Configuration
	WorkerNodes uint32 `protobuf:"varint,14,opt,name=worker_nodes,json=workerNodes,proto3" json:"worker_nodes,omitempty"`
	// Gateway Type
	//
	// x-displayName: "Gateway Type"
	// Gateway Type
	GatewayType CloudGatewayType `protobuf:"varint,11,opt,name=gateway_type,json=gatewayType,proto3,enum=ves.io.schema.views.terraform_parameters.CloudGatewayType" json:"gateway_type,omitempty"`
	// Public SSH key
	//
	// x-displayName: "Public SSH key"
	// Public SSH key for accessing the site.
	SshKey string `protobuf:"bytes,13,opt,name=ssh_key,json=sshKey,proto3" json:"ssh_key,omitempty"`
	// Azure Availability Sets Information
	//
	// x-displayName: "Availability Sets Information"
	// Provides information related to availability sets
	AvailabilitySet *AvailabilitySetsInfoType `protobuf:"bytes,18,opt,name=availability_set,json=availabilitySet,proto3" json:"availability_set,omitempty"`
	// Azure Tags
	//
	// x-displayName: "Azure Tags"
	// Azure Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources.
	Tags map[string]string `protobuf:"bytes,19,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Enable Multi Node in AZ
	//
	// x-displayName: "Enable Multi Node in AZ"
	// Flag is enabled when multiple nodes are configured in single or two Availability Zones
	MultiNodeNonStdAz bool `protobuf:"varint,20,opt,name=multi_node_non_std_az,json=multiNodeNonStdAz,proto3" json:"multi_node_non_std_az,omitempty"`
	// Spoke Vnets Information
	//
	// x-displayName: "Spoke Vnets Information"
	// Spoke Vnet related information, these vnets will be peered with volterra site vnet
	SpokeVnets []*SpokeVnetsInfoType `protobuf:"bytes,21,rep,name=spoke_vnets,json=spokeVnets,proto3" json:"spoke_vnets,omitempty"`
	// ExpressRoute Information
	//
	// x-displayName: "ExpressRoute Information"
	// Information related ExpressRoute like subnets, authorization key, vgw sku's.
	ExpressRoute *AzureExpressRouteType `protobuf:"bytes,22,opt,name=express_route,json=expressRoute,proto3" json:"express_route,omitempty"`
}

func (m *AzureVnetSiteType) Reset()      { *m = AzureVnetSiteType{} }
func (*AzureVnetSiteType) ProtoMessage() {}
func (*AzureVnetSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{9}
}
func (m *AzureVnetSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetSiteType.Merge(m, src)
}
func (m *AzureVnetSiteType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetSiteType proto.InternalMessageInfo

func (m *AzureVnetSiteType) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

func (m *AzureVnetSiteType) GetAzureName() string {
	if m != nil {
		return m.AzureName
	}
	return ""
}

func (m *AzureVnetSiteType) GetVoltVnetId() string {
	if m != nil {
		return m.VoltVnetId
	}
	return ""
}

func (m *AzureVnetSiteType) GetCertifiedHw() string {
	if m != nil {
		return m.CertifiedHw
	}
	return ""
}

func (m *AzureVnetSiteType) GetAzureRegion() string {
	if m != nil {
		return m.AzureRegion
	}
	return ""
}

func (m *AzureVnetSiteType) GetAzureResourceGrp() string {
	if m != nil {
		return m.AzureResourceGrp
	}
	return ""
}

func (m *AzureVnetSiteType) GetVnet() *AzureVnetInfoType {
	if m != nil {
		return m.Vnet
	}
	return nil
}

func (m *AzureVnetSiteType) GetSubnets() []*AzureSubnetType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *AzureVnetSiteType) GetMasterNodes() []*AzureInstanceType {
	if m != nil {
		return m.MasterNodes
	}
	return nil
}

func (m *AzureVnetSiteType) GetInsideVipPortConfig() []*VIPPortConfig {
	if m != nil {
		return m.InsideVipPortConfig
	}
	return nil
}

func (m *AzureVnetSiteType) GetOutsideVipPortConfig() []*VIPPortConfig {
	if m != nil {
		return m.OutsideVipPortConfig
	}
	return nil
}

func (m *AzureVnetSiteType) GetWorkerNodes() uint32 {
	if m != nil {
		return m.WorkerNodes
	}
	return 0
}

func (m *AzureVnetSiteType) GetGatewayType() CloudGatewayType {
	if m != nil {
		return m.GatewayType
	}
	return INGRESS_GATEWAY
}

func (m *AzureVnetSiteType) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func (m *AzureVnetSiteType) GetAvailabilitySet() *AvailabilitySetsInfoType {
	if m != nil {
		return m.AvailabilitySet
	}
	return nil
}

func (m *AzureVnetSiteType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AzureVnetSiteType) GetMultiNodeNonStdAz() bool {
	if m != nil {
		return m.MultiNodeNonStdAz
	}
	return false
}

func (m *AzureVnetSiteType) GetSpokeVnets() []*SpokeVnetsInfoType {
	if m != nil {
		return m.SpokeVnets
	}
	return nil
}

func (m *AzureVnetSiteType) GetExpressRoute() *AzureExpressRouteType {
	if m != nil {
		return m.ExpressRoute
	}
	return nil
}

type ExpressRouteCircuitInfo struct {
	// Express Route Circuit Resource Group
	//
	// x-displayName: "Resource Group"
	// Name of the Resource group in which ExpressRoute Circuit Exists
	ExpressRouteCircuitResourceGroup string `protobuf:"bytes,1,opt,name=express_route_circuit_resource_group,json=expressRouteCircuitResourceGroup,proto3" json:"express_route_circuit_resource_group,omitempty"`
	// Express Route Circuit Name
	//
	// x-displayName: "Circuit Name"
	// Name of the ExpressRoute Circuit
	ExpressRouteCircuitName string `protobuf:"bytes,2,opt,name=express_route_circuit_name,json=expressRouteCircuitName,proto3" json:"express_route_circuit_name,omitempty"`
	// Subscription ID
	//
	// x-displayName: "Subscription ID"
	// Subscription ID in which ExpressRoute Circuit exists. Would be different if it's different than hub vnet.
	ExpressRouteCircuitId string `protobuf:"bytes,3,opt,name=express_route_circuit_id,json=expressRouteCircuitId,proto3" json:"express_route_circuit_id,omitempty"`
	// Authorization Key
	//
	// x-displayName: "ExpressRoute Authorization Key"
	// Authorization Key of ExpressRoute Circuit to establish connection with virtual network gateway.
	AuthorizationKey string `protobuf:"bytes,4,opt,name=authorization_key,json=authorizationKey,proto3" json:"authorization_key,omitempty"`
	// Connection Name
	//
	// x-displayName: "Connection Name"
	// Name of the connection from ExpressRoute Circuit to Virtual Network Gateway.
	ConnectionName string `protobuf:"bytes,5,opt,name=connection_name,json=connectionName,proto3" json:"connection_name,omitempty"`
	// ExpressRoute Authorization Key
	//
	// x-displayName: "ExpressRoute Authorization Key"
	// Authorization Key of ExpressRoute Circuit in clear secret format to establish connection with virtual network gateway.
	// This field will only be set when user configures the key in clear secret format ( To be decoded in terraform )
	AuthorizationKeyClearB64 string `protobuf:"bytes,6,opt,name=authorization_key_clear_b64,json=authorizationKeyClearB64,proto3" json:"authorization_key_clear_b64,omitempty"`
	// ExpressRoute Authorization Key
	//
	// x-displayName: "ExpressRoute Authorization Key"
	// Blindfolded Authorization Key of ExpressRoute Circuit to establish connection with virtual network gateway.
	// This field will only be set when user configures the key as blindfolded secret ( To be decrypted in tfctl )
	AuthorizationKeyBlindfolded string `protobuf:"bytes,7,opt,name=authorization_key_blindfolded,json=authorizationKeyBlindfolded,proto3" json:"authorization_key_blindfolded,omitempty"`
	// Express Route Routing Weight
	//
	// x-displayName: "Express Route Routing Weight"
	// Weight for Propogated Routes.
	RoutingWeight string `protobuf:"bytes,8,opt,name=routing_weight,json=routingWeight,proto3" json:"routing_weight,omitempty"`
}

func (m *ExpressRouteCircuitInfo) Reset()      { *m = ExpressRouteCircuitInfo{} }
func (*ExpressRouteCircuitInfo) ProtoMessage() {}
func (*ExpressRouteCircuitInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{10}
}
func (m *ExpressRouteCircuitInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpressRouteCircuitInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExpressRouteCircuitInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpressRouteCircuitInfo.Merge(m, src)
}
func (m *ExpressRouteCircuitInfo) XXX_Size() int {
	return m.Size()
}
func (m *ExpressRouteCircuitInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpressRouteCircuitInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ExpressRouteCircuitInfo proto.InternalMessageInfo

func (m *ExpressRouteCircuitInfo) GetExpressRouteCircuitResourceGroup() string {
	if m != nil {
		return m.ExpressRouteCircuitResourceGroup
	}
	return ""
}

func (m *ExpressRouteCircuitInfo) GetExpressRouteCircuitName() string {
	if m != nil {
		return m.ExpressRouteCircuitName
	}
	return ""
}

func (m *ExpressRouteCircuitInfo) GetExpressRouteCircuitId() string {
	if m != nil {
		return m.ExpressRouteCircuitId
	}
	return ""
}

func (m *ExpressRouteCircuitInfo) GetAuthorizationKey() string {
	if m != nil {
		return m.AuthorizationKey
	}
	return ""
}

func (m *ExpressRouteCircuitInfo) GetConnectionName() string {
	if m != nil {
		return m.ConnectionName
	}
	return ""
}

func (m *ExpressRouteCircuitInfo) GetAuthorizationKeyClearB64() string {
	if m != nil {
		return m.AuthorizationKeyClearB64
	}
	return ""
}

func (m *ExpressRouteCircuitInfo) GetAuthorizationKeyBlindfolded() string {
	if m != nil {
		return m.AuthorizationKeyBlindfolded
	}
	return ""
}

func (m *ExpressRouteCircuitInfo) GetRoutingWeight() string {
	if m != nil {
		return m.RoutingWeight
	}
	return ""
}

type AzureExpressRouteType struct {
	// Virtual Network Gateway Subnet Prefix
	//
	// x-displayName: "Virtual Network Gateway Subnet Prefix"
	// Subnet Prefix Required to provision virtual network gateway
	NewGatewaySubnet *AzureSubnetParamType `protobuf:"bytes,1,opt,name=new_gateway_subnet,json=newGatewaySubnet,proto3" json:"new_gateway_subnet,omitempty"`
	// Route Server Prefix
	//
	// x-displayName: "Route Server Subnet Prefix"
	// Subnet Prefix Required to provision route server
	NewRouteServerSubnet *AzureSubnetParamType `protobuf:"bytes,2,opt,name=new_route_server_subnet,json=newRouteServerSubnet,proto3" json:"new_route_server_subnet,omitempty"`
	// Existing Virtual Network Gateway Subnet Prefix
	//
	// x-displayName: "Virtual Network Gateway Subnet Prefix"
	// Subnet Prefix Required to provision virtual network gateway
	ExistingGatewaySubnet *AzureExistingSubnetParamType `protobuf:"bytes,3,opt,name=existing_gateway_subnet,json=existingGatewaySubnet,proto3" json:"existing_gateway_subnet,omitempty"`
	// Existing Route Server Prefix
	//
	// x-displayName: "Route Server Subnet Prefix"
	// Subnet Prefix Required to provision route server
	ExistingRouteServerSubnet *AzureExistingSubnetParamType `protobuf:"bytes,4,opt,name=existing_route_server_subnet,json=existingRouteServerSubnet,proto3" json:"existing_route_server_subnet,omitempty"`
	// Express Route Circuit Information
	//
	// x-displayName: "Express Route Circuit Information"
	// Express Route Circuit Information like Circuit Resource Group, Circuit Name, Authorization Key, Circuit ID
	ExpressRouteCircuitInfo []*ExpressRouteCircuitInfo `protobuf:"bytes,5,rep,name=express_route_circuit_info,json=expressRouteCircuitInfo,proto3" json:"express_route_circuit_info,omitempty"`
	// Virtual Network Gateway SKU
	//
	// x-displayName: "Virtual Network Gateway SKU"
	// Virtual Network Gateway SKU for Gateway Performance.
	VirtualNetworkGatewaySku string `protobuf:"bytes,6,opt,name=virtual_network_gateway_sku,json=virtualNetworkGatewaySku,proto3" json:"virtual_network_gateway_sku,omitempty"`
	// Enable Azure Express Route
	//
	// x-displayName: "Enable Azure Express Route"
	// Flag is enabled when express route needs to be configured
	ExpressRouteEnable bool `protobuf:"varint,7,opt,name=express_route_enable,json=expressRouteEnable,proto3" json:"express_route_enable,omitempty"`
	// F5XC Site ASN
	//
	// x-displayName: "F5XC Site ASN"
	// x-example: "64500"
	// F5XC Site ASN
	SiteAsn uint32 `protobuf:"varint,8,opt,name=site_asn,json=siteAsn,proto3" json:"site_asn,omitempty"`
}

func (m *AzureExpressRouteType) Reset()      { *m = AzureExpressRouteType{} }
func (*AzureExpressRouteType) ProtoMessage() {}
func (*AzureExpressRouteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfa180cd722a5ccd, []int{11}
}
func (m *AzureExpressRouteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureExpressRouteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureExpressRouteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureExpressRouteType.Merge(m, src)
}
func (m *AzureExpressRouteType) XXX_Size() int {
	return m.Size()
}
func (m *AzureExpressRouteType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureExpressRouteType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureExpressRouteType proto.InternalMessageInfo

func (m *AzureExpressRouteType) GetNewGatewaySubnet() *AzureSubnetParamType {
	if m != nil {
		return m.NewGatewaySubnet
	}
	return nil
}

func (m *AzureExpressRouteType) GetNewRouteServerSubnet() *AzureSubnetParamType {
	if m != nil {
		return m.NewRouteServerSubnet
	}
	return nil
}

func (m *AzureExpressRouteType) GetExistingGatewaySubnet() *AzureExistingSubnetParamType {
	if m != nil {
		return m.ExistingGatewaySubnet
	}
	return nil
}

func (m *AzureExpressRouteType) GetExistingRouteServerSubnet() *AzureExistingSubnetParamType {
	if m != nil {
		return m.ExistingRouteServerSubnet
	}
	return nil
}

func (m *AzureExpressRouteType) GetExpressRouteCircuitInfo() []*ExpressRouteCircuitInfo {
	if m != nil {
		return m.ExpressRouteCircuitInfo
	}
	return nil
}

func (m *AzureExpressRouteType) GetVirtualNetworkGatewaySku() string {
	if m != nil {
		return m.VirtualNetworkGatewaySku
	}
	return ""
}

func (m *AzureExpressRouteType) GetExpressRouteEnable() bool {
	if m != nil {
		return m.ExpressRouteEnable
	}
	return false
}

func (m *AzureExpressRouteType) GetSiteAsn() uint32 {
	if m != nil {
		return m.SiteAsn
	}
	return 0
}

func init() {
	proto.RegisterType((*AzureInstanceType)(nil), "ves.io.schema.views.terraform_parameters.AzureInstanceType")
	golang_proto.RegisterType((*AzureInstanceType)(nil), "ves.io.schema.views.terraform_parameters.AzureInstanceType")
	proto.RegisterType((*AzureSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetParamType")
	golang_proto.RegisterType((*AzureSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetParamType")
	proto.RegisterType((*AzureExistingSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.AzureExistingSubnetParamType")
	golang_proto.RegisterType((*AzureExistingSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.AzureExistingSubnetParamType")
	proto.RegisterType((*AzureSubnetChoice)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetChoice")
	golang_proto.RegisterType((*AzureSubnetChoice)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetChoice")
	proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetType")
	golang_proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.terraform_parameters.AzureSubnetType")
	proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetParamsType")
	golang_proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetParamsType")
	proto.RegisterType((*AzureVnetInfoType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetInfoType")
	golang_proto.RegisterType((*AzureVnetInfoType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetInfoType")
	proto.RegisterType((*AvailabilitySetsInfoType)(nil), "ves.io.schema.views.terraform_parameters.AvailabilitySetsInfoType")
	golang_proto.RegisterType((*AvailabilitySetsInfoType)(nil), "ves.io.schema.views.terraform_parameters.AvailabilitySetsInfoType")
	proto.RegisterType((*SpokeVnetsInfoType)(nil), "ves.io.schema.views.terraform_parameters.SpokeVnetsInfoType")
	golang_proto.RegisterType((*SpokeVnetsInfoType)(nil), "ves.io.schema.views.terraform_parameters.SpokeVnetsInfoType")
	proto.RegisterType((*AzureVnetSiteType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetSiteType")
	golang_proto.RegisterType((*AzureVnetSiteType)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetSiteType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetSiteType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.AzureVnetSiteType.TagsEntry")
	proto.RegisterType((*ExpressRouteCircuitInfo)(nil), "ves.io.schema.views.terraform_parameters.ExpressRouteCircuitInfo")
	golang_proto.RegisterType((*ExpressRouteCircuitInfo)(nil), "ves.io.schema.views.terraform_parameters.ExpressRouteCircuitInfo")
	proto.RegisterType((*AzureExpressRouteType)(nil), "ves.io.schema.views.terraform_parameters.AzureExpressRouteType")
	golang_proto.RegisterType((*AzureExpressRouteType)(nil), "ves.io.schema.views.terraform_parameters.AzureExpressRouteType")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/terraform_parameters/azure_types.proto", fileDescriptor_cfa180cd722a5ccd)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/terraform_parameters/azure_types.proto", fileDescriptor_cfa180cd722a5ccd)
}

var fileDescriptor_cfa180cd722a5ccd = []byte{
	// 1886 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x73, 0x1b, 0x49,
	0x15, 0xf7, 0x48, 0xb2, 0x2d, 0x3d, 0x7d, 0x58, 0xee, 0xd8, 0xeb, 0x59, 0x3b, 0xd1, 0x3a, 0xaa,
	0x50, 0xb8, 0x42, 0x22, 0x07, 0xe3, 0x72, 0xd8, 0x2c, 0x0b, 0x58, 0x26, 0x2c, 0x36, 0x45, 0x36,
	0x35, 0xde, 0x0a, 0xb5, 0x54, 0x6d, 0xa6, 0x5a, 0x9a, 0x96, 0xdc, 0x65, 0x69, 0x7a, 0x6a, 0xa6,
	0x47, 0x8a, 0x7d, 0xa0, 0xf6, 0xc6, 0x91, 0x3d, 0x70, 0x84, 0x03, 0x37, 0xfe, 0x06, 0x96, 0xc3,
	0x1e, 0x39, 0xe6, 0x98, 0xe2, 0x44, 0x9c, 0x0b, 0x50, 0x45, 0x55, 0x8e, 0xcb, 0x69, 0xa9, 0x7e,
	0xdd, 0x92, 0x46, 0xb6, 0x4c, 0x6c, 0x93, 0xdb, 0xcc, 0x7b, 0xbf, 0xf7, 0xd1, 0xaf, 0xdf, 0xfb,
	0x75, 0xcf, 0xc0, 0x83, 0x1e, 0x8b, 0x6a, 0x5c, 0xac, 0x47, 0xcd, 0x03, 0xd6, 0xa5, 0xeb, 0x3d,
	0xce, 0xfa, 0xd1, 0xba, 0x64, 0x61, 0x48, 0x5b, 0x22, 0xec, 0xba, 0x01, 0x0d, 0x69, 0x97, 0x49,
	0x16, 0x46, 0xeb, 0xf4, 0x38, 0x0e, 0x99, 0x2b, 0x8f, 0x02, 0x16, 0xd5, 0x82, 0x50, 0x48, 0x41,
	0xd6, 0xb4, 0x6d, 0x4d, 0xdb, 0xd6, 0xd0, 0xb6, 0x36, 0xc9, 0x76, 0xf9, 0x6e, 0x9b, 0xcb, 0x83,
	0xb8, 0x51, 0x6b, 0x8a, 0xee, 0x7a, 0x5b, 0xb4, 0xc5, 0x3a, 0x3a, 0x68, 0xc4, 0x2d, 0x7c, 0xc3,
	0x17, 0x7c, 0xd2, 0x8e, 0x97, 0xdf, 0x6d, 0x0b, 0xd1, 0xee, 0xb0, 0x11, 0x8a, 0xfa, 0x47, 0x46,
	0x75, 0x67, 0x3c, 0xdf, 0x26, 0x0b, 0x25, 0x6f, 0x71, 0xe6, 0xb9, 0x07, 0x34, 0xf4, 0xfa, 0x34,
	0x64, 0xeb, 0x89, 0x0c, 0x97, 0x57, 0xc6, 0xd1, 0x22, 0x90, 0x5c, 0xf8, 0x03, 0xe5, 0xbb, 0xe3,
	0xca, 0xa4, 0xdd, 0xf5, 0x53, 0x55, 0xa1, 0x1d, 0xee, 0x51, 0xc9, 0x8c, 0x76, 0xf5, 0x6c, 0xcd,
	0xdc, 0x71, 0xd7, 0xb7, 0x26, 0x55, 0x35, 0xe2, 0x72, 0xac, 0x7e, 0xcb, 0x9b, 0x17, 0xae, 0x7d,
	0xd2, 0xea, 0xbd, 0x89, 0x56, 0x23, 0x40, 0xf5, 0x3f, 0x29, 0x98, 0xdf, 0x56, 0x9b, 0xb5, 0xeb,
	0x47, 0x92, 0xfa, 0x4d, 0xf6, 0xc9, 0x51, 0xc0, 0xc8, 0x2a, 0x14, 0x7a, 0xa2, 0x23, 0x5d, 0x5f,
	0x78, 0xcc, 0xe5, 0x9e, 0x6d, 0xad, 0x5a, 0x6b, 0x39, 0x07, 0x94, 0xec, 0x91, 0xf0, 0xd8, 0xae,
	0x37, 0x44, 0xf4, 0x7c, 0x26, 0x15, 0x22, 0x3d, 0x42, 0x3c, 0xf1, 0x99, 0xdc, 0xf5, 0xc8, 0x1a,
	0x94, 0x83, 0xb8, 0xd1, 0xe1, 0x4d, 0x37, 0x8a, 0x1b, 0x06, 0x95, 0x41, 0x54, 0x49, 0xcb, 0xf7,
	0x51, 0xbc, 0xeb, 0x91, 0xdb, 0x30, 0x1f, 0x84, 0xbc, 0x47, 0x25, 0x4b, 0x40, 0xa7, 0x11, 0x3a,
	0x67, 0x14, 0x43, 0xec, 0x4d, 0x28, 0x74, 0x69, 0xf3, 0x80, 0xfb, 0xba, 0x3a, 0xf6, 0x0c, 0xc2,
	0xf2, 0x46, 0x86, 0xc9, 0xaf, 0x40, 0xce, 0xe3, 0xd1, 0xa1, 0x1b, 0xf1, 0x63, 0x66, 0xcf, 0xa2,
	0x3e, 0xab, 0x04, 0xfb, 0xfc, 0x98, 0x91, 0x8f, 0x21, 0xdf, 0xa5, 0xe1, 0x21, 0x93, 0x41, 0x87,
	0x36, 0x99, 0x9d, 0x5b, 0xb5, 0xd6, 0xf2, 0x1b, 0x77, 0x6b, 0xe3, 0xcd, 0x79, 0xb6, 0x51, 0x6a,
	0xbf, 0x18, 0x19, 0x39, 0x49, 0x0f, 0xa4, 0x04, 0x29, 0x7a, 0x6c, 0x03, 0x86, 0x49, 0xd1, 0x63,
	0x72, 0x03, 0x00, 0xab, 0xd6, 0x14, 0xb1, 0x2f, 0xed, 0xfc, 0xaa, 0xb5, 0x36, 0xed, 0xe4, 0x94,
	0x64, 0x47, 0x09, 0xf6, 0x32, 0xd9, 0x54, 0x39, 0xbd, 0x97, 0xc9, 0x66, 0xcb, 0xb9, 0xea, 0x17,
	0x16, 0x2c, 0x60, 0xed, 0xf5, 0xea, 0x1e, 0xab, 0x2d, 0xc4, 0x15, 0xdc, 0x83, 0x52, 0xc8, 0x22,
	0x11, 0x87, 0x4d, 0xe6, 0xb6, 0x43, 0x11, 0x07, 0x7a, 0x03, 0xea, 0xb9, 0x3f, 0xff, 0xf3, 0xab,
	0x74, 0x26, 0x4c, 0xd9, 0x3f, 0x76, 0x8a, 0x03, 0xc0, 0x47, 0x4a, 0x4f, 0xaa, 0x90, 0xe1, 0x41,
	0x6f, 0xd3, 0x4e, 0x21, 0xae, 0xf4, 0xf5, 0x97, 0xd6, 0x94, 0xc2, 0x4e, 0x87, 0xe9, 0xaf, 0x2d,
	0xcb, 0x41, 0x9d, 0xc1, 0x6c, 0xe9, 0xad, 0x1a, 0xc3, 0x7c, 0x9e, 0xd2, 0x98, 0xad, 0xaa, 0x80,
	0xeb, 0x98, 0xd1, 0xc3, 0x67, 0x3c, 0x92, 0xdc, 0x6f, 0x9f, 0xce, 0xec, 0x3d, 0xc8, 0x9b, 0x2d,
	0xf2, 0x69, 0x97, 0x0d, 0xfa, 0x42, 0x8b, 0x1e, 0xd1, 0x2e, 0x23, 0x35, 0xb8, 0x66, 0x00, 0x89,
	0x15, 0x04, 0x3a, 0x2f, 0x67, 0x5e, 0xab, 0x9c, 0x61, 0xea, 0x41, 0xf5, 0xdf, 0x96, 0xe9, 0x3f,
	0x1d, 0x69, 0xe7, 0x40, 0xf0, 0x26, 0x23, 0x14, 0x0a, 0xc6, 0x0b, 0xf6, 0x35, 0xc6, 0xc9, 0x6f,
	0xfc, 0xb0, 0x76, 0x51, 0x0e, 0xa9, 0x4d, 0x2a, 0xab, 0x63, 0x52, 0x47, 0x01, 0x11, 0x30, 0xc7,
	0xcc, 0x22, 0x4d, 0xd7, 0x61, 0x61, 0xf2, 0x1b, 0x3f, 0xbd, 0x64, 0x94, 0x73, 0x4a, 0xe5, 0x94,
	0xd8, 0x98, 0x42, 0xef, 0x7c, 0xf5, 0x77, 0x29, 0x98, 0x4b, 0x24, 0x87, 0x45, 0xbd, 0x05, 0x25,
	0x9c, 0xa5, 0x51, 0xf3, 0xeb, 0xba, 0xe2, 0x84, 0x0d, 0x3b, 0xff, 0xf4, 0xc4, 0xa5, 0xce, 0x4c,
	0xdc, 0x3e, 0xcc, 0x98, 0x95, 0x64, 0x70, 0x25, 0x1f, 0x5c, 0xa9, 0x5e, 0x7a, 0x0b, 0x1c, 0xe3,
	0x8a, 0x3c, 0x85, 0x12, 0xf7, 0x25, 0x0b, 0x5b, 0xb4, 0x69, 0x46, 0x4e, 0x4d, 0x66, 0x69, 0xe3,
	0xfe, 0xc5, 0x9d, 0xef, 0x0e, 0xec, 0xb1, 0x2e, 0x45, 0x9e, 0x7c, 0xdd, 0xcb, 0x64, 0xd3, 0xe5,
	0x4c, 0xf5, 0x0f, 0x16, 0x5c, 0xc3, 0x1c, 0x9e, 0x0c, 0x6a, 0x18, 0x5d, 0x71, 0x12, 0x6e, 0x42,
	0x06, 0x5b, 0x53, 0x4f, 0x42, 0x71, 0xd0, 0xe5, 0x1a, 0x8b, 0x2a, 0xf2, 0x5d, 0x28, 0x04, 0x21,
	0xef, 0xd2, 0xf0, 0xc8, 0xc5, 0xa1, 0x49, 0x4f, 0x1c, 0x9a, 0xbc, 0xc1, 0xec, 0x06, 0xbd, 0x4d,
	0x35, 0xaa, 0xf3, 0xc3, 0xfc, 0x76, 0xfd, 0x96, 0xc0, 0xec, 0x76, 0x20, 0xeb, 0xb3, 0x3e, 0xee,
	0x88, 0x69, 0xd1, 0xb5, 0x89, 0x55, 0x99, 0xb0, 0x32, 0x67, 0xd6, 0x67, 0x7d, 0x25, 0x22, 0x5b,
	0x90, 0x41, 0x07, 0x29, 0x74, 0x50, 0xfd, 0xdf, 0x0e, 0xd0, 0x14, 0xf1, 0xd5, 0xbf, 0x58, 0x60,
	0x6f, 0xf7, 0x28, 0xef, 0xd0, 0x06, 0xef, 0x70, 0x79, 0xb4, 0xcf, 0x64, 0x34, 0xcc, 0xec, 0x0e,
	0xcc, 0x30, 0x9f, 0x36, 0x3a, 0x66, 0x44, 0xeb, 0x0b, 0x6a, 0x61, 0x73, 0x61, 0xd1, 0xc9, 0xc8,
	0x30, 0x66, 0xce, 0x74, 0x8b, 0x76, 0x22, 0xe6, 0x18, 0x0c, 0xb9, 0x0f, 0xc5, 0x16, 0x8d, 0x3b,
	0xd2, 0xf5, 0x44, 0x97, 0x72, 0x3f, 0xc2, 0xfe, 0x29, 0xd6, 0x09, 0x16, 0xee, 0x76, 0x6a, 0xcd,
	0x32, 0x0f, 0x76, 0xda, 0x29, 0x20, 0xf0, 0x27, 0x1a, 0x47, 0xde, 0x87, 0x52, 0x1c, 0xa8, 0xc3,
	0x6e, 0x68, 0x39, 0x7d, 0x8e, 0xe5, 0x82, 0x53, 0xd4, 0x48, 0x63, 0x5a, 0xfd, 0xad, 0x05, 0x64,
	0x3f, 0x10, 0x87, 0xb8, 0xac, 0x51, 0xe2, 0x35, 0xb8, 0xd6, 0x3b, 0xc5, 0x1e, 0xc3, 0x5d, 0x77,
	0xe6, 0x7b, 0x63, 0xec, 0xa1, 0xb6, 0x7b, 0x05, 0x72, 0xbd, 0x21, 0x1d, 0xe9, 0x91, 0xc8, 0xf6,
	0x06, 0x64, 0x74, 0x07, 0x0a, 0x34, 0x96, 0xc2, 0x0d, 0x45, 0xac, 0x06, 0x11, 0x37, 0x3a, 0x5b,
	0xcf, 0xfd, 0xed, 0x4b, 0xcb, 0x14, 0x20, 0xaf, 0xd4, 0x8e, 0xd6, 0x56, 0x5f, 0x43, 0x62, 0x8f,
	0xf7, 0xb9, 0x1c, 0x9e, 0x26, 0x78, 0x16, 0x27, 0xf8, 0x2e, 0xab, 0x04, 0x18, 0xe0, 0x06, 0x80,
	0xbe, 0xe9, 0xa0, 0x76, 0x0e, 0xb5, 0x39, 0x94, 0xa0, 0xfa, 0xcd, 0x23, 0x7b, 0x13, 0x0a, 0x89,
	0xc3, 0xa6, 0x6f, 0x0e, 0xc8, 0xfc, 0x50, 0xf6, 0xb3, 0xbe, 0x82, 0xe8, 0x18, 0x21, 0x6b, 0x73,
	0xe1, 0x9b, 0x83, 0x31, 0x8f, 0x32, 0x07, 0x45, 0xe4, 0x0e, 0x90, 0x01, 0x24, 0xc1, 0xb9, 0xfa,
	0x68, 0x2c, 0x1b, 0xe0, 0x90, 0x72, 0xc9, 0xc7, 0xa6, 0xe1, 0x66, 0xaf, 0x44, 0x12, 0xc9, 0x01,
	0xd0, 0x9d, 0x48, 0xf6, 0x61, 0x56, 0x93, 0x45, 0x64, 0x67, 0x57, 0xd3, 0x6b, 0xf9, 0x8d, 0xf7,
	0xaf, 0x44, 0x3c, 0x7a, 0x2c, 0x8c, 0x27, 0xf2, 0x54, 0x1d, 0xf4, 0x91, 0x64, 0x21, 0x5e, 0x42,
	0x22, 0x3b, 0x87, 0x9e, 0x2f, 0x9b, 0x6d, 0xf2, 0x56, 0xa3, 0xce, 0x6d, 0xe5, 0x50, 0xdd, 0x60,
	0x22, 0xd2, 0x81, 0x77, 0xb8, 0x1f, 0x71, 0x8f, 0xb9, 0x3d, 0x1e, 0xb8, 0x81, 0x08, 0xa5, 0xdb,
	0x14, 0x7e, 0x8b, 0xb7, 0xed, 0x32, 0x46, 0xba, 0x04, 0xbf, 0x3d, 0xd9, 0x7d, 0xfc, 0x58, 0x84,
	0x72, 0x07, 0xcd, 0x9d, 0x6b, 0xda, 0xed, 0x13, 0x1e, 0x8c, 0x84, 0xc4, 0x87, 0x25, 0x11, 0xcb,
	0x89, 0xe1, 0xe6, 0xff, 0xbf, 0x70, 0x0b, 0xc6, 0xef, 0x78, 0xbc, 0x9b, 0x50, 0xe8, 0x8b, 0xf0,
	0x70, 0x58, 0xbd, 0x92, 0x1a, 0x4b, 0x27, 0xaf, 0x65, 0xba, 0x00, 0x9f, 0x41, 0xa1, 0x4d, 0x25,
	0xeb, 0xd3, 0x23, 0x4d, 0xeb, 0x79, 0xa4, 0xf5, 0x07, 0x17, 0xcf, 0x63, 0xa7, 0x23, 0x62, 0xef,
	0x23, 0xed, 0x42, 0xd7, 0xb7, 0x3d, 0x7a, 0x21, 0x4b, 0x30, 0x1b, 0x45, 0x07, 0xee, 0x21, 0x3b,
	0xb2, 0x8b, 0xd8, 0x88, 0x33, 0x51, 0x74, 0xf0, 0x73, 0x76, 0x44, 0xba, 0x50, 0xa6, 0x09, 0xda,
	0x72, 0x23, 0x26, 0x6d, 0x82, 0xad, 0x58, 0xbf, 0xc4, 0xe6, 0x9e, 0x43, 0x7c, 0xce, 0x1c, 0x1d,
	0xd7, 0x90, 0x4f, 0x21, 0x23, 0x69, 0x3b, 0xb2, 0xaf, 0x61, 0x99, 0x1f, 0x5e, 0xa1, 0xdb, 0x07,
	0x54, 0x50, 0xfb, 0x84, 0xb6, 0xa3, 0x87, 0xbe, 0x0c, 0x8f, 0x1c, 0x74, 0x49, 0xee, 0xc1, 0x62,
	0x37, 0xee, 0x48, 0xae, 0xaf, 0xc9, 0xbe, 0xf0, 0xdd, 0x48, 0x7a, 0x2e, 0x3d, 0xb6, 0x17, 0x14,
	0xcf, 0x38, 0xf3, 0xa8, 0x54, 0xc5, 0x7e, 0x24, 0xfc, 0x7d, 0xe9, 0x6d, 0x1f, 0x93, 0xcf, 0x20,
	0x1f, 0x29, 0xce, 0x43, 0x46, 0x88, 0xec, 0x45, 0xcc, 0xe9, 0x07, 0x17, 0xcf, 0xe9, 0x2c, 0x61,
	0x3a, 0x10, 0x0d, 0x65, 0xc4, 0x83, 0x22, 0x7b, 0x16, 0x84, 0x2c, 0x8a, 0x90, 0xf2, 0x98, 0xfd,
	0x0e, 0xd6, 0xf5, 0x47, 0x97, 0xbe, 0xd1, 0xa0, 0x0f, 0xc5, 0x8b, 0x7a, 0x70, 0x0a, 0x2c, 0x21,
	0x59, 0xbe, 0x0f, 0xb9, 0x61, 0x25, 0x48, 0x19, 0xd2, 0x6a, 0x8b, 0x35, 0x31, 0xaa, 0x47, 0xb2,
	0x00, 0xd3, 0x3d, 0xda, 0x89, 0x07, 0x6c, 0xac, 0x5f, 0x1e, 0xa4, 0xbe, 0x6f, 0xe9, 0xa3, 0x7e,
	0x2f, 0x93, 0x85, 0x72, 0x7e, 0x2f, 0x93, 0x2d, 0x94, 0x8b, 0xd5, 0x7f, 0xa5, 0x61, 0x29, 0x19,
	0x6d, 0x87, 0x87, 0xcd, 0x98, 0x23, 0xbf, 0x90, 0x4f, 0xe1, 0xd6, 0xd8, 0x62, 0xdc, 0xa6, 0x56,
	0xba, 0x6f, 0xba, 0x10, 0xac, 0xb2, 0xb3, 0x1e, 0xc7, 0x0f, 0x8d, 0x0f, 0x60, 0x79, 0xb2, 0xeb,
	0xc4, 0x29, 0xb2, 0x34, 0xc1, 0x0b, 0x92, 0xfa, 0x7d, 0xb0, 0x27, 0x1b, 0x0f, 0xbf, 0x82, 0x16,
	0x27, 0x98, 0xee, 0x7a, 0xe4, 0x3b, 0x30, 0x4f, 0x63, 0x79, 0x20, 0x42, 0x7e, 0x4c, 0xd5, 0xf7,
	0x1f, 0xce, 0x46, 0xc6, 0x90, 0x74, 0x52, 0xa1, 0xa6, 0xe4, 0xdb, 0x30, 0xd7, 0x14, 0xbe, 0xcf,
	0x9a, 0x88, 0xc4, 0xbc, 0x34, 0xf1, 0x97, 0x46, 0x62, 0x4c, 0xe7, 0x43, 0x58, 0x39, 0xe3, 0xd5,
	0x6d, 0x76, 0x18, 0x0d, 0xdd, 0xc6, 0xd6, 0xa6, 0x39, 0x04, 0xec, 0xd3, 0xfe, 0x77, 0x14, 0xa0,
	0xbe, 0xb5, 0x49, 0xea, 0x70, 0xe3, 0xac, 0x79, 0xa3, 0xc3, 0x7d, 0xaf, 0x25, 0x3a, 0x1e, 0xf3,
	0xcc, 0x07, 0xd4, 0xca, 0x69, 0x07, 0xf5, 0x11, 0x84, 0x7c, 0x0b, 0x4a, 0xe6, 0x84, 0x75, 0xfb,
	0x8c, 0xb7, 0x0f, 0xa4, 0x9d, 0x45, 0xa3, 0xa2, 0x91, 0xfe, 0x12, 0x85, 0xd5, 0x3f, 0xce, 0xc0,
	0xe2, 0xc4, 0xfe, 0x22, 0x1d, 0x20, 0xea, 0x1e, 0x35, 0xa0, 0x23, 0x73, 0x89, 0x7d, 0x3b, 0x97,
	0xfe, 0xb2, 0xcf, 0xfa, 0x86, 0xa4, 0xb4, 0x8a, 0xc4, 0xb0, 0xa4, 0xa2, 0xe9, 0xcd, 0x8b, 0x58,
	0xd8, 0x63, 0xe1, 0x20, 0x64, 0xea, 0xad, 0x84, 0x5c, 0xf0, 0x59, 0x1f, 0x17, 0xb7, 0x8f, 0xce,
	0x4d, 0xd8, 0x5f, 0xc3, 0xd2, 0xf0, 0x83, 0xe3, 0xd4, 0x4a, 0xdf, 0xee, 0x87, 0xc7, 0xe2, 0x20,
	0xcc, 0xf8, 0xb2, 0x7f, 0x63, 0xc1, 0xf5, 0x61, 0x02, 0x93, 0x16, 0x9f, 0x79, 0xab, 0x59, 0xbc,
	0x3b, 0x88, 0x35, 0xa9, 0x12, 0xe7, 0x8c, 0x1f, 0xf7, 0x5b, 0xc2, 0x9e, 0x46, 0x52, 0xdc, 0xbe,
	0x78, 0x1a, 0xe7, 0x10, 0xc8, 0xc4, 0x09, 0x46, 0x66, 0xf9, 0x10, 0x56, 0x7a, 0x3c, 0x94, 0x31,
	0xed, 0xb8, 0x3e, 0x93, 0xea, 0x4c, 0x1c, 0x6d, 0xc8, 0x61, 0x3c, 0x18, 0x19, 0x03, 0x79, 0xa4,
	0x11, 0x83, 0x5a, 0x1e, 0xc6, 0xe4, 0x1e, 0x2c, 0x8c, 0xa7, 0x6f, 0x6e, 0xda, 0xb3, 0xc8, 0xfa,
	0x24, 0x19, 0xf5, 0xa1, 0xbe, 0x5f, 0xaf, 0x01, 0x5e, 0x19, 0x5d, 0x1a, 0xf9, 0x38, 0x1a, 0xc5,
	0x7a, 0x51, 0xd1, 0x55, 0xf6, 0xf6, 0x8c, 0xfd, 0xcd, 0x37, 0xe9, 0x55, 0xcb, 0x99, 0x55, 0xea,
	0xed, 0xc8, 0xaf, 0xff, 0xde, 0x7a, 0xfe, 0xb2, 0x32, 0xf5, 0xe2, 0x65, 0x65, 0xea, 0xf5, 0xcb,
	0x8a, 0xf5, 0xf9, 0x49, 0xc5, 0xfa, 0xd3, 0x49, 0xc5, 0xfa, 0xeb, 0x49, 0xc5, 0x7a, 0x7e, 0x52,
	0xb1, 0x5e, 0x9c, 0x54, 0xac, 0xbf, 0x9f, 0x54, 0xac, 0x7f, 0x9c, 0x54, 0xa6, 0x5e, 0x9f, 0x54,
	0xac, 0x2f, 0x5e, 0x55, 0xa6, 0xbe, 0x7a, 0x55, 0xb1, 0x9e, 0xbf, 0xaa, 0x4c, 0xbd, 0x78, 0x55,
	0x99, 0xfa, 0xd5, 0xd3, 0xb6, 0x08, 0x0e, 0xdb, 0x35, 0x75, 0xc1, 0x54, 0x95, 0xaa, 0xc5, 0x89,
	0x5f, 0x44, 0x77, 0x83, 0x50, 0xf4, 0xb8, 0xc7, 0xc2, 0xbb, 0x03, 0xf5, 0x7a, 0xd0, 0x68, 0x8b,
	0x75, 0xf6, 0x4c, 0x9a, 0xbf, 0x43, 0x6f, 0xfc, 0xb5, 0xd4, 0x98, 0xc1, 0x9f, 0x46, 0xdf, 0xfb,
	0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x93, 0xa6, 0x1d, 0xba, 0x09, 0x14, 0x00, 0x00,
}

func (this *AzureInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureInstanceType)
	if !ok {
		that2, ok := that.(AzureInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VoltNodeId != that1.VoltNodeId {
		return false
	}
	if this.VoltVnetId != that1.VoltVnetId {
		return false
	}
	if this.PublicSubnetId != that1.PublicSubnetId {
		return false
	}
	if this.PrivateSubnetId != that1.PrivateSubnetId {
		return false
	}
	if this.MachineType != that1.MachineType {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	if !this.Marketplace.Equal(that1.Marketplace) {
		return false
	}
	if this.Az != that1.Az {
		return false
	}
	if this.NodeCount != that1.NodeCount {
		return false
	}
	return true
}
func (this *AzureSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetParamType)
	if !ok {
		that2, ok := that.(AzureSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceGroup != that1.ResourceGroup {
		return false
	}
	if this.Ipv4 != that1.Ipv4 {
		return false
	}
	if this.Ipv6 != that1.Ipv6 {
		return false
	}
	return true
}
func (this *AzureExistingSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureExistingSubnetParamType)
	if !ok {
		that2, ok := that.(AzureExistingSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	if this.SubnetResourceGrp != that1.SubnetResourceGrp {
		return false
	}
	return true
}
func (this *AzureSubnetChoice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoice)
	if !ok {
		that2, ok := that.(AzureSubnetChoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	if !this.ExistingSubnet.Equal(that1.ExistingSubnet) {
		return false
	}
	return true
}
func (this *AzureSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType)
	if !ok {
		that2, ok := that.(AzureSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VoltSubnetId != that1.VoltSubnetId {
		return false
	}
	if this.VoltVnetId != that1.VoltVnetId {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	return true
}
func (this *AzureVnetParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetParamsType)
	if !ok {
		that2, ok := that.(AzureVnetParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceGroup != that1.ResourceGroup {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	return true
}
func (this *AzureVnetInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetInfoType)
	if !ok {
		that2, ok := that.(AzureVnetInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVnet.Equal(that1.NewVnet) {
		return false
	}
	if !this.Vnet.Equal(that1.Vnet) {
		return false
	}
	return true
}
func (this *AvailabilitySetsInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AvailabilitySetsInfoType)
	if !ok {
		that2, ok := that.(AvailabilitySetsInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enable != that1.Enable {
		return false
	}
	if this.FaultDomains != that1.FaultDomains {
		return false
	}
	if this.UpdateDomains != that1.UpdateDomains {
		return false
	}
	return true
}
func (this *SpokeVnetsInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpokeVnetsInfoType)
	if !ok {
		that2, ok := that.(SpokeVnetsInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VnetResourceGroup != that1.VnetResourceGroup {
		return false
	}
	if this.VnetName != that1.VnetName {
		return false
	}
	if this.AutoRouting != that1.AutoRouting {
		return false
	}
	return true
}
func (this *AzureVnetSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetSiteType)
	if !ok {
		that2, ok := that.(AzureVnetSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	if this.AzureName != that1.AzureName {
		return false
	}
	if this.VoltVnetId != that1.VoltVnetId {
		return false
	}
	if this.CertifiedHw != that1.CertifiedHw {
		return false
	}
	if this.AzureRegion != that1.AzureRegion {
		return false
	}
	if this.AzureResourceGrp != that1.AzureResourceGrp {
		return false
	}
	if !this.Vnet.Equal(that1.Vnet) {
		return false
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if len(this.MasterNodes) != len(that1.MasterNodes) {
		return false
	}
	for i := range this.MasterNodes {
		if !this.MasterNodes[i].Equal(that1.MasterNodes[i]) {
			return false
		}
	}
	if len(this.InsideVipPortConfig) != len(that1.InsideVipPortConfig) {
		return false
	}
	for i := range this.InsideVipPortConfig {
		if !this.InsideVipPortConfig[i].Equal(that1.InsideVipPortConfig[i]) {
			return false
		}
	}
	if len(this.OutsideVipPortConfig) != len(that1.OutsideVipPortConfig) {
		return false
	}
	for i := range this.OutsideVipPortConfig {
		if !this.OutsideVipPortConfig[i].Equal(that1.OutsideVipPortConfig[i]) {
			return false
		}
	}
	if this.WorkerNodes != that1.WorkerNodes {
		return false
	}
	if this.GatewayType != that1.GatewayType {
		return false
	}
	if this.SshKey != that1.SshKey {
		return false
	}
	if !this.AvailabilitySet.Equal(that1.AvailabilitySet) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if this.MultiNodeNonStdAz != that1.MultiNodeNonStdAz {
		return false
	}
	if len(this.SpokeVnets) != len(that1.SpokeVnets) {
		return false
	}
	for i := range this.SpokeVnets {
		if !this.SpokeVnets[i].Equal(that1.SpokeVnets[i]) {
			return false
		}
	}
	if !this.ExpressRoute.Equal(that1.ExpressRoute) {
		return false
	}
	return true
}
func (this *ExpressRouteCircuitInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExpressRouteCircuitInfo)
	if !ok {
		that2, ok := that.(ExpressRouteCircuitInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpressRouteCircuitResourceGroup != that1.ExpressRouteCircuitResourceGroup {
		return false
	}
	if this.ExpressRouteCircuitName != that1.ExpressRouteCircuitName {
		return false
	}
	if this.ExpressRouteCircuitId != that1.ExpressRouteCircuitId {
		return false
	}
	if this.AuthorizationKey != that1.AuthorizationKey {
		return false
	}
	if this.ConnectionName != that1.ConnectionName {
		return false
	}
	if this.AuthorizationKeyClearB64 != that1.AuthorizationKeyClearB64 {
		return false
	}
	if this.AuthorizationKeyBlindfolded != that1.AuthorizationKeyBlindfolded {
		return false
	}
	if this.RoutingWeight != that1.RoutingWeight {
		return false
	}
	return true
}
func (this *AzureExpressRouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureExpressRouteType)
	if !ok {
		that2, ok := that.(AzureExpressRouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewGatewaySubnet.Equal(that1.NewGatewaySubnet) {
		return false
	}
	if !this.NewRouteServerSubnet.Equal(that1.NewRouteServerSubnet) {
		return false
	}
	if !this.ExistingGatewaySubnet.Equal(that1.ExistingGatewaySubnet) {
		return false
	}
	if !this.ExistingRouteServerSubnet.Equal(that1.ExistingRouteServerSubnet) {
		return false
	}
	if len(this.ExpressRouteCircuitInfo) != len(that1.ExpressRouteCircuitInfo) {
		return false
	}
	for i := range this.ExpressRouteCircuitInfo {
		if !this.ExpressRouteCircuitInfo[i].Equal(that1.ExpressRouteCircuitInfo[i]) {
			return false
		}
	}
	if this.VirtualNetworkGatewaySku != that1.VirtualNetworkGatewaySku {
		return false
	}
	if this.ExpressRouteEnable != that1.ExpressRouteEnable {
		return false
	}
	if this.SiteAsn != that1.SiteAsn {
		return false
	}
	return true
}
func (this *AzureInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&terraform_parameters.AzureInstanceType{")
	s = append(s, "VoltNodeId: "+fmt.Sprintf("%#v", this.VoltNodeId)+",\n")
	s = append(s, "VoltVnetId: "+fmt.Sprintf("%#v", this.VoltVnetId)+",\n")
	s = append(s, "PublicSubnetId: "+fmt.Sprintf("%#v", this.PublicSubnetId)+",\n")
	s = append(s, "PrivateSubnetId: "+fmt.Sprintf("%#v", this.PrivateSubnetId)+",\n")
	s = append(s, "MachineType: "+fmt.Sprintf("%#v", this.MachineType)+",\n")
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	if this.Marketplace != nil {
		s = append(s, "Marketplace: "+fmt.Sprintf("%#v", this.Marketplace)+",\n")
	}
	s = append(s, "Az: "+fmt.Sprintf("%#v", this.Az)+",\n")
	s = append(s, "NodeCount: "+fmt.Sprintf("%#v", this.NodeCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.AzureSubnetParamType{")
	s = append(s, "ResourceGroup: "+fmt.Sprintf("%#v", this.ResourceGroup)+",\n")
	s = append(s, "Ipv4: "+fmt.Sprintf("%#v", this.Ipv4)+",\n")
	s = append(s, "Ipv6: "+fmt.Sprintf("%#v", this.Ipv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureExistingSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.AzureExistingSubnetParamType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	s = append(s, "SubnetResourceGrp: "+fmt.Sprintf("%#v", this.SubnetResourceGrp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.AzureSubnetChoice{")
	if this.SubnetParam != nil {
		s = append(s, "SubnetParam: "+fmt.Sprintf("%#v", this.SubnetParam)+",\n")
	}
	if this.ExistingSubnet != nil {
		s = append(s, "ExistingSubnet: "+fmt.Sprintf("%#v", this.ExistingSubnet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&terraform_parameters.AzureSubnetType{")
	s = append(s, "VoltSubnetId: "+fmt.Sprintf("%#v", this.VoltSubnetId)+",\n")
	s = append(s, "VoltVnetId: "+fmt.Sprintf("%#v", this.VoltVnetId)+",\n")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.AzureVnetParamsType{")
	s = append(s, "ResourceGroup: "+fmt.Sprintf("%#v", this.ResourceGroup)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.AzureVnetInfoType{")
	if this.NewVnet != nil {
		s = append(s, "NewVnet: "+fmt.Sprintf("%#v", this.NewVnet)+",\n")
	}
	if this.Vnet != nil {
		s = append(s, "Vnet: "+fmt.Sprintf("%#v", this.Vnet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AvailabilitySetsInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.AvailabilitySetsInfoType{")
	s = append(s, "Enable: "+fmt.Sprintf("%#v", this.Enable)+",\n")
	s = append(s, "FaultDomains: "+fmt.Sprintf("%#v", this.FaultDomains)+",\n")
	s = append(s, "UpdateDomains: "+fmt.Sprintf("%#v", this.UpdateDomains)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SpokeVnetsInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.SpokeVnetsInfoType{")
	s = append(s, "VnetResourceGroup: "+fmt.Sprintf("%#v", this.VnetResourceGroup)+",\n")
	s = append(s, "VnetName: "+fmt.Sprintf("%#v", this.VnetName)+",\n")
	s = append(s, "AutoRouting: "+fmt.Sprintf("%#v", this.AutoRouting)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&terraform_parameters.AzureVnetSiteType{")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	s = append(s, "AzureName: "+fmt.Sprintf("%#v", this.AzureName)+",\n")
	s = append(s, "VoltVnetId: "+fmt.Sprintf("%#v", this.VoltVnetId)+",\n")
	s = append(s, "CertifiedHw: "+fmt.Sprintf("%#v", this.CertifiedHw)+",\n")
	s = append(s, "AzureRegion: "+fmt.Sprintf("%#v", this.AzureRegion)+",\n")
	s = append(s, "AzureResourceGrp: "+fmt.Sprintf("%#v", this.AzureResourceGrp)+",\n")
	if this.Vnet != nil {
		s = append(s, "Vnet: "+fmt.Sprintf("%#v", this.Vnet)+",\n")
	}
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.MasterNodes != nil {
		s = append(s, "MasterNodes: "+fmt.Sprintf("%#v", this.MasterNodes)+",\n")
	}
	if this.InsideVipPortConfig != nil {
		s = append(s, "InsideVipPortConfig: "+fmt.Sprintf("%#v", this.InsideVipPortConfig)+",\n")
	}
	if this.OutsideVipPortConfig != nil {
		s = append(s, "OutsideVipPortConfig: "+fmt.Sprintf("%#v", this.OutsideVipPortConfig)+",\n")
	}
	s = append(s, "WorkerNodes: "+fmt.Sprintf("%#v", this.WorkerNodes)+",\n")
	s = append(s, "GatewayType: "+fmt.Sprintf("%#v", this.GatewayType)+",\n")
	s = append(s, "SshKey: "+fmt.Sprintf("%#v", this.SshKey)+",\n")
	if this.AvailabilitySet != nil {
		s = append(s, "AvailabilitySet: "+fmt.Sprintf("%#v", this.AvailabilitySet)+",\n")
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "MultiNodeNonStdAz: "+fmt.Sprintf("%#v", this.MultiNodeNonStdAz)+",\n")
	if this.SpokeVnets != nil {
		s = append(s, "SpokeVnets: "+fmt.Sprintf("%#v", this.SpokeVnets)+",\n")
	}
	if this.ExpressRoute != nil {
		s = append(s, "ExpressRoute: "+fmt.Sprintf("%#v", this.ExpressRoute)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExpressRouteCircuitInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&terraform_parameters.ExpressRouteCircuitInfo{")
	s = append(s, "ExpressRouteCircuitResourceGroup: "+fmt.Sprintf("%#v", this.ExpressRouteCircuitResourceGroup)+",\n")
	s = append(s, "ExpressRouteCircuitName: "+fmt.Sprintf("%#v", this.ExpressRouteCircuitName)+",\n")
	s = append(s, "ExpressRouteCircuitId: "+fmt.Sprintf("%#v", this.ExpressRouteCircuitId)+",\n")
	s = append(s, "AuthorizationKey: "+fmt.Sprintf("%#v", this.AuthorizationKey)+",\n")
	s = append(s, "ConnectionName: "+fmt.Sprintf("%#v", this.ConnectionName)+",\n")
	s = append(s, "AuthorizationKeyClearB64: "+fmt.Sprintf("%#v", this.AuthorizationKeyClearB64)+",\n")
	s = append(s, "AuthorizationKeyBlindfolded: "+fmt.Sprintf("%#v", this.AuthorizationKeyBlindfolded)+",\n")
	s = append(s, "RoutingWeight: "+fmt.Sprintf("%#v", this.RoutingWeight)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureExpressRouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&terraform_parameters.AzureExpressRouteType{")
	if this.NewGatewaySubnet != nil {
		s = append(s, "NewGatewaySubnet: "+fmt.Sprintf("%#v", this.NewGatewaySubnet)+",\n")
	}
	if this.NewRouteServerSubnet != nil {
		s = append(s, "NewRouteServerSubnet: "+fmt.Sprintf("%#v", this.NewRouteServerSubnet)+",\n")
	}
	if this.ExistingGatewaySubnet != nil {
		s = append(s, "ExistingGatewaySubnet: "+fmt.Sprintf("%#v", this.ExistingGatewaySubnet)+",\n")
	}
	if this.ExistingRouteServerSubnet != nil {
		s = append(s, "ExistingRouteServerSubnet: "+fmt.Sprintf("%#v", this.ExistingRouteServerSubnet)+",\n")
	}
	if this.ExpressRouteCircuitInfo != nil {
		s = append(s, "ExpressRouteCircuitInfo: "+fmt.Sprintf("%#v", this.ExpressRouteCircuitInfo)+",\n")
	}
	s = append(s, "VirtualNetworkGatewaySku: "+fmt.Sprintf("%#v", this.VirtualNetworkGatewaySku)+",\n")
	s = append(s, "ExpressRouteEnable: "+fmt.Sprintf("%#v", this.ExpressRouteEnable)+",\n")
	s = append(s, "SiteAsn: "+fmt.Sprintf("%#v", this.SiteAsn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAzureTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AzureInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureInstanceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureInstanceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeCount != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Az) > 0 {
		i -= len(m.Az)
		copy(dAtA[i:], m.Az)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Az)))
		i--
		dAtA[i] = 0x52
	}
	if m.Marketplace != nil {
		{
			size, err := m.Marketplace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DiskSize) > 0 {
		i -= len(m.DiskSize)
		copy(dAtA[i:], m.DiskSize)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.DiskSize)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MachineType) > 0 {
		i -= len(m.MachineType)
		copy(dAtA[i:], m.MachineType)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.MachineType)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PrivateSubnetId) > 0 {
		i -= len(m.PrivateSubnetId)
		copy(dAtA[i:], m.PrivateSubnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.PrivateSubnetId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicSubnetId) > 0 {
		i -= len(m.PublicSubnetId)
		copy(dAtA[i:], m.PublicSubnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.PublicSubnetId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VoltVnetId) > 0 {
		i -= len(m.VoltVnetId)
		copy(dAtA[i:], m.VoltVnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltVnetId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VoltNodeId) > 0 {
		i -= len(m.VoltNodeId)
		copy(dAtA[i:], m.VoltNodeId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltNodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetParamType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6) > 0 {
		i -= len(m.Ipv6)
		copy(dAtA[i:], m.Ipv6)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Ipv6)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ipv4) > 0 {
		i -= len(m.Ipv4)
		copy(dAtA[i:], m.Ipv4)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Ipv4)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceGroup) > 0 {
		i -= len(m.ResourceGroup)
		copy(dAtA[i:], m.ResourceGroup)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.ResourceGroup)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureExistingSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureExistingSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureExistingSubnetParamType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubnetResourceGrp) > 0 {
		i -= len(m.SubnetResourceGrp)
		copy(dAtA[i:], m.SubnetResourceGrp)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.SubnetResourceGrp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SubnetName) > 0 {
		i -= len(m.SubnetName)
		copy(dAtA[i:], m.SubnetName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.SubnetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExistingSubnet != nil {
		{
			size, err := m.ExistingSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceType != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.InterfaceType))
		i--
		dAtA[i] = 0x28
	}
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.VoltVnetId) > 0 {
		i -= len(m.VoltVnetId)
		copy(dAtA[i:], m.VoltVnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltVnetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VoltSubnetId) > 0 {
		i -= len(m.VoltSubnetId)
		copy(dAtA[i:], m.VoltSubnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltSubnetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrimaryIpv4) > 0 {
		i -= len(m.PrimaryIpv4)
		copy(dAtA[i:], m.PrimaryIpv4)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceGroup) > 0 {
		i -= len(m.ResourceGroup)
		copy(dAtA[i:], m.ResourceGroup)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.ResourceGroup)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Vnet != nil {
		{
			size, err := m.Vnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewVnet != nil {
		{
			size, err := m.NewVnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AvailabilitySetsInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvailabilitySetsInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AvailabilitySetsInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateDomains != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.UpdateDomains))
		i--
		dAtA[i] = 0x28
	}
	if m.FaultDomains != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.FaultDomains))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Enable) > 0 {
		i -= len(m.Enable)
		copy(dAtA[i:], m.Enable)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.Enable)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpokeVnetsInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpokeVnetsInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpokeVnetsInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AutoRouting {
		i--
		if m.AutoRouting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.VnetName) > 0 {
		i -= len(m.VnetName)
		copy(dAtA[i:], m.VnetName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VnetName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VnetResourceGroup) > 0 {
		i -= len(m.VnetResourceGroup)
		copy(dAtA[i:], m.VnetResourceGroup)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VnetResourceGroup)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpressRoute != nil {
		{
			size, err := m.ExpressRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.SpokeVnets) > 0 {
		for iNdEx := len(m.SpokeVnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpokeVnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.MultiNodeNonStdAz {
		i--
		if m.MultiNodeNonStdAz {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAzureTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintAzureTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAzureTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.AvailabilitySet != nil {
		{
			size, err := m.AvailabilitySet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.OutsideVipPortConfig) > 0 {
		for iNdEx := len(m.OutsideVipPortConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutsideVipPortConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.InsideVipPortConfig) > 0 {
		for iNdEx := len(m.InsideVipPortConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InsideVipPortConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.AzureName) > 0 {
		i -= len(m.AzureName)
		copy(dAtA[i:], m.AzureName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AzureName)))
		i--
		dAtA[i] = 0x7a
	}
	if m.WorkerNodes != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.WorkerNodes))
		i--
		dAtA[i] = 0x70
	}
	if len(m.SshKey) > 0 {
		i -= len(m.SshKey)
		copy(dAtA[i:], m.SshKey)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.SshKey)))
		i--
		dAtA[i] = 0x6a
	}
	if m.GatewayType != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.GatewayType))
		i--
		dAtA[i] = 0x58
	}
	if len(m.MasterNodes) > 0 {
		for iNdEx := len(m.MasterNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MasterNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Vnet != nil {
		{
			size, err := m.Vnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AzureResourceGrp) > 0 {
		i -= len(m.AzureResourceGrp)
		copy(dAtA[i:], m.AzureResourceGrp)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AzureResourceGrp)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AzureRegion) > 0 {
		i -= len(m.AzureRegion)
		copy(dAtA[i:], m.AzureRegion)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AzureRegion)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CertifiedHw) > 0 {
		i -= len(m.CertifiedHw)
		copy(dAtA[i:], m.CertifiedHw)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.CertifiedHw)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VoltVnetId) > 0 {
		i -= len(m.VoltVnetId)
		copy(dAtA[i:], m.VoltVnetId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VoltVnetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SiteName) > 0 {
		i -= len(m.SiteName)
		copy(dAtA[i:], m.SiteName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.SiteName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExpressRouteCircuitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpressRouteCircuitInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExpressRouteCircuitInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoutingWeight) > 0 {
		i -= len(m.RoutingWeight)
		copy(dAtA[i:], m.RoutingWeight)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.RoutingWeight)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AuthorizationKeyBlindfolded) > 0 {
		i -= len(m.AuthorizationKeyBlindfolded)
		copy(dAtA[i:], m.AuthorizationKeyBlindfolded)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AuthorizationKeyBlindfolded)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AuthorizationKeyClearB64) > 0 {
		i -= len(m.AuthorizationKeyClearB64)
		copy(dAtA[i:], m.AuthorizationKeyClearB64)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AuthorizationKeyClearB64)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ConnectionName) > 0 {
		i -= len(m.ConnectionName)
		copy(dAtA[i:], m.ConnectionName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.ConnectionName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AuthorizationKey) > 0 {
		i -= len(m.AuthorizationKey)
		copy(dAtA[i:], m.AuthorizationKey)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.AuthorizationKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExpressRouteCircuitId) > 0 {
		i -= len(m.ExpressRouteCircuitId)
		copy(dAtA[i:], m.ExpressRouteCircuitId)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.ExpressRouteCircuitId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExpressRouteCircuitName) > 0 {
		i -= len(m.ExpressRouteCircuitName)
		copy(dAtA[i:], m.ExpressRouteCircuitName)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.ExpressRouteCircuitName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ExpressRouteCircuitResourceGroup) > 0 {
		i -= len(m.ExpressRouteCircuitResourceGroup)
		copy(dAtA[i:], m.ExpressRouteCircuitResourceGroup)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.ExpressRouteCircuitResourceGroup)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureExpressRouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureExpressRouteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureExpressRouteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SiteAsn != 0 {
		i = encodeVarintAzureTypes(dAtA, i, uint64(m.SiteAsn))
		i--
		dAtA[i] = 0x40
	}
	if m.ExpressRouteEnable {
		i--
		if m.ExpressRouteEnable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.VirtualNetworkGatewaySku) > 0 {
		i -= len(m.VirtualNetworkGatewaySku)
		copy(dAtA[i:], m.VirtualNetworkGatewaySku)
		i = encodeVarintAzureTypes(dAtA, i, uint64(len(m.VirtualNetworkGatewaySku)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExpressRouteCircuitInfo) > 0 {
		for iNdEx := len(m.ExpressRouteCircuitInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExpressRouteCircuitInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAzureTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ExistingRouteServerSubnet != nil {
		{
			size, err := m.ExistingRouteServerSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ExistingGatewaySubnet != nil {
		{
			size, err := m.ExistingGatewaySubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NewRouteServerSubnet != nil {
		{
			size, err := m.NewRouteServerSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewGatewaySubnet != nil {
		{
			size, err := m.NewGatewaySubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAzureTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAzureTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovAzureTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AzureInstanceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VoltNodeId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.VoltVnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.PublicSubnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.PrivateSubnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.MachineType)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.DiskSize)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Marketplace != nil {
		l = m.Marketplace.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.Az)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.NodeCount != 0 {
		n += 1 + sovAzureTypes(uint64(m.NodeCount))
	}
	return n
}

func (m *AzureSubnetParamType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.Ipv6)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureExistingSubnetParamType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.SubnetResourceGrp)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureSubnetChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.ExistingSubnet != nil {
		l = m.ExistingSubnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureSubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VoltSubnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.VoltVnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.InterfaceType != 0 {
		n += 1 + sovAzureTypes(uint64(m.InterfaceType))
	}
	return n
}

func (m *AzureVnetParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewVnet != nil {
		l = m.NewVnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Vnet != nil {
		l = m.Vnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AvailabilitySetsInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Enable)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.FaultDomains != 0 {
		n += 1 + sovAzureTypes(uint64(m.FaultDomains))
	}
	if m.UpdateDomains != 0 {
		n += 1 + sovAzureTypes(uint64(m.UpdateDomains))
	}
	return n
}

func (m *SpokeVnetsInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VnetResourceGroup)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.VnetName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.AutoRouting {
		n += 2
	}
	return n
}

func (m *AzureVnetSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.VoltVnetId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.CertifiedHw)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.AzureRegion)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.AzureResourceGrp)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.Vnet != nil {
		l = m.Vnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovAzureTypes(uint64(l))
		}
	}
	if len(m.MasterNodes) > 0 {
		for _, e := range m.MasterNodes {
			l = e.Size()
			n += 1 + l + sovAzureTypes(uint64(l))
		}
	}
	if m.GatewayType != 0 {
		n += 1 + sovAzureTypes(uint64(m.GatewayType))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.WorkerNodes != 0 {
		n += 1 + sovAzureTypes(uint64(m.WorkerNodes))
	}
	l = len(m.AzureName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if len(m.InsideVipPortConfig) > 0 {
		for _, e := range m.InsideVipPortConfig {
			l = e.Size()
			n += 2 + l + sovAzureTypes(uint64(l))
		}
	}
	if len(m.OutsideVipPortConfig) > 0 {
		for _, e := range m.OutsideVipPortConfig {
			l = e.Size()
			n += 2 + l + sovAzureTypes(uint64(l))
		}
	}
	if m.AvailabilitySet != nil {
		l = m.AvailabilitySet.Size()
		n += 2 + l + sovAzureTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAzureTypes(uint64(len(k))) + 1 + len(v) + sovAzureTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovAzureTypes(uint64(mapEntrySize))
		}
	}
	if m.MultiNodeNonStdAz {
		n += 3
	}
	if len(m.SpokeVnets) > 0 {
		for _, e := range m.SpokeVnets {
			l = e.Size()
			n += 2 + l + sovAzureTypes(uint64(l))
		}
	}
	if m.ExpressRoute != nil {
		l = m.ExpressRoute.Size()
		n += 2 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *ExpressRouteCircuitInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExpressRouteCircuitResourceGroup)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.ExpressRouteCircuitName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.ExpressRouteCircuitId)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.AuthorizationKey)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.ConnectionName)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.AuthorizationKeyClearB64)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.AuthorizationKeyBlindfolded)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	l = len(m.RoutingWeight)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	return n
}

func (m *AzureExpressRouteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewGatewaySubnet != nil {
		l = m.NewGatewaySubnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.NewRouteServerSubnet != nil {
		l = m.NewRouteServerSubnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.ExistingGatewaySubnet != nil {
		l = m.ExistingGatewaySubnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.ExistingRouteServerSubnet != nil {
		l = m.ExistingRouteServerSubnet.Size()
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if len(m.ExpressRouteCircuitInfo) > 0 {
		for _, e := range m.ExpressRouteCircuitInfo {
			l = e.Size()
			n += 1 + l + sovAzureTypes(uint64(l))
		}
	}
	l = len(m.VirtualNetworkGatewaySku)
	if l > 0 {
		n += 1 + l + sovAzureTypes(uint64(l))
	}
	if m.ExpressRouteEnable {
		n += 2
	}
	if m.SiteAsn != 0 {
		n += 1 + sovAzureTypes(uint64(m.SiteAsn))
	}
	return n
}

func sovAzureTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAzureTypes(x uint64) (n int) {
	return sovAzureTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AzureInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureInstanceType{`,
		`VoltNodeId:` + fmt.Sprintf("%v", this.VoltNodeId) + `,`,
		`VoltVnetId:` + fmt.Sprintf("%v", this.VoltVnetId) + `,`,
		`PublicSubnetId:` + fmt.Sprintf("%v", this.PublicSubnetId) + `,`,
		`PrivateSubnetId:` + fmt.Sprintf("%v", this.PrivateSubnetId) + `,`,
		`MachineType:` + fmt.Sprintf("%v", this.MachineType) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`Marketplace:` + strings.Replace(fmt.Sprintf("%v", this.Marketplace), "Marketplace", "certified_hardware.Marketplace", 1) + `,`,
		`Az:` + fmt.Sprintf("%v", this.Az) + `,`,
		`NodeCount:` + fmt.Sprintf("%v", this.NodeCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetParamType{`,
		`ResourceGroup:` + fmt.Sprintf("%v", this.ResourceGroup) + `,`,
		`Ipv4:` + fmt.Sprintf("%v", this.Ipv4) + `,`,
		`Ipv6:` + fmt.Sprintf("%v", this.Ipv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureExistingSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureExistingSubnetParamType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`SubnetResourceGrp:` + fmt.Sprintf("%v", this.SubnetResourceGrp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoice{`,
		`SubnetParam:` + strings.Replace(this.SubnetParam.String(), "AzureSubnetParamType", "AzureSubnetParamType", 1) + `,`,
		`ExistingSubnet:` + strings.Replace(this.ExistingSubnet.String(), "AzureExistingSubnetParamType", "AzureExistingSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType{`,
		`VoltSubnetId:` + fmt.Sprintf("%v", this.VoltSubnetId) + `,`,
		`VoltVnetId:` + fmt.Sprintf("%v", this.VoltVnetId) + `,`,
		`Subnet:` + strings.Replace(this.Subnet.String(), "AzureSubnetChoice", "AzureSubnetChoice", 1) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetParamsType{`,
		`ResourceGroup:` + fmt.Sprintf("%v", this.ResourceGroup) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetInfoType{`,
		`NewVnet:` + strings.Replace(fmt.Sprintf("%v", this.NewVnet), "AzureVnetParamsType", "views.AzureVnetParamsType", 1) + `,`,
		`Vnet:` + strings.Replace(fmt.Sprintf("%v", this.Vnet), "AzureVnetType", "views.AzureVnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AvailabilitySetsInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AvailabilitySetsInfoType{`,
		`Enable:` + fmt.Sprintf("%v", this.Enable) + `,`,
		`FaultDomains:` + fmt.Sprintf("%v", this.FaultDomains) + `,`,
		`UpdateDomains:` + fmt.Sprintf("%v", this.UpdateDomains) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SpokeVnetsInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SpokeVnetsInfoType{`,
		`VnetResourceGroup:` + fmt.Sprintf("%v", this.VnetResourceGroup) + `,`,
		`VnetName:` + fmt.Sprintf("%v", this.VnetName) + `,`,
		`AutoRouting:` + fmt.Sprintf("%v", this.AutoRouting) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetSiteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnets := "[]*AzureSubnetType{"
	for _, f := range this.Subnets {
		repeatedStringForSubnets += strings.Replace(f.String(), "AzureSubnetType", "AzureSubnetType", 1) + ","
	}
	repeatedStringForSubnets += "}"
	repeatedStringForMasterNodes := "[]*AzureInstanceType{"
	for _, f := range this.MasterNodes {
		repeatedStringForMasterNodes += strings.Replace(f.String(), "AzureInstanceType", "AzureInstanceType", 1) + ","
	}
	repeatedStringForMasterNodes += "}"
	repeatedStringForInsideVipPortConfig := "[]*VIPPortConfig{"
	for _, f := range this.InsideVipPortConfig {
		repeatedStringForInsideVipPortConfig += strings.Replace(fmt.Sprintf("%v", f), "VIPPortConfig", "VIPPortConfig", 1) + ","
	}
	repeatedStringForInsideVipPortConfig += "}"
	repeatedStringForOutsideVipPortConfig := "[]*VIPPortConfig{"
	for _, f := range this.OutsideVipPortConfig {
		repeatedStringForOutsideVipPortConfig += strings.Replace(fmt.Sprintf("%v", f), "VIPPortConfig", "VIPPortConfig", 1) + ","
	}
	repeatedStringForOutsideVipPortConfig += "}"
	repeatedStringForSpokeVnets := "[]*SpokeVnetsInfoType{"
	for _, f := range this.SpokeVnets {
		repeatedStringForSpokeVnets += strings.Replace(f.String(), "SpokeVnetsInfoType", "SpokeVnetsInfoType", 1) + ","
	}
	repeatedStringForSpokeVnets += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AzureVnetSiteType{`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`VoltVnetId:` + fmt.Sprintf("%v", this.VoltVnetId) + `,`,
		`CertifiedHw:` + fmt.Sprintf("%v", this.CertifiedHw) + `,`,
		`AzureRegion:` + fmt.Sprintf("%v", this.AzureRegion) + `,`,
		`AzureResourceGrp:` + fmt.Sprintf("%v", this.AzureResourceGrp) + `,`,
		`Vnet:` + strings.Replace(this.Vnet.String(), "AzureVnetInfoType", "AzureVnetInfoType", 1) + `,`,
		`Subnets:` + repeatedStringForSubnets + `,`,
		`MasterNodes:` + repeatedStringForMasterNodes + `,`,
		`GatewayType:` + fmt.Sprintf("%v", this.GatewayType) + `,`,
		`SshKey:` + fmt.Sprintf("%v", this.SshKey) + `,`,
		`WorkerNodes:` + fmt.Sprintf("%v", this.WorkerNodes) + `,`,
		`AzureName:` + fmt.Sprintf("%v", this.AzureName) + `,`,
		`InsideVipPortConfig:` + repeatedStringForInsideVipPortConfig + `,`,
		`OutsideVipPortConfig:` + repeatedStringForOutsideVipPortConfig + `,`,
		`AvailabilitySet:` + strings.Replace(this.AvailabilitySet.String(), "AvailabilitySetsInfoType", "AvailabilitySetsInfoType", 1) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`MultiNodeNonStdAz:` + fmt.Sprintf("%v", this.MultiNodeNonStdAz) + `,`,
		`SpokeVnets:` + repeatedStringForSpokeVnets + `,`,
		`ExpressRoute:` + strings.Replace(this.ExpressRoute.String(), "AzureExpressRouteType", "AzureExpressRouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExpressRouteCircuitInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExpressRouteCircuitInfo{`,
		`ExpressRouteCircuitResourceGroup:` + fmt.Sprintf("%v", this.ExpressRouteCircuitResourceGroup) + `,`,
		`ExpressRouteCircuitName:` + fmt.Sprintf("%v", this.ExpressRouteCircuitName) + `,`,
		`ExpressRouteCircuitId:` + fmt.Sprintf("%v", this.ExpressRouteCircuitId) + `,`,
		`AuthorizationKey:` + fmt.Sprintf("%v", this.AuthorizationKey) + `,`,
		`ConnectionName:` + fmt.Sprintf("%v", this.ConnectionName) + `,`,
		`AuthorizationKeyClearB64:` + fmt.Sprintf("%v", this.AuthorizationKeyClearB64) + `,`,
		`AuthorizationKeyBlindfolded:` + fmt.Sprintf("%v", this.AuthorizationKeyBlindfolded) + `,`,
		`RoutingWeight:` + fmt.Sprintf("%v", this.RoutingWeight) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureExpressRouteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExpressRouteCircuitInfo := "[]*ExpressRouteCircuitInfo{"
	for _, f := range this.ExpressRouteCircuitInfo {
		repeatedStringForExpressRouteCircuitInfo += strings.Replace(f.String(), "ExpressRouteCircuitInfo", "ExpressRouteCircuitInfo", 1) + ","
	}
	repeatedStringForExpressRouteCircuitInfo += "}"
	s := strings.Join([]string{`&AzureExpressRouteType{`,
		`NewGatewaySubnet:` + strings.Replace(this.NewGatewaySubnet.String(), "AzureSubnetParamType", "AzureSubnetParamType", 1) + `,`,
		`NewRouteServerSubnet:` + strings.Replace(this.NewRouteServerSubnet.String(), "AzureSubnetParamType", "AzureSubnetParamType", 1) + `,`,
		`ExistingGatewaySubnet:` + strings.Replace(this.ExistingGatewaySubnet.String(), "AzureExistingSubnetParamType", "AzureExistingSubnetParamType", 1) + `,`,
		`ExistingRouteServerSubnet:` + strings.Replace(this.ExistingRouteServerSubnet.String(), "AzureExistingSubnetParamType", "AzureExistingSubnetParamType", 1) + `,`,
		`ExpressRouteCircuitInfo:` + repeatedStringForExpressRouteCircuitInfo + `,`,
		`VirtualNetworkGatewaySku:` + fmt.Sprintf("%v", this.VirtualNetworkGatewaySku) + `,`,
		`ExpressRouteEnable:` + fmt.Sprintf("%v", this.ExpressRouteEnable) + `,`,
		`SiteAsn:` + fmt.Sprintf("%v", this.SiteAsn) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAzureTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AzureInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltNodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MachineType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marketplace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Marketplace == nil {
				m.Marketplace = &certified_hardware.Marketplace{}
			}
			if err := m.Marketplace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Az", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Az = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureExistingSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureExistingSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureExistingSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetResourceGrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetResourceGrp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetParam == nil {
				m.SubnetParam = &AzureSubnetParamType{}
			}
			if err := m.SubnetParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingSubnet == nil {
				m.ExistingSubnet = &AzureExistingSubnetParamType{}
			}
			if err := m.ExistingSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &AzureSubnetChoice{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= InterfaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewVnet == nil {
				m.NewVnet = &views.AzureVnetParamsType{}
			}
			if err := m.NewVnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vnet == nil {
				m.Vnet = &views.AzureVnetType{}
			}
			if err := m.Vnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvailabilitySetsInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvailabilitySetsInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvailabilitySetsInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultDomains", wireType)
			}
			m.FaultDomains = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FaultDomains |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDomains", wireType)
			}
			m.UpdateDomains = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDomains |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpokeVnetsInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpokeVnetsInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpokeVnetsInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnetResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRouting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRouting = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltVnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltVnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertifiedHw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureResourceGrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureResourceGrp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vnet == nil {
				m.Vnet = &AzureVnetInfoType{}
			}
			if err := m.Vnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &AzureSubnetType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterNodes = append(m.MasterNodes, &AzureInstanceType{})
			if err := m.MasterNodes[len(m.MasterNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayType", wireType)
			}
			m.GatewayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayType |= CloudGatewayType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodes", wireType)
			}
			m.WorkerNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerNodes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVipPortConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVipPortConfig = append(m.InsideVipPortConfig, &VIPPortConfig{})
			if err := m.InsideVipPortConfig[len(m.InsideVipPortConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVipPortConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVipPortConfig = append(m.OutsideVipPortConfig, &VIPPortConfig{})
			if err := m.OutsideVipPortConfig[len(m.OutsideVipPortConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilitySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AvailabilitySet == nil {
				m.AvailabilitySet = &AvailabilitySetsInfoType{}
			}
			if err := m.AvailabilitySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAzureTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAzureTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAzureTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAzureTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAzureTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAzureTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAzureTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAzureTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAzureTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiNodeNonStdAz", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiNodeNonStdAz = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpokeVnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpokeVnets = append(m.SpokeVnets, &SpokeVnetsInfoType{})
			if err := m.SpokeVnets[len(m.SpokeVnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpressRoute == nil {
				m.ExpressRoute = &AzureExpressRouteType{}
			}
			if err := m.ExpressRoute.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpressRouteCircuitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpressRouteCircuitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpressRouteCircuitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressRouteCircuitResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressRouteCircuitResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressRouteCircuitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressRouteCircuitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressRouteCircuitId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressRouteCircuitId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationKeyClearB64", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationKeyClearB64 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationKeyBlindfolded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationKeyBlindfolded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingWeight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureExpressRouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureExpressRouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureExpressRouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewGatewaySubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewGatewaySubnet == nil {
				m.NewGatewaySubnet = &AzureSubnetParamType{}
			}
			if err := m.NewGatewaySubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewRouteServerSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewRouteServerSubnet == nil {
				m.NewRouteServerSubnet = &AzureSubnetParamType{}
			}
			if err := m.NewRouteServerSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingGatewaySubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingGatewaySubnet == nil {
				m.ExistingGatewaySubnet = &AzureExistingSubnetParamType{}
			}
			if err := m.ExistingGatewaySubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingRouteServerSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingRouteServerSubnet == nil {
				m.ExistingRouteServerSubnet = &AzureExistingSubnetParamType{}
			}
			if err := m.ExistingRouteServerSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressRouteCircuitInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressRouteCircuitInfo = append(m.ExpressRouteCircuitInfo, &ExpressRouteCircuitInfo{})
			if err := m.ExpressRouteCircuitInfo[len(m.ExpressRouteCircuitInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetworkGatewaySku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAzureTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetworkGatewaySku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressRouteEnable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpressRouteEnable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteAsn", wireType)
			}
			m.SiteAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteAsn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAzureTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAzureTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAzureTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAzureTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAzureTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAzureTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAzureTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAzureTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAzureTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAzureTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAzureTypes = fmt.Errorf("proto: unexpected end of group")
)
