// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package terraform_parameters

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AWSInstanceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSInstanceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSInstanceType) DeepCopy() *AWSInstanceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSInstanceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSInstanceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSInstanceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSInstanceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSInstanceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSInstanceType) EbsVolumeSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ebs_volume_size")
	}

	return validatorFn, nil
}

func (v *ValidateAWSInstanceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSInstanceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSInstanceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ami_id"]; exists {

		vOpts := append(opts, db.WithValidateField("ami_id"))
		if err := fv(ctx, m.GetAmiId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ebs_volume_az"]; exists {

		vOpts := append(opts, db.WithValidateField("ebs_volume_az"))
		if err := fv(ctx, m.GetEbsVolumeAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ebs_volume_size"]; exists {

		vOpts := append(opts, db.WithValidateField("ebs_volume_size"))
		if err := fv(ctx, m.GetEbsVolumeSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["instance_type"]; exists {

		vOpts := append(opts, db.WithValidateField("instance_type"))
		if err := fv(ctx, m.GetInstanceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_count"]; exists {

		vOpts := append(opts, db.WithValidateField("node_count"))
		if err := fv(ctx, m.GetNodeCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("private_subnet_id"))
		if err := fv(ctx, m.GetPrivateSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("public_subnet_id"))
		if err := fv(ctx, m.GetPublicSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volt_node_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_node_id"))
		if err := fv(ctx, m.GetVoltNodeId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volt_vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_vpc_id"))
		if err := fv(ctx, m.GetVoltVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSInstanceTypeValidator = func() *ValidateAWSInstanceType {
	v := &ValidateAWSInstanceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEbsVolumeSize := v.EbsVolumeSizeValidationRuleHandler
	rulesEbsVolumeSize := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "1024",
	}
	vFn, err = vrhEbsVolumeSize(rulesEbsVolumeSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSInstanceType.ebs_volume_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ebs_volume_size"] = vFn

	return v
}()

func AWSInstanceTypeValidator() db.Validator {
	return DefaultAWSInstanceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSTGWInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSTGWInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSTGWInfoType) DeepCopy() *AWSTGWInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSTGWInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSTGWInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSTGWInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSTGWInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSTGWInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSTGWInfoType) TgwAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_asn")
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWInfoType) VolterraSiteAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_site_asn")
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSTGWInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSTGWInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["new_tgw"]; exists {

		vOpts := append(opts, db.WithValidateField("new_tgw"))
		if err := fv(ctx, m.GetNewTgw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_asn"))
		if err := fv(ctx, m.GetTgwAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_id"))
		if err := fv(ctx, m.GetTgwId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_site_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_site_asn"))
		if err := fv(ctx, m.GetVolterraSiteAsn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSTGWInfoTypeValidator = func() *ValidateAWSTGWInfoType {
	v := &ValidateAWSTGWInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTgwAsn := v.TgwAsnValidationRuleHandler
	rulesTgwAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt": "0",
	}
	vFn, err = vrhTgwAsn(rulesTgwAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWInfoType.tgw_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_asn"] = vFn

	vrhVolterraSiteAsn := v.VolterraSiteAsnValidationRuleHandler
	rulesVolterraSiteAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt": "0",
	}
	vFn, err = vrhVolterraSiteAsn(rulesVolterraSiteAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWInfoType.volterra_site_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_site_asn"] = vFn

	return v
}()

func AWSTGWInfoTypeValidator() db.Validator {
	return DefaultAWSTGWInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSTGWTunnelInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSTGWTunnelInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AWSTGWTunnelInfoType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTunnel1Psk().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AWSTGWTunnelInfoType.tunnel1_psk")
	}

	if err := m.GetTunnel2Psk().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AWSTGWTunnelInfoType.tunnel2_psk")
	}

	return nil
}

func (m *AWSTGWTunnelInfoType) DeepCopy() *AWSTGWTunnelInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSTGWTunnelInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSTGWTunnelInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSTGWTunnelInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSTGWTunnelInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSTGWTunnelInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSTGWTunnelInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSTGWTunnelInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSTGWTunnelInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["node_name"]; exists {

		vOpts := append(opts, db.WithValidateField("node_name"))
		if err := fv(ctx, m.GetNodeName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel1_inside_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel1_inside_prefix"))
		if err := fv(ctx, m.GetTunnel1InsidePrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel1_psk"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel1_psk"))
		if err := fv(ctx, m.GetTunnel1Psk(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel2_inside_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel2_inside_prefix"))
		if err := fv(ctx, m.GetTunnel2InsidePrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel2_psk"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel2_psk"))
		if err := fv(ctx, m.GetTunnel2Psk(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSTGWTunnelInfoTypeValidator = func() *ValidateAWSTGWTunnelInfoType {
	v := &ValidateAWSTGWTunnelInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["tunnel1_psk"] = ves_io_schema.SecretTypeValidator().Validate

	v.FldValidators["tunnel2_psk"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func AWSTGWTunnelInfoTypeValidator() db.Validator {
	return DefaultAWSTGWTunnelInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSTGWType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSTGWType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSTGWType) String() string {
	if m == nil {
		return ""
	}
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.string()
}

func (m *AWSTGWType) GoString() string {
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.goString()
}

// Redact squashes sensitive info in m (in-place)
func (m *AWSTGWType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	m.AdminPasswordBlindfolded = ""

	for idx, e := range m.GetTunnelInformation() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting AWSTGWType.tunnel_information idx %v", idx)
		}
	}

	for idx, e := range m.GetSvcsTunnelInformation() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting AWSTGWType.svcs_tunnel_information idx %v", idx)
		}
	}

	return nil
}

func (m *AWSTGWType) DeepCopy() *AWSTGWType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSTGWType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSTGWType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSTGWType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSTGWTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSTGWType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSTGWType) VpcIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for vpc_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vpc_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vpc_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vpc_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSTGWType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSTGWType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["admin_password"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_password"))
		if err := fv(ctx, m.GetAdminPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["admin_password_blindfolded"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_password_blindfolded"))
		if err := fv(ctx, m.GetAdminPasswordBlindfolded(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["admin_password_clear_b64"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_password_clear_b64"))
		if err := fv(ctx, m.GetAdminPasswordClearB64(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["assume_role"]; exists {

		vOpts := append(opts, db.WithValidateField("assume_role"))
		if err := fv(ctx, m.GetAssumeRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_name"))
		if err := fv(ctx, m.GetAwsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_region"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_region"))
		if err := fv(ctx, m.GetAwsRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certified_hw"]; exists {

		vOpts := append(opts, db.WithValidateField("certified_hw"))
		if err := fv(ctx, m.GetCertifiedHw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment"))
		if err := fv(ctx, m.GetDeployment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_internet_connectivity_via_igw"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_internet_connectivity_via_igw"))
		if err := fv(ctx, m.GetDisableInternetConnectivityViaIgw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dx_connect"]; exists {

		vOpts := append(opts, db.WithValidateField("dx_connect"))
		if err := fv(ctx, m.GetDxConnect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fleet_label"]; exists {

		vOpts := append(opts, db.WithValidateField("fleet_label"))
		if err := fv(ctx, m.GetFleetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gre_tunnel"]; exists {

		vOpts := append(opts, db.WithValidateField("gre_tunnel"))
		if err := fv(ctx, m.GetGreTunnel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_security_group_id"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_security_group_id"))
		if err := fv(ctx, m.GetInsideSecurityGroupId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip_port_config"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip_port_config"))
		for idx, item := range m.GetInsideVipPortConfig() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["internet_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("internet_vip"))
		if err := fv(ctx, m.GetInternetVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["master_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("master_nodes"))
		for idx, item := range m.GetMasterNodes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["multi_node_non_std_az"]; exists {

		vOpts := append(opts, db.WithValidateField("multi_node_non_std_az"))
		if err := fv(ctx, m.GetMultiNodeNonStdAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_security_group_id"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_security_group_id"))
		if err := fv(ctx, m.GetOutsideSecurityGroupId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip_port_config"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip_port_config"))
		for idx, item := range m.GetOutsideVipPortConfig() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_name"]; exists {

		vOpts := append(opts, db.WithValidateField("site_name"))
		if err := fv(ctx, m.GetSiteName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ssh_key"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_key"))
		if err := fv(ctx, m.GetSshKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnets"]; exists {

		vOpts := append(opts, db.WithValidateField("subnets"))
		for idx, item := range m.GetSubnets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["svcs_tunnel_information"]; exists {

		vOpts := append(opts, db.WithValidateField("svcs_tunnel_information"))
		for idx, item := range m.GetSvcsTunnelInformation() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {

		vOpts := append(opts, db.WithValidateField("tags"))
		for key, value := range m.GetTags() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tgw"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw"))
		if err := fv(ctx, m.GetTgw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transit_gateway_cidr_block"]; exists {

		vOpts := append(opts, db.WithValidateField("transit_gateway_cidr_block"))
		for idx, item := range m.GetTransitGatewayCidrBlock() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tunnel_information"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_information"))
		for idx, item := range m.GetTunnelInformation() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volt_vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_vpc_id"))
		if err := fv(ctx, m.GetVoltVpcId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc"))
		if err := fv(ctx, m.GetVpc(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("vpc_ids"))
		if err := fv(ctx, m.GetVpcIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["worker_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("worker_nodes"))
		if err := fv(ctx, m.GetWorkerNodes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSTGWTypeValidator = func() *ValidateAWSTGWType {
	v := &ValidateAWSTGWType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVpcIds := v.VpcIdsValidationRuleHandler
	rulesVpcIds := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_len": "64",
	}
	vFn, err = vrhVpcIds(rulesVpcIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWType.vpc_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vpc_ids"] = vFn

	v.FldValidators["tgw"] = AWSTGWInfoTypeValidator().Validate

	v.FldValidators["vpc"] = AWSVPCInfoTypeValidator().Validate

	v.FldValidators["subnets"] = SubnetTypeValidator().Validate

	v.FldValidators["master_nodes"] = AWSInstanceTypeValidator().Validate

	v.FldValidators["tunnel_information"] = AWSTGWTunnelInfoTypeValidator().Validate

	v.FldValidators["svcs_tunnel_information"] = AWSTGWTunnelInfoTypeValidator().Validate

	v.FldValidators["inside_vip_port_config"] = VIPPortConfigValidator().Validate

	v.FldValidators["outside_vip_port_config"] = VIPPortConfigValidator().Validate

	v.FldValidators["dx_connect"] = DirectConnectTypeValidator().Validate

	v.FldValidators["deployment"] = DeploymentInfoValidator().Validate

	return v
}()

func AWSTGWTypeValidator() db.Validator {
	return DefaultAWSTGWTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCInfoType) DeepCopy() *AWSVPCInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["new_vpc"]; exists {

		vOpts := append(opts, db.WithValidateField("new_vpc"))
		if err := fv(ctx, m.GetNewVpc(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_id"))
		if err := fv(ctx, m.GetVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCInfoTypeValidator = func() *ValidateAWSVPCInfoType {
	v := &ValidateAWSVPCInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["new_vpc"] = ves_io_schema_views.AWSVPCParamsTypeValidator().Validate

	return v
}()

func AWSVPCInfoTypeValidator() db.Validator {
	return DefaultAWSVPCInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCType) String() string {
	if m == nil {
		return ""
	}
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.string()
}

func (m *AWSVPCType) GoString() string {
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.goString()
}

// Redact squashes sensitive info in m (in-place)
func (m *AWSVPCType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	m.AdminPasswordBlindfolded = ""

	return nil
}

func (m *AWSVPCType) DeepCopy() *AWSVPCType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["admin_password"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_password"))
		if err := fv(ctx, m.GetAdminPassword(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["admin_password_blindfolded"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_password_blindfolded"))
		if err := fv(ctx, m.GetAdminPasswordBlindfolded(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["admin_password_clear_b64"]; exists {

		vOpts := append(opts, db.WithValidateField("admin_password_clear_b64"))
		if err := fv(ctx, m.GetAdminPasswordClearB64(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["assume_role"]; exists {

		vOpts := append(opts, db.WithValidateField("assume_role"))
		if err := fv(ctx, m.GetAssumeRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_name"))
		if err := fv(ctx, m.GetAwsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_region"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_region"))
		if err := fv(ctx, m.GetAwsRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certified_hw"]; exists {

		vOpts := append(opts, db.WithValidateField("certified_hw"))
		if err := fv(ctx, m.GetCertifiedHw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment"))
		if err := fv(ctx, m.GetDeployment(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disable_internet_connectivity_via_igw"]; exists {

		vOpts := append(opts, db.WithValidateField("disable_internet_connectivity_via_igw"))
		if err := fv(ctx, m.GetDisableInternetConnectivityViaIgw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dx_connect"]; exists {

		vOpts := append(opts, db.WithValidateField("dx_connect"))
		if err := fv(ctx, m.GetDxConnect(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["egress_gw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("egress_gw_id"))
		if err := fv(ctx, m.GetEgressGwId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gateway_type"]; exists {

		vOpts := append(opts, db.WithValidateField("gateway_type"))
		if err := fv(ctx, m.GetGatewayType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_security_group_id"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_security_group_id"))
		if err := fv(ctx, m.GetInsideSecurityGroupId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip_port_config"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip_port_config"))
		for idx, item := range m.GetInsideVipPortConfig() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["internet_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("internet_vip"))
		if err := fv(ctx, m.GetInternetVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["master_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("master_nodes"))
		for idx, item := range m.GetMasterNodes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["multi_node_non_std_az"]; exists {

		vOpts := append(opts, db.WithValidateField("multi_node_non_std_az"))
		if err := fv(ctx, m.GetMultiNodeNonStdAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_security_group_id"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_security_group_id"))
		if err := fv(ctx, m.GetOutsideSecurityGroupId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip_port_config"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip_port_config"))
		for idx, item := range m.GetOutsideVipPortConfig() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_name"]; exists {

		vOpts := append(opts, db.WithValidateField("site_name"))
		if err := fv(ctx, m.GetSiteName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ssh_key"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_key"))
		if err := fv(ctx, m.GetSshKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnets"]; exists {

		vOpts := append(opts, db.WithValidateField("subnets"))
		for idx, item := range m.GetSubnets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {

		vOpts := append(opts, db.WithValidateField("tags"))
		for key, value := range m.GetTags() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volt_vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_vpc_id"))
		if err := fv(ctx, m.GetVoltVpcId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc"))
		if err := fv(ctx, m.GetVpc(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["worker_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("worker_nodes"))
		if err := fv(ctx, m.GetWorkerNodes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCTypeValidator = func() *ValidateAWSVPCType {
	v := &ValidateAWSVPCType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["vpc"] = AWSVPCInfoTypeValidator().Validate

	v.FldValidators["subnets"] = SubnetTypeValidator().Validate

	v.FldValidators["master_nodes"] = AWSInstanceTypeValidator().Validate

	v.FldValidators["inside_vip_port_config"] = VIPPortConfigValidator().Validate

	v.FldValidators["outside_vip_port_config"] = VIPPortConfigValidator().Validate

	v.FldValidators["dx_connect"] = DirectConnectTypeValidator().Validate

	v.FldValidators["deployment"] = DeploymentInfoValidator().Validate

	return v
}()

func AWSVPCTypeValidator() db.Validator {
	return DefaultAWSVPCTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AssumeRoleType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AssumeRoleType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AssumeRoleType) DeepCopy() *AssumeRoleType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AssumeRoleType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AssumeRoleType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AssumeRoleType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AssumeRoleTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAssumeRoleType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAssumeRoleType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AssumeRoleType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AssumeRoleType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["duration_seconds"]; exists {

		vOpts := append(opts, db.WithValidateField("duration_seconds"))
		if err := fv(ctx, m.GetDurationSeconds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["enable"]; exists {

		vOpts := append(opts, db.WithValidateField("enable"))
		if err := fv(ctx, m.GetEnable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["external_id"]; exists {

		vOpts := append(opts, db.WithValidateField("external_id"))
		if err := fv(ctx, m.GetExternalId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role_arn"]; exists {

		vOpts := append(opts, db.WithValidateField("role_arn"))
		if err := fv(ctx, m.GetRoleArn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["session_name"]; exists {

		vOpts := append(opts, db.WithValidateField("session_name"))
		if err := fv(ctx, m.GetSessionName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["session_tags"]; exists {

		vOpts := append(opts, db.WithValidateField("session_tags"))
		for key, value := range m.GetSessionTags() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAssumeRoleTypeValidator = func() *ValidateAssumeRoleType {
	v := &ValidateAssumeRoleType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AssumeRoleTypeValidator() db.Validator {
	return DefaultAssumeRoleTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CloudSubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloudSubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloudSubnetType) DeepCopy() *CloudSubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloudSubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloudSubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloudSubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloudSubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCloudSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloudSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloudSubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloudSubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["existing_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("existing_subnet_id"))
		if err := fv(ctx, m.GetExistingSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnet_param"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet_param"))
		if err := fv(ctx, m.GetSubnetParam(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloudSubnetTypeValidator = func() *ValidateCloudSubnetType {
	v := &ValidateCloudSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["subnet_param"] = ves_io_schema_views.CloudSubnetParamTypeValidator().Validate

	return v
}()

func CloudSubnetTypeValidator() db.Validator {
	return DefaultCloudSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeploymentInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeploymentInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeploymentInfo) DeepCopy() *DeploymentInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeploymentInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeploymentInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeploymentInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeploymentInfoValidator().Validate(ctx, m, opts...)
}

type ValidateDeploymentInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeploymentInfo) VpcIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vpc_id")
	}

	return validatorFn, nil
}

func (v *ValidateDeploymentInfo) SubnetIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for subnet_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.AWSSubnetIdsType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_views.AWSSubnetIdsTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for subnet_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.AWSSubnetIdsType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.AWSSubnetIdsType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated subnet_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items subnet_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDeploymentInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeploymentInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeploymentInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["subnet_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("subnet_ids"))
		if err := fv(ctx, m.GetSubnetIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_id"))
		if err := fv(ctx, m.GetVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeploymentInfoValidator = func() *ValidateDeploymentInfo {
	v := &ValidateDeploymentInfo{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVpcId := v.VpcIdValidationRuleHandler
	rulesVpcId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.pattern":   "^(vpc-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhVpcId(rulesVpcId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeploymentInfo.vpc_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vpc_id"] = vFn

	vrhSubnetIds := v.SubnetIdsValidationRuleHandler
	rulesSubnetIds := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.num_items": "0,1,3",
	}
	vFn, err = vrhSubnetIds(rulesSubnetIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DeploymentInfo.subnet_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subnet_ids"] = vFn

	return v
}()

func DeploymentInfoValidator() db.Validator {
	return DefaultDeploymentInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *DirectConnectType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DirectConnectType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DirectConnectType) DeepCopy() *DirectConnectType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DirectConnectType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DirectConnectType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DirectConnectType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DirectConnectTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDirectConnectType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDirectConnectType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DirectConnectType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DirectConnectType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["adn_dns_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("adn_dns_ip"))
		if err := fv(ctx, m.GetAdnDnsIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dx_gw_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("dx_gw_asn"))
		if err := fv(ctx, m.GetDxGwAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dx_gw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("dx_gw_id"))
		if err := fv(ctx, m.GetDxGwId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["enable"]; exists {

		vOpts := append(opts, db.WithValidateField("enable"))
		if err := fv(ctx, m.GetEnable(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["manage_dx_gw"]; exists {

		vOpts := append(opts, db.WithValidateField("manage_dx_gw"))
		if err := fv(ctx, m.GetManageDxGw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_network_name"]; exists {

		vOpts := append(opts, db.WithValidateField("private_network_name"))
		if err := fv(ctx, m.GetPrivateNetworkName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vif_ids"]; exists {

		vOpts := append(opts, db.WithValidateField("vif_ids"))
		for idx, item := range m.GetVifIds() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDirectConnectTypeValidator = func() *ValidateDirectConnectType {
	v := &ValidateDirectConnectType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["vif_ids"] = DirectConnectVifInfoValidator().Validate

	return v
}()

func DirectConnectTypeValidator() db.Validator {
	return DefaultDirectConnectTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DirectConnectVifInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DirectConnectVifInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DirectConnectVifInfo) DeepCopy() *DirectConnectVifInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DirectConnectVifInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DirectConnectVifInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DirectConnectVifInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DirectConnectVifInfoValidator().Validate(ctx, m, opts...)
}

type ValidateDirectConnectVifInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDirectConnectVifInfo) VifIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for vif_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vif_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vif_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vif_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDirectConnectVifInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DirectConnectVifInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DirectConnectVifInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["vif_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("vif_ids"))
		if err := fv(ctx, m.GetVifIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vif_region"]; exists {

		vOpts := append(opts, db.WithValidateField("vif_region"))
		if err := fv(ctx, m.GetVifRegion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDirectConnectVifInfoValidator = func() *ValidateDirectConnectVifInfo {
	v := &ValidateDirectConnectVifInfo{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVifIds := v.VifIdsValidationRuleHandler
	rulesVifIds := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_len": "50",
	}
	vFn, err = vrhVifIds(rulesVifIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DirectConnectVifInfo.vif_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vif_ids"] = vFn

	return v
}()

func DirectConnectVifInfoValidator() db.Validator {
	return DefaultDirectConnectVifInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *SubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubnetType) DeepCopy() *SubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["az"]; exists {

		vOpts := append(opts, db.WithValidateField("az"))
		if err := fv(ctx, m.GetAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_type"]; exists {

		vOpts := append(opts, db.WithValidateField("interface_type"))
		if err := fv(ctx, m.GetInterfaceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet"))
		if err := fv(ctx, m.GetSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volt_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_subnet_id"))
		if err := fv(ctx, m.GetVoltSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volt_vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_vpc_id"))
		if err := fv(ctx, m.GetVoltVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubnetTypeValidator = func() *ValidateSubnetType {
	v := &ValidateSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["subnet"] = CloudSubnetTypeValidator().Validate

	return v
}()

func SubnetTypeValidator() db.Validator {
	return DefaultSubnetTypeValidator
}
