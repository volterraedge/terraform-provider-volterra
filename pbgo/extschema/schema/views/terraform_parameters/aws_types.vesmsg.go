//
// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package terraform_parameters

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AWSInstanceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSInstanceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSInstanceType) DeepCopy() *AWSInstanceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSInstanceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSInstanceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSInstanceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSInstanceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSInstanceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSInstanceType) EbsVolumeSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ebs_volume_size")
	}

	return validatorFn, nil
}

func (v *ValidateAWSInstanceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSInstanceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSInstanceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ami_id"]; exists {

		vOpts := append(opts, db.WithValidateField("ami_id"))
		if err := fv(ctx, m.GetAmiId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ebs_volume_az"]; exists {

		vOpts := append(opts, db.WithValidateField("ebs_volume_az"))
		if err := fv(ctx, m.GetEbsVolumeAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ebs_volume_size"]; exists {

		vOpts := append(opts, db.WithValidateField("ebs_volume_size"))
		if err := fv(ctx, m.GetEbsVolumeSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["instance_type"]; exists {

		vOpts := append(opts, db.WithValidateField("instance_type"))
		if err := fv(ctx, m.GetInstanceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_count"]; exists {

		vOpts := append(opts, db.WithValidateField("node_count"))
		if err := fv(ctx, m.GetNodeCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("private_subnet_id"))
		if err := fv(ctx, m.GetPrivateSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("public_subnet_id"))
		if err := fv(ctx, m.GetPublicSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volt_node_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_node_id"))
		if err := fv(ctx, m.GetVoltNodeId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volt_vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_vpc_id"))
		if err := fv(ctx, m.GetVoltVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSInstanceTypeValidator = func() *ValidateAWSInstanceType {
	v := &ValidateAWSInstanceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEbsVolumeSize := v.EbsVolumeSizeValidationRuleHandler
	rulesEbsVolumeSize := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "1024",
	}
	vFn, err = vrhEbsVolumeSize(rulesEbsVolumeSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSInstanceType.ebs_volume_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ebs_volume_size"] = vFn

	return v
}()

func AWSInstanceTypeValidator() db.Validator {
	return DefaultAWSInstanceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSTGWInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSTGWInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSTGWInfoType) DeepCopy() *AWSTGWInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSTGWInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSTGWInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSTGWInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSTGWInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSTGWInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSTGWInfoType) TgwAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_asn")
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWInfoType) VolterraSiteAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_site_asn")
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSTGWInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSTGWInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["new_tgw"]; exists {

		vOpts := append(opts, db.WithValidateField("new_tgw"))
		if err := fv(ctx, m.GetNewTgw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_asn"))
		if err := fv(ctx, m.GetTgwAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_id"))
		if err := fv(ctx, m.GetTgwId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_site_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_site_asn"))
		if err := fv(ctx, m.GetVolterraSiteAsn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSTGWInfoTypeValidator = func() *ValidateAWSTGWInfoType {
	v := &ValidateAWSTGWInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTgwAsn := v.TgwAsnValidationRuleHandler
	rulesTgwAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt": "0",
	}
	vFn, err = vrhTgwAsn(rulesTgwAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWInfoType.tgw_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_asn"] = vFn

	vrhVolterraSiteAsn := v.VolterraSiteAsnValidationRuleHandler
	rulesVolterraSiteAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt": "0",
	}
	vFn, err = vrhVolterraSiteAsn(rulesVolterraSiteAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWInfoType.volterra_site_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_site_asn"] = vFn

	return v
}()

func AWSTGWInfoTypeValidator() db.Validator {
	return DefaultAWSTGWInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSTGWTunnelInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSTGWTunnelInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AWSTGWTunnelInfoType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetTunnel1Psk().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AWSTGWTunnelInfoType.tunnel1_psk")
	}

	if err := m.GetTunnel2Psk().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting AWSTGWTunnelInfoType.tunnel2_psk")
	}

	return nil
}

func (m *AWSTGWTunnelInfoType) DeepCopy() *AWSTGWTunnelInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSTGWTunnelInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSTGWTunnelInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSTGWTunnelInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSTGWTunnelInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSTGWTunnelInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSTGWTunnelInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSTGWTunnelInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSTGWTunnelInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["node_name"]; exists {

		vOpts := append(opts, db.WithValidateField("node_name"))
		if err := fv(ctx, m.GetNodeName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel1_inside_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel1_inside_prefix"))
		if err := fv(ctx, m.GetTunnel1InsidePrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel1_psk"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel1_psk"))
		if err := fv(ctx, m.GetTunnel1Psk(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel2_inside_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel2_inside_prefix"))
		if err := fv(ctx, m.GetTunnel2InsidePrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel2_psk"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel2_psk"))
		if err := fv(ctx, m.GetTunnel2Psk(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSTGWTunnelInfoTypeValidator = func() *ValidateAWSTGWTunnelInfoType {
	v := &ValidateAWSTGWTunnelInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["tunnel1_psk"] = ves_io_schema.SecretTypeValidator().Validate

	v.FldValidators["tunnel2_psk"] = ves_io_schema.SecretTypeValidator().Validate

	return v
}()

func AWSTGWTunnelInfoTypeValidator() db.Validator {
	return DefaultAWSTGWTunnelInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSTGWType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSTGWType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *AWSTGWType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	for idx, e := range m.GetTunnelInformation() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting AWSTGWType.tunnel_information idx %v", idx)
		}
	}

	for idx, e := range m.GetSvcsTunnelInformation() {
		if err := e.Redact(ctx); err != nil {
			return errors.Wrapf(err, "Redacting AWSTGWType.svcs_tunnel_information idx %v", idx)
		}
	}

	return nil
}

func (m *AWSTGWType) DeepCopy() *AWSTGWType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSTGWType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSTGWType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSTGWType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSTGWTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSTGWType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSTGWType) VpcIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for vpc_ids")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vpc_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vpc_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vpc_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSTGWType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSTGWType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_name"))
		if err := fv(ctx, m.GetAwsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_region"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_region"))
		if err := fv(ctx, m.GetAwsRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certified_hw"]; exists {

		vOpts := append(opts, db.WithValidateField("certified_hw"))
		if err := fv(ctx, m.GetCertifiedHw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fleet_label"]; exists {

		vOpts := append(opts, db.WithValidateField("fleet_label"))
		if err := fv(ctx, m.GetFleetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["master_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("master_nodes"))
		for idx, item := range m.GetMasterNodes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_name"]; exists {

		vOpts := append(opts, db.WithValidateField("site_name"))
		if err := fv(ctx, m.GetSiteName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ssh_key"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_key"))
		if err := fv(ctx, m.GetSshKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnets"]; exists {

		vOpts := append(opts, db.WithValidateField("subnets"))
		for idx, item := range m.GetSubnets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["svcs_tunnel_information"]; exists {

		vOpts := append(opts, db.WithValidateField("svcs_tunnel_information"))
		for idx, item := range m.GetSvcsTunnelInformation() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {

		vOpts := append(opts, db.WithValidateField("tags"))
		for key, value := range m.GetTags() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tgw"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw"))
		if err := fv(ctx, m.GetTgw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_information"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_information"))
		for idx, item := range m.GetTunnelInformation() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volt_vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_vpc_id"))
		if err := fv(ctx, m.GetVoltVpcId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc"))
		if err := fv(ctx, m.GetVpc(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("vpc_ids"))
		if err := fv(ctx, m.GetVpcIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["worker_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("worker_nodes"))
		if err := fv(ctx, m.GetWorkerNodes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSTGWTypeValidator = func() *ValidateAWSTGWType {
	v := &ValidateAWSTGWType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVpcIds := v.VpcIdsValidationRuleHandler
	rulesVpcIds := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_len": "64",
	}
	vFn, err = vrhVpcIds(rulesVpcIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWType.vpc_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vpc_ids"] = vFn

	v.FldValidators["tgw"] = AWSTGWInfoTypeValidator().Validate

	v.FldValidators["vpc"] = AWSVPCInfoTypeValidator().Validate

	v.FldValidators["subnets"] = SubnetTypeValidator().Validate

	v.FldValidators["master_nodes"] = AWSInstanceTypeValidator().Validate

	v.FldValidators["tunnel_information"] = AWSTGWTunnelInfoTypeValidator().Validate

	v.FldValidators["svcs_tunnel_information"] = AWSTGWTunnelInfoTypeValidator().Validate

	return v
}()

func AWSTGWTypeValidator() db.Validator {
	return DefaultAWSTGWTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCInfoType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCInfoType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCInfoType) DeepCopy() *AWSVPCInfoType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCInfoType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCInfoType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCInfoType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCInfoTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCInfoType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCInfoType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCInfoType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCInfoType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["new_vpc"]; exists {

		vOpts := append(opts, db.WithValidateField("new_vpc"))
		if err := fv(ctx, m.GetNewVpc(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_id"))
		if err := fv(ctx, m.GetVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCInfoTypeValidator = func() *ValidateAWSVPCInfoType {
	v := &ValidateAWSVPCInfoType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["new_vpc"] = ves_io_schema_views.AWSVPCParamsTypeValidator().Validate

	return v
}()

func AWSVPCInfoTypeValidator() db.Validator {
	return DefaultAWSVPCInfoTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPCType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPCType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPCType) DeepCopy() *AWSVPCType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPCType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPCType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPCType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPCTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPCType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPCType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPCType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPCType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_name"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_name"))
		if err := fv(ctx, m.GetAwsName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_region"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_region"))
		if err := fv(ctx, m.GetAwsRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["certified_hw"]; exists {

		vOpts := append(opts, db.WithValidateField("certified_hw"))
		if err := fv(ctx, m.GetCertifiedHw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fleet_label"]; exists {

		vOpts := append(opts, db.WithValidateField("fleet_label"))
		if err := fv(ctx, m.GetFleetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gateway_type"]; exists {

		vOpts := append(opts, db.WithValidateField("gateway_type"))
		if err := fv(ctx, m.GetGatewayType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip_port_config"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip_port_config"))
		for idx, item := range m.GetInsideVipPortConfig() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["master_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("master_nodes"))
		for idx, item := range m.GetMasterNodes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["outside_vip_port_config"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip_port_config"))
		for idx, item := range m.GetOutsideVipPortConfig() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_name"]; exists {

		vOpts := append(opts, db.WithValidateField("site_name"))
		if err := fv(ctx, m.GetSiteName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ssh_key"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_key"))
		if err := fv(ctx, m.GetSshKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnets"]; exists {

		vOpts := append(opts, db.WithValidateField("subnets"))
		for idx, item := range m.GetSubnets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {

		vOpts := append(opts, db.WithValidateField("tags"))
		for key, value := range m.GetTags() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volt_vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_vpc_id"))
		if err := fv(ctx, m.GetVoltVpcId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc"))
		if err := fv(ctx, m.GetVpc(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["worker_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("worker_nodes"))
		if err := fv(ctx, m.GetWorkerNodes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPCTypeValidator = func() *ValidateAWSVPCType {
	v := &ValidateAWSVPCType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["vpc"] = AWSVPCInfoTypeValidator().Validate

	v.FldValidators["subnets"] = SubnetTypeValidator().Validate

	v.FldValidators["master_nodes"] = AWSInstanceTypeValidator().Validate

	v.FldValidators["inside_vip_port_config"] = VIPPortConfigValidator().Validate

	v.FldValidators["outside_vip_port_config"] = VIPPortConfigValidator().Validate

	return v
}()

func AWSVPCTypeValidator() db.Validator {
	return DefaultAWSVPCTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CloudSubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CloudSubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CloudSubnetType) DeepCopy() *CloudSubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CloudSubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CloudSubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CloudSubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CloudSubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCloudSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCloudSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CloudSubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CloudSubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["existing_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("existing_subnet_id"))
		if err := fv(ctx, m.GetExistingSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnet_param"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet_param"))
		if err := fv(ctx, m.GetSubnetParam(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCloudSubnetTypeValidator = func() *ValidateCloudSubnetType {
	v := &ValidateCloudSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["subnet_param"] = ves_io_schema_views.CloudSubnetParamTypeValidator().Validate

	return v
}()

func CloudSubnetTypeValidator() db.Validator {
	return DefaultCloudSubnetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SubnetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubnetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubnetType) DeepCopy() *SubnetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubnetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubnetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubnetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubnetTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSubnetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubnetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubnetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubnetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["az"]; exists {

		vOpts := append(opts, db.WithValidateField("az"))
		if err := fv(ctx, m.GetAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_type"]; exists {

		vOpts := append(opts, db.WithValidateField("interface_type"))
		if err := fv(ctx, m.GetInterfaceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnet"]; exists {

		vOpts := append(opts, db.WithValidateField("subnet"))
		if err := fv(ctx, m.GetSubnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volt_subnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_subnet_id"))
		if err := fv(ctx, m.GetVoltSubnetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volt_vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("volt_vpc_id"))
		if err := fv(ctx, m.GetVoltVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubnetTypeValidator = func() *ValidateSubnetType {
	v := &ValidateSubnetType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["subnet"] = CloudSubnetTypeValidator().Validate

	return v
}()

func SubnetTypeValidator() db.Validator {
	return DefaultSubnetTypeValidator
}
