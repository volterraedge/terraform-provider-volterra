// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/terraform_parameters/gcp_types.proto

package terraform_parameters

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/certified_hardware"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GCP Terraform Instance Parameters
//
// x-displayName: "GCP Terraform Instance Parameters"
// Shape of the view terraform parameters specification
type GCPInstanceType struct {
	// F5XC Node Id
	//
	// x-displayName: "F5XC Node ID"
	// F5XC Node ID will be used to refer to this node in other TF parameters
	VoltNodeId string `protobuf:"bytes,1,opt,name=volt_node_id,json=voltNodeId,proto3" json:"volt_node_id,omitempty"`
	// Region id
	//
	// x-displayName: "Region id"
	// Region in which Cloud Instance site will be created
	VoltRegionId string `protobuf:"bytes,3,opt,name=volt_region_id,json=voltRegionId,proto3" json:"volt_region_id,omitempty"`
	// Public Subnet
	//
	// x-displayName: "Public Subnet"
	// Public subnet will be used as site local network
	PublicSubnetId *GCPSubnetChoice `protobuf:"bytes,4,opt,name=public_subnet_id,json=publicSubnetId,proto3" json:"public_subnet_id,omitempty"`
	// Private Subnet
	//
	// x-displayName: "Private Subnet"
	// Private subnet will be used as site inside network, when node type has two interfaces.
	PrivateSubnetId *GCPSubnetChoice `protobuf:"bytes,5,opt,name=private_subnet_id,json=privateSubnetId,proto3" json:"private_subnet_id,omitempty"`
	// Cloud Instance Type
	//
	// x-displayName: "Cloud Instance Type"
	// Cloud instance type like small, medium, large etc
	InstanceType string `protobuf:"bytes,6,opt,name=instance_type,json=instanceType,proto3" json:"instance_type,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// Disk size to be used for this instance
	DiskSize string `protobuf:"bytes,7,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// AMI ID
	//
	// x-displayName: "Image ID"
	// Amazon Machine Image ID
	ImageId string `protobuf:"bytes,8,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	// F5XC Worker Node count
	//
	// x-displayName: "F5XC Node count"
	// Desired number of node count used for worker nodes
	WorkerNodeCount uint32 `protobuf:"varint,9,opt,name=worker_node_count,json=workerNodeCount,proto3" json:"worker_node_count,omitempty"`
	// F5XC Master Node count
	//
	// x-displayName: "F5XC Node count"
	// Desired number of node count used for master nodes
	MasterNodeCount uint32 `protobuf:"varint,11,opt,name=master_node_count,json=masterNodeCount,proto3" json:"master_node_count,omitempty"`
	// List of Zones
	//
	// x-displayName: "Zone"
	// Zones in which Cloud Instance site will be created
	Zones []string `protobuf:"bytes,10,rep,name=zones,proto3" json:"zones,omitempty"`
}

func (m *GCPInstanceType) Reset()      { *m = GCPInstanceType{} }
func (*GCPInstanceType) ProtoMessage() {}
func (*GCPInstanceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_84b96cb7afb63b46, []int{0}
}
func (m *GCPInstanceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPInstanceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPInstanceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPInstanceType.Merge(m, src)
}
func (m *GCPInstanceType) XXX_Size() int {
	return m.Size()
}
func (m *GCPInstanceType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPInstanceType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPInstanceType proto.InternalMessageInfo

func (m *GCPInstanceType) GetVoltNodeId() string {
	if m != nil {
		return m.VoltNodeId
	}
	return ""
}

func (m *GCPInstanceType) GetVoltRegionId() string {
	if m != nil {
		return m.VoltRegionId
	}
	return ""
}

func (m *GCPInstanceType) GetPublicSubnetId() *GCPSubnetChoice {
	if m != nil {
		return m.PublicSubnetId
	}
	return nil
}

func (m *GCPInstanceType) GetPrivateSubnetId() *GCPSubnetChoice {
	if m != nil {
		return m.PrivateSubnetId
	}
	return nil
}

func (m *GCPInstanceType) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

func (m *GCPInstanceType) GetDiskSize() string {
	if m != nil {
		return m.DiskSize
	}
	return ""
}

func (m *GCPInstanceType) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

func (m *GCPInstanceType) GetWorkerNodeCount() uint32 {
	if m != nil {
		return m.WorkerNodeCount
	}
	return 0
}

func (m *GCPInstanceType) GetMasterNodeCount() uint32 {
	if m != nil {
		return m.MasterNodeCount
	}
	return 0
}

func (m *GCPInstanceType) GetZones() []string {
	if m != nil {
		return m.Zones
	}
	return nil
}

// GCP subnet Parameters
//
// x-displayName: "New GCP subetn Parameters"
// parameters to create subnet in VPC network.
type GCPSubnetParamType struct {
	// New Subnet name
	//
	// x-displayName: "subnet name"
	// Name for new subnet
	Subnet *views.GCPSubnetParamsType `protobuf:"bytes,1,opt,name=subnet,proto3" json:"subnet,omitempty"`
	// VPC network name
	//
	// x-displayName: "VPC network name"
	// To which VPC network create subnet
	NetworkName string `protobuf:"bytes,2,opt,name=network_name,json=networkName,proto3" json:"network_name,omitempty"`
	// Subnet region
	//
	// x-displayName: "Region name"
	// Subnets region
	Region string `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
}

func (m *GCPSubnetParamType) Reset()      { *m = GCPSubnetParamType{} }
func (*GCPSubnetParamType) ProtoMessage() {}
func (*GCPSubnetParamType) Descriptor() ([]byte, []int) {
	return fileDescriptor_84b96cb7afb63b46, []int{1}
}
func (m *GCPSubnetParamType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPSubnetParamType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPSubnetParamType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPSubnetParamType.Merge(m, src)
}
func (m *GCPSubnetParamType) XXX_Size() int {
	return m.Size()
}
func (m *GCPSubnetParamType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPSubnetParamType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPSubnetParamType proto.InternalMessageInfo

func (m *GCPSubnetParamType) GetSubnet() *views.GCPSubnetParamsType {
	if m != nil {
		return m.Subnet
	}
	return nil
}

func (m *GCPSubnetParamType) GetNetworkName() string {
	if m != nil {
		return m.NetworkName
	}
	return ""
}

func (m *GCPSubnetParamType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

// GCP VPC network choice
//
// x-displayName: "GCP VPC network"
// Parameters for GCP VPC network
type GCPVPCNetworkChoice struct {
	// New VPC Network
	//
	// x-displayName: "New VPC nerwork"
	// Parameters for creating new VPC network
	NetworkParam *views.GCPVPCNetworkParamsType `protobuf:"bytes,1,opt,name=network_param,json=networkParam,proto3" json:"network_param,omitempty"`
	// Existing NEtwork Name
	//
	// x-displayName: "Existing VPC network Name"
	// Information about existing VPC network
	ExistingNetwork *views.GCPVPCNetworkType `protobuf:"bytes,2,opt,name=existing_network,json=existingNetwork,proto3" json:"existing_network,omitempty"`
	// Interface Type
	//
	// x-displayName: "Interface Type"
	// Interface Type
	InterfaceType InterfaceType `protobuf:"varint,3,opt,name=interface_type,json=interfaceType,proto3,enum=ves.io.schema.views.terraform_parameters.InterfaceType" json:"interface_type,omitempty"`
}

func (m *GCPVPCNetworkChoice) Reset()      { *m = GCPVPCNetworkChoice{} }
func (*GCPVPCNetworkChoice) ProtoMessage() {}
func (*GCPVPCNetworkChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_84b96cb7afb63b46, []int{2}
}
func (m *GCPVPCNetworkChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPVPCNetworkChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPVPCNetworkChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPVPCNetworkChoice.Merge(m, src)
}
func (m *GCPVPCNetworkChoice) XXX_Size() int {
	return m.Size()
}
func (m *GCPVPCNetworkChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPVPCNetworkChoice.DiscardUnknown(m)
}

var xxx_messageInfo_GCPVPCNetworkChoice proto.InternalMessageInfo

func (m *GCPVPCNetworkChoice) GetNetworkParam() *views.GCPVPCNetworkParamsType {
	if m != nil {
		return m.NetworkParam
	}
	return nil
}

func (m *GCPVPCNetworkChoice) GetExistingNetwork() *views.GCPVPCNetworkType {
	if m != nil {
		return m.ExistingNetwork
	}
	return nil
}

func (m *GCPVPCNetworkChoice) GetInterfaceType() InterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return INTERFACE_INSIDE
}

// GCP Subnet choice
//
// x-displayName: "GCP Subnet"
// Parameters for GCP Subnet
type GCPSubnetChoice struct {
	// New Subnet
	//
	// x-displayName: "New Subnet"
	// Parameters for creating new subnet
	SubnetParam *GCPSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam,proto3" json:"subnet_param,omitempty"`
	// Existing NEtwork Name
	//
	// x-displayName: "Existing Subnet"
	// Information about existing subnet
	ExistingSubnet *views.GCPSubnetType `protobuf:"bytes,2,opt,name=existing_subnet,json=existingSubnet,proto3" json:"existing_subnet,omitempty"`
	// Interface Type
	//
	// x-displayName: "Interface Type"
	// Interface Type
	InterfaceType InterfaceType `protobuf:"varint,3,opt,name=interface_type,json=interfaceType,proto3,enum=ves.io.schema.views.terraform_parameters.InterfaceType" json:"interface_type,omitempty"`
}

func (m *GCPSubnetChoice) Reset()      { *m = GCPSubnetChoice{} }
func (*GCPSubnetChoice) ProtoMessage() {}
func (*GCPSubnetChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_84b96cb7afb63b46, []int{3}
}
func (m *GCPSubnetChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPSubnetChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPSubnetChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPSubnetChoice.Merge(m, src)
}
func (m *GCPSubnetChoice) XXX_Size() int {
	return m.Size()
}
func (m *GCPSubnetChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPSubnetChoice.DiscardUnknown(m)
}

var xxx_messageInfo_GCPSubnetChoice proto.InternalMessageInfo

func (m *GCPSubnetChoice) GetSubnetParam() *GCPSubnetParamType {
	if m != nil {
		return m.SubnetParam
	}
	return nil
}

func (m *GCPSubnetChoice) GetExistingSubnet() *views.GCPSubnetType {
	if m != nil {
		return m.ExistingSubnet
	}
	return nil
}

func (m *GCPSubnetChoice) GetInterfaceType() InterfaceType {
	if m != nil {
		return m.InterfaceType
	}
	return INTERFACE_INSIDE
}

// Terraform GCP VPC Site Parameters
//
// x-displayName: "Terraform Object Parameters"
// Terraform parameters to create site in GCP.
type GCPVpcSiteType struct {
	// Site Name
	//
	// x-displayName: "Site Name"
	// Name of the site object to be created
	SiteName string `protobuf:"bytes,1,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
	// GCP Unique Name
	//
	// x-displayName: "GCP Unique Name"
	// GCP unique name which will be used to create the cloud resource objects on gcp"
	GcpName string `protobuf:"bytes,15,opt,name=gcp_name,json=gcpName,proto3" json:"gcp_name,omitempty"`
	// Outside GCP network
	//
	// x-displayName: "GCP outside network"
	// Outside GCP network
	GcpVpcNetworkOutside *GCPVPCNetworkChoice `protobuf:"bytes,2,opt,name=gcp_vpc_network_outside,json=gcpVpcNetworkOutside,proto3" json:"gcp_vpc_network_outside,omitempty"`
	// Inside GCP network
	//
	// x-displayName: "GCP inside network"
	// Inside GCP network
	GcpVpcNetworkInside *GCPVPCNetworkChoice `protobuf:"bytes,17,opt,name=gcp_vpc_network_inside,json=gcpVpcNetworkInside,proto3" json:"gcp_vpc_network_inside,omitempty"`
	// Certified Hardware
	//
	// x-displayName: "Certified Hardware"
	// Certified Hardware to be used to create this site.
	CertifiedHw string `protobuf:"bytes,4,opt,name=certified_hw,json=certifiedHw,proto3" json:"certified_hw,omitempty"`
	// GCP Region
	//
	// x-displayName: "GCP Region"
	// GCP region
	GcpRegion string `protobuf:"bytes,5,opt,name=gcp_region,json=gcpRegion,proto3" json:"gcp_region,omitempty"`
	// Outside Subnet
	//
	// x-displayName: "Outside Subnet"
	// Outside Subnet
	SubnetOutside *GCPSubnetChoice `protobuf:"bytes,8,opt,name=subnet_outside,json=subnetOutside,proto3" json:"subnet_outside,omitempty"`
	// Inside Subnet
	//
	// x-displayName: "Inside Subnet"
	// Inside Subnet
	SubnetInside *GCPSubnetChoice `protobuf:"bytes,16,opt,name=subnet_inside,json=subnetInside,proto3" json:"subnet_inside,omitempty"`
	// Master Node Parameters
	//
	// x-displayName: "Master Node Parameters"
	// Master Node Parameters in this Site that TF script needs to instantiate
	Node *GCPInstanceType `protobuf:"bytes,9,opt,name=node,proto3" json:"node,omitempty"`
	// Worker Node Scaling
	//
	// x-displayName: "Worker Node Scaling"
	// Number of Maximum Worker Nodes for Auto Scale Configuration
	WorkerNodes uint32 `protobuf:"varint,14,opt,name=worker_nodes,json=workerNodes,proto3" json:"worker_nodes,omitempty"`
	// Gateway Type
	//
	// x-displayName: "Gateway Type"
	// Gateway Type
	GatewayType CloudGatewayType `protobuf:"varint,11,opt,name=gateway_type,json=gatewayType,proto3,enum=ves.io.schema.views.terraform_parameters.CloudGatewayType" json:"gateway_type,omitempty"`
	// Public SSH key
	//
	// x-displayName: "Public SSH key"
	// Public SSH key for accessing the site.
	SshKey string `protobuf:"bytes,13,opt,name=ssh_key,json=sshKey,proto3" json:"ssh_key,omitempty"`
	// Admin Password
	//
	// x-displayName: "Admin Password"
	// Admin Password. This a plain text key, only used by terraform job to set it in memory.
	// This is set before the terraform execution is triggered
	AdminPassword string `protobuf:"bytes,50,opt,name=admin_password,json=adminPassword,proto3" json:"admin_password,omitempty"`
	// Admin Password B64
	//
	// x-displayName: "Admin Password B64"
	// Admin Password in b64 format. This field will only be set when user configures the key in clear secret format ( To be decoded in terraform job)
	AdminPasswordClearB64 string `protobuf:"bytes,51,opt,name=admin_password_clear_b64,json=adminPasswordClearB64,proto3" json:"admin_password_clear_b64,omitempty"`
	// Admin Password Blindfolded
	//
	// x-displayName: "Admin Password Blindfolded"
	// Blindfolded Admin Password. This field will only be set when user configures the key as blindfolded secret ( To be decrypted in terraform job)
	AdminPasswordBlindfolded string `protobuf:"bytes,52,opt,name=admin_password_blindfolded,json=adminPasswordBlindfolded,proto3" json:"admin_password_blindfolded,omitempty"`
	// GCP Labels
	//
	// x-displayName: "GCP Labels"
	// GCP Labels is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources.
	Labels map[string]string `protobuf:"bytes,19,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Enable Multi Node in AZ
	//
	// x-displayName: "Enable Multi Node in AZ"
	// Flag is enabled when multiple nodes are configured in single or two Availability Zones
	MultiNodeNonStdAz bool `protobuf:"varint,20,opt,name=multi_node_non_std_az,json=multiNodeNonStdAz,proto3" json:"multi_node_non_std_az,omitempty"`
	// GCP Interconnect Parameters
	// x-displayName: "GCP Interconnect Parameters"
	// GCP Interconnect Parameters
	Interconnect *GCPInterconnectType `protobuf:"bytes,21,opt,name=interconnect,proto3" json:"interconnect,omitempty"`
}

func (m *GCPVpcSiteType) Reset()      { *m = GCPVpcSiteType{} }
func (*GCPVpcSiteType) ProtoMessage() {}
func (*GCPVpcSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_84b96cb7afb63b46, []int{4}
}
func (m *GCPVpcSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPVpcSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPVpcSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPVpcSiteType.Merge(m, src)
}
func (m *GCPVpcSiteType) XXX_Size() int {
	return m.Size()
}
func (m *GCPVpcSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPVpcSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPVpcSiteType proto.InternalMessageInfo

func (m *GCPVpcSiteType) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

func (m *GCPVpcSiteType) GetGcpName() string {
	if m != nil {
		return m.GcpName
	}
	return ""
}

func (m *GCPVpcSiteType) GetGcpVpcNetworkOutside() *GCPVPCNetworkChoice {
	if m != nil {
		return m.GcpVpcNetworkOutside
	}
	return nil
}

func (m *GCPVpcSiteType) GetGcpVpcNetworkInside() *GCPVPCNetworkChoice {
	if m != nil {
		return m.GcpVpcNetworkInside
	}
	return nil
}

func (m *GCPVpcSiteType) GetCertifiedHw() string {
	if m != nil {
		return m.CertifiedHw
	}
	return ""
}

func (m *GCPVpcSiteType) GetGcpRegion() string {
	if m != nil {
		return m.GcpRegion
	}
	return ""
}

func (m *GCPVpcSiteType) GetSubnetOutside() *GCPSubnetChoice {
	if m != nil {
		return m.SubnetOutside
	}
	return nil
}

func (m *GCPVpcSiteType) GetSubnetInside() *GCPSubnetChoice {
	if m != nil {
		return m.SubnetInside
	}
	return nil
}

func (m *GCPVpcSiteType) GetNode() *GCPInstanceType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *GCPVpcSiteType) GetWorkerNodes() uint32 {
	if m != nil {
		return m.WorkerNodes
	}
	return 0
}

func (m *GCPVpcSiteType) GetGatewayType() CloudGatewayType {
	if m != nil {
		return m.GatewayType
	}
	return INGRESS_GATEWAY
}

func (m *GCPVpcSiteType) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func (m *GCPVpcSiteType) GetAdminPassword() string {
	if m != nil {
		return m.AdminPassword
	}
	return ""
}

func (m *GCPVpcSiteType) GetAdminPasswordClearB64() string {
	if m != nil {
		return m.AdminPasswordClearB64
	}
	return ""
}

func (m *GCPVpcSiteType) GetAdminPasswordBlindfolded() string {
	if m != nil {
		return m.AdminPasswordBlindfolded
	}
	return ""
}

func (m *GCPVpcSiteType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *GCPVpcSiteType) GetMultiNodeNonStdAz() bool {
	if m != nil {
		return m.MultiNodeNonStdAz
	}
	return false
}

func (m *GCPVpcSiteType) GetInterconnect() *GCPInterconnectType {
	if m != nil {
		return m.Interconnect
	}
	return nil
}

// GCP Interconnect Parameters
// x-displayName: "GCP Interconnect Parameters"
// GCP Interconnect Parameters
type GCPInterconnectType struct {
	// Cloud Link Network Name
	//
	// x-displayName: "Cloud Link Network Name"
	// x-example: "cloud-private-ntw"
	// Cloud Link Network Name for private access connectivity to F5XC ADN.
	PrivateNetworkName string `protobuf:"bytes,1,opt,name=private_network_name,json=privateNetworkName,proto3" json:"private_network_name,omitempty"`
	// Cloud Link ADN DNS IP
	//
	// x-displayName: "Cloud Link DNS IP"
	// x-example: "10.0.0.1"
	// Cloud Link ADN DNS IP, which will be used to resolve domains
	AdnDnsIp string `protobuf:"bytes,2,opt,name=adn_dns_ip,json=adnDnsIp,proto3" json:"adn_dns_ip,omitempty"`
}

func (m *GCPInterconnectType) Reset()      { *m = GCPInterconnectType{} }
func (*GCPInterconnectType) ProtoMessage() {}
func (*GCPInterconnectType) Descriptor() ([]byte, []int) {
	return fileDescriptor_84b96cb7afb63b46, []int{5}
}
func (m *GCPInterconnectType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPInterconnectType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPInterconnectType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPInterconnectType.Merge(m, src)
}
func (m *GCPInterconnectType) XXX_Size() int {
	return m.Size()
}
func (m *GCPInterconnectType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPInterconnectType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPInterconnectType proto.InternalMessageInfo

func (m *GCPInterconnectType) GetPrivateNetworkName() string {
	if m != nil {
		return m.PrivateNetworkName
	}
	return ""
}

func (m *GCPInterconnectType) GetAdnDnsIp() string {
	if m != nil {
		return m.AdnDnsIp
	}
	return ""
}

func init() {
	proto.RegisterType((*GCPInstanceType)(nil), "ves.io.schema.views.terraform_parameters.GCPInstanceType")
	golang_proto.RegisterType((*GCPInstanceType)(nil), "ves.io.schema.views.terraform_parameters.GCPInstanceType")
	proto.RegisterType((*GCPSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.GCPSubnetParamType")
	golang_proto.RegisterType((*GCPSubnetParamType)(nil), "ves.io.schema.views.terraform_parameters.GCPSubnetParamType")
	proto.RegisterType((*GCPVPCNetworkChoice)(nil), "ves.io.schema.views.terraform_parameters.GCPVPCNetworkChoice")
	golang_proto.RegisterType((*GCPVPCNetworkChoice)(nil), "ves.io.schema.views.terraform_parameters.GCPVPCNetworkChoice")
	proto.RegisterType((*GCPSubnetChoice)(nil), "ves.io.schema.views.terraform_parameters.GCPSubnetChoice")
	golang_proto.RegisterType((*GCPSubnetChoice)(nil), "ves.io.schema.views.terraform_parameters.GCPSubnetChoice")
	proto.RegisterType((*GCPVpcSiteType)(nil), "ves.io.schema.views.terraform_parameters.GCPVpcSiteType")
	golang_proto.RegisterType((*GCPVpcSiteType)(nil), "ves.io.schema.views.terraform_parameters.GCPVpcSiteType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.GCPVpcSiteType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.views.terraform_parameters.GCPVpcSiteType.LabelsEntry")
	proto.RegisterType((*GCPInterconnectType)(nil), "ves.io.schema.views.terraform_parameters.GCPInterconnectType")
	golang_proto.RegisterType((*GCPInterconnectType)(nil), "ves.io.schema.views.terraform_parameters.GCPInterconnectType")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/terraform_parameters/gcp_types.proto", fileDescriptor_84b96cb7afb63b46)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/terraform_parameters/gcp_types.proto", fileDescriptor_84b96cb7afb63b46)
}

var fileDescriptor_84b96cb7afb63b46 = []byte{
	// 1265 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xcf, 0xc6, 0x6e, 0xea, 0x8c, 0x63, 0xc7, 0x99, 0xa6, 0xed, 0x26, 0xed, 0x77, 0xbf, 0x26,
	0x14, 0x64, 0xa1, 0xd6, 0xae, 0xd2, 0xa8, 0xbf, 0x04, 0x12, 0x8d, 0x8b, 0x82, 0x53, 0x08, 0xe9,
	0x06, 0xf5, 0x80, 0xa0, 0xcb, 0x78, 0x77, 0xb2, 0x19, 0x65, 0x3d, 0xb3, 0xda, 0x19, 0xdb, 0x75,
	0x24, 0x24, 0x24, 0xfe, 0x01, 0x38, 0x83, 0xc4, 0x95, 0x3f, 0x83, 0x63, 0x8f, 0x3d, 0xf6, 0x48,
	0x9d, 0x0b, 0xc7, 0x9e, 0x38, 0xa3, 0xf9, 0xb1, 0xf6, 0x3a, 0x04, 0x9a, 0x36, 0x70, 0xdb, 0x79,
	0xef, 0x7d, 0x3e, 0x6f, 0xe6, 0x33, 0xef, 0xbd, 0x59, 0x70, 0xbb, 0x87, 0x79, 0x9d, 0xb0, 0x06,
	0xf7, 0xf7, 0x70, 0x07, 0x35, 0x7a, 0x04, 0xf7, 0x79, 0x43, 0xe0, 0x24, 0x41, 0xbb, 0x2c, 0xe9,
	0x78, 0x31, 0x4a, 0x50, 0x07, 0x0b, 0x9c, 0xf0, 0x46, 0xe8, 0xc7, 0x9e, 0x18, 0xc4, 0x98, 0xd7,
	0xe3, 0x84, 0x09, 0x06, 0x6b, 0x1a, 0x59, 0xd7, 0xc8, 0xba, 0x42, 0xd6, 0x8f, 0x43, 0x2e, 0x5f,
	0x0b, 0x89, 0xd8, 0xeb, 0xb6, 0xeb, 0x3e, 0xeb, 0x34, 0x42, 0x16, 0xb2, 0x86, 0x22, 0x68, 0x77,
	0x77, 0xd5, 0x4a, 0x2d, 0xd4, 0x97, 0x26, 0x5e, 0x5e, 0x0a, 0x19, 0x0b, 0x23, 0x3c, 0x8e, 0x42,
	0x74, 0x60, 0x5c, 0x57, 0x27, 0x77, 0xeb, 0xe3, 0x44, 0x90, 0x5d, 0x82, 0x03, 0x6f, 0x0f, 0x25,
	0x41, 0x1f, 0x25, 0xb8, 0x91, 0xd9, 0xe1, 0xf2, 0xa5, 0xc9, 0x68, 0x16, 0x0b, 0xc2, 0x68, 0xea,
	0x5c, 0x9a, 0x74, 0x66, 0x71, 0x97, 0x8f, 0x68, 0x82, 0x22, 0x12, 0x20, 0x81, 0x8d, 0xb7, 0xfa,
	0x57, 0xc5, 0xbc, 0x49, 0xea, 0x2b, 0xc7, 0x69, 0xca, 0x89, 0xc0, 0x59, 0xfd, 0x96, 0xd7, 0x4e,
	0xac, 0x7c, 0x16, 0xf5, 0xff, 0x63, 0x51, 0xe3, 0x80, 0x95, 0x3f, 0x72, 0x60, 0x7e, 0xa3, 0xb9,
	0xdd, 0xa2, 0x5c, 0x20, 0xea, 0xe3, 0xcf, 0x07, 0x31, 0x86, 0x55, 0x30, 0xd7, 0x63, 0x91, 0xf0,
	0x28, 0x0b, 0xb0, 0x47, 0x02, 0xdb, 0xaa, 0x5a, 0xb5, 0x59, 0x17, 0x48, 0xdb, 0x16, 0x0b, 0x70,
	0x2b, 0x80, 0x57, 0x40, 0x59, 0x45, 0x24, 0x38, 0x24, 0x8c, 0xca, 0x98, 0x9c, 0x8a, 0x51, 0x38,
	0x57, 0x19, 0x5b, 0x01, 0xf4, 0x41, 0x25, 0xee, 0xb6, 0x23, 0xe2, 0x7b, 0xbc, 0xdb, 0xa6, 0x58,
	0xc8, 0xb8, 0x7c, 0xd5, 0xaa, 0x15, 0x57, 0xef, 0xd4, 0x4f, 0x5a, 0x0d, 0xf5, 0x8d, 0xe6, 0xf6,
	0x8e, 0x42, 0x37, 0xf7, 0x18, 0xf1, 0xb1, 0x5b, 0xd6, 0x94, 0xda, 0xd6, 0x0a, 0x20, 0x06, 0x0b,
	0x71, 0x42, 0x7a, 0x48, 0xe0, 0x4c, 0x96, 0x33, 0xa7, 0xcd, 0x32, 0x6f, 0x38, 0x47, 0x69, 0xde,
	0x06, 0x25, 0x62, 0x34, 0x52, 0xd7, 0x62, 0xcf, 0xe8, 0x03, 0x93, 0xac, 0x70, 0x97, 0xc0, 0x6c,
	0x40, 0xf8, 0xbe, 0xc7, 0xc9, 0x01, 0xb6, 0xcf, 0xaa, 0x80, 0x82, 0x34, 0xec, 0x90, 0x03, 0x0c,
	0x97, 0x40, 0x81, 0x74, 0x50, 0xa8, 0x14, 0x2d, 0x28, 0xdf, 0x59, 0xb5, 0x6e, 0x05, 0xf0, 0x3d,
	0xb0, 0xd0, 0x67, 0xc9, 0x3e, 0x4e, 0xb4, 0xe4, 0x3e, 0xeb, 0x52, 0x61, 0xcf, 0x56, 0xad, 0x5a,
	0xc9, 0x9d, 0xd7, 0x0e, 0xa9, 0x7b, 0x53, 0x9a, 0x65, 0x6c, 0x07, 0x71, 0x31, 0x19, 0x5b, 0xd4,
	0xb1, 0xda, 0x31, 0x8e, 0x5d, 0x04, 0x67, 0x0e, 0x18, 0xc5, 0xdc, 0x06, 0xd5, 0x5c, 0x6d, 0xd6,
	0xd5, 0x8b, 0xcd, 0x7c, 0x61, 0xba, 0x92, 0x5b, 0xf9, 0xc1, 0x02, 0x70, 0x74, 0xea, 0x6d, 0xa9,
	0x84, 0x3a, 0xc2, 0x87, 0x60, 0x46, 0xcb, 0xa8, 0x6e, 0xbd, 0xb8, 0x5a, 0x3b, 0x56, 0xc3, 0x49,
	0x20, 0x97, 0x48, 0xd7, 0xe0, 0xe0, 0x5b, 0x60, 0x8e, 0x62, 0x21, 0xb7, 0xed, 0x51, 0xd4, 0xc1,
	0xf6, 0xb4, 0x3a, 0x6b, 0xd1, 0xd8, 0xb6, 0x50, 0x07, 0xc3, 0x0b, 0x60, 0x46, 0x57, 0x8e, 0x29,
	0x1b, 0xb3, 0x5a, 0xf9, 0x71, 0x1a, 0x9c, 0xdb, 0x68, 0x6e, 0x3f, 0xda, 0x6e, 0x6e, 0xe9, 0x68,
	0x7d, 0x1b, 0xf0, 0x21, 0x28, 0xa5, 0x94, 0xea, 0xce, 0xcc, 0xde, 0xae, 0xfe, 0xdd, 0xde, 0xc6,
	0x04, 0x99, 0xfd, 0xa5, 0xbb, 0x52, 0x26, 0xf8, 0x10, 0x54, 0xf0, 0x13, 0xc2, 0x05, 0xa1, 0xa1,
	0x67, 0x1c, 0x6a, 0xa7, 0xc5, 0xd5, 0x77, 0x5f, 0xcd, 0xaa, 0xf8, 0xe6, 0x53, 0xbc, 0x31, 0xc2,
	0xc7, 0xa0, 0x4c, 0xa8, 0xc0, 0xc9, 0x2e, 0x4a, 0x6b, 0x44, 0x9e, 0xae, 0xbc, 0x7a, 0xeb, 0xe4,
	0x65, 0xd8, 0x4a, 0xf1, 0x2a, 0x43, 0x89, 0x64, 0x97, 0x2b, 0x3f, 0x4f, 0xab, 0x56, 0xcd, 0xd6,
	0x29, 0xf4, 0xc0, 0x9c, 0xa9, 0xfa, 0xac, 0x30, 0xef, 0xbf, 0x41, 0xe1, 0x8f, 0x4a, 0xc0, 0x2d,
	0xf2, 0xb1, 0x01, 0x3e, 0x00, 0xa3, 0x73, 0x9a, 0xfe, 0x32, 0x32, 0xad, 0xfc, 0x73, 0x61, 0x28,
	0xa6, 0x72, 0x0a, 0xd5, 0xb6, 0xff, 0x5c, 0xa1, 0xef, 0x00, 0x28, 0xcb, 0x8b, 0x8a, 0xfd, 0x1d,
	0x22, 0x46, 0x2d, 0xa9, 0x46, 0xa9, 0x2a, 0x45, 0x3d, 0xc8, 0x0a, 0xd2, 0xa0, 0xea, 0x70, 0x09,
	0x14, 0xe4, 0x33, 0xa5, 0x7c, 0xf3, 0xba, 0x25, 0x43, 0x3f, 0x56, 0x2e, 0x01, 0x2e, 0x4a, 0x57,
	0x2f, 0xf6, 0xd3, 0xf2, 0xf0, 0x58, 0x57, 0x70, 0x12, 0x60, 0x73, 0xfe, 0x0f, 0x5e, 0x4b, 0xe3,
	0xa3, 0x25, 0xed, 0x2e, 0x86, 0x7e, 0xfc, 0x28, 0xf6, 0x8d, 0xf1, 0x33, 0x4d, 0x0d, 0x13, 0x70,
	0xe1, 0x68, 0x56, 0x42, 0x55, 0xd2, 0x85, 0x7f, 0x23, 0xe9, 0xb9, 0x89, 0xa4, 0x2d, 0xc5, 0x2c,
	0xfb, 0x35, 0xf3, 0x30, 0xf6, 0xd5, 0x84, 0x9e, 0x75, 0x8b, 0x23, 0xdb, 0xc7, 0x7d, 0xf8, 0x3f,
	0x00, 0xe4, 0xb6, 0x4c, 0xcf, 0x9e, 0x51, 0x01, 0xb3, 0xa1, 0x1f, 0xeb, 0x49, 0x0f, 0xbf, 0x06,
	0x65, 0x53, 0x84, 0xa9, 0x44, 0x85, 0xd3, 0xce, 0xdf, 0x92, 0x26, 0x4c, 0x75, 0x79, 0x0c, 0x4a,
	0xe9, 0x70, 0xd7, 0x72, 0x54, 0x4e, 0x9b, 0xc0, 0xb4, 0x8d, 0xd1, 0xe0, 0x53, 0x90, 0x97, 0xd3,
	0x54, 0xcd, 0xdc, 0xd7, 0xa5, 0xcd, 0x3e, 0x9d, 0xae, 0xa2, 0x91, 0x92, 0x66, 0xe6, 0x39, 0xb7,
	0xcb, 0x6a, 0x3c, 0x17, 0xc7, 0xa3, 0x9c, 0xc3, 0xaf, 0xc0, 0x5c, 0x88, 0x04, 0xee, 0xa3, 0x81,
	0x6e, 0x84, 0xa2, 0x6a, 0x84, 0xbb, 0x27, 0xcf, 0xdc, 0x8c, 0x58, 0x37, 0xd8, 0xd0, 0x14, 0xba,
	0x6d, 0xc3, 0xf1, 0x02, 0x5e, 0x04, 0x67, 0x39, 0xdf, 0xf3, 0xf6, 0xf1, 0xc0, 0x2e, 0xe9, 0x11,
	0xcb, 0xf9, 0xde, 0x03, 0x3c, 0x80, 0xef, 0x80, 0x32, 0x0a, 0x3a, 0x84, 0x7a, 0x31, 0xe2, 0xbc,
	0xcf, 0x92, 0xc0, 0x5e, 0x55, 0xfe, 0x92, 0xb2, 0x6e, 0x1b, 0x23, 0xbc, 0x05, 0xec, 0xc9, 0x30,
	0xcf, 0x8f, 0x30, 0x4a, 0xbc, 0xf6, 0xcd, 0x35, 0xfb, 0x86, 0x02, 0x9c, 0x9f, 0x00, 0x34, 0xa5,
	0x77, 0xfd, 0xe6, 0x1a, 0xbc, 0x07, 0x96, 0x8f, 0x00, 0xdb, 0x11, 0xa1, 0xc1, 0x2e, 0x8b, 0x02,
	0x1c, 0xd8, 0x6b, 0x12, 0xba, 0x9e, 0x7b, 0xfa, 0x8d, 0xe5, 0xda, 0x13, 0xf8, 0xf5, 0x71, 0x10,
	0xfc, 0x12, 0xcc, 0x44, 0xa8, 0x8d, 0x23, 0x6e, 0x9f, 0xab, 0xe6, 0x6a, 0xc5, 0xd5, 0xfb, 0xaf,
	0x57, 0xf4, 0xe3, 0xe6, 0xaf, 0x7f, 0xa2, 0x68, 0x3e, 0xa2, 0x22, 0x19, 0xb8, 0x86, 0x13, 0x5e,
	0x07, 0xe7, 0x3b, 0xdd, 0x48, 0x10, 0xfd, 0x7c, 0x52, 0x46, 0x3d, 0x2e, 0x02, 0x0f, 0x1d, 0xd8,
	0x8b, 0x55, 0xab, 0x56, 0x70, 0x17, 0x94, 0x53, 0xde, 0xd1, 0x16, 0xa3, 0x3b, 0x22, 0xb8, 0x77,
	0x00, 0x11, 0x98, 0x53, 0x63, 0xc6, 0x67, 0x94, 0x62, 0x5f, 0xd8, 0xe7, 0xdf, 0xa0, 0x15, 0x5b,
	0x19, 0x02, 0xfd, 0x1a, 0x65, 0x29, 0x97, 0xef, 0x80, 0x62, 0x66, 0xaf, 0xb0, 0x02, 0x72, 0xf2,
	0xe6, 0xf4, 0xb8, 0x92, 0x9f, 0xf2, 0x25, 0xef, 0xa1, 0xa8, 0x9b, 0xbe, 0xa6, 0x7a, 0x71, 0x77,
	0xfa, 0xb6, 0xb5, 0x99, 0x2f, 0xe4, 0x2a, 0xf9, 0xcd, 0x7c, 0x01, 0x54, 0x8a, 0x9b, 0xf9, 0xc2,
	0x5c, 0xa5, 0xb4, 0x82, 0xd5, 0x23, 0x7a, 0x34, 0x23, 0xbc, 0x0e, 0x16, 0xd3, 0x1f, 0xa5, 0x89,
	0xf7, 0x59, 0x67, 0x81, 0xc6, 0xb7, 0x95, 0x79, 0xa6, 0x2f, 0x03, 0x80, 0x02, 0xea, 0x05, 0x94,
	0x7b, 0x24, 0x36, 0x99, 0x0b, 0x28, 0xa0, 0xf7, 0x29, 0x6f, 0xc5, 0xeb, 0x3f, 0x59, 0xcf, 0x5e,
	0x38, 0x53, 0xcf, 0x5f, 0x38, 0x53, 0x2f, 0x5f, 0x38, 0xd6, 0xb7, 0x43, 0xc7, 0xfa, 0x65, 0xe8,
	0x58, 0x4f, 0x87, 0x8e, 0xf5, 0x6c, 0xe8, 0x58, 0xcf, 0x87, 0x8e, 0xf5, 0xdb, 0xd0, 0xb1, 0x7e,
	0x1f, 0x3a, 0x53, 0x2f, 0x87, 0x8e, 0xf5, 0xfd, 0xa1, 0x33, 0xf5, 0xeb, 0xa1, 0x63, 0x3d, 0x3b,
	0x74, 0xa6, 0x9e, 0x1f, 0x3a, 0x53, 0x5f, 0x3c, 0x0e, 0x59, 0xbc, 0x1f, 0xd6, 0xe5, 0x0f, 0xa3,
	0xd4, 0xac, 0xde, 0xcd, 0xfc, 0xcd, 0x5e, 0x8b, 0x13, 0xd6, 0x23, 0x01, 0x4e, 0xae, 0xa5, 0xee,
	0x46, 0xdc, 0x0e, 0x59, 0x03, 0x3f, 0x11, 0xe6, 0x47, 0xf6, 0x95, 0x7f, 0xc1, 0xed, 0x19, 0xf5,
	0x7f, 0x7b, 0xe3, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9e, 0xcc, 0x87, 0xf2, 0xb2, 0x0c, 0x00,
	0x00,
}

func (this *GCPInstanceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPInstanceType)
	if !ok {
		that2, ok := that.(GCPInstanceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VoltNodeId != that1.VoltNodeId {
		return false
	}
	if this.VoltRegionId != that1.VoltRegionId {
		return false
	}
	if !this.PublicSubnetId.Equal(that1.PublicSubnetId) {
		return false
	}
	if !this.PrivateSubnetId.Equal(that1.PrivateSubnetId) {
		return false
	}
	if this.InstanceType != that1.InstanceType {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	if this.ImageId != that1.ImageId {
		return false
	}
	if this.WorkerNodeCount != that1.WorkerNodeCount {
		return false
	}
	if this.MasterNodeCount != that1.MasterNodeCount {
		return false
	}
	if len(this.Zones) != len(that1.Zones) {
		return false
	}
	for i := range this.Zones {
		if this.Zones[i] != that1.Zones[i] {
			return false
		}
	}
	return true
}
func (this *GCPSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetParamType)
	if !ok {
		that2, ok := that.(GCPSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	if this.NetworkName != that1.NetworkName {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoice)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetworkParam.Equal(that1.NetworkParam) {
		return false
	}
	if !this.ExistingNetwork.Equal(that1.ExistingNetwork) {
		return false
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	return true
}
func (this *GCPSubnetChoice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetChoice)
	if !ok {
		that2, ok := that.(GCPSubnetChoice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	if !this.ExistingSubnet.Equal(that1.ExistingSubnet) {
		return false
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	return true
}
func (this *GCPVpcSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVpcSiteType)
	if !ok {
		that2, ok := that.(GCPVpcSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	if this.GcpName != that1.GcpName {
		return false
	}
	if !this.GcpVpcNetworkOutside.Equal(that1.GcpVpcNetworkOutside) {
		return false
	}
	if !this.GcpVpcNetworkInside.Equal(that1.GcpVpcNetworkInside) {
		return false
	}
	if this.CertifiedHw != that1.CertifiedHw {
		return false
	}
	if this.GcpRegion != that1.GcpRegion {
		return false
	}
	if !this.SubnetOutside.Equal(that1.SubnetOutside) {
		return false
	}
	if !this.SubnetInside.Equal(that1.SubnetInside) {
		return false
	}
	if !this.Node.Equal(that1.Node) {
		return false
	}
	if this.WorkerNodes != that1.WorkerNodes {
		return false
	}
	if this.GatewayType != that1.GatewayType {
		return false
	}
	if this.SshKey != that1.SshKey {
		return false
	}
	if this.AdminPassword != that1.AdminPassword {
		return false
	}
	if this.AdminPasswordClearB64 != that1.AdminPasswordClearB64 {
		return false
	}
	if this.AdminPasswordBlindfolded != that1.AdminPasswordBlindfolded {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.MultiNodeNonStdAz != that1.MultiNodeNonStdAz {
		return false
	}
	if !this.Interconnect.Equal(that1.Interconnect) {
		return false
	}
	return true
}
func (this *GCPInterconnectType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPInterconnectType)
	if !ok {
		that2, ok := that.(GCPInterconnectType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PrivateNetworkName != that1.PrivateNetworkName {
		return false
	}
	if this.AdnDnsIp != that1.AdnDnsIp {
		return false
	}
	return true
}
func (this *GCPInstanceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&terraform_parameters.GCPInstanceType{")
	s = append(s, "VoltNodeId: "+fmt.Sprintf("%#v", this.VoltNodeId)+",\n")
	s = append(s, "VoltRegionId: "+fmt.Sprintf("%#v", this.VoltRegionId)+",\n")
	if this.PublicSubnetId != nil {
		s = append(s, "PublicSubnetId: "+fmt.Sprintf("%#v", this.PublicSubnetId)+",\n")
	}
	if this.PrivateSubnetId != nil {
		s = append(s, "PrivateSubnetId: "+fmt.Sprintf("%#v", this.PrivateSubnetId)+",\n")
	}
	s = append(s, "InstanceType: "+fmt.Sprintf("%#v", this.InstanceType)+",\n")
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "ImageId: "+fmt.Sprintf("%#v", this.ImageId)+",\n")
	s = append(s, "WorkerNodeCount: "+fmt.Sprintf("%#v", this.WorkerNodeCount)+",\n")
	s = append(s, "MasterNodeCount: "+fmt.Sprintf("%#v", this.MasterNodeCount)+",\n")
	s = append(s, "Zones: "+fmt.Sprintf("%#v", this.Zones)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.GCPSubnetParamType{")
	if this.Subnet != nil {
		s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	}
	s = append(s, "NetworkName: "+fmt.Sprintf("%#v", this.NetworkName)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.GCPVPCNetworkChoice{")
	if this.NetworkParam != nil {
		s = append(s, "NetworkParam: "+fmt.Sprintf("%#v", this.NetworkParam)+",\n")
	}
	if this.ExistingNetwork != nil {
		s = append(s, "ExistingNetwork: "+fmt.Sprintf("%#v", this.ExistingNetwork)+",\n")
	}
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&terraform_parameters.GCPSubnetChoice{")
	if this.SubnetParam != nil {
		s = append(s, "SubnetParam: "+fmt.Sprintf("%#v", this.SubnetParam)+",\n")
	}
	if this.ExistingSubnet != nil {
		s = append(s, "ExistingSubnet: "+fmt.Sprintf("%#v", this.ExistingSubnet)+",\n")
	}
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVpcSiteType) goString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&terraform_parameters.GCPVpcSiteType{")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	s = append(s, "GcpName: "+fmt.Sprintf("%#v", this.GcpName)+",\n")
	if this.GcpVpcNetworkOutside != nil {
		s = append(s, "GcpVpcNetworkOutside: "+fmt.Sprintf("%#v", this.GcpVpcNetworkOutside)+",\n")
	}
	if this.GcpVpcNetworkInside != nil {
		s = append(s, "GcpVpcNetworkInside: "+fmt.Sprintf("%#v", this.GcpVpcNetworkInside)+",\n")
	}
	s = append(s, "CertifiedHw: "+fmt.Sprintf("%#v", this.CertifiedHw)+",\n")
	s = append(s, "GcpRegion: "+fmt.Sprintf("%#v", this.GcpRegion)+",\n")
	if this.SubnetOutside != nil {
		s = append(s, "SubnetOutside: "+fmt.Sprintf("%#v", this.SubnetOutside)+",\n")
	}
	if this.SubnetInside != nil {
		s = append(s, "SubnetInside: "+fmt.Sprintf("%#v", this.SubnetInside)+",\n")
	}
	if this.Node != nil {
		s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	}
	s = append(s, "WorkerNodes: "+fmt.Sprintf("%#v", this.WorkerNodes)+",\n")
	s = append(s, "GatewayType: "+fmt.Sprintf("%#v", this.GatewayType)+",\n")
	s = append(s, "SshKey: "+fmt.Sprintf("%#v", this.SshKey)+",\n")
	s = append(s, "AdminPassword: "+fmt.Sprintf("%#v", this.AdminPassword)+",\n")
	s = append(s, "AdminPasswordClearB64: "+fmt.Sprintf("%#v", this.AdminPasswordClearB64)+",\n")
	s = append(s, "AdminPasswordBlindfolded: "+fmt.Sprintf("%#v", this.AdminPasswordBlindfolded)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "MultiNodeNonStdAz: "+fmt.Sprintf("%#v", this.MultiNodeNonStdAz)+",\n")
	if this.Interconnect != nil {
		s = append(s, "Interconnect: "+fmt.Sprintf("%#v", this.Interconnect)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPInterconnectType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&terraform_parameters.GCPInterconnectType{")
	s = append(s, "PrivateNetworkName: "+fmt.Sprintf("%#v", this.PrivateNetworkName)+",\n")
	s = append(s, "AdnDnsIp: "+fmt.Sprintf("%#v", this.AdnDnsIp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringGcpTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GCPInstanceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPInstanceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPInstanceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MasterNodeCount != 0 {
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.MasterNodeCount))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Zones) > 0 {
		for iNdEx := len(m.Zones) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Zones[iNdEx])
			copy(dAtA[i:], m.Zones[iNdEx])
			i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.Zones[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.WorkerNodeCount != 0 {
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.WorkerNodeCount))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ImageId) > 0 {
		i -= len(m.ImageId)
		copy(dAtA[i:], m.ImageId)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.ImageId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DiskSize) > 0 {
		i -= len(m.DiskSize)
		copy(dAtA[i:], m.DiskSize)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.DiskSize)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InstanceType) > 0 {
		i -= len(m.InstanceType)
		copy(dAtA[i:], m.InstanceType)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.InstanceType)))
		i--
		dAtA[i] = 0x32
	}
	if m.PrivateSubnetId != nil {
		{
			size, err := m.PrivateSubnetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.PublicSubnetId != nil {
		{
			size, err := m.PublicSubnetId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.VoltRegionId) > 0 {
		i -= len(m.VoltRegionId)
		copy(dAtA[i:], m.VoltRegionId)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.VoltRegionId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VoltNodeId) > 0 {
		i -= len(m.VoltNodeId)
		copy(dAtA[i:], m.VoltNodeId)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.VoltNodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPSubnetParamType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NetworkName) > 0 {
		i -= len(m.NetworkName)
		copy(dAtA[i:], m.NetworkName)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.NetworkName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPVPCNetworkChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCNetworkChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceType != 0 {
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.InterfaceType))
		i--
		dAtA[i] = 0x18
	}
	if m.ExistingNetwork != nil {
		{
			size, err := m.ExistingNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NetworkParam != nil {
		{
			size, err := m.NetworkParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPSubnetChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPSubnetChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceType != 0 {
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.InterfaceType))
		i--
		dAtA[i] = 0x18
	}
	if m.ExistingSubnet != nil {
		{
			size, err := m.ExistingSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPVpcSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVpcSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVpcSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AdminPasswordBlindfolded) > 0 {
		i -= len(m.AdminPasswordBlindfolded)
		copy(dAtA[i:], m.AdminPasswordBlindfolded)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.AdminPasswordBlindfolded)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if len(m.AdminPasswordClearB64) > 0 {
		i -= len(m.AdminPasswordClearB64)
		copy(dAtA[i:], m.AdminPasswordClearB64)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.AdminPasswordClearB64)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if len(m.AdminPassword) > 0 {
		i -= len(m.AdminPassword)
		copy(dAtA[i:], m.AdminPassword)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.AdminPassword)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.Interconnect != nil {
		{
			size, err := m.Interconnect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.MultiNodeNonStdAz {
		i--
		if m.MultiNodeNonStdAz {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGcpTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintGcpTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGcpTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.GcpVpcNetworkInside != nil {
		{
			size, err := m.GcpVpcNetworkInside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.SubnetInside != nil {
		{
			size, err := m.SubnetInside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.GcpName) > 0 {
		i -= len(m.GcpName)
		copy(dAtA[i:], m.GcpName)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.GcpName)))
		i--
		dAtA[i] = 0x7a
	}
	if m.WorkerNodes != 0 {
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.WorkerNodes))
		i--
		dAtA[i] = 0x70
	}
	if len(m.SshKey) > 0 {
		i -= len(m.SshKey)
		copy(dAtA[i:], m.SshKey)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.SshKey)))
		i--
		dAtA[i] = 0x6a
	}
	if m.GatewayType != 0 {
		i = encodeVarintGcpTypes(dAtA, i, uint64(m.GatewayType))
		i--
		dAtA[i] = 0x58
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.SubnetOutside != nil {
		{
			size, err := m.SubnetOutside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.GcpRegion) > 0 {
		i -= len(m.GcpRegion)
		copy(dAtA[i:], m.GcpRegion)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.GcpRegion)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CertifiedHw) > 0 {
		i -= len(m.CertifiedHw)
		copy(dAtA[i:], m.CertifiedHw)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.CertifiedHw)))
		i--
		dAtA[i] = 0x22
	}
	if m.GcpVpcNetworkOutside != nil {
		{
			size, err := m.GcpVpcNetworkOutside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGcpTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SiteName) > 0 {
		i -= len(m.SiteName)
		copy(dAtA[i:], m.SiteName)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.SiteName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPInterconnectType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPInterconnectType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPInterconnectType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AdnDnsIp) > 0 {
		i -= len(m.AdnDnsIp)
		copy(dAtA[i:], m.AdnDnsIp)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.AdnDnsIp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrivateNetworkName) > 0 {
		i -= len(m.PrivateNetworkName)
		copy(dAtA[i:], m.PrivateNetworkName)
		i = encodeVarintGcpTypes(dAtA, i, uint64(len(m.PrivateNetworkName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGcpTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovGcpTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GCPInstanceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VoltNodeId)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.VoltRegionId)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.PublicSubnetId != nil {
		l = m.PublicSubnetId.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.PrivateSubnetId != nil {
		l = m.PrivateSubnetId.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.InstanceType)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.DiskSize)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.WorkerNodeCount != 0 {
		n += 1 + sovGcpTypes(uint64(m.WorkerNodeCount))
	}
	if len(m.Zones) > 0 {
		for _, s := range m.Zones {
			l = len(s)
			n += 1 + l + sovGcpTypes(uint64(l))
		}
	}
	if m.MasterNodeCount != 0 {
		n += 1 + sovGcpTypes(uint64(m.MasterNodeCount))
	}
	return n
}

func (m *GCPSubnetParamType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.NetworkName)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCNetworkChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkParam != nil {
		l = m.NetworkParam.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.ExistingNetwork != nil {
		l = m.ExistingNetwork.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.InterfaceType != 0 {
		n += 1 + sovGcpTypes(uint64(m.InterfaceType))
	}
	return n
}

func (m *GCPSubnetChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.ExistingSubnet != nil {
		l = m.ExistingSubnet.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.InterfaceType != 0 {
		n += 1 + sovGcpTypes(uint64(m.InterfaceType))
	}
	return n
}

func (m *GCPVpcSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.GcpVpcNetworkOutside != nil {
		l = m.GcpVpcNetworkOutside.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.CertifiedHw)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.GcpRegion)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.SubnetOutside != nil {
		l = m.SubnetOutside.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.GatewayType != 0 {
		n += 1 + sovGcpTypes(uint64(m.GatewayType))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.WorkerNodes != 0 {
		n += 1 + sovGcpTypes(uint64(m.WorkerNodes))
	}
	l = len(m.GcpName)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	if m.SubnetInside != nil {
		l = m.SubnetInside.Size()
		n += 2 + l + sovGcpTypes(uint64(l))
	}
	if m.GcpVpcNetworkInside != nil {
		l = m.GcpVpcNetworkInside.Size()
		n += 2 + l + sovGcpTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGcpTypes(uint64(len(k))) + 1 + len(v) + sovGcpTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovGcpTypes(uint64(mapEntrySize))
		}
	}
	if m.MultiNodeNonStdAz {
		n += 3
	}
	if m.Interconnect != nil {
		l = m.Interconnect.Size()
		n += 2 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.AdminPassword)
	if l > 0 {
		n += 2 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.AdminPasswordClearB64)
	if l > 0 {
		n += 2 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.AdminPasswordBlindfolded)
	if l > 0 {
		n += 2 + l + sovGcpTypes(uint64(l))
	}
	return n
}

func (m *GCPInterconnectType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrivateNetworkName)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	l = len(m.AdnDnsIp)
	if l > 0 {
		n += 1 + l + sovGcpTypes(uint64(l))
	}
	return n
}

func sovGcpTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGcpTypes(x uint64) (n int) {
	return sovGcpTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GCPInstanceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPInstanceType{`,
		`VoltNodeId:` + fmt.Sprintf("%v", this.VoltNodeId) + `,`,
		`VoltRegionId:` + fmt.Sprintf("%v", this.VoltRegionId) + `,`,
		`PublicSubnetId:` + strings.Replace(this.PublicSubnetId.String(), "GCPSubnetChoice", "GCPSubnetChoice", 1) + `,`,
		`PrivateSubnetId:` + strings.Replace(this.PrivateSubnetId.String(), "GCPSubnetChoice", "GCPSubnetChoice", 1) + `,`,
		`InstanceType:` + fmt.Sprintf("%v", this.InstanceType) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`ImageId:` + fmt.Sprintf("%v", this.ImageId) + `,`,
		`WorkerNodeCount:` + fmt.Sprintf("%v", this.WorkerNodeCount) + `,`,
		`Zones:` + fmt.Sprintf("%v", this.Zones) + `,`,
		`MasterNodeCount:` + fmt.Sprintf("%v", this.MasterNodeCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetParamType{`,
		`Subnet:` + strings.Replace(fmt.Sprintf("%v", this.Subnet), "GCPSubnetParamsType", "views.GCPSubnetParamsType", 1) + `,`,
		`NetworkName:` + fmt.Sprintf("%v", this.NetworkName) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoice{`,
		`NetworkParam:` + strings.Replace(fmt.Sprintf("%v", this.NetworkParam), "GCPVPCNetworkParamsType", "views.GCPVPCNetworkParamsType", 1) + `,`,
		`ExistingNetwork:` + strings.Replace(fmt.Sprintf("%v", this.ExistingNetwork), "GCPVPCNetworkType", "views.GCPVPCNetworkType", 1) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetChoice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetChoice{`,
		`SubnetParam:` + strings.Replace(this.SubnetParam.String(), "GCPSubnetParamType", "GCPSubnetParamType", 1) + `,`,
		`ExistingSubnet:` + strings.Replace(fmt.Sprintf("%v", this.ExistingSubnet), "GCPSubnetType", "views.GCPSubnetType", 1) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVpcSiteType) string() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&GCPVpcSiteType{`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`GcpVpcNetworkOutside:` + strings.Replace(this.GcpVpcNetworkOutside.String(), "GCPVPCNetworkChoice", "GCPVPCNetworkChoice", 1) + `,`,
		`CertifiedHw:` + fmt.Sprintf("%v", this.CertifiedHw) + `,`,
		`GcpRegion:` + fmt.Sprintf("%v", this.GcpRegion) + `,`,
		`SubnetOutside:` + strings.Replace(this.SubnetOutside.String(), "GCPSubnetChoice", "GCPSubnetChoice", 1) + `,`,
		`Node:` + strings.Replace(this.Node.String(), "GCPInstanceType", "GCPInstanceType", 1) + `,`,
		`GatewayType:` + fmt.Sprintf("%v", this.GatewayType) + `,`,
		`SshKey:` + fmt.Sprintf("%v", this.SshKey) + `,`,
		`WorkerNodes:` + fmt.Sprintf("%v", this.WorkerNodes) + `,`,
		`GcpName:` + fmt.Sprintf("%v", this.GcpName) + `,`,
		`SubnetInside:` + strings.Replace(this.SubnetInside.String(), "GCPSubnetChoice", "GCPSubnetChoice", 1) + `,`,
		`GcpVpcNetworkInside:` + strings.Replace(this.GcpVpcNetworkInside.String(), "GCPVPCNetworkChoice", "GCPVPCNetworkChoice", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`MultiNodeNonStdAz:` + fmt.Sprintf("%v", this.MultiNodeNonStdAz) + `,`,
		`Interconnect:` + strings.Replace(this.Interconnect.String(), "GCPInterconnectType", "GCPInterconnectType", 1) + `,`,
		`AdminPassword:` + fmt.Sprintf("%v", this.AdminPassword) + `,`,
		`AdminPasswordClearB64:` + fmt.Sprintf("%v", this.AdminPasswordClearB64) + `,`,
		`AdminPasswordBlindfolded:` + fmt.Sprintf("%v", this.AdminPasswordBlindfolded) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPInterconnectType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPInterconnectType{`,
		`PrivateNetworkName:` + fmt.Sprintf("%v", this.PrivateNetworkName) + `,`,
		`AdnDnsIp:` + fmt.Sprintf("%v", this.AdnDnsIp) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGcpTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GCPInstanceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPInstanceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPInstanceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltNodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltRegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoltRegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicSubnetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicSubnetId == nil {
				m.PublicSubnetId = &GCPSubnetChoice{}
			}
			if err := m.PublicSubnetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateSubnetId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivateSubnetId == nil {
				m.PrivateSubnetId = &GCPSubnetChoice{}
			}
			if err := m.PrivateSubnetId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodeCount", wireType)
			}
			m.WorkerNodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerNodeCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zones", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zones = append(m.Zones, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterNodeCount", wireType)
			}
			m.MasterNodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MasterNodeCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &views.GCPSubnetParamsType{}
			}
			if err := m.Subnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkParam == nil {
				m.NetworkParam = &views.GCPVPCNetworkParamsType{}
			}
			if err := m.NetworkParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingNetwork == nil {
				m.ExistingNetwork = &views.GCPVPCNetworkType{}
			}
			if err := m.ExistingNetwork.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= InterfaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetParam == nil {
				m.SubnetParam = &GCPSubnetParamType{}
			}
			if err := m.SubnetParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingSubnet == nil {
				m.ExistingSubnet = &views.GCPSubnetType{}
			}
			if err := m.ExistingSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			m.InterfaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterfaceType |= InterfaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVpcSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVpcSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVpcSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpVpcNetworkOutside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GcpVpcNetworkOutside == nil {
				m.GcpVpcNetworkOutside = &GCPVPCNetworkChoice{}
			}
			if err := m.GcpVpcNetworkOutside.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertifiedHw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertifiedHw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetOutside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetOutside == nil {
				m.SubnetOutside = &GCPSubnetChoice{}
			}
			if err := m.SubnetOutside.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &GCPInstanceType{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayType", wireType)
			}
			m.GatewayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayType |= CloudGatewayType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodes", wireType)
			}
			m.WorkerNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerNodes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcpName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubnetInside == nil {
				m.SubnetInside = &GCPSubnetChoice{}
			}
			if err := m.SubnetInside.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcpVpcNetworkInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GcpVpcNetworkInside == nil {
				m.GcpVpcNetworkInside = &GCPVPCNetworkChoice{}
			}
			if err := m.GcpVpcNetworkInside.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGcpTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGcpTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGcpTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGcpTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGcpTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGcpTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGcpTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGcpTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGcpTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiNodeNonStdAz", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiNodeNonStdAz = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interconnect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interconnect == nil {
				m.Interconnect = &GCPInterconnectType{}
			}
			if err := m.Interconnect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPasswordClearB64", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminPasswordClearB64 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPasswordBlindfolded", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminPasswordBlindfolded = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPInterconnectType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPInterconnectType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPInterconnectType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateNetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateNetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdnDnsIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGcpTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdnDnsIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGcpTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGcpTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGcpTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGcpTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGcpTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGcpTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGcpTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGcpTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGcpTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGcpTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGcpTypes = fmt.Errorf("proto: unexpected end of group")
)
