// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package common_security

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AppEndpointType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AppEndpointType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AppEndpointType) DeepCopy() *AppEndpointType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AppEndpointType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AppEndpointType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AppEndpointType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AppEndpointTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAppEndpointType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAppEndpointType) AppTrafficTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for app_traffic_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAppEndpointType) FlowLabelChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for flow_label_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAppEndpointType) GoodbotChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for goodbot_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAppEndpointType) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppEndpointType) HttpMethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.BotHttpMethod)
		return int32(i)
	}
	// ves_io_schema.BotHttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.BotHttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.BotHttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for http_methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.BotHttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.BotHttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated http_methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items http_methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppEndpointType) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for path")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.PathMatcherTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppEndpointType) MitigationValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for mitigation")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAppEndpointType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AppEndpointType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AppEndpointType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["app_traffic_type_choice"]; exists {
		val := m.GetAppTrafficTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("app_traffic_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAppTrafficTypeChoice().(type) {
	case *AppEndpointType_Web:
		if fv, exists := v.FldValidators["app_traffic_type_choice.web"]; exists {
			val := m.GetAppTrafficTypeChoice().(*AppEndpointType_Web).Web
			vOpts := append(opts,
				db.WithValidateField("app_traffic_type_choice"),
				db.WithValidateField("web"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AppEndpointType_Mobile:
		if fv, exists := v.FldValidators["app_traffic_type_choice.mobile"]; exists {
			val := m.GetAppTrafficTypeChoice().(*AppEndpointType_Mobile).Mobile
			vOpts := append(opts,
				db.WithValidateField("app_traffic_type_choice"),
				db.WithValidateField("mobile"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AppEndpointType_WebMobile:
		if fv, exists := v.FldValidators["app_traffic_type_choice.web_mobile"]; exists {
			val := m.GetAppTrafficTypeChoice().(*AppEndpointType_WebMobile).WebMobile
			vOpts := append(opts,
				db.WithValidateField("app_traffic_type_choice"),
				db.WithValidateField("web_mobile"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetDomainMatcherChoice().(type) {
	case *AppEndpointType_AnyDomain:
		if fv, exists := v.FldValidators["domain_matcher_choice.any_domain"]; exists {
			val := m.GetDomainMatcherChoice().(*AppEndpointType_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AppEndpointType_Domain:
		if fv, exists := v.FldValidators["domain_matcher_choice.domain"]; exists {
			val := m.GetDomainMatcherChoice().(*AppEndpointType_Domain).Domain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["flow_label_choice"]; exists {
		val := m.GetFlowLabelChoice()
		vOpts := append(opts,
			db.WithValidateField("flow_label_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFlowLabelChoice().(type) {
	case *AppEndpointType_UndefinedFlowLabel:
		if fv, exists := v.FldValidators["flow_label_choice.undefined_flow_label"]; exists {
			val := m.GetFlowLabelChoice().(*AppEndpointType_UndefinedFlowLabel).UndefinedFlowLabel
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("undefined_flow_label"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AppEndpointType_FlowLabel:
		if fv, exists := v.FldValidators["flow_label_choice.flow_label"]; exists {
			val := m.GetFlowLabelChoice().(*AppEndpointType_FlowLabel).FlowLabel
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("flow_label"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["goodbot_choice"]; exists {
		val := m.GetGoodbotChoice()
		vOpts := append(opts,
			db.WithValidateField("goodbot_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGoodbotChoice().(type) {
	case *AppEndpointType_MitigateGoodBots:
		if fv, exists := v.FldValidators["goodbot_choice.mitigate_good_bots"]; exists {
			val := m.GetGoodbotChoice().(*AppEndpointType_MitigateGoodBots).MitigateGoodBots
			vOpts := append(opts,
				db.WithValidateField("goodbot_choice"),
				db.WithValidateField("mitigate_good_bots"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AppEndpointType_AllowGoodBots:
		if fv, exists := v.FldValidators["goodbot_choice.allow_good_bots"]; exists {
			val := m.GetGoodbotChoice().(*AppEndpointType_AllowGoodBots).AllowGoodBots
			vOpts := append(opts,
				db.WithValidateField("goodbot_choice"),
				db.WithValidateField("allow_good_bots"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["http_methods"]; exists {
		vOpts := append(opts, db.WithValidateField("http_methods"))
		if err := fv(ctx, m.GetHttpMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mitigation"]; exists {

		vOpts := append(opts, db.WithValidateField("mitigation"))
		if err := fv(ctx, m.GetMitigation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("protocol"))
		if err := fv(ctx, m.GetProtocol(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAppEndpointTypeValidator = func() *ValidateAppEndpointType {
	v := &ValidateAppEndpointType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppTrafficTypeChoice := v.AppTrafficTypeChoiceValidationRuleHandler
	rulesAppTrafficTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAppTrafficTypeChoice(rulesAppTrafficTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppEndpointType.app_traffic_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_traffic_type_choice"] = vFn

	vrhFlowLabelChoice := v.FlowLabelChoiceValidationRuleHandler
	rulesFlowLabelChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFlowLabelChoice(rulesFlowLabelChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppEndpointType.flow_label_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["flow_label_choice"] = vFn

	vrhGoodbotChoice := v.GoodbotChoiceValidationRuleHandler
	rulesGoodbotChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhGoodbotChoice(rulesGoodbotChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppEndpointType.goodbot_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["goodbot_choice"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppEndpointType.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhHttpMethods := v.HttpMethodsValidationRuleHandler
	rulesHttpMethods := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.in":           "[0,1,3,4,10]",
		"ves.io.schema.rules.repeated.max_items":               "5",
		"ves.io.schema.rules.repeated.min_items":               "1",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhHttpMethods(rulesHttpMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppEndpointType.http_methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_methods"] = vFn

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppEndpointType.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	vrhMitigation := v.MitigationValidationRuleHandler
	rulesMitigation := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMitigation(rulesMitigation)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AppEndpointType.mitigation: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mitigation"] = vFn

	v.FldValidators["app_traffic_type_choice.web_mobile"] = WebMobileTrafficTypeValidator().Validate

	v.FldValidators["domain_matcher_choice.domain"] = ves_io_schema.DomainTypeValidator().Validate

	v.FldValidators["flow_label_choice.flow_label"] = ves_io_schema.BotDefenseFlowLabelCategoriesChoiceTypeValidator().Validate

	return v
}()

func AppEndpointTypeValidator() db.Validator {
	return DefaultAppEndpointTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotAdvancedMobileSDKConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotAdvancedMobileSDKConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotAdvancedMobileSDKConfigType) DeepCopy() *BotAdvancedMobileSDKConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotAdvancedMobileSDKConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotAdvancedMobileSDKConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotAdvancedMobileSDKConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotAdvancedMobileSDKConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotAdvancedMobileSDKConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotAdvancedMobileSDKConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotAdvancedMobileSDKConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotAdvancedMobileSDKConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mobile_identifier"]; exists {

		vOpts := append(opts, db.WithValidateField("mobile_identifier"))
		if err := fv(ctx, m.GetMobileIdentifier(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotAdvancedMobileSDKConfigTypeValidator = func() *ValidateBotAdvancedMobileSDKConfigType {
	v := &ValidateBotAdvancedMobileSDKConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["mobile_identifier"] = MobileTrafficIdentifierTypeValidator().Validate

	return v
}()

func BotAdvancedMobileSDKConfigTypeValidator() db.Validator {
	return DefaultBotAdvancedMobileSDKConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseAdvancedPolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseAdvancedPolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseAdvancedPolicyType) DeepCopy() *BotDefenseAdvancedPolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseAdvancedPolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseAdvancedPolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseAdvancedPolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseAdvancedPolicyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBotDefenseAdvancedPolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseAdvancedPolicyType) MobileSdkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mobile_sdk_choice")
	}
	return validatorFn, nil
}

func (v *ValidateBotDefenseAdvancedPolicyType) ProtectedAppEndpointsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for protected_app_endpoints")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ProtectedAppEndpointType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ProtectedAppEndpointTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for protected_app_endpoints")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ProtectedAppEndpointType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ProtectedAppEndpointType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated protected_app_endpoints")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items protected_app_endpoints")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBotDefenseAdvancedPolicyType) JsDownloadPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for js_download_path")
	}

	return validatorFn, nil
}

func (v *ValidateBotDefenseAdvancedPolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseAdvancedPolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseAdvancedPolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["js_download_path"]; exists {

		vOpts := append(opts, db.WithValidateField("js_download_path"))
		if err := fv(ctx, m.GetJsDownloadPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mobile_sdk_choice"]; exists {
		val := m.GetMobileSdkChoice()
		vOpts := append(opts,
			db.WithValidateField("mobile_sdk_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMobileSdkChoice().(type) {
	case *BotDefenseAdvancedPolicyType_DisableMobileSdk:
		if fv, exists := v.FldValidators["mobile_sdk_choice.disable_mobile_sdk"]; exists {
			val := m.GetMobileSdkChoice().(*BotDefenseAdvancedPolicyType_DisableMobileSdk).DisableMobileSdk
			vOpts := append(opts,
				db.WithValidateField("mobile_sdk_choice"),
				db.WithValidateField("disable_mobile_sdk"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *BotDefenseAdvancedPolicyType_MobileSdkConfig:
		if fv, exists := v.FldValidators["mobile_sdk_choice.mobile_sdk_config"]; exists {
			val := m.GetMobileSdkChoice().(*BotDefenseAdvancedPolicyType_MobileSdkConfig).MobileSdkConfig
			vOpts := append(opts,
				db.WithValidateField("mobile_sdk_choice"),
				db.WithValidateField("mobile_sdk_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["protected_app_endpoints"]; exists {
		vOpts := append(opts, db.WithValidateField("protected_app_endpoints"))
		if err := fv(ctx, m.GetProtectedAppEndpoints(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseAdvancedPolicyTypeValidator = func() *ValidateBotDefenseAdvancedPolicyType {
	v := &ValidateBotDefenseAdvancedPolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMobileSdkChoice := v.MobileSdkChoiceValidationRuleHandler
	rulesMobileSdkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMobileSdkChoice(rulesMobileSdkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseAdvancedPolicyType.mobile_sdk_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mobile_sdk_choice"] = vFn

	vrhProtectedAppEndpoints := v.ProtectedAppEndpointsValidationRuleHandler
	rulesProtectedAppEndpoints := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhProtectedAppEndpoints(rulesProtectedAppEndpoints)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseAdvancedPolicyType.protected_app_endpoints: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protected_app_endpoints"] = vFn

	vrhJsDownloadPath := v.JsDownloadPathValidationRuleHandler
	rulesJsDownloadPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.http_path": "true",
	}
	vFn, err = vrhJsDownloadPath(rulesJsDownloadPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseAdvancedPolicyType.js_download_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["js_download_path"] = vFn

	v.FldValidators["mobile_sdk_choice.mobile_sdk_config"] = BotAdvancedMobileSDKConfigTypeValidator().Validate

	return v
}()

func BotDefenseAdvancedPolicyTypeValidator() db.Validator {
	return DefaultBotDefenseAdvancedPolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *BotDefenseAdvancedType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotDefenseAdvancedType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotDefenseAdvancedType) DeepCopy() *BotDefenseAdvancedType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotDefenseAdvancedType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotDefenseAdvancedType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotDefenseAdvancedType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotDefenseAdvancedTypeValidator().Validate(ctx, m, opts...)
}

func (m *BotDefenseAdvancedType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetMobileDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetMobileDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetWebDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetWebDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *BotDefenseAdvancedType) GetMobileDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetMobile()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("bot_defense_app_infrastructure.Object")
	dri := db.DRefInfo{
		RefdType:   "bot_defense_app_infrastructure.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "mobile",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetMobileDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *BotDefenseAdvancedType) GetMobileDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "bot_defense_app_infrastructure.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: bot_defense_app_infrastructure")
	}

	vref := m.GetMobile()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "bot_defense_app_infrastructure.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

func (m *BotDefenseAdvancedType) GetWebDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetWeb()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("bot_defense_app_infrastructure.Object")
	dri := db.DRefInfo{
		RefdType:   "bot_defense_app_infrastructure.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "web",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetWebDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *BotDefenseAdvancedType) GetWebDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "bot_defense_app_infrastructure.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: bot_defense_app_infrastructure")
	}

	vref := m.GetWeb()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "bot_defense_app_infrastructure.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateBotDefenseAdvancedType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotDefenseAdvancedType) PolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for policy")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := BotDefenseAdvancedPolicyTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateBotDefenseAdvancedType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotDefenseAdvancedType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotDefenseAdvancedType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mobile"]; exists {

		vOpts := append(opts, db.WithValidateField("mobile"))
		if err := fv(ctx, m.GetMobile(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["policy"]; exists {

		vOpts := append(opts, db.WithValidateField("policy"))
		if err := fv(ctx, m.GetPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["web"]; exists {

		vOpts := append(opts, db.WithValidateField("web"))
		if err := fv(ctx, m.GetWeb(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotDefenseAdvancedTypeValidator = func() *ValidateBotDefenseAdvancedType {
	v := &ValidateBotDefenseAdvancedType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPolicy := v.PolicyValidationRuleHandler
	rulesPolicy := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPolicy(rulesPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for BotDefenseAdvancedType.policy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["policy"] = vFn

	v.FldValidators["web"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["mobile"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func BotDefenseAdvancedTypeValidator() db.Validator {
	return DefaultBotDefenseAdvancedTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CSDJavaScriptInsertAllWithExceptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CSDJavaScriptInsertAllWithExceptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CSDJavaScriptInsertAllWithExceptionsType) DeepCopy() *CSDJavaScriptInsertAllWithExceptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CSDJavaScriptInsertAllWithExceptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CSDJavaScriptInsertAllWithExceptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CSDJavaScriptInsertAllWithExceptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CSDJavaScriptInsertAllWithExceptionsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCSDJavaScriptInsertAllWithExceptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCSDJavaScriptInsertAllWithExceptionsType) ExcludeListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ShapeJavaScriptExclusionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ShapeJavaScriptExclusionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ShapeJavaScriptExclusionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ShapeJavaScriptExclusionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCSDJavaScriptInsertAllWithExceptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CSDJavaScriptInsertAllWithExceptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CSDJavaScriptInsertAllWithExceptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_list"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_list"))
		if err := fv(ctx, m.GetExcludeList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCSDJavaScriptInsertAllWithExceptionsTypeValidator = func() *ValidateCSDJavaScriptInsertAllWithExceptionsType {
	v := &ValidateCSDJavaScriptInsertAllWithExceptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeList := v.ExcludeListValidationRuleHandler
	rulesExcludeList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeList(rulesExcludeList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CSDJavaScriptInsertAllWithExceptionsType.exclude_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_list"] = vFn

	return v
}()

func CSDJavaScriptInsertAllWithExceptionsTypeValidator() db.Validator {
	return DefaultCSDJavaScriptInsertAllWithExceptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CSDJavaScriptInsertType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CSDJavaScriptInsertType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CSDJavaScriptInsertType) DeepCopy() *CSDJavaScriptInsertType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CSDJavaScriptInsertType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CSDJavaScriptInsertType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CSDJavaScriptInsertType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CSDJavaScriptInsertTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCSDJavaScriptInsertType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCSDJavaScriptInsertType) RulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CSDJavaScriptInsertionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CSDJavaScriptInsertionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CSDJavaScriptInsertionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CSDJavaScriptInsertionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCSDJavaScriptInsertType) ExcludeListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ShapeJavaScriptExclusionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ShapeJavaScriptExclusionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ShapeJavaScriptExclusionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ShapeJavaScriptExclusionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCSDJavaScriptInsertType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CSDJavaScriptInsertType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CSDJavaScriptInsertType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_list"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_list"))
		if err := fv(ctx, m.GetExcludeList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rules"]; exists {
		vOpts := append(opts, db.WithValidateField("rules"))
		if err := fv(ctx, m.GetRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCSDJavaScriptInsertTypeValidator = func() *ValidateCSDJavaScriptInsertType {
	v := &ValidateCSDJavaScriptInsertType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRules := v.RulesValidationRuleHandler
	rulesRules := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRules(rulesRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CSDJavaScriptInsertType.rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rules"] = vFn

	vrhExcludeList := v.ExcludeListValidationRuleHandler
	rulesExcludeList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeList(rulesExcludeList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CSDJavaScriptInsertType.exclude_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_list"] = vFn

	return v
}()

func CSDJavaScriptInsertTypeValidator() db.Validator {
	return DefaultCSDJavaScriptInsertTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CSDJavaScriptInsertionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CSDJavaScriptInsertionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CSDJavaScriptInsertionRule) DeepCopy() *CSDJavaScriptInsertionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CSDJavaScriptInsertionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CSDJavaScriptInsertionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CSDJavaScriptInsertionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CSDJavaScriptInsertionRuleValidator().Validate(ctx, m, opts...)
}

type ValidateCSDJavaScriptInsertionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCSDJavaScriptInsertionRule) DomainMatcherChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_matcher_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCSDJavaScriptInsertionRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCSDJavaScriptInsertionRule) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for path")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.PathMatcherTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCSDJavaScriptInsertionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CSDJavaScriptInsertionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CSDJavaScriptInsertionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_matcher_choice"]; exists {
		val := m.GetDomainMatcherChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_matcher_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainMatcherChoice().(type) {
	case *CSDJavaScriptInsertionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_matcher_choice.any_domain"]; exists {
			val := m.GetDomainMatcherChoice().(*CSDJavaScriptInsertionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CSDJavaScriptInsertionRule_Domain:
		if fv, exists := v.FldValidators["domain_matcher_choice.domain"]; exists {
			val := m.GetDomainMatcherChoice().(*CSDJavaScriptInsertionRule_Domain).Domain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCSDJavaScriptInsertionRuleValidator = func() *ValidateCSDJavaScriptInsertionRule {
	v := &ValidateCSDJavaScriptInsertionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainMatcherChoice := v.DomainMatcherChoiceValidationRuleHandler
	rulesDomainMatcherChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainMatcherChoice(rulesDomainMatcherChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CSDJavaScriptInsertionRule.domain_matcher_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_matcher_choice"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CSDJavaScriptInsertionRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CSDJavaScriptInsertionRule.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	v.FldValidators["domain_matcher_choice.domain"] = ves_io_schema.DomainTypeValidator().Validate

	return v
}()

func CSDJavaScriptInsertionRuleValidator() db.Validator {
	return DefaultCSDJavaScriptInsertionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *ClientSideDefensePolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ClientSideDefensePolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ClientSideDefensePolicyType) DeepCopy() *ClientSideDefensePolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ClientSideDefensePolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ClientSideDefensePolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ClientSideDefensePolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ClientSideDefensePolicyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateClientSideDefensePolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateClientSideDefensePolicyType) JavaScriptChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for java_script_choice")
	}
	return validatorFn, nil
}

func (v *ValidateClientSideDefensePolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ClientSideDefensePolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ClientSideDefensePolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["java_script_choice"]; exists {
		val := m.GetJavaScriptChoice()
		vOpts := append(opts,
			db.WithValidateField("java_script_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetJavaScriptChoice().(type) {
	case *ClientSideDefensePolicyType_DisableJsInsert:
		if fv, exists := v.FldValidators["java_script_choice.disable_js_insert"]; exists {
			val := m.GetJavaScriptChoice().(*ClientSideDefensePolicyType_DisableJsInsert).DisableJsInsert
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("disable_js_insert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientSideDefensePolicyType_JsInsertAllPages:
		if fv, exists := v.FldValidators["java_script_choice.js_insert_all_pages"]; exists {
			val := m.GetJavaScriptChoice().(*ClientSideDefensePolicyType_JsInsertAllPages).JsInsertAllPages
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("js_insert_all_pages"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientSideDefensePolicyType_JsInsertAllPagesExcept:
		if fv, exists := v.FldValidators["java_script_choice.js_insert_all_pages_except"]; exists {
			val := m.GetJavaScriptChoice().(*ClientSideDefensePolicyType_JsInsertAllPagesExcept).JsInsertAllPagesExcept
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("js_insert_all_pages_except"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ClientSideDefensePolicyType_JsInsertionRules:
		if fv, exists := v.FldValidators["java_script_choice.js_insertion_rules"]; exists {
			val := m.GetJavaScriptChoice().(*ClientSideDefensePolicyType_JsInsertionRules).JsInsertionRules
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("js_insertion_rules"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultClientSideDefensePolicyTypeValidator = func() *ValidateClientSideDefensePolicyType {
	v := &ValidateClientSideDefensePolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJavaScriptChoice := v.JavaScriptChoiceValidationRuleHandler
	rulesJavaScriptChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhJavaScriptChoice(rulesJavaScriptChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientSideDefensePolicyType.java_script_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["java_script_choice"] = vFn

	v.FldValidators["java_script_choice.js_insert_all_pages_except"] = CSDJavaScriptInsertAllWithExceptionsTypeValidator().Validate
	v.FldValidators["java_script_choice.js_insertion_rules"] = CSDJavaScriptInsertTypeValidator().Validate

	return v
}()

func ClientSideDefensePolicyTypeValidator() db.Validator {
	return DefaultClientSideDefensePolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ClientSideDefenseType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ClientSideDefenseType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ClientSideDefenseType) DeepCopy() *ClientSideDefenseType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ClientSideDefenseType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ClientSideDefenseType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ClientSideDefenseType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ClientSideDefenseTypeValidator().Validate(ctx, m, opts...)
}

type ValidateClientSideDefenseType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateClientSideDefenseType) PolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for policy")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ClientSideDefensePolicyTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateClientSideDefenseType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ClientSideDefenseType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ClientSideDefenseType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["policy"]; exists {

		vOpts := append(opts, db.WithValidateField("policy"))
		if err := fv(ctx, m.GetPolicy(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultClientSideDefenseTypeValidator = func() *ValidateClientSideDefenseType {
	v := &ValidateClientSideDefenseType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPolicy := v.PolicyValidationRuleHandler
	rulesPolicy := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPolicy(rulesPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ClientSideDefenseType.policy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["policy"] = vFn

	return v
}()

func ClientSideDefenseTypeValidator() db.Validator {
	return DefaultClientSideDefenseTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DDoSClientSource) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DDoSClientSource) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DDoSClientSource) DeepCopy() *DDoSClientSource {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DDoSClientSource{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DDoSClientSource) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DDoSClientSource) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DDoSClientSourceValidator().Validate(ctx, m, opts...)
}

type ValidateDDoSClientSource struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDDoSClientSource) CountryListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema_policy.CountryCode)
		return int32(i)
	}
	// ves_io_schema_policy.CountryCode_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema_policy.CountryCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for country_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema_policy.CountryCode, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for country_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema_policy.CountryCode)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema_policy.CountryCode, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated country_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items country_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDDoSClientSource) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DDoSClientSource)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DDoSClientSource got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn_list"]; exists {

		vOpts := append(opts, db.WithValidateField("asn_list"))
		if err := fv(ctx, m.GetAsnList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["country_list"]; exists {
		vOpts := append(opts, db.WithValidateField("country_list"))
		if err := fv(ctx, m.GetCountryList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tls_fingerprint_matcher"]; exists {

		vOpts := append(opts, db.WithValidateField("tls_fingerprint_matcher"))
		if err := fv(ctx, m.GetTlsFingerprintMatcher(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDDoSClientSourceValidator = func() *ValidateDDoSClientSource {
	v := &ValidateDDoSClientSource{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCountryList := v.CountryListValidationRuleHandler
	rulesCountryList := map[string]string{
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.not_in":       "[0]",
		"ves.io.schema.rules.repeated.max_items":               "64",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhCountryList(rulesCountryList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DDoSClientSource.country_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["country_list"] = vFn

	v.FldValidators["asn_list"] = ves_io_schema_policy.AsnMatchListValidator().Validate

	v.FldValidators["tls_fingerprint_matcher"] = ves_io_schema_policy.TlsFingerprintMatcherTypeValidator().Validate

	return v
}()

func DDoSClientSourceValidator() db.Validator {
	return DefaultDDoSClientSourceValidator
}

// augmented methods on protoc/std generated struct

func (m *DDoSMitigationRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DDoSMitigationRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DDoSMitigationRule) DeepCopy() *DDoSMitigationRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DDoSMitigationRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DDoSMitigationRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DDoSMitigationRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DDoSMitigationRuleValidator().Validate(ctx, m, opts...)
}

type ValidateDDoSMitigationRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDDoSMitigationRule) MitigationActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mitigation_action")
	}
	return validatorFn, nil
}

func (v *ValidateDDoSMitigationRule) MitigationChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mitigation_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDDoSMitigationRule) MitigationChoiceDdosClientSourceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	return DDoSClientSourceValidator().Validate, nil
}

func (v *ValidateDDoSMitigationRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDDoSMitigationRule) ExpirationTimestampValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDDoSMitigationRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DDoSMitigationRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DDoSMitigationRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["expiration_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("expiration_timestamp"))
		if err := fv(ctx, m.GetExpirationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mitigation_action"]; exists {
		val := m.GetMitigationAction()
		vOpts := append(opts,
			db.WithValidateField("mitigation_action"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMitigationAction().(type) {
	case *DDoSMitigationRule_Block:
		if fv, exists := v.FldValidators["mitigation_action.block"]; exists {
			val := m.GetMitigationAction().(*DDoSMitigationRule_Block).Block
			vOpts := append(opts,
				db.WithValidateField("mitigation_action"),
				db.WithValidateField("block"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mitigation_choice"]; exists {
		val := m.GetMitigationChoice()
		vOpts := append(opts,
			db.WithValidateField("mitigation_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMitigationChoice().(type) {
	case *DDoSMitigationRule_DdosClientSource:
		if fv, exists := v.FldValidators["mitigation_choice.ddos_client_source"]; exists {
			val := m.GetMitigationChoice().(*DDoSMitigationRule_DdosClientSource).DdosClientSource
			vOpts := append(opts,
				db.WithValidateField("mitigation_choice"),
				db.WithValidateField("ddos_client_source"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DDoSMitigationRule_IpPrefixList:
		if fv, exists := v.FldValidators["mitigation_choice.ip_prefix_list"]; exists {
			val := m.GetMitigationChoice().(*DDoSMitigationRule_IpPrefixList).IpPrefixList
			vOpts := append(opts,
				db.WithValidateField("mitigation_choice"),
				db.WithValidateField("ip_prefix_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDDoSMitigationRuleValidator = func() *ValidateDDoSMitigationRule {
	v := &ValidateDDoSMitigationRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMitigationAction := v.MitigationActionValidationRuleHandler
	rulesMitigationAction := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMitigationAction(rulesMitigationAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DDoSMitigationRule.mitigation_action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mitigation_action"] = vFn

	vrhMitigationChoice := v.MitigationChoiceValidationRuleHandler
	rulesMitigationChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMitigationChoice(rulesMitigationChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DDoSMitigationRule.mitigation_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mitigation_choice"] = vFn

	vrhMitigationChoiceDdosClientSource := v.MitigationChoiceDdosClientSourceValidationRuleHandler
	rulesMitigationChoiceDdosClientSource := map[string]string{
		"ves.io.schema.rules.message.required_one_nonzero_field": "true",
	}
	vFnMap["mitigation_choice.ddos_client_source"], err = vrhMitigationChoiceDdosClientSource(rulesMitigationChoiceDdosClientSource)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DDoSMitigationRule.mitigation_choice_ddos_client_source: %s", err)
		panic(errMsg)
	}

	v.FldValidators["mitigation_choice.ddos_client_source"] = vFnMap["mitigation_choice.ddos_client_source"]

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DDoSMitigationRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhExpirationTimestamp := v.ExpirationTimestampValidationRuleHandler
	rulesExpirationTimestamp := map[string]string{
		"ves.io.schema.rules.timestamp.within.seconds": "31536000",
	}
	vFn, err = vrhExpirationTimestamp(rulesExpirationTimestamp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DDoSMitigationRule.expiration_timestamp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["expiration_timestamp"] = vFn

	v.FldValidators["mitigation_choice.ip_prefix_list"] = ves_io_schema_policy.PrefixMatchListValidator().Validate

	return v
}()

func DDoSMitigationRuleValidator() db.Validator {
	return DefaultDDoSMitigationRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *MobileSDKConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MobileSDKConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MobileSDKConfigType) DeepCopy() *MobileSDKConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MobileSDKConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MobileSDKConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MobileSDKConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MobileSDKConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMobileSDKConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMobileSDKConfigType) ReloadHeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for reload_header_name")
	}

	return validatorFn, nil
}

func (v *ValidateMobileSDKConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MobileSDKConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MobileSDKConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mobile_identifier"]; exists {

		vOpts := append(opts, db.WithValidateField("mobile_identifier"))
		if err := fv(ctx, m.GetMobileIdentifier(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reload_header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("reload_header_name"))
		if err := fv(ctx, m.GetReloadHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMobileSDKConfigTypeValidator = func() *ValidateMobileSDKConfigType {
	v := &ValidateMobileSDKConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhReloadHeaderName := v.ReloadHeaderNameValidationRuleHandler
	rulesReloadHeaderName := map[string]string{
		"ves.io.schema.rules.string.http_header_field": "true",
		"ves.io.schema.rules.string.max_bytes":         "256",
	}
	vFn, err = vrhReloadHeaderName(rulesReloadHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MobileSDKConfigType.reload_header_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["reload_header_name"] = vFn

	v.FldValidators["mobile_identifier"] = MobileTrafficIdentifierTypeValidator().Validate

	return v
}()

func MobileSDKConfigTypeValidator() db.Validator {
	return DefaultMobileSDKConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *MobileTrafficIdentifierType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *MobileTrafficIdentifierType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *MobileTrafficIdentifierType) DeepCopy() *MobileTrafficIdentifierType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &MobileTrafficIdentifierType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *MobileTrafficIdentifierType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *MobileTrafficIdentifierType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MobileTrafficIdentifierTypeValidator().Validate(ctx, m, opts...)
}

type ValidateMobileTrafficIdentifierType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMobileTrafficIdentifierType) HeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_policy.HeaderMatcherTypeBasic, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema_policy.HeaderMatcherTypeBasicValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_policy.HeaderMatcherTypeBasic)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_policy.HeaderMatcherTypeBasic, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateMobileTrafficIdentifierType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*MobileTrafficIdentifierType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *MobileTrafficIdentifierType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["headers"]; exists {
		vOpts := append(opts, db.WithValidateField("headers"))
		if err := fv(ctx, m.GetHeaders(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMobileTrafficIdentifierTypeValidator = func() *ValidateMobileTrafficIdentifierType {
	v := &ValidateMobileTrafficIdentifierType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaders := v.HeadersValidationRuleHandler
	rulesHeaders := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhHeaders(rulesHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for MobileTrafficIdentifierType.headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["headers"] = vFn

	return v
}()

func MobileTrafficIdentifierTypeValidator() db.Validator {
	return DefaultMobileTrafficIdentifierTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ProtectedAppEndpointType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProtectedAppEndpointType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProtectedAppEndpointType) DeepCopy() *ProtectedAppEndpointType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProtectedAppEndpointType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProtectedAppEndpointType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProtectedAppEndpointType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProtectedAppEndpointTypeValidator().Validate(ctx, m, opts...)
}

type ValidateProtectedAppEndpointType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProtectedAppEndpointType) AppTrafficTypeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for app_traffic_type_choice")
	}
	return validatorFn, nil
}

func (v *ValidateProtectedAppEndpointType) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedAppEndpointType) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for path")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.PathMatcherTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedAppEndpointType) HttpMethodsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.BotHttpMethod)
		return int32(i)
	}
	// ves_io_schema.BotHttpMethod_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ves_io_schema.BotHttpMethod_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_methods")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ves_io_schema.BotHttpMethod, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for http_methods")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ves_io_schema.BotHttpMethod)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ves_io_schema.BotHttpMethod, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated http_methods")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items http_methods")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateProtectedAppEndpointType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProtectedAppEndpointType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProtectedAppEndpointType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["app_traffic_type_choice"]; exists {
		val := m.GetAppTrafficTypeChoice()
		vOpts := append(opts,
			db.WithValidateField("app_traffic_type_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAppTrafficTypeChoice().(type) {
	case *ProtectedAppEndpointType_WebClient:
		if fv, exists := v.FldValidators["app_traffic_type_choice.web_client"]; exists {
			val := m.GetAppTrafficTypeChoice().(*ProtectedAppEndpointType_WebClient).WebClient
			vOpts := append(opts,
				db.WithValidateField("app_traffic_type_choice"),
				db.WithValidateField("web_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedAppEndpointType_MobileClient:
		if fv, exists := v.FldValidators["app_traffic_type_choice.mobile_client"]; exists {
			val := m.GetAppTrafficTypeChoice().(*ProtectedAppEndpointType_MobileClient).MobileClient
			vOpts := append(opts,
				db.WithValidateField("app_traffic_type_choice"),
				db.WithValidateField("mobile_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedAppEndpointType_WebMobileClient:
		if fv, exists := v.FldValidators["app_traffic_type_choice.web_mobile_client"]; exists {
			val := m.GetAppTrafficTypeChoice().(*ProtectedAppEndpointType_WebMobileClient).WebMobileClient
			vOpts := append(opts,
				db.WithValidateField("app_traffic_type_choice"),
				db.WithValidateField("web_mobile_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetDomainMatcherChoice().(type) {
	case *ProtectedAppEndpointType_AnyDomain:
		if fv, exists := v.FldValidators["domain_matcher_choice.any_domain"]; exists {
			val := m.GetDomainMatcherChoice().(*ProtectedAppEndpointType_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedAppEndpointType_Domain:
		if fv, exists := v.FldValidators["domain_matcher_choice.domain"]; exists {
			val := m.GetDomainMatcherChoice().(*ProtectedAppEndpointType_Domain).Domain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetFlowLabelChoice().(type) {
	case *ProtectedAppEndpointType_UndefinedFlowLabel:
		if fv, exists := v.FldValidators["flow_label_choice.undefined_flow_label"]; exists {
			val := m.GetFlowLabelChoice().(*ProtectedAppEndpointType_UndefinedFlowLabel).UndefinedFlowLabel
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("undefined_flow_label"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ProtectedAppEndpointType_FlowLabel:
		if fv, exists := v.FldValidators["flow_label_choice.flow_label"]; exists {
			val := m.GetFlowLabelChoice().(*ProtectedAppEndpointType_FlowLabel).FlowLabel
			vOpts := append(opts,
				db.WithValidateField("flow_label_choice"),
				db.WithValidateField("flow_label"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["http_methods"]; exists {
		vOpts := append(opts, db.WithValidateField("http_methods"))
		if err := fv(ctx, m.GetHttpMethods(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		for idx, item := range m.GetQuery() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["request_body"]; exists {

		vOpts := append(opts, db.WithValidateField("request_body"))
		for idx, item := range m.GetRequestBody() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProtectedAppEndpointTypeValidator = func() *ValidateProtectedAppEndpointType {
	v := &ValidateProtectedAppEndpointType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAppTrafficTypeChoice := v.AppTrafficTypeChoiceValidationRuleHandler
	rulesAppTrafficTypeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAppTrafficTypeChoice(rulesAppTrafficTypeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedAppEndpointType.app_traffic_type_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["app_traffic_type_choice"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedAppEndpointType.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedAppEndpointType.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	vrhHttpMethods := v.HttpMethodsValidationRuleHandler
	rulesHttpMethods := map[string]string{
		"ves.io.schema.rules.message.required":                 "true",
		"ves.io.schema.rules.repeated.items.enum.defined_only": "true",
		"ves.io.schema.rules.repeated.items.enum.in":           "[0,1,3,4,5,6]",
		"ves.io.schema.rules.repeated.max_items":               "6",
		"ves.io.schema.rules.repeated.min_items":               "1",
		"ves.io.schema.rules.repeated.unique":                  "true",
	}
	vFn, err = vrhHttpMethods(rulesHttpMethods)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedAppEndpointType.http_methods: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_methods"] = vFn

	v.FldValidators["app_traffic_type_choice.web_mobile_client"] = WebMobileTrafficTypeValidator().Validate

	v.FldValidators["domain_matcher_choice.domain"] = ves_io_schema.DomainTypeValidator().Validate

	v.FldValidators["flow_label_choice.flow_label"] = ves_io_schema.BotDefenseFlowLabelCategoriesChoiceTypeValidator().Validate

	v.FldValidators["query"] = QueryValidator().Validate

	v.FldValidators["request_body"] = RequestBodyValidator().Validate

	return v
}()

func ProtectedAppEndpointTypeValidator() db.Validator {
	return DefaultProtectedAppEndpointTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Query) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Query) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Query) DeepCopy() *Query {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Query{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Query) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Query) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return QueryValidator().Validate(ctx, m, opts...)
}

type ValidateQuery struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateQuery) ValueTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value_type")
	}
	return validatorFn, nil
}

func (v *ValidateQuery) ValueTypeExactValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExactValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_value")
	}
	return oValidatorFn_ExactValue, nil
}
func (v *ValidateQuery) ValueTypeRegexValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_RegexValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for regex_value")
	}
	return oValidatorFn_RegexValue, nil
}

func (v *ValidateQuery) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Query)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Query got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value_type"]; exists {
		val := m.GetValueType()
		vOpts := append(opts,
			db.WithValidateField("value_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetValueType().(type) {
	case *Query_ExactValue:
		if fv, exists := v.FldValidators["value_type.exact_value"]; exists {
			val := m.GetValueType().(*Query_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("value_type"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Query_RegexValue:
		if fv, exists := v.FldValidators["value_type.regex_value"]; exists {
			val := m.GetValueType().(*Query_RegexValue).RegexValue
			vOpts := append(opts,
				db.WithValidateField("value_type"),
				db.WithValidateField("regex_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Query_CheckPresence:
		if fv, exists := v.FldValidators["value_type.check_presence"]; exists {
			val := m.GetValueType().(*Query_CheckPresence).CheckPresence
			vOpts := append(opts,
				db.WithValidateField("value_type"),
				db.WithValidateField("check_presence"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultQueryValidator = func() *ValidateQuery {
	v := &ValidateQuery{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValueType := v.ValueTypeValidationRuleHandler
	rulesValueType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhValueType(rulesValueType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Query.value_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value_type"] = vFn

	vrhValueTypeExactValue := v.ValueTypeExactValueValidationRuleHandler
	rulesValueTypeExactValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["value_type.exact_value"], err = vrhValueTypeExactValue(rulesValueTypeExactValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field Query.value_type_exact_value: %s", err)
		panic(errMsg)
	}
	vrhValueTypeRegexValue := v.ValueTypeRegexValueValidationRuleHandler
	rulesValueTypeRegexValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFnMap["value_type.regex_value"], err = vrhValueTypeRegexValue(rulesValueTypeRegexValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field Query.value_type_regex_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["value_type.exact_value"] = vFnMap["value_type.exact_value"]
	v.FldValidators["value_type.regex_value"] = vFnMap["value_type.regex_value"]

	return v
}()

func QueryValidator() db.Validator {
	return DefaultQueryValidator
}

// augmented methods on protoc/std generated struct

func (m *RequestBody) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RequestBody) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RequestBody) DeepCopy() *RequestBody {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RequestBody{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RequestBody) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RequestBody) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RequestBodyValidator().Validate(ctx, m, opts...)
}

type ValidateRequestBody struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRequestBody) ValueTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for value_type")
	}
	return validatorFn, nil
}

func (v *ValidateRequestBody) ValueTypeExactValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ExactValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for exact_value")
	}
	return oValidatorFn_ExactValue, nil
}
func (v *ValidateRequestBody) ValueTypeRegexValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_RegexValue, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for regex_value")
	}
	return oValidatorFn_RegexValue, nil
}

func (v *ValidateRequestBody) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RequestBody)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RequestBody got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value_type"]; exists {
		val := m.GetValueType()
		vOpts := append(opts,
			db.WithValidateField("value_type"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetValueType().(type) {
	case *RequestBody_ExactValue:
		if fv, exists := v.FldValidators["value_type.exact_value"]; exists {
			val := m.GetValueType().(*RequestBody_ExactValue).ExactValue
			vOpts := append(opts,
				db.WithValidateField("value_type"),
				db.WithValidateField("exact_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *RequestBody_RegexValue:
		if fv, exists := v.FldValidators["value_type.regex_value"]; exists {
			val := m.GetValueType().(*RequestBody_RegexValue).RegexValue
			vOpts := append(opts,
				db.WithValidateField("value_type"),
				db.WithValidateField("regex_value"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRequestBodyValidator = func() *ValidateRequestBody {
	v := &ValidateRequestBody{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValueType := v.ValueTypeValidationRuleHandler
	rulesValueType := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhValueType(rulesValueType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RequestBody.value_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value_type"] = vFn

	vrhValueTypeExactValue := v.ValueTypeExactValueValidationRuleHandler
	rulesValueTypeExactValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["value_type.exact_value"], err = vrhValueTypeExactValue(rulesValueTypeExactValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestBody.value_type_exact_value: %s", err)
		panic(errMsg)
	}
	vrhValueTypeRegexValue := v.ValueTypeRegexValueValidationRuleHandler
	rulesValueTypeRegexValue := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
		"ves.io.schema.rules.string.min_len": "1",
		"ves.io.schema.rules.string.regex":   "true",
	}
	vFnMap["value_type.regex_value"], err = vrhValueTypeRegexValue(rulesValueTypeRegexValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field RequestBody.value_type_regex_value: %s", err)
		panic(errMsg)
	}

	v.FldValidators["value_type.exact_value"] = vFnMap["value_type.exact_value"]
	v.FldValidators["value_type.regex_value"] = vFnMap["value_type.regex_value"]

	return v
}()

func RequestBodyValidator() db.Validator {
	return DefaultRequestBodyValidator
}

// augmented methods on protoc/std generated struct

func (m *SensitiveDataPolicySettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SensitiveDataPolicySettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SensitiveDataPolicySettings) DeepCopy() *SensitiveDataPolicySettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SensitiveDataPolicySettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SensitiveDataPolicySettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SensitiveDataPolicySettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SensitiveDataPolicySettingsValidator().Validate(ctx, m, opts...)
}

func (m *SensitiveDataPolicySettings) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetSensitiveDataPolicyRefDRefInfo()

}

func (m *SensitiveDataPolicySettings) GetSensitiveDataPolicyRefDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetSensitiveDataPolicyRef()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("sensitive_data_policy.Object")
	dri := db.DRefInfo{
		RefdType:   "sensitive_data_policy.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "sensitive_data_policy_ref",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetSensitiveDataPolicyRefDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *SensitiveDataPolicySettings) GetSensitiveDataPolicyRefDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "sensitive_data_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: sensitive_data_policy")
	}

	vref := m.GetSensitiveDataPolicyRef()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "sensitive_data_policy.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateSensitiveDataPolicySettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSensitiveDataPolicySettings) SensitiveDataPolicyRefValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for sensitive_data_policy_ref")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSensitiveDataPolicySettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SensitiveDataPolicySettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SensitiveDataPolicySettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["sensitive_data_policy_ref"]; exists {

		vOpts := append(opts, db.WithValidateField("sensitive_data_policy_ref"))
		if err := fv(ctx, m.GetSensitiveDataPolicyRef(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSensitiveDataPolicySettingsValidator = func() *ValidateSensitiveDataPolicySettings {
	v := &ValidateSensitiveDataPolicySettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSensitiveDataPolicyRef := v.SensitiveDataPolicyRefValidationRuleHandler
	rulesSensitiveDataPolicyRef := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSensitiveDataPolicyRef(rulesSensitiveDataPolicyRef)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SensitiveDataPolicySettings.sensitive_data_policy_ref: %s", err)
		panic(errMsg)
	}
	v.FldValidators["sensitive_data_policy_ref"] = vFn

	return v
}()

func SensitiveDataPolicySettingsValidator() db.Validator {
	return DefaultSensitiveDataPolicySettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotDefensePolicyType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotDefensePolicyType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotDefensePolicyType) DeepCopy() *ShapeBotDefensePolicyType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotDefensePolicyType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotDefensePolicyType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotDefensePolicyType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotDefensePolicyTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotDefensePolicyType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotDefensePolicyType) JavaScriptChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for java_script_choice")
	}
	return validatorFn, nil
}

func (v *ValidateShapeBotDefensePolicyType) MobileSdkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mobile_sdk_choice")
	}
	return validatorFn, nil
}

func (v *ValidateShapeBotDefensePolicyType) ProtectedAppEndpointsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for protected_app_endpoints")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AppEndpointType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AppEndpointTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for protected_app_endpoints")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AppEndpointType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AppEndpointType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated protected_app_endpoints")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items protected_app_endpoints")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefensePolicyType) JsDownloadPathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for js_download_path")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefensePolicyType) JavascriptModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.JavaScriptMode)
		return int32(i)
	}
	// ves_io_schema.JavaScriptMode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.JavaScriptMode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for javascript_mode")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefensePolicyType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotDefensePolicyType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotDefensePolicyType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["java_script_choice"]; exists {
		val := m.GetJavaScriptChoice()
		vOpts := append(opts,
			db.WithValidateField("java_script_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetJavaScriptChoice().(type) {
	case *ShapeBotDefensePolicyType_DisableJsInsert:
		if fv, exists := v.FldValidators["java_script_choice.disable_js_insert"]; exists {
			val := m.GetJavaScriptChoice().(*ShapeBotDefensePolicyType_DisableJsInsert).DisableJsInsert
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("disable_js_insert"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotDefensePolicyType_JsInsertAllPages:
		if fv, exists := v.FldValidators["java_script_choice.js_insert_all_pages"]; exists {
			val := m.GetJavaScriptChoice().(*ShapeBotDefensePolicyType_JsInsertAllPages).JsInsertAllPages
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("js_insert_all_pages"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotDefensePolicyType_JsInsertAllPagesExcept:
		if fv, exists := v.FldValidators["java_script_choice.js_insert_all_pages_except"]; exists {
			val := m.GetJavaScriptChoice().(*ShapeBotDefensePolicyType_JsInsertAllPagesExcept).JsInsertAllPagesExcept
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("js_insert_all_pages_except"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotDefensePolicyType_JsInsertionRules:
		if fv, exists := v.FldValidators["java_script_choice.js_insertion_rules"]; exists {
			val := m.GetJavaScriptChoice().(*ShapeBotDefensePolicyType_JsInsertionRules).JsInsertionRules
			vOpts := append(opts,
				db.WithValidateField("java_script_choice"),
				db.WithValidateField("js_insertion_rules"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["javascript_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_mode"))
		if err := fv(ctx, m.GetJavascriptMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["js_download_path"]; exists {

		vOpts := append(opts, db.WithValidateField("js_download_path"))
		if err := fv(ctx, m.GetJsDownloadPath(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mobile_sdk_choice"]; exists {
		val := m.GetMobileSdkChoice()
		vOpts := append(opts,
			db.WithValidateField("mobile_sdk_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetMobileSdkChoice().(type) {
	case *ShapeBotDefensePolicyType_DisableMobileSdk:
		if fv, exists := v.FldValidators["mobile_sdk_choice.disable_mobile_sdk"]; exists {
			val := m.GetMobileSdkChoice().(*ShapeBotDefensePolicyType_DisableMobileSdk).DisableMobileSdk
			vOpts := append(opts,
				db.WithValidateField("mobile_sdk_choice"),
				db.WithValidateField("disable_mobile_sdk"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotDefensePolicyType_MobileSdkConfig:
		if fv, exists := v.FldValidators["mobile_sdk_choice.mobile_sdk_config"]; exists {
			val := m.GetMobileSdkChoice().(*ShapeBotDefensePolicyType_MobileSdkConfig).MobileSdkConfig
			vOpts := append(opts,
				db.WithValidateField("mobile_sdk_choice"),
				db.WithValidateField("mobile_sdk_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["protected_app_endpoints"]; exists {
		vOpts := append(opts, db.WithValidateField("protected_app_endpoints"))
		if err := fv(ctx, m.GetProtectedAppEndpoints(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotDefensePolicyTypeValidator = func() *ValidateShapeBotDefensePolicyType {
	v := &ValidateShapeBotDefensePolicyType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhJavaScriptChoice := v.JavaScriptChoiceValidationRuleHandler
	rulesJavaScriptChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhJavaScriptChoice(rulesJavaScriptChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefensePolicyType.java_script_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["java_script_choice"] = vFn

	vrhMobileSdkChoice := v.MobileSdkChoiceValidationRuleHandler
	rulesMobileSdkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhMobileSdkChoice(rulesMobileSdkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefensePolicyType.mobile_sdk_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mobile_sdk_choice"] = vFn

	vrhProtectedAppEndpoints := v.ProtectedAppEndpointsValidationRuleHandler
	rulesProtectedAppEndpoints := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhProtectedAppEndpoints(rulesProtectedAppEndpoints)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefensePolicyType.protected_app_endpoints: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protected_app_endpoints"] = vFn

	vrhJsDownloadPath := v.JsDownloadPathValidationRuleHandler
	rulesJsDownloadPath := map[string]string{
		"ves.io.schema.rules.string.http_path": "true",
	}
	vFn, err = vrhJsDownloadPath(rulesJsDownloadPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefensePolicyType.js_download_path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["js_download_path"] = vFn

	vrhJavascriptMode := v.JavascriptModeValidationRuleHandler
	rulesJavascriptMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhJavascriptMode(rulesJavascriptMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefensePolicyType.javascript_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["javascript_mode"] = vFn

	v.FldValidators["java_script_choice.js_insert_all_pages_except"] = ShapeJavaScriptInsertAllWithExceptionsTypeValidator().Validate
	v.FldValidators["java_script_choice.js_insertion_rules"] = ShapeJavaScriptInsertTypeValidator().Validate

	v.FldValidators["mobile_sdk_choice.mobile_sdk_config"] = MobileSDKConfigTypeValidator().Validate

	return v
}()

func ShapeBotDefensePolicyTypeValidator() db.Validator {
	return DefaultShapeBotDefensePolicyTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeBotDefenseType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeBotDefenseType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeBotDefenseType) DeepCopy() *ShapeBotDefenseType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeBotDefenseType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeBotDefenseType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeBotDefenseType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeBotDefenseTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeBotDefenseType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeBotDefenseType) CorsSupportChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cors_support_choice")
	}
	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseType) RegionalEndpointValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ShapeBotDefenseRegion)
		return int32(i)
	}
	// ShapeBotDefenseRegion_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ShapeBotDefenseRegion_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for regional_endpoint")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseType) PolicyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for policy")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ShapeBotDefensePolicyTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseType) TimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for timeout")
	}

	return validatorFn, nil
}

func (v *ValidateShapeBotDefenseType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeBotDefenseType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeBotDefenseType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cors_support_choice"]; exists {
		val := m.GetCorsSupportChoice()
		vOpts := append(opts,
			db.WithValidateField("cors_support_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCorsSupportChoice().(type) {
	case *ShapeBotDefenseType_EnableCorsSupport:
		if fv, exists := v.FldValidators["cors_support_choice.enable_cors_support"]; exists {
			val := m.GetCorsSupportChoice().(*ShapeBotDefenseType_EnableCorsSupport).EnableCorsSupport
			vOpts := append(opts,
				db.WithValidateField("cors_support_choice"),
				db.WithValidateField("enable_cors_support"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeBotDefenseType_DisableCorsSupport:
		if fv, exists := v.FldValidators["cors_support_choice.disable_cors_support"]; exists {
			val := m.GetCorsSupportChoice().(*ShapeBotDefenseType_DisableCorsSupport).DisableCorsSupport
			vOpts := append(opts,
				db.WithValidateField("cors_support_choice"),
				db.WithValidateField("disable_cors_support"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["policy"]; exists {

		vOpts := append(opts, db.WithValidateField("policy"))
		if err := fv(ctx, m.GetPolicy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["regional_endpoint"]; exists {

		vOpts := append(opts, db.WithValidateField("regional_endpoint"))
		if err := fv(ctx, m.GetRegionalEndpoint(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("timeout"))
		if err := fv(ctx, m.GetTimeout(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeBotDefenseTypeValidator = func() *ValidateShapeBotDefenseType {
	v := &ValidateShapeBotDefenseType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCorsSupportChoice := v.CorsSupportChoiceValidationRuleHandler
	rulesCorsSupportChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCorsSupportChoice(rulesCorsSupportChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseType.cors_support_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cors_support_choice"] = vFn

	vrhRegionalEndpoint := v.RegionalEndpointValidationRuleHandler
	rulesRegionalEndpoint := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.message.required":  "true",
	}
	vFn, err = vrhRegionalEndpoint(rulesRegionalEndpoint)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseType.regional_endpoint: %s", err)
		panic(errMsg)
	}
	v.FldValidators["regional_endpoint"] = vFn

	vrhPolicy := v.PolicyValidationRuleHandler
	rulesPolicy := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPolicy(rulesPolicy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseType.policy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["policy"] = vFn

	vrhTimeout := v.TimeoutValidationRuleHandler
	rulesTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "60000",
	}
	vFn, err = vrhTimeout(rulesTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeBotDefenseType.timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["timeout"] = vFn

	return v
}()

func ShapeBotDefenseTypeValidator() db.Validator {
	return DefaultShapeBotDefenseTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeJavaScriptExclusionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeJavaScriptExclusionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeJavaScriptExclusionRule) DeepCopy() *ShapeJavaScriptExclusionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeJavaScriptExclusionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeJavaScriptExclusionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeJavaScriptExclusionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeJavaScriptExclusionRuleValidator().Validate(ctx, m, opts...)
}

type ValidateShapeJavaScriptExclusionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeJavaScriptExclusionRule) DomainMatcherChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_matcher_choice")
	}
	return validatorFn, nil
}

func (v *ValidateShapeJavaScriptExclusionRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeJavaScriptExclusionRule) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for path")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.PathMatcherTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeJavaScriptExclusionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeJavaScriptExclusionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeJavaScriptExclusionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_matcher_choice"]; exists {
		val := m.GetDomainMatcherChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_matcher_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainMatcherChoice().(type) {
	case *ShapeJavaScriptExclusionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_matcher_choice.any_domain"]; exists {
			val := m.GetDomainMatcherChoice().(*ShapeJavaScriptExclusionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeJavaScriptExclusionRule_Domain:
		if fv, exists := v.FldValidators["domain_matcher_choice.domain"]; exists {
			val := m.GetDomainMatcherChoice().(*ShapeJavaScriptExclusionRule_Domain).Domain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeJavaScriptExclusionRuleValidator = func() *ValidateShapeJavaScriptExclusionRule {
	v := &ValidateShapeJavaScriptExclusionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainMatcherChoice := v.DomainMatcherChoiceValidationRuleHandler
	rulesDomainMatcherChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainMatcherChoice(rulesDomainMatcherChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeJavaScriptExclusionRule.domain_matcher_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_matcher_choice"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeJavaScriptExclusionRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeJavaScriptExclusionRule.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	v.FldValidators["domain_matcher_choice.domain"] = ves_io_schema.DomainTypeValidator().Validate

	return v
}()

func ShapeJavaScriptExclusionRuleValidator() db.Validator {
	return DefaultShapeJavaScriptExclusionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeJavaScriptInsertAllType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeJavaScriptInsertAllType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeJavaScriptInsertAllType) DeepCopy() *ShapeJavaScriptInsertAllType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeJavaScriptInsertAllType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeJavaScriptInsertAllType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeJavaScriptInsertAllType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeJavaScriptInsertAllTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeJavaScriptInsertAllType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeJavaScriptInsertAllType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeJavaScriptInsertAllType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeJavaScriptInsertAllType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["javascript_location"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_location"))
		if err := fv(ctx, m.GetJavascriptLocation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeJavaScriptInsertAllTypeValidator = func() *ValidateShapeJavaScriptInsertAllType {
	v := &ValidateShapeJavaScriptInsertAllType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ShapeJavaScriptInsertAllTypeValidator() db.Validator {
	return DefaultShapeJavaScriptInsertAllTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeJavaScriptInsertAllWithExceptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeJavaScriptInsertAllWithExceptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeJavaScriptInsertAllWithExceptionsType) DeepCopy() *ShapeJavaScriptInsertAllWithExceptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeJavaScriptInsertAllWithExceptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeJavaScriptInsertAllWithExceptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeJavaScriptInsertAllWithExceptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeJavaScriptInsertAllWithExceptionsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeJavaScriptInsertAllWithExceptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeJavaScriptInsertAllWithExceptionsType) ExcludeListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ShapeJavaScriptExclusionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ShapeJavaScriptExclusionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ShapeJavaScriptExclusionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ShapeJavaScriptExclusionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeJavaScriptInsertAllWithExceptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeJavaScriptInsertAllWithExceptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeJavaScriptInsertAllWithExceptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_list"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_list"))
		if err := fv(ctx, m.GetExcludeList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["javascript_location"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_location"))
		if err := fv(ctx, m.GetJavascriptLocation(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeJavaScriptInsertAllWithExceptionsTypeValidator = func() *ValidateShapeJavaScriptInsertAllWithExceptionsType {
	v := &ValidateShapeJavaScriptInsertAllWithExceptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExcludeList := v.ExcludeListValidationRuleHandler
	rulesExcludeList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeList(rulesExcludeList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeJavaScriptInsertAllWithExceptionsType.exclude_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_list"] = vFn

	return v
}()

func ShapeJavaScriptInsertAllWithExceptionsTypeValidator() db.Validator {
	return DefaultShapeJavaScriptInsertAllWithExceptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeJavaScriptInsertType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeJavaScriptInsertType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeJavaScriptInsertType) DeepCopy() *ShapeJavaScriptInsertType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeJavaScriptInsertType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeJavaScriptInsertType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeJavaScriptInsertType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeJavaScriptInsertTypeValidator().Validate(ctx, m, opts...)
}

type ValidateShapeJavaScriptInsertType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeJavaScriptInsertType) RulesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rules")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ShapeJavaScriptInsertionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ShapeJavaScriptInsertionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rules")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ShapeJavaScriptInsertionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ShapeJavaScriptInsertionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rules")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rules")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeJavaScriptInsertType) ExcludeListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for exclude_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ShapeJavaScriptExclusionRule, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ShapeJavaScriptExclusionRuleValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for exclude_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ShapeJavaScriptExclusionRule)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ShapeJavaScriptExclusionRule, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated exclude_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items exclude_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeJavaScriptInsertType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeJavaScriptInsertType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeJavaScriptInsertType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["exclude_list"]; exists {
		vOpts := append(opts, db.WithValidateField("exclude_list"))
		if err := fv(ctx, m.GetExcludeList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rules"]; exists {
		vOpts := append(opts, db.WithValidateField("rules"))
		if err := fv(ctx, m.GetRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeJavaScriptInsertTypeValidator = func() *ValidateShapeJavaScriptInsertType {
	v := &ValidateShapeJavaScriptInsertType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRules := v.RulesValidationRuleHandler
	rulesRules := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRules(rulesRules)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeJavaScriptInsertType.rules: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rules"] = vFn

	vrhExcludeList := v.ExcludeListValidationRuleHandler
	rulesExcludeList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhExcludeList(rulesExcludeList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeJavaScriptInsertType.exclude_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["exclude_list"] = vFn

	return v
}()

func ShapeJavaScriptInsertTypeValidator() db.Validator {
	return DefaultShapeJavaScriptInsertTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ShapeJavaScriptInsertionRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ShapeJavaScriptInsertionRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ShapeJavaScriptInsertionRule) DeepCopy() *ShapeJavaScriptInsertionRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ShapeJavaScriptInsertionRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ShapeJavaScriptInsertionRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ShapeJavaScriptInsertionRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ShapeJavaScriptInsertionRuleValidator().Validate(ctx, m, opts...)
}

type ValidateShapeJavaScriptInsertionRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateShapeJavaScriptInsertionRule) DomainMatcherChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for domain_matcher_choice")
	}
	return validatorFn, nil
}

func (v *ValidateShapeJavaScriptInsertionRule) MetadataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for metadata")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.MessageMetaTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeJavaScriptInsertionRule) PathValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for path")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema.PathMatcherTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateShapeJavaScriptInsertionRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ShapeJavaScriptInsertionRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ShapeJavaScriptInsertionRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["domain_matcher_choice"]; exists {
		val := m.GetDomainMatcherChoice()
		vOpts := append(opts,
			db.WithValidateField("domain_matcher_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDomainMatcherChoice().(type) {
	case *ShapeJavaScriptInsertionRule_AnyDomain:
		if fv, exists := v.FldValidators["domain_matcher_choice.any_domain"]; exists {
			val := m.GetDomainMatcherChoice().(*ShapeJavaScriptInsertionRule_AnyDomain).AnyDomain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("any_domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ShapeJavaScriptInsertionRule_Domain:
		if fv, exists := v.FldValidators["domain_matcher_choice.domain"]; exists {
			val := m.GetDomainMatcherChoice().(*ShapeJavaScriptInsertionRule_Domain).Domain
			vOpts := append(opts,
				db.WithValidateField("domain_matcher_choice"),
				db.WithValidateField("domain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["javascript_location"]; exists {

		vOpts := append(opts, db.WithValidateField("javascript_location"))
		if err := fv(ctx, m.GetJavascriptLocation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metadata"]; exists {

		vOpts := append(opts, db.WithValidateField("metadata"))
		if err := fv(ctx, m.GetMetadata(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path"]; exists {

		vOpts := append(opts, db.WithValidateField("path"))
		if err := fv(ctx, m.GetPath(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultShapeJavaScriptInsertionRuleValidator = func() *ValidateShapeJavaScriptInsertionRule {
	v := &ValidateShapeJavaScriptInsertionRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDomainMatcherChoice := v.DomainMatcherChoiceValidationRuleHandler
	rulesDomainMatcherChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDomainMatcherChoice(rulesDomainMatcherChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeJavaScriptInsertionRule.domain_matcher_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["domain_matcher_choice"] = vFn

	vrhMetadata := v.MetadataValidationRuleHandler
	rulesMetadata := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMetadata(rulesMetadata)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeJavaScriptInsertionRule.metadata: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metadata"] = vFn

	vrhPath := v.PathValidationRuleHandler
	rulesPath := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPath(rulesPath)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ShapeJavaScriptInsertionRule.path: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path"] = vFn

	v.FldValidators["domain_matcher_choice.domain"] = ves_io_schema.DomainTypeValidator().Validate

	return v
}()

func ShapeJavaScriptInsertionRuleValidator() db.Validator {
	return DefaultShapeJavaScriptInsertionRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *WebMobileTrafficType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WebMobileTrafficType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WebMobileTrafficType) DeepCopy() *WebMobileTrafficType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WebMobileTrafficType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WebMobileTrafficType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WebMobileTrafficType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WebMobileTrafficTypeValidator().Validate(ctx, m, opts...)
}

type ValidateWebMobileTrafficType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWebMobileTrafficType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WebMobileTrafficType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WebMobileTrafficType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header"]; exists {

		vOpts := append(opts, db.WithValidateField("header"))
		if err := fv(ctx, m.GetHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["headers"]; exists {

		vOpts := append(opts, db.WithValidateField("headers"))
		for idx, item := range m.GetHeaders() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mobile_identifier"]; exists {

		vOpts := append(opts, db.WithValidateField("mobile_identifier"))
		if err := fv(ctx, m.GetMobileIdentifier(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWebMobileTrafficTypeValidator = func() *ValidateWebMobileTrafficType {
	v := &ValidateWebMobileTrafficType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["header"] = ves_io_schema_policy.HeaderMatcherTypeBasicValidator().Validate

	v.FldValidators["headers"] = ves_io_schema_policy.HeaderMatcherTypeBasicValidator().Validate

	return v
}()

func WebMobileTrafficTypeValidator() db.Validator {
	return DefaultWebMobileTrafficTypeValidator
}
