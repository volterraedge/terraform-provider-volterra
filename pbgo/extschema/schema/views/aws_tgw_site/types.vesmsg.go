//
// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package aws_tgw_site

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_fleet "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/fleet"
	ves_io_schema_network_firewall "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/network_firewall"
	ves_io_schema_site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AWSTGWInfoConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSTGWInfoConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSTGWInfoConfigType) DeepCopy() *AWSTGWInfoConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSTGWInfoConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSTGWInfoConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSTGWInfoConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSTGWInfoConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSTGWInfoConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSTGWInfoConfigType) TgwIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_id")
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWInfoConfigType) VpcIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vpc_id")
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWInfoConfigType) SubnetIdsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.AWSSubnetIdsType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema_views.AWSSubnetIdsTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for subnet_ids")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.AWSSubnetIdsType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.AWSSubnetIdsType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated subnet_ids")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items subnet_ids")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWInfoConfigType) PublicIpsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for public_ips")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for public_ips")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated public_ips")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items public_ips")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWInfoConfigType) PrivateIpsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for private_ips")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for private_ips")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated private_ips")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items private_ips")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAWSTGWInfoConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSTGWInfoConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSTGWInfoConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["private_ips"]; exists {
		vOpts := append(opts, db.WithValidateField("private_ips"))
		if err := fv(ctx, m.GetPrivateIps(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_ips"]; exists {
		vOpts := append(opts, db.WithValidateField("public_ips"))
		if err := fv(ctx, m.GetPublicIps(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subnet_ids"]; exists {
		vOpts := append(opts, db.WithValidateField("subnet_ids"))
		if err := fv(ctx, m.GetSubnetIds(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_id"))
		if err := fv(ctx, m.GetTgwId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_id"))
		if err := fv(ctx, m.GetVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSTGWInfoConfigTypeValidator = func() *ValidateAWSTGWInfoConfigType {
	v := &ValidateAWSTGWInfoConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTgwId := v.TgwIdValidationRuleHandler
	rulesTgwId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.pattern":   "^(tgw-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhTgwId(rulesTgwId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWInfoConfigType.tgw_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_id"] = vFn

	vrhVpcId := v.VpcIdValidationRuleHandler
	rulesVpcId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.pattern":   "^(vpc-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhVpcId(rulesVpcId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWInfoConfigType.vpc_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vpc_id"] = vFn

	vrhSubnetIds := v.SubnetIdsValidationRuleHandler
	rulesSubnetIds := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.num_items": "0, 1,3",
	}
	vFn, err = vrhSubnetIds(rulesSubnetIds)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWInfoConfigType.subnet_ids: %s", err)
		panic(errMsg)
	}
	v.FldValidators["subnet_ids"] = vFn

	vrhPublicIps := v.PublicIpsValidationRuleHandler
	rulesPublicIps := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.repeated.items.string.ip": "true",
		"ves.io.schema.rules.repeated.num_items":       "0,1,3",
		"ves.io.schema.rules.repeated.unique":          "true",
	}
	vFn, err = vrhPublicIps(rulesPublicIps)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWInfoConfigType.public_ips: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ips"] = vFn

	vrhPrivateIps := v.PrivateIpsValidationRuleHandler
	rulesPrivateIps := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.repeated.items.string.ip": "true",
		"ves.io.schema.rules.repeated.num_items":       "0,1,3",
		"ves.io.schema.rules.repeated.unique":          "true",
	}
	vFn, err = vrhPrivateIps(rulesPrivateIps)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSTGWInfoConfigType.private_ips: %s", err)
		panic(errMsg)
	}
	v.FldValidators["private_ips"] = vFn

	return v
}()

func AWSTGWInfoConfigTypeValidator() db.Validator {
	return DefaultAWSTGWInfoConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AWSVPNTunnelConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AWSVPNTunnelConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AWSVPNTunnelConfigType) DeepCopy() *AWSVPNTunnelConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AWSVPNTunnelConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AWSVPNTunnelConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AWSVPNTunnelConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AWSVPNTunnelConfigTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAWSVPNTunnelConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAWSVPNTunnelConfigType) NodeNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_name")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPNTunnelConfigType) TunnelRemoteIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for tunnel_remote_ip")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tunnel_remote_ip")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tunnel_remote_ip")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tunnel_remote_ip")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPNTunnelConfigType) NodeIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_id")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPNTunnelConfigType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(VPNTunnelType)
		return int32(i)
	}
	// VPNTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, VPNTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateAWSVPNTunnelConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AWSVPNTunnelConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AWSVPNTunnelConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["node_id"]; exists {

		vOpts := append(opts, db.WithValidateField("node_id"))
		if err := fv(ctx, m.GetNodeId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_name"]; exists {

		vOpts := append(opts, db.WithValidateField("node_name"))
		if err := fv(ctx, m.GetNodeName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_remote_ip"]; exists {
		vOpts := append(opts, db.WithValidateField("tunnel_remote_ip"))
		if err := fv(ctx, m.GetTunnelRemoteIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAWSVPNTunnelConfigTypeValidator = func() *ValidateAWSVPNTunnelConfigType {
	v := &ValidateAWSVPNTunnelConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeName := v.NodeNameValidationRuleHandler
	rulesNodeName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhNodeName(rulesNodeName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPNTunnelConfigType.node_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_name"] = vFn

	vrhTunnelRemoteIp := v.TunnelRemoteIpValidationRuleHandler
	rulesTunnelRemoteIp := map[string]string{
		"ves.io.schema.rules.message.required":           "true",
		"ves.io.schema.rules.repeated.items.string.ipv4": "true",
		"ves.io.schema.rules.repeated.max_items":         "2",
		"ves.io.schema.rules.repeated.min_items":         "1",
		"ves.io.schema.rules.repeated.unique":            "true",
	}
	vFn, err = vrhTunnelRemoteIp(rulesTunnelRemoteIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPNTunnelConfigType.tunnel_remote_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_remote_ip"] = vFn

	vrhNodeId := v.NodeIdValidationRuleHandler
	rulesNodeId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhNodeId(rulesNodeId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPNTunnelConfigType.node_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_id"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AWSVPNTunnelConfigType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	return v
}()

func AWSVPNTunnelConfigTypeValidator() db.Validator {
	return DefaultAWSVPNTunnelConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ActiveServicePoliciesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ActiveServicePoliciesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ActiveServicePoliciesType) DeepCopy() *ActiveServicePoliciesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ActiveServicePoliciesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ActiveServicePoliciesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ActiveServicePoliciesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ActiveServicePoliciesTypeValidator().Validate(ctx, m, opts...)
}

func (m *ActiveServicePoliciesType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetServicePoliciesDRefInfo()

}

func (m *ActiveServicePoliciesType) GetServicePoliciesDRefInfo() ([]db.DRefInfo, error) {
	vrefs := m.GetServicePolicies()
	if len(vrefs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(vrefs))
	for i, vref := range vrefs {
		if vref == nil {
			return nil, fmt.Errorf("ActiveServicePoliciesType.service_policies[%d] has a nil value", i)
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("service_policy.Object")
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "service_policy.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "service_policies",
			Ref:        vdRef,
		})
	}
	return drInfos, nil

}

// GetServicePoliciesDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ActiveServicePoliciesType) GetServicePoliciesDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "service_policy.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: service_policy")
	}
	for i, vref := range m.GetServicePolicies() {
		if vref == nil {
			return nil, fmt.Errorf("ActiveServicePoliciesType.service_policies[%d] has a nil value", i)
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "service_policy.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateActiveServicePoliciesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateActiveServicePoliciesType) ServicePoliciesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for service_policies")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated service_policies")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items service_policies")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateActiveServicePoliciesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ActiveServicePoliciesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ActiveServicePoliciesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["service_policies"]; exists {
		vOpts := append(opts, db.WithValidateField("service_policies"))
		if err := fv(ctx, m.GetServicePolicies(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultActiveServicePoliciesTypeValidator = func() *ValidateActiveServicePoliciesType {
	v := &ValidateActiveServicePoliciesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhServicePolicies := v.ServicePoliciesValidationRuleHandler
	rulesServicePolicies := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "32",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhServicePolicies(rulesServicePolicies)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ActiveServicePoliciesType.service_policies: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_policies"] = vFn

	return v
}()

func ActiveServicePoliciesTypeValidator() db.Validator {
	return DefaultActiveServicePoliciesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *CreateSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetVnConfig().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting CreateSpecType.vn_config")
	}

	return nil
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAwsParametersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAwsParametersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLogsReceiverChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTgwSecurityDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTgwSecurityDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVnConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVnConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetAwsParametersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAwsParameters() == nil {
		return nil, nil
	}

	drInfos, err := m.GetAwsParameters().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetAwsParameters().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "aws_parameters." + dri.DRField
	}
	return drInfos, err

}

func (m *CreateSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetLogsReceiverChoice().(type) {
	case *CreateSpecType_LogsStreamingDisabled:

		return nil, nil

	case *CreateSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		dri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *CreateSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *CreateSpecType_LogsStreamingDisabled:

	case *CreateSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetTgwSecurityDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTgwSecurity() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTgwSecurity().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTgwSecurity().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tgw_security." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetVnConfigDRefInfo() ([]db.DRefInfo, error) {
	if m.GetVnConfig() == nil {
		return nil, nil
	}

	drInfos, err := m.GetVnConfig().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetVnConfig().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "vn_config." + dri.DRField
	}
	return drInfos, err

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) BlockedServicesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocked_services_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) DirectConnectChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for direct_connect_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) AwsParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_parameters")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ServicesVPCTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) TagsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for tags")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for tags")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for tags")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map tags")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tags")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_parameters"))
		if err := fv(ctx, m.GetAwsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocked_services_choice"]; exists {
		val := m.GetBlockedServicesChoice()
		vOpts := append(opts,
			db.WithValidateField("blocked_services_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockedServicesChoice().(type) {
	case *CreateSpecType_DefaultBlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.default_blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*CreateSpecType_DefaultBlockedServices).DefaultBlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("default_blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_BlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*CreateSpecType_BlockedServices).BlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["direct_connect_choice"]; exists {
		val := m.GetDirectConnectChoice()
		vOpts := append(opts,
			db.WithValidateField("direct_connect_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDirectConnectChoice().(type) {
	case *CreateSpecType_DirectConnectDisabled:
		if fv, exists := v.FldValidators["direct_connect_choice.direct_connect_disabled"]; exists {
			val := m.GetDirectConnectChoice().(*CreateSpecType_DirectConnectDisabled).DirectConnectDisabled
			vOpts := append(opts,
				db.WithValidateField("direct_connect_choice"),
				db.WithValidateField("direct_connect_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DirectConnectEnabled:
		if fv, exists := v.FldValidators["direct_connect_choice.direct_connect_enabled"]; exists {
			val := m.GetDirectConnectChoice().(*CreateSpecType_DirectConnectEnabled).DirectConnectEnabled
			vOpts := append(opts,
				db.WithValidateField("direct_connect_choice"),
				db.WithValidateField("direct_connect_enabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["local_control_plane"]; exists {

		vOpts := append(opts, db.WithValidateField("local_control_plane"))
		if err := fv(ctx, m.GetLocalControlPlane(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *CreateSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*CreateSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*CreateSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["os"]; exists {

		vOpts := append(opts, db.WithValidateField("os"))
		if err := fv(ctx, m.GetOs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sw"]; exists {

		vOpts := append(opts, db.WithValidateField("sw"))
		if err := fv(ctx, m.GetSw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {
		vOpts := append(opts, db.WithValidateField("tags"))
		if err := fv(ctx, m.GetTags(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_security"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_security"))
		if err := fv(ctx, m.GetTgwSecurity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vn_config"]; exists {

		vOpts := append(opts, db.WithValidateField("vn_config"))
		if err := fv(ctx, m.GetVnConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_attachments"))
		if err := fv(ctx, m.GetVpcAttachments(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBlockedServicesChoice := v.BlockedServicesChoiceValidationRuleHandler
	rulesBlockedServicesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockedServicesChoice(rulesBlockedServicesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.blocked_services_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocked_services_choice"] = vFn

	vrhDirectConnectChoice := v.DirectConnectChoiceValidationRuleHandler
	rulesDirectConnectChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDirectConnectChoice(rulesDirectConnectChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.direct_connect_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["direct_connect_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhAwsParameters := v.AwsParametersValidationRuleHandler
	rulesAwsParameters := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsParameters(rulesAwsParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.aws_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_parameters"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhTags := v.TagsValidationRuleHandler
	rulesTags := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "127",
		"ves.io.schema.rules.map.max_pairs":             "5",
		"ves.io.schema.rules.map.values.string.max_len": "255",
	}
	vFn, err = vrhTags(rulesTags)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.tags: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tags"] = vFn

	v.FldValidators["blocked_services_choice.blocked_services"] = ves_io_schema_fleet.BlockedServicesListTypeValidator().Validate

	v.FldValidators["direct_connect_choice.direct_connect_enabled"] = ves_io_schema_views.DirectConnectConfigTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["vpc_attachments"] = VPCAttachmentListTypeValidator().Validate

	v.FldValidators["tgw_security"] = SecurityConfigTypeValidator().Validate

	v.FldValidators["vn_config"] = VnConfigurationValidator().Validate

	v.FldValidators["coordinates"] = ves_io_schema_site.CoordinatesValidator().Validate

	v.FldValidators["sw"] = ves_io_schema_views.VolterraSoftwareTypeValidator().Validate

	v.FldValidators["os"] = ves_io_schema_views.OperatingSystemTypeValidator().Validate

	v.FldValidators["local_control_plane"] = ves_io_schema_views.LocalControlPlaneTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ExistingTGWType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ExistingTGWType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ExistingTGWType) DeepCopy() *ExistingTGWType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ExistingTGWType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ExistingTGWType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ExistingTGWType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ExistingTGWTypeValidator().Validate(ctx, m, opts...)
}

type ValidateExistingTGWType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateExistingTGWType) TgwIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_id")
	}

	return validatorFn, nil
}

func (v *ValidateExistingTGWType) TgwAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_asn")
	}

	return validatorFn, nil
}

func (v *ValidateExistingTGWType) VolterraSiteAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_site_asn")
	}

	return validatorFn, nil
}

func (v *ValidateExistingTGWType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ExistingTGWType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ExistingTGWType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tgw_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_asn"))
		if err := fv(ctx, m.GetTgwAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_id"))
		if err := fv(ctx, m.GetTgwId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_site_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_site_asn"))
		if err := fv(ctx, m.GetVolterraSiteAsn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultExistingTGWTypeValidator = func() *ValidateExistingTGWType {
	v := &ValidateExistingTGWType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTgwId := v.TgwIdValidationRuleHandler
	rulesTgwId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(tgw-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhTgwId(rulesTgwId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ExistingTGWType.tgw_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_id"] = vFn

	vrhTgwAsn := v.TgwAsnValidationRuleHandler
	rulesTgwAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt":  "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhTgwAsn(rulesTgwAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ExistingTGWType.tgw_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_asn"] = vFn

	vrhVolterraSiteAsn := v.VolterraSiteAsnValidationRuleHandler
	rulesVolterraSiteAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt":  "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhVolterraSiteAsn(rulesVolterraSiteAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ExistingTGWType.volterra_site_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_site_asn"] = vFn

	return v
}()

func ExistingTGWTypeValidator() db.Validator {
	return DefaultExistingTGWTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GetSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetVnConfig().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GetSpecType.vn_config")
	}

	return nil
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAwsParametersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAwsParametersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLogsReceiverChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTgwSecurityDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTgwSecurityDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVnConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVnConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetAwsParametersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAwsParameters() == nil {
		return nil, nil
	}

	drInfos, err := m.GetAwsParameters().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetAwsParameters().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "aws_parameters." + dri.DRField
	}
	return drInfos, err

}

func (m *GetSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetLogsReceiverChoice().(type) {
	case *GetSpecType_LogsStreamingDisabled:

		return nil, nil

	case *GetSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		dri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *GetSpecType_LogsStreamingDisabled:

	case *GetSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetTgwSecurityDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTgwSecurity() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTgwSecurity().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTgwSecurity().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tgw_security." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetVnConfigDRefInfo() ([]db.DRefInfo, error) {
	if m.GetVnConfig() == nil {
		return nil, nil
	}

	drInfos, err := m.GetVnConfig().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetVnConfig().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "vn_config." + dri.DRField
	}
	return drInfos, err

}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) BlockedServicesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocked_services_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) DirectConnectChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for direct_connect_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) AwsParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_parameters")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ServicesVPCTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) VipParamsPerAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_site.PublishVIPParamsPerAz, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema_site.PublishVIPParamsPerAzValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vip_params_per_az")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_site.PublishVIPParamsPerAz)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_site.PublishVIPParamsPerAz, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vip_params_per_az")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vip_params_per_az")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TagsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for tags")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for tags")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for tags")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map tags")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tags")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TunnelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*AWSVPNTunnelConfigType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := AWSVPNTunnelConfigTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tunnels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AWSVPNTunnelConfigType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AWSVPNTunnelConfigType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tunnels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tunnels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_parameters"))
		if err := fv(ctx, m.GetAwsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocked_services_choice"]; exists {
		val := m.GetBlockedServicesChoice()
		vOpts := append(opts,
			db.WithValidateField("blocked_services_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockedServicesChoice().(type) {
	case *GetSpecType_DefaultBlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.default_blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*GetSpecType_DefaultBlockedServices).DefaultBlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("default_blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_BlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*GetSpecType_BlockedServices).BlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["direct_connect_choice"]; exists {
		val := m.GetDirectConnectChoice()
		vOpts := append(opts,
			db.WithValidateField("direct_connect_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDirectConnectChoice().(type) {
	case *GetSpecType_DirectConnectDisabled:
		if fv, exists := v.FldValidators["direct_connect_choice.direct_connect_disabled"]; exists {
			val := m.GetDirectConnectChoice().(*GetSpecType_DirectConnectDisabled).DirectConnectDisabled
			vOpts := append(opts,
				db.WithValidateField("direct_connect_choice"),
				db.WithValidateField("direct_connect_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DirectConnectEnabled:
		if fv, exists := v.FldValidators["direct_connect_choice.direct_connect_enabled"]; exists {
			val := m.GetDirectConnectChoice().(*GetSpecType_DirectConnectEnabled).DirectConnectEnabled
			vOpts := append(opts,
				db.WithValidateField("direct_connect_choice"),
				db.WithValidateField("direct_connect_enabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["direct_connect_info"]; exists {

		vOpts := append(opts, db.WithValidateField("direct_connect_info"))
		if err := fv(ctx, m.GetDirectConnectInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *GetSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*GetSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*GetSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_state"]; exists {

		vOpts := append(opts, db.WithValidateField("site_state"))
		if err := fv(ctx, m.GetSiteState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {
		vOpts := append(opts, db.WithValidateField("tags"))
		if err := fv(ctx, m.GetTags(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_info"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_info"))
		if err := fv(ctx, m.GetTgwInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_security"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_security"))
		if err := fv(ctx, m.GetTgwSecurity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnels"]; exists {
		vOpts := append(opts, db.WithValidateField("tunnels"))
		if err := fv(ctx, m.GetTunnels(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_modification_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("user_modification_timestamp"))
		if err := fv(ctx, m.GetUserModificationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_params_per_az"]; exists {
		vOpts := append(opts, db.WithValidateField("vip_params_per_az"))
		if err := fv(ctx, m.GetVipParamsPerAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vn_config"]; exists {

		vOpts := append(opts, db.WithValidateField("vn_config"))
		if err := fv(ctx, m.GetVnConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_attachments"))
		if err := fv(ctx, m.GetVpcAttachments(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_ip_prefixes"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_ip_prefixes"))
		for key, value := range m.GetVpcIpPrefixes() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBlockedServicesChoice := v.BlockedServicesChoiceValidationRuleHandler
	rulesBlockedServicesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockedServicesChoice(rulesBlockedServicesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.blocked_services_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocked_services_choice"] = vFn

	vrhDirectConnectChoice := v.DirectConnectChoiceValidationRuleHandler
	rulesDirectConnectChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDirectConnectChoice(rulesDirectConnectChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.direct_connect_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["direct_connect_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhAwsParameters := v.AwsParametersValidationRuleHandler
	rulesAwsParameters := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsParameters(rulesAwsParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.aws_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_parameters"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhVipParamsPerAz := v.VipParamsPerAzValidationRuleHandler
	rulesVipParamsPerAz := map[string]string{
		"ves.io.schema.rules.repeated.num_items": "0,1,2,3",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhVipParamsPerAz(rulesVipParamsPerAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.vip_params_per_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vip_params_per_az"] = vFn

	vrhTags := v.TagsValidationRuleHandler
	rulesTags := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "127",
		"ves.io.schema.rules.map.max_pairs":             "5",
		"ves.io.schema.rules.map.values.string.max_len": "255",
	}
	vFn, err = vrhTags(rulesTags)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tags: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tags"] = vFn

	vrhTunnels := v.TunnelsValidationRuleHandler
	rulesTunnels := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhTunnels(rulesTunnels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tunnels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnels"] = vFn

	v.FldValidators["blocked_services_choice.blocked_services"] = ves_io_schema_fleet.BlockedServicesListTypeValidator().Validate

	v.FldValidators["direct_connect_choice.direct_connect_enabled"] = ves_io_schema_views.DirectConnectConfigTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["vpc_attachments"] = VPCAttachmentListTypeValidator().Validate

	v.FldValidators["tgw_security"] = SecurityConfigTypeValidator().Validate

	v.FldValidators["vpc_ip_prefixes"] = VPCIpPrefixesTypeValidator().Validate

	v.FldValidators["vn_config"] = VnConfigurationValidator().Validate

	v.FldValidators["coordinates"] = ves_io_schema_site.CoordinatesValidator().Validate

	v.FldValidators["tgw_info"] = AWSTGWInfoConfigTypeValidator().Validate

	v.FldValidators["direct_connect_info"] = ves_io_schema_views.DirectConnectInfoValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *GlobalSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetVnConfig().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting GlobalSpecType.vn_config")
	}

	return nil
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAwsParametersDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAwsParametersDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLogsReceiverChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTfParamsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTfParamsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTgwSecurityDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTgwSecurityDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetViewInternalDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetViewInternalDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVnConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVnConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetAwsParametersDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAwsParameters() == nil {
		return nil, nil
	}

	drInfos, err := m.GetAwsParameters().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetAwsParameters().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "aws_parameters." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetLogsReceiverChoice().(type) {
	case *GlobalSpecType_LogsStreamingDisabled:

		return nil, nil

	case *GlobalSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		dri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *GlobalSpecType_LogsStreamingDisabled:

	case *GlobalSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

func (m *GlobalSpecType) GetTfParamsDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetTfParams()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("terraform_parameters.Object")
	dri := db.DRefInfo{
		RefdType:   "terraform_parameters.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "tf_params",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetTfParamsDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetTfParamsDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "terraform_parameters.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: terraform_parameters")
	}

	vref := m.GetTfParams()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "terraform_parameters.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetTgwSecurityDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTgwSecurity() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTgwSecurity().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTgwSecurity().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tgw_security." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetViewInternalDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("view_internal.Object")
	dri := db.DRefInfo{
		RefdType:   "view_internal.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "view_internal",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetViewInternalDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetViewInternalDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "view_internal.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: view_internal")
	}

	vref := m.GetViewInternal()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "view_internal.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetVnConfigDRefInfo() ([]db.DRefInfo, error) {
	if m.GetVnConfig() == nil {
		return nil, nil
	}

	drInfos, err := m.GetVnConfig().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetVnConfig().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "vn_config." + dri.DRField
	}
	return drInfos, err

}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) BlockedServicesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocked_services_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DirectConnectChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for direct_connect_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AwsParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_parameters")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ServicesVPCTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VolterraSoftwareVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_software_version")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OperatingSystemVersionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for operating_system_version")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VipParamsPerAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_site.PublishVIPParamsPerAz, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema_site.PublishVIPParamsPerAzValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vip_params_per_az")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_site.PublishVIPParamsPerAz)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_site.PublishVIPParamsPerAz, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vip_params_per_az")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vip_params_per_az")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TagsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for tags")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for tags")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for tags")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map tags")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tags")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TunnelsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*AWSVPNTunnelConfigType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := AWSVPNTunnelConfigTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tunnels")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AWSVPNTunnelConfigType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AWSVPNTunnelConfigType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tunnels")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tunnels")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_parameters"))
		if err := fv(ctx, m.GetAwsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocked_services_choice"]; exists {
		val := m.GetBlockedServicesChoice()
		vOpts := append(opts,
			db.WithValidateField("blocked_services_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockedServicesChoice().(type) {
	case *GlobalSpecType_DefaultBlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.default_blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*GlobalSpecType_DefaultBlockedServices).DefaultBlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("default_blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_BlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*GlobalSpecType_BlockedServices).BlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["direct_connect_choice"]; exists {
		val := m.GetDirectConnectChoice()
		vOpts := append(opts,
			db.WithValidateField("direct_connect_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDirectConnectChoice().(type) {
	case *GlobalSpecType_DirectConnectDisabled:
		if fv, exists := v.FldValidators["direct_connect_choice.direct_connect_disabled"]; exists {
			val := m.GetDirectConnectChoice().(*GlobalSpecType_DirectConnectDisabled).DirectConnectDisabled
			vOpts := append(opts,
				db.WithValidateField("direct_connect_choice"),
				db.WithValidateField("direct_connect_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DirectConnectEnabled:
		if fv, exists := v.FldValidators["direct_connect_choice.direct_connect_enabled"]; exists {
			val := m.GetDirectConnectChoice().(*GlobalSpecType_DirectConnectEnabled).DirectConnectEnabled
			vOpts := append(opts,
				db.WithValidateField("direct_connect_choice"),
				db.WithValidateField("direct_connect_enabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["direct_connect_info"]; exists {

		vOpts := append(opts, db.WithValidateField("direct_connect_info"))
		if err := fv(ctx, m.GetDirectConnectInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_control_plane"]; exists {

		vOpts := append(opts, db.WithValidateField("local_control_plane"))
		if err := fv(ctx, m.GetLocalControlPlane(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *GlobalSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*GlobalSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*GlobalSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["os"]; exists {

		vOpts := append(opts, db.WithValidateField("os"))
		if err := fv(ctx, m.GetOs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sw"]; exists {

		vOpts := append(opts, db.WithValidateField("sw"))
		if err := fv(ctx, m.GetSw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tags"]; exists {
		vOpts := append(opts, db.WithValidateField("tags"))
		if err := fv(ctx, m.GetTags(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tf_params"]; exists {

		vOpts := append(opts, db.WithValidateField("tf_params"))
		if err := fv(ctx, m.GetTfParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_info"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_info"))
		if err := fv(ctx, m.GetTgwInfo(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_security"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_security"))
		if err := fv(ctx, m.GetTgwSecurity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnels"]; exists {
		vOpts := append(opts, db.WithValidateField("tunnels"))
		if err := fv(ctx, m.GetTunnels(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_modification_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("user_modification_timestamp"))
		if err := fv(ctx, m.GetUserModificationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["view_internal"]; exists {

		vOpts := append(opts, db.WithValidateField("view_internal"))
		if err := fv(ctx, m.GetViewInternal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_params_per_az"]; exists {
		vOpts := append(opts, db.WithValidateField("vip_params_per_az"))
		if err := fv(ctx, m.GetVipParamsPerAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vn_config"]; exists {

		vOpts := append(opts, db.WithValidateField("vn_config"))
		if err := fv(ctx, m.GetVnConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_attachments"))
		if err := fv(ctx, m.GetVpcAttachments(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_ip_prefixes"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_ip_prefixes"))
		for key, value := range m.GetVpcIpPrefixes() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBlockedServicesChoice := v.BlockedServicesChoiceValidationRuleHandler
	rulesBlockedServicesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockedServicesChoice(rulesBlockedServicesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.blocked_services_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocked_services_choice"] = vFn

	vrhDirectConnectChoice := v.DirectConnectChoiceValidationRuleHandler
	rulesDirectConnectChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDirectConnectChoice(rulesDirectConnectChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.direct_connect_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["direct_connect_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhAwsParameters := v.AwsParametersValidationRuleHandler
	rulesAwsParameters := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsParameters(rulesAwsParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.aws_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_parameters"] = vFn

	vrhVolterraSoftwareVersion := v.VolterraSoftwareVersionValidationRuleHandler
	rulesVolterraSoftwareVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhVolterraSoftwareVersion(rulesVolterraSoftwareVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.volterra_software_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_software_version"] = vFn

	vrhOperatingSystemVersion := v.OperatingSystemVersionValidationRuleHandler
	rulesOperatingSystemVersion := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhOperatingSystemVersion(rulesOperatingSystemVersion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.operating_system_version: %s", err)
		panic(errMsg)
	}
	v.FldValidators["operating_system_version"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhVipParamsPerAz := v.VipParamsPerAzValidationRuleHandler
	rulesVipParamsPerAz := map[string]string{
		"ves.io.schema.rules.repeated.num_items": "0,1,2,3",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhVipParamsPerAz(rulesVipParamsPerAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.vip_params_per_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vip_params_per_az"] = vFn

	vrhTags := v.TagsValidationRuleHandler
	rulesTags := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len":   "127",
		"ves.io.schema.rules.map.max_pairs":             "5",
		"ves.io.schema.rules.map.values.string.max_len": "255",
	}
	vFn, err = vrhTags(rulesTags)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tags: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tags"] = vFn

	vrhTunnels := v.TunnelsValidationRuleHandler
	rulesTunnels := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhTunnels(rulesTunnels)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tunnels: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnels"] = vFn

	v.FldValidators["blocked_services_choice.blocked_services"] = ves_io_schema_fleet.BlockedServicesListTypeValidator().Validate

	v.FldValidators["direct_connect_choice.direct_connect_enabled"] = ves_io_schema_views.DirectConnectConfigTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["vpc_attachments"] = VPCAttachmentListTypeValidator().Validate

	v.FldValidators["tgw_security"] = SecurityConfigTypeValidator().Validate

	v.FldValidators["vpc_ip_prefixes"] = VPCIpPrefixesTypeValidator().Validate

	v.FldValidators["vn_config"] = VnConfigurationValidator().Validate

	v.FldValidators["coordinates"] = ves_io_schema_site.CoordinatesValidator().Validate

	v.FldValidators["tgw_info"] = AWSTGWInfoConfigTypeValidator().Validate

	v.FldValidators["sw"] = ves_io_schema_views.VolterraSoftwareTypeValidator().Validate

	v.FldValidators["os"] = ves_io_schema_views.OperatingSystemTypeValidator().Validate

	v.FldValidators["local_control_plane"] = ves_io_schema_views.LocalControlPlaneTypeValidator().Validate

	v.FldValidators["tf_params"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["view_internal"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["direct_connect_info"] = ves_io_schema_views.DirectConnectInfoValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *ReplaceSpecType) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetVnConfig().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting ReplaceSpecType.vn_config")
	}

	return nil
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetLogsReceiverChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetLogsReceiverChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTgwSecurityDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTgwSecurityDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVnConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVnConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *ReplaceSpecType) GetLogsReceiverChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetLogsReceiverChoice().(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:

		return nil, nil

	case *ReplaceSpecType_LogReceiver:

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("log_receiver.Object")
		dri := db.DRefInfo{
			RefdType:   "log_receiver.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "log_receiver",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetLogsReceiverChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ReplaceSpecType) GetLogsReceiverChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetLogsReceiverChoice().(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:

	case *ReplaceSpecType_LogReceiver:
		refdType, err := d.TypeForEntryKind("", "", "log_receiver.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: log_receiver")
		}

		vref := m.GetLogReceiver()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "log_receiver.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetTgwSecurityDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTgwSecurity() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTgwSecurity().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTgwSecurity().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tgw_security." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetVnConfigDRefInfo() ([]db.DRefInfo, error) {
	if m.GetVnConfig() == nil {
		return nil, nil
	}

	drInfos, err := m.GetVnConfig().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetVnConfig().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "vn_config." + dri.DRField
	}
	return drInfos, err

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) BlockedServicesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocked_services_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) DirectConnectChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for direct_connect_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) LogsReceiverChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for logs_receiver_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) AwsParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for aws_parameters")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ServicesVPCReplaceTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_parameters"))
		if err := fv(ctx, m.GetAwsParameters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["blocked_services_choice"]; exists {
		val := m.GetBlockedServicesChoice()
		vOpts := append(opts,
			db.WithValidateField("blocked_services_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockedServicesChoice().(type) {
	case *ReplaceSpecType_DefaultBlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.default_blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*ReplaceSpecType_DefaultBlockedServices).DefaultBlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("default_blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_BlockedServices:
		if fv, exists := v.FldValidators["blocked_services_choice.blocked_services"]; exists {
			val := m.GetBlockedServicesChoice().(*ReplaceSpecType_BlockedServices).BlockedServices
			vOpts := append(opts,
				db.WithValidateField("blocked_services_choice"),
				db.WithValidateField("blocked_services"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["direct_connect_choice"]; exists {
		val := m.GetDirectConnectChoice()
		vOpts := append(opts,
			db.WithValidateField("direct_connect_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDirectConnectChoice().(type) {
	case *ReplaceSpecType_DirectConnectDisabled:
		if fv, exists := v.FldValidators["direct_connect_choice.direct_connect_disabled"]; exists {
			val := m.GetDirectConnectChoice().(*ReplaceSpecType_DirectConnectDisabled).DirectConnectDisabled
			vOpts := append(opts,
				db.WithValidateField("direct_connect_choice"),
				db.WithValidateField("direct_connect_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DirectConnectEnabled:
		if fv, exists := v.FldValidators["direct_connect_choice.direct_connect_enabled"]; exists {
			val := m.GetDirectConnectChoice().(*ReplaceSpecType_DirectConnectEnabled).DirectConnectEnabled
			vOpts := append(opts,
				db.WithValidateField("direct_connect_choice"),
				db.WithValidateField("direct_connect_enabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["logs_receiver_choice"]; exists {
		val := m.GetLogsReceiverChoice()
		vOpts := append(opts,
			db.WithValidateField("logs_receiver_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLogsReceiverChoice().(type) {
	case *ReplaceSpecType_LogsStreamingDisabled:
		if fv, exists := v.FldValidators["logs_receiver_choice.logs_streaming_disabled"]; exists {
			val := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogsStreamingDisabled).LogsStreamingDisabled
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("logs_streaming_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_LogReceiver:
		if fv, exists := v.FldValidators["logs_receiver_choice.log_receiver"]; exists {
			val := m.GetLogsReceiverChoice().(*ReplaceSpecType_LogReceiver).LogReceiver
			vOpts := append(opts,
				db.WithValidateField("logs_receiver_choice"),
				db.WithValidateField("log_receiver"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tgw_security"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_security"))
		if err := fv(ctx, m.GetTgwSecurity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vn_config"]; exists {

		vOpts := append(opts, db.WithValidateField("vn_config"))
		if err := fv(ctx, m.GetVnConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vpc_attachments"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_attachments"))
		if err := fv(ctx, m.GetVpcAttachments(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBlockedServicesChoice := v.BlockedServicesChoiceValidationRuleHandler
	rulesBlockedServicesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockedServicesChoice(rulesBlockedServicesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.blocked_services_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocked_services_choice"] = vFn

	vrhDirectConnectChoice := v.DirectConnectChoiceValidationRuleHandler
	rulesDirectConnectChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDirectConnectChoice(rulesDirectConnectChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.direct_connect_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["direct_connect_choice"] = vFn

	vrhLogsReceiverChoice := v.LogsReceiverChoiceValidationRuleHandler
	rulesLogsReceiverChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLogsReceiverChoice(rulesLogsReceiverChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.logs_receiver_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["logs_receiver_choice"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhAwsParameters := v.AwsParametersValidationRuleHandler
	rulesAwsParameters := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAwsParameters(rulesAwsParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.aws_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_parameters"] = vFn

	v.FldValidators["blocked_services_choice.blocked_services"] = ves_io_schema_fleet.BlockedServicesListTypeValidator().Validate

	v.FldValidators["direct_connect_choice.direct_connect_enabled"] = ves_io_schema_views.DirectConnectConfigTypeValidator().Validate

	v.FldValidators["logs_receiver_choice.log_receiver"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["vpc_attachments"] = VPCAttachmentListTypeValidator().Validate

	v.FldValidators["tgw_security"] = SecurityConfigTypeValidator().Validate

	v.FldValidators["vn_config"] = VnConfigurationValidator().Validate

	v.FldValidators["coordinates"] = ves_io_schema_site.CoordinatesValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityConfigType) DeepCopy() *SecurityConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityConfigTypeValidator().Validate(ctx, m, opts...)
}

func (m *SecurityConfigType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetEastWestServicePolicyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetEastWestServicePolicyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetForwardProxyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetForwardProxyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkPolicyChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkPolicyChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *SecurityConfigType) GetEastWestServicePolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetEastWestServicePolicyChoice() == nil {
		return nil, nil
	}
	switch m.GetEastWestServicePolicyChoice().(type) {
	case *SecurityConfigType_NoEastWestPolicy:

		return nil, nil

	case *SecurityConfigType_ActiveEastWestServicePolicies:
		drInfos, err := m.GetActiveEastWestServicePolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveEastWestServicePolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_east_west_service_policies." + dri.DRField
		}
		return drInfos, err

	case *SecurityConfigType_EastWestServicePolicyAllowAll:

		return nil, nil

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *SecurityConfigType) GetForwardProxyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetForwardProxyChoice() == nil {
		return nil, nil
	}
	switch m.GetForwardProxyChoice().(type) {
	case *SecurityConfigType_NoForwardProxy:

		return nil, nil

	case *SecurityConfigType_ActiveForwardProxyPolicies:
		drInfos, err := m.GetActiveForwardProxyPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveForwardProxyPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_forward_proxy_policies." + dri.DRField
		}
		return drInfos, err

	case *SecurityConfigType_ForwardProxyAllowAll:

		return nil, nil

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *SecurityConfigType) GetNetworkPolicyChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNetworkPolicyChoice() == nil {
		return nil, nil
	}
	switch m.GetNetworkPolicyChoice().(type) {
	case *SecurityConfigType_NoNetworkPolicy:

		return nil, nil

	case *SecurityConfigType_ActiveNetworkPolicies:
		drInfos, err := m.GetActiveNetworkPolicies().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetActiveNetworkPolicies().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "active_network_policies." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateSecurityConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityConfigType) EastWestServicePolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for east_west_service_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSecurityConfigType) ForwardProxyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for forward_proxy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSecurityConfigType) NetworkPolicyChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_policy_choice")
	}
	return validatorFn, nil
}

func (v *ValidateSecurityConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["east_west_service_policy_choice"]; exists {
		val := m.GetEastWestServicePolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("east_west_service_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEastWestServicePolicyChoice().(type) {
	case *SecurityConfigType_NoEastWestPolicy:
		if fv, exists := v.FldValidators["east_west_service_policy_choice.no_east_west_policy"]; exists {
			val := m.GetEastWestServicePolicyChoice().(*SecurityConfigType_NoEastWestPolicy).NoEastWestPolicy
			vOpts := append(opts,
				db.WithValidateField("east_west_service_policy_choice"),
				db.WithValidateField("no_east_west_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityConfigType_ActiveEastWestServicePolicies:
		if fv, exists := v.FldValidators["east_west_service_policy_choice.active_east_west_service_policies"]; exists {
			val := m.GetEastWestServicePolicyChoice().(*SecurityConfigType_ActiveEastWestServicePolicies).ActiveEastWestServicePolicies
			vOpts := append(opts,
				db.WithValidateField("east_west_service_policy_choice"),
				db.WithValidateField("active_east_west_service_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityConfigType_EastWestServicePolicyAllowAll:
		if fv, exists := v.FldValidators["east_west_service_policy_choice.east_west_service_policy_allow_all"]; exists {
			val := m.GetEastWestServicePolicyChoice().(*SecurityConfigType_EastWestServicePolicyAllowAll).EastWestServicePolicyAllowAll
			vOpts := append(opts,
				db.WithValidateField("east_west_service_policy_choice"),
				db.WithValidateField("east_west_service_policy_allow_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["forward_proxy_choice"]; exists {
		val := m.GetForwardProxyChoice()
		vOpts := append(opts,
			db.WithValidateField("forward_proxy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetForwardProxyChoice().(type) {
	case *SecurityConfigType_NoForwardProxy:
		if fv, exists := v.FldValidators["forward_proxy_choice.no_forward_proxy"]; exists {
			val := m.GetForwardProxyChoice().(*SecurityConfigType_NoForwardProxy).NoForwardProxy
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("no_forward_proxy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityConfigType_ActiveForwardProxyPolicies:
		if fv, exists := v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"]; exists {
			val := m.GetForwardProxyChoice().(*SecurityConfigType_ActiveForwardProxyPolicies).ActiveForwardProxyPolicies
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("active_forward_proxy_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityConfigType_ForwardProxyAllowAll:
		if fv, exists := v.FldValidators["forward_proxy_choice.forward_proxy_allow_all"]; exists {
			val := m.GetForwardProxyChoice().(*SecurityConfigType_ForwardProxyAllowAll).ForwardProxyAllowAll
			vOpts := append(opts,
				db.WithValidateField("forward_proxy_choice"),
				db.WithValidateField("forward_proxy_allow_all"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_policy_choice"]; exists {
		val := m.GetNetworkPolicyChoice()
		vOpts := append(opts,
			db.WithValidateField("network_policy_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkPolicyChoice().(type) {
	case *SecurityConfigType_NoNetworkPolicy:
		if fv, exists := v.FldValidators["network_policy_choice.no_network_policy"]; exists {
			val := m.GetNetworkPolicyChoice().(*SecurityConfigType_NoNetworkPolicy).NoNetworkPolicy
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("no_network_policy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SecurityConfigType_ActiveNetworkPolicies:
		if fv, exists := v.FldValidators["network_policy_choice.active_network_policies"]; exists {
			val := m.GetNetworkPolicyChoice().(*SecurityConfigType_ActiveNetworkPolicies).ActiveNetworkPolicies
			vOpts := append(opts,
				db.WithValidateField("network_policy_choice"),
				db.WithValidateField("active_network_policies"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityConfigTypeValidator = func() *ValidateSecurityConfigType {
	v := &ValidateSecurityConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEastWestServicePolicyChoice := v.EastWestServicePolicyChoiceValidationRuleHandler
	rulesEastWestServicePolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEastWestServicePolicyChoice(rulesEastWestServicePolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityConfigType.east_west_service_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["east_west_service_policy_choice"] = vFn

	vrhForwardProxyChoice := v.ForwardProxyChoiceValidationRuleHandler
	rulesForwardProxyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhForwardProxyChoice(rulesForwardProxyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityConfigType.forward_proxy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["forward_proxy_choice"] = vFn

	vrhNetworkPolicyChoice := v.NetworkPolicyChoiceValidationRuleHandler
	rulesNetworkPolicyChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkPolicyChoice(rulesNetworkPolicyChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityConfigType.network_policy_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_policy_choice"] = vFn

	v.FldValidators["east_west_service_policy_choice.active_east_west_service_policies"] = ActiveServicePoliciesTypeValidator().Validate

	v.FldValidators["forward_proxy_choice.active_forward_proxy_policies"] = ves_io_schema_network_firewall.ActiveForwardProxyPoliciesTypeValidator().Validate

	v.FldValidators["network_policy_choice.active_network_policies"] = ves_io_schema_network_firewall.ActiveNetworkPoliciesTypeValidator().Validate

	return v
}()

func SecurityConfigTypeValidator() db.Validator {
	return DefaultSecurityConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServicesVPCReplaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServicesVPCReplaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServicesVPCReplaceType) DeepCopy() *ServicesVPCReplaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServicesVPCReplaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServicesVPCReplaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServicesVPCReplaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServicesVPCReplaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateServicesVPCReplaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServicesVPCReplaceType) WorkerNodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for worker_nodes")
	}
	return validatorFn, nil
}

func (v *ValidateServicesVPCReplaceType) WorkerNodesNodesPerAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NodesPerAz, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nodes_per_az")
	}
	return oValidatorFn_NodesPerAz, nil
}
func (v *ValidateServicesVPCReplaceType) WorkerNodesTotalNodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_TotalNodes, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for total_nodes")
	}
	return oValidatorFn_TotalNodes, nil
}

func (v *ValidateServicesVPCReplaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServicesVPCReplaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServicesVPCReplaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["worker_nodes"]; exists {
		val := m.GetWorkerNodes()
		vOpts := append(opts,
			db.WithValidateField("worker_nodes"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWorkerNodes().(type) {
	case *ServicesVPCReplaceType_NodesPerAz:
		if fv, exists := v.FldValidators["worker_nodes.nodes_per_az"]; exists {
			val := m.GetWorkerNodes().(*ServicesVPCReplaceType_NodesPerAz).NodesPerAz
			vOpts := append(opts,
				db.WithValidateField("worker_nodes"),
				db.WithValidateField("nodes_per_az"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCReplaceType_TotalNodes:
		if fv, exists := v.FldValidators["worker_nodes.total_nodes"]; exists {
			val := m.GetWorkerNodes().(*ServicesVPCReplaceType_TotalNodes).TotalNodes
			vOpts := append(opts,
				db.WithValidateField("worker_nodes"),
				db.WithValidateField("total_nodes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCReplaceType_NoWorkerNodes:
		if fv, exists := v.FldValidators["worker_nodes.no_worker_nodes"]; exists {
			val := m.GetWorkerNodes().(*ServicesVPCReplaceType_NoWorkerNodes).NoWorkerNodes
			vOpts := append(opts,
				db.WithValidateField("worker_nodes"),
				db.WithValidateField("no_worker_nodes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServicesVPCReplaceTypeValidator = func() *ValidateServicesVPCReplaceType {
	v := &ValidateServicesVPCReplaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhWorkerNodes := v.WorkerNodesValidationRuleHandler
	rulesWorkerNodes := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWorkerNodes(rulesWorkerNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCReplaceType.worker_nodes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["worker_nodes"] = vFn

	vrhWorkerNodesNodesPerAz := v.WorkerNodesNodesPerAzValidationRuleHandler
	rulesWorkerNodesNodesPerAz := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "21",
	}
	vFnMap["worker_nodes.nodes_per_az"], err = vrhWorkerNodesNodesPerAz(rulesWorkerNodesNodesPerAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServicesVPCReplaceType.worker_nodes_nodes_per_az: %s", err)
		panic(errMsg)
	}
	vrhWorkerNodesTotalNodes := v.WorkerNodesTotalNodesValidationRuleHandler
	rulesWorkerNodesTotalNodes := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "61",
	}
	vFnMap["worker_nodes.total_nodes"], err = vrhWorkerNodesTotalNodes(rulesWorkerNodesTotalNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServicesVPCReplaceType.worker_nodes_total_nodes: %s", err)
		panic(errMsg)
	}

	v.FldValidators["worker_nodes.nodes_per_az"] = vFnMap["worker_nodes.nodes_per_az"]
	v.FldValidators["worker_nodes.total_nodes"] = vFnMap["worker_nodes.total_nodes"]

	return v
}()

func ServicesVPCReplaceTypeValidator() db.Validator {
	return DefaultServicesVPCReplaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ServicesVPCType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServicesVPCType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServicesVPCType) DeepCopy() *ServicesVPCType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServicesVPCType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServicesVPCType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServicesVPCType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServicesVPCTypeValidator().Validate(ctx, m, opts...)
}

func (m *ServicesVPCType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetDeploymentDRefInfo()

}

func (m *ServicesVPCType) GetDeploymentDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetDeployment().(type) {
	case *ServicesVPCType_AwsCred:

		vref := m.GetAwsCred()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("cloud_credentials.Object")
		dri := db.DRefInfo{
			RefdType:   "cloud_credentials.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "aws_cred",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *ServicesVPCType_Assisted:

		return nil, nil

	default:
		return nil, nil
	}
}

// GetDeploymentDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *ServicesVPCType) GetDeploymentDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetDeployment().(type) {
	case *ServicesVPCType_AwsCred:
		refdType, err := d.TypeForEntryKind("", "", "cloud_credentials.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: cloud_credentials")
		}

		vref := m.GetAwsCred()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "cloud_credentials.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *ServicesVPCType_Assisted:

	}

	return entries, nil
}

type ValidateServicesVPCType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServicesVPCType) DeploymentValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for deployment")
	}
	return validatorFn, nil
}

func (v *ValidateServicesVPCType) ServiceVpcChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for service_vpc_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServicesVPCType) ServiceVpcChoiceVpcIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VpcId, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vpc_id")
	}
	return oValidatorFn_VpcId, nil
}

func (v *ValidateServicesVPCType) TgwChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_choice")
	}
	return validatorFn, nil
}

func (v *ValidateServicesVPCType) WorkerNodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for worker_nodes")
	}
	return validatorFn, nil
}

func (v *ValidateServicesVPCType) WorkerNodesNodesPerAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NodesPerAz, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nodes_per_az")
	}
	return oValidatorFn_NodesPerAz, nil
}
func (v *ValidateServicesVPCType) WorkerNodesTotalNodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_TotalNodes, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for total_nodes")
	}
	return oValidatorFn_TotalNodes, nil
}

func (v *ValidateServicesVPCType) AwsRegionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_region")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) AwsCertifiedHwValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for aws_certified_hw")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) InstanceTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for instance_type")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) SshKeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ssh_key")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) AzNodesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema_views.AWSVPCTwoInterfaceNodeType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema_views.AWSVPCTwoInterfaceNodeTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for az_nodes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema_views.AWSVPCTwoInterfaceNodeType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema_views.AWSVPCTwoInterfaceNodeType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated az_nodes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items az_nodes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) DiskSizeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disk_size")
	}

	return validatorFn, nil
}

func (v *ValidateServicesVPCType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServicesVPCType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServicesVPCType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aws_certified_hw"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_certified_hw"))
		if err := fv(ctx, m.GetAwsCertifiedHw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["aws_region"]; exists {

		vOpts := append(opts, db.WithValidateField("aws_region"))
		if err := fv(ctx, m.GetAwsRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["az_nodes"]; exists {
		vOpts := append(opts, db.WithValidateField("az_nodes"))
		if err := fv(ctx, m.GetAzNodes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment"]; exists {
		val := m.GetDeployment()
		vOpts := append(opts,
			db.WithValidateField("deployment"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDeployment().(type) {
	case *ServicesVPCType_AwsCred:
		if fv, exists := v.FldValidators["deployment.aws_cred"]; exists {
			val := m.GetDeployment().(*ServicesVPCType_AwsCred).AwsCred
			vOpts := append(opts,
				db.WithValidateField("deployment"),
				db.WithValidateField("aws_cred"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCType_Assisted:
		if fv, exists := v.FldValidators["deployment.assisted"]; exists {
			val := m.GetDeployment().(*ServicesVPCType_Assisted).Assisted
			vOpts := append(opts,
				db.WithValidateField("deployment"),
				db.WithValidateField("assisted"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["disk_size"]; exists {

		vOpts := append(opts, db.WithValidateField("disk_size"))
		if err := fv(ctx, m.GetDiskSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["instance_type"]; exists {

		vOpts := append(opts, db.WithValidateField("instance_type"))
		if err := fv(ctx, m.GetInstanceType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["service_vpc_choice"]; exists {
		val := m.GetServiceVpcChoice()
		vOpts := append(opts,
			db.WithValidateField("service_vpc_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetServiceVpcChoice().(type) {
	case *ServicesVPCType_NewVpc:
		if fv, exists := v.FldValidators["service_vpc_choice.new_vpc"]; exists {
			val := m.GetServiceVpcChoice().(*ServicesVPCType_NewVpc).NewVpc
			vOpts := append(opts,
				db.WithValidateField("service_vpc_choice"),
				db.WithValidateField("new_vpc"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCType_VpcId:
		if fv, exists := v.FldValidators["service_vpc_choice.vpc_id"]; exists {
			val := m.GetServiceVpcChoice().(*ServicesVPCType_VpcId).VpcId
			vOpts := append(opts,
				db.WithValidateField("service_vpc_choice"),
				db.WithValidateField("vpc_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ssh_key"]; exists {

		vOpts := append(opts, db.WithValidateField("ssh_key"))
		if err := fv(ctx, m.GetSshKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tgw_choice"]; exists {
		val := m.GetTgwChoice()
		vOpts := append(opts,
			db.WithValidateField("tgw_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetTgwChoice().(type) {
	case *ServicesVPCType_NewTgw:
		if fv, exists := v.FldValidators["tgw_choice.new_tgw"]; exists {
			val := m.GetTgwChoice().(*ServicesVPCType_NewTgw).NewTgw
			vOpts := append(opts,
				db.WithValidateField("tgw_choice"),
				db.WithValidateField("new_tgw"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCType_ExistingTgw:
		if fv, exists := v.FldValidators["tgw_choice.existing_tgw"]; exists {
			val := m.GetTgwChoice().(*ServicesVPCType_ExistingTgw).ExistingTgw
			vOpts := append(opts,
				db.WithValidateField("tgw_choice"),
				db.WithValidateField("existing_tgw"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["worker_nodes"]; exists {
		val := m.GetWorkerNodes()
		vOpts := append(opts,
			db.WithValidateField("worker_nodes"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetWorkerNodes().(type) {
	case *ServicesVPCType_NodesPerAz:
		if fv, exists := v.FldValidators["worker_nodes.nodes_per_az"]; exists {
			val := m.GetWorkerNodes().(*ServicesVPCType_NodesPerAz).NodesPerAz
			vOpts := append(opts,
				db.WithValidateField("worker_nodes"),
				db.WithValidateField("nodes_per_az"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCType_TotalNodes:
		if fv, exists := v.FldValidators["worker_nodes.total_nodes"]; exists {
			val := m.GetWorkerNodes().(*ServicesVPCType_TotalNodes).TotalNodes
			vOpts := append(opts,
				db.WithValidateField("worker_nodes"),
				db.WithValidateField("total_nodes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ServicesVPCType_NoWorkerNodes:
		if fv, exists := v.FldValidators["worker_nodes.no_worker_nodes"]; exists {
			val := m.GetWorkerNodes().(*ServicesVPCType_NoWorkerNodes).NoWorkerNodes
			vOpts := append(opts,
				db.WithValidateField("worker_nodes"),
				db.WithValidateField("no_worker_nodes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServicesVPCTypeValidator = func() *ValidateServicesVPCType {
	v := &ValidateServicesVPCType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDeployment := v.DeploymentValidationRuleHandler
	rulesDeployment := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDeployment(rulesDeployment)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.deployment: %s", err)
		panic(errMsg)
	}
	v.FldValidators["deployment"] = vFn

	vrhServiceVpcChoice := v.ServiceVpcChoiceValidationRuleHandler
	rulesServiceVpcChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhServiceVpcChoice(rulesServiceVpcChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.service_vpc_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["service_vpc_choice"] = vFn

	vrhServiceVpcChoiceVpcId := v.ServiceVpcChoiceVpcIdValidationRuleHandler
	rulesServiceVpcChoiceVpcId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(vpc-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFnMap["service_vpc_choice.vpc_id"], err = vrhServiceVpcChoiceVpcId(rulesServiceVpcChoiceVpcId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServicesVPCType.service_vpc_choice_vpc_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["service_vpc_choice.vpc_id"] = vFnMap["service_vpc_choice.vpc_id"]

	vrhTgwChoice := v.TgwChoiceValidationRuleHandler
	rulesTgwChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhTgwChoice(rulesTgwChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.tgw_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_choice"] = vFn

	vrhWorkerNodes := v.WorkerNodesValidationRuleHandler
	rulesWorkerNodes := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhWorkerNodes(rulesWorkerNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.worker_nodes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["worker_nodes"] = vFn

	vrhWorkerNodesNodesPerAz := v.WorkerNodesNodesPerAzValidationRuleHandler
	rulesWorkerNodesNodesPerAz := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "21",
	}
	vFnMap["worker_nodes.nodes_per_az"], err = vrhWorkerNodesNodesPerAz(rulesWorkerNodesNodesPerAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServicesVPCType.worker_nodes_nodes_per_az: %s", err)
		panic(errMsg)
	}
	vrhWorkerNodesTotalNodes := v.WorkerNodesTotalNodesValidationRuleHandler
	rulesWorkerNodesTotalNodes := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "61",
	}
	vFnMap["worker_nodes.total_nodes"], err = vrhWorkerNodesTotalNodes(rulesWorkerNodesTotalNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ServicesVPCType.worker_nodes_total_nodes: %s", err)
		panic(errMsg)
	}

	v.FldValidators["worker_nodes.nodes_per_az"] = vFnMap["worker_nodes.nodes_per_az"]
	v.FldValidators["worker_nodes.total_nodes"] = vFnMap["worker_nodes.total_nodes"]

	vrhAwsRegion := v.AwsRegionValidationRuleHandler
	rulesAwsRegion := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"af-south-1\",\"ap-east-1\",\"ap-northeast-1\",\"ap-northeast-2\",\"ap-south-1\",\"ap-southeast-1\",\"ap-southeast-2\",\"ap-southeast-3\",\"ca-central-1\",\"eu-central-1\",\"eu-north-1\",\"eu-south-1\",\"eu-west-1\",\"eu-west-2\",\"eu-west-3\",\"me-south-1\",\"sa-east-1\",\"us-east-1\",\"us-east-2\",\"us-west-1\",\"us-west-2\"]",
	}
	vFn, err = vrhAwsRegion(rulesAwsRegion)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.aws_region: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_region"] = vFn

	vrhAwsCertifiedHw := v.AwsCertifiedHwValidationRuleHandler
	rulesAwsCertifiedHw := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.in":        "[\"aws-byol-multi-nic-voltmesh\"]",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhAwsCertifiedHw(rulesAwsCertifiedHw)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.aws_certified_hw: %s", err)
		panic(errMsg)
	}
	v.FldValidators["aws_certified_hw"] = vFn

	vrhInstanceType := v.InstanceTypeValidationRuleHandler
	rulesInstanceType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
	}
	vFn, err = vrhInstanceType(rulesInstanceType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.instance_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["instance_type"] = vFn

	vrhSshKey := v.SshKeyValidationRuleHandler
	rulesSshKey := map[string]string{
		"ves.io.schema.rules.string.max_len": "8192",
	}
	vFn, err = vrhSshKey(rulesSshKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.ssh_key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ssh_key"] = vFn

	vrhAzNodes := v.AzNodesValidationRuleHandler
	rulesAzNodes := map[string]string{
		"ves.io.schema.rules.repeated.num_items": "0,1,3",
	}
	vFn, err = vrhAzNodes(rulesAzNodes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.az_nodes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["az_nodes"] = vFn

	vrhDiskSize := v.DiskSizeValidationRuleHandler
	rulesDiskSize := map[string]string{
		"ves.io.schema.rules.uint32.lte": "64000",
	}
	vFn, err = vrhDiskSize(rulesDiskSize)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ServicesVPCType.disk_size: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disk_size"] = vFn

	v.FldValidators["deployment.aws_cred"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["service_vpc_choice.new_vpc"] = ves_io_schema_views.AWSVPCParamsTypeValidator().Validate

	v.FldValidators["tgw_choice.new_tgw"] = TGWParamsTypeValidator().Validate
	v.FldValidators["tgw_choice.existing_tgw"] = ExistingTGWTypeValidator().Validate

	return v
}()

func ServicesVPCTypeValidator() db.Validator {
	return DefaultServicesVPCTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TGWAssignedASNType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TGWAssignedASNType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TGWAssignedASNType) DeepCopy() *TGWAssignedASNType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TGWAssignedASNType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TGWAssignedASNType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TGWAssignedASNType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TGWAssignedASNTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTGWAssignedASNType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTGWAssignedASNType) TgwAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tgw_asn")
	}

	return validatorFn, nil
}

func (v *ValidateTGWAssignedASNType) VolterraSiteAsnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for volterra_site_asn")
	}

	return validatorFn, nil
}

func (v *ValidateTGWAssignedASNType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TGWAssignedASNType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TGWAssignedASNType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tgw_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("tgw_asn"))
		if err := fv(ctx, m.GetTgwAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_site_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_site_asn"))
		if err := fv(ctx, m.GetVolterraSiteAsn(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTGWAssignedASNTypeValidator = func() *ValidateTGWAssignedASNType {
	v := &ValidateTGWAssignedASNType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTgwAsn := v.TgwAsnValidationRuleHandler
	rulesTgwAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt":  "64512",
		"ves.io.schema.rules.uint32.lte": "65534",
	}
	vFn, err = vrhTgwAsn(rulesTgwAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TGWAssignedASNType.tgw_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tgw_asn"] = vFn

	vrhVolterraSiteAsn := v.VolterraSiteAsnValidationRuleHandler
	rulesVolterraSiteAsn := map[string]string{
		"ves.io.schema.rules.uint32.gt":  "0",
		"ves.io.schema.rules.uint32.lte": "65535",
	}
	vFn, err = vrhVolterraSiteAsn(rulesVolterraSiteAsn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TGWAssignedASNType.volterra_site_asn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volterra_site_asn"] = vFn

	return v
}()

func TGWAssignedASNTypeValidator() db.Validator {
	return DefaultTGWAssignedASNTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TGWParamsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TGWParamsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TGWParamsType) DeepCopy() *TGWParamsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TGWParamsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TGWParamsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TGWParamsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TGWParamsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateTGWParamsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTGWParamsType) AsnChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for asn_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTGWParamsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TGWParamsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TGWParamsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asn_choice"]; exists {
		val := m.GetAsnChoice()
		vOpts := append(opts,
			db.WithValidateField("asn_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAsnChoice().(type) {
	case *TGWParamsType_SystemGenerated:
		if fv, exists := v.FldValidators["asn_choice.system_generated"]; exists {
			val := m.GetAsnChoice().(*TGWParamsType_SystemGenerated).SystemGenerated
			vOpts := append(opts,
				db.WithValidateField("asn_choice"),
				db.WithValidateField("system_generated"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TGWParamsType_UserAssigned:
		if fv, exists := v.FldValidators["asn_choice.user_assigned"]; exists {
			val := m.GetAsnChoice().(*TGWParamsType_UserAssigned).UserAssigned
			vOpts := append(opts,
				db.WithValidateField("asn_choice"),
				db.WithValidateField("user_assigned"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTGWParamsTypeValidator = func() *ValidateTGWParamsType {
	v := &ValidateTGWParamsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAsnChoice := v.AsnChoiceValidationRuleHandler
	rulesAsnChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAsnChoice(rulesAsnChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TGWParamsType.asn_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["asn_choice"] = vFn

	v.FldValidators["asn_choice.user_assigned"] = TGWAssignedASNTypeValidator().Validate

	return v
}()

func TGWParamsTypeValidator() db.Validator {
	return DefaultTGWParamsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VPCAttachmentListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VPCAttachmentListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VPCAttachmentListType) DeepCopy() *VPCAttachmentListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VPCAttachmentListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VPCAttachmentListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VPCAttachmentListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VPCAttachmentListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVPCAttachmentListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVPCAttachmentListType) VpcListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*VPCAttachmentType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := VPCAttachmentTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vpc_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*VPCAttachmentType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*VPCAttachmentType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vpc_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vpc_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVPCAttachmentListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VPCAttachmentListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VPCAttachmentListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["vpc_list"]; exists {
		vOpts := append(opts, db.WithValidateField("vpc_list"))
		if err := fv(ctx, m.GetVpcList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVPCAttachmentListTypeValidator = func() *ValidateVPCAttachmentListType {
	v := &ValidateVPCAttachmentListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVpcList := v.VpcListValidationRuleHandler
	rulesVpcList := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "128",
	}
	vFn, err = vrhVpcList(rulesVpcList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VPCAttachmentListType.vpc_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vpc_list"] = vFn

	return v
}()

func VPCAttachmentListTypeValidator() db.Validator {
	return DefaultVPCAttachmentListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VPCAttachmentType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VPCAttachmentType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VPCAttachmentType) DeepCopy() *VPCAttachmentType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VPCAttachmentType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VPCAttachmentType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VPCAttachmentType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VPCAttachmentTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVPCAttachmentType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVPCAttachmentType) VpcIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vpc_id")
	}

	return validatorFn, nil
}

func (v *ValidateVPCAttachmentType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VPCAttachmentType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VPCAttachmentType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vpc_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vpc_id"))
		if err := fv(ctx, m.GetVpcId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVPCAttachmentTypeValidator = func() *ValidateVPCAttachmentType {
	v := &ValidateVPCAttachmentType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVpcId := v.VpcIdValidationRuleHandler
	rulesVpcId := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.pattern": "^(vpc-)([a-z0-9]{8}|[a-z0-9]{17})$",
	}
	vFn, err = vrhVpcId(rulesVpcId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VPCAttachmentType.vpc_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vpc_id"] = vFn

	return v
}()

func VPCAttachmentTypeValidator() db.Validator {
	return DefaultVPCAttachmentTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VPCIpPrefixesType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VPCIpPrefixesType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VPCIpPrefixesType) DeepCopy() *VPCIpPrefixesType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VPCIpPrefixesType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VPCIpPrefixesType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VPCIpPrefixesType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VPCIpPrefixesTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVPCIpPrefixesType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVPCIpPrefixesType) PrefixesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for prefixes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for prefixes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated prefixes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items prefixes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVPCIpPrefixesType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VPCIpPrefixesType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VPCIpPrefixesType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["prefixes"]; exists {
		vOpts := append(opts, db.WithValidateField("prefixes"))
		if err := fv(ctx, m.GetPrefixes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVPCIpPrefixesTypeValidator = func() *ValidateVPCIpPrefixesType {
	v := &ValidateVPCIpPrefixesType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrefixes := v.PrefixesValidationRuleHandler
	rulesPrefixes := map[string]string{
		"ves.io.schema.rules.message.required":                  "true",
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
		"ves.io.schema.rules.repeated.max_items":                "1024",
		"ves.io.schema.rules.repeated.min_items":                "1",
		"ves.io.schema.rules.repeated.unique":                   "true",
	}
	vFn, err = vrhPrefixes(rulesPrefixes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VPCIpPrefixesType.prefixes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["prefixes"] = vFn

	return v
}()

func VPCIpPrefixesTypeValidator() db.Validator {
	return DefaultVPCIpPrefixesTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VnConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VnConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

// Redact squashes sensitive info in m (in-place)
func (m *VnConfiguration) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	if err := m.GetGlobalNetworkList().Redact(ctx); err != nil {
		return errors.Wrapf(err, "Redacting VnConfiguration.global_network_list")
	}

	return nil
}

func (m *VnConfiguration) DeepCopy() *VnConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VnConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VnConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VnConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VnConfigurationValidator().Validate(ctx, m, opts...)
}

func (m *VnConfiguration) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDcClusterGroupChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDcClusterGroupChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetGlobalNetworkChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetGlobalNetworkChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInsideStaticRouteChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetInsideStaticRouteChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetOutsideStaticRouteChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetOutsideStaticRouteChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *VnConfiguration) GetDcClusterGroupChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetDcClusterGroupChoice().(type) {
	case *VnConfiguration_NoDcClusterGroup:

		return nil, nil

	case *VnConfiguration_DcClusterGroupOutsideVn:

		vref := m.GetDcClusterGroupOutsideVn()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_outside_vn",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *VnConfiguration_DcClusterGroupInsideVn:

		vref := m.GetDcClusterGroupInsideVn()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("dc_cluster_group.Object")
		dri := db.DRefInfo{
			RefdType:   "dc_cluster_group.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "dc_cluster_group_inside_vn",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetDcClusterGroupChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *VnConfiguration) GetDcClusterGroupChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetDcClusterGroupChoice().(type) {
	case *VnConfiguration_NoDcClusterGroup:

	case *VnConfiguration_DcClusterGroupOutsideVn:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupOutsideVn()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *VnConfiguration_DcClusterGroupInsideVn:
		refdType, err := d.TypeForEntryKind("", "", "dc_cluster_group.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: dc_cluster_group")
		}

		vref := m.GetDcClusterGroupInsideVn()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "dc_cluster_group.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *VnConfiguration) GetGlobalNetworkChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetGlobalNetworkChoice() == nil {
		return nil, nil
	}
	switch m.GetGlobalNetworkChoice().(type) {
	case *VnConfiguration_NoGlobalNetwork:

		return nil, nil

	case *VnConfiguration_GlobalNetworkList:
		drInfos, err := m.GetGlobalNetworkList().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetGlobalNetworkList().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "global_network_list." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *VnConfiguration) GetInsideStaticRouteChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetInsideStaticRouteChoice() == nil {
		return nil, nil
	}
	switch m.GetInsideStaticRouteChoice().(type) {
	case *VnConfiguration_NoInsideStaticRoutes:

		return nil, nil

	case *VnConfiguration_InsideStaticRoutes:
		drInfos, err := m.GetInsideStaticRoutes().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetInsideStaticRoutes().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "inside_static_routes." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *VnConfiguration) GetOutsideStaticRouteChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetOutsideStaticRouteChoice() == nil {
		return nil, nil
	}
	switch m.GetOutsideStaticRouteChoice().(type) {
	case *VnConfiguration_NoOutsideStaticRoutes:

		return nil, nil

	case *VnConfiguration_OutsideStaticRoutes:
		drInfos, err := m.GetOutsideStaticRoutes().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetOutsideStaticRoutes().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "outside_static_routes." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateVnConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVnConfiguration) DcClusterGroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dc_cluster_group_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVnConfiguration) GlobalNetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for global_network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVnConfiguration) InsideStaticRouteChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_static_route_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVnConfiguration) OutsideStaticRouteChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_static_route_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVnConfiguration) SiteMeshGroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_mesh_group_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVnConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VnConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VnConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allowed_vip_port"]; exists {

		vOpts := append(opts, db.WithValidateField("allowed_vip_port"))
		if err := fv(ctx, m.GetAllowedVipPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dc_cluster_group_choice"]; exists {
		val := m.GetDcClusterGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("dc_cluster_group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDcClusterGroupChoice().(type) {
	case *VnConfiguration_NoDcClusterGroup:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.no_dc_cluster_group"]; exists {
			val := m.GetDcClusterGroupChoice().(*VnConfiguration_NoDcClusterGroup).NoDcClusterGroup
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("no_dc_cluster_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VnConfiguration_DcClusterGroupOutsideVn:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group_outside_vn"]; exists {
			val := m.GetDcClusterGroupChoice().(*VnConfiguration_DcClusterGroupOutsideVn).DcClusterGroupOutsideVn
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group_outside_vn"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VnConfiguration_DcClusterGroupInsideVn:
		if fv, exists := v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside_vn"]; exists {
			val := m.GetDcClusterGroupChoice().(*VnConfiguration_DcClusterGroupInsideVn).DcClusterGroupInsideVn
			vOpts := append(opts,
				db.WithValidateField("dc_cluster_group_choice"),
				db.WithValidateField("dc_cluster_group_inside_vn"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["global_network_choice"]; exists {
		val := m.GetGlobalNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("global_network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGlobalNetworkChoice().(type) {
	case *VnConfiguration_NoGlobalNetwork:
		if fv, exists := v.FldValidators["global_network_choice.no_global_network"]; exists {
			val := m.GetGlobalNetworkChoice().(*VnConfiguration_NoGlobalNetwork).NoGlobalNetwork
			vOpts := append(opts,
				db.WithValidateField("global_network_choice"),
				db.WithValidateField("no_global_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VnConfiguration_GlobalNetworkList:
		if fv, exists := v.FldValidators["global_network_choice.global_network_list"]; exists {
			val := m.GetGlobalNetworkChoice().(*VnConfiguration_GlobalNetworkList).GlobalNetworkList
			vOpts := append(opts,
				db.WithValidateField("global_network_choice"),
				db.WithValidateField("global_network_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["inside_static_route_choice"]; exists {
		val := m.GetInsideStaticRouteChoice()
		vOpts := append(opts,
			db.WithValidateField("inside_static_route_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInsideStaticRouteChoice().(type) {
	case *VnConfiguration_NoInsideStaticRoutes:
		if fv, exists := v.FldValidators["inside_static_route_choice.no_inside_static_routes"]; exists {
			val := m.GetInsideStaticRouteChoice().(*VnConfiguration_NoInsideStaticRoutes).NoInsideStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("inside_static_route_choice"),
				db.WithValidateField("no_inside_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VnConfiguration_InsideStaticRoutes:
		if fv, exists := v.FldValidators["inside_static_route_choice.inside_static_routes"]; exists {
			val := m.GetInsideStaticRouteChoice().(*VnConfiguration_InsideStaticRoutes).InsideStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("inside_static_route_choice"),
				db.WithValidateField("inside_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["outside_static_route_choice"]; exists {
		val := m.GetOutsideStaticRouteChoice()
		vOpts := append(opts,
			db.WithValidateField("outside_static_route_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetOutsideStaticRouteChoice().(type) {
	case *VnConfiguration_NoOutsideStaticRoutes:
		if fv, exists := v.FldValidators["outside_static_route_choice.no_outside_static_routes"]; exists {
			val := m.GetOutsideStaticRouteChoice().(*VnConfiguration_NoOutsideStaticRoutes).NoOutsideStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("outside_static_route_choice"),
				db.WithValidateField("no_outside_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VnConfiguration_OutsideStaticRoutes:
		if fv, exists := v.FldValidators["outside_static_route_choice.outside_static_routes"]; exists {
			val := m.GetOutsideStaticRouteChoice().(*VnConfiguration_OutsideStaticRoutes).OutsideStaticRoutes
			vOpts := append(opts,
				db.WithValidateField("outside_static_route_choice"),
				db.WithValidateField("outside_static_routes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["site_mesh_group_choice"]; exists {
		val := m.GetSiteMeshGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("site_mesh_group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSiteMeshGroupChoice().(type) {
	case *VnConfiguration_SmConnectionPublicIp:
		if fv, exists := v.FldValidators["site_mesh_group_choice.sm_connection_public_ip"]; exists {
			val := m.GetSiteMeshGroupChoice().(*VnConfiguration_SmConnectionPublicIp).SmConnectionPublicIp
			vOpts := append(opts,
				db.WithValidateField("site_mesh_group_choice"),
				db.WithValidateField("sm_connection_public_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VnConfiguration_SmConnectionPvtIp:
		if fv, exists := v.FldValidators["site_mesh_group_choice.sm_connection_pvt_ip"]; exists {
			val := m.GetSiteMeshGroupChoice().(*VnConfiguration_SmConnectionPvtIp).SmConnectionPvtIp
			vOpts := append(opts,
				db.WithValidateField("site_mesh_group_choice"),
				db.WithValidateField("sm_connection_pvt_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVnConfigurationValidator = func() *ValidateVnConfiguration {
	v := &ValidateVnConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDcClusterGroupChoice := v.DcClusterGroupChoiceValidationRuleHandler
	rulesDcClusterGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDcClusterGroupChoice(rulesDcClusterGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VnConfiguration.dc_cluster_group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dc_cluster_group_choice"] = vFn

	vrhGlobalNetworkChoice := v.GlobalNetworkChoiceValidationRuleHandler
	rulesGlobalNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhGlobalNetworkChoice(rulesGlobalNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VnConfiguration.global_network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["global_network_choice"] = vFn

	vrhInsideStaticRouteChoice := v.InsideStaticRouteChoiceValidationRuleHandler
	rulesInsideStaticRouteChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInsideStaticRouteChoice(rulesInsideStaticRouteChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VnConfiguration.inside_static_route_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_static_route_choice"] = vFn

	vrhOutsideStaticRouteChoice := v.OutsideStaticRouteChoiceValidationRuleHandler
	rulesOutsideStaticRouteChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhOutsideStaticRouteChoice(rulesOutsideStaticRouteChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VnConfiguration.outside_static_route_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_static_route_choice"] = vFn

	vrhSiteMeshGroupChoice := v.SiteMeshGroupChoiceValidationRuleHandler
	rulesSiteMeshGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSiteMeshGroupChoice(rulesSiteMeshGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VnConfiguration.site_mesh_group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_mesh_group_choice"] = vFn

	v.FldValidators["dc_cluster_group_choice.dc_cluster_group_outside_vn"] = ves_io_schema_views.ObjectRefTypeValidator().Validate
	v.FldValidators["dc_cluster_group_choice.dc_cluster_group_inside_vn"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["global_network_choice.global_network_list"] = ves_io_schema_views.GlobalNetworkConnectionListTypeValidator().Validate

	v.FldValidators["inside_static_route_choice.inside_static_routes"] = ves_io_schema_views.SiteStaticRoutesListTypeValidator().Validate

	v.FldValidators["outside_static_route_choice.outside_static_routes"] = ves_io_schema_views.SiteStaticRoutesListTypeValidator().Validate

	v.FldValidators["allowed_vip_port"] = ves_io_schema_views.AllowedVIPPortsValidator().Validate

	return v
}()

func VnConfigurationValidator() db.Validator {
	return DefaultVnConfigurationValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetBlockedServicesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BlockedServicesChoice.(type) {
	case nil:
		o.BlockedServicesChoice = nil

	case *CreateSpecType_BlockedServices:
		o.BlockedServicesChoice = &GlobalSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	case *CreateSpecType_DefaultBlockedServices:
		o.BlockedServicesChoice = &GlobalSpecType_DefaultBlockedServices{DefaultBlockedServices: of.DefaultBlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetBlockedServicesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BlockedServicesChoice.(type) {
	case nil:
		r.BlockedServicesChoice = nil

	case *GlobalSpecType_BlockedServices:
		r.BlockedServicesChoice = &CreateSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	case *GlobalSpecType_DefaultBlockedServices:
		r.BlockedServicesChoice = &CreateSpecType_DefaultBlockedServices{DefaultBlockedServices: of.DefaultBlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetDirectConnectChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DirectConnectChoice.(type) {
	case nil:
		o.DirectConnectChoice = nil

	case *CreateSpecType_DirectConnectDisabled:
		o.DirectConnectChoice = &GlobalSpecType_DirectConnectDisabled{DirectConnectDisabled: of.DirectConnectDisabled}

	case *CreateSpecType_DirectConnectEnabled:
		o.DirectConnectChoice = &GlobalSpecType_DirectConnectEnabled{DirectConnectEnabled: of.DirectConnectEnabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetDirectConnectChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DirectConnectChoice.(type) {
	case nil:
		r.DirectConnectChoice = nil

	case *GlobalSpecType_DirectConnectDisabled:
		r.DirectConnectChoice = &CreateSpecType_DirectConnectDisabled{DirectConnectDisabled: of.DirectConnectDisabled}

	case *GlobalSpecType_DirectConnectEnabled:
		r.DirectConnectChoice = &CreateSpecType_DirectConnectEnabled{DirectConnectEnabled: of.DirectConnectEnabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetLogsReceiverChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LogsReceiverChoice.(type) {
	case nil:
		o.LogsReceiverChoice = nil

	case *CreateSpecType_LogReceiver:
		o.LogsReceiverChoice = &GlobalSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *CreateSpecType_LogsStreamingDisabled:
		o.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetLogsReceiverChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LogsReceiverChoice.(type) {
	case nil:
		r.LogsReceiverChoice = nil

	case *GlobalSpecType_LogReceiver:
		r.LogsReceiverChoice = &CreateSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GlobalSpecType_LogsStreamingDisabled:
		r.LogsReceiverChoice = &CreateSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.AwsParameters = f.GetAwsParameters()
	m.GetBlockedServicesChoiceFromGlobalSpecType(f)
	m.Coordinates = f.GetCoordinates()
	m.GetDirectConnectChoiceFromGlobalSpecType(f)
	m.LocalControlPlane = f.GetLocalControlPlane()
	m.GetLogsReceiverChoiceFromGlobalSpecType(f)
	m.Os = f.GetOs()
	m.Sw = f.GetSw()
	m.Tags = f.GetTags()
	m.TgwSecurity = f.GetTgwSecurity()
	m.VnConfig = f.GetVnConfig()
	m.VpcAttachments = f.GetVpcAttachments()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Address = m1.Address
	f.AwsParameters = m1.AwsParameters
	m1.SetBlockedServicesChoiceToGlobalSpecType(f)
	f.Coordinates = m1.Coordinates
	m1.SetDirectConnectChoiceToGlobalSpecType(f)
	f.LocalControlPlane = m1.LocalControlPlane
	m1.SetLogsReceiverChoiceToGlobalSpecType(f)
	f.Os = m1.Os
	f.Sw = m1.Sw
	f.Tags = m1.Tags
	f.TgwSecurity = m1.TgwSecurity
	f.VnConfig = m1.VnConfig
	f.VpcAttachments = m1.VpcAttachments
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetBlockedServicesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BlockedServicesChoice.(type) {
	case nil:
		o.BlockedServicesChoice = nil

	case *GetSpecType_BlockedServices:
		o.BlockedServicesChoice = &GlobalSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	case *GetSpecType_DefaultBlockedServices:
		o.BlockedServicesChoice = &GlobalSpecType_DefaultBlockedServices{DefaultBlockedServices: of.DefaultBlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetBlockedServicesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BlockedServicesChoice.(type) {
	case nil:
		r.BlockedServicesChoice = nil

	case *GlobalSpecType_BlockedServices:
		r.BlockedServicesChoice = &GetSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	case *GlobalSpecType_DefaultBlockedServices:
		r.BlockedServicesChoice = &GetSpecType_DefaultBlockedServices{DefaultBlockedServices: of.DefaultBlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDirectConnectChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DirectConnectChoice.(type) {
	case nil:
		o.DirectConnectChoice = nil

	case *GetSpecType_DirectConnectDisabled:
		o.DirectConnectChoice = &GlobalSpecType_DirectConnectDisabled{DirectConnectDisabled: of.DirectConnectDisabled}

	case *GetSpecType_DirectConnectEnabled:
		o.DirectConnectChoice = &GlobalSpecType_DirectConnectEnabled{DirectConnectEnabled: of.DirectConnectEnabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDirectConnectChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DirectConnectChoice.(type) {
	case nil:
		r.DirectConnectChoice = nil

	case *GlobalSpecType_DirectConnectDisabled:
		r.DirectConnectChoice = &GetSpecType_DirectConnectDisabled{DirectConnectDisabled: of.DirectConnectDisabled}

	case *GlobalSpecType_DirectConnectEnabled:
		r.DirectConnectChoice = &GetSpecType_DirectConnectEnabled{DirectConnectEnabled: of.DirectConnectEnabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetLogsReceiverChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LogsReceiverChoice.(type) {
	case nil:
		o.LogsReceiverChoice = nil

	case *GetSpecType_LogReceiver:
		o.LogsReceiverChoice = &GlobalSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GetSpecType_LogsStreamingDisabled:
		o.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetLogsReceiverChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LogsReceiverChoice.(type) {
	case nil:
		r.LogsReceiverChoice = nil

	case *GlobalSpecType_LogReceiver:
		r.LogsReceiverChoice = &GetSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GlobalSpecType_LogsStreamingDisabled:
		r.LogsReceiverChoice = &GetSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.AwsParameters = f.GetAwsParameters()
	m.GetBlockedServicesChoiceFromGlobalSpecType(f)
	m.Coordinates = f.GetCoordinates()
	m.GetDirectConnectChoiceFromGlobalSpecType(f)
	m.DirectConnectInfo = f.GetDirectConnectInfo()
	m.GetLogsReceiverChoiceFromGlobalSpecType(f)
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()

	m.Tags = f.GetTags()
	m.TgwInfo = f.GetTgwInfo()
	m.TgwSecurity = f.GetTgwSecurity()
	m.Tunnels = f.GetTunnels()
	m.UserModificationTimestamp = f.GetUserModificationTimestamp()
	m.VipParamsPerAz = f.GetVipParamsPerAz()
	m.VnConfig = f.GetVnConfig()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
	m.VpcAttachments = f.GetVpcAttachments()
	m.VpcIpPrefixes = f.GetVpcIpPrefixes()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Address = m1.Address
	f.AwsParameters = m1.AwsParameters
	m1.SetBlockedServicesChoiceToGlobalSpecType(f)
	f.Coordinates = m1.Coordinates
	m1.SetDirectConnectChoiceToGlobalSpecType(f)
	f.DirectConnectInfo = m1.DirectConnectInfo
	m1.SetLogsReceiverChoiceToGlobalSpecType(f)
	f.OperatingSystemVersion = m1.OperatingSystemVersion

	f.Tags = m1.Tags
	f.TgwInfo = m1.TgwInfo
	f.TgwSecurity = m1.TgwSecurity
	f.Tunnels = m1.Tunnels
	f.UserModificationTimestamp = m1.UserModificationTimestamp
	f.VipParamsPerAz = m1.VipParamsPerAz
	f.VnConfig = m1.VnConfig
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
	f.VpcAttachments = m1.VpcAttachments
	f.VpcIpPrefixes = m1.VpcIpPrefixes
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetBlockedServicesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BlockedServicesChoice.(type) {
	case nil:
		o.BlockedServicesChoice = nil

	case *ReplaceSpecType_BlockedServices:
		o.BlockedServicesChoice = &GlobalSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	case *ReplaceSpecType_DefaultBlockedServices:
		o.BlockedServicesChoice = &GlobalSpecType_DefaultBlockedServices{DefaultBlockedServices: of.DefaultBlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetBlockedServicesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BlockedServicesChoice.(type) {
	case nil:
		r.BlockedServicesChoice = nil

	case *GlobalSpecType_BlockedServices:
		r.BlockedServicesChoice = &ReplaceSpecType_BlockedServices{BlockedServices: of.BlockedServices}

	case *GlobalSpecType_DefaultBlockedServices:
		r.BlockedServicesChoice = &ReplaceSpecType_DefaultBlockedServices{DefaultBlockedServices: of.DefaultBlockedServices}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetDirectConnectChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DirectConnectChoice.(type) {
	case nil:
		o.DirectConnectChoice = nil

	case *ReplaceSpecType_DirectConnectDisabled:
		o.DirectConnectChoice = &GlobalSpecType_DirectConnectDisabled{DirectConnectDisabled: of.DirectConnectDisabled}

	case *ReplaceSpecType_DirectConnectEnabled:
		o.DirectConnectChoice = &GlobalSpecType_DirectConnectEnabled{DirectConnectEnabled: of.DirectConnectEnabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetDirectConnectChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DirectConnectChoice.(type) {
	case nil:
		r.DirectConnectChoice = nil

	case *GlobalSpecType_DirectConnectDisabled:
		r.DirectConnectChoice = &ReplaceSpecType_DirectConnectDisabled{DirectConnectDisabled: of.DirectConnectDisabled}

	case *GlobalSpecType_DirectConnectEnabled:
		r.DirectConnectChoice = &ReplaceSpecType_DirectConnectEnabled{DirectConnectEnabled: of.DirectConnectEnabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetLogsReceiverChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.LogsReceiverChoice.(type) {
	case nil:
		o.LogsReceiverChoice = nil

	case *ReplaceSpecType_LogReceiver:
		o.LogsReceiverChoice = &GlobalSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *ReplaceSpecType_LogsStreamingDisabled:
		o.LogsReceiverChoice = &GlobalSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetLogsReceiverChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.LogsReceiverChoice.(type) {
	case nil:
		r.LogsReceiverChoice = nil

	case *GlobalSpecType_LogReceiver:
		r.LogsReceiverChoice = &ReplaceSpecType_LogReceiver{LogReceiver: of.LogReceiver}

	case *GlobalSpecType_LogsStreamingDisabled:
		r.LogsReceiverChoice = &ReplaceSpecType_LogsStreamingDisabled{LogsStreamingDisabled: of.LogsStreamingDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()

	if f.GetAwsParameters() != nil {
		if m.AwsParameters == nil {
			m.AwsParameters = &ServicesVPCReplaceType{}
		}
		m.AwsParameters.FromServicesVPCTypeWithoutDeepCopy(f.GetAwsParameters())
	} else {
		m.AwsParameters = nil
	}

	m.GetBlockedServicesChoiceFromGlobalSpecType(f)
	m.Coordinates = f.GetCoordinates()
	m.GetDirectConnectChoiceFromGlobalSpecType(f)
	m.GetLogsReceiverChoiceFromGlobalSpecType(f)
	m.TgwSecurity = f.GetTgwSecurity()
	m.VnConfig = f.GetVnConfig()
	m.VpcAttachments = f.GetVpcAttachments()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Address = m1.Address

	if m1.AwsParameters != nil {
		if f.AwsParameters == nil {
			f.AwsParameters = &ServicesVPCType{}
		}
	} else if f.AwsParameters != nil {
		f.AwsParameters = nil
	}

	if m1.AwsParameters != nil {
		m1.AwsParameters.ToServicesVPCTypeWithoutDeepCopy(f.AwsParameters)
	}

	m1.SetBlockedServicesChoiceToGlobalSpecType(f)
	f.Coordinates = m1.Coordinates
	m1.SetDirectConnectChoiceToGlobalSpecType(f)
	m1.SetLogsReceiverChoiceToGlobalSpecType(f)
	f.TgwSecurity = m1.TgwSecurity
	f.VnConfig = m1.VnConfig
	f.VpcAttachments = m1.VpcAttachments
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ServicesVPCReplaceType from ServicesVPCType for oneof fields
func (r *ServicesVPCReplaceType) SetWorkerNodesToServicesVPCType(o *ServicesVPCType) error {
	switch of := r.WorkerNodes.(type) {
	case nil:
		o.WorkerNodes = nil

	case *ServicesVPCReplaceType_NoWorkerNodes:
		o.WorkerNodes = &ServicesVPCType_NoWorkerNodes{NoWorkerNodes: of.NoWorkerNodes}

	case *ServicesVPCReplaceType_NodesPerAz:
		o.WorkerNodes = &ServicesVPCType_NodesPerAz{NodesPerAz: of.NodesPerAz}

	case *ServicesVPCReplaceType_TotalNodes:
		o.WorkerNodes = &ServicesVPCType_TotalNodes{TotalNodes: of.TotalNodes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ServicesVPCReplaceType) GetWorkerNodesFromServicesVPCType(o *ServicesVPCType) error {
	switch of := o.WorkerNodes.(type) {
	case nil:
		r.WorkerNodes = nil

	case *ServicesVPCType_NoWorkerNodes:
		r.WorkerNodes = &ServicesVPCReplaceType_NoWorkerNodes{NoWorkerNodes: of.NoWorkerNodes}

	case *ServicesVPCType_NodesPerAz:
		r.WorkerNodes = &ServicesVPCReplaceType_NodesPerAz{NodesPerAz: of.NodesPerAz}

	case *ServicesVPCType_TotalNodes:
		r.WorkerNodes = &ServicesVPCReplaceType_TotalNodes{TotalNodes: of.TotalNodes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ServicesVPCReplaceType) fromServicesVPCType(f *ServicesVPCType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetWorkerNodesFromServicesVPCType(f)
}

func (m *ServicesVPCReplaceType) FromServicesVPCType(f *ServicesVPCType) {
	m.fromServicesVPCType(f, true)
}

func (m *ServicesVPCReplaceType) FromServicesVPCTypeWithoutDeepCopy(f *ServicesVPCType) {
	m.fromServicesVPCType(f, false)
}

func (m *ServicesVPCReplaceType) toServicesVPCType(f *ServicesVPCType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetWorkerNodesToServicesVPCType(f)
}

func (m *ServicesVPCReplaceType) ToServicesVPCType(f *ServicesVPCType) {
	m.toServicesVPCType(f, true)
}

func (m *ServicesVPCReplaceType) ToServicesVPCTypeWithoutDeepCopy(f *ServicesVPCType) {
	m.toServicesVPCType(f, false)
}
